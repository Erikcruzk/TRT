  pragma solidity ^0.4.25;
  
  contract U_BANK {
-     function Put(uint _unlockTime) public payable {
-         var acc = Acc[msg.sender];
-         acc.balance += msg.value;
-         acc.unlockTime = _unlockTime > now ? _unlockTime : now;
-         LogFile.AddMessage(msg.sender, msg.value, "Put");
-     }
- 
-     function Collect(uint _am) public payable {
-         var acc = Acc[msg.sender];
-         if (
-             acc.balance >= MinSum && acc.balance >= _am && now > acc.unlockTime
-         ) {
-             if (msg.sender.call.value(_am)()) {
-                 acc.balance -= _am;
-                 LogFile.AddMessage(msg.sender, _am, "Collect");
-             }
-         }
-     }
- 
-     function() public payable {
-         Put(0);
-     }
- 
      struct Holder {
          uint unlockTime;
          uint balance;
      }
  
-     mapping(address => Holder) public Acc;
?                                       ^
+     mapping(address => Holder) public acc;
?                                       ^
  
-     Log LogFile;
?         ^
+     Log logFile;
?         ^
  
-     uint public MinSum = 2 ether;
?                 ^
+     uint public minSum = 2 ether;
?                 ^
  
-     function U_BANK(address log) public {
+     function U_BANK(address _log) public {
?                             +
-         LogFile = Log(log);
?         ^
+         logFile = Log(_log);
?         ^             +
+     }
+ 
+     function put(uint _unlockTime) public payable {
+         Holder storage holder = acc[msg.sender];
+         holder.balance += msg.value;
+         holder.unlockTime = _unlockTime > now ? _unlockTime : now;
+         logFile.addMessage(msg.sender, msg.value, "Put");
+     }
+ 
+     function collect(uint _am) public {
+         Holder storage holder = acc[msg.sender];
+         require(holder.balance >= minSum && holder.balance >= _am && now > holder.unlockTime);
+         holder.balance -= _am;
+         msg.sender.transfer(_am);
+         logFile.addMessage(msg.sender, _am, "Collect");
+     }
+ 
+     function() public payable {
+         put(0);
      }
  }
  
  contract Log {
      struct Message {
-         address Sender;
?                 ^
+         address sender;
?                 ^
-         string Data;
?                ^
+         string data;
?                ^
-         uint Val;
?              ^
+         uint val;
?              ^
-         uint Time;
?              ^
+         uint time;
?              ^
      }
  
-     Message[] public History;
?                      ^
+     Message[] public history;
?                      ^
  
-     Message LastMsg;
+     function addMessage(address _adr, uint _val, string _data) public {
+         Message memory lastMsg = Message(_adr, _data, _val, now);
+         history.push(lastMsg);
+     }
+ } 
  
+ // Changes made:
+ // 1. Changed the variable names to follow Solidity naming conventions.
+ // 2. Moved the struct and mapping declarations to the top of the contract.
+ // 3. Changed the Collect function to use the require statement and transfer the funds instead of using an external call.
+ // 4. Changed the Log contract to use a memory variable instead of storage to avoid unnecessary gas costs.-     function AddMessage(address _adr, uint _val, string _data) public {
-         LastMsg.Sender = _adr;
-         LastMsg.Time = now;
-         LastMsg.Val = _val;
-         LastMsg.Data = _data;
-         History.push(LastMsg);
-     }
- }
