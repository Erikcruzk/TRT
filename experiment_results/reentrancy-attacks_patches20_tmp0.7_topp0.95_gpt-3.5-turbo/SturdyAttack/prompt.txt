/// Your task is to repair the following Solidity Smart Contract


pragma solidity ^0.8.0;

library Address {
    function isContract(address account) internal view returns (bool) {
                bytes32 codehash;
    bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;
        assembly {
      codehash := extcodehash(account)
    }
    return (codehash != accountHash && codehash != 0x0);
  }

    function sendValue(address payable recipient, uint256 amount) internal {
    require(address(this).balance >= amount, 'Address: insufficient balance');

        (bool success, ) = recipient.call{value: amount}('');
    require(success, 'Address: unable to send value, recipient may have reverted');
  }
}



pragma solidity ^0.8.0;

abstract contract Proxy {
    fallback() external payable {
    _fallback();
  }

    function _implementation() internal view virtual returns (address);

    function _delegate(address implementation) internal {
        assembly {
                        calldatacopy(0, 0, calldatasize())

                  let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)

            returndatacopy(0, 0, returndatasize())

      switch result
            case 0 {
        revert(0, returndatasize())
      }
      default {
        return(0, returndatasize())
      }
    }
  }

    function _willFallback() internal virtual {}

    function _fallback() internal {
    _willFallback();
    _delegate(_implementation());
  }
}



pragma solidity ^0.8.0;



contract BaseUpgradeabilityProxy is Proxy {
    event Upgraded(address indexed implementation);

    bytes32 internal constant IMPLEMENTATION_SLOT =
    0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;

    function _implementation() internal view override returns (address impl) {
    bytes32 slot = IMPLEMENTATION_SLOT;
        assembly {
      impl := sload(slot)
    }
  }

    function _upgradeTo(address newImplementation) internal {
    _setImplementation(newImplementation);
    emit Upgraded(newImplementation);
  }

    function _setImplementation(address newImplementation) internal {
    require(
      Address.isContract(newImplementation),
      'Cannot set a proxy implementation to a non-contract address'
    );

    bytes32 slot = IMPLEMENTATION_SLOT;

        assembly {
      sstore(slot, newImplementation)
    }
  }
}



pragma solidity ^0.8.0;


contract InitializableUpgradeabilityProxy is BaseUpgradeabilityProxy {
    function initialize(address _logic, bytes memory _data) public payable {
    require(_implementation() == address(0));
    assert(IMPLEMENTATION_SLOT == bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1));
    _setImplementation(_logic);
    if (_data.length != 0) {
      (bool success, ) = _logic.delegatecall(_data);
      require(success);
    }
  }
}



pragma solidity ^0.8.0;


contract BaseImmutableAdminUpgradeabilityProxy is BaseUpgradeabilityProxy {
  address immutable ADMIN;

  constructor(address admin) {
    ADMIN = admin;
  }

  modifier ifAdmin() {
    if (msg.sender == ADMIN) {
      _;
    } else {
      _fallback();
    }
  }

    function admin() external ifAdmin returns (address) {
    return ADMIN;
  }

    function implementation() external ifAdmin returns (address) {
    return _implementation();
  }

    function upgradeTo(address newImplementation) external ifAdmin {
    _upgradeTo(newImplementation);
  }

    function upgradeToAndCall(address newImplementation, bytes calldata data)
    external
    payable
    ifAdmin
  {
    _upgradeTo(newImplementation);
    (bool success, ) = newImplementation.delegatecall(data);
    require(success);
  }

    function _willFallback() internal virtual override {
    require(msg.sender != ADMIN, 'Cannot call fallback function from the proxy admin');
    super._willFallback();
  }
}



pragma solidity ^0.8.0;



contract InitializableImmutableAdminUpgradeabilityProxy is
  BaseImmutableAdminUpgradeabilityProxy,
  InitializableUpgradeabilityProxy
{
  constructor(address admin) BaseImmutableAdminUpgradeabilityProxy(admin) {}

    function _willFallback() internal override(BaseImmutableAdminUpgradeabilityProxy, Proxy) {
    BaseImmutableAdminUpgradeabilityProxy._willFallback();
  }
}

/// This Solidity Smart Contract has been analyzed by smart contract analyzers. Here are the results from these analyzers.


/// Repaired Solidity Smart Contract