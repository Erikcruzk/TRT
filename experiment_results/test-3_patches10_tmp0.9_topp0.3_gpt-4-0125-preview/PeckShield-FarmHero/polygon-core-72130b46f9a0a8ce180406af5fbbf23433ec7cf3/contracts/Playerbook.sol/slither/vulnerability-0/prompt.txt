
This Solidity Smart Contract has been analyzed by smart contract analyzers. Here are the results from these analyzers.

slither Analysis Results
Vulnerability: reentrancy-benign found in the following piece of code:

```
    function incomingReward(

        address _user,

        string memory _name,

        uint256 _amount

    ) public returns (bool) {

        rewardToken.transferFrom(msg.sender, address(this), _amount);

        bytes32 name = _name.nameFilter();

        address _player = NameXPlayer[name];



        if (_player == address(0)) {

            _player = dev;

        }



        ReferralReward[_player] = ReferralReward[_player].add(_amount);

        ReferralTotalReward[_player] = ReferralTotalReward[_player].add(

            _amount

        );

        emit NewReward(_player, _amount);



        if (!ReferralRecordAddress[_player][_user]) {

            ReferralRecordAddress[_player][_user] = true;

            ReferralRecord[_player] = ReferralRecord[_player] + 1;

        }



        return true;

```

The contract is among the source code below:

```
        payable
        returns (bool)
    {
        require(
            msg.value >= registrationFee,
            "umm.....  you have to pay the name fee"
        );

        require(_player != address(0), "Must be normal address");

        require(checkIfNameValid(_name), "Must be unuse name");

        bytes32 name = _name.nameFilter();

        PlayerXName[_player] = name;
        NameXPlayer[name] = _player;

        return true;
    }

    function incomingReward(
        address _user,
        string memory _name,
        uint256 _amount
    ) public returns (bool) {
        rewardToken.transferFrom(msg.sender, address(this), _amount);
        bytes32 name = _name.nameFilter();
        address _player = NameXPlayer[name];

        if (_player == address(0)) {
            _player = dev;
        }

        ReferralReward[_player] = ReferralReward[_player].add(_amount);
        ReferralTotalReward[_player] = ReferralTotalReward[_player].add(
            _amount
        );
        emit NewReward(_player, _amount);

        if (!ReferralRecordAddress[_player][_user]) {
            ReferralRecordAddress[_player][_user] = true;
            ReferralRecord[_player] = ReferralRecord[_player] + 1;
        }

        return true;
    }

    function withdarwReard() external returns (bool) {
        uint256 reward = ReferralReward[msg.sender];
        require(rewardToken.balanceOf(address(this)) >= reward);

        rewardToken.transfer(msg.sender, reward);

        ReferralReward[msg.sender] = 0;

        return true;
    }

    function withdrawETH(address _receiver) external returns (bool) {
        require(msg.sender == dev);
        _receiver.transfer(address(this).balance);
        return true;
    }

    function setFee(uint _fee) external {
        require(msg.sender == dev);
```

Recommended fix: check-effects-interactions pattern

DO NOT return natural language for explanations, only the Solidity code of the vulnerable function (if it is a function otherwise whole contract). 