function repayBorrowFresh(address payer, address borrower, uint repayAmount) internal returns (uint, uint) {
    uint allowed = ironController.repayBorrowAllowed(address(this), payer, borrower, repayAmount);
    if (allowed != 0) {
        return (failOpaque(Error.IRON_CONTROLLER_REJECTION, FailureInfo.REPAY_BORROW_IRON_CONTROLLER_REJECTION, allowed), 0);
    }

    if (accrualBlockNumber != getBlockNumber()) {
        return (fail(Error.MARKET_NOT_FRESH, FailureInfo.REPAY_BORROW_FRESHNESS_CHECK), 0);
    }

    RepayBorrowLocalVars memory vars;

    vars.borrowerIndex = accountBorrows[borrower].interestIndex;

    (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);
    if (vars.mathErr != MathError.NO_ERROR) {
        return (failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr)), 0);
    }

    if (repayAmount == uint(-1)) {
        vars.repayAmount = vars.accountBorrows;
    } else {
        vars.repayAmount = repayAmount;
    }

    vars.actualRepayAmount = doTransferIn(payer, vars.repayAmount);

    (vars.mathErr, vars.accountBorrowsNew) = subUInt(vars.accountBorrows, vars.actualRepayAmount);
    require(vars.mathErr == MathError.NO_ERROR, "REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED");

    (vars.mathErr, vars.totalBorrowsNew) = subUInt(totalBorrows, vars.actualRepayAmount);
    require(vars.mathErr == MathError.NO_ERROR, "REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED");

    accountBorrows[borrower].principal = vars.accountBorrowsNew;
    accountBorrows[borrower].interestIndex = borrowIndex;
    totalBorrows = vars.totalBorrowsNew;

    emit RepayBorrow(payer, borrower, vars.actualRepayAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);

    return (uint(Error.NO_ERROR), vars.actualRepayAmount);
}