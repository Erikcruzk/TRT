function repayBorrowFresh(address payer, address borrower, uint repayAmount) internal returns (uint, uint) {
    // Ensure that this function is only callable internally to prevent re-entrancy attacks
    uint allowed = ironController.repayBorrowAllowed(address(this), payer, borrower, repayAmount);
    if (allowed != 0) {
        return (failOpaque(Error.IRON_CONTROLLER_REJECTION, FailureInfo.REPAY_BORROW_IRON_CONTROLLER_REJECTION, allowed), 0);
    }

    // Verify market's block number equals current block number for freshness
    if (accrualBlockNumber != getBlockNumber()) {
        return (fail(Error.MARKET_NOT_FRESH, FailureInfo.REPAY_BORROW_FRESHNESS_CHECK), 0);
    }

    RepayBorrowLocalVars memory vars;

    // We fetch the amount the borrower owes, with accumulated interest
    (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);
    if (vars.mathErr != MathError.NO_ERROR) {
        return (failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr)), 0);
    }

    // If repayAmount == -1, repayAmount = accountBorrows
    if (repayAmount == uint(-1)) {
        vars.repayAmount = vars.accountBorrows;
    } else {
        vars.repayAmount = repayAmount;
    }

    // We call doTransferIn for the payer and the repayAmount
    // Note: Transfer should happen before any state changes to prevent re-entrancy
    vars.actualRepayAmount = doTransferIn(payer, vars.repayAmount);

    // We calculate the new borrower and total borrow balances
    (vars.mathErr, vars.accountBorrowsNew) = subUInt(vars.accountBorrows, vars.actualRepayAmount);
    require(vars.mathErr == MathError.NO_ERROR, "REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED");

    (vars.mathErr, vars.totalBorrowsNew) = subUInt(totalBorrows, vars.actualRepayAmount);
    require(vars.mathErr == MathError.NO_ERROR, "REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED");

    // We write the previously calculated values into storage
    accountBorrows[borrower].principal = vars.accountBorrowsNew;
    accountBorrows[borrower].interestIndex = borrowIndex;
    totalBorrows = vars.totalBorrowsNew;

    // Event to emit
    emit RepayBorrow(payer, borrower, vars.actualRepayAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);

    return (uint(Error.NO_ERROR), vars.actualRepayAmount);
}