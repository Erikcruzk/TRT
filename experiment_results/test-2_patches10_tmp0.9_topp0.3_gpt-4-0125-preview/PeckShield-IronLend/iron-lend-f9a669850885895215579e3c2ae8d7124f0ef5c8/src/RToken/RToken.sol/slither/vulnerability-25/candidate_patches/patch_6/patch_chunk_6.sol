function seizeInternal(address seizeRToken, address liquidator, address borrower, uint seizeTokens) internal returns (uint) {
    // Ensure interaction with IronController occurs before state changes
    uint allowed = ironController.seizeAllowed(address(this), seizeRToken, liquidator, borrower, seizeTokens);
    if (allowed != 0) {
        return failOpaque(Error.IRON_CONTROLLER_REJECTION, FailureInfo.LIQUIDATE_SEIZE_IRON_CONTROLLER_REJECTION, allowed);
    }

    // Ensure borrower is not the liquidator to prevent self-liquidation
    if (borrower == liquidator) {
        return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER);
    }

    // Arithmetic operations to calculate the new token balances
    MathError mathErr;
    uint borroweRTokensNew;
    uint liquidatoRTokensNew;

    // Subtract seizeTokens from borrower's balance
    (mathErr, borroweRTokensNew) = subUInt(accountTokens[borrower], seizeTokens);
    if (mathErr != MathError.NO_ERROR) {
        return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED, uint(mathErr));
    }

    // Add seizeTokens to liquidator's balance
    (mathErr, liquidatoRTokensNew) = addUInt(accountTokens[liquidator], seizeTokens);
    if (mathErr != MathError.NO_ERROR) {
        return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED, uint(mathErr));
    }

    // Update the state with the new token balances
    accountTokens[borrower] = borroweRTokensNew;
    accountTokens[liquidator] = liquidatoRTokensNew;

    // Emit a Transfer event to log the action
    emit Transfer(borrower, liquidator, seizeTokens);

    // Return NO_ERROR to indicate success
    return uint(Error.NO_ERROR);
}