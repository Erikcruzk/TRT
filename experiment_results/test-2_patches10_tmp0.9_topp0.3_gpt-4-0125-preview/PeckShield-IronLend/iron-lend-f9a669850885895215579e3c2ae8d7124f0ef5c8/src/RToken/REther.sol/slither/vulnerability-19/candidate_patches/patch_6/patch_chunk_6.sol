function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {
    require(redeemTokensIn == 0 || redeemAmountIn == 0, "one of redeemTokensIn or redeemAmountIn must be zero");

    RedeemLocalVars memory vars;

    vars.err = IronControllerErrorReporter.Error.NO_ERROR;
    vars.exchangeRateMantissa = exchangeRateStored();
    if (vars.exchangeRateMantissa == 0) {
        return fail(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED);
    }

    if (redeemTokensIn > 0) {
        vars.redeemTokens = redeemTokensIn;

        (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);
        if (vars.mathErr != MathError.NO_ERROR) {
            return fail(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED);
        }
    } else {
        (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));
        if (vars.mathErr != MathError.NO_ERROR) {
            return fail(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED);
        }

        vars.redeemAmount = redeemAmountIn;
    }

    vars.totalSupplyNew = totalSupply.sub(vars.redeemTokens);
    vars.accountTokensNew = accountTokens[redeemer].sub(vars.redeemTokens);

    accountTokens[redeemer] = vars.accountTokensNew;
    totalSupply = vars.totalSupplyNew;

    emit Transfer(redeemer, address(this), vars.redeemTokens);
    emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);

    doTransferOut(redeemer, vars.redeemAmount);

    return uint(Error.NO_ERROR);
}