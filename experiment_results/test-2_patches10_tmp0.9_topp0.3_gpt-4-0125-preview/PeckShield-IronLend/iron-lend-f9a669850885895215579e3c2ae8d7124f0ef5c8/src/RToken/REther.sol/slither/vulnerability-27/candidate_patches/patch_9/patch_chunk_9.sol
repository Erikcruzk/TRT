function seizeInternal(address seizeRToken, address liquidator, address borrower, uint seizeTokens) internal returns (uint) {
    IronControllerInterface ironControllerLocal = ironController;
    address ironControllerLocalAddress = address(ironControllerLocal);

    // Checks if the call to seizeAllowed reverts or throws otherwise proceed
    (bool success, bytes memory data) = ironControllerLocalAddress.call(abi.encodeWithSignature("seizeAllowed(address,address,address,address,uint256)", address(this), seizeRToken, liquidator, borrower, seizeTokens));
    require(success);

    uint allowed = abi.decode(data, (uint));
    if (allowed != 0) {
        return failOpaque(Error.IRON_CONTROLLER_REJECTION, FailureInfo.LIQUIDATE_SEIZE_IRON_CONTROLLER_REJECTION, allowed);
    }

    if (borrower == liquidator) {
        return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER);
    }

    MathError mathErr;
    uint borrowerTokensNew;
    uint liquidatorTokensNew;

    (mathErr, borrowerTokensNew) = subUInt(accountTokens[borrower], seizeTokens);
    if (mathErr != MathError.NO_ERROR) {
        return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED, uint(mathErr));
    }

    (mathErr, liquidatorTokensNew) = addUInt(accountTokens[liquidator], seizeTokens);
    if (mathErr != MathError.NO_ERROR) {
        return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED, uint(mathErr));
    }

    accountTokens[borrower] = borrowerTokensNew;
    accountTokens[liquidator] = liquidatorTokensNew;

    emit Transfer(borrower, liquidator, seizeTokens);

    return uint(Error.NO_ERROR);
}