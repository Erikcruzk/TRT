function seizeInternal(address seizeRToken, address liquidator, address borrower, uint seizeTokens) internal returns (uint) {

    /* Fail if seize not allowed */

    uint allowed = ironController.seizeAllowed(address(this), seizeRToken, liquidator, borrower, seizeTokens);

    if (allowed != 0) {

        return failOpaque(Error.IRON_CONTROLLER_REJECTION, FailureInfo.LIQUIDATE_SEIZE_IRON_CONTROLLER_REJECTION, allowed);

    }



    /* Fail if borrower = liquidator */

    if (borrower == liquidator) {

        return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER);

    }



    MathError mathErr;

    uint borroweRTokensNew;

    uint liquidatoRTokensNew;



    /*

     * We calculate the new borrower and liquidator token balances, failing on underflow/overflow:

     *  borroweRTokensNew = accountTokens[borrower] - seizeTokens

     *  liquidatoRTokensNew = accountTokens[liquidator] + seizeTokens

     */

    (mathErr, borroweRTokensNew) = subUInt(accountTokens[borrower], seizeTokens);

    if (mathErr != MathError.NO_ERROR) {

        return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED, uint(mathErr));

    }



    (mathErr, liquidatoRTokensNew) = addUInt(accountTokens[liquidator], seizeTokens);

    if (mathErr != MathError.NO_ERROR) {

        return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED, uint(mathErr));

    }



    /////////////////////////

    // EFFECTS & INTERACTIONS

    // (No safe failures beyond this point)



    /* We block reentrancy by updating state before external calls */

    accountTokens[borrower] = borroweRTokensNew;

    accountTokens[liquidator] = liquidatoRTokensNew;



    /* Emit a Transfer event */

    emit Transfer(borrower, liquidator, seizeTokens);



    /* We call the defense hook */

    // unused function

    // ironController.seizeVerify(address(this), seizeRToken, liquidator, borrower, seizeTokens);



    return uint(Error.NO_ERROR);

}