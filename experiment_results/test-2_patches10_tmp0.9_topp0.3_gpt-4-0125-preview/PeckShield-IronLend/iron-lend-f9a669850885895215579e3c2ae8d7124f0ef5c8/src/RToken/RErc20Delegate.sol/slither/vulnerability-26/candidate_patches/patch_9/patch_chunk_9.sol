function seizeInternal(address seizeRToken, address liquidator, address borrower, uint seizeTokens) internal returns (uint) {
        if (borrower == liquidator) {
            return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER);
        }

        MathError mathErr;
        uint borrowerTokensNew;
        uint liquidatorTokensNew;

        (mathErr, borrowerTokensNew) = subUInt(accountTokens[borrower], seizeTokens);
        if (mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED, uint(mathErr));
        }

        (mathErr, liquidatorTokensNew) = addUInt(accountTokens[liquidator], seizeTokens);
        if (mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED, uint(mathErr));
        }

        // Ensure that the seize operation does not result in reentrancy vulnerability
        accountTokens[borrower] = borrowerTokensNew;
        accountTokens[liquidator] = liquidatorTokensNew;

        emit Transfer(borrower, liquidator, seizeTokens);

        uint allowed = ironController.seizeAllowed(address(this), seizeRToken, liquidator, borrower, seizeTokens);
        if (allowed != 0) {
            return failOpaque(Error.IRON_CONTROLLER_REJECTION, FailureInfo.LIQUIDATE_SEIZE_IRON_CONTROLLER_REJECTION, allowed);
        }

        return uint(Error.NO_ERROR);
    }