{
  "smartbugs_completed": true,
  "analyzer_results": {
    "oyente": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "Integer Overflow",
          "vulnerability_from_line": 92,
          "vulnerability_to_line": null,
          "vulnerability_code": "        seed[_index] = _value;",
          "message": null
        },
        {
          "name": "Integer Underflow",
          "vulnerability_from_line": 66,
          "vulnerability_to_line": null,
          "vulnerability_code": "        bytes32 hash = keccak256(blockhash(block.number - 1));",
          "message": null
        },
        {
          "name": "Re-Entrancy Vulnerability",
          "vulnerability_from_line": 116,
          "vulnerability_to_line": null,
          "vulnerability_code": "        owner.call.value(1 wei)();",
          "message": null
        },
        {
          "name": "Transaction-Ordering Dependence (TOD)",
          "vulnerability_from_line": null,
          "vulnerability_to_line": null,
          "vulnerability_code": null,
          "message": null
        }
      ]
    },
    "slither": {
      "successfull_analysis": true,
      "errors": [
        "EXIT_CODE_29"
      ],
      "vulnerability_findings": [
        {
          "name": "incorrect-equality",
          "vulnerability_from_line": 65,
          "vulnerability_to_line": 74,
          "vulnerability_code": "    function unlockSecret() private returns (bool) {\n        bytes32 hash = keccak256(blockhash(block.number - 1));\n        uint256 secret = uint256(hash);\n        if (secret % 5 == 0) {\n            winner = msg.sender;\n            return true;\n        } else {\n            return false;\n        }",
          "message": "DrainMe.unlockSecret (0xb620cee6b52f96f3c6b253e6eea556aa2d214a99.sol#65-74) uses a dangerous strict equality:\n\t- secret % 5 == 0\n"
        },
        {
          "name": "shadowing-local",
          "vulnerability_from_line": 67,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint256 secret = uint256(hash);",
          "message": "DrainMe.unlockSecret.secret (local variable @ 0xb620cee6b52f96f3c6b253e6eea556aa2d214a99.sol#67) shadows:\n\t- DrainMe.secret (state variable @ 0xb620cee6b52f96f3c6b253e6eea556aa2d214a99.sol#12)\n"
        },
        {
          "name": "constable-states",
          "vulnerability_from_line": 6,
          "vulnerability_to_line": null,
          "vulnerability_code": "    address public firstTarget = 0x461ec7309F187dd4650EE6b4D25D93c922d7D56b;",
          "message": "DrainMe.firstTarget should be constant (0xb620cee6b52f96f3c6b253e6eea556aa2d214a99.sol#6)\nDrainMe.secondTarget should be constant (0xb620cee6b52f96f3c6b253e6eea556aa2d214a99.sol#7)\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 16,
          "vulnerability_to_line": 18,
          "vulnerability_code": "    function DranMe() public payable {\n        owner = msg.sender;",
          "message": "DrainMe.DranMe (0xb620cee6b52f96f3c6b253e6eea556aa2d214a99.sol#16-18) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 35,
          "vulnerability_to_line": 37,
          "vulnerability_code": "    function getLength() public constant returns (uint256) {\n        return seed.length;",
          "message": "DrainMe.getLength (0xb620cee6b52f96f3c6b253e6eea556aa2d214a99.sol#35-37) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 39,
          "vulnerability_to_line": 41,
          "vulnerability_code": "    function setSecret(uint256 _secret) public payable onlyOwner {\n        secret = _secret;",
          "message": "DrainMe.setSecret (0xb620cee6b52f96f3c6b253e6eea556aa2d214a99.sol#39-41) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 43,
          "vulnerability_to_line": 45,
          "vulnerability_code": "    function getPlayerCount() public constant returns (uint256) {\n        return players.length;",
          "message": "DrainMe.getPlayerCount (0xb620cee6b52f96f3c6b253e6eea556aa2d214a99.sol#43-45) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 47,
          "vulnerability_to_line": 49,
          "vulnerability_code": "    function getPrize() public constant returns (uint256) {\n        return address(this).balance;",
          "message": "DrainMe.getPrize (0xb620cee6b52f96f3c6b253e6eea556aa2d214a99.sol#47-49) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 51,
          "vulnerability_to_line": 55,
          "vulnerability_code": "    function becomePlayer() public payable {\n        require(msg.value >= 0.02 ether);\n        players.push(msg.sender);\n        approvedPlayers[msg.sender] = true;",
          "message": "DrainMe.becomePlayer (0xb620cee6b52f96f3c6b253e6eea556aa2d214a99.sol#51-55) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 57,
          "vulnerability_to_line": 63,
          "vulnerability_code": "    function manipulateSecret() public payable onlyPlayers {\n        require(msg.value >= 0.01 ether);\n        if (msg.sender != owner || unlockSecret()) {\n            uint256 amount = 0;\n            msg.sender.transfer(amount);\n        }",
          "message": "DrainMe.manipulateSecret (0xb620cee6b52f96f3c6b253e6eea556aa2d214a99.sol#57-63) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 76,
          "vulnerability_to_line": 80,
          "vulnerability_code": "    function callFirstTarget() public payable onlyPlayers {\n        require(msg.value >= 0.005 ether);\n\n        firstTarget.call.value(msg.value)();",
          "message": "DrainMe.callFirstTarget (0xb620cee6b52f96f3c6b253e6eea556aa2d214a99.sol#76-80) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 82,
          "vulnerability_to_line": 86,
          "vulnerability_code": "    function callSecondTarget() public payable onlyPlayers {\n        require(msg.value >= 0.005 ether);\n\n        secondTarget.call.value(msg.value)();",
          "message": "DrainMe.callSecondTarget (0xb620cee6b52f96f3c6b253e6eea556aa2d214a99.sol#82-86) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 88,
          "vulnerability_to_line": 93,
          "vulnerability_code": "    function setSeed(\n        uint256 _index,\n        uint256 _value\n    ) public payable onlyPlayers {\n        seed[_index] = _value;",
          "message": "DrainMe.setSeed (0xb620cee6b52f96f3c6b253e6eea556aa2d214a99.sol#88-93) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 95,
          "vulnerability_to_line": 97,
          "vulnerability_code": "    function addSeed(uint256 _add) public payable onlyPlayers {\n        seed.length = _add;",
          "message": "DrainMe.addSeed (0xb620cee6b52f96f3c6b253e6eea556aa2d214a99.sol#95-97) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 99,
          "vulnerability_to_line": 106,
          "vulnerability_code": "    function guessSeed(\n        uint256 _seed\n    ) public payable onlyPlayers returns (uint256) {\n        return (_seed / (seed[0] * seed[1]));\n        if ((_seed / (seed[0] * seed[1])) == secret) {\n            owner = winner;\n        }",
          "message": "DrainMe.guessSeed (0xb620cee6b52f96f3c6b253e6eea556aa2d214a99.sol#99-106) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 108,
          "vulnerability_to_line": 113,
          "vulnerability_code": "    function checkSecret() public payable onlyPlayers returns (bool) {\n        require(msg.value >= 0.01 ether);\n        if (msg.value == secret) {\n            return true;\n        }",
          "message": "DrainMe.checkSecret (0xb620cee6b52f96f3c6b253e6eea556aa2d214a99.sol#108-113) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 115,
          "vulnerability_to_line": 117,
          "vulnerability_code": "    function winPrize() public payable onlyOwner {\n        owner.call.value(1 wei)();",
          "message": "DrainMe.winPrize (0xb620cee6b52f96f3c6b253e6eea556aa2d214a99.sol#115-117) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 119,
          "vulnerability_to_line": 121,
          "vulnerability_code": "    function claimPrize() public payable onlyWinner {\n        winner.transfer(address(this).balance);",
          "message": "DrainMe.claimPrize (0xb620cee6b52f96f3c6b253e6eea556aa2d214a99.sol#119-121) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 123,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function() public payable {}",
          "message": "DrainMe.fallback (0xb620cee6b52f96f3c6b253e6eea556aa2d214a99.sol#123) should be declared external\n"
        },
        {
          "name": "solc-version",
          "vulnerability_from_line": 1,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.23;",
          "message": "Detected issues with version pragma in 0xb620cee6b52f96f3c6b253e6eea556aa2d214a99.sol:\n\t- pragma solidity^0.4.23 (0xb620cee6b52f96f3c6b253e6eea556aa2d214a99.sol#1): it allows old versions\n"
        },
        {
          "name": "low-level-calls",
          "vulnerability_from_line": 76,
          "vulnerability_to_line": 80,
          "vulnerability_code": "    function callFirstTarget() public payable onlyPlayers {\n        require(msg.value >= 0.005 ether);\n\n        firstTarget.call.value(msg.value)();",
          "message": "Low level call in DrainMe.callFirstTarget (0xb620cee6b52f96f3c6b253e6eea556aa2d214a99.sol#76-80):\n\t-firstTarget.call.value(msg.value)() 0xb620cee6b52f96f3c6b253e6eea556aa2d214a99.sol#79\n"
        },
        {
          "name": "low-level-calls",
          "vulnerability_from_line": 82,
          "vulnerability_to_line": 86,
          "vulnerability_code": "    function callSecondTarget() public payable onlyPlayers {\n        require(msg.value >= 0.005 ether);\n\n        secondTarget.call.value(msg.value)();",
          "message": "Low level call in DrainMe.callSecondTarget (0xb620cee6b52f96f3c6b253e6eea556aa2d214a99.sol#82-86):\n\t-secondTarget.call.value(msg.value)() 0xb620cee6b52f96f3c6b253e6eea556aa2d214a99.sol#85\n"
        },
        {
          "name": "low-level-calls",
          "vulnerability_from_line": 115,
          "vulnerability_to_line": 117,
          "vulnerability_code": "    function winPrize() public payable onlyOwner {\n        owner.call.value(1 wei)();",
          "message": "Low level call in DrainMe.winPrize (0xb620cee6b52f96f3c6b253e6eea556aa2d214a99.sol#115-117):\n\t-owner.call.value(1)() 0xb620cee6b52f96f3c6b253e6eea556aa2d214a99.sol#116\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 16,
          "vulnerability_to_line": 18,
          "vulnerability_code": "    function DranMe() public payable {\n        owner = msg.sender;",
          "message": "Function 'DrainMe.DranMe' (0xb620cee6b52f96f3c6b253e6eea556aa2d214a99.sol#16-18) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 39,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setSecret(uint256 _secret) public payable onlyOwner {",
          "message": "Parameter '_secret' of DrainMe.setSecret (0xb620cee6b52f96f3c6b253e6eea556aa2d214a99.sol#39) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 89,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint256 _index,",
          "message": "Parameter '_index' of DrainMe.setSeed (0xb620cee6b52f96f3c6b253e6eea556aa2d214a99.sol#89) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 90,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint256 _value",
          "message": "Parameter '_value' of DrainMe.setSeed (0xb620cee6b52f96f3c6b253e6eea556aa2d214a99.sol#90) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 95,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function addSeed(uint256 _add) public payable onlyPlayers {",
          "message": "Parameter '_add' of DrainMe.addSeed (0xb620cee6b52f96f3c6b253e6eea556aa2d214a99.sol#95) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 100,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint256 _seed",
          "message": "Parameter '_seed' of DrainMe.guessSeed (0xb620cee6b52f96f3c6b253e6eea556aa2d214a99.sol#100) is not in mixedCase\n"
        }
      ]
    },
    "mythril-0.23.15": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "Unchecked return value from external call. (SWC 104)",
          "vulnerability_from_line": 79,
          "vulnerability_to_line": null,
          "vulnerability_code": "        firstTarget.call.value(msg.value)();",
          "message": "The return value of a message call is not checked.\nExternal calls return a boolean value. If the callee halts with an exception, 'false' is returned and execution continues in the caller. The caller should check whether an exception happened and react accordingly to avoid unexpected behavior. For example it is often desirable to wrap external calls in require() so the transaction is reverted if the call fails.\nClassification: SWC-104"
        },
        {
          "name": "Unchecked return value from external call. (SWC 104)",
          "vulnerability_from_line": 85,
          "vulnerability_to_line": null,
          "vulnerability_code": "        secondTarget.call.value(msg.value)();",
          "message": "The return value of a message call is not checked.\nExternal calls return a boolean value. If the callee halts with an exception, 'false' is returned and execution continues in the caller. The caller should check whether an exception happened and react accordingly to avoid unexpected behavior. For example it is often desirable to wrap external calls in require() so the transaction is reverted if the call fails.\nClassification: SWC-104"
        },
        {
          "name": "Exception State (SWC 110)",
          "vulnerability_from_line": 88,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setSeed(",
          "message": "An assertion violation was triggered.\nIt is possible to trigger an assertion violation. Note that Solidity assert() statements should only be used to check invariants. Review the transaction trace generated for this issue and either make sure your program logic is correct, or use require() instead of assert() if your goal is to constrain user inputs or enforce preconditions. Remember to validate inputs from both callers (for instance, via passed arguments) and callees (for instance, via return values).\nClassification: SWC-110"
        },
        {
          "name": "Exception State (SWC 110)",
          "vulnerability_from_line": 14,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint256[] public balance;",
          "message": "An assertion violation was triggered.\nIt is possible to trigger an assertion violation. Note that Solidity assert() statements should only be used to check invariants. Review the transaction trace generated for this issue and either make sure your program logic is correct, or use require() instead of assert() if your goal is to constrain user inputs or enforce preconditions. Remember to validate inputs from both callers (for instance, via passed arguments) and callees (for instance, via return values).\nClassification: SWC-110"
        },
        {
          "name": "Exception State (SWC 110)",
          "vulnerability_from_line": 13,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint256[] public seed = [951828771, 158769871220];",
          "message": "An assertion violation was triggered.\nIt is possible to trigger an assertion violation. Note that Solidity assert() statements should only be used to check invariants. Review the transaction trace generated for this issue and either make sure your program logic is correct, or use require() instead of assert() if your goal is to constrain user inputs or enforce preconditions. Remember to validate inputs from both callers (for instance, via passed arguments) and callees (for instance, via return values).\nClassification: SWC-110"
        },
        {
          "name": "External Call To User-Supplied Address (SWC 107)",
          "vulnerability_from_line": 116,
          "vulnerability_to_line": null,
          "vulnerability_code": "        owner.call.value(1 wei)();",
          "message": "A call to a user-supplied address is executed.\nAn external message call to an address specified by the caller is executed. Note that the callee account might contain arbitrary code and could re-enter any function within this contract. Reentering the contract in an intermediate state may lead to unexpected behaviour. Make sure that no state modifications are executed after this call and/or reentrancy guards are in place.\nClassification: SWC-107"
        },
        {
          "name": "Unchecked return value from external call. (SWC 104)",
          "vulnerability_from_line": 116,
          "vulnerability_to_line": null,
          "vulnerability_code": "        owner.call.value(1 wei)();",
          "message": "The return value of a message call is not checked.\nExternal calls return a boolean value. If the callee halts with an exception, 'false' is returned and execution continues in the caller. The caller should check whether an exception happened and react accordingly to avoid unexpected behavior. For example it is often desirable to wrap external calls in require() so the transaction is reverted if the call fails.\nClassification: SWC-104"
        },
        {
          "name": "Exception State (SWC 110)",
          "vulnerability_from_line": 8,
          "vulnerability_to_line": null,
          "vulnerability_code": "    address[] public players;",
          "message": "An assertion violation was triggered.\nIt is possible to trigger an assertion violation. Note that Solidity assert() statements should only be used to check invariants. Review the transaction trace generated for this issue and either make sure your program logic is correct, or use require() instead of assert() if your goal is to constrain user inputs or enforce preconditions. Remember to validate inputs from both callers (for instance, via passed arguments) and callees (for instance, via return values).\nClassification: SWC-110"
        }
      ]
    }
  }
}