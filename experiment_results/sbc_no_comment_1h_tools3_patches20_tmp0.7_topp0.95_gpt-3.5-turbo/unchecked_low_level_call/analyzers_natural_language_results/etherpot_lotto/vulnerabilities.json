{
  "smartbugs_completed": true,
  "analyzer_results": {
    "oyente": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "Callstack Depth Attack Vulnerability",
          "vulnerability_from_line": 139,
          "vulnerability_to_line": null,
          "vulnerability_code": "            msg.sender.send(msg.value - value);",
          "message": null
        },
        {
          "name": "Integer Overflow",
          "vulnerability_from_line": 129,
          "vulnerability_to_line": null,
          "vulnerability_code": "        return rounds[roundIndex].pot;",
          "message": null
        }
      ]
    },
    "slither": {
      "successfull_analysis": true,
      "errors": [
        "EXIT_CODE_14"
      ],
      "vulnerability_findings": [
        {
          "name": "arbitrary-send",
          "vulnerability_from_line": 88,
          "vulnerability_to_line": 108,
          "vulnerability_code": "    function cash(uint roundIndex, uint subpotIndex) {\n        var subpotsCount = getSubpotsCount(roundIndex);\n\n        if (subpotIndex >= subpotsCount) return;\n\n        var decisionBlockNumber = getDecisionBlockNumber(\n            roundIndex,\n            subpotIndex\n        );\n\n        if (decisionBlockNumber > block.number) return;\n\n        if (rounds[roundIndex].isCashed[subpotIndex]) return;\n\n        var winner = calculateWinner(roundIndex, subpotIndex);\n        var subpot = getSubpot(roundIndex);\n\n        winner.send(subpot);\n\n        rounds[roundIndex].isCashed[subpotIndex] = true;",
          "message": "Lotto.cash (etherpot_lotto.sol#88-108) sends eth to arbitrary user\n\tDangerous calls:\n\t- winner.send(subpot) (etherpot_lotto.sol#105)\n"
        },
        {
          "name": "deprecated-standards",
          "vulnerability_from_line": 111,
          "vulnerability_to_line": null,
          "vulnerability_code": "        return uint(block.blockhash(blockIndex));",
          "message": "Deprecated standard detected @ etherpot_lotto.sol#111:\n\t- Usage of \"block.blockhash()\" should be replaced with \"blockhash()\"\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 10,
          "vulnerability_to_line": 12,
          "vulnerability_code": "    function getBlocksPerRound() constant returns (uint) {\n        return blocksPerRound;",
          "message": "Lotto.getBlocksPerRound (etherpot_lotto.sol#10-12) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 14,
          "vulnerability_to_line": 16,
          "vulnerability_code": "    function getTicketPrice() constant returns (uint) {\n        return ticketPrice;",
          "message": "Lotto.getTicketPrice (etherpot_lotto.sol#14-16) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 31,
          "vulnerability_to_line": 36,
          "vulnerability_code": "    function getIsCashed(\n        uint roundIndex,\n        uint subpotIndex\n    ) constant returns (bool) {\n        return rounds[roundIndex].isCashed[subpotIndex];",
          "message": "Lotto.getIsCashed (etherpot_lotto.sol#31-36) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 88,
          "vulnerability_to_line": 108,
          "vulnerability_code": "    function cash(uint roundIndex, uint subpotIndex) {\n        var subpotsCount = getSubpotsCount(roundIndex);\n\n        if (subpotIndex >= subpotsCount) return;\n\n        var decisionBlockNumber = getDecisionBlockNumber(\n            roundIndex,\n            subpotIndex\n        );\n\n        if (decisionBlockNumber > block.number) return;\n\n        if (rounds[roundIndex].isCashed[subpotIndex]) return;\n\n        var winner = calculateWinner(roundIndex, subpotIndex);\n        var subpot = getSubpot(roundIndex);\n\n        winner.send(subpot);\n\n        rounds[roundIndex].isCashed[subpotIndex] = true;",
          "message": "Lotto.cash (etherpot_lotto.sol#88-108) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 114,
          "vulnerability_to_line": 119,
          "vulnerability_code": "    function getBuyers(\n        uint roundIndex,\n        address buyer\n    ) constant returns (address[]) {\n        return rounds[roundIndex].buyers;",
          "message": "Lotto.getBuyers (etherpot_lotto.sol#114-119) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 121,
          "vulnerability_to_line": 126,
          "vulnerability_code": "    function getTicketsCountByBuyer(\n        uint roundIndex,\n        address buyer\n    ) constant returns (uint) {\n        return rounds[roundIndex].ticketsCountByBuyer[buyer];",
          "message": "Lotto.getTicketsCountByBuyer (etherpot_lotto.sol#121-126) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 128,
          "vulnerability_to_line": 130,
          "vulnerability_code": "    function getPot(uint roundIndex) constant returns (uint) {\n        return rounds[roundIndex].pot;",
          "message": "Lotto.getPot (etherpot_lotto.sol#128-130) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 132,
          "vulnerability_to_line": 154,
          "vulnerability_code": "    function() {\n        var roundIndex = getRoundIndex();\n        var value = msg.value - (msg.value % ticketPrice);\n\n        if (value == 0) return;\n\n        if (value < msg.value) {\n            msg.sender.send(msg.value - value);\n        }\n\n        var ticketsCount = value / ticketPrice;\n        rounds[roundIndex].ticketsCount += ticketsCount;\n\n        if (rounds[roundIndex].ticketsCountByBuyer[msg.sender] == 0) {\n            var buyersLength = rounds[roundIndex].buyers.length++;\n            rounds[roundIndex].buyers[buyersLength] = msg.sender;\n        }\n\n        rounds[roundIndex].ticketsCountByBuyer[msg.sender] += ticketsCount;\n        rounds[roundIndex].ticketsCount += ticketsCount;\n\n        rounds[roundIndex].pot += value;",
          "message": "Lotto.fallback (etherpot_lotto.sol#132-154) should be declared external\n"
        },
        {
          "name": "solc-version",
          "vulnerability_from_line": 1,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.0;",
          "message": "Detected issues with version pragma in etherpot_lotto.sol:\n\t- pragma solidity^0.4.0 (etherpot_lotto.sol#1): it allows old versions\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 4,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint public constant blocksPerRound = 6800;",
          "message": "Constant 'Lotto.blocksPerRound' (etherpot_lotto.sol#4) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 6,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint public constant ticketPrice = 100000000000000000;",
          "message": "Constant 'Lotto.ticketPrice' (etherpot_lotto.sol#6) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 8,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint public constant blockReward = 5000000000000000000;",
          "message": "Constant 'Lotto.blockReward' (etherpot_lotto.sol#8) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        }
      ]
    },
    "mythril-0.23.15": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "Dependence on predictable environment variable (SWC 120)",
          "vulnerability_from_line": 47,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (decisionBlockNumber > block.number) return;",
          "message": "A control flow decision is made based on The block.number environment variable.\nThe block.number environment variable is used to determine a control flow decision. Note that the values of variables like coinbase, gaslimit, block number and timestamp are predictable and can be manipulated by a malicious miner. Also keep in mind that attackers know hashes of earlier blocks. Don't use any of those environment variables as sources of randomness and be aware that use of these variables introduces a certain level of trust into miners.\nClassification: SWC-120"
        },
        {
          "name": "Exception State (SWC 110)",
          "vulnerability_from_line": 110,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getHashOfBlock(uint blockIndex) constant returns (uint) {",
          "message": "An assertion violation was triggered.\nIt is possible to trigger an assertion violation. Note that Solidity assert() statements should only be used to check invariants. Review the transaction trace generated for this issue and either make sure your program logic is correct, or use require() instead of assert() if your goal is to constrain user inputs or enforce preconditions. Remember to validate inputs from both callers (for instance, via passed arguments) and callees (for instance, via return values).\nClassification: SWC-110"
        },
        {
          "name": "Exception State (SWC 110)",
          "vulnerability_from_line": 76,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getSubpotsCount(uint roundIndex) constant returns (uint) {",
          "message": "An assertion violation was triggered.\nIt is possible to trigger an assertion violation. Note that Solidity assert() statements should only be used to check invariants. Review the transaction trace generated for this issue and either make sure your program logic is correct, or use require() instead of assert() if your goal is to constrain user inputs or enforce preconditions. Remember to validate inputs from both callers (for instance, via passed arguments) and callees (for instance, via return values).\nClassification: SWC-110"
        },
        {
          "name": "Integer Arithmetic Bugs (SWC 101)",
          "vulnerability_from_line": 73,
          "vulnerability_to_line": null,
          "vulnerability_code": "        return ((roundIndex + 1) * blocksPerRound) + subpotIndex;",
          "message": "The arithmetic operator can overflow.\nIt is possible to cause an integer overflow or underflow in the arithmetic operation. \nClassification: SWC-101"
        },
        {
          "name": "Integer Arithmetic Bugs (SWC 101)",
          "vulnerability_from_line": 73,
          "vulnerability_to_line": null,
          "vulnerability_code": "        return ((roundIndex + 1) * blocksPerRound) + subpotIndex;",
          "message": "The arithmetic operator can overflow.\nIt is possible to cause an integer overflow or underflow in the arithmetic operation. \nClassification: SWC-101"
        },
        {
          "name": "Integer Arithmetic Bugs (SWC 101)",
          "vulnerability_from_line": 73,
          "vulnerability_to_line": null,
          "vulnerability_code": "        return ((roundIndex + 1) * blocksPerRound) + subpotIndex;",
          "message": "The arithmetic operator can overflow.\nIt is possible to cause an integer overflow or underflow in the arithmetic operation. \nClassification: SWC-101"
        },
        {
          "name": "Integer Arithmetic Bugs (SWC 101)",
          "vulnerability_from_line": 73,
          "vulnerability_to_line": null,
          "vulnerability_code": "        return ((roundIndex + 1) * blocksPerRound) + subpotIndex;",
          "message": "The arithmetic operator can overflow.\nIt is possible to cause an integer overflow or underflow in the arithmetic operation. \nClassification: SWC-101"
        },
        {
          "name": "Integer Arithmetic Bugs (SWC 101)",
          "vulnerability_from_line": 73,
          "vulnerability_to_line": null,
          "vulnerability_code": "        return ((roundIndex + 1) * blocksPerRound) + subpotIndex;",
          "message": "The arithmetic operator can overflow.\nIt is possible to cause an integer overflow or underflow in the arithmetic operation. \nClassification: SWC-101"
        },
        {
          "name": "Integer Arithmetic Bugs (SWC 101)",
          "vulnerability_from_line": 73,
          "vulnerability_to_line": null,
          "vulnerability_code": "        return ((roundIndex + 1) * blocksPerRound) + subpotIndex;",
          "message": "The arithmetic operator can overflow.\nIt is possible to cause an integer overflow or underflow in the arithmetic operation. \nClassification: SWC-101"
        }
      ]
    }
  }
}