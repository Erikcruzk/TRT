/// Your task is to repair the following Solidity Smart Contract
pragma solidity ^0.4.23;

contract MultiOwnable {
    address public root;
    mapping(address => address) public owners;

    constructor() public {
        root = msg.sender;
        owners[root] = root;
    }

    modifier onlyOwner() {
        require(owners[msg.sender] != 0);
        _;
    }

    function newOwner(address _owner) external returns (bool) {
        require(_owner != 0);
        owners[_owner] = msg.sender;
        return true;
    }

    function deleteOwner(address _owner) external onlyOwner returns (bool) {
        require(
            owners[_owner] == msg.sender ||
                (owners[_owner] != 0 && msg.sender == root)
        );
        owners[_owner] = 0;
        return true;
    }
}

contract TestContract is MultiOwnable {
    function withdrawAll() onlyOwner {
        msg.sender.transfer(this.balance);
    }

    function() payable {}
}

/// This Solidity Smart Contract has been analyzed by smart contract analyzers. Here are the results from these analyzers.

/// 1. Mythril-0.23.15 Analysis Results
/// 1.1. Vulnerability: access_control at Line 35:
        msg.sender.transfer(this.balance);
///  Message:Any sender can withdraw Ether from the contract account.
///   Arbitrary senders other than the contract creator can profitably extract Ether from the contract account. Verify the business logic carefully and make sure that appropriate security controls are in place to prevent unexpected loss of funds.
///   Classification: SWC-105



/// Repaired Solidity Smart Contract