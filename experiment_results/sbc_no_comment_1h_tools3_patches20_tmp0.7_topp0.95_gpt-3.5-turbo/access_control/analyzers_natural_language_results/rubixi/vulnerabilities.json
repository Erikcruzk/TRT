{
  "smartbugs_completed": true,
  "analyzer_results": {
    "slither": {
      "successfull_analysis": true,
      "errors": [
        "EXIT_CODE_29"
      ],
      "vulnerability_findings": [
        {
          "name": "calls-loop",
          "vulnerability_from_line": 57,
          "vulnerability_to_line": null,
          "vulnerability_code": "            participants[payoutOrder].etherAddress.send(payoutToSend);",
          "message": "Rubixi.addPayout has external calls inside a loop:\n\t- participants[payoutOrder].etherAddress.send(payoutToSend) (rubixi.sol#57)\n"
        },
        {
          "name": "deprecated-standards",
          "vulnerability_from_line": 65,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (collectedFees == 0) throw;",
          "message": "Deprecated standard detected @ rubixi.sol#65:\n\t- Usage of \"throw\" should be replaced with \"revert()\"\n"
        },
        {
          "name": "deprecated-standards",
          "vulnerability_from_line": 75,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (collectedFees == 0) throw;",
          "message": "Deprecated standard detected @ rubixi.sol#75:\n\t- Usage of \"throw\" should be replaced with \"revert()\"\n"
        },
        {
          "name": "deprecated-standards",
          "vulnerability_from_line": 82,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (collectedFees == 0 || _pcent > 100) throw;",
          "message": "Deprecated standard detected @ rubixi.sol#82:\n\t- Usage of \"throw\" should be replaced with \"revert()\"\n"
        },
        {
          "name": "deprecated-standards",
          "vulnerability_from_line": 94,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (_mult > 300 || _mult < 120) throw;",
          "message": "Deprecated standard detected @ rubixi.sol#94:\n\t- Usage of \"throw\" should be replaced with \"revert()\"\n"
        },
        {
          "name": "deprecated-standards",
          "vulnerability_from_line": 100,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (_fee > 10) throw;",
          "message": "Deprecated standard detected @ rubixi.sol#100:\n\t- Usage of \"throw\" should be replaced with \"revert()\"\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 12,
          "vulnerability_to_line": 14,
          "vulnerability_code": "    function DynamicPyramid() {\n        creator = msg.sender;",
          "message": "Rubixi.DynamicPyramid (rubixi.sol#12-14) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 27,
          "vulnerability_to_line": 29,
          "vulnerability_code": "    function() {\n        init();",
          "message": "Rubixi.fallback (rubixi.sol#27-29) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 71,
          "vulnerability_to_line": 79,
          "vulnerability_code": "    function collectFeesInEther(uint _amt) onlyowner {\n        _amt *= 1 ether;\n        if (_amt > collectedFees) collectAllFees();\n\n        if (collectedFees == 0) throw;\n\n        creator.send(_amt);\n        collectedFees -= _amt;",
          "message": "Rubixi.collectFeesInEther (rubixi.sol#71-79) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 81,
          "vulnerability_to_line": 87,
          "vulnerability_code": "    function collectPercentOfFees(uint _pcent) onlyowner {\n        if (collectedFees == 0 || _pcent > 100) throw;\n\n        uint feesToCollect = (collectedFees / 100) * _pcent;\n        creator.send(feesToCollect);\n        collectedFees -= feesToCollect;",
          "message": "Rubixi.collectPercentOfFees (rubixi.sol#81-87) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 89,
          "vulnerability_to_line": 91,
          "vulnerability_code": "    function changeOwner(address _owner) onlyowner {\n        creator = _owner;",
          "message": "Rubixi.changeOwner (rubixi.sol#89-91) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 93,
          "vulnerability_to_line": 97,
          "vulnerability_code": "    function changeMultiplier(uint _mult) onlyowner {\n        if (_mult > 300 || _mult < 120) throw;\n\n        pyramidMultiplier = _mult;",
          "message": "Rubixi.changeMultiplier (rubixi.sol#93-97) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 99,
          "vulnerability_to_line": 103,
          "vulnerability_code": "    function changeFeePercentage(uint _fee) onlyowner {\n        if (_fee > 10) throw;\n\n        feePercent = _fee;",
          "message": "Rubixi.changeFeePercentage (rubixi.sol#99-103) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 105,
          "vulnerability_to_line": 111,
          "vulnerability_code": "    function currentMultiplier()\n        constant\n        returns (uint multiplier, string info)\n    {\n        multiplier = pyramidMultiplier;\n        info = \"This multiplier applies to you as soon as transaction is received, may be lowered to hasten payouts or increased if payouts are fast enough. Due to no float or decimals, multiplier is x100 for a fractional multiplier e.g. 250 is actually a 2.5x multiplier. Capped at 3x max and 1.2x min.\";",
          "message": "Rubixi.currentMultiplier (rubixi.sol#105-111) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 113,
          "vulnerability_to_line": 116,
          "vulnerability_code": "    function currentFeePercentage() constant returns (uint fee, string info) {\n        fee = feePercent;\n        info = \"Shown in % form. Fee is halved(50%) for amounts equal or greater than 50 ethers. (Fee may change, but is capped to a maximum of 10%)\";",
          "message": "Rubixi.currentFeePercentage (rubixi.sol#113-116) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 118,
          "vulnerability_to_line": 124,
          "vulnerability_code": "    function currentPyramidBalanceApproximately()\n        constant\n        returns (uint pyramidBalance, string info)\n    {\n        pyramidBalance = balance / 1 ether;\n        info = \"All balance values are measured in Ethers, note that due to no decimal placing, these values show up as integers only, within the contract itself you will get the exact decimal value you are supposed to\";",
          "message": "Rubixi.currentPyramidBalanceApproximately (rubixi.sol#118-124) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 126,
          "vulnerability_to_line": 131,
          "vulnerability_code": "    function nextPayoutWhenPyramidBalanceTotalsApproximately()\n        constant\n        returns (uint balancePayout)\n    {\n        balancePayout = participants[payoutOrder].payout / 1 ether;",
          "message": "Rubixi.nextPayoutWhenPyramidBalanceTotalsApproximately (rubixi.sol#126-131) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 133,
          "vulnerability_to_line": 138,
          "vulnerability_code": "    function feesSeperateFromBalanceApproximately()\n        constant\n        returns (uint fees)\n    {\n        fees = collectedFees / 1 ether;",
          "message": "Rubixi.feesSeperateFromBalanceApproximately (rubixi.sol#133-138) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 140,
          "vulnerability_to_line": 142,
          "vulnerability_code": "    function totalParticipants() constant returns (uint count) {\n        count = participants.length;",
          "message": "Rubixi.totalParticipants (rubixi.sol#140-142) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 144,
          "vulnerability_to_line": 149,
          "vulnerability_code": "    function numberOfParticipantsWaitingForPayout()\n        constant\n        returns (uint count)\n    {\n        count = participants.length - payoutOrder;",
          "message": "Rubixi.numberOfParticipantsWaitingForPayout (rubixi.sol#144-149) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 151,
          "vulnerability_to_line": 158,
          "vulnerability_code": "    function participantDetails(\n        uint orderInPyramid\n    ) constant returns (address Address, uint Payout) {\n        if (orderInPyramid <= participants.length) {\n            Address = participants[orderInPyramid].etherAddress;\n            Payout = participants[orderInPyramid].payout / 1 ether;\n        }",
          "message": "Rubixi.participantDetails (rubixi.sol#151-158) should be declared external\n"
        },
        {
          "name": "solc-version",
          "vulnerability_from_line": 1,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.15;",
          "message": "Detected issues with version pragma in rubixi.sol:\n\t- pragma solidity^0.4.15 (rubixi.sol#1): it allows old versions\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 12,
          "vulnerability_to_line": 14,
          "vulnerability_code": "    function DynamicPyramid() {\n        creator = msg.sender;",
          "message": "Function 'Rubixi.DynamicPyramid' (rubixi.sol#12-14) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 44,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function addPayout(uint _fee) private {",
          "message": "Parameter '_fee' of Rubixi.addPayout (rubixi.sol#44) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 71,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function collectFeesInEther(uint _amt) onlyowner {",
          "message": "Parameter '_amt' of Rubixi.collectFeesInEther (rubixi.sol#71) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 81,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function collectPercentOfFees(uint _pcent) onlyowner {",
          "message": "Parameter '_pcent' of Rubixi.collectPercentOfFees (rubixi.sol#81) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 89,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function changeOwner(address _owner) onlyowner {",
          "message": "Parameter '_owner' of Rubixi.changeOwner (rubixi.sol#89) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 93,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function changeMultiplier(uint _mult) onlyowner {",
          "message": "Parameter '_mult' of Rubixi.changeMultiplier (rubixi.sol#93) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 99,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function changeFeePercentage(uint _fee) onlyowner {",
          "message": "Parameter '_fee' of Rubixi.changeFeePercentage (rubixi.sol#99) is not in mixedCase\n"
        }
      ]
    },
    "oyente": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "Callstack Depth Attack Vulnerability",
          "vulnerability_from_line": 85,
          "vulnerability_to_line": null,
          "vulnerability_code": "        creator.send(feesToCollect);",
          "message": null
        },
        {
          "name": "Integer Overflow",
          "vulnerability_from_line": 130,
          "vulnerability_to_line": null,
          "vulnerability_code": "        balancePayout = participants[payoutOrder].payout / 1 ether;",
          "message": null
        },
        {
          "name": "Integer Underflow",
          "vulnerability_from_line": 148,
          "vulnerability_to_line": null,
          "vulnerability_code": "        count = participants.length - payoutOrder;",
          "message": null
        }
      ]
    },
    "mythril-0.23.15": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "Exception State (SWC 110)",
          "vulnerability_from_line": 126,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function nextPayoutWhenPyramidBalanceTotalsApproximately()",
          "message": "An assertion violation was triggered.\nIt is possible to trigger an assertion violation. Note that Solidity assert() statements should only be used to check invariants. Review the transaction trace generated for this issue and either make sure your program logic is correct, or use require() instead of assert() if your goal is to constrain user inputs or enforce preconditions. Remember to validate inputs from both callers (for instance, via passed arguments) and callees (for instance, via return values).\nClassification: SWC-110"
        },
        {
          "name": "Exception State (SWC 110)",
          "vulnerability_from_line": 151,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function participantDetails(",
          "message": "An assertion violation was triggered.\nIt is possible to trigger an assertion violation. Note that Solidity assert() statements should only be used to check invariants. Review the transaction trace generated for this issue and either make sure your program logic is correct, or use require() instead of assert() if your goal is to constrain user inputs or enforce preconditions. Remember to validate inputs from both callers (for instance, via passed arguments) and callees (for instance, via return values).\nClassification: SWC-110"
        }
      ]
    }
  }
}