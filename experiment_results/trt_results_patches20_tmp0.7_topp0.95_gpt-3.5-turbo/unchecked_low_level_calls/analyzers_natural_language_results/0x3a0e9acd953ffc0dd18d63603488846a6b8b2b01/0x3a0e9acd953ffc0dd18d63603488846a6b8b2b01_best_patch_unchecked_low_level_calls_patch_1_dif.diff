  pragma solidity ^0.4.18;
  
  contract Ownable {
-     address newOwner;
+     address public newOwner;
?            +++++++
-     address owner = msg.sender;
+     address public owner;
  
+     function Ownable() public {
+         owner = msg.sender;
+     }
+ 
-     function changeOwner(address addr) public onlyOwner {
?                                  ^^^
+     function changeOwner(address _newOwner) public onlyOwner {
?                                  ^^^^^^^^
+         require(_newOwner != address(0));
-         newOwner = addr;
?                    ^^^
+         newOwner = _newOwner;
?                    ^^^^^^^^
      }
  
      function confirmOwner() public {
-         if (msg.sender == newOwner) {
?          ^^                        ^^
+         require(msg.sender == newOwner);
?         ++++ ^^                        ^
-             owner = newOwner;
? ----
+         owner = newOwner;
-         }
+         newOwner = address(0);
      }
  
      modifier onlyOwner() {
-         if (owner == msg.sender) _;
+         require(msg.sender == owner);
+         _;
      }
  }
  
  contract Token is Ownable {
-     address owner = msg.sender;
- 
-     function WithdrawToken(
?              ^
+     function withdrawToken(
?              ^
-         address token,
+         address _token,
?                 +
-         uint256 amount,
+         uint256 _amount,
?                 +
-         address to
+         address _to
?                 +
      ) public onlyOwner {
+         require(_to != address(0));
-         token.call(bytes4(sha3("transfer(address,uint256)")), to, amount);
?                           ^^ ^
+         require(_token.call(bytes4(keccak256("transfer(address,uint256)")), _to, _amount));
?         +++++++++                  ^^^^ ^^^^                                +    +       +
      }
  }
  
  contract TokenBank is Token {
      uint public MinDeposit;
      mapping(address => uint) public Holders;
  
-     function initTokenBank() public {
?              ----
+     function TokenBank() public {
          owner = msg.sender;
          MinDeposit = 1 ether;
      }
  
-     function() payable {
+     function() public payable {
?                +++++++
-         Deposit();
?         ^
+         deposit();
?         ^
      }
  
-     function Deposit() payable {
?              ^
+     function deposit() public payable {
?              ^         +++++++
          if (msg.value > MinDeposit) {
              Holders[msg.sender] += msg.value;
          }
      }
  
-     function WitdrawTokenToHolder(
?              ^
+     function withdrawTokenToHolder(
?              ^  +
          address _to,
          address _token,
          uint _amount
      ) public onlyOwner {
-         if (Holders[_to] > 0) {
+         require(_to != address(0));
+         require(Holders[_to] > 0 && _amount > 0);
-             Holders[_to] = 0;
? ----
+         Holders[_to] = 0;
-             WithdrawToken(_token, _amount, _to);
?         ^^^^^
+         withdrawToken(_token, _amount, _to);
?         ^
-         }
      }
  
-     function WithdrawToHolder(
?              ^
+     function withdrawToHolder(
?              ^
          address _addr,
          uint _wei
-     ) public payable onlyOwner {
?             --------
+     ) public onlyOwner {
-         if (Holders[msg.sender] > 0) {
-             if (Holders[_addr] >= _wei) {
-                 _addr.call.value(_wei);
+         require(_addr != address(0));
+         require(Holders[msg.sender] > 0 && Holders[_addr] >= _wei && _wei > 0);
+         _addr.transfer(_wei);
-                 Holders[_addr] -= _wei;
? --------
+         Holders[_addr] -= _wei;
-             }
-         }
      }
  
-     function Bal() public constant returns (uint) {
?              ^
+     function balance() public constant returns (uint) {
?              ^  ++++
          return this.balance;
      }
- }
+ }