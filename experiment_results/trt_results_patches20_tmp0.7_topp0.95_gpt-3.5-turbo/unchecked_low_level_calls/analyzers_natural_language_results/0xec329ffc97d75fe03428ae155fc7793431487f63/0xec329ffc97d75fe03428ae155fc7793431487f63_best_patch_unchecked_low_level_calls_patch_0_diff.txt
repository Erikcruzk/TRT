  pragma solidity >=0.4.11;
  
  contract Owned {
-     function Owned() {
+     address public owner;
+ 
+     constructor() public {
          owner = msg.sender;
      }
  
-     address public owner;
- 
      modifier onlyOwner() {
-         if (msg.sender == owner) _;
+         require(msg.sender == owner, "Only owner can call this function.");
+         _;
      }
  
-     function changeOwner(address _newOwner) onlyOwner {
+     function changeOwner(address _newOwner) public onlyOwner {
?                                             +++++++
          owner = _newOwner;
      }
  
-     function execute(address _dst, uint _value, bytes _data) onlyOwner {
+     function execute(address payable _dst, uint _value, bytes memory _data) public onlyOwner {
?                              ++++++++                        +++++++       +++++++
-         _dst.call.value(_value)(_data);
+         (bool success, ) = _dst.call.value(_value)(_data);
?        +++++++++++++++++++
+         require(success, "Execution failed.");
      }
  }
  
- contract Token {
? ^^     ^
+ interface Token {
? ^  + +  ^
-     function transfer(address, uint) returns (bool);
+     function transfer(address to, uint256 value) external returns (bool);
?                              +++      +++++++++ +++++++++
  
-     function balanceOf(address) constant returns (uint);
?                                 ^^ -- ^^
+     function balanceOf(address owner) external view returns (uint256);
?                               ++++++  ^^^^^  ^^^^^^              +++
  }
  
  contract TokenSender is Owned {
      Token public token;
      uint public totalToDistribute;
  
      uint public next;
  
      struct Transfer {
          address addr;
          uint amount;
      }
  
      Transfer[] public transfers;
  
-     function TokenSender(address _token) {
+     constructor(address _token) public {
          token = Token(_token);
      }
  
      uint constant D160 = 0x0010000000000000000000000000000000000000000;
  
-     function fill(uint[] data) onlyOwner {
+     function fill(uint[] memory data) public onlyOwner {
?                          +++++++     +++++++
+         require(next == 0, "Tokens have already been distributed.");
-         if (next > 0) throw;
- 
          uint acc;
          uint offset = transfers.length;
-         transfers.length = transfers.length + data.length;
?                           -------------------
+         transfers.length += data.length;
?                          +
          for (uint i = 0; i < data.length; i++) {
              address addr = address(data[i] & (D160 - 1));
              uint amount = data[i] / D160;
  
              transfers[offset + i].addr = addr;
              transfers[offset + i].amount = amount;
              acc += amount;
          }
          totalToDistribute += acc;
      }
  
-     function run() onlyOwner {
+     function run() public onlyOwner {
?                   +++++++
+         require(transfers.length > 0, "No transfers have been added.");
-         if (transfers.length == 0) return;
- 
          uint mNext = next;
  
          next = transfers.length;
  
-         if ((mNext == 0) && (token.balanceOf(this) != totalToDistribute)) throw;
?                                                                           ^^^^^^
+         if ((mNext == 0) && (token.balanceOf(address(this)) != totalToDistribute)) {
?                                              ++++++++     +                        ^
+             revert("Incorrect token balance.");
+         }
  
-         while ((mNext < transfers.length) && (gas() > 150000)) {
+         while ((mNext < transfers.length) && (gasleft() > 150000)) {
?                                                  ++++
              uint amount = transfers[mNext].amount;
              address addr = transfers[mNext].addr;
              if (amount > 0) {
-                 if (!token.transfer(addr, transfers[mNext].amount)) throw;
+                 require(token.transfer(addr, amount), "Transfer failed.");
              }
              mNext++;
          }
  
          next = mNext;
      }
  
-     function hasTerminated() constant returns (bool) {
?                               ^^^^^^^
+     function hasTerminated() public view returns (bool) {
?                              +++++ ^^^^^
+         return (transfers.length > 0 && next >= transfers.length);
-         if (transfers.length == 0) return false;
-         if (next < transfers.length) return false;
-         return true;
      }
  
-     function nTransfers() constant returns (uint) {
?                            ^^^^^^^
+     function nTransfers() public view returns (uint) {
?                           +++++ ^^^^^
          return transfers.length;
      }
+ }- 
-     function gas() internal constant returns (uint _gas) {
-         assembly {
-             _gas := gas
-         }
-     }
- }
