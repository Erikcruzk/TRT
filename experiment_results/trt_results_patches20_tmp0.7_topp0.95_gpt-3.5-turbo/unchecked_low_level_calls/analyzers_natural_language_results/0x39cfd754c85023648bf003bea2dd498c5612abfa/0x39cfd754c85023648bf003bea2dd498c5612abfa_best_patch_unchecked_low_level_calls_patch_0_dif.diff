  pragma solidity ^0.4.18;
  
  contract Ownable {
-     address newOwner;
+     address public newOwner;
?            +++++++
+     address public owner;
+ 
+     function Ownable() public {
-     address owner = msg.sender;
?     ^^^^^^^
+         owner = msg.sender;
?     ^^^
+     }
  
      function changeOwner(address addr) public onlyOwner {
          newOwner = addr;
      }
  
      function confirmOwner() public {
-         if (msg.sender == newOwner) {
?          ^^                        ^^
+         require(msg.sender == newOwner);
?         ++++ ^^                        ^
-             owner = newOwner;
? ----
+         owner = newOwner;
-         }
+         newOwner = address(0);
      }
  
      modifier onlyOwner() {
-         if (owner == msg.sender) _;
+         require(msg.sender == owner);
+         _;
      }
  }
  
  contract Token is Ownable {
-     address owner = msg.sender;
- 
      function WithdrawToken(
-         address token,
+         address _token,
?                 +
-         uint256 amount,
+         uint256 _amount,
?                 +
-         address to
+         address _to
?                 +
      ) public onlyOwner {
-         token.call(bytes4(sha3("transfer(address,uint256)")), to, amount);
?                           ^^ ^
+         require(_token.call(bytes4(keccak256("transfer(address,uint256)")), _to, _amount));
?         +++++++++                  ^^^^ ^^^^                                +    +       +
      }
  }
  
  contract TokenBank is Token {
      uint public MinDeposit;
      mapping(address => uint) public Holders;
  
-     function initTokenBank() public {
?              ----
+     function TokenBank() public {
          owner = msg.sender;
          MinDeposit = 1 ether;
      }
  
-     function() payable {
+     function() public payable {
?                +++++++
          Deposit();
      }
  
-     function Deposit() payable {
+     function Deposit() public payable {
?                        +++++++
          if (msg.value > MinDeposit) {
              Holders[msg.sender] += msg.value;
          }
      }
  
-     function WitdrawTokenToHolder(
+     function WithdrawTokenToHolder(
?                 +
          address _to,
          address _token,
          uint _amount
      ) public onlyOwner {
          if (Holders[_to] > 0) {
              Holders[_to] = 0;
              WithdrawToken(_token, _amount, _to);
          }
      }
  
      function WithdrawToHolder(
          address _addr,
          uint _wei
-     ) public payable onlyOwner {
?             --------
+     ) public onlyOwner {
-         if (Holders[msg.sender] > 0) {
-             if (Holders[_addr] >= _wei) {
? ----
+         if (Holders[_addr] >= _wei) {
-                 _addr.call.value(_wei);
-                 Holders[_addr] -= _wei;
? ----
+             Holders[_addr] -= _wei;
-             }
+             _addr.transfer(_wei);
          }
      }
- }
+ }