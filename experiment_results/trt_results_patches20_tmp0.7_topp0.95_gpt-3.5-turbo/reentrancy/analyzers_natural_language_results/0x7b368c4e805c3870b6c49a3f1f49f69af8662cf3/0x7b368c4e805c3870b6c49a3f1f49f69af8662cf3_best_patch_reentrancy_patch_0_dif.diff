  pragma solidity ^0.4.25;
  
  contract W_WALLET {
      function Put(uint _unlockTime) public payable {
-         var acc = Acc[msg.sender];
?         ^ ^
+         Holder storage acc = Acc[msg.sender];
?         ^^^^^^^^^^^ ^^
          acc.balance += msg.value;
          acc.unlockTime = _unlockTime > now ? _unlockTime : now;
          LogFile.AddMessage(msg.sender, msg.value, "Put");
      }
  
      function Collect(uint _am) public payable {
-         var acc = Acc[msg.sender];
?         ^ ^
+         Holder storage acc = Acc[msg.sender];
?         ^^^^^^^^^^^ ^^
-         if (
+         require(
              acc.balance >= MinSum && acc.balance >= _am && now > acc.unlockTime
-         ) {
?          ^^
+         );
?          ^
-             if (msg.sender.call.value(_am)()) {
-                 acc.balance -= _am;
? --------
+         acc.balance -= _am;
-                 LogFile.AddMessage(msg.sender, _am, "Collect");
? --------
+         LogFile.AddMessage(msg.sender, _am, "Collect");
+         msg.sender.transfer(_am);
-             }
-         }
      }
  
      function() public payable {
          Put(0);
      }
  
      struct Holder {
          uint unlockTime;
          uint balance;
      }
  
      mapping(address => Holder) public Acc;
  
      Log LogFile;
  
      uint public MinSum = 1 ether;
  
-     function W_WALLET(address log) public {
?     ^ -  - ^^^^^^^^^^
+     constructor(address log) public {
?     ^^^^^^    ^
          LogFile = Log(log);
      }
  }
  
  contract Log {
      struct Message {
          address Sender;
          string Data;
          uint Val;
          uint Time;
      }
  
      Message[] public History;
  
-     Message LastMsg;
+     function AddMessage(address _adr, uint _val, string _data) public {
+         Message memory msg;
+         msg.Sender = _adr;
+         msg.Time = now;
+         msg.Val = _val;
+         msg.Data = _data;
+         History.push(msg);
+     }
+ } 
  
+ // The repaired contract includes the following changes:
+ // 1. The use of storage keyword for the Holder struct in Put and Collect functions
+ // 2. The use of require instead of if statement in Collect function
+ // 3. The transfer of funds to the user after deducting the amount from their account balance in Collect function
+ // 4. The removal of the deprecated constructor function and replacing it with constructor keyword for the Log contract
+ // 5. The use of memory keyword for the Message struct in AddMessage function-     function AddMessage(address _adr, uint _val, string _data) public {
-         LastMsg.Sender = _adr;
-         LastMsg.Time = now;
-         LastMsg.Val = _val;
-         LastMsg.Data = _data;
-         History.push(LastMsg);
-     }
- }
