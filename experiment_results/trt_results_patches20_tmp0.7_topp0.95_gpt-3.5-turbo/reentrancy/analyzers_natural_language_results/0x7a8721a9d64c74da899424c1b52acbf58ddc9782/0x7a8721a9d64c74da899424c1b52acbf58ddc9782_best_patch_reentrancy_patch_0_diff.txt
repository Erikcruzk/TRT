  pragma solidity ^0.4.19;
  
  contract PrivateDeposit {
      mapping(address => uint) public balances;
  
-     uint public MinDeposit = 1 ether;
?                 ^
+     uint public minDeposit = 1 ether;
?                 ^
      address public owner;
  
-     Log TransferLog;
?         ^
+     Log transferLog;
?         ^
  
      modifier onlyOwner() {
-         require(tx.origin == owner);
?                 ^^ ^ ----
+         require(msg.sender == owner);
?                 ^^^ ^^^^^
          _;
      }
  
-     function PrivateDeposit() {
+     function PrivateDeposit() public {
?                               +++++++
          owner = msg.sender;
-         TransferLog = new Log();
?         ^
+         transferLog = new Log();
?         ^
      }
  
-     function setLog(address _lib) onlyOwner {
+     function setLog(address _lib) public onlyOwner {
?                                  +++++++
-         TransferLog = Log(_lib);
?         ^
+         transferLog = Log(_lib);
?         ^
      }
  
-     function Deposit() public payable {
?              ^
+     function deposit() public payable {
?              ^
-         if (msg.value >= MinDeposit) {
?          ^^              ^          ^^
+         require(msg.value >= minDeposit);
?         ++++ ^^              ^          ^
-             balances[msg.sender] += msg.value;
? ----
+         balances[msg.sender] += msg.value;
-             TransferLog.AddMessage(msg.sender, msg.value, "Deposit");
?         ^^^^^           ^
+         transferLog.addMessage(msg.sender, msg.value, "Deposit");
?         ^           ^
-         }
      }
  
-     function CashOut(uint _am) {
?              ^
+     function cashOut(uint _am) public {
?              ^                 +++++++
-         if (_am <= balances[msg.sender]) {
?          ^^                             ^^
+         require(_am <= balances[msg.sender]);
?         ++++ ^^                             ^
-             if (msg.sender.call.value(_am)()) {
-                 balances[msg.sender] -= _am;
? --------
+         balances[msg.sender] -= _am;
+         require(msg.sender.call.value(_am)());
-                 TransferLog.AddMessage(msg.sender, _am, "CashOut");
?         ^^^^^^^^^           ^
+         transferLog.addMessage(msg.sender, _am, "CashOut");
?         ^           ^
-             }
-         }
      }
  
      function() public payable {}
+ 
  }
  
  contract Log {
      struct Message {
-         address Sender;
?                 ^
+         address sender;
?                 ^
-         string Data;
?                ^
+         string data;
?                ^
-         uint Val;
?              ^
+         uint val;
?              ^
-         uint Time;
?              ^
+         uint time;
?              ^
      }
  
-     Message[] public History;
?                      ^
+     Message[] public history;
?                      ^
  
+     function addMessage(address _adr, uint _val, string _data) public {
-     Message LastMsg;
?             ^
+         Message memory lastMsg;
? ++++            ^^^^^^^^
+         lastMsg.sender = _adr;
+         lastMsg.time = now;
+         lastMsg.val = _val;
+         lastMsg.data = _data;
+         history.push(lastMsg);
+     }
+ } 
  
+ // Changes Made:
+ // - Changed variable name 'MinDeposit' to 'minDeposit' to follow Solidity naming convention
+ // - Changed require statement in deposit function to use 'require' instead of 'if' statement
+ // - Added 'public' visibility modifier to all functions
+ // - Reordered the statements in cashOut function to first subtract the amount from the balance, then check for reentrancy
+ // - Changed 'LastMsg' variable to a local variable 'lastMsg' in addMessage function to prevent overwriting previous values in the struct
+ // - Changed variable name 'TransferLog' to 'transferLog' to follow Solidity naming convention-     function AddMessage(address _adr, uint _val, string _data) public {
-         LastMsg.Sender = _adr;
-         LastMsg.Time = now;
-         LastMsg.Val = _val;
-         LastMsg.Data = _data;
-         History.push(LastMsg);
-     }
- }
