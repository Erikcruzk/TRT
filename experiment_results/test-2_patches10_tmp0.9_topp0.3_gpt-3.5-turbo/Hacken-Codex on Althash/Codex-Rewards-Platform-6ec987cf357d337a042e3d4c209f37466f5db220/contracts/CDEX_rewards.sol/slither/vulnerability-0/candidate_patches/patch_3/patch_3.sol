pragma solidity 0.4.21;





contract ReentrancyGuard {
    












    uint256 private constant _NOT_ENTERED = 1;
    uint256 private constant _ENTERED = 2;

    uint256 private _status;

    function ReentrancyGuard() internal {
        _status = _NOT_ENTERED;
    }

    






    modifier nonReentrant() {
        
        require(_status != _ENTERED);
        
        _status = _ENTERED;

        _;

        
        
        _status = _NOT_ENTERED;
    }
}

contract Owned {
    address public owner;
    address public nominatedOwner;

    function Owned(address _owner) public {
        require(_owner != address(0));
        owner = _owner;
        emit OwnerChanged(address(0), _owner);
    }

    function nominateNewOwner(address _owner) external onlyOwner {
        nominatedOwner = _owner;
        emit OwnerNominated(_owner);
    }

    function acceptOwnership() external {
        require(msg.sender == nominatedOwner);
        emit OwnerChanged(owner, nominatedOwner);
        owner = nominatedOwner;
        nominatedOwner = address(0);
    }

    modifier onlyOwner {
        _onlyOwner();
        _;
    }

    function _onlyOwner() private view {
        require(msg.sender == owner);
    }

    event OwnerNominated(address newOwner);
    event OwnerChanged(address oldOwner, address newOwner);
}

contract Pausable is Owned {
    uint256 public lastPauseTime;
    bool public paused;

    function Pausable() internal {
        
        require(owner != address(0));
        
    }

    



    function setPaused(bool _paused) external onlyOwner {
        
        if (_paused == paused) {
            return;
        }

        
        paused = _paused;
        
        if (paused) {
            lastPauseTime = now;
        }
        
        emit PauseChanged(paused);
    }

    event PauseChanged(bool isPaused);

    modifier notPaused {
        require(!paused);
        _;
    }
}

library SafeMath {
    









    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a);

        return c;
    }

    









    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a);
        uint256 c = a - b;

        return c;
    }

    









    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        
        
        
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b);

        return c;
    }

    











    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b > 0);
        uint256 c = a / b;

        return c;
    }

    











    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b != 0);
        return a % b;
    }
}


interface CDEXTokenContract {

    function balanceOf(address account) external view returns (uint256);
    function transfer(address _to, uint256 _value) external;
    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);

}


interface CDEXRankingContract {

    function insert(uint _key, address _value) external;
    function remove(uint _key, address _value) external;

}

function beginMigration() external {
        require(msg.sender == migrationManager, "Not authorized");
        
        inMigration = true;
        
        // Transfer all remaining tokens to the migration manager
        CDEXToken.transfer(migrationManager, CDEXToken.balanceOf(address(this)));
    }