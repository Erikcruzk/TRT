pragma solidity ^0.4.24;

library Roles {
    struct Role {
        mapping(address => bool) bearer;
    }

    function add(Role storage role, address account) internal {
        require(!has(role, account));
        role.bearer[account] = true;
    }

    function remove(Role storage role, address account) internal {
        require(has(role, account));
        role.bearer[account] = false;
    }

    function has(Role storage role, address account)
        internal
        view
        returns (bool)
    {
        require(account != address(0));
        return role.bearer[account];
    }
}

contract ApproverRole {
    using Roles for Roles.Role;

    event ApproverAdded(address indexed account);
    event ApproverRemoved(address indexed account);

    Roles.Role private _approvers;

    address firstSignAddress;
    address secondSignAddress;

    mapping(address => bool) signed; 

    constructor() internal {
        _addApprover(msg.sender);

        firstSignAddress = 0xBdCf81639242C471f79f985D66BE8A289bD78428; 
        secondSignAddress = 0xFb46431618d4769F2b14178C19402eca7fbb2b5f; 
    }

    modifier onlyApprover() {
        require(isApprover(msg.sender));
        _;
    }

    function sign() external {
        require(
            msg.sender == firstSignAddress || msg.sender == secondSignAddress
        );
        require(!signed[msg.sender]);
        signed[msg.sender] = true;
    }

    function isApprover(address account) public view returns (bool) {
        return _approvers.has(account);
    }

    function addApprover(address account) external onlyApprover {
        require(signed[firstSignAddress] && signed[secondSignAddress]);
        _addApprover(account);

        signed[firstSignAddress] = false;
        signed[secondSignAddress] = false;
    }

    function removeApprover(address account) external onlyApprover {
        require(signed[firstSignAddress] && signed[secondSignAddress]);
        _removeApprover(account);

        signed[firstSignAddress] = false;
        signed[secondSignAddress] = false;
    }

    function renounceApprover() external {
        require(signed[firstSignAddress] && signed[secondSignAddress]);
        _removeApprover(msg.sender);

        signed[firstSignAddress] = false;
        signed[secondSignAddress] = false;
    }

    function _addApprover(address account) internal {
        _approvers.add(account);
        emit ApproverAdded(account);
    }

    function _removeApprover(address account) internal {
        _approvers.remove(account);
        emit ApproverRemoved(account);
    }
}

library SafeMath {
    function safeAdd(uint256 a, uint256 b) external pure returns (uint256 c) {
        c = a + b;
        require(c >= a);
    }

    function safeSub(uint256 a, uint256 b) external pure returns (uint256 c) {
        require(b <= a);
        c = a - b;
    }

    function safeMul(uint256 a, uint256 b) external pure returns (uint256 c) {
        c = a * b;
        require(a == 0 || c / a == b);
    }

    function safeDiv(uint256 a, uint256 b) external pure returns (uint256 c) {
        require(b > 0);
        c = a / b;
    }
}

interface IERC20 {
    function totalSupply() external constant returns (uint256);

    function balanceOf(address tokenOwner)
        external
        constant
        returns (uint256 balance);

    function allowance(address tokenOwner, address spender)
        external
        constant
        returns (uint256 remaining);

    function transfer(address to, uint256 tokens)
        external
        returns (bool success);

    function approve(address spender, uint256 tokens)
        external
        returns (bool success);

    function transferFrom(
        address from,
        address to,
        uint256 tokens
    ) external returns (bool success);

    event Transfer(address indexed from, address indexed to, uint256 tokens);
    event Approval(
        address indexed tokenOwner,
        address indexed spender,
        uint256 tokens
    );
}

contract ReentrancyGuard {
    
    
    
    
    

    
    
    
    
    
    uint256 private constant _NOT_ENTERED = 1;
    uint256 private constant _ENTERED = 2;

    uint256 private _status;

    constructor() public {
        _status = _NOT_ENTERED;
    }

    






    modifier nonReentrant() {
        
        require(_status != _ENTERED, "ReentrancyGuard: reentrant call");

        
        _status = _ENTERED;

        _;

        
        
        _status = _NOT_ENTERED;
    }
}

contract MainContract is ApproverRole, ReentrancyGuard {
    using SafeMath for uint256;
    struct AccountData {
        uint8 accountType; 
        address personWalletAddress;
        uint256 personWorkCount;
        uint256[] personPuan; 
        address[] WorkAddresses; 
        string personInfoData;
    }

    mapping(address => AccountData) accounts;
    mapping(address => bool) personsAddress;
    mapping(address => uint8) public feeRates;
    mapping(address => bool) public availableTokens;
    mapping(address => uint256) public approverLockBalances;
    mapping(address => bool) public isDeployedWorks;

    uint8 public bnbFeeRate;
    uint256 public remainingArgonToken;
    uint256 public approverMinArgonLimit;
    address[] public deployedWorks;
    address[] public allPersons;
    address public feeAddress;
    address public argonTokenContractAddress;
    bool public isActive;
    IERC20 public argonToken; 

    modifier isInAccounts() {
        require(personsAddress[msg.sender]);
        _;
    }

    modifier mustApprover() {
        require(personsAddress[msg.sender]);
        AccountData storage data = accounts[msg.sender];
        require(data.accountType == 1);
        _;
    }

    modifier mustActive() {
        require(isActive);
        _;
    }

    constructor(
        address _argonTokenAddress,
        uint8 _bnbFeeRate,
        address _feeAddress
    ) public {
        argonToken = IERC20(_argonTokenAddress);
        bnbFeeRate = _bnbFeeRate;
        remainingArgonToken = 5e6 ether;
        approverMinArgonLimit = 20000 * 10**18;
        feeAddress = _feeAddress;
        argonTokenContractAddress = _argonTokenAddress;
    }

    function changeActive(bool _active) external onlyApprover {
        isActive = _active;
    }

    function changeAvailableTokenFee(
        address _tokenAddress,
        uint8 _feeRate,
        bool _available
    ) external onlyApprover {
        feeRates[_tokenAddress] = _feeRate;
        availableTokens[_tokenAddress] = _available;
    }

    function changeSettings(
        uint256 _approverMinArgonLimit,
        uint8 _bnbFeeRate,
        address _feeAddress
    ) external onlyApprover {
        approverMinArgonLimit = _approverMinArgonLimit;
        bnbFeeRate = _bnbFeeRate;
        feeAddress = _feeAddress;
    }

    function sendArgonTokenAdmin(address _address, uint256 amount)
        external
        onlyApprover
        nonReentrant
    {
        argonToken.transfer(_address, amount);
    }

    function unLock() external mustApprover nonReentrant {
        require(approverLockBalances[msg.sender] > 0);
        AccountData storage data = accounts[msg.sender];
        require(data.WorkAddresses.length == 0);
        delete accounts[msg.sender];
        personsAddress[msg.sender] = false;
        for (uint256 x = 0; x < allPersons.length; x++) {
            if (allPersons[x] == msg.sender) {
                delete allPersons[x];
            }
        }
        argonToken.transfer(msg.sender, approverLockBalances[msg.sender]);
        approverLockBalances[msg.sender] = 0;
    }

    function getAllPersons() external view returns (address[]) {
        return allPersons;
    }

    function addPerson(uint8 _accountType, string _personInfoData)
        external
        mustActive
        nonReentrant
    {
        if (_accountType == 1) {
            approverLockBalances[msg.sender] = approverLockBalances[msg.sender]
                .safeAdd(approverMinArgonLimit);
            require(
                argonToken.transferFrom(
                    msg.sender,
                    address(this),
                    approverMinArgonLimit
                )
            );
        }
        require(!personsAddress[msg.sender]);
        AccountData memory newAccount =
            AccountData({
                accountType: _accountType,
                personWalletAddress: msg.sender,
                personWorkCount: 0,
                personPuan: new uint256[](0),
                WorkAddresses: new address[](0),
                personInfoData: _personInfoData
            });

        accounts[msg.sender] = newAccount; 
        allPersons.push(msg.sender); 
        personsAddress[msg.sender] = true;
    }

    function getPersonInfoData(address _personAddress)
        external
        view
        returns (
            uint8,
            uint256,
            uint256[],
            address[],
            string
        )
    {
        AccountData storage data = accounts[_personAddress];
        return (
            data.accountType,
            data.personWorkCount,
            data.personPuan,
            data.WorkAddresses,
            data.personInfoData
        );
    }

    function getPersonAccountType(address _personAddress)
        public
        view
        returns (uint8)
    {
        AccountData storage data = accounts[_personAddress];
        return data.accountType;
    }

    function updatePerson(string _personInfoData)
        external
        isInAccounts
        mustActive
    {
        AccountData storage data = accounts[msg.sender];
        data.personInfoData = _personInfoData;
    }

    function createWork(
        string _workTitle,
        string _workCategory,
        string _workDescription,
        string _workAvarageBudget
    ) external mustActive {
        AccountData storage data = accounts[msg.sender];
        require(getPersonAccountType(msg.sender) == 2);
        address newWork =
            new WorkContract(
                _workTitle,
                _workCategory,
                _workDescription,
                _workAvarageBudget,
                msg.sender,
                this
            );
        data.WorkAddresses.push(newWork); 
        deployedWorks.push(newWork); 
        isDeployedWorks[newWork] = true;
    }

    function getWorks() external view returns (address[]) {
        return deployedWorks;
    }

    function setPuan(uint256 _puan, address _freelancerAddress) external {
        require(isDeployedWorks[msg.sender]);
        AccountData storage data = accounts[_freelancerAddress];
        data.personPuan.push(_puan);
    }

    function setApproverWorkAddress(
        address _workAddress,
        address _approveraddress
    ) external {
        require(isDeployedWorks[msg.sender]);

        AccountData storage data = accounts[_approveraddress];
        data.WorkAddresses.push(_workAddress);
    }

    function _removeApproverWorkAddressArray(
        uint256 index,
        address _approveraddress
    ) private {
        AccountData storage data = accounts[_approveraddress];

        if (index >= data.WorkAddresses.length) return;

        for (uint256 i = index; i < data.WorkAddresses.length - 1; i++) {
            data.WorkAddresses[i] = data.WorkAddresses[i + 1];
        }
        delete data.WorkAddresses[data.WorkAddresses.length - 1];
        data.WorkAddresses.length--;
    }

    function deleteApproverWorkAddress(
        address _workAddress,
        address _approveraddress
    ) external {
        require(isDeployedWorks[msg.sender]);

        AccountData storage data = accounts[_approveraddress];
        for (uint256 i = 0; i < data.WorkAddresses.length; i++) {
            if (data.WorkAddresses[i] == _workAddress) {
                _removeApproverWorkAddressArray(i, _approveraddress);
            }
        }
    }

    function checkDeadline(address _workAddress)
        external
        view
        returns (bool, address)
    {
        WorkContract deployedWork;
        deployedWork = WorkContract(_workAddress);
        if (now > deployedWork.deadLine() && deployedWork.deadLine() != 0) {
            return (true, _workAddress);
        } else {
            return (false, _workAddress);
        }
    }

    function sendApproverArgonCoin(address _approveraddress) external {
        require(isDeployedWorks[msg.sender]);

        uint256 amount = (remainingArgonToken.safeMul(3)).safeDiv(1e5);
        argonToken.transfer(_approveraddress, amount);
        remainingArgonToken = remainingArgonToken.safeSub(amount);
    }
}

function beginMigration(
        string _workTitle,
        string _workCategory,
        string _workDescription,
        string _workAvarageBudget,
        address _employerAddress,
        address _t
    ) public {
        require(deployedFromContract.isActive());
        require(deployedFromContract.getPersonAccountType(_employerAddress) == 2);
        workTitle = _workTitle;
        workCategory = _workCategory;
        workDescription = _workDescription;
        workCreateTime = now;
        workAvarageBudget = _workAvarageBudget;
        workOfferCount = 0;
        workStatus = false;
        employerAddress = _employerAddress;
        freelancerSendFiles = false;
        employerReceiveFiles = false;
        argonToken = IERC20(deployedFromContract.argonTokenContractAddress());
    }