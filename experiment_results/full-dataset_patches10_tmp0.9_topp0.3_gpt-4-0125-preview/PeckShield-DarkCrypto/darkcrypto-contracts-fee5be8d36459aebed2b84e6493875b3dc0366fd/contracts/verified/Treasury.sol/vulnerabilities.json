{
  "smartbugs_completed": true,
  "analyzer_results": {
    "semgrep": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "use-abi-encodecall-instead-of-encodewithselector",
          "vulnerability_from_line": 523,
          "vulnerability_to_line": null,
          "vulnerability_code": "        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n",
          "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
        },
        {
          "name": "use-abi-encodecall-instead-of-encodewithselector",
          "vulnerability_from_line": 527,
          "vulnerability_to_line": null,
          "vulnerability_code": "        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n",
          "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
        },
        {
          "name": "use-abi-encodecall-instead-of-encodewithselector",
          "vulnerability_from_line": 545,
          "vulnerability_to_line": null,
          "vulnerability_code": "        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n",
          "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
        },
        {
          "name": "use-abi-encodecall-instead-of-encodewithselector",
          "vulnerability_from_line": 550,
          "vulnerability_to_line": null,
          "vulnerability_code": "        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n",
          "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
        },
        {
          "name": "use-abi-encodecall-instead-of-encodewithselector",
          "vulnerability_from_line": 555,
          "vulnerability_to_line": null,
          "vulnerability_code": "        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n",
          "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
        },
        {
          "name": "use-ownable2step",
          "vulnerability_from_line": 743,
          "vulnerability_to_line": null,
          "vulnerability_code": "contract Operator is Context, Ownable {\n",
          "message": "By demanding that the receiver of the owner permissions actively accept via a contract call of its own,  `Ownable2Step` and `Ownable2StepUpgradeable` prevent the contract ownership from accidentally being transferred  to an address that cannot handle it."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 1263,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint8 entryId = 0; entryId < excludedFromTotalSupply.length; ++entryId) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "init-variables-with-default-value",
          "vulnerability_from_line": 876,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bool public initialized = false;\n",
          "message": "Uninitialized variables are assigned with the types default value. Explicitly initializing a variable with its default value costs unnecessary gas."
        },
        {
          "name": "init-variables-with-default-value",
          "vulnerability_from_line": 880,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint256 public epoch = 0;\n",
          "message": "Uninitialized variables are assigned with the types default value. Explicitly initializing a variable with its default value costs unnecessary gas."
        },
        {
          "name": "init-variables-with-default-value",
          "vulnerability_from_line": 881,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint256 public epochSupplyContractionLeft = 0;\n",
          "message": "Uninitialized variables are assigned with the types default value. Explicitly initializing a variable with its default value costs unnecessary gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 748,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor() internal {\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 749,
          "vulnerability_to_line": null,
          "vulnerability_code": "        _operator = _msgSender();\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 750,
          "vulnerability_to_line": null,
          "vulnerability_code": "        emit OperatorTransferred(address(0), _operator);\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 751,
          "vulnerability_to_line": null,
          "vulnerability_code": "    }\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 1263,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint8 entryId = 0; entryId < excludedFromTotalSupply.length; ++entryId) {\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 1264,
          "vulnerability_to_line": null,
          "vulnerability_code": "            balanceExcluded = balanceExcluded.add(darkErc20.balanceOf(excludedFromTotalSupply[entryId]));\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 1263,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint8 entryId = 0; entryId < excludedFromTotalSupply.length; ++entryId) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 192,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(c >= a, \"SafeMath: addition overflow\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 207,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(b <= a, \"SafeMath: subtraction overflow\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 224,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(c / a == b, \"SafeMath: multiplication overflow\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 241,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(b > 0, \"SafeMath: division by zero\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 258,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(b > 0, \"SafeMath: modulo by zero\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 371,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(address(this).balance >= amount, \"Address: insufficient balance\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 375,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(success, \"Address: unable to send value, recipient may have reverted\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 432,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 433,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(isContract(target), \"Address: call to non-contract\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 457,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(isContract(target), \"Address: static call to non-contract\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 481,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(isContract(target), \"Address: delegate call to non-contract\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 542,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require((value == 0) || (token.allowance(address(this), spender) == 0),\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 543,
          "vulnerability_to_line": null,
          "vulnerability_code": "            \"SafeERC20: approve from non-zero to non-zero allowance\"\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 544,
          "vulnerability_to_line": null,
          "vulnerability_code": "        );\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 572,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 624,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 715,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 736,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 758,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_operator == msg.sender, \"operator: caller is not the operator\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 771,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(newOperator_ != address(0), \"operator: zero address given for new operator\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 789,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(!checkSameOriginReentranted(), \"ContractGuard: one block, one function\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 790,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(!checkSameSenderReentranted(), \"ContractGuard: one block, one function\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 956,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(operator == msg.sender, \"Treasury: caller is not the operator\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 961,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(now >= startTime, \"Treasury: not started yet\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 967,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(now >= nextEpochPoint(), \"Treasury: not opened yet\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 976,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 977,
          "vulnerability_to_line": null,
          "vulnerability_code": "            IBasisAsset(dark).operator() == address(this) &&\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 978,
          "vulnerability_to_line": null,
          "vulnerability_code": "                IBasisAsset(light).operator() == address(this) &&\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 979,
          "vulnerability_to_line": null,
          "vulnerability_code": "                IBasisAsset(sky).operator() == address(this) &&\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 980,
          "vulnerability_to_line": null,
          "vulnerability_code": "                Operator(boardroom).operator() == address(this),\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 981,
          "vulnerability_to_line": null,
          "vulnerability_code": "            \"Treasury: need more permission\"\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 982,
          "vulnerability_to_line": null,
          "vulnerability_code": "        );\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 988,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(!initialized, \"Treasury: already initialized\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1009,
          "vulnerability_to_line": null,
          "vulnerability_code": "            revert(\"Treasury: failed to consult DARK price from the oracle\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1017,
          "vulnerability_to_line": null,
          "vulnerability_code": "            revert(\"Treasury: failed to consult DARK price from the oracle\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1143,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_boardroomWithdrawFee <= 20, \"Max withdraw fee is 20%\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1148,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_boardroomStakeFee <= 5, \"Max stake fee is 5%\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1158,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_darkPriceCeiling >= darkPriceOne && _darkPriceCeiling <= darkPriceOne.mul(120).div(100), \"out of range\"); // [$1.0, $1.2]\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1163,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_maxSupplyExpansionPercent >= 10 && _maxSupplyExpansionPercent <= 1000, \"_maxSupplyExpansionPercent: out of range\"); // [0.1%, 10%]\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1168,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_bondDepletionFloorPercent >= 500 && _bondDepletionFloorPercent <= 10000, \"out of range\"); // [5%, 100%]\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1173,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_maxSupplyContractionPercent >= 100 && _maxSupplyContractionPercent <= 1500, \"out of range\"); // [0.1%, 15%]\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1178,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_maxDebtRatioPercent >= 1000 && _maxDebtRatioPercent <= 10000, \"out of range\"); // [10%, 100%]\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1183,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_bootstrapEpochs <= 90, \"_bootstrapEpochs: out of range\"); // <= 1 month\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1184,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_bootstrapSupplyExpansionPercent >= 100 && _bootstrapSupplyExpansionPercent <= 1000, \"_bootstrapSupplyExpansionPercent: out of range\"); // [1%, 10%]\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1197,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_daoFund != address(0), \"zero\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1198,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_daoFundSharedPercent <= 5000, \"out of range\"); // <= 50%\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1199,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_devFund != address(0), \"zero\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1200,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_devFundSharedPercent <= 1000, \"out of range\"); // <= 10%\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1201,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_insuranceFund != address(0), \"zero\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1202,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_insuranceFundSharedPercent <= 1000, \"out of range\"); // <= 10%\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1215,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_allocateSeigniorageSalary <= 10 ether, \"Treasury: dont pay too much\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1228,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_discountPercent <= 20000, \"_discountPercent is over 200%\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1233,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_premiumThreshold >= darkPriceCeiling, \"_premiumThreshold exceeds darkPriceCeiling\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1234,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_premiumThreshold <= 150, \"_premiumThreshold is higher than 1.5\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1239,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_premiumPercent <= 20000, \"_premiumPercent is over 200%\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1244,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_mintingFactorForPayingDebt >= 10000 && _mintingFactorForPayingDebt <= 20000, \"_mintingFactorForPayingDebt: out of range\"); // [100%, 200%]\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1249,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_darkSupplyTarget > getDarkCirculatingSupply(), \"too small\"); // >= current circulating supply\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1270,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_darkAmount > 0, \"Treasury: cannot purchase bonds with zero amount\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1273,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(darkPrice == targetPrice, \"Treasury: DARK price moved\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1274,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1275,
          "vulnerability_to_line": null,
          "vulnerability_code": "            darkPrice < darkPriceOne, // price < $1\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1276,
          "vulnerability_to_line": null,
          "vulnerability_code": "            \"Treasury: darkPrice not eligible for bond purchase\"\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1277,
          "vulnerability_to_line": null,
          "vulnerability_code": "        );\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1279,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_darkAmount <= epochSupplyContractionLeft, \"Treasury: not enough bond left to purchase\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1282,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_rate > 0, \"Treasury: invalid bond rate\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1287,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(newBondSupply <= darkSupply.mul(maxDebtRatioPercent).div(10000), \"over max debt ratio\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1299,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_bondAmount > 0, \"Treasury: cannot redeem bonds with zero amount\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1302,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(darkPrice == targetPrice, \"Treasury: DARK price moved\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1303,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1304,
          "vulnerability_to_line": null,
          "vulnerability_code": "            darkPrice > darkPriceCeiling, // price > $1.01\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1305,
          "vulnerability_to_line": null,
          "vulnerability_code": "            \"Treasury: darkPrice not eligible for bond purchase\"\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1306,
          "vulnerability_to_line": null,
          "vulnerability_code": "        );\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1309,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_rate > 0, \"Treasury: invalid bond rate\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1312,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(IERC20(dark).balanceOf(address(this)) >= _darkAmount, \"Treasury: treasury has no more budget\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1454,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(address(_token) != address(dark), \"dark\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1455,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(address(_token) != address(light), \"light\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1456,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(address(_token) != address(sky), \"share\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 976,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 977,
          "vulnerability_to_line": null,
          "vulnerability_code": "            IBasisAsset(dark).operator() == address(this) &&\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 978,
          "vulnerability_to_line": null,
          "vulnerability_code": "                IBasisAsset(light).operator() == address(this) &&\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 979,
          "vulnerability_to_line": null,
          "vulnerability_code": "                IBasisAsset(sky).operator() == address(this) &&\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 980,
          "vulnerability_to_line": null,
          "vulnerability_code": "                Operator(boardroom).operator() == address(this),\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 981,
          "vulnerability_to_line": null,
          "vulnerability_code": "            \"Treasury: need more permission\"\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 982,
          "vulnerability_to_line": null,
          "vulnerability_code": "        );\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 1158,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_darkPriceCeiling >= darkPriceOne && _darkPriceCeiling <= darkPriceOne.mul(120).div(100), \"out of range\"); // [$1.0, $1.2]\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 1163,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_maxSupplyExpansionPercent >= 10 && _maxSupplyExpansionPercent <= 1000, \"_maxSupplyExpansionPercent: out of range\"); // [0.1%, 10%]\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 1168,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_bondDepletionFloorPercent >= 500 && _bondDepletionFloorPercent <= 10000, \"out of range\"); // [5%, 100%]\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 1173,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_maxSupplyContractionPercent >= 100 && _maxSupplyContractionPercent <= 1500, \"out of range\"); // [0.1%, 15%]\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 1178,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_maxDebtRatioPercent >= 1000 && _maxDebtRatioPercent <= 10000, \"out of range\"); // [10%, 100%]\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 1184,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_bootstrapSupplyExpansionPercent >= 100 && _bootstrapSupplyExpansionPercent <= 1000, \"_bootstrapSupplyExpansionPercent: out of range\"); // [1%, 10%]\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 1244,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_mintingFactorForPayingDebt >= 10000 && _mintingFactorForPayingDebt <= 20000, \"_mintingFactorForPayingDebt: out of range\"); // [100%, 200%]\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 1061,
          "vulnerability_to_line": null,
          "vulnerability_code": "                if (maxDiscountRate > 0 && _rate > maxDiscountRate) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 1062,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    _rate = maxDiscountRate;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 1063,
          "vulnerability_to_line": null,
          "vulnerability_code": "                }\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 1076,
          "vulnerability_to_line": null,
          "vulnerability_code": "                if (maxPremiumRate > 0 && _rate > maxPremiumRate) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 1077,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    _rate = maxPremiumRate;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 1078,
          "vulnerability_to_line": null,
          "vulnerability_code": "                }\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 224,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(c / a == b, \"SafeMath: multiplication overflow\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 375,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(success, \"Address: unable to send value, recipient may have reverted\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 432,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 457,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(isContract(target), \"Address: static call to non-contract\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 481,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(isContract(target), \"Address: delegate call to non-contract\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 542,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require((value == 0) || (token.allowance(address(this), spender) == 0),\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 543,
          "vulnerability_to_line": null,
          "vulnerability_code": "            \"SafeERC20: approve from non-zero to non-zero allowance\"\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 544,
          "vulnerability_to_line": null,
          "vulnerability_code": "        );\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 572,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 736,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 758,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_operator == msg.sender, \"operator: caller is not the operator\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 771,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(newOperator_ != address(0), \"operator: zero address given for new operator\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 789,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(!checkSameOriginReentranted(), \"ContractGuard: one block, one function\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 790,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(!checkSameSenderReentranted(), \"ContractGuard: one block, one function\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 956,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(operator == msg.sender, \"Treasury: caller is not the operator\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 1009,
          "vulnerability_to_line": null,
          "vulnerability_code": "            revert(\"Treasury: failed to consult DARK price from the oracle\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 1017,
          "vulnerability_to_line": null,
          "vulnerability_code": "            revert(\"Treasury: failed to consult DARK price from the oracle\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 1163,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_maxSupplyExpansionPercent >= 10 && _maxSupplyExpansionPercent <= 1000, \"_maxSupplyExpansionPercent: out of range\"); // [0.1%, 10%]\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 1184,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_bootstrapSupplyExpansionPercent >= 100 && _bootstrapSupplyExpansionPercent <= 1000, \"_bootstrapSupplyExpansionPercent: out of range\"); // [1%, 10%]\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 1233,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_premiumThreshold >= darkPriceCeiling, \"_premiumThreshold exceeds darkPriceCeiling\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 1234,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_premiumThreshold <= 150, \"_premiumThreshold is higher than 1.5\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 1244,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_mintingFactorForPayingDebt >= 10000 && _mintingFactorForPayingDebt <= 20000, \"_mintingFactorForPayingDebt: out of range\"); // [100%, 200%]\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 1270,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_darkAmount > 0, \"Treasury: cannot purchase bonds with zero amount\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 1274,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 1275,
          "vulnerability_to_line": null,
          "vulnerability_code": "            darkPrice < darkPriceOne, // price < $1\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 1276,
          "vulnerability_to_line": null,
          "vulnerability_code": "            \"Treasury: darkPrice not eligible for bond purchase\"\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 1277,
          "vulnerability_to_line": null,
          "vulnerability_code": "        );\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 1279,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_darkAmount <= epochSupplyContractionLeft, \"Treasury: not enough bond left to purchase\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 1299,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_bondAmount > 0, \"Treasury: cannot redeem bonds with zero amount\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 1303,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 1304,
          "vulnerability_to_line": null,
          "vulnerability_code": "            darkPrice > darkPriceCeiling, // price > $1.01\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 1305,
          "vulnerability_to_line": null,
          "vulnerability_code": "            \"Treasury: darkPrice not eligible for bond purchase\"\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 1306,
          "vulnerability_to_line": null,
          "vulnerability_code": "        );\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 1312,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(IERC20(dark).balanceOf(address(this)) >= _darkAmount, \"Treasury: treasury has no more budget\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        }
      ]
    },
    "slither": {
      "successfull_analysis": false,
      "errors": [
        "EXIT_CODE_255",
        "error parsing results: file could not be opened successfully"
      ],
      "vulnerability_findings": []
    },
    "smartcheck": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 885,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address(0x28d81863438F25b6EC4c9DA28348445FC5E44196) // DarkRewardPool\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 728,
          "vulnerability_to_line": null,
          "vulnerability_code": "        _owner = address(0);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 1263,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint8 entryId = 0; entryId < excludedFromTotalSupply.length; ++entryId) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 1263,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint8 entryId = 0; entryId < excludedFromTotalSupply.length; ++entryId) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 642,
          "vulnerability_to_line": null,
          "vulnerability_code": "            while (x < z) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 606,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint256 private constant _NOT_ENTERED = 1;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 607,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint256 private constant _ENTERED = 2;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 609,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint256 private _status;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 691,
          "vulnerability_to_line": null,
          "vulnerability_code": "    address private _owner;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 744,
          "vulnerability_to_line": null,
          "vulnerability_code": "    address private _operator;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 778,
          "vulnerability_to_line": null,
          "vulnerability_code": "    mapping(uint256 => mapping(address => bool)) private _status;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SAFEMATH",
          "vulnerability_from_line": 519,
          "vulnerability_to_line": null,
          "vulnerability_code": "    using SafeMath for uint256;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SAFEMATH",
          "vulnerability_from_line": 865,
          "vulnerability_to_line": null,
          "vulnerability_code": "    using SafeMath for uint256;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
          "vulnerability_from_line": 343,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function isContract(address account) internal view returns (bool) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 129,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 140,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 150,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 165,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 175,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_TX_ORIGIN",
          "vulnerability_from_line": 781,
          "vulnerability_to_line": null,
          "vulnerability_code": "        return _status[block.number][tx.origin];\n",
          "message": null
        },
        {
          "name": "SOLIDITY_TX_ORIGIN",
          "vulnerability_from_line": 792,
          "vulnerability_to_line": null,
          "vulnerability_code": "        _status[block.number][tx.origin] = true;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UNCHECKED_CALL",
          "vulnerability_from_line": 523,
          "vulnerability_to_line": null,
          "vulnerability_code": "        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UNCHECKED_CALL",
          "vulnerability_from_line": 527,
          "vulnerability_to_line": null,
          "vulnerability_code": "        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UNCHECKED_CALL",
          "vulnerability_from_line": 545,
          "vulnerability_to_line": null,
          "vulnerability_code": "        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UNCHECKED_CALL",
          "vulnerability_from_line": 550,
          "vulnerability_to_line": null,
          "vulnerability_code": "        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UNCHECKED_CALL",
          "vulnerability_from_line": 555,
          "vulnerability_to_line": null,
          "vulnerability_code": "        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 370,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function sendValue(address payable recipient, uint256 amount) internal {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 370,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function sendValue(address payable recipient, uint256 amount) internal {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 370,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function sendValue(address payable recipient, uint256 amount) internal {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 371,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(address(this).balance >= amount, \"Address: insufficient balance\");\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 371,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(address(this).balance >= amount, \"Address: insufficient balance\");\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 371,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(address(this).balance >= amount, \"Address: insufficient balance\");\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 371,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(address(this).balance >= amount, \"Address: insufficient balance\");\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 374,
          "vulnerability_to_line": null,
          "vulnerability_code": "        (bool success, ) = recipient.call{ value: amount }(\"\");\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 374,
          "vulnerability_to_line": null,
          "vulnerability_code": "        (bool success, ) = recipient.call{ value: amount }(\"\");\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 374,
          "vulnerability_to_line": null,
          "vulnerability_code": "        (bool success, ) = recipient.call{ value: amount }(\"\");\n",
          "message": null
        }
      ]
    },
    "oyente": {
      "successfull_analysis": false,
      "errors": [
        "exception (IndexError: pop from empty list)"
      ],
      "vulnerability_findings": []
    },
    "mythril": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "Dependence on tx.origin (SWC 115)",
          "vulnerability_from_line": 956,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(operator == msg.sender, \"Treasury: caller is not the operator\");\n",
          "message": "Use of tx.origin as a part of authorization control.\nThe tx.origin environment variable has been found to influence a control flow decision. Note that using tx.origin as a security control might cause a situation where a user inadvertently authorizes a smart contract to perform an action on their behalf. It is recommended to use msg.sender instead.\nClassification: SWC-115"
        },
        {
          "name": "Dependence on tx.origin (SWC 115)",
          "vulnerability_from_line": 956,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(operator == msg.sender, \"Treasury: caller is not the operator\");\n",
          "message": "Use of tx.origin as a part of authorization control.\nThe tx.origin environment variable has been found to influence a control flow decision. Note that using tx.origin as a security control might cause a situation where a user inadvertently authorizes a smart contract to perform an action on their behalf. It is recommended to use msg.sender instead.\nClassification: SWC-115"
        },
        {
          "name": "Dependence on tx.origin (SWC 115)",
          "vulnerability_from_line": 956,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(operator == msg.sender, \"Treasury: caller is not the operator\");\n",
          "message": "Use of tx.origin as a part of authorization control.\nThe tx.origin environment variable has been found to influence a control flow decision. Note that using tx.origin as a security control might cause a situation where a user inadvertently authorizes a smart contract to perform an action on their behalf. It is recommended to use msg.sender instead.\nClassification: SWC-115"
        },
        {
          "name": "Dependence on predictable environment variable (SWC 116)",
          "vulnerability_from_line": 961,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(now >= startTime, \"Treasury: not started yet\");\n",
          "message": "A control flow decision is made based on The block.timestamp environment variable.\nThe block.timestamp environment variable is used to determine a control flow decision. Note that the values of variables like coinbase, gaslimit, block number and timestamp are predictable and can be manipulated by a malicious miner. Also keep in mind that attackers know hashes of earlier blocks. Don't use any of those environment variables as sources of randomness and be aware that use of these variables introduces a certain level of trust into miners.\nClassification: SWC-116"
        },
        {
          "name": "Dependence on tx.origin (SWC 115)",
          "vulnerability_from_line": 956,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(operator == msg.sender, \"Treasury: caller is not the operator\");\n",
          "message": "Use of tx.origin as a part of authorization control.\nThe tx.origin environment variable has been found to influence a control flow decision. Note that using tx.origin as a security control might cause a situation where a user inadvertently authorizes a smart contract to perform an action on their behalf. It is recommended to use msg.sender instead.\nClassification: SWC-115"
        },
        {
          "name": "Dependence on tx.origin (SWC 115)",
          "vulnerability_from_line": 956,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(operator == msg.sender, \"Treasury: caller is not the operator\");\n",
          "message": "Use of tx.origin as a part of authorization control.\nThe tx.origin environment variable has been found to influence a control flow decision. Note that using tx.origin as a security control might cause a situation where a user inadvertently authorizes a smart contract to perform an action on their behalf. It is recommended to use msg.sender instead.\nClassification: SWC-115"
        },
        {
          "name": "Dependence on tx.origin (SWC 115)",
          "vulnerability_from_line": 956,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(operator == msg.sender, \"Treasury: caller is not the operator\");\n",
          "message": "Use of tx.origin as a part of authorization control.\nThe tx.origin environment variable has been found to influence a control flow decision. Note that using tx.origin as a security control might cause a situation where a user inadvertently authorizes a smart contract to perform an action on their behalf. It is recommended to use msg.sender instead.\nClassification: SWC-115"
        },
        {
          "name": "Dependence on tx.origin (SWC 115)",
          "vulnerability_from_line": 956,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(operator == msg.sender, \"Treasury: caller is not the operator\");\n",
          "message": "Use of tx.origin as a part of authorization control.\nThe tx.origin environment variable has been found to influence a control flow decision. Note that using tx.origin as a security control might cause a situation where a user inadvertently authorizes a smart contract to perform an action on their behalf. It is recommended to use msg.sender instead.\nClassification: SWC-115"
        },
        {
          "name": "Dependence on tx.origin (SWC 115)",
          "vulnerability_from_line": 956,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(operator == msg.sender, \"Treasury: caller is not the operator\");\n",
          "message": "Use of tx.origin as a part of authorization control.\nThe tx.origin environment variable has been found to influence a control flow decision. Note that using tx.origin as a security control might cause a situation where a user inadvertently authorizes a smart contract to perform an action on their behalf. It is recommended to use msg.sender instead.\nClassification: SWC-115"
        },
        {
          "name": "Dependence on tx.origin (SWC 115)",
          "vulnerability_from_line": 956,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(operator == msg.sender, \"Treasury: caller is not the operator\");\n",
          "message": "Use of tx.origin as a part of authorization control.\nThe tx.origin environment variable has been found to influence a control flow decision. Note that using tx.origin as a security control might cause a situation where a user inadvertently authorizes a smart contract to perform an action on their behalf. It is recommended to use msg.sender instead.\nClassification: SWC-115"
        },
        {
          "name": "Dependence on tx.origin (SWC 115)",
          "vulnerability_from_line": 956,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(operator == msg.sender, \"Treasury: caller is not the operator\");\n",
          "message": "Use of tx.origin as a part of authorization control.\nThe tx.origin environment variable has been found to influence a control flow decision. Note that using tx.origin as a security control might cause a situation where a user inadvertently authorizes a smart contract to perform an action on their behalf. It is recommended to use msg.sender instead.\nClassification: SWC-115"
        },
        {
          "name": "Dependence on tx.origin (SWC 115)",
          "vulnerability_from_line": 956,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(operator == msg.sender, \"Treasury: caller is not the operator\");\n",
          "message": "Use of tx.origin as a part of authorization control.\nThe tx.origin environment variable has been found to influence a control flow decision. Note that using tx.origin as a security control might cause a situation where a user inadvertently authorizes a smart contract to perform an action on their behalf. It is recommended to use msg.sender instead.\nClassification: SWC-115"
        },
        {
          "name": "Dependence on predictable environment variable (SWC 116)",
          "vulnerability_from_line": 961,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(now >= startTime, \"Treasury: not started yet\");\n",
          "message": "A control flow decision is made based on The block.timestamp environment variable.\nThe block.timestamp environment variable is used to determine a control flow decision. Note that the values of variables like coinbase, gaslimit, block number and timestamp are predictable and can be manipulated by a malicious miner. Also keep in mind that attackers know hashes of earlier blocks. Don't use any of those environment variables as sources of randomness and be aware that use of these variables introduces a certain level of trust into miners.\nClassification: SWC-116"
        },
        {
          "name": "Dependence on tx.origin (SWC 115)",
          "vulnerability_from_line": 956,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(operator == msg.sender, \"Treasury: caller is not the operator\");\n",
          "message": "Use of tx.origin as a part of authorization control.\nThe tx.origin environment variable has been found to influence a control flow decision. Note that using tx.origin as a security control might cause a situation where a user inadvertently authorizes a smart contract to perform an action on their behalf. It is recommended to use msg.sender instead.\nClassification: SWC-115"
        },
        {
          "name": "Dependence on predictable environment variable (SWC 116)",
          "vulnerability_from_line": 961,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(now >= startTime, \"Treasury: not started yet\");\n",
          "message": "A control flow decision is made based on The block.timestamp environment variable.\nThe block.timestamp environment variable is used to determine a control flow decision. Note that the values of variables like coinbase, gaslimit, block number and timestamp are predictable and can be manipulated by a malicious miner. Also keep in mind that attackers know hashes of earlier blocks. Don't use any of those environment variables as sources of randomness and be aware that use of these variables introduces a certain level of trust into miners.\nClassification: SWC-116"
        },
        {
          "name": "Dependence on predictable environment variable (SWC 116)",
          "vulnerability_from_line": 967,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(now >= nextEpochPoint(), \"Treasury: not opened yet\");\n",
          "message": "A control flow decision is made based on The block.timestamp environment variable.\nThe block.timestamp environment variable is used to determine a control flow decision. Note that the values of variables like coinbase, gaslimit, block number and timestamp are predictable and can be manipulated by a malicious miner. Also keep in mind that attackers know hashes of earlier blocks. Don't use any of those environment variables as sources of randomness and be aware that use of these variables introduces a certain level of trust into miners.\nClassification: SWC-116"
        },
        {
          "name": "Multiple Calls in a Single Transaction (SWC 113)",
          "vulnerability_from_line": 978,
          "vulnerability_to_line": null,
          "vulnerability_code": "                IBasisAsset(light).operator() == address(this) &&\n",
          "message": "Multiple calls are executed in the same transaction.\nThis call is executed following another call within the same transaction. It is possible that the call never gets executed if a prior call fails permanently. This might be caused intentionally by a malicious callee. If possible, refactor the code such that each transaction only executes one external call or make sure that all callees can be trusted (i.e. they\u2019re part of your own codebase).\nClassification: SWC-113"
        },
        {
          "name": "State access after external call (SWC 107)",
          "vulnerability_from_line": 1399,
          "vulnerability_to_line": null,
          "vulnerability_code": "        previousEpochDarkPrice = getDarkPrice();\n",
          "message": "Write to persistent state following external call\nThe contract account state is accessed after an external call to a fixed address. To prevent reentrancy issues, consider accessing the state only before the call, especially if the callee is untrusted. Alternatively, a reentrancy lock can be used to prevent untrusted callees from re-entering the contract in an intermediate state.\nClassification: SWC-107"
        },
        {
          "name": "State access after external call (SWC 107)",
          "vulnerability_from_line": 1400,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint256 darkSupply = getDarkCirculatingSupply().sub(seigniorageSaved);\n",
          "message": "Read of persistent state following external call\nThe contract account state is accessed after an external call to a fixed address. To prevent reentrancy issues, consider accessing the state only before the call, especially if the callee is untrusted. Alternatively, a reentrancy lock can be used to prevent untrusted callees from re-entering the contract in an intermediate state.\nClassification: SWC-107"
        },
        {
          "name": "State access after external call (SWC 107)",
          "vulnerability_from_line": 1401,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (epoch < bootstrapEpochs) {\n",
          "message": "Read of persistent state following external call\nThe contract account state is accessed after an external call to a fixed address. To prevent reentrancy issues, consider accessing the state only before the call, especially if the callee is untrusted. Alternatively, a reentrancy lock can be used to prevent untrusted callees from re-entering the contract in an intermediate state.\nClassification: SWC-107"
        },
        {
          "name": "State access after external call (SWC 107)",
          "vulnerability_from_line": 1401,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (epoch < bootstrapEpochs) {\n",
          "message": "Read of persistent state following external call\nThe contract account state is accessed after an external call to a fixed address. To prevent reentrancy issues, consider accessing the state only before the call, especially if the callee is untrusted. Alternatively, a reentrancy lock can be used to prevent untrusted callees from re-entering the contract in an intermediate state.\nClassification: SWC-107"
        },
        {
          "name": "State access after external call (SWC 107)",
          "vulnerability_from_line": 1406,
          "vulnerability_to_line": null,
          "vulnerability_code": "            if (previousEpochDarkPrice >= darkPriceCeiling) {\n",
          "message": "Read of persistent state following external call\nThe contract account state is accessed after an external call to a fixed address. To prevent reentrancy issues, consider accessing the state only before the call, especially if the callee is untrusted. Alternatively, a reentrancy lock can be used to prevent untrusted callees from re-entering the contract in an intermediate state.\nClassification: SWC-107"
        },
        {
          "name": "State access after external call (SWC 107)",
          "vulnerability_from_line": 1406,
          "vulnerability_to_line": null,
          "vulnerability_code": "            if (previousEpochDarkPrice >= darkPriceCeiling) {\n",
          "message": "Read of persistent state following external call\nThe contract account state is accessed after an external call to a fixed address. To prevent reentrancy issues, consider accessing the state only before the call, especially if the callee is untrusted. Alternatively, a reentrancy lock can be used to prevent untrusted callees from re-entering the contract in an intermediate state.\nClassification: SWC-107"
        },
        {
          "name": "State access after external call (SWC 107)",
          "vulnerability_from_line": 1407,
          "vulnerability_to_line": null,
          "vulnerability_code": "                IBoardroom(boardroom).setWithdrawFee(0);\n",
          "message": "Read of persistent state following external call\nThe contract account state is accessed after an external call to a fixed address. To prevent reentrancy issues, consider accessing the state only before the call, especially if the callee is untrusted. Alternatively, a reentrancy lock can be used to prevent untrusted callees from re-entering the contract in an intermediate state.\nClassification: SWC-107"
        },
        {
          "name": "State access after external call (SWC 107)",
          "vulnerability_from_line": 1407,
          "vulnerability_to_line": null,
          "vulnerability_code": "                IBoardroom(boardroom).setWithdrawFee(0);\n",
          "message": "Write to persistent state following external call\nThe contract account state is accessed after an external call to a fixed address. To prevent reentrancy issues, consider accessing the state only before the call, especially if the callee is untrusted. Alternatively, a reentrancy lock can be used to prevent untrusted callees from re-entering the contract in an intermediate state.\nClassification: SWC-107"
        },
        {
          "name": "State access after external call (SWC 107)",
          "vulnerability_from_line": 1409,
          "vulnerability_to_line": null,
          "vulnerability_code": "                uint256 bondSupply = IERC20(light).totalSupply();\n",
          "message": "Read of persistent state following external call\nThe contract account state is accessed after an external call to a fixed address. To prevent reentrancy issues, consider accessing the state only before the call, especially if the callee is untrusted. Alternatively, a reentrancy lock can be used to prevent untrusted callees from re-entering the contract in an intermediate state.\nClassification: SWC-107"
        },
        {
          "name": "State access after external call (SWC 107)",
          "vulnerability_from_line": 1410,
          "vulnerability_to_line": null,
          "vulnerability_code": "                uint256 _percentage = previousEpochDarkPrice.sub(darkPriceOne);\n",
          "message": "Read of persistent state following external call\nThe contract account state is accessed after an external call to a fixed address. To prevent reentrancy issues, consider accessing the state only before the call, especially if the callee is untrusted. Alternatively, a reentrancy lock can be used to prevent untrusted callees from re-entering the contract in an intermediate state.\nClassification: SWC-107"
        },
        {
          "name": "State access after external call (SWC 107)",
          "vulnerability_from_line": 1410,
          "vulnerability_to_line": null,
          "vulnerability_code": "                uint256 _percentage = previousEpochDarkPrice.sub(darkPriceOne);\n",
          "message": "Read of persistent state following external call\nThe contract account state is accessed after an external call to a fixed address. To prevent reentrancy issues, consider accessing the state only before the call, especially if the callee is untrusted. Alternatively, a reentrancy lock can be used to prevent untrusted callees from re-entering the contract in an intermediate state.\nClassification: SWC-107"
        },
        {
          "name": "State access after external call (SWC 107)",
          "vulnerability_from_line": 1417,
          "vulnerability_to_line": null,
          "vulnerability_code": "                if (seigniorageSaved >= bondSupply.mul(bondDepletionFloorPercent).div(10000)) {\n",
          "message": "Read of persistent state following external call\nThe contract account state is accessed after an external call to a fixed address. To prevent reentrancy issues, consider accessing the state only before the call, especially if the callee is untrusted. Alternatively, a reentrancy lock can be used to prevent untrusted callees from re-entering the contract in an intermediate state.\nClassification: SWC-107"
        },
        {
          "name": "State access after external call (SWC 107)",
          "vulnerability_from_line": 1417,
          "vulnerability_to_line": null,
          "vulnerability_code": "                if (seigniorageSaved >= bondSupply.mul(bondDepletionFloorPercent).div(10000)) {\n",
          "message": "Read of persistent state following external call\nThe contract account state is accessed after an external call to a fixed address. To prevent reentrancy issues, consider accessing the state only before the call, especially if the callee is untrusted. Alternatively, a reentrancy lock can be used to prevent untrusted callees from re-entering the contract in an intermediate state.\nClassification: SWC-107"
        },
        {
          "name": "State access after external call (SWC 107)",
          "vulnerability_from_line": 1437,
          "vulnerability_to_line": null,
          "vulnerability_code": "                emit Seigniorage(epoch, previousEpochDarkPrice, _savedForBoardroom);\n",
          "message": "Read of persistent state following external call\nThe contract account state is accessed after an external call to a fixed address. To prevent reentrancy issues, consider accessing the state only before the call, especially if the callee is untrusted. Alternatively, a reentrancy lock can be used to prevent untrusted callees from re-entering the contract in an intermediate state.\nClassification: SWC-107"
        },
        {
          "name": "State access after external call (SWC 107)",
          "vulnerability_from_line": 1437,
          "vulnerability_to_line": null,
          "vulnerability_code": "                emit Seigniorage(epoch, previousEpochDarkPrice, _savedForBoardroom);\n",
          "message": "Read of persistent state following external call\nThe contract account state is accessed after an external call to a fixed address. To prevent reentrancy issues, consider accessing the state only before the call, especially if the callee is untrusted. Alternatively, a reentrancy lock can be used to prevent untrusted callees from re-entering the contract in an intermediate state.\nClassification: SWC-107"
        },
        {
          "name": "State access after external call (SWC 107)",
          "vulnerability_from_line": 1443,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (allocateSeigniorageSalary > 0) {\n",
          "message": "Read of persistent state following external call\nThe contract account state is accessed after an external call to a fixed address. To prevent reentrancy issues, consider accessing the state only before the call, especially if the callee is untrusted. Alternatively, a reentrancy lock can be used to prevent untrusted callees from re-entering the contract in an intermediate state.\nClassification: SWC-107"
        },
        {
          "name": "State access after external call (SWC 107)",
          "vulnerability_from_line": 971,
          "vulnerability_to_line": null,
          "vulnerability_code": "        epoch = epoch.add(1);\n",
          "message": "Read of persistent state following external call\nThe contract account state is accessed after an external call to a fixed address. To prevent reentrancy issues, consider accessing the state only before the call, especially if the callee is untrusted. Alternatively, a reentrancy lock can be used to prevent untrusted callees from re-entering the contract in an intermediate state.\nClassification: SWC-107"
        },
        {
          "name": "State access after external call (SWC 107)",
          "vulnerability_from_line": 971,
          "vulnerability_to_line": null,
          "vulnerability_code": "        epoch = epoch.add(1);\n",
          "message": "Write to persistent state following external call\nThe contract account state is accessed after an external call to a fixed address. To prevent reentrancy issues, consider accessing the state only before the call, especially if the callee is untrusted. Alternatively, a reentrancy lock can be used to prevent untrusted callees from re-entering the contract in an intermediate state.\nClassification: SWC-107"
        },
        {
          "name": "State access after external call (SWC 107)",
          "vulnerability_from_line": 972,
          "vulnerability_to_line": null,
          "vulnerability_code": "        epochSupplyContractionLeft = (getDarkPrice() > darkPriceCeiling) ? 0 : getDarkCirculatingSupply().mul(maxSupplyContractionPercent).div(10000);\n",
          "message": "Read of persistent state following external call\nThe contract account state is accessed after an external call to a fixed address. To prevent reentrancy issues, consider accessing the state only before the call, especially if the callee is untrusted. Alternatively, a reentrancy lock can be used to prevent untrusted callees from re-entering the contract in an intermediate state.\nClassification: SWC-107"
        },
        {
          "name": "State access after external call (SWC 107)",
          "vulnerability_from_line": 972,
          "vulnerability_to_line": null,
          "vulnerability_code": "        epochSupplyContractionLeft = (getDarkPrice() > darkPriceCeiling) ? 0 : getDarkCirculatingSupply().mul(maxSupplyContractionPercent).div(10000);\n",
          "message": "Read of persistent state following external call\nThe contract account state is accessed after an external call to a fixed address. To prevent reentrancy issues, consider accessing the state only before the call, especially if the callee is untrusted. Alternatively, a reentrancy lock can be used to prevent untrusted callees from re-entering the contract in an intermediate state.\nClassification: SWC-107"
        },
        {
          "name": "State access after external call (SWC 107)",
          "vulnerability_from_line": 972,
          "vulnerability_to_line": null,
          "vulnerability_code": "        epochSupplyContractionLeft = (getDarkPrice() > darkPriceCeiling) ? 0 : getDarkCirculatingSupply().mul(maxSupplyContractionPercent).div(10000);\n",
          "message": "Write to persistent state following external call\nThe contract account state is accessed after an external call to a fixed address. To prevent reentrancy issues, consider accessing the state only before the call, especially if the callee is untrusted. Alternatively, a reentrancy lock can be used to prevent untrusted callees from re-entering the contract in an intermediate state.\nClassification: SWC-107"
        },
        {
          "name": "State access after external call (SWC 107)",
          "vulnerability_from_line": 1006,
          "vulnerability_to_line": null,
          "vulnerability_code": "        try IOracle(darkOracle).consult(dark, 1e18) returns (uint144 price) {\n",
          "message": "Read of persistent state following external call\nThe contract account state is accessed after an external call to a fixed address. To prevent reentrancy issues, consider accessing the state only before the call, especially if the callee is untrusted. Alternatively, a reentrancy lock can be used to prevent untrusted callees from re-entering the contract in an intermediate state.\nClassification: SWC-107"
        },
        {
          "name": "State access after external call (SWC 107)",
          "vulnerability_from_line": 1006,
          "vulnerability_to_line": null,
          "vulnerability_code": "        try IOracle(darkOracle).consult(dark, 1e18) returns (uint144 price) {\n",
          "message": "Read of persistent state following external call\nThe contract account state is accessed after an external call to a fixed address. To prevent reentrancy issues, consider accessing the state only before the call, especially if the callee is untrusted. Alternatively, a reentrancy lock can be used to prevent untrusted callees from re-entering the contract in an intermediate state.\nClassification: SWC-107"
        },
        {
          "name": "Exception State (SWC 110)",
          "vulnerability_from_line": 884,
          "vulnerability_to_line": null,
          "vulnerability_code": "    address[] public excludedFromTotalSupply = [\n",
          "message": "An assertion violation was triggered.\nIt is possible to trigger an assertion violation. Note that Solidity assert() statements should only be used to check invariants. Review the transaction trace generated for this issue and either make sure your program logic is correct, or use require() instead of assert() if your goal is to constrain user inputs or enforce preconditions. Remember to validate inputs from both callers (for instance, via passed arguments) and callees (for instance, via return values).\nClassification: SWC-110"
        },
        {
          "name": "Dependence on tx.origin (SWC 115)",
          "vulnerability_from_line": 956,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(operator == msg.sender, \"Treasury: caller is not the operator\");\n",
          "message": "Use of tx.origin as a part of authorization control.\nThe tx.origin environment variable has been found to influence a control flow decision. Note that using tx.origin as a security control might cause a situation where a user inadvertently authorizes a smart contract to perform an action on their behalf. It is recommended to use msg.sender instead.\nClassification: SWC-115"
        },
        {
          "name": "Dependence on tx.origin (SWC 115)",
          "vulnerability_from_line": 956,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(operator == msg.sender, \"Treasury: caller is not the operator\");\n",
          "message": "Use of tx.origin as a part of authorization control.\nThe tx.origin environment variable has been found to influence a control flow decision. Note that using tx.origin as a security control might cause a situation where a user inadvertently authorizes a smart contract to perform an action on their behalf. It is recommended to use msg.sender instead.\nClassification: SWC-115"
        },
        {
          "name": "Dependence on tx.origin (SWC 115)",
          "vulnerability_from_line": 956,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(operator == msg.sender, \"Treasury: caller is not the operator\");\n",
          "message": "Use of tx.origin as a part of authorization control.\nThe tx.origin environment variable has been found to influence a control flow decision. Note that using tx.origin as a security control might cause a situation where a user inadvertently authorizes a smart contract to perform an action on their behalf. It is recommended to use msg.sender instead.\nClassification: SWC-115"
        },
        {
          "name": "Dependence on tx.origin (SWC 115)",
          "vulnerability_from_line": 956,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(operator == msg.sender, \"Treasury: caller is not the operator\");\n",
          "message": "Use of tx.origin as a part of authorization control.\nThe tx.origin environment variable has been found to influence a control flow decision. Note that using tx.origin as a security control might cause a situation where a user inadvertently authorizes a smart contract to perform an action on their behalf. It is recommended to use msg.sender instead.\nClassification: SWC-115"
        },
        {
          "name": "Dependence on tx.origin (SWC 115)",
          "vulnerability_from_line": 956,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(operator == msg.sender, \"Treasury: caller is not the operator\");\n",
          "message": "Use of tx.origin as a part of authorization control.\nThe tx.origin environment variable has been found to influence a control flow decision. Note that using tx.origin as a security control might cause a situation where a user inadvertently authorizes a smart contract to perform an action on their behalf. It is recommended to use msg.sender instead.\nClassification: SWC-115"
        },
        {
          "name": "Dependence on tx.origin (SWC 115)",
          "vulnerability_from_line": 956,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(operator == msg.sender, \"Treasury: caller is not the operator\");\n",
          "message": "Use of tx.origin as a part of authorization control.\nThe tx.origin environment variable has been found to influence a control flow decision. Note that using tx.origin as a security control might cause a situation where a user inadvertently authorizes a smart contract to perform an action on their behalf. It is recommended to use msg.sender instead.\nClassification: SWC-115"
        },
        {
          "name": "Dependence on tx.origin (SWC 115)",
          "vulnerability_from_line": 956,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(operator == msg.sender, \"Treasury: caller is not the operator\");\n",
          "message": "Use of tx.origin as a part of authorization control.\nThe tx.origin environment variable has been found to influence a control flow decision. Note that using tx.origin as a security control might cause a situation where a user inadvertently authorizes a smart contract to perform an action on their behalf. It is recommended to use msg.sender instead.\nClassification: SWC-115"
        },
        {
          "name": "Dependence on tx.origin (SWC 115)",
          "vulnerability_from_line": 956,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(operator == msg.sender, \"Treasury: caller is not the operator\");\n",
          "message": "Use of tx.origin as a part of authorization control.\nThe tx.origin environment variable has been found to influence a control flow decision. Note that using tx.origin as a security control might cause a situation where a user inadvertently authorizes a smart contract to perform an action on their behalf. It is recommended to use msg.sender instead.\nClassification: SWC-115"
        },
        {
          "name": "State access after external call (SWC 107)",
          "vulnerability_from_line": 1260,
          "vulnerability_to_line": null,
          "vulnerability_code": "        IERC20 darkErc20 = IERC20(dark);\n",
          "message": "Read of persistent state following external call\nThe contract account state is accessed after an external call to a fixed address. To prevent reentrancy issues, consider accessing the state only before the call, especially if the callee is untrusted. Alternatively, a reentrancy lock can be used to prevent untrusted callees from re-entering the contract in an intermediate state.\nClassification: SWC-107"
        },
        {
          "name": "State access after external call (SWC 107)",
          "vulnerability_from_line": 1263,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint8 entryId = 0; entryId < excludedFromTotalSupply.length; ++entryId) {\n",
          "message": "Read of persistent state following external call\nThe contract account state is accessed after an external call to a fixed address. To prevent reentrancy issues, consider accessing the state only before the call, especially if the callee is untrusted. Alternatively, a reentrancy lock can be used to prevent untrusted callees from re-entering the contract in an intermediate state.\nClassification: SWC-107"
        },
        {
          "name": "State access after external call (SWC 107)",
          "vulnerability_from_line": 1264,
          "vulnerability_to_line": null,
          "vulnerability_code": "            balanceExcluded = balanceExcluded.add(darkErc20.balanceOf(excludedFromTotalSupply[entryId]));\n",
          "message": "Read of persistent state following external call\nThe contract account state is accessed after an external call to a fixed address. To prevent reentrancy issues, consider accessing the state only before the call, especially if the callee is untrusted. Alternatively, a reentrancy lock can be used to prevent untrusted callees from re-entering the contract in an intermediate state.\nClassification: SWC-107"
        },
        {
          "name": "State access after external call (SWC 107)",
          "vulnerability_from_line": 1264,
          "vulnerability_to_line": null,
          "vulnerability_code": "            balanceExcluded = balanceExcluded.add(darkErc20.balanceOf(excludedFromTotalSupply[entryId]));\n",
          "message": "Read of persistent state following external call\nThe contract account state is accessed after an external call to a fixed address. To prevent reentrancy issues, consider accessing the state only before the call, especially if the callee is untrusted. Alternatively, a reentrancy lock can be used to prevent untrusted callees from re-entering the contract in an intermediate state.\nClassification: SWC-107"
        },
        {
          "name": "Dependence on tx.origin (SWC 115)",
          "vulnerability_from_line": 956,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(operator == msg.sender, \"Treasury: caller is not the operator\");\n",
          "message": "Use of tx.origin as a part of authorization control.\nThe tx.origin environment variable has been found to influence a control flow decision. Note that using tx.origin as a security control might cause a situation where a user inadvertently authorizes a smart contract to perform an action on their behalf. It is recommended to use msg.sender instead.\nClassification: SWC-115"
        },
        {
          "name": "Dependence on tx.origin (SWC 115)",
          "vulnerability_from_line": 956,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(operator == msg.sender, \"Treasury: caller is not the operator\");\n",
          "message": "Use of tx.origin as a part of authorization control.\nThe tx.origin environment variable has been found to influence a control flow decision. Note that using tx.origin as a security control might cause a situation where a user inadvertently authorizes a smart contract to perform an action on their behalf. It is recommended to use msg.sender instead.\nClassification: SWC-115"
        },
        {
          "name": "Dependence on tx.origin (SWC 115)",
          "vulnerability_from_line": 956,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(operator == msg.sender, \"Treasury: caller is not the operator\");\n",
          "message": "Use of tx.origin as a part of authorization control.\nThe tx.origin environment variable has been found to influence a control flow decision. Note that using tx.origin as a security control might cause a situation where a user inadvertently authorizes a smart contract to perform an action on their behalf. It is recommended to use msg.sender instead.\nClassification: SWC-115"
        },
        {
          "name": "Dependence on tx.origin (SWC 115)",
          "vulnerability_from_line": 956,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(operator == msg.sender, \"Treasury: caller is not the operator\");\n",
          "message": "Use of tx.origin as a part of authorization control.\nThe tx.origin environment variable has been found to influence a control flow decision. Note that using tx.origin as a security control might cause a situation where a user inadvertently authorizes a smart contract to perform an action on their behalf. It is recommended to use msg.sender instead.\nClassification: SWC-115"
        },
        {
          "name": "State access after external call (SWC 107)",
          "vulnerability_from_line": 1357,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (_darkSupply >= darkSupplyTarget) {\n",
          "message": "Read of persistent state following external call\nThe contract account state is accessed after an external call to a fixed address. To prevent reentrancy issues, consider accessing the state only before the call, especially if the callee is untrusted. Alternatively, a reentrancy lock can be used to prevent untrusted callees from re-entering the contract in an intermediate state.\nClassification: SWC-107"
        },
        {
          "name": "State access after external call (SWC 107)",
          "vulnerability_from_line": 1358,
          "vulnerability_to_line": null,
          "vulnerability_code": "            darkSupplyTarget = darkSupplyTarget.mul(12500).div(10000); // +25%\n",
          "message": "Read of persistent state following external call\nThe contract account state is accessed after an external call to a fixed address. To prevent reentrancy issues, consider accessing the state only before the call, especially if the callee is untrusted. Alternatively, a reentrancy lock can be used to prevent untrusted callees from re-entering the contract in an intermediate state.\nClassification: SWC-107"
        },
        {
          "name": "State access after external call (SWC 107)",
          "vulnerability_from_line": 1358,
          "vulnerability_to_line": null,
          "vulnerability_code": "            darkSupplyTarget = darkSupplyTarget.mul(12500).div(10000); // +25%\n",
          "message": "Write to persistent state following external call\nThe contract account state is accessed after an external call to a fixed address. To prevent reentrancy issues, consider accessing the state only before the call, especially if the callee is untrusted. Alternatively, a reentrancy lock can be used to prevent untrusted callees from re-entering the contract in an intermediate state.\nClassification: SWC-107"
        },
        {
          "name": "State access after external call (SWC 107)",
          "vulnerability_from_line": 1359,
          "vulnerability_to_line": null,
          "vulnerability_code": "            maxSupplyExpansionPercent = maxSupplyExpansionPercent.mul(9500).div(10000); // -5%\n",
          "message": "Read of persistent state following external call\nThe contract account state is accessed after an external call to a fixed address. To prevent reentrancy issues, consider accessing the state only before the call, especially if the callee is untrusted. Alternatively, a reentrancy lock can be used to prevent untrusted callees from re-entering the contract in an intermediate state.\nClassification: SWC-107"
        },
        {
          "name": "State access after external call (SWC 107)",
          "vulnerability_from_line": 1359,
          "vulnerability_to_line": null,
          "vulnerability_code": "            maxSupplyExpansionPercent = maxSupplyExpansionPercent.mul(9500).div(10000); // -5%\n",
          "message": "Write to persistent state following external call\nThe contract account state is accessed after an external call to a fixed address. To prevent reentrancy issues, consider accessing the state only before the call, especially if the callee is untrusted. Alternatively, a reentrancy lock can be used to prevent untrusted callees from re-entering the contract in an intermediate state.\nClassification: SWC-107"
        },
        {
          "name": "State access after external call (SWC 107)",
          "vulnerability_from_line": 1360,
          "vulnerability_to_line": null,
          "vulnerability_code": "            if (maxSupplyExpansionPercent < 10) {\n",
          "message": "Read of persistent state following external call\nThe contract account state is accessed after an external call to a fixed address. To prevent reentrancy issues, consider accessing the state only before the call, especially if the callee is untrusted. Alternatively, a reentrancy lock can be used to prevent untrusted callees from re-entering the contract in an intermediate state.\nClassification: SWC-107"
        },
        {
          "name": "State access after external call (SWC 107)",
          "vulnerability_from_line": 1361,
          "vulnerability_to_line": null,
          "vulnerability_code": "                maxSupplyExpansionPercent = 10; // min 0.1%\n",
          "message": "Write to persistent state following external call\nThe contract account state is accessed after an external call to a fixed address. To prevent reentrancy issues, consider accessing the state only before the call, especially if the callee is untrusted. Alternatively, a reentrancy lock can be used to prevent untrusted callees from re-entering the contract in an intermediate state.\nClassification: SWC-107"
        },
        {
          "name": "State access after external call (SWC 107)",
          "vulnerability_from_line": 1364,
          "vulnerability_to_line": null,
          "vulnerability_code": "        return maxSupplyExpansionPercent;\n",
          "message": "Read of persistent state following external call\nThe contract account state is accessed after an external call to a fixed address. To prevent reentrancy issues, consider accessing the state only before the call, especially if the callee is untrusted. Alternatively, a reentrancy lock can be used to prevent untrusted callees from re-entering the contract in an intermediate state.\nClassification: SWC-107"
        }
      ]
    },
    "osiris": {
      "successfull_analysis": false,
      "errors": [
        "Solidity compilation failed"
      ],
      "vulnerability_findings": []
    }
  }
}