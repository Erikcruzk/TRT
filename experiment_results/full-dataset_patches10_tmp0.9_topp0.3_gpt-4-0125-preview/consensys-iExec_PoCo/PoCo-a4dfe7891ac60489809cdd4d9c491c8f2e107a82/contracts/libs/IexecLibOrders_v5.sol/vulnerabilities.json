{
  "smartbugs_completed": true,
  "analyzer_results": {
    "semgrep": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 384,
          "vulnerability_to_line": null,
          "vulnerability_code": "\t\t\trevert(\"invalid-signature-format\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 388,
          "vulnerability_to_line": null,
          "vulnerability_code": "\t\trequire(v == 27 || v == 28, \"invalid-signature-v\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        }
      ]
    },
    "slither": {
      "successfull_analysis": true,
      "errors": [
        "EXIT_CODE_34"
      ],
      "vulnerability_findings": [
        {
          "name": "constant-function",
          "vulnerability_from_line": 126,
          "vulnerability_to_line": 160,
          "vulnerability_code": "\tfunction hash(EIP712Domain memory _domain)\n\n\tpublic pure returns (bytes32 domainhash)\n\n\t{\n\n\t\t/**\n\n\t\t * Readeable but expensive\n\n\t\t */\n\n\t\t// return keccak256(abi.encode(\n\n\t\t// \tEIP712DOMAIN_TYPEHASH\n\n\t\t// , keccak256(bytes(_domain.name))\n\n\t\t// , keccak256(bytes(_domain.version))\n\n\t\t// , _domain.chainId\n\n\t\t// , _domain.verifyingContract\n\n\t\t// ));\n\n\n\n\t\t// Compute sub-hashes\n\n\t\tbytes32 typeHash    = EIP712DOMAIN_TYPEHASH;\n\n\t\tbytes32 nameHash    = keccak256(bytes(_domain.name));\n\n\t\tbytes32 versionHash = keccak256(bytes(_domain.version));\n\n\t\tassembly {\n\n\t\t\t// Back up select memory\n\n\t\t\tlet temp1 := mload(sub(_domain, 0x20))\n\n\t\t\tlet temp2 := mload(add(_domain, 0x00))\n\n\t\t\tlet temp3 := mload(add(_domain, 0x20))\n\n\t\t\t// Write typeHash and sub-hashes\n\n\t\t\tmstore(sub(_domain, 0x20),    typeHash)\n\n\t\t\tmstore(add(_domain, 0x00),    nameHash)\n\n\t\t\tmstore(add(_domain, 0x20), versionHash)\n\n\t\t\t// Compute hash\n\n\t\t\tdomainhash := keccak256(sub(_domain, 0x20), 0xA0) // 160 = 32 + 128\n\n\t\t\t// Restore memory\n\n\t\t\tmstore(sub(_domain, 0x20), temp1)\n\n\t\t\tmstore(add(_domain, 0x00), temp2)\n\n\t\t\tmstore(add(_domain, 0x20), temp3)\n\n\t\t}\n",
          "message": "IexecLibOrders_v5.hash (IexecLibOrders_v5.sol#126-160) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 162,
          "vulnerability_to_line": 194,
          "vulnerability_code": "\tfunction hash(AppOrder memory _apporder)\n\n\tpublic pure returns (bytes32 apphash)\n\n\t{\n\n\t\t/**\n\n\t\t * Readeable but expensive\n\n\t\t */\n\n\t\t// return keccak256(abi.encode(\n\n\t\t// \tAPPORDER_TYPEHASH\n\n\t\t// , _apporder.app\n\n\t\t// , _apporder.appprice\n\n\t\t// , _apporder.volume\n\n\t\t// , _apporder.tag\n\n\t\t// , _apporder.datasetrestrict\n\n\t\t// , _apporder.workerpoolrestrict\n\n\t\t// , _apporder.requesterrestrict\n\n\t\t// , _apporder.salt\n\n\t\t// ));\n\n\n\n\t\t// Compute sub-hashes\n\n\t\tbytes32 typeHash = APPORDER_TYPEHASH;\n\n\t\tassembly {\n\n\t\t\t// Back up select memory\n\n\t\t\tlet temp1 := mload(sub(_apporder, 0x20))\n\n\t\t\t// Write typeHash and sub-hashes\n\n\t\t\tmstore(sub(_apporder, 0x20), typeHash)\n\n\t\t\t// Compute hash\n\n\t\t\tapphash := keccak256(sub(_apporder, 0x20), 0x120) // TODO: order evolution - 0x120\u21920x140\n\n\t\t\t// Restore memory\n\n\t\t\tmstore(sub(_apporder, 0x20), temp1)\n\n\t\t}\n\n\t}\n\n\n",
          "message": "IexecLibOrders_v5.hash (IexecLibOrders_v5.sol#162-194) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 194,
          "vulnerability_to_line": 226,
          "vulnerability_code": "\tfunction hash(DatasetOrder memory _datasetorder)\n\n\tpublic pure returns (bytes32 datasethash)\n\n\t{\n\n\t\t/**\n\n\t\t * Readeable but expensive\n\n\t\t */\n\n\t\t// return keccak256(abi.encode(\n\n\t\t// \tDATASETORDER_TYPEHASH\n\n\t\t// , _datasetorder.dataset\n\n\t\t// , _datasetorder.datasetprice\n\n\t\t// , _datasetorder.volume\n\n\t\t// , _datasetorder.tag\n\n\t\t// , _datasetorder.apprestrict\n\n\t\t// , _datasetorder.workerpoolrestrict\n\n\t\t// , _datasetorder.requesterrestrict\n\n\t\t// , _datasetorder.salt\n\n\t\t// ));\n\n\n\n\t\t// Compute sub-hashes\n\n\t\tbytes32 typeHash = DATASETORDER_TYPEHASH;\n\n\t\tassembly {\n\n\t\t\t// Back up select memory\n\n\t\t\tlet temp1 := mload(sub(_datasetorder, 0x20))\n\n\t\t\t// Write typeHash and sub-hashes\n\n\t\t\tmstore(sub(_datasetorder, 0x20), typeHash)\n\n\t\t\t// Compute hash\n\n\t\t\tdatasethash := keccak256(sub(_datasetorder, 0x20), 0x120) // TODO: order evolution - 0x120\u21920x140\n\n\t\t\t// Restore memory\n\n\t\t\tmstore(sub(_datasetorder, 0x20), temp1)\n\n\t\t}\n\n\t}\n\n\n",
          "message": "IexecLibOrders_v5.hash (IexecLibOrders_v5.sol#194-226) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 226,
          "vulnerability_to_line": 260,
          "vulnerability_code": "\tfunction hash(WorkerpoolOrder memory _workerpoolorder)\n\n\tpublic pure returns (bytes32 workerpoolhash)\n\n\t{\n\n\t\t/**\n\n\t\t * Readeable but expensive\n\n\t\t */\n\n\t\t// return keccak256(abi.encode(\n\n\t\t// \tWORKERPOOLORDER_TYPEHASH\n\n\t\t// , _workerpoolorder.workerpool\n\n\t\t// , _workerpoolorder.workerpoolprice\n\n\t\t// , _workerpoolorder.volume\n\n\t\t// , _workerpoolorder.tag\n\n\t\t// , _workerpoolorder.category\n\n\t\t// , _workerpoolorder.trust\n\n\t\t// , _workerpoolorder.apprestrict\n\n\t\t// , _workerpoolorder.datasetrestrict\n\n\t\t// , _workerpoolorder.requesterrestrict\n\n\t\t// , _workerpoolorder.salt\n\n\t\t// ));\n\n\n\n\t\t// Compute sub-hashes\n\n\t\tbytes32 typeHash = WORKERPOOLORDER_TYPEHASH;\n\n\t\tassembly {\n\n\t\t\t// Back up select memory\n\n\t\t\tlet temp1 := mload(sub(_workerpoolorder, 0x20))\n\n\t\t\t// Write typeHash and sub-hashes\n\n\t\t\tmstore(sub(_workerpoolorder, 0x20), typeHash)\n\n\t\t\t// Compute hash\n\n\t\t\tworkerpoolhash := keccak256(sub(_workerpoolorder, 0x20), 0x160) // TODO: order evolution - 0x160\u21920x180\n\n\t\t\t// Restore memory\n\n\t\t\tmstore(sub(_workerpoolorder, 0x20), temp1)\n\n\t\t}\n\n\t}\n\n\n",
          "message": "IexecLibOrders_v5.hash (IexecLibOrders_v5.sol#226-260) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 260,
          "vulnerability_to_line": 305,
          "vulnerability_code": "\tfunction hash(RequestOrder memory _requestorder)\n\n\tpublic pure returns (bytes32 requesthash)\n\n\t{\n\n\t\t/**\n\n\t\t * Readeable but expensive\n\n\t\t */\n\n\t\t//return keccak256(abi.encodePacked(\n\n\t\t//\tabi.encode(\n\n\t\t//\t\tREQUESTORDER_TYPEHASH\n\n\t\t//\t, _requestorder.app\n\n\t\t//\t, _requestorder.appmaxprice\n\n\t\t//\t, _requestorder.dataset\n\n\t\t//\t, _requestorder.datasetmaxprice\n\n\t\t//\t, _requestorder.workerpool\n\n\t\t//\t, _requestorder.workerpoolmaxprice\n\n\t\t//\t, _requestorder.requester\n\n\t\t//\t, _requestorder.volume\n\n\t\t//\t, _requestorder.tag\n\n\t\t//\t, _requestorder.category\n\n\t\t//\t, _requestorder.trust\n\n\t\t//\t, _requestorder.beneficiary\n\n\t\t//\t, _requestorder.callback\n\n\t\t//\t, keccak256(bytes(_requestorder.params))\n\n\t\t//\t, _requestorder.salt\n\n\t\t//\t)\n\n\t\t//));\n\n\n\n\t\t// Compute sub-hashes\n\n\t\tbytes32 typeHash = REQUESTORDER_TYPEHASH;\n\n\t\tbytes32 paramsHash = keccak256(bytes(_requestorder.params));\n\n\t\tassembly {\n\n\t\t\t// Back up select memory\n\n\t\t\tlet temp1 := mload(sub(_requestorder, 0x020))\n\n\t\t\tlet temp2 := mload(add(_requestorder, 0x1A0))\n\n\t\t\t// Write typeHash and sub-hashes\n\n\t\t\tmstore(sub(_requestorder, 0x020), typeHash)\n\n\t\t\tmstore(add(_requestorder, 0x1A0), paramsHash)\n\n\t\t\t// Compute hash\n\n\t\t\trequesthash := keccak256(sub(_requestorder, 0x20), 0x200) // TODO: order evolution - 0x200\u21920x220\n\n\t\t\t// Restore memory\n\n\t\t\tmstore(sub(_requestorder, 0x020), temp1)\n\n\t\t\tmstore(add(_requestorder, 0x1A0), temp2)\n\n\t\t}\n\n\t}\n\n\n",
          "message": "IexecLibOrders_v5.hash (IexecLibOrders_v5.sol#260-305) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 357,
          "vulnerability_to_line": 391,
          "vulnerability_code": "\tfunction recover(bytes32 _hash, bytes memory _sign)\n\n\tpublic pure returns (address)\n\n\t{\n\n\t\tbytes32 r;\n\n\t\tbytes32 s;\n\n\t\tuint8   v;\n\n\n\n\t\tif (_sign.length == 65) // 65bytes: (r,s,v) form\n\n\t\t{\n\n\t\t\tassembly\n\n\t\t\t{\n\n\t\t\t\tr :=         mload(add(_sign, 0x20))\n\n\t\t\t\ts :=         mload(add(_sign, 0x40))\n\n\t\t\t\tv := byte(0, mload(add(_sign, 0x60)))\n\n\t\t\t}\n\n\t\t}\n\n\t\telse if (_sign.length == 64) // 64bytes: (r,vs) form \u2192 see EIP2098\n\n\t\t{\n\n\t\t\tassembly\n\n\t\t\t{\n\n\t\t\t\tr :=                mload(add(_sign, 0x20))\n\n\t\t\t\ts := and(           mload(add(_sign, 0x40)), 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\n\n\t\t\t\tv := shr(7, byte(0, mload(add(_sign, 0x40))))\n\n\t\t\t}\n\n\t\t}\n\n\t\telse\n\n\t\t{\n\n\t\t\trevert(\"invalid-signature-format\");\n\n\t\t}\n\n\n\n\t\tif (v < 27) v += 27;\n\n\t\trequire(v == 27 || v == 28, \"invalid-signature-v\");\n\n\t\treturn ecrecover(_hash, v, r, s);\n\n\t}\n",
          "message": "IexecLibOrders_v5.recover (IexecLibOrders_v5.sol#357-391) is declared view but contains assembly code\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 126,
          "vulnerability_to_line": 160,
          "vulnerability_code": "\tfunction hash(EIP712Domain memory _domain)\n\n\tpublic pure returns (bytes32 domainhash)\n\n\t{\n\n\t\t/**\n\n\t\t * Readeable but expensive\n\n\t\t */\n\n\t\t// return keccak256(abi.encode(\n\n\t\t// \tEIP712DOMAIN_TYPEHASH\n\n\t\t// , keccak256(bytes(_domain.name))\n\n\t\t// , keccak256(bytes(_domain.version))\n\n\t\t// , _domain.chainId\n\n\t\t// , _domain.verifyingContract\n\n\t\t// ));\n\n\n\n\t\t// Compute sub-hashes\n\n\t\tbytes32 typeHash    = EIP712DOMAIN_TYPEHASH;\n\n\t\tbytes32 nameHash    = keccak256(bytes(_domain.name));\n\n\t\tbytes32 versionHash = keccak256(bytes(_domain.version));\n\n\t\tassembly {\n\n\t\t\t// Back up select memory\n\n\t\t\tlet temp1 := mload(sub(_domain, 0x20))\n\n\t\t\tlet temp2 := mload(add(_domain, 0x00))\n\n\t\t\tlet temp3 := mload(add(_domain, 0x20))\n\n\t\t\t// Write typeHash and sub-hashes\n\n\t\t\tmstore(sub(_domain, 0x20),    typeHash)\n\n\t\t\tmstore(add(_domain, 0x00),    nameHash)\n\n\t\t\tmstore(add(_domain, 0x20), versionHash)\n\n\t\t\t// Compute hash\n\n\t\t\tdomainhash := keccak256(sub(_domain, 0x20), 0xA0) // 160 = 32 + 128\n\n\t\t\t// Restore memory\n\n\t\t\tmstore(sub(_domain, 0x20), temp1)\n\n\t\t\tmstore(add(_domain, 0x00), temp2)\n\n\t\t\tmstore(add(_domain, 0x20), temp3)\n\n\t\t}\n",
          "message": "IexecLibOrders_v5.hash uses assembly (IexecLibOrders_v5.sol#126-160)\n\t- IexecLibOrders_v5.sol#144-159\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 162,
          "vulnerability_to_line": 194,
          "vulnerability_code": "\tfunction hash(AppOrder memory _apporder)\n\n\tpublic pure returns (bytes32 apphash)\n\n\t{\n\n\t\t/**\n\n\t\t * Readeable but expensive\n\n\t\t */\n\n\t\t// return keccak256(abi.encode(\n\n\t\t// \tAPPORDER_TYPEHASH\n\n\t\t// , _apporder.app\n\n\t\t// , _apporder.appprice\n\n\t\t// , _apporder.volume\n\n\t\t// , _apporder.tag\n\n\t\t// , _apporder.datasetrestrict\n\n\t\t// , _apporder.workerpoolrestrict\n\n\t\t// , _apporder.requesterrestrict\n\n\t\t// , _apporder.salt\n\n\t\t// ));\n\n\n\n\t\t// Compute sub-hashes\n\n\t\tbytes32 typeHash = APPORDER_TYPEHASH;\n\n\t\tassembly {\n\n\t\t\t// Back up select memory\n\n\t\t\tlet temp1 := mload(sub(_apporder, 0x20))\n\n\t\t\t// Write typeHash and sub-hashes\n\n\t\t\tmstore(sub(_apporder, 0x20), typeHash)\n\n\t\t\t// Compute hash\n\n\t\t\tapphash := keccak256(sub(_apporder, 0x20), 0x120) // TODO: order evolution - 0x120\u21920x140\n\n\t\t\t// Restore memory\n\n\t\t\tmstore(sub(_apporder, 0x20), temp1)\n\n\t\t}\n\n\t}\n\n\n",
          "message": "IexecLibOrders_v5.hash uses assembly (IexecLibOrders_v5.sol#162-194)\n\t- IexecLibOrders_v5.sol#182-192\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 194,
          "vulnerability_to_line": 226,
          "vulnerability_code": "\tfunction hash(DatasetOrder memory _datasetorder)\n\n\tpublic pure returns (bytes32 datasethash)\n\n\t{\n\n\t\t/**\n\n\t\t * Readeable but expensive\n\n\t\t */\n\n\t\t// return keccak256(abi.encode(\n\n\t\t// \tDATASETORDER_TYPEHASH\n\n\t\t// , _datasetorder.dataset\n\n\t\t// , _datasetorder.datasetprice\n\n\t\t// , _datasetorder.volume\n\n\t\t// , _datasetorder.tag\n\n\t\t// , _datasetorder.apprestrict\n\n\t\t// , _datasetorder.workerpoolrestrict\n\n\t\t// , _datasetorder.requesterrestrict\n\n\t\t// , _datasetorder.salt\n\n\t\t// ));\n\n\n\n\t\t// Compute sub-hashes\n\n\t\tbytes32 typeHash = DATASETORDER_TYPEHASH;\n\n\t\tassembly {\n\n\t\t\t// Back up select memory\n\n\t\t\tlet temp1 := mload(sub(_datasetorder, 0x20))\n\n\t\t\t// Write typeHash and sub-hashes\n\n\t\t\tmstore(sub(_datasetorder, 0x20), typeHash)\n\n\t\t\t// Compute hash\n\n\t\t\tdatasethash := keccak256(sub(_datasetorder, 0x20), 0x120) // TODO: order evolution - 0x120\u21920x140\n\n\t\t\t// Restore memory\n\n\t\t\tmstore(sub(_datasetorder, 0x20), temp1)\n\n\t\t}\n\n\t}\n\n\n",
          "message": "IexecLibOrders_v5.hash uses assembly (IexecLibOrders_v5.sol#194-226)\n\t- IexecLibOrders_v5.sol#214-225\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 226,
          "vulnerability_to_line": 260,
          "vulnerability_code": "\tfunction hash(WorkerpoolOrder memory _workerpoolorder)\n\n\tpublic pure returns (bytes32 workerpoolhash)\n\n\t{\n\n\t\t/**\n\n\t\t * Readeable but expensive\n\n\t\t */\n\n\t\t// return keccak256(abi.encode(\n\n\t\t// \tWORKERPOOLORDER_TYPEHASH\n\n\t\t// , _workerpoolorder.workerpool\n\n\t\t// , _workerpoolorder.workerpoolprice\n\n\t\t// , _workerpoolorder.volume\n\n\t\t// , _workerpoolorder.tag\n\n\t\t// , _workerpoolorder.category\n\n\t\t// , _workerpoolorder.trust\n\n\t\t// , _workerpoolorder.apprestrict\n\n\t\t// , _workerpoolorder.datasetrestrict\n\n\t\t// , _workerpoolorder.requesterrestrict\n\n\t\t// , _workerpoolorder.salt\n\n\t\t// ));\n\n\n\n\t\t// Compute sub-hashes\n\n\t\tbytes32 typeHash = WORKERPOOLORDER_TYPEHASH;\n\n\t\tassembly {\n\n\t\t\t// Back up select memory\n\n\t\t\tlet temp1 := mload(sub(_workerpoolorder, 0x20))\n\n\t\t\t// Write typeHash and sub-hashes\n\n\t\t\tmstore(sub(_workerpoolorder, 0x20), typeHash)\n\n\t\t\t// Compute hash\n\n\t\t\tworkerpoolhash := keccak256(sub(_workerpoolorder, 0x20), 0x160) // TODO: order evolution - 0x160\u21920x180\n\n\t\t\t// Restore memory\n\n\t\t\tmstore(sub(_workerpoolorder, 0x20), temp1)\n\n\t\t}\n\n\t}\n\n\n",
          "message": "IexecLibOrders_v5.hash uses assembly (IexecLibOrders_v5.sol#226-260)\n\t- IexecLibOrders_v5.sol#248-260\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 260,
          "vulnerability_to_line": 305,
          "vulnerability_code": "\tfunction hash(RequestOrder memory _requestorder)\n\n\tpublic pure returns (bytes32 requesthash)\n\n\t{\n\n\t\t/**\n\n\t\t * Readeable but expensive\n\n\t\t */\n\n\t\t//return keccak256(abi.encodePacked(\n\n\t\t//\tabi.encode(\n\n\t\t//\t\tREQUESTORDER_TYPEHASH\n\n\t\t//\t, _requestorder.app\n\n\t\t//\t, _requestorder.appmaxprice\n\n\t\t//\t, _requestorder.dataset\n\n\t\t//\t, _requestorder.datasetmaxprice\n\n\t\t//\t, _requestorder.workerpool\n\n\t\t//\t, _requestorder.workerpoolmaxprice\n\n\t\t//\t, _requestorder.requester\n\n\t\t//\t, _requestorder.volume\n\n\t\t//\t, _requestorder.tag\n\n\t\t//\t, _requestorder.category\n\n\t\t//\t, _requestorder.trust\n\n\t\t//\t, _requestorder.beneficiary\n\n\t\t//\t, _requestorder.callback\n\n\t\t//\t, keccak256(bytes(_requestorder.params))\n\n\t\t//\t, _requestorder.salt\n\n\t\t//\t)\n\n\t\t//));\n\n\n\n\t\t// Compute sub-hashes\n\n\t\tbytes32 typeHash = REQUESTORDER_TYPEHASH;\n\n\t\tbytes32 paramsHash = keccak256(bytes(_requestorder.params));\n\n\t\tassembly {\n\n\t\t\t// Back up select memory\n\n\t\t\tlet temp1 := mload(sub(_requestorder, 0x020))\n\n\t\t\tlet temp2 := mload(add(_requestorder, 0x1A0))\n\n\t\t\t// Write typeHash and sub-hashes\n\n\t\t\tmstore(sub(_requestorder, 0x020), typeHash)\n\n\t\t\tmstore(add(_requestorder, 0x1A0), paramsHash)\n\n\t\t\t// Compute hash\n\n\t\t\trequesthash := keccak256(sub(_requestorder, 0x20), 0x200) // TODO: order evolution - 0x200\u21920x220\n\n\t\t\t// Restore memory\n\n\t\t\tmstore(sub(_requestorder, 0x020), temp1)\n\n\t\t\tmstore(add(_requestorder, 0x1A0), temp2)\n\n\t\t}\n\n\t}\n\n\n",
          "message": "IexecLibOrders_v5.hash uses assembly (IexecLibOrders_v5.sol#260-305)\n\t- IexecLibOrders_v5.sol#290-305\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 357,
          "vulnerability_to_line": 391,
          "vulnerability_code": "\tfunction recover(bytes32 _hash, bytes memory _sign)\n\n\tpublic pure returns (address)\n\n\t{\n\n\t\tbytes32 r;\n\n\t\tbytes32 s;\n\n\t\tuint8   v;\n\n\n\n\t\tif (_sign.length == 65) // 65bytes: (r,s,v) form\n\n\t\t{\n\n\t\t\tassembly\n\n\t\t\t{\n\n\t\t\t\tr :=         mload(add(_sign, 0x20))\n\n\t\t\t\ts :=         mload(add(_sign, 0x40))\n\n\t\t\t\tv := byte(0, mload(add(_sign, 0x60)))\n\n\t\t\t}\n\n\t\t}\n\n\t\telse if (_sign.length == 64) // 64bytes: (r,vs) form \u2192 see EIP2098\n\n\t\t{\n\n\t\t\tassembly\n\n\t\t\t{\n\n\t\t\t\tr :=                mload(add(_sign, 0x20))\n\n\t\t\t\ts := and(           mload(add(_sign, 0x40)), 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\n\n\t\t\t\tv := shr(7, byte(0, mload(add(_sign, 0x40))))\n\n\t\t\t}\n\n\t\t}\n\n\t\telse\n\n\t\t{\n\n\t\t\trevert(\"invalid-signature-format\");\n\n\t\t}\n\n\n\n\t\tif (v < 27) v += 27;\n\n\t\trequire(v == 27 || v == 28, \"invalid-signature-v\");\n\n\t\treturn ecrecover(_hash, v, r, s);\n\n\t}\n",
          "message": "IexecLibOrders_v5.recover uses assembly (IexecLibOrders_v5.sol#357-391)\n\t- IexecLibOrders_v5.sol#366-373\n\t- IexecLibOrders_v5.sol#376-382\n"
        },
        {
          "name": "pragma",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.6.0;\n",
          "message": "Different versions of Solidity is used in IexecLibOrders_v5.sol:\n\t- Version used: ['ABIEncoderV2', '^0.6.0']\n\t- IexecLibOrders_v5.sol#3 declares pragma solidity^0.6.0\n\t- IexecLibOrders_v5.sol#4 declares pragma experimentalABIEncoderV2\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 126,
          "vulnerability_to_line": 160,
          "vulnerability_code": "\tfunction hash(EIP712Domain memory _domain)\n\n\tpublic pure returns (bytes32 domainhash)\n\n\t{\n\n\t\t/**\n\n\t\t * Readeable but expensive\n\n\t\t */\n\n\t\t// return keccak256(abi.encode(\n\n\t\t// \tEIP712DOMAIN_TYPEHASH\n\n\t\t// , keccak256(bytes(_domain.name))\n\n\t\t// , keccak256(bytes(_domain.version))\n\n\t\t// , _domain.chainId\n\n\t\t// , _domain.verifyingContract\n\n\t\t// ));\n\n\n\n\t\t// Compute sub-hashes\n\n\t\tbytes32 typeHash    = EIP712DOMAIN_TYPEHASH;\n\n\t\tbytes32 nameHash    = keccak256(bytes(_domain.name));\n\n\t\tbytes32 versionHash = keccak256(bytes(_domain.version));\n\n\t\tassembly {\n\n\t\t\t// Back up select memory\n\n\t\t\tlet temp1 := mload(sub(_domain, 0x20))\n\n\t\t\tlet temp2 := mload(add(_domain, 0x00))\n\n\t\t\tlet temp3 := mload(add(_domain, 0x20))\n\n\t\t\t// Write typeHash and sub-hashes\n\n\t\t\tmstore(sub(_domain, 0x20),    typeHash)\n\n\t\t\tmstore(add(_domain, 0x00),    nameHash)\n\n\t\t\tmstore(add(_domain, 0x20), versionHash)\n\n\t\t\t// Compute hash\n\n\t\t\tdomainhash := keccak256(sub(_domain, 0x20), 0xA0) // 160 = 32 + 128\n\n\t\t\t// Restore memory\n\n\t\t\tmstore(sub(_domain, 0x20), temp1)\n\n\t\t\tmstore(add(_domain, 0x00), temp2)\n\n\t\t\tmstore(add(_domain, 0x20), temp3)\n\n\t\t}\n",
          "message": "IexecLibOrders_v5.hash (IexecLibOrders_v5.sol#126-160) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 305,
          "vulnerability_to_line": 315,
          "vulnerability_code": "\tfunction hash(AppOrderOperation memory _apporderoperation)\n\n\tpublic pure returns (bytes32)\n\n\t{\n\n\t\treturn keccak256(abi.encode(\n\n\t\t\tAPPORDEROPERATION_TYPEHASH,\n\n\t\t\thash(_apporderoperation.order),\n\n\t\t\t_apporderoperation.operation\n\n\t\t));\n\n\t}\n\n\n",
          "message": "IexecLibOrders_v5.hash (IexecLibOrders_v5.sol#305-315) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 315,
          "vulnerability_to_line": 325,
          "vulnerability_code": "\tfunction hash(DatasetOrderOperation memory _datasetorderoperation)\n\n\tpublic pure returns (bytes32)\n\n\t{\n\n\t\treturn keccak256(abi.encode(\n\n\t\t\tDATASETORDEROPERATION_TYPEHASH,\n\n\t\t\thash(_datasetorderoperation.order),\n\n\t\t\t_datasetorderoperation.operation\n\n\t\t));\n\n\t}\n\n\n",
          "message": "IexecLibOrders_v5.hash (IexecLibOrders_v5.sol#315-325) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 325,
          "vulnerability_to_line": 335,
          "vulnerability_code": "\tfunction hash(WorkerpoolOrderOperation memory _workerpoolorderoperation)\n\n\tpublic pure returns (bytes32)\n\n\t{\n\n\t\treturn keccak256(abi.encode(\n\n\t\t\tWORKERPOOLORDEROPERATION_TYPEHASH,\n\n\t\t\thash(_workerpoolorderoperation.order),\n\n\t\t\t_workerpoolorderoperation.operation\n\n\t\t));\n\n\t}\n\n\n",
          "message": "IexecLibOrders_v5.hash (IexecLibOrders_v5.sol#325-335) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 335,
          "vulnerability_to_line": 345,
          "vulnerability_code": "\tfunction hash(RequestOrderOperation memory _requestorderoperation)\n\n\tpublic pure returns (bytes32)\n\n\t{\n\n\t\treturn keccak256(abi.encode(\n\n\t\t\tREQUESTORDEROPERATION_TYPEHASH,\n\n\t\t\thash(_requestorderoperation.order),\n\n\t\t\t_requestorderoperation.operation\n\n\t\t));\n\n\t}\n\n\n",
          "message": "IexecLibOrders_v5.hash (IexecLibOrders_v5.sol#335-345) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 345,
          "vulnerability_to_line": 351,
          "vulnerability_code": "\tfunction toEthSignedMessageHash(bytes32 _msgHash)\n\n\tpublic pure returns (bytes32)\n\n\t{\n\n\t\treturn keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", _msgHash));\n\n\t}\n\n\n",
          "message": "IexecLibOrders_v5.toEthSignedMessageHash (IexecLibOrders_v5.sol#345-351) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 351,
          "vulnerability_to_line": 357,
          "vulnerability_code": "\tfunction toEthTypedStructHash(bytes32 _structHash, bytes32 _domainHash)\n\n\tpublic pure returns (bytes32 typedStructHash)\n\n\t{\n\n\t\treturn keccak256(abi.encodePacked(\"\\x19\\x01\", _domainHash, _structHash));\n\n\t}\n\n\n",
          "message": "IexecLibOrders_v5.toEthTypedStructHash (IexecLibOrders_v5.sol#351-357) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 357,
          "vulnerability_to_line": 391,
          "vulnerability_code": "\tfunction recover(bytes32 _hash, bytes memory _sign)\n\n\tpublic pure returns (address)\n\n\t{\n\n\t\tbytes32 r;\n\n\t\tbytes32 s;\n\n\t\tuint8   v;\n\n\n\n\t\tif (_sign.length == 65) // 65bytes: (r,s,v) form\n\n\t\t{\n\n\t\t\tassembly\n\n\t\t\t{\n\n\t\t\t\tr :=         mload(add(_sign, 0x20))\n\n\t\t\t\ts :=         mload(add(_sign, 0x40))\n\n\t\t\t\tv := byte(0, mload(add(_sign, 0x60)))\n\n\t\t\t}\n\n\t\t}\n\n\t\telse if (_sign.length == 64) // 64bytes: (r,vs) form \u2192 see EIP2098\n\n\t\t{\n\n\t\t\tassembly\n\n\t\t\t{\n\n\t\t\t\tr :=                mload(add(_sign, 0x20))\n\n\t\t\t\ts := and(           mload(add(_sign, 0x40)), 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\n\n\t\t\t\tv := shr(7, byte(0, mload(add(_sign, 0x40))))\n\n\t\t\t}\n\n\t\t}\n\n\t\telse\n\n\t\t{\n\n\t\t\trevert(\"invalid-signature-format\");\n\n\t\t}\n\n\n\n\t\tif (v < 27) v += 27;\n\n\t\trequire(v == 27 || v == 28, \"invalid-signature-v\");\n\n\t\treturn ecrecover(_hash, v, r, s);\n\n\t}\n",
          "message": "IexecLibOrders_v5.recover (IexecLibOrders_v5.sol#357-391) should be declared external\n"
        },
        {
          "name": "solc-version",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.6.0;\n",
          "message": "Detected issues with version pragma in IexecLibOrders_v5.sol:\n\t- pragma solidity^0.6.0 (IexecLibOrders_v5.sol#3): it allows old versions\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 7,
          "vulnerability_to_line": 391,
          "vulnerability_code": "library IexecLibOrders_v5\n\n{\n\n\tbytes32 public constant             EIP712DOMAIN_TYPEHASH = keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n\n\tbytes32 public constant                 APPORDER_TYPEHASH = keccak256(\"AppOrder(address app,uint256 appprice,uint256 volume,bytes32 tag,address datasetrestrict,address workerpoolrestrict,address requesterrestrict,bytes32 salt)\"); // TODO: uint256 expiry\n\n\tbytes32 public constant             DATASETORDER_TYPEHASH = keccak256(\"DatasetOrder(address dataset,uint256 datasetprice,uint256 volume,bytes32 tag,address apprestrict,address workerpoolrestrict,address requesterrestrict,bytes32 salt)\"); // TODO: uint256 expiry\n\n\tbytes32 public constant          WORKERPOOLORDER_TYPEHASH = keccak256(\"WorkerpoolOrder(address workerpool,uint256 workerpoolprice,uint256 volume,bytes32 tag,uint256 category,uint256 trust,address apprestrict,address datasetrestrict,address requesterrestrict,bytes32 salt)\"); // TODO: uint256 expiry\n\n\tbytes32 public constant             REQUESTORDER_TYPEHASH = keccak256(\"RequestOrder(address app,uint256 appmaxprice,address dataset,uint256 datasetmaxprice,address workerpool,uint256 workerpoolmaxprice,address requester,uint256 volume,bytes32 tag,uint256 category,uint256 trust,address beneficiary,address callback,string params,bytes32 salt)\"); // TODO: uint256 expiry\n\n\tbytes32 public constant        APPORDEROPERATION_TYPEHASH = keccak256(\"AppOrderOperation(AppOrder order,uint256 operation)AppOrder(address app,uint256 appprice,uint256 volume,bytes32 tag,address datasetrestrict,address workerpoolrestrict,address requesterrestrict,bytes32 salt)\");\n\n\tbytes32 public constant    DATASETORDEROPERATION_TYPEHASH = keccak256(\"DatasetOrderOperation(DatasetOrder order,uint256 operation)DatasetOrder(address dataset,uint256 datasetprice,uint256 volume,bytes32 tag,address apprestrict,address workerpoolrestrict,address requesterrestrict,bytes32 salt)\");\n\n\tbytes32 public constant WORKERPOOLORDEROPERATION_TYPEHASH = keccak256(\"WorkerpoolOrderOperation(WorkerpoolOrder order,uint256 operation)WorkerpoolOrder(address workerpool,uint256 workerpoolprice,uint256 volume,bytes32 tag,uint256 category,uint256 trust,address apprestrict,address datasetrestrict,address requesterrestrict,bytes32 salt)\");\n\n\tbytes32 public constant    REQUESTORDEROPERATION_TYPEHASH = keccak256(\"RequestOrderOperation(RequestOrder order,uint256 operation)RequestOrder(address app,uint256 appmaxprice,address dataset,uint256 datasetmaxprice,address workerpool,uint256 workerpoolmaxprice,address requester,uint256 volume,bytes32 tag,uint256 category,uint256 trust,address beneficiary,address callback,string params,bytes32 salt)\");\n\n\n\n\tenum OrderOperationEnum\n\n\t{\n\n\t\tSIGN,\n\n\t\tCLOSE\n\n\t}\n\n\n\n\tstruct EIP712Domain\n\n\t{\n\n\t\tstring  name;\n\n\t\tstring  version;\n\n\t\tuint256 chainId;\n\n\t\taddress verifyingContract;\n\n\t}\n\n\n\n\tstruct AppOrder\n\n\t{\n\n\t\taddress app;\n\n\t\tuint256 appprice;\n\n\t\tuint256 volume;\n\n\t\tbytes32 tag;\n\n\t\taddress datasetrestrict;\n\n\t\taddress workerpoolrestrict;\n\n\t\taddress requesterrestrict;\n\n\t\t// uint256 expiration; // TODO: order evolution - deadlines\n\n\t\tbytes32 salt;\n\n\t\tbytes   sign;\n\n\t}\n\n\n\n\tstruct DatasetOrder\n\n\t{\n\n\t\taddress dataset;\n\n\t\tuint256 datasetprice;\n\n\t\tuint256 volume;\n\n\t\tbytes32 tag;\n\n\t\taddress apprestrict;\n\n\t\taddress workerpoolrestrict;\n\n\t\taddress requesterrestrict;\n\n\t\t// uint256 expiration; // TODO: order evolution - deadlines\n\n\t\tbytes32 salt;\n\n\t\tbytes   sign;\n\n\t}\n\n\n\n\tstruct WorkerpoolOrder\n\n\t{\n\n\t\taddress workerpool;\n\n\t\tuint256 workerpoolprice;\n\n\t\tuint256 volume;\n\n\t\tbytes32 tag;\n\n\t\tuint256 category;\n\n\t\tuint256 trust;\n\n\t\taddress apprestrict;\n\n\t\taddress datasetrestrict;\n\n\t\taddress requesterrestrict;\n\n\t\t// uint256 expiration; // TODO: order evolution - deadlines\n\n\t\tbytes32 salt;\n\n\t\tbytes   sign;\n\n\t}\n\n\n\n\tstruct RequestOrder\n\n\t{\n\n\t\taddress app;\n\n\t\tuint256 appmaxprice;\n\n\t\taddress dataset;\n\n\t\tuint256 datasetmaxprice;\n\n\t\taddress workerpool;\n\n\t\tuint256 workerpoolmaxprice;\n\n\t\taddress requester;\n\n\t\tuint256 volume;\n\n\t\tbytes32 tag;\n\n\t\tuint256 category;\n\n\t\tuint256 trust;\n\n\t\taddress beneficiary;\n\n\t\taddress callback;\n\n\t\tstring  params;\n\n\t\t// uint256 expiration; // TODO: order evolution - deadlines\n\n\t\tbytes32 salt;\n\n\t\tbytes   sign;\n\n\t}\n\n\n\n\tstruct AppOrderOperation\n\n\t{\n\n\t\tAppOrder           order;\n\n\t\tOrderOperationEnum operation;\n\n\t\tbytes              sign;\n\n\t}\n\n\n\n\tstruct DatasetOrderOperation\n\n\t{\n\n\t\tDatasetOrder       order;\n\n\t\tOrderOperationEnum operation;\n\n\t\tbytes              sign;\n\n\t}\n\n\n\n\tstruct WorkerpoolOrderOperation\n\n\t{\n\n\t\tWorkerpoolOrder    order;\n\n\t\tOrderOperationEnum operation;\n\n\t\tbytes              sign;\n\n\t}\n\n\n\n\tstruct RequestOrderOperation\n\n\t{\n\n\t\tRequestOrder       order;\n\n\t\tOrderOperationEnum operation;\n\n\t\tbytes              sign;\n\n\t}\n\n\n\n\tfunction hash(EIP712Domain memory _domain)\n\n\tpublic pure returns (bytes32 domainhash)\n\n\t{\n\n\t\t/**\n\n\t\t * Readeable but expensive\n\n\t\t */\n\n\t\t// return keccak256(abi.encode(\n\n\t\t// \tEIP712DOMAIN_TYPEHASH\n\n\t\t// , keccak256(bytes(_domain.name))\n\n\t\t// , keccak256(bytes(_domain.version))\n\n\t\t// , _domain.chainId\n\n\t\t// , _domain.verifyingContract\n\n\t\t// ));\n\n\n\n\t\t// Compute sub-hashes\n\n\t\tbytes32 typeHash    = EIP712DOMAIN_TYPEHASH;\n\n\t\tbytes32 nameHash    = keccak256(bytes(_domain.name));\n\n\t\tbytes32 versionHash = keccak256(bytes(_domain.version));\n\n\t\tassembly {\n\n\t\t\t// Back up select memory\n\n\t\t\tlet temp1 := mload(sub(_domain, 0x20))\n\n\t\t\tlet temp2 := mload(add(_domain, 0x00))\n\n\t\t\tlet temp3 := mload(add(_domain, 0x20))\n\n\t\t\t// Write typeHash and sub-hashes\n\n\t\t\tmstore(sub(_domain, 0x20),    typeHash)\n\n\t\t\tmstore(add(_domain, 0x00),    nameHash)\n\n\t\t\tmstore(add(_domain, 0x20), versionHash)\n\n\t\t\t// Compute hash\n\n\t\t\tdomainhash := keccak256(sub(_domain, 0x20), 0xA0) // 160 = 32 + 128\n\n\t\t\t// Restore memory\n\n\t\t\tmstore(sub(_domain, 0x20), temp1)\n\n\t\t\tmstore(add(_domain, 0x00), temp2)\n\n\t\t\tmstore(add(_domain, 0x20), temp3)\n\n\t\t}\n\n\t}\n\n\n\n\tfunction hash(AppOrder memory _apporder)\n\n\tpublic pure returns (bytes32 apphash)\n\n\t{\n\n\t\t/**\n\n\t\t * Readeable but expensive\n\n\t\t */\n\n\t\t// return keccak256(abi.encode(\n\n\t\t// \tAPPORDER_TYPEHASH\n\n\t\t// , _apporder.app\n\n\t\t// , _apporder.appprice\n\n\t\t// , _apporder.volume\n\n\t\t// , _apporder.tag\n\n\t\t// , _apporder.datasetrestrict\n\n\t\t// , _apporder.workerpoolrestrict\n\n\t\t// , _apporder.requesterrestrict\n\n\t\t// , _apporder.salt\n\n\t\t// ));\n\n\n\n\t\t// Compute sub-hashes\n\n\t\tbytes32 typeHash = APPORDER_TYPEHASH;\n\n\t\tassembly {\n\n\t\t\t// Back up select memory\n\n\t\t\tlet temp1 := mload(sub(_apporder, 0x20))\n\n\t\t\t// Write typeHash and sub-hashes\n\n\t\t\tmstore(sub(_apporder, 0x20), typeHash)\n\n\t\t\t// Compute hash\n\n\t\t\tapphash := keccak256(sub(_apporder, 0x20), 0x120) // TODO: order evolution - 0x120\u21920x140\n\n\t\t\t// Restore memory\n\n\t\t\tmstore(sub(_apporder, 0x20), temp1)\n\n\t\t}\n\n\t}\n\n\n\n\tfunction hash(DatasetOrder memory _datasetorder)\n\n\tpublic pure returns (bytes32 datasethash)\n\n\t{\n\n\t\t/**\n\n\t\t * Readeable but expensive\n\n\t\t */\n\n\t\t// return keccak256(abi.encode(\n\n\t\t// \tDATASETORDER_TYPEHASH\n\n\t\t// , _datasetorder.dataset\n\n\t\t// , _datasetorder.datasetprice\n\n\t\t// , _datasetorder.volume\n\n\t\t// , _datasetorder.tag\n\n\t\t// , _datasetorder.apprestrict\n\n\t\t// , _datasetorder.workerpoolrestrict\n\n\t\t// , _datasetorder.requesterrestrict\n\n\t\t// , _datasetorder.salt\n\n\t\t// ));\n\n\n\n\t\t// Compute sub-hashes\n\n\t\tbytes32 typeHash = DATASETORDER_TYPEHASH;\n\n\t\tassembly {\n\n\t\t\t// Back up select memory\n\n\t\t\tlet temp1 := mload(sub(_datasetorder, 0x20))\n\n\t\t\t// Write typeHash and sub-hashes\n\n\t\t\tmstore(sub(_datasetorder, 0x20), typeHash)\n\n\t\t\t// Compute hash\n\n\t\t\tdatasethash := keccak256(sub(_datasetorder, 0x20), 0x120) // TODO: order evolution - 0x120\u21920x140\n\n\t\t\t// Restore memory\n\n\t\t\tmstore(sub(_datasetorder, 0x20), temp1)\n\n\t\t}\n\n\t}\n\n\n\n\tfunction hash(WorkerpoolOrder memory _workerpoolorder)\n\n\tpublic pure returns (bytes32 workerpoolhash)\n\n\t{\n\n\t\t/**\n\n\t\t * Readeable but expensive\n\n\t\t */\n\n\t\t// return keccak256(abi.encode(\n\n\t\t// \tWORKERPOOLORDER_TYPEHASH\n\n\t\t// , _workerpoolorder.workerpool\n\n\t\t// , _workerpoolorder.workerpoolprice\n\n\t\t// , _workerpoolorder.volume\n\n\t\t// , _workerpoolorder.tag\n\n\t\t// , _workerpoolorder.category\n\n\t\t// , _workerpoolorder.trust\n\n\t\t// , _workerpoolorder.apprestrict\n\n\t\t// , _workerpoolorder.datasetrestrict\n\n\t\t// , _workerpoolorder.requesterrestrict\n\n\t\t// , _workerpoolorder.salt\n\n\t\t// ));\n\n\n\n\t\t// Compute sub-hashes\n\n\t\tbytes32 typeHash = WORKERPOOLORDER_TYPEHASH;\n\n\t\tassembly {\n\n\t\t\t// Back up select memory\n\n\t\t\tlet temp1 := mload(sub(_workerpoolorder, 0x20))\n\n\t\t\t// Write typeHash and sub-hashes\n\n\t\t\tmstore(sub(_workerpoolorder, 0x20), typeHash)\n\n\t\t\t// Compute hash\n\n\t\t\tworkerpoolhash := keccak256(sub(_workerpoolorder, 0x20), 0x160) // TODO: order evolution - 0x160\u21920x180\n\n\t\t\t// Restore memory\n\n\t\t\tmstore(sub(_workerpoolorder, 0x20), temp1)\n\n\t\t}\n\n\t}\n\n\n\n\tfunction hash(RequestOrder memory _requestorder)\n\n\tpublic pure returns (bytes32 requesthash)\n\n\t{\n\n\t\t/**\n\n\t\t * Readeable but expensive\n\n\t\t */\n\n\t\t//return keccak256(abi.encodePacked(\n\n\t\t//\tabi.encode(\n\n\t\t//\t\tREQUESTORDER_TYPEHASH\n\n\t\t//\t, _requestorder.app\n\n\t\t//\t, _requestorder.appmaxprice\n\n\t\t//\t, _requestorder.dataset\n\n\t\t//\t, _requestorder.datasetmaxprice\n\n\t\t//\t, _requestorder.workerpool\n\n\t\t//\t, _requestorder.workerpoolmaxprice\n\n\t\t//\t, _requestorder.requester\n\n\t\t//\t, _requestorder.volume\n\n\t\t//\t, _requestorder.tag\n\n\t\t//\t, _requestorder.category\n\n\t\t//\t, _requestorder.trust\n\n\t\t//\t, _requestorder.beneficiary\n\n\t\t//\t, _requestorder.callback\n\n\t\t//\t, keccak256(bytes(_requestorder.params))\n\n\t\t//\t, _requestorder.salt\n\n\t\t//\t)\n\n\t\t//));\n\n\n\n\t\t// Compute sub-hashes\n\n\t\tbytes32 typeHash = REQUESTORDER_TYPEHASH;\n\n\t\tbytes32 paramsHash = keccak256(bytes(_requestorder.params));\n\n\t\tassembly {\n\n\t\t\t// Back up select memory\n\n\t\t\tlet temp1 := mload(sub(_requestorder, 0x020))\n\n\t\t\tlet temp2 := mload(add(_requestorder, 0x1A0))\n\n\t\t\t// Write typeHash and sub-hashes\n\n\t\t\tmstore(sub(_requestorder, 0x020), typeHash)\n\n\t\t\tmstore(add(_requestorder, 0x1A0), paramsHash)\n\n\t\t\t// Compute hash\n\n\t\t\trequesthash := keccak256(sub(_requestorder, 0x20), 0x200) // TODO: order evolution - 0x200\u21920x220\n\n\t\t\t// Restore memory\n\n\t\t\tmstore(sub(_requestorder, 0x020), temp1)\n\n\t\t\tmstore(add(_requestorder, 0x1A0), temp2)\n\n\t\t}\n\n\t}\n\n\n\n\tfunction hash(AppOrderOperation memory _apporderoperation)\n\n\tpublic pure returns (bytes32)\n\n\t{\n\n\t\treturn keccak256(abi.encode(\n\n\t\t\tAPPORDEROPERATION_TYPEHASH,\n\n\t\t\thash(_apporderoperation.order),\n\n\t\t\t_apporderoperation.operation\n\n\t\t));\n\n\t}\n\n\n\n\tfunction hash(DatasetOrderOperation memory _datasetorderoperation)\n\n\tpublic pure returns (bytes32)\n\n\t{\n\n\t\treturn keccak256(abi.encode(\n\n\t\t\tDATASETORDEROPERATION_TYPEHASH,\n\n\t\t\thash(_datasetorderoperation.order),\n\n\t\t\t_datasetorderoperation.operation\n\n\t\t));\n\n\t}\n\n\n\n\tfunction hash(WorkerpoolOrderOperation memory _workerpoolorderoperation)\n\n\tpublic pure returns (bytes32)\n\n\t{\n\n\t\treturn keccak256(abi.encode(\n\n\t\t\tWORKERPOOLORDEROPERATION_TYPEHASH,\n\n\t\t\thash(_workerpoolorderoperation.order),\n\n\t\t\t_workerpoolorderoperation.operation\n\n\t\t));\n\n\t}\n\n\n\n\tfunction hash(RequestOrderOperation memory _requestorderoperation)\n\n\tpublic pure returns (bytes32)\n\n\t{\n\n\t\treturn keccak256(abi.encode(\n\n\t\t\tREQUESTORDEROPERATION_TYPEHASH,\n\n\t\t\thash(_requestorderoperation.order),\n\n\t\t\t_requestorderoperation.operation\n\n\t\t));\n\n\t}\n\n\n\n\tfunction toEthSignedMessageHash(bytes32 _msgHash)\n\n\tpublic pure returns (bytes32)\n\n\t{\n\n\t\treturn keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", _msgHash));\n\n\t}\n\n\n\n\tfunction toEthTypedStructHash(bytes32 _structHash, bytes32 _domainHash)\n\n\tpublic pure returns (bytes32 typedStructHash)\n\n\t{\n\n\t\treturn keccak256(abi.encodePacked(\"\\x19\\x01\", _domainHash, _structHash));\n\n\t}\n\n\n\n\tfunction recover(bytes32 _hash, bytes memory _sign)\n\n\tpublic pure returns (address)\n\n\t{\n\n\t\tbytes32 r;\n\n\t\tbytes32 s;\n\n\t\tuint8   v;\n\n\n\n\t\tif (_sign.length == 65) // 65bytes: (r,s,v) form\n\n\t\t{\n\n\t\t\tassembly\n\n\t\t\t{\n\n\t\t\t\tr :=         mload(add(_sign, 0x20))\n\n\t\t\t\ts :=         mload(add(_sign, 0x40))\n\n\t\t\t\tv := byte(0, mload(add(_sign, 0x60)))\n\n\t\t\t}\n\n\t\t}\n\n\t\telse if (_sign.length == 64) // 64bytes: (r,vs) form \u2192 see EIP2098\n\n\t\t{\n\n\t\t\tassembly\n\n\t\t\t{\n\n\t\t\t\tr :=                mload(add(_sign, 0x20))\n\n\t\t\t\ts := and(           mload(add(_sign, 0x40)), 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\n\n\t\t\t\tv := shr(7, byte(0, mload(add(_sign, 0x40))))\n\n\t\t\t}\n\n\t\t}\n\n\t\telse\n\n\t\t{\n\n\t\t\trevert(\"invalid-signature-format\");\n\n\t\t}\n\n\n\n\t\tif (v < 27) v += 27;\n\n\t\trequire(v == 27 || v == 28, \"invalid-signature-v\");\n\n\t\treturn ecrecover(_hash, v, r, s);\n\n\t}\n",
          "message": "Contract 'IexecLibOrders_v5' (IexecLibOrders_v5.sol#7-391) is not in CapWords\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 126,
          "vulnerability_to_line": null,
          "vulnerability_code": "\tfunction hash(EIP712Domain memory _domain)\n",
          "message": "Parameter '_domain' of IexecLibOrders_v5.hash (IexecLibOrders_v5.sol#126) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 260,
          "vulnerability_to_line": 261,
          "vulnerability_code": "\tfunction hash(RequestOrder memory _requestorder)\n",
          "message": "Parameter '_requestorder' of IexecLibOrders_v5.hash (IexecLibOrders_v5.sol#260-261) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 305,
          "vulnerability_to_line": 306,
          "vulnerability_code": "\tfunction hash(AppOrderOperation memory _apporderoperation)\n",
          "message": "Parameter '_apporderoperation' of IexecLibOrders_v5.hash (IexecLibOrders_v5.sol#305-306) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 315,
          "vulnerability_to_line": 316,
          "vulnerability_code": "\tfunction hash(DatasetOrderOperation memory _datasetorderoperation)\n",
          "message": "Parameter '_datasetorderoperation' of IexecLibOrders_v5.hash (IexecLibOrders_v5.sol#315-316) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 325,
          "vulnerability_to_line": 326,
          "vulnerability_code": "\tfunction hash(WorkerpoolOrderOperation memory _workerpoolorderoperation)\n",
          "message": "Parameter '_workerpoolorderoperation' of IexecLibOrders_v5.hash (IexecLibOrders_v5.sol#325-326) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 335,
          "vulnerability_to_line": 336,
          "vulnerability_code": "\tfunction hash(RequestOrderOperation memory _requestorderoperation)\n",
          "message": "Parameter '_requestorderoperation' of IexecLibOrders_v5.hash (IexecLibOrders_v5.sol#335-336) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 345,
          "vulnerability_to_line": 346,
          "vulnerability_code": "\tfunction toEthSignedMessageHash(bytes32 _msgHash)\n",
          "message": "Parameter '_msgHash' of IexecLibOrders_v5.toEthSignedMessageHash (IexecLibOrders_v5.sol#345-346) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 351,
          "vulnerability_to_line": null,
          "vulnerability_code": "\tfunction toEthTypedStructHash(bytes32 _structHash, bytes32 _domainHash)\n",
          "message": "Parameter '_structHash' of IexecLibOrders_v5.toEthTypedStructHash (IexecLibOrders_v5.sol#351) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 351,
          "vulnerability_to_line": 352,
          "vulnerability_code": "\tfunction toEthTypedStructHash(bytes32 _structHash, bytes32 _domainHash)\n",
          "message": "Parameter '_domainHash' of IexecLibOrders_v5.toEthTypedStructHash (IexecLibOrders_v5.sol#351-352) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 357,
          "vulnerability_to_line": null,
          "vulnerability_code": "\tfunction recover(bytes32 _hash, bytes memory _sign)\n",
          "message": "Parameter '_hash' of IexecLibOrders_v5.recover (IexecLibOrders_v5.sol#357) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 357,
          "vulnerability_to_line": 358,
          "vulnerability_code": "\tfunction recover(bytes32 _hash, bytes memory _sign)\n",
          "message": "Parameter '_sign' of IexecLibOrders_v5.recover (IexecLibOrders_v5.sol#357-358) is not in mixedCase\n"
        }
      ]
    },
    "smartcheck": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
          "vulnerability_from_line": 126,
          "vulnerability_to_line": null,
          "vulnerability_code": "\tfunction hash(EIP712Domain memory _domain)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
          "vulnerability_from_line": 162,
          "vulnerability_to_line": null,
          "vulnerability_code": "\tfunction hash(AppOrder memory _apporder)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
          "vulnerability_from_line": 194,
          "vulnerability_to_line": null,
          "vulnerability_code": "\tfunction hash(DatasetOrder memory _datasetorder)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
          "vulnerability_from_line": 226,
          "vulnerability_to_line": null,
          "vulnerability_code": "\tfunction hash(WorkerpoolOrder memory _workerpoolorder)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
          "vulnerability_from_line": 260,
          "vulnerability_to_line": null,
          "vulnerability_code": "\tfunction hash(RequestOrder memory _requestorder)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.6.0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_REVERT_REQUIRE",
          "vulnerability_from_line": 373,
          "vulnerability_to_line": null,
          "vulnerability_code": "\t\telse if (_sign.length == 64) // 64bytes: (r,vs) form \u2192 see EIP2098\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 126,
          "vulnerability_to_line": null,
          "vulnerability_code": "\tfunction hash(EIP712Domain memory _domain)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 162,
          "vulnerability_to_line": null,
          "vulnerability_code": "\tfunction hash(AppOrder memory _apporder)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 194,
          "vulnerability_to_line": null,
          "vulnerability_code": "\tfunction hash(DatasetOrder memory _datasetorder)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 226,
          "vulnerability_to_line": null,
          "vulnerability_code": "\tfunction hash(WorkerpoolOrder memory _workerpoolorder)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 260,
          "vulnerability_to_line": null,
          "vulnerability_code": "\tfunction hash(RequestOrder memory _requestorder)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 357,
          "vulnerability_to_line": null,
          "vulnerability_code": "\tfunction recover(bytes32 _hash, bytes memory _sign)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 144,
          "vulnerability_to_line": null,
          "vulnerability_code": "\t\tassembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 182,
          "vulnerability_to_line": null,
          "vulnerability_code": "\t\tassembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 214,
          "vulnerability_to_line": null,
          "vulnerability_code": "\t\tassembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 248,
          "vulnerability_to_line": null,
          "vulnerability_code": "\t\tassembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 290,
          "vulnerability_to_line": null,
          "vulnerability_code": "\t\tassembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 366,
          "vulnerability_to_line": null,
          "vulnerability_code": "\t\t\tassembly\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 375,
          "vulnerability_to_line": null,
          "vulnerability_code": "\t\t\tassembly\n",
          "message": null
        }
      ]
    },
    "oyente": {
      "successfull_analysis": false,
      "errors": [
        "exception (RuntimeError: Source map error, unknown name(SHR) or instr_name(INVALID))"
      ],
      "vulnerability_findings": []
    },
    "mythril": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": []
    },
    "osiris": {
      "successfull_analysis": false,
      "errors": [
        "Solidity compilation failed"
      ],
      "vulnerability_findings": []
    }
  }
}