{
  "smartbugs_completed": true,
  "analyzer_results": {
    "semgrep": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 332,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor(\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 333,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint256 _registrationFee,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 334,
          "vulnerability_to_line": null,
          "vulnerability_code": "        IERC20 _rewardToken,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 335,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address _dev\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 336,
          "vulnerability_to_line": null,
          "vulnerability_code": "    ) public {\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 337,
          "vulnerability_to_line": null,
          "vulnerability_code": "        registrationFee = _registrationFee;\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 338,
          "vulnerability_to_line": null,
          "vulnerability_code": "        rewardToken = _rewardToken;\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 339,
          "vulnerability_to_line": null,
          "vulnerability_code": "        dev = _dev;\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 340,
          "vulnerability_to_line": null,
          "vulnerability_code": "\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 341,
          "vulnerability_to_line": null,
          "vulnerability_code": "        string memory _name = \"dev\";\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 40,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 i = 0; i < _length; i++)\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 26,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require (_length <= 32 && _length > 0, \"string must be between 1 and 32 characters\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 28,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_temp[0] != 0x20 && _temp[_length-1] != 0x20, \"string cannot start or end with space\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 32,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(_temp[1] != 0x78, \"string cannot start with 0x\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 33,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(_temp[1] != 0x58, \"string cannot start with 0X\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 52,
          "vulnerability_to_line": null,
          "vulnerability_code": "                require\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 53,
          "vulnerability_to_line": null,
          "vulnerability_code": "                (\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 54,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    // require character is a space\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 55,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    _temp[i] == 0x20 || \n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 56,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    // OR lowercase a-z\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 57,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    (_temp[i] > 0x60 && _temp[i] < 0x7b) ||\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 58,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    // or 0-9\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 59,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    (_temp[i] > 0x2f && _temp[i] < 0x3a),\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 60,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    \"string contains invalid characters\"\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 61,
          "vulnerability_to_line": null,
          "vulnerability_code": "                );\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 64,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    require( _temp[i+1] != 0x20, \"string cannot contain consecutive spaces\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 72,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_hasNonNumber == true, \"string cannot be only numbers\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 179,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(c >= a, \"SafeMath: addition overflow\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 235,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(c / a == b, \"SafeMath: multiplication overflow\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 352,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 353,
          "vulnerability_to_line": null,
          "vulnerability_code": "            msg.value >= registrationFee,\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 354,
          "vulnerability_to_line": null,
          "vulnerability_code": "            \"umm.....  you have to pay the name fee\"\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 355,
          "vulnerability_to_line": null,
          "vulnerability_code": "        );\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 357,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_player != address(0), \"Must be normal address\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 359,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(checkIfNameValid(_name), \"Must be unuse name\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 26,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require (_length <= 32 && _length > 0, \"string must be between 1 and 32 characters\");\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 28,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_temp[0] != 0x20 && _temp[_length-1] != 0x20, \"string cannot start or end with space\");\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 52,
          "vulnerability_to_line": null,
          "vulnerability_code": "                require\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 53,
          "vulnerability_to_line": null,
          "vulnerability_code": "                (\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 54,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    // require character is a space\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 55,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    _temp[i] == 0x20 || \n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 56,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    // OR lowercase a-z\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 57,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    (_temp[i] > 0x60 && _temp[i] < 0x7b) ||\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 58,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    // or 0-9\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 59,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    (_temp[i] > 0x2f && _temp[i] < 0x3a),\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 60,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    \"string contains invalid characters\"\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 61,
          "vulnerability_to_line": null,
          "vulnerability_code": "                );\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 43,
          "vulnerability_to_line": null,
          "vulnerability_code": "            if (_temp[i] > 0x40 && _temp[i] < 0x5b)\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 44,
          "vulnerability_to_line": null,
          "vulnerability_code": "            {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 45,
          "vulnerability_to_line": null,
          "vulnerability_code": "                // convert to lower case a-z\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 46,
          "vulnerability_to_line": null,
          "vulnerability_code": "                _temp[i] = byte(uint(_temp[i]) + 32);\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 47,
          "vulnerability_to_line": null,
          "vulnerability_code": "                \n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 48,
          "vulnerability_to_line": null,
          "vulnerability_code": "                // we have a non number\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 49,
          "vulnerability_to_line": null,
          "vulnerability_code": "                if (_hasNonNumber == false)\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 50,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    _hasNonNumber = true;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 51,
          "vulnerability_to_line": null,
          "vulnerability_code": "            } else {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 52,
          "vulnerability_to_line": null,
          "vulnerability_code": "                require\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 67,
          "vulnerability_to_line": null,
          "vulnerability_code": "                if (_hasNonNumber == false && (_temp[i] < 0x30 || _temp[i] > 0x39))\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 68,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    _hasNonNumber = true;    \n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 40,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 i = 0; i < _length; i++)\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 26,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require (_length <= 32 && _length > 0, \"string must be between 1 and 32 characters\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 28,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_temp[0] != 0x20 && _temp[_length-1] != 0x20, \"string cannot start or end with space\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 52,
          "vulnerability_to_line": null,
          "vulnerability_code": "                require\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 53,
          "vulnerability_to_line": null,
          "vulnerability_code": "                (\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 54,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    // require character is a space\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 55,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    _temp[i] == 0x20 || \n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 56,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    // OR lowercase a-z\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 57,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    (_temp[i] > 0x60 && _temp[i] < 0x7b) ||\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 58,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    // or 0-9\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 59,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    (_temp[i] > 0x2f && _temp[i] < 0x3a),\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 60,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    \"string contains invalid characters\"\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 61,
          "vulnerability_to_line": null,
          "vulnerability_code": "                );\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 64,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    require( _temp[i+1] != 0x20, \"string cannot contain consecutive spaces\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 235,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(c / a == b, \"SafeMath: multiplication overflow\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 352,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 353,
          "vulnerability_to_line": null,
          "vulnerability_code": "            msg.value >= registrationFee,\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 354,
          "vulnerability_to_line": null,
          "vulnerability_code": "            \"umm.....  you have to pay the name fee\"\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 355,
          "vulnerability_to_line": null,
          "vulnerability_code": "        );\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        }
      ]
    },
    "slither": {
      "successfull_analysis": true,
      "errors": [
        "EXIT_CODE_32"
      ],
      "vulnerability_findings": [
        {
          "name": "constant-function",
          "vulnerability_from_line": 17,
          "vulnerability_to_line": 79,
          "vulnerability_code": "    function nameFilter(string memory _input)\n\n        internal\n\n        pure\n\n        returns(bytes32)\n\n    {\n\n        bytes memory _temp = bytes(_input);\n\n        uint256 _length = _temp.length;\n\n        \n\n        //sorry limited to 32 characters\n\n        require (_length <= 32 && _length > 0, \"string must be between 1 and 32 characters\");\n\n        // make sure it doesnt start with or end with space\n\n        require(_temp[0] != 0x20 && _temp[_length-1] != 0x20, \"string cannot start or end with space\");\n\n        // make sure first two characters are not 0x\n\n        if (_temp[0] == 0x30)\n\n        {\n\n            require(_temp[1] != 0x78, \"string cannot start with 0x\");\n\n            require(_temp[1] != 0x58, \"string cannot start with 0X\");\n\n        }\n\n        \n\n        // create a bool to track if we have a non number character\n\n        bool _hasNonNumber;\n\n        \n\n        // convert & check\n\n        for (uint256 i = 0; i < _length; i++)\n\n        {\n\n            // if its uppercase A-Z\n\n            if (_temp[i] > 0x40 && _temp[i] < 0x5b)\n\n            {\n\n                // convert to lower case a-z\n\n                _temp[i] = byte(uint(_temp[i]) + 32);\n\n                \n\n                // we have a non number\n\n                if (_hasNonNumber == false)\n\n                    _hasNonNumber = true;\n\n            } else {\n\n                require\n\n                (\n\n                    // require character is a space\n\n                    _temp[i] == 0x20 || \n\n                    // OR lowercase a-z\n\n                    (_temp[i] > 0x60 && _temp[i] < 0x7b) ||\n\n                    // or 0-9\n\n                    (_temp[i] > 0x2f && _temp[i] < 0x3a),\n\n                    \"string contains invalid characters\"\n\n                );\n\n                // make sure theres not 2x spaces in a row\n\n                if (_temp[i] == 0x20)\n\n                    require( _temp[i+1] != 0x20, \"string cannot contain consecutive spaces\");\n\n                \n\n                // see if we have a character other than a number\n\n                if (_hasNonNumber == false && (_temp[i] < 0x30 || _temp[i] > 0x39))\n\n                    _hasNonNumber = true;    \n\n            }\n\n        }\n\n        \n\n        require(_hasNonNumber == true, \"string cannot be only numbers\");\n\n        \n\n        bytes32 _ret;\n\n        assembly {\n\n            _ret := mload(add(_temp, 32))\n\n        }\n\n        return (_ret);\n",
          "message": "NameFilter.nameFilter (Playerbook.sol#17-79) is declared view but contains assembly code\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 396,
          "vulnerability_to_line": 405,
          "vulnerability_code": "    function withdarwReard() external returns (bool) {\n\n        uint256 reward = ReferralReward[msg.sender];\n\n        require(rewardToken.balanceOf(address(this)) >= reward);\n\n\n\n        rewardToken.transfer(msg.sender, reward);\n\n\n\n        ReferralReward[msg.sender] = 0;\n\n\n\n        return true;\n",
          "message": "Reentrancy in Playerbook.withdarwReard (Playerbook.sol#396-405):\n\tExternal calls:\n\t- require(bool)(rewardToken.balanceOf(address(this)) >= reward) (Playerbook.sol#398)\n\t- rewardToken.transfer(msg.sender,reward) (Playerbook.sol#400)\n\tState variables written after the call(s):\n\t- ReferralReward (Playerbook.sol#402)\n"
        },
        {
          "name": "unused-return",
          "vulnerability_from_line": 369,
          "vulnerability_to_line": 394,
          "vulnerability_code": "    function incomingReward(\n\n        address _user,\n\n        string memory _name,\n\n        uint256 _amount\n\n    ) public returns (bool) {\n\n        rewardToken.transferFrom(msg.sender, address(this), _amount);\n\n        bytes32 name = _name.nameFilter();\n\n        address _player = NameXPlayer[name];\n\n\n\n        if (_player == address(0)) {\n\n            _player = dev;\n\n        }\n\n\n\n        ReferralReward[_player] = ReferralReward[_player].add(_amount);\n\n        ReferralTotalReward[_player] = ReferralTotalReward[_player].add(\n\n            _amount\n\n        );\n\n        emit NewReward(_player, _amount);\n\n\n\n        if (!ReferralRecordAddress[_player][_user]) {\n\n            ReferralRecordAddress[_player][_user] = true;\n\n            ReferralRecord[_player] = ReferralRecord[_player] + 1;\n\n        }\n\n\n\n        return true;\n",
          "message": "Playerbook.incomingReward (Playerbook.sol#369-394) does not use the value returned by external calls:\n\t-rewardToken.transferFrom(msg.sender,address(this),_amount) (Playerbook.sol#374)\n"
        },
        {
          "name": "unused-return",
          "vulnerability_from_line": 396,
          "vulnerability_to_line": 405,
          "vulnerability_code": "    function withdarwReard() external returns (bool) {\n\n        uint256 reward = ReferralReward[msg.sender];\n\n        require(rewardToken.balanceOf(address(this)) >= reward);\n\n\n\n        rewardToken.transfer(msg.sender, reward);\n\n\n\n        ReferralReward[msg.sender] = 0;\n\n\n\n        return true;\n",
          "message": "Playerbook.withdarwReard (Playerbook.sol#396-405) does not use the value returned by external calls:\n\t-rewardToken.transfer(msg.sender,reward) (Playerbook.sol#400)\n"
        },
        {
          "name": "unused-return",
          "vulnerability_from_line": 419,
          "vulnerability_to_line": 422,
          "vulnerability_code": "    function forceExit(IERC20 _token) public {\n\n        require(msg.sender == dev);\n\n        _token.transfer(msg.sender, _token.balanceOf(address(this)));\n",
          "message": "Playerbook.forceExit (Playerbook.sol#419-422) does not use the value returned by external calls:\n\t-_token.transfer(msg.sender,_token.balanceOf(address(this))) (Playerbook.sol#421)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 369,
          "vulnerability_to_line": 394,
          "vulnerability_code": "    function incomingReward(\n\n        address _user,\n\n        string memory _name,\n\n        uint256 _amount\n\n    ) public returns (bool) {\n\n        rewardToken.transferFrom(msg.sender, address(this), _amount);\n\n        bytes32 name = _name.nameFilter();\n\n        address _player = NameXPlayer[name];\n\n\n\n        if (_player == address(0)) {\n\n            _player = dev;\n\n        }\n\n\n\n        ReferralReward[_player] = ReferralReward[_player].add(_amount);\n\n        ReferralTotalReward[_player] = ReferralTotalReward[_player].add(\n\n            _amount\n\n        );\n\n        emit NewReward(_player, _amount);\n\n\n\n        if (!ReferralRecordAddress[_player][_user]) {\n\n            ReferralRecordAddress[_player][_user] = true;\n\n            ReferralRecord[_player] = ReferralRecord[_player] + 1;\n\n        }\n\n\n\n        return true;\n",
          "message": "Reentrancy in Playerbook.incomingReward (Playerbook.sol#369-394):\n\tExternal calls:\n\t- rewardToken.transferFrom(msg.sender,address(this),_amount) (Playerbook.sol#374)\n\tState variables written after the call(s):\n\t- ReferralRecord (Playerbook.sol#390)\n\t- ReferralRecordAddress (Playerbook.sol#389)\n\t- ReferralReward (Playerbook.sol#382)\n\t- ReferralTotalReward (Playerbook.sol#383-385)\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 17,
          "vulnerability_to_line": 79,
          "vulnerability_code": "    function nameFilter(string memory _input)\n\n        internal\n\n        pure\n\n        returns(bytes32)\n\n    {\n\n        bytes memory _temp = bytes(_input);\n\n        uint256 _length = _temp.length;\n\n        \n\n        //sorry limited to 32 characters\n\n        require (_length <= 32 && _length > 0, \"string must be between 1 and 32 characters\");\n\n        // make sure it doesnt start with or end with space\n\n        require(_temp[0] != 0x20 && _temp[_length-1] != 0x20, \"string cannot start or end with space\");\n\n        // make sure first two characters are not 0x\n\n        if (_temp[0] == 0x30)\n\n        {\n\n            require(_temp[1] != 0x78, \"string cannot start with 0x\");\n\n            require(_temp[1] != 0x58, \"string cannot start with 0X\");\n\n        }\n\n        \n\n        // create a bool to track if we have a non number character\n\n        bool _hasNonNumber;\n\n        \n\n        // convert & check\n\n        for (uint256 i = 0; i < _length; i++)\n\n        {\n\n            // if its uppercase A-Z\n\n            if (_temp[i] > 0x40 && _temp[i] < 0x5b)\n\n            {\n\n                // convert to lower case a-z\n\n                _temp[i] = byte(uint(_temp[i]) + 32);\n\n                \n\n                // we have a non number\n\n                if (_hasNonNumber == false)\n\n                    _hasNonNumber = true;\n\n            } else {\n\n                require\n\n                (\n\n                    // require character is a space\n\n                    _temp[i] == 0x20 || \n\n                    // OR lowercase a-z\n\n                    (_temp[i] > 0x60 && _temp[i] < 0x7b) ||\n\n                    // or 0-9\n\n                    (_temp[i] > 0x2f && _temp[i] < 0x3a),\n\n                    \"string contains invalid characters\"\n\n                );\n\n                // make sure theres not 2x spaces in a row\n\n                if (_temp[i] == 0x20)\n\n                    require( _temp[i+1] != 0x20, \"string cannot contain consecutive spaces\");\n\n                \n\n                // see if we have a character other than a number\n\n                if (_hasNonNumber == false && (_temp[i] < 0x30 || _temp[i] > 0x39))\n\n                    _hasNonNumber = true;    \n\n            }\n\n        }\n\n        \n\n        require(_hasNonNumber == true, \"string cannot be only numbers\");\n\n        \n\n        bytes32 _ret;\n\n        assembly {\n\n            _ret := mload(add(_temp, 32))\n\n        }\n\n        return (_ret);\n",
          "message": "NameFilter.nameFilter uses assembly (Playerbook.sol#17-79)\n\t- Playerbook.sol#75-78\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 347,
          "vulnerability_to_line": 367,
          "vulnerability_code": "    function registerPlayerName(address _player, string memory _name)\n\n        public\n\n        payable\n\n        returns (bool)\n\n    {\n\n        require(\n\n            msg.value >= registrationFee,\n\n            \"umm.....  you have to pay the name fee\"\n\n        );\n\n\n\n        require(_player != address(0), \"Must be normal address\");\n\n\n\n        require(checkIfNameValid(_name), \"Must be unuse name\");\n\n\n\n        bytes32 name = _name.nameFilter();\n\n\n\n        PlayerXName[_player] = name;\n\n        NameXPlayer[name] = _player;\n\n\n\n        return true;\n",
          "message": "Playerbook.registerPlayerName (Playerbook.sol#347-367) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 369,
          "vulnerability_to_line": 394,
          "vulnerability_code": "    function incomingReward(\n\n        address _user,\n\n        string memory _name,\n\n        uint256 _amount\n\n    ) public returns (bool) {\n\n        rewardToken.transferFrom(msg.sender, address(this), _amount);\n\n        bytes32 name = _name.nameFilter();\n\n        address _player = NameXPlayer[name];\n\n\n\n        if (_player == address(0)) {\n\n            _player = dev;\n\n        }\n\n\n\n        ReferralReward[_player] = ReferralReward[_player].add(_amount);\n\n        ReferralTotalReward[_player] = ReferralTotalReward[_player].add(\n\n            _amount\n\n        );\n\n        emit NewReward(_player, _amount);\n\n\n\n        if (!ReferralRecordAddress[_player][_user]) {\n\n            ReferralRecordAddress[_player][_user] = true;\n\n            ReferralRecord[_player] = ReferralRecord[_player] + 1;\n\n        }\n\n\n\n        return true;\n",
          "message": "Playerbook.incomingReward (Playerbook.sol#369-394) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 419,
          "vulnerability_to_line": 422,
          "vulnerability_code": "    function forceExit(IERC20 _token) public {\n\n        require(msg.sender == dev);\n\n        _token.transfer(msg.sender, _token.balanceOf(address(this)));\n",
          "message": "Playerbook.forceExit (Playerbook.sol#419-422) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 432,
          "vulnerability_to_line": 435,
          "vulnerability_code": "    function getPlayer(string memory _nameStr) public view returns (address) {\n\n        bytes32 _name = _nameStr.nameFilter();\n\n        return NameXPlayer[_name];\n",
          "message": "Playerbook.getPlayer (Playerbook.sol#432-435) should be declared external\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 17,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function nameFilter(string memory _input)\n",
          "message": "Parameter '_input' of NameFilter.nameFilter (Playerbook.sol#17) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 333,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint256 _registrationFee,\n",
          "message": "Parameter '_registrationFee' of Playerbook. (Playerbook.sol#333) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 334,
          "vulnerability_to_line": null,
          "vulnerability_code": "        IERC20 _rewardToken,\n",
          "message": "Parameter '_rewardToken' of Playerbook. (Playerbook.sol#334) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 335,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address _dev\n",
          "message": "Parameter '_dev' of Playerbook. (Playerbook.sol#335) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 347,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function registerPlayerName(address _player, string memory _name)\n",
          "message": "Parameter '_player' of Playerbook.registerPlayerName (Playerbook.sol#347) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 347,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function registerPlayerName(address _player, string memory _name)\n",
          "message": "Parameter '_name' of Playerbook.registerPlayerName (Playerbook.sol#347) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 370,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address _user,\n",
          "message": "Parameter '_user' of Playerbook.incomingReward (Playerbook.sol#370) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 371,
          "vulnerability_to_line": null,
          "vulnerability_code": "        string memory _name,\n",
          "message": "Parameter '_name' of Playerbook.incomingReward (Playerbook.sol#371) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 372,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint256 _amount\n",
          "message": "Parameter '_amount' of Playerbook.incomingReward (Playerbook.sol#372) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 407,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function withdrawETH(address _receiver) external returns (bool) {\n",
          "message": "Parameter '_receiver' of Playerbook.withdrawETH (Playerbook.sol#407) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 413,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setFee(uint _fee) external {\n",
          "message": "Parameter '_fee' of Playerbook.setFee (Playerbook.sol#413) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 419,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function forceExit(IERC20 _token) public {\n",
          "message": "Parameter '_token' of Playerbook.forceExit (Playerbook.sol#419) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 428,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getReferralReward(address _user) external view returns (uint256) {\n",
          "message": "Parameter '_user' of Playerbook.getReferralReward (Playerbook.sol#428) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 432,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getPlayer(string memory _nameStr) public view returns (address) {\n",
          "message": "Parameter '_nameStr' of Playerbook.getPlayer (Playerbook.sol#432) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 437,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function checkIfNameValid(string memory _nameStr)\n",
          "message": "Parameter '_nameStr' of Playerbook.checkIfNameValid (Playerbook.sol#437) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 319,
          "vulnerability_to_line": null,
          "vulnerability_code": "    mapping(address => bytes32) public PlayerXName;\n",
          "message": "Variable 'Playerbook.PlayerXName' (Playerbook.sol#319) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 320,
          "vulnerability_to_line": null,
          "vulnerability_code": "    mapping(bytes32 => address) public NameXPlayer;\n",
          "message": "Variable 'Playerbook.NameXPlayer' (Playerbook.sol#320) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 321,
          "vulnerability_to_line": null,
          "vulnerability_code": "    mapping(address => uint256) public ReferralReward;\n",
          "message": "Variable 'Playerbook.ReferralReward' (Playerbook.sol#321) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 322,
          "vulnerability_to_line": null,
          "vulnerability_code": "    mapping(address => uint256) public ReferralTotalReward;\n",
          "message": "Variable 'Playerbook.ReferralTotalReward' (Playerbook.sol#322) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 323,
          "vulnerability_to_line": null,
          "vulnerability_code": "    mapping(address => mapping(address => bool)) public ReferralRecordAddress;\n",
          "message": "Variable 'Playerbook.ReferralRecordAddress' (Playerbook.sol#323) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 324,
          "vulnerability_to_line": null,
          "vulnerability_code": "    mapping(address => uint256) public ReferralRecord;\n",
          "message": "Variable 'Playerbook.ReferralRecord' (Playerbook.sol#324) is not in mixedCase\n"
        }
      ]
    },
    "smartcheck": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 28,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_temp[0] != 0x20 && _temp[_length-1] != 0x20, \"string cannot start or end with space\");\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 28,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_temp[0] != 0x20 && _temp[_length-1] != 0x20, \"string cannot start or end with space\");\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 30,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (_temp[0] == 0x30)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 32,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(_temp[1] != 0x78, \"string cannot start with 0x\");\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 33,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(_temp[1] != 0x58, \"string cannot start with 0X\");\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 43,
          "vulnerability_to_line": null,
          "vulnerability_code": "            if (_temp[i] > 0x40 && _temp[i] < 0x5b)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 43,
          "vulnerability_to_line": null,
          "vulnerability_code": "            if (_temp[i] > 0x40 && _temp[i] < 0x5b)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 55,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    _temp[i] == 0x20 || \n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 57,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    (_temp[i] > 0x60 && _temp[i] < 0x7b) ||\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 57,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    (_temp[i] > 0x60 && _temp[i] < 0x7b) ||\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 59,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    (_temp[i] > 0x2f && _temp[i] < 0x3a),\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 59,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    (_temp[i] > 0x2f && _temp[i] < 0x3a),\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 63,
          "vulnerability_to_line": null,
          "vulnerability_code": "                if (_temp[i] == 0x20)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 64,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    require( _temp[i+1] != 0x20, \"string cannot contain consecutive spaces\");\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 67,
          "vulnerability_to_line": null,
          "vulnerability_code": "                if (_hasNonNumber == false && (_temp[i] < 0x30 || _temp[i] > 0x39))\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 67,
          "vulnerability_to_line": null,
          "vulnerability_code": "                if (_hasNonNumber == false && (_temp[i] < 0x30 || _temp[i] > 0x39))\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 40,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 i = 0; i < _length; i++)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_OVERPOWERED_ROLE",
          "vulnerability_from_line": 413,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setFee(uint _fee) external {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.24;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SAFEMATH",
          "vulnerability_from_line": 317,
          "vulnerability_to_line": null,
          "vulnerability_code": "    using SafeMath for uint256;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 17,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function nameFilter(string memory _input)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 75,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        }
      ]
    },
    "oyente": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "Integer Overflow",
          "vulnerability_from_line": 432,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getPlayer(string memory _nameStr) public view returns (address) {\n",
          "message": null
        }
      ]
    },
    "mythril": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "Integer Arithmetic Bugs (SWC 101)",
          "vulnerability_from_line": 437,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function checkIfNameValid(string memory _nameStr)\n",
          "message": "The arithmetic operator can overflow.\nIt is possible to cause an integer overflow or underflow in the arithmetic operation. \nClassification: SWC-101"
        },
        {
          "name": "External Call To User-Supplied Address (SWC 107)",
          "vulnerability_from_line": 421,
          "vulnerability_to_line": null,
          "vulnerability_code": "        _token.transfer(msg.sender, _token.balanceOf(address(this)));\n",
          "message": "A call to a user-supplied address is executed.\nAn external message call to an address specified by the caller is executed. Note that the callee account might contain arbitrary code and could re-enter any function within this contract. Reentering the contract in an intermediate state may lead to unexpected behaviour. Make sure that no state modifications are executed after this call and/or reentrancy guards are in place.\nClassification: SWC-107"
        },
        {
          "name": "External Call To User-Supplied Address (SWC 107)",
          "vulnerability_from_line": 421,
          "vulnerability_to_line": null,
          "vulnerability_code": "        _token.transfer(msg.sender, _token.balanceOf(address(this)));\n",
          "message": "A call to a user-supplied address is executed.\nAn external message call to an address specified by the caller is executed. Note that the callee account might contain arbitrary code and could re-enter any function within this contract. Reentering the contract in an intermediate state may lead to unexpected behaviour. Make sure that no state modifications are executed after this call and/or reentrancy guards are in place.\nClassification: SWC-107"
        },
        {
          "name": "Multiple Calls in a Single Transaction (SWC 113)",
          "vulnerability_from_line": 421,
          "vulnerability_to_line": null,
          "vulnerability_code": "        _token.transfer(msg.sender, _token.balanceOf(address(this)));\n",
          "message": "Multiple calls are executed in the same transaction.\nThis call is executed following another call within the same transaction. It is possible that the call never gets executed if a prior call fails permanently. This might be caused intentionally by a malicious callee. If possible, refactor the code such that each transaction only executes one external call or make sure that all callees can be trusted (i.e. they\u2019re part of your own codebase).\nClassification: SWC-113"
        },
        {
          "name": "External Call To User-Supplied Address (SWC 107)",
          "vulnerability_from_line": 398,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(rewardToken.balanceOf(address(this)) >= reward);\n",
          "message": "A call to a user-supplied address is executed.\nAn external message call to an address specified by the caller is executed. Note that the callee account might contain arbitrary code and could re-enter any function within this contract. Reentering the contract in an intermediate state may lead to unexpected behaviour. Make sure that no state modifications are executed after this call and/or reentrancy guards are in place.\nClassification: SWC-107"
        },
        {
          "name": "State access after external call (SWC 107)",
          "vulnerability_from_line": 400,
          "vulnerability_to_line": null,
          "vulnerability_code": "        rewardToken.transfer(msg.sender, reward);\n",
          "message": "Read of persistent state following external call\nThe contract account state is accessed after an external call to a user defined address. To prevent reentrancy issues, consider accessing the state only before the call, especially if the callee is untrusted. Alternatively, a reentrancy lock can be used to prevent untrusted callees from re-entering the contract in an intermediate state.\nClassification: SWC-107"
        },
        {
          "name": "External Call To User-Supplied Address (SWC 107)",
          "vulnerability_from_line": 400,
          "vulnerability_to_line": null,
          "vulnerability_code": "        rewardToken.transfer(msg.sender, reward);\n",
          "message": "A call to a user-supplied address is executed.\nAn external message call to an address specified by the caller is executed. Note that the callee account might contain arbitrary code and could re-enter any function within this contract. Reentering the contract in an intermediate state may lead to unexpected behaviour. Make sure that no state modifications are executed after this call and/or reentrancy guards are in place.\nClassification: SWC-107"
        },
        {
          "name": "Multiple Calls in a Single Transaction (SWC 113)",
          "vulnerability_from_line": 400,
          "vulnerability_to_line": null,
          "vulnerability_code": "        rewardToken.transfer(msg.sender, reward);\n",
          "message": "Multiple calls are executed in the same transaction.\nThis call is executed following another call within the same transaction. It is possible that the call never gets executed if a prior call fails permanently. This might be caused intentionally by a malicious callee. If possible, refactor the code such that each transaction only executes one external call or make sure that all callees can be trusted (i.e. they\u2019re part of your own codebase).\nClassification: SWC-113"
        },
        {
          "name": "State access after external call (SWC 107)",
          "vulnerability_from_line": 400,
          "vulnerability_to_line": null,
          "vulnerability_code": "        rewardToken.transfer(msg.sender, reward);\n",
          "message": "Write to persistent state following external call\nThe contract account state is accessed after an external call to a user defined address. To prevent reentrancy issues, consider accessing the state only before the call, especially if the callee is untrusted. Alternatively, a reentrancy lock can be used to prevent untrusted callees from re-entering the contract in an intermediate state.\nClassification: SWC-107"
        },
        {
          "name": "State access after external call (SWC 107)",
          "vulnerability_from_line": 402,
          "vulnerability_to_line": null,
          "vulnerability_code": "        ReferralReward[msg.sender] = 0;\n",
          "message": "Write to persistent state following external call\nThe contract account state is accessed after an external call to a user defined address. To prevent reentrancy issues, consider accessing the state only before the call, especially if the callee is untrusted. Alternatively, a reentrancy lock can be used to prevent untrusted callees from re-entering the contract in an intermediate state.\nClassification: SWC-107"
        },
        {
          "name": "Exception State (SWC 110)",
          "vulnerability_from_line": 433,
          "vulnerability_to_line": null,
          "vulnerability_code": "        bytes32 _name = _nameStr.nameFilter();\n",
          "message": "An assertion violation was triggered.\nIt is possible to trigger an assertion violation. Note that Solidity assert() statements should only be used to check invariants. Review the transaction trace generated for this issue and either make sure your program logic is correct, or use require() instead of assert() if your goal is to constrain user inputs or enforce preconditions. Remember to validate inputs from both callers (for instance, via passed arguments) and callees (for instance, via return values).\nClassification: SWC-110"
        },
        {
          "name": "Exception State (SWC 110)",
          "vulnerability_from_line": 442,
          "vulnerability_to_line": null,
          "vulnerability_code": "        bytes32 _name = _nameStr.nameFilter();\n",
          "message": "An assertion violation was triggered.\nIt is possible to trigger an assertion violation. Note that Solidity assert() statements should only be used to check invariants. Review the transaction trace generated for this issue and either make sure your program logic is correct, or use require() instead of assert() if your goal is to constrain user inputs or enforce preconditions. Remember to validate inputs from both callers (for instance, via passed arguments) and callees (for instance, via return values).\nClassification: SWC-110"
        },
        {
          "name": "Exception State (SWC 110)",
          "vulnerability_from_line": 40,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 i = 0; i < _length; i++)\n",
          "message": "An assertion violation was triggered.\nIt is possible to trigger an assertion violation. Note that Solidity assert() statements should only be used to check invariants. Review the transaction trace generated for this issue and either make sure your program logic is correct, or use require() instead of assert() if your goal is to constrain user inputs or enforce preconditions. Remember to validate inputs from both callers (for instance, via passed arguments) and callees (for instance, via return values).\nClassification: SWC-110"
        }
      ]
    },
    "osiris": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "Overflow bugs",
          "vulnerability_from_line": 390,
          "vulnerability_to_line": null,
          "vulnerability_code": "            ReferralRecord[_player] = ReferralRecord[_player] + 1;\n",
          "message": null
        }
      ]
    }
  }
}