{
  "smartbugs_completed": true,
  "analyzer_results": {
    "semgrep": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 970,
          "vulnerability_to_line": null,
          "vulnerability_code": "    for (uint i = 0; i < _selectors.length; i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 1017,
          "vulnerability_to_line": null,
          "vulnerability_code": "    for (uint i = 0; i < _selectors.length; i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 970,
          "vulnerability_to_line": null,
          "vulnerability_code": "    for (uint i = 0; i < _selectors.length; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 1017,
          "vulnerability_to_line": null,
          "vulnerability_code": "    for (uint i = 0; i < _selectors.length; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 15,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require(c / a == b, \"Overflow - Multiplication\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 30,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require(b <= a, \"Underflow - Subtraction\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 39,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require(c >= a, \"Overflow - Addition\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 74,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require(freeMem() == 0x80, \"Memory allocated prior to execution\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 107,
          "vulnerability_to_line": null,
          "vulnerability_code": "      revert(\"Sender is not authorized as a script exec address\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 122,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require(freeMem() == 0x80, \"Memory allocated prior to execution\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 158,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require(ptr >= 0x180, \"Invalid buffer pointer\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 174,
          "vulnerability_to_line": null,
          "vulnerability_code": "      revert('Expected Contract.execute()');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 177,
          "vulnerability_to_line": null,
          "vulnerability_code": "      revert('Invalid buffer pointer');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 203,
          "vulnerability_to_line": null,
          "vulnerability_code": "      revert('Invalid current action - expected STORES');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 209,
          "vulnerability_to_line": null,
          "vulnerability_code": "      revert('Invalid current action - expected EMITS');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 215,
          "vulnerability_to_line": null,
          "vulnerability_code": "      revert('Invalid current action - expected PAYS');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 243,
          "vulnerability_to_line": null,
          "vulnerability_code": "      revert('Duplicate request - stores');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 255,
          "vulnerability_to_line": null,
          "vulnerability_code": "      revert('Duplicate request - emits');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 267,
          "vulnerability_to_line": null,
          "vulnerability_code": "      revert('Duplicate request - pays');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 278,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require(exec_id != bytes32(0), \"Execution id overwritten, or not read\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 284,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require(addr != address(0), \"Sender address overwritten, or not read\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 312,
          "vulnerability_to_line": null,
          "vulnerability_code": "      revert('Unexpected function order - expected storage destination to be pushed');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 325,
          "vulnerability_to_line": null,
          "vulnerability_code": "    ) revert('Unexpected function order - expected storage value to be pushed');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 335,
          "vulnerability_to_line": null,
          "vulnerability_code": "      revert('Unexpected function order - expected payment destination to be pushed');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 345,
          "vulnerability_to_line": null,
          "vulnerability_code": "      revert('Unexpected function order - expected payment amount to be pushed');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 355,
          "vulnerability_to_line": null,
          "vulnerability_code": "      revert('Unexpected function order - expected event to be pushed');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 515,
          "vulnerability_to_line": null,
          "vulnerability_code": "      revert('Expected VAL_INC or VAL_DEC');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 543,
          "vulnerability_to_line": null,
          "vulnerability_code": "      revert('Expected VAL_DEC');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 933,
          "vulnerability_to_line": null,
          "vulnerability_code": "      revert(\"app is already registered\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 936,
          "vulnerability_to_line": null,
          "vulnerability_code": "      revert(\"invalid input arrays\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 989,
          "vulnerability_to_line": null,
          "vulnerability_code": "      revert(\"App has not been registered\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 992,
          "vulnerability_to_line": null,
          "vulnerability_code": "      revert(\"Version already exists\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 997,
          "vulnerability_to_line": null,
          "vulnerability_code": "    ) revert(\"Invalid input array lengths\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 176,
          "vulnerability_to_line": null,
          "vulnerability_code": "    if (buffPtr() != 0 && buffPtr() < 0x180)\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 177,
          "vulnerability_to_line": null,
          "vulnerability_code": "      revert('Invalid buffer pointer');\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 321,
          "vulnerability_to_line": null,
          "vulnerability_code": "    if (\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 322,
          "vulnerability_to_line": null,
          "vulnerability_code": "      expected() != NextFunction.VAL_SET &&\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 323,
          "vulnerability_to_line": null,
          "vulnerability_code": "      expected() != NextFunction.VAL_INC &&\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 324,
          "vulnerability_to_line": null,
          "vulnerability_code": "      expected() != NextFunction.VAL_DEC\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 325,
          "vulnerability_to_line": null,
          "vulnerability_code": "    ) revert('Unexpected function order - expected storage value to be pushed');\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 970,
          "vulnerability_to_line": null,
          "vulnerability_code": "    for (uint i = 0; i < _selectors.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 1017,
          "vulnerability_to_line": null,
          "vulnerability_code": "    for (uint i = 0; i < _selectors.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 74,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require(freeMem() == 0x80, \"Memory allocated prior to execution\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 107,
          "vulnerability_to_line": null,
          "vulnerability_code": "      revert(\"Sender is not authorized as a script exec address\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 122,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require(freeMem() == 0x80, \"Memory allocated prior to execution\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 203,
          "vulnerability_to_line": null,
          "vulnerability_code": "      revert('Invalid current action - expected STORES');\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 209,
          "vulnerability_to_line": null,
          "vulnerability_code": "      revert('Invalid current action - expected EMITS');\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 215,
          "vulnerability_to_line": null,
          "vulnerability_code": "      revert('Invalid current action - expected PAYS');\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 278,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require(exec_id != bytes32(0), \"Execution id overwritten, or not read\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 284,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require(addr != address(0), \"Sender address overwritten, or not read\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 312,
          "vulnerability_to_line": null,
          "vulnerability_code": "      revert('Unexpected function order - expected storage destination to be pushed');\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 325,
          "vulnerability_to_line": null,
          "vulnerability_code": "    ) revert('Unexpected function order - expected storage value to be pushed');\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 335,
          "vulnerability_to_line": null,
          "vulnerability_code": "      revert('Unexpected function order - expected payment destination to be pushed');\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 345,
          "vulnerability_to_line": null,
          "vulnerability_code": "      revert('Unexpected function order - expected payment amount to be pushed');\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 355,
          "vulnerability_to_line": null,
          "vulnerability_code": "      revert('Unexpected function order - expected event to be pushed');\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        }
      ]
    },
    "slither": {
      "successfull_analysis": true,
      "errors": [
        "EXIT_CODE_104"
      ],
      "vulnerability_findings": [
        {
          "name": "constant-function",
          "vulnerability_from_line": 71,
          "vulnerability_to_line": 108,
          "vulnerability_code": "  function authorize(address _script_exec) internal view {\n\n    // No memory should have been allocated yet - expect the free memory pointer\n\n    // to point to 0x80 - and throw if it does not\n\n    require(freeMem() == 0x80, \"Memory allocated prior to execution\");\n\n    // Next, set up memory for execution\n\n    bytes32 perms = EXEC_PERMISSIONS;\n\n    assembly {\n\n      mstore(0x80, sload(0))     // Execution id, read from storage\n\n      mstore(0xa0, sload(1))     // Original sender address, read from storage\n\n      mstore(0xc0, 0)            // Pointer to storage buffer\n\n      mstore(0xe0, 0)            // Bytes4 value of the current action requestor being used\n\n      mstore(0x100, 0)           // Enum representing the next type of function to be called (when pushing to buffer)\n\n      mstore(0x120, 0)           // Number of storage slots written to in buffer\n\n      mstore(0x140, 0)           // Number of events pushed to buffer\n\n      mstore(0x160, 0)           // Number of payment destinations pushed to buffer\n\n\n\n      // Update free memory pointer -\n\n      mstore(0x40, 0x180)\n\n    }\n\n    // Ensure that the sender and execution id returned from storage are nonzero -\n\n    assert(execID() != bytes32(0) && sender() != address(0));\n\n\n\n    // Check that the sender is authorized as a script exec contract for this exec id\n\n    bool authorized;\n\n    assembly {\n\n      // Place the script exec address at 0, and the exec permissions seed after it\n\n      mstore(0, _script_exec)\n\n      mstore(0x20, perms)\n\n      // Hash the resulting 0x34 bytes, and place back into memory at 0\n\n      mstore(0, keccak256(0x0c, 0x34))\n\n      // Place the exec id after the hash -\n\n      mstore(0x20, mload(0x80))\n\n      // Hash the previous hash with the execution id, and check the result\n\n      authorized := sload(keccak256(0, 0x40))\n\n    }\n\n    if (!authorized)\n\n      revert(\"Sender is not authorized as a script exec address\");\n",
          "message": "Contract.authorize (Provider.sol#71-108) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 119,
          "vulnerability_to_line": 139,
          "vulnerability_code": "  function initialize() internal view {\n\n    // No memory should have been allocated yet - expect the free memory pointer\n\n    // to point to 0x80 - and throw if it does not\n\n    require(freeMem() == 0x80, \"Memory allocated prior to execution\");\n\n    // Next, set up memory for execution\n\n    assembly {\n\n      mstore(0x80, sload(0))     // Execution id, read from storage\n\n      mstore(0xa0, sload(1))     // Original sender address, read from storage\n\n      mstore(0xc0, 0)            // Pointer to storage buffer\n\n      mstore(0xe0, 0)            // Bytes4 value of the current action requestor being used\n\n      mstore(0x100, 0)           // Enum representing the next type of function to be called (when pushing to buffer)\n\n      mstore(0x120, 0)           // Number of storage slots written to in buffer\n\n      mstore(0x140, 0)           // Number of events pushed to buffer\n\n      mstore(0x160, 0)           // Number of payment destinations pushed to buffer\n\n\n\n      // Update free memory pointer -\n\n      mstore(0x40, 0x180)\n\n    }\n\n    // Ensure that the sender and execution id returned from storage are expected values -\n\n    assert(execID() != bytes32(0) && sender() != address(0));\n",
          "message": "Contract.initialize (Provider.sol#119-139) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 155,
          "vulnerability_to_line": 167,
          "vulnerability_code": "  function commit() conditions(validState, none) internal pure {\n\n    // Check value of storage buffer pointer - should be at least 0x180\n\n    bytes32 ptr = buffPtr();\n\n    require(ptr >= 0x180, \"Invalid buffer pointer\");\n\n\n\n    assembly {\n\n      // Get the size of the buffer\n\n      let size := mload(add(0x20, ptr))\n\n      mstore(ptr, 0x20) // Place dynamic data offset before buffer\n\n      // Revert to storage\n\n      revert(ptr, add(0x40, size))\n\n    }\n",
          "message": "Contract.commit (Provider.sol#155-167) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 183,
          "vulnerability_to_line": 185,
          "vulnerability_code": "  function buffPtr() private pure returns (bytes32 ptr) {\n\n    assembly { ptr := mload(0xc0) }\n",
          "message": "Contract.buffPtr (Provider.sol#183-185) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 188,
          "vulnerability_to_line": 190,
          "vulnerability_code": "  function freeMem() private pure returns (bytes32 ptr) {\n\n    assembly { ptr := mload(0x40) }\n",
          "message": "Contract.freeMem (Provider.sol#188-190) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 193,
          "vulnerability_to_line": 198,
          "vulnerability_code": "  function currentAction() private pure returns (bytes4 action) {\n\n    if (buffPtr() == bytes32(0))\n\n      return bytes4(0);\n\n\n\n    assembly { action := mload(0xe0) }\n",
          "message": "Contract.currentAction (Provider.sol#193-198) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 219,
          "vulnerability_to_line": 232,
          "vulnerability_code": "  function startBuffer() private pure {\n\n    assembly {\n\n      // Get a pointer to free memory, and place at 0xc0 (storage buffer pointer)\n\n      let ptr := msize()\n\n      mstore(0xc0, ptr)\n\n      // Clear bytes at pointer -\n\n      mstore(ptr, 0)            // temp ptr\n\n      mstore(add(0x20, ptr), 0) // buffer length\n\n      // Update free memory pointer -\n\n      mstore(0x40, add(0x40, ptr))\n\n      // Set expected next function to 'NONE' -\n\n      mstore(0x100, 1)\n\n    }\n",
          "message": "Contract.startBuffer (Provider.sol#219-232) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 276,
          "vulnerability_to_line": 279,
          "vulnerability_code": "  function execID() internal pure returns (bytes32 exec_id) {\n\n    assembly { exec_id := mload(0x80) }\n\n    require(exec_id != bytes32(0), \"Execution id overwritten, or not read\");\n",
          "message": "Contract.execID (Provider.sol#276-279) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 282,
          "vulnerability_to_line": 285,
          "vulnerability_code": "  function sender() internal pure returns (address addr) {\n\n    assembly { addr := mload(0xa0) }\n\n    require(addr != address(0), \"Sender address overwritten, or not read\");\n",
          "message": "Contract.sender (Provider.sol#282-285) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 291,
          "vulnerability_to_line": 294,
          "vulnerability_code": "  function read(bytes32 _location) internal view returns (bytes32 data) {\n\n    data = keccak256(_location, execID());\n\n    assembly { data := sload(data) }\n",
          "message": "Contract.read (Provider.sol#291-294) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 363,
          "vulnerability_to_line": 387,
          "vulnerability_code": "  function storing() conditions(validStoreBuff, isStoring) internal pure {\n\n    bytes4 action_req = STORES;\n\n    assembly {\n\n      // Get pointer to buffer length -\n\n      let ptr := add(0x20, mload(0xc0))\n\n      // Push requestor to the end of buffer, as well as to the 'current action' slot -\n\n      mstore(add(0x20, add(ptr, mload(ptr))), action_req)\n\n      mstore(0xe0, action_req)\n\n      // Push '0' to the end of the 4 bytes just pushed - this will be the length of the STORES action\n\n      mstore(add(0x24, add(ptr, mload(ptr))), 0)\n\n      // Increment buffer length - 0x24 plus the previous length\n\n      mstore(ptr, add(0x24, mload(ptr)))\n\n      // Set the current action being executed (STORES) -\n\n      // SWC-Code With No Effects: L334\n\n      mstore(0xe0, action_req)\n\n      // Set the expected next function - STORE_DEST\n\n      mstore(0x100, 2)\n\n      // Set a pointer to the length of the current request within the buffer\n\n      mstore(sub(ptr, 0x20), add(ptr, mload(ptr)))\n\n      // If the free-memory pointer does not point beyond the buffer's current size, update it\n\n      if lt(mload(0x40), add(0x20, add(ptr, mload(ptr)))) {\n\n        mstore(0x40, add(0x20, add(ptr, mload(ptr))))\n\n      }\n\n    }\n",
          "message": "Contract.storing (Provider.sol#363-387) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 390,
          "vulnerability_to_line": 413,
          "vulnerability_code": "  function set(bytes32 _field) conditions(validStoreDest, validStoreVal) internal pure returns (bytes32) {\n\n    assembly {\n\n      // Get pointer to buffer length -\n\n      let ptr := add(0x20, mload(0xc0))\n\n      // Push storage destination to the end of the buffer -\n\n      mstore(add(0x20, add(ptr, mload(ptr))), _field)\n\n      // Increment buffer length - 0x20 plus the previous length\n\n      mstore(ptr, add(0x20, mload(ptr)))\n\n      // Set the expected next function - VAL_SET\n\n      mstore(0x100, 3)\n\n      // Increment STORES action length -\n\n      mstore(\n\n        mload(sub(ptr, 0x20)),\n\n        add(1, mload(mload(sub(ptr, 0x20))))\n\n      )\n\n      // Update number of storage slots pushed to -\n\n      mstore(0x120, add(1, mload(0x120)))\n\n      // If the free-memory pointer does not point beyond the buffer's current size, update it\n\n      if lt(mload(0x40), add(0x20, add(ptr, mload(ptr)))) {\n\n        mstore(0x40, add(0x20, add(ptr, mload(ptr))))\n\n      }\n\n    }\n\n    return _field;\n",
          "message": "Contract.set (Provider.sol#390-413) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 416,
          "vulnerability_to_line": 431,
          "vulnerability_code": "  function to(bytes32, bytes32 _val) conditions(validStoreVal, validStoreDest) internal pure {\n\n    assembly {\n\n      // Get pointer to buffer length -\n\n      let ptr := add(0x20, mload(0xc0))\n\n      // Push storage value to the end of the buffer -\n\n      mstore(add(0x20, add(ptr, mload(ptr))), _val)\n\n      // Increment buffer length - 0x20 plus the previous length\n\n      mstore(ptr, add(0x20, mload(ptr)))\n\n      // Set the expected next function - STORE_DEST\n\n      mstore(0x100, 2)\n\n      // If the free-memory pointer does not point beyond the buffer's current size, update it\n\n      if lt(mload(0x40), add(0x20, add(ptr, mload(ptr)))) {\n\n        mstore(0x40, add(0x20, add(ptr, mload(ptr))))\n\n      }\n\n    }\n",
          "message": "Contract.to (Provider.sol#416-431) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 451,
          "vulnerability_to_line": 477,
          "vulnerability_code": "  function increase(bytes32 _field) conditions(validStoreDest, validStoreVal) internal view returns (bytes32 val) {\n\n    // Read value stored at the location in storage -\n\n    val = keccak256(_field, execID());\n\n    assembly {\n\n      val := sload(val)\n\n      // Get pointer to buffer length -\n\n      let ptr := add(0x20, mload(0xc0))\n\n      // Push storage destination to the end of the buffer -\n\n      mstore(add(0x20, add(ptr, mload(ptr))), _field)\n\n      // Increment buffer length - 0x20 plus the previous length\n\n      mstore(ptr, add(0x20, mload(ptr)))\n\n      // Set the expected next function - VAL_INC\n\n      mstore(0x100, 4)\n\n      // Increment STORES action length -\n\n      mstore(\n\n        mload(sub(ptr, 0x20)),\n\n        add(1, mload(mload(sub(ptr, 0x20))))\n\n      )\n\n      // Update number of storage slots pushed to -\n\n      mstore(0x120, add(1, mload(0x120)))\n\n      // If the free-memory pointer does not point beyond the buffer's current size, update it\n\n      if lt(mload(0x40), add(0x20, add(ptr, mload(ptr)))) {\n\n        mstore(0x40, add(0x20, add(ptr, mload(ptr))))\n\n      }\n\n    }\n\n    return val;\n",
          "message": "Contract.increase (Provider.sol#451-477) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 479,
          "vulnerability_to_line": 505,
          "vulnerability_code": "  function decrease(bytes32 _field) conditions(validStoreDest, validStoreVal) internal view returns (bytes32 val) {\n\n    // Read value stored at the location in storage -\n\n    val = keccak256(_field, execID());\n\n    assembly {\n\n      val := sload(val)\n\n      // Get pointer to buffer length -\n\n      let ptr := add(0x20, mload(0xc0))\n\n      // Push storage destination to the end of the buffer -\n\n      mstore(add(0x20, add(ptr, mload(ptr))), _field)\n\n      // Increment buffer length - 0x20 plus the previous length\n\n      mstore(ptr, add(0x20, mload(ptr)))\n\n      // Set the expected next function - VAL_DEC\n\n      mstore(0x100, 5)\n\n      // Increment STORES action length -\n\n      mstore(\n\n        mload(sub(ptr, 0x20)),\n\n        add(1, mload(mload(sub(ptr, 0x20))))\n\n      )\n\n      // Update number of storage slots pushed to -\n\n      mstore(0x120, add(1, mload(0x120)))\n\n      // If the free-memory pointer does not point beyond the buffer's current size, update it\n\n      if lt(mload(0x40), add(0x20, add(ptr, mload(ptr)))) {\n\n        mstore(0x40, add(0x20, add(ptr, mload(ptr))))\n\n      }\n\n    }\n\n    return val;\n",
          "message": "Contract.decrease (Provider.sol#479-505) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 507,
          "vulnerability_to_line": 531,
          "vulnerability_code": "  function by(bytes32 _val, uint _amt) conditions(validStoreVal, validStoreDest) internal pure {\n\n    // Check the expected function type - if it is VAL_INC, perform safe-add on the value\n\n    // If it is VAL_DEC, perform safe-sub on the value\n\n    if (expected() == NextFunction.VAL_INC)\n\n      _amt = _amt.add(uint(_val));\n\n    else if (expected() == NextFunction.VAL_DEC)\n\n      _amt = uint(_val).sub(_amt);\n\n    else\n\n      revert('Expected VAL_INC or VAL_DEC');\n\n\n\n    assembly {\n\n      // Get pointer to buffer length -\n\n      let ptr := add(0x20, mload(0xc0))\n\n      // Push storage value to the end of the buffer -\n\n      mstore(add(0x20, add(ptr, mload(ptr))), _amt)\n\n      // Increment buffer length - 0x20 plus the previous length\n\n      mstore(ptr, add(0x20, mload(ptr)))\n\n      // Set the expected next function - STORE_DEST\n\n      mstore(0x100, 2)\n\n      // If the free-memory pointer does not point beyond the buffer's current size, update it\n\n      if lt(mload(0x40), add(0x20, add(ptr, mload(ptr)))) {\n\n        mstore(0x40, add(0x20, add(ptr, mload(ptr))))\n\n      }\n\n    }\n",
          "message": "Contract.by (Provider.sol#507-531) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 534,
          "vulnerability_to_line": 560,
          "vulnerability_code": "  function byMaximum(bytes32 _val, uint _amt) conditions(validStoreVal, validStoreDest) internal pure {\n\n    // Check the expected function type - if it is VAL_DEC, set the new amount to the difference of\n\n    // _val and _amt, to a minimum of 0\n\n    if (expected() == NextFunction.VAL_DEC) {\n\n      if (_amt > uint(_val))\n\n        _amt = 0;\n\n      else\n\n        _amt = uint(_val).sub(_amt);\n\n    } else {\n\n      revert('Expected VAL_DEC');\n\n    }\n\n\n\n    assembly {\n\n      // Get pointer to buffer length -\n\n      let ptr := add(0x20, mload(0xc0))\n\n      // Push storage value to the end of the buffer -\n\n      mstore(add(0x20, add(ptr, mload(ptr))), _amt)\n\n      // Increment buffer length - 0x20 plus the previous length\n\n      mstore(ptr, add(0x20, mload(ptr)))\n\n      // Set the expected next function - STORE_DEST\n\n      mstore(0x100, 2)\n\n      // If the free-memory pointer does not point beyond the buffer's current size, update it\n\n      if lt(mload(0x40), add(0x20, add(ptr, mload(ptr)))) {\n\n        mstore(0x40, add(0x20, add(ptr, mload(ptr))))\n\n      }\n\n    }\n",
          "message": "Contract.byMaximum (Provider.sol#534-560) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 564,
          "vulnerability_to_line": 587,
          "vulnerability_code": "  function emitting() conditions(validEmitBuff, isEmitting) internal pure {\n\n    bytes4 action_req = EMITS;\n\n    assembly {\n\n      // Get pointer to buffer length -\n\n      let ptr := add(0x20, mload(0xc0))\n\n      // Push requestor to the end of buffer, as well as to the 'current action' slot -\n\n      mstore(add(0x20, add(ptr, mload(ptr))), action_req)\n\n      mstore(0xe0, action_req)\n\n      // Push '0' to the end of the 4 bytes just pushed - this will be the length of the EMITS action\n\n      mstore(add(0x24, add(ptr, mload(ptr))), 0)\n\n      // Increment buffer length - 0x24 plus the previous length\n\n      mstore(ptr, add(0x24, mload(ptr)))\n\n      // Set the current action being executed (EMITS) -\n\n      mstore(0xe0, action_req)\n\n      // Set the expected next function - EMIT_LOG\n\n      mstore(0x100, 6)\n\n      // Set a pointer to the length of the current request within the buffer\n\n      mstore(sub(ptr, 0x20), add(ptr, mload(ptr)))\n\n      // If the free-memory pointer does not point beyond the buffer's current size, update it\n\n      if lt(mload(0x40), add(0x20, add(ptr, mload(ptr)))) {\n\n        mstore(0x40, add(0x20, add(ptr, mload(ptr))))\n\n      }\n\n    }\n",
          "message": "Contract.emitting (Provider.sol#564-587) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 589,
          "vulnerability_to_line": 622,
          "vulnerability_code": "  function log(bytes32 _data) conditions(validEvent, validEvent) internal pure {\n\n    assembly {\n\n      // Get pointer to buffer length -\n\n      let ptr := add(0x20, mload(0xc0))\n\n      // Push 0 to the end of the buffer - event will have 0 topics\n\n      mstore(add(0x20, add(ptr, mload(ptr))), 0)\n\n      // If _data is zero, set data size to 0 in buffer and push -\n\n      if eq(_data, 0) {\n\n        mstore(add(0x40, add(ptr, mload(ptr))), 0)\n\n        // Increment buffer length - 0x40 plus the original length\n\n        mstore(ptr, add(0x40, mload(ptr)))\n\n      }\n\n      // If _data is not zero, set size to 0x20 and push to buffer -\n\n      if iszero(eq(_data, 0)) {\n\n        // Push data size (0x20) to the end of the buffer\n\n        mstore(add(0x40, add(ptr, mload(ptr))), 0x20)\n\n        // Push data to the end of the buffer\n\n        mstore(add(0x60, add(ptr, mload(ptr))), _data)\n\n        // Increment buffer length - 0x60 plus the original length\n\n        mstore(ptr, add(0x60, mload(ptr)))\n\n      }\n\n      // Increment EMITS action length -\n\n      mstore(\n\n        mload(sub(ptr, 0x20)),\n\n        add(1, mload(mload(sub(ptr, 0x20))))\n\n      )\n\n      // Update number of events pushed to buffer -\n\n      mstore(0x140, add(1, mload(0x140)))\n\n      // If the free-memory pointer does not point beyond the buffer's current size, update it\n\n      if lt(mload(0x40), add(0x20, add(ptr, mload(ptr)))) {\n\n        mstore(0x40, add(0x20, add(ptr, mload(ptr))))\n\n      }\n\n    }\n",
          "message": "Contract.log (Provider.sol#589-622) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 624,
          "vulnerability_to_line": 659,
          "vulnerability_code": "  function log(bytes32[1] memory _topics, bytes32 _data) conditions(validEvent, validEvent) internal pure {\n\n    assembly {\n\n      // Get pointer to buffer length -\n\n      let ptr := add(0x20, mload(0xc0))\n\n      // Push 1 to the end of the buffer - event will have 1 topic\n\n      mstore(add(0x20, add(ptr, mload(ptr))), 1)\n\n      // Push topic to end of buffer\n\n      mstore(add(0x40, add(ptr, mload(ptr))), mload(_topics))\n\n      // If _data is zero, set data size to 0 in buffer and push -\n\n      if eq(_data, 0) {\n\n        mstore(add(0x60, add(ptr, mload(ptr))), 0)\n\n        // Increment buffer length - 0x60 plus the original length\n\n        mstore(ptr, add(0x60, mload(ptr)))\n\n      }\n\n      // If _data is not zero, set size to 0x20 and push to buffer -\n\n      if iszero(eq(_data, 0)) {\n\n        // Push data size (0x20) to the end of the buffer\n\n        mstore(add(0x60, add(ptr, mload(ptr))), 0x20)\n\n        // Push data to the end of the buffer\n\n        mstore(add(0x80, add(ptr, mload(ptr))), _data)\n\n        // Increment buffer length - 0x80 plus the original length\n\n        mstore(ptr, add(0x80, mload(ptr)))\n\n      }\n\n      // Increment EMITS action length -\n\n      mstore(\n\n        mload(sub(ptr, 0x20)),\n\n        add(1, mload(mload(sub(ptr, 0x20))))\n\n      )\n\n      // Update number of events pushed to buffer -\n\n      mstore(0x140, add(1, mload(0x140)))\n\n      // If the free-memory pointer does not point beyond the buffer's current size, update it\n\n      if lt(mload(0x40), add(0x20, add(ptr, mload(ptr)))) {\n\n        mstore(0x40, add(0x20, add(ptr, mload(ptr))))\n\n      }\n\n    }\n",
          "message": "Contract.log (Provider.sol#624-659) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 661,
          "vulnerability_to_line": 697,
          "vulnerability_code": "  function log(bytes32[2] memory _topics, bytes32 _data) conditions(validEvent, validEvent) internal pure {\n\n    assembly {\n\n      // Get pointer to buffer length -\n\n      let ptr := add(0x20, mload(0xc0))\n\n      // Push 2 to the end of the buffer - event will have 2 topics\n\n      mstore(add(0x20, add(ptr, mload(ptr))), 2)\n\n      // Push topics to end of buffer\n\n      mstore(add(0x40, add(ptr, mload(ptr))), mload(_topics))\n\n      mstore(add(0x60, add(ptr, mload(ptr))), mload(add(0x20, _topics)))\n\n      // If _data is zero, set data size to 0 in buffer and push -\n\n      if eq(_data, 0) {\n\n        mstore(add(0x80, add(ptr, mload(ptr))), 0)\n\n        // Increment buffer length - 0x80 plus the original length\n\n        mstore(ptr, add(0x80, mload(ptr)))\n\n      }\n\n      // If _data is not zero, set size to 0x20 and push to buffer -\n\n      if iszero(eq(_data, 0)) {\n\n        // Push data size (0x20) to the end of the buffer\n\n        mstore(add(0x80, add(ptr, mload(ptr))), 0x20)\n\n        // Push data to the end of the buffer\n\n        mstore(add(0xa0, add(ptr, mload(ptr))), _data)\n\n        // Increment buffer length - 0xa0 plus the original length\n\n        mstore(ptr, add(0xa0, mload(ptr)))\n\n      }\n\n      // Increment EMITS action length -\n\n      mstore(\n\n        mload(sub(ptr, 0x20)),\n\n        add(1, mload(mload(sub(ptr, 0x20))))\n\n      )\n\n      // Update number of events pushed to buffer -\n\n      mstore(0x140, add(1, mload(0x140)))\n\n      // If the free-memory pointer does not point beyond the buffer's current size, update it\n\n      if lt(mload(0x40), add(0x20, add(ptr, mload(ptr)))) {\n\n        mstore(0x40, add(0x20, add(ptr, mload(ptr))))\n\n      }\n\n    }\n",
          "message": "Contract.log (Provider.sol#661-697) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 699,
          "vulnerability_to_line": 736,
          "vulnerability_code": "  function log(bytes32[3] memory _topics, bytes32 _data) conditions(validEvent, validEvent) internal pure {\n\n    assembly {\n\n      // Get pointer to buffer length -\n\n      let ptr := add(0x20, mload(0xc0))\n\n      // Push 3 to the end of the buffer - event will have 3 topics\n\n      mstore(add(0x20, add(ptr, mload(ptr))), 3)\n\n      // Push topics to end of buffer\n\n      mstore(add(0x40, add(ptr, mload(ptr))), mload(_topics))\n\n      mstore(add(0x60, add(ptr, mload(ptr))), mload(add(0x20, _topics)))\n\n      mstore(add(0x80, add(ptr, mload(ptr))), mload(add(0x40, _topics)))\n\n      // If _data is zero, set data size to 0 in buffer and push -\n\n      if eq(_data, 0) {\n\n        mstore(add(0xa0, add(ptr, mload(ptr))), 0)\n\n        // Increment buffer length - 0xa0 plus the original length\n\n        mstore(ptr, add(0xa0, mload(ptr)))\n\n      }\n\n      // If _data is not zero, set size to 0x20 and push to buffer -\n\n      if iszero(eq(_data, 0)) {\n\n        // Push data size (0x20) to the end of the buffer\n\n        mstore(add(0xa0, add(ptr, mload(ptr))), 0x20)\n\n        // Push data to the end of the buffer\n\n        mstore(add(0xc0, add(ptr, mload(ptr))), _data)\n\n        // Increment buffer length - 0xc0 plus the original length\n\n        mstore(ptr, add(0xc0, mload(ptr)))\n\n      }\n\n      // Increment EMITS action length -\n\n      mstore(\n\n        mload(sub(ptr, 0x20)),\n\n        add(1, mload(mload(sub(ptr, 0x20))))\n\n      )\n\n      // Update number of events pushed to buffer -\n\n      mstore(0x140, add(1, mload(0x140)))\n\n      // If the free-memory pointer does not point beyond the buffer's current size, update it\n\n      if lt(mload(0x40), add(0x20, add(ptr, mload(ptr)))) {\n\n        mstore(0x40, add(0x20, add(ptr, mload(ptr))))\n\n      }\n\n    }\n",
          "message": "Contract.log (Provider.sol#699-736) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 738,
          "vulnerability_to_line": 776,
          "vulnerability_code": "  function log(bytes32[4] memory _topics, bytes32 _data) conditions(validEvent, validEvent) internal pure {\n\n    assembly {\n\n      // Get pointer to buffer length -\n\n      let ptr := add(0x20, mload(0xc0))\n\n      // Push 4 to the end of the buffer - event will have 4 topics\n\n      mstore(add(0x20, add(ptr, mload(ptr))), 4)\n\n      // Push topics to end of buffer\n\n      mstore(add(0x40, add(ptr, mload(ptr))), mload(_topics))\n\n      mstore(add(0x60, add(ptr, mload(ptr))), mload(add(0x20, _topics)))\n\n      mstore(add(0x80, add(ptr, mload(ptr))), mload(add(0x40, _topics)))\n\n      mstore(add(0xa0, add(ptr, mload(ptr))), mload(add(0x60, _topics)))\n\n      // If _data is zero, set data size to 0 in buffer and push -\n\n      if eq(_data, 0) {\n\n        mstore(add(0xc0, add(ptr, mload(ptr))), 0)\n\n        // Increment buffer length - 0xc0 plus the original length\n\n        mstore(ptr, add(0xc0, mload(ptr)))\n\n      }\n\n      // If _data is not zero, set size to 0x20 and push to buffer -\n\n      if iszero(eq(_data, 0)) {\n\n        // Push data size (0x20) to the end of the buffer\n\n        mstore(add(0xc0, add(ptr, mload(ptr))), 0x20)\n\n        // Push data to the end of the buffer\n\n        mstore(add(0xe0, add(ptr, mload(ptr))), _data)\n\n        // Increment buffer length - 0xe0 plus the original length\n\n        mstore(ptr, add(0xe0, mload(ptr)))\n\n      }\n\n      // Increment EMITS action length -\n\n      mstore(\n\n        mload(sub(ptr, 0x20)),\n\n        add(1, mload(mload(sub(ptr, 0x20))))\n\n      )\n\n      // Update number of events pushed to buffer -\n\n      mstore(0x140, add(1, mload(0x140)))\n\n      // If the free-memory pointer does not point beyond the buffer's current size, update it\n\n      if lt(mload(0x40), add(0x20, add(ptr, mload(ptr)))) {\n\n        mstore(0x40, add(0x20, add(ptr, mload(ptr))))\n\n      }\n\n    }\n",
          "message": "Contract.log (Provider.sol#738-776) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 780,
          "vulnerability_to_line": 803,
          "vulnerability_code": "  function paying() conditions(validPayBuff, isPaying) internal pure {\n\n    bytes4 action_req = PAYS;\n\n    assembly {\n\n      // Get pointer to buffer length -\n\n      let ptr := add(0x20, mload(0xc0))\n\n      // Push requestor to the end of buffer, as well as to the 'current action' slot -\n\n      mstore(add(0x20, add(ptr, mload(ptr))), action_req)\n\n      mstore(0xe0, action_req)\n\n      // Push '0' to the end of the 4 bytes just pushed - this will be the length of the PAYS action\n\n      mstore(add(0x24, add(ptr, mload(ptr))), 0)\n\n      // Increment buffer length - 0x24 plus the previous length\n\n      mstore(ptr, add(0x24, mload(ptr)))\n\n      // Set the current action being executed (PAYS) -\n\n      mstore(0xe0, action_req)\n\n      // Set the expected next function - PAY_AMT\n\n      mstore(0x100, 8)\n\n      // Set a pointer to the length of the current request within the buffer\n\n      mstore(sub(ptr, 0x20), add(ptr, mload(ptr)))\n\n      // If the free-memory pointer does not point beyond the buffer's current size, update it\n\n      if lt(mload(0x40), add(0x20, add(ptr, mload(ptr)))) {\n\n        mstore(0x40, add(0x20, add(ptr, mload(ptr))))\n\n      }\n\n    }\n",
          "message": "Contract.paying (Provider.sol#780-803) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 806,
          "vulnerability_to_line": 829,
          "vulnerability_code": "  function pay(uint _amount) conditions(validPayAmt, validPayDest) internal pure returns (uint) {\n\n    assembly {\n\n      // Get pointer to buffer length -\n\n      let ptr := add(0x20, mload(0xc0))\n\n      // Push payment amount to the end of the buffer -\n\n      mstore(add(0x20, add(ptr, mload(ptr))), _amount)\n\n      // Increment buffer length - 0x20 plus the previous length\n\n      mstore(ptr, add(0x20, mload(ptr)))\n\n      // Set the expected next function - PAY_DEST\n\n      mstore(0x100, 7)\n\n      // Increment PAYS action length -\n\n      mstore(\n\n        mload(sub(ptr, 0x20)),\n\n        add(1, mload(mload(sub(ptr, 0x20))))\n\n      )\n\n      // Update number of payment destinations to be pushed to -\n\n      mstore(0x160, add(1, mload(0x160)))\n\n      // If the free-memory pointer does not point beyond the buffer's current size, update it\n\n      if lt(mload(0x40), add(0x20, add(ptr, mload(ptr)))) {\n\n        mstore(0x40, add(0x20, add(ptr, mload(ptr))))\n\n      }\n\n    }\n\n    return _amount;\n",
          "message": "Contract.pay (Provider.sol#806-829) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 832,
          "vulnerability_to_line": 847,
          "vulnerability_code": "  function toAcc(uint, address _dest) conditions(validPayDest, validPayAmt) internal pure {\n\n    assembly {\n\n      // Get pointer to buffer length -\n\n      let ptr := add(0x20, mload(0xc0))\n\n      // Push payment destination to the end of the buffer -\n\n      mstore(add(0x20, add(ptr, mload(ptr))), _dest)\n\n      // Increment buffer length - 0x20 plus the previous length\n\n      mstore(ptr, add(0x20, mload(ptr)))\n\n      // Set the expected next function - PAY_AMT\n\n      mstore(0x100, 8)\n\n      // If the free-memory pointer does not point beyond the buffer's current size, update it\n\n      if lt(mload(0x40), add(0x20, add(ptr, mload(ptr)))) {\n\n        mstore(0x40, add(0x20, add(ptr, mload(ptr))))\n\n      }\n\n    }\n",
          "message": "Contract.toAcc (Provider.sol#832-847) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 850,
          "vulnerability_to_line": 852,
          "vulnerability_code": "  function expected() private pure returns (NextFunction next) {\n\n    assembly { next := mload(0x100) }\n",
          "message": "Contract.expected (Provider.sol#850-852) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 855,
          "vulnerability_to_line": 861,
          "vulnerability_code": "  function emitted() internal pure returns (uint num_emitted) {\n\n    if (buffPtr() == bytes32(0))\n\n      return 0;\n\n\n\n    // Load number emitted from buffer -\n\n    assembly { num_emitted := mload(0x140) }\n",
          "message": "Contract.emitted (Provider.sol#855-861) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 864,
          "vulnerability_to_line": 870,
          "vulnerability_code": "  function stored() internal pure returns (uint num_stored) {\n\n    if (buffPtr() == bytes32(0))\n\n      return 0;\n\n\n\n    // Load number stored from buffer -\n\n    assembly { num_stored := mload(0x120) }\n",
          "message": "Contract.stored (Provider.sol#864-870) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 873,
          "vulnerability_to_line": 879,
          "vulnerability_code": "  function paid() internal pure returns (uint num_paid) {\n\n    if (buffPtr() == bytes32(0))\n\n      return 0;\n\n\n\n    // Load number paid from buffer -\n\n    assembly { num_paid := mload(0x160) }\n",
          "message": "Contract.paid (Provider.sol#873-879) is declared view but contains assembly code\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 71,
          "vulnerability_to_line": 108,
          "vulnerability_code": "  function authorize(address _script_exec) internal view {\n\n    // No memory should have been allocated yet - expect the free memory pointer\n\n    // to point to 0x80 - and throw if it does not\n\n    require(freeMem() == 0x80, \"Memory allocated prior to execution\");\n\n    // Next, set up memory for execution\n\n    bytes32 perms = EXEC_PERMISSIONS;\n\n    assembly {\n\n      mstore(0x80, sload(0))     // Execution id, read from storage\n\n      mstore(0xa0, sload(1))     // Original sender address, read from storage\n\n      mstore(0xc0, 0)            // Pointer to storage buffer\n\n      mstore(0xe0, 0)            // Bytes4 value of the current action requestor being used\n\n      mstore(0x100, 0)           // Enum representing the next type of function to be called (when pushing to buffer)\n\n      mstore(0x120, 0)           // Number of storage slots written to in buffer\n\n      mstore(0x140, 0)           // Number of events pushed to buffer\n\n      mstore(0x160, 0)           // Number of payment destinations pushed to buffer\n\n\n\n      // Update free memory pointer -\n\n      mstore(0x40, 0x180)\n\n    }\n\n    // Ensure that the sender and execution id returned from storage are nonzero -\n\n    assert(execID() != bytes32(0) && sender() != address(0));\n\n\n\n    // Check that the sender is authorized as a script exec contract for this exec id\n\n    bool authorized;\n\n    assembly {\n\n      // Place the script exec address at 0, and the exec permissions seed after it\n\n      mstore(0, _script_exec)\n\n      mstore(0x20, perms)\n\n      // Hash the resulting 0x34 bytes, and place back into memory at 0\n\n      mstore(0, keccak256(0x0c, 0x34))\n\n      // Place the exec id after the hash -\n\n      mstore(0x20, mload(0x80))\n\n      // Hash the previous hash with the execution id, and check the result\n\n      authorized := sload(keccak256(0, 0x40))\n\n    }\n\n    if (!authorized)\n\n      revert(\"Sender is not authorized as a script exec address\");\n",
          "message": "Contract.authorize uses assembly (Provider.sol#71-108)\n\t- Provider.sol#77-91\n\t- Provider.sol#95-106\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 119,
          "vulnerability_to_line": 139,
          "vulnerability_code": "  function initialize() internal view {\n\n    // No memory should have been allocated yet - expect the free memory pointer\n\n    // to point to 0x80 - and throw if it does not\n\n    require(freeMem() == 0x80, \"Memory allocated prior to execution\");\n\n    // Next, set up memory for execution\n\n    assembly {\n\n      mstore(0x80, sload(0))     // Execution id, read from storage\n\n      mstore(0xa0, sload(1))     // Original sender address, read from storage\n\n      mstore(0xc0, 0)            // Pointer to storage buffer\n\n      mstore(0xe0, 0)            // Bytes4 value of the current action requestor being used\n\n      mstore(0x100, 0)           // Enum representing the next type of function to be called (when pushing to buffer)\n\n      mstore(0x120, 0)           // Number of storage slots written to in buffer\n\n      mstore(0x140, 0)           // Number of events pushed to buffer\n\n      mstore(0x160, 0)           // Number of payment destinations pushed to buffer\n\n\n\n      // Update free memory pointer -\n\n      mstore(0x40, 0x180)\n\n    }\n\n    // Ensure that the sender and execution id returned from storage are expected values -\n\n    assert(execID() != bytes32(0) && sender() != address(0));\n",
          "message": "Contract.initialize uses assembly (Provider.sol#119-139)\n\t- Provider.sol#124-138\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 155,
          "vulnerability_to_line": 167,
          "vulnerability_code": "  function commit() conditions(validState, none) internal pure {\n\n    // Check value of storage buffer pointer - should be at least 0x180\n\n    bytes32 ptr = buffPtr();\n\n    require(ptr >= 0x180, \"Invalid buffer pointer\");\n\n\n\n    assembly {\n\n      // Get the size of the buffer\n\n      let size := mload(add(0x20, ptr))\n\n      mstore(ptr, 0x20) // Place dynamic data offset before buffer\n\n      // Revert to storage\n\n      revert(ptr, add(0x40, size))\n\n    }\n",
          "message": "Contract.commit uses assembly (Provider.sol#155-167)\n\t- Provider.sol#160-167\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 183,
          "vulnerability_to_line": 185,
          "vulnerability_code": "  function buffPtr() private pure returns (bytes32 ptr) {\n\n    assembly { ptr := mload(0xc0) }\n",
          "message": "Contract.buffPtr uses assembly (Provider.sol#183-185)\n\t- Provider.sol#184-185\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 188,
          "vulnerability_to_line": 190,
          "vulnerability_code": "  function freeMem() private pure returns (bytes32 ptr) {\n\n    assembly { ptr := mload(0x40) }\n",
          "message": "Contract.freeMem uses assembly (Provider.sol#188-190)\n\t- Provider.sol#189-190\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 193,
          "vulnerability_to_line": 198,
          "vulnerability_code": "  function currentAction() private pure returns (bytes4 action) {\n\n    if (buffPtr() == bytes32(0))\n\n      return bytes4(0);\n\n\n\n    assembly { action := mload(0xe0) }\n",
          "message": "Contract.currentAction uses assembly (Provider.sol#193-198)\n\t- Provider.sol#197-198\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 219,
          "vulnerability_to_line": 232,
          "vulnerability_code": "  function startBuffer() private pure {\n\n    assembly {\n\n      // Get a pointer to free memory, and place at 0xc0 (storage buffer pointer)\n\n      let ptr := msize()\n\n      mstore(0xc0, ptr)\n\n      // Clear bytes at pointer -\n\n      mstore(ptr, 0)            // temp ptr\n\n      mstore(add(0x20, ptr), 0) // buffer length\n\n      // Update free memory pointer -\n\n      mstore(0x40, add(0x40, ptr))\n\n      // Set expected next function to 'NONE' -\n\n      mstore(0x100, 1)\n\n    }\n",
          "message": "Contract.startBuffer uses assembly (Provider.sol#219-232)\n\t- Provider.sol#220-232\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 276,
          "vulnerability_to_line": 279,
          "vulnerability_code": "  function execID() internal pure returns (bytes32 exec_id) {\n\n    assembly { exec_id := mload(0x80) }\n\n    require(exec_id != bytes32(0), \"Execution id overwritten, or not read\");\n",
          "message": "Contract.execID uses assembly (Provider.sol#276-279)\n\t- Provider.sol#277-278\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 282,
          "vulnerability_to_line": 285,
          "vulnerability_code": "  function sender() internal pure returns (address addr) {\n\n    assembly { addr := mload(0xa0) }\n\n    require(addr != address(0), \"Sender address overwritten, or not read\");\n",
          "message": "Contract.sender uses assembly (Provider.sol#282-285)\n\t- Provider.sol#283-284\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 291,
          "vulnerability_to_line": 294,
          "vulnerability_code": "  function read(bytes32 _location) internal view returns (bytes32 data) {\n\n    data = keccak256(_location, execID());\n\n    assembly { data := sload(data) }\n",
          "message": "Contract.read uses assembly (Provider.sol#291-294)\n\t- Provider.sol#293-294\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 363,
          "vulnerability_to_line": 387,
          "vulnerability_code": "  function storing() conditions(validStoreBuff, isStoring) internal pure {\n\n    bytes4 action_req = STORES;\n\n    assembly {\n\n      // Get pointer to buffer length -\n\n      let ptr := add(0x20, mload(0xc0))\n\n      // Push requestor to the end of buffer, as well as to the 'current action' slot -\n\n      mstore(add(0x20, add(ptr, mload(ptr))), action_req)\n\n      mstore(0xe0, action_req)\n\n      // Push '0' to the end of the 4 bytes just pushed - this will be the length of the STORES action\n\n      mstore(add(0x24, add(ptr, mload(ptr))), 0)\n\n      // Increment buffer length - 0x24 plus the previous length\n\n      mstore(ptr, add(0x24, mload(ptr)))\n\n      // Set the current action being executed (STORES) -\n\n      // SWC-Code With No Effects: L334\n\n      mstore(0xe0, action_req)\n\n      // Set the expected next function - STORE_DEST\n\n      mstore(0x100, 2)\n\n      // Set a pointer to the length of the current request within the buffer\n\n      mstore(sub(ptr, 0x20), add(ptr, mload(ptr)))\n\n      // If the free-memory pointer does not point beyond the buffer's current size, update it\n\n      if lt(mload(0x40), add(0x20, add(ptr, mload(ptr)))) {\n\n        mstore(0x40, add(0x20, add(ptr, mload(ptr))))\n\n      }\n\n    }\n",
          "message": "Contract.storing uses assembly (Provider.sol#363-387)\n\t- Provider.sol#365-387\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 390,
          "vulnerability_to_line": 413,
          "vulnerability_code": "  function set(bytes32 _field) conditions(validStoreDest, validStoreVal) internal pure returns (bytes32) {\n\n    assembly {\n\n      // Get pointer to buffer length -\n\n      let ptr := add(0x20, mload(0xc0))\n\n      // Push storage destination to the end of the buffer -\n\n      mstore(add(0x20, add(ptr, mload(ptr))), _field)\n\n      // Increment buffer length - 0x20 plus the previous length\n\n      mstore(ptr, add(0x20, mload(ptr)))\n\n      // Set the expected next function - VAL_SET\n\n      mstore(0x100, 3)\n\n      // Increment STORES action length -\n\n      mstore(\n\n        mload(sub(ptr, 0x20)),\n\n        add(1, mload(mload(sub(ptr, 0x20))))\n\n      )\n\n      // Update number of storage slots pushed to -\n\n      mstore(0x120, add(1, mload(0x120)))\n\n      // If the free-memory pointer does not point beyond the buffer's current size, update it\n\n      if lt(mload(0x40), add(0x20, add(ptr, mload(ptr)))) {\n\n        mstore(0x40, add(0x20, add(ptr, mload(ptr))))\n\n      }\n\n    }\n\n    return _field;\n",
          "message": "Contract.set uses assembly (Provider.sol#390-413)\n\t- Provider.sol#391-412\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 416,
          "vulnerability_to_line": 431,
          "vulnerability_code": "  function to(bytes32, bytes32 _val) conditions(validStoreVal, validStoreDest) internal pure {\n\n    assembly {\n\n      // Get pointer to buffer length -\n\n      let ptr := add(0x20, mload(0xc0))\n\n      // Push storage value to the end of the buffer -\n\n      mstore(add(0x20, add(ptr, mload(ptr))), _val)\n\n      // Increment buffer length - 0x20 plus the previous length\n\n      mstore(ptr, add(0x20, mload(ptr)))\n\n      // Set the expected next function - STORE_DEST\n\n      mstore(0x100, 2)\n\n      // If the free-memory pointer does not point beyond the buffer's current size, update it\n\n      if lt(mload(0x40), add(0x20, add(ptr, mload(ptr)))) {\n\n        mstore(0x40, add(0x20, add(ptr, mload(ptr))))\n\n      }\n\n    }\n",
          "message": "Contract.to uses assembly (Provider.sol#416-431)\n\t- Provider.sol#417-431\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 451,
          "vulnerability_to_line": 477,
          "vulnerability_code": "  function increase(bytes32 _field) conditions(validStoreDest, validStoreVal) internal view returns (bytes32 val) {\n\n    // Read value stored at the location in storage -\n\n    val = keccak256(_field, execID());\n\n    assembly {\n\n      val := sload(val)\n\n      // Get pointer to buffer length -\n\n      let ptr := add(0x20, mload(0xc0))\n\n      // Push storage destination to the end of the buffer -\n\n      mstore(add(0x20, add(ptr, mload(ptr))), _field)\n\n      // Increment buffer length - 0x20 plus the previous length\n\n      mstore(ptr, add(0x20, mload(ptr)))\n\n      // Set the expected next function - VAL_INC\n\n      mstore(0x100, 4)\n\n      // Increment STORES action length -\n\n      mstore(\n\n        mload(sub(ptr, 0x20)),\n\n        add(1, mload(mload(sub(ptr, 0x20))))\n\n      )\n\n      // Update number of storage slots pushed to -\n\n      mstore(0x120, add(1, mload(0x120)))\n\n      // If the free-memory pointer does not point beyond the buffer's current size, update it\n\n      if lt(mload(0x40), add(0x20, add(ptr, mload(ptr)))) {\n\n        mstore(0x40, add(0x20, add(ptr, mload(ptr))))\n\n      }\n\n    }\n\n    return val;\n",
          "message": "Contract.increase uses assembly (Provider.sol#451-477)\n\t- Provider.sol#454-476\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 479,
          "vulnerability_to_line": 505,
          "vulnerability_code": "  function decrease(bytes32 _field) conditions(validStoreDest, validStoreVal) internal view returns (bytes32 val) {\n\n    // Read value stored at the location in storage -\n\n    val = keccak256(_field, execID());\n\n    assembly {\n\n      val := sload(val)\n\n      // Get pointer to buffer length -\n\n      let ptr := add(0x20, mload(0xc0))\n\n      // Push storage destination to the end of the buffer -\n\n      mstore(add(0x20, add(ptr, mload(ptr))), _field)\n\n      // Increment buffer length - 0x20 plus the previous length\n\n      mstore(ptr, add(0x20, mload(ptr)))\n\n      // Set the expected next function - VAL_DEC\n\n      mstore(0x100, 5)\n\n      // Increment STORES action length -\n\n      mstore(\n\n        mload(sub(ptr, 0x20)),\n\n        add(1, mload(mload(sub(ptr, 0x20))))\n\n      )\n\n      // Update number of storage slots pushed to -\n\n      mstore(0x120, add(1, mload(0x120)))\n\n      // If the free-memory pointer does not point beyond the buffer's current size, update it\n\n      if lt(mload(0x40), add(0x20, add(ptr, mload(ptr)))) {\n\n        mstore(0x40, add(0x20, add(ptr, mload(ptr))))\n\n      }\n\n    }\n\n    return val;\n",
          "message": "Contract.decrease uses assembly (Provider.sol#479-505)\n\t- Provider.sol#482-504\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 507,
          "vulnerability_to_line": 531,
          "vulnerability_code": "  function by(bytes32 _val, uint _amt) conditions(validStoreVal, validStoreDest) internal pure {\n\n    // Check the expected function type - if it is VAL_INC, perform safe-add on the value\n\n    // If it is VAL_DEC, perform safe-sub on the value\n\n    if (expected() == NextFunction.VAL_INC)\n\n      _amt = _amt.add(uint(_val));\n\n    else if (expected() == NextFunction.VAL_DEC)\n\n      _amt = uint(_val).sub(_amt);\n\n    else\n\n      revert('Expected VAL_INC or VAL_DEC');\n\n\n\n    assembly {\n\n      // Get pointer to buffer length -\n\n      let ptr := add(0x20, mload(0xc0))\n\n      // Push storage value to the end of the buffer -\n\n      mstore(add(0x20, add(ptr, mload(ptr))), _amt)\n\n      // Increment buffer length - 0x20 plus the previous length\n\n      mstore(ptr, add(0x20, mload(ptr)))\n\n      // Set the expected next function - STORE_DEST\n\n      mstore(0x100, 2)\n\n      // If the free-memory pointer does not point beyond the buffer's current size, update it\n\n      if lt(mload(0x40), add(0x20, add(ptr, mload(ptr)))) {\n\n        mstore(0x40, add(0x20, add(ptr, mload(ptr))))\n\n      }\n\n    }\n",
          "message": "Contract.by uses assembly (Provider.sol#507-531)\n\t- Provider.sol#517-531\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 534,
          "vulnerability_to_line": 560,
          "vulnerability_code": "  function byMaximum(bytes32 _val, uint _amt) conditions(validStoreVal, validStoreDest) internal pure {\n\n    // Check the expected function type - if it is VAL_DEC, set the new amount to the difference of\n\n    // _val and _amt, to a minimum of 0\n\n    if (expected() == NextFunction.VAL_DEC) {\n\n      if (_amt > uint(_val))\n\n        _amt = 0;\n\n      else\n\n        _amt = uint(_val).sub(_amt);\n\n    } else {\n\n      revert('Expected VAL_DEC');\n\n    }\n\n\n\n    assembly {\n\n      // Get pointer to buffer length -\n\n      let ptr := add(0x20, mload(0xc0))\n\n      // Push storage value to the end of the buffer -\n\n      mstore(add(0x20, add(ptr, mload(ptr))), _amt)\n\n      // Increment buffer length - 0x20 plus the previous length\n\n      mstore(ptr, add(0x20, mload(ptr)))\n\n      // Set the expected next function - STORE_DEST\n\n      mstore(0x100, 2)\n\n      // If the free-memory pointer does not point beyond the buffer's current size, update it\n\n      if lt(mload(0x40), add(0x20, add(ptr, mload(ptr)))) {\n\n        mstore(0x40, add(0x20, add(ptr, mload(ptr))))\n\n      }\n\n    }\n",
          "message": "Contract.byMaximum uses assembly (Provider.sol#534-560)\n\t- Provider.sol#546-560\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 564,
          "vulnerability_to_line": 587,
          "vulnerability_code": "  function emitting() conditions(validEmitBuff, isEmitting) internal pure {\n\n    bytes4 action_req = EMITS;\n\n    assembly {\n\n      // Get pointer to buffer length -\n\n      let ptr := add(0x20, mload(0xc0))\n\n      // Push requestor to the end of buffer, as well as to the 'current action' slot -\n\n      mstore(add(0x20, add(ptr, mload(ptr))), action_req)\n\n      mstore(0xe0, action_req)\n\n      // Push '0' to the end of the 4 bytes just pushed - this will be the length of the EMITS action\n\n      mstore(add(0x24, add(ptr, mload(ptr))), 0)\n\n      // Increment buffer length - 0x24 plus the previous length\n\n      mstore(ptr, add(0x24, mload(ptr)))\n\n      // Set the current action being executed (EMITS) -\n\n      mstore(0xe0, action_req)\n\n      // Set the expected next function - EMIT_LOG\n\n      mstore(0x100, 6)\n\n      // Set a pointer to the length of the current request within the buffer\n\n      mstore(sub(ptr, 0x20), add(ptr, mload(ptr)))\n\n      // If the free-memory pointer does not point beyond the buffer's current size, update it\n\n      if lt(mload(0x40), add(0x20, add(ptr, mload(ptr)))) {\n\n        mstore(0x40, add(0x20, add(ptr, mload(ptr))))\n\n      }\n\n    }\n",
          "message": "Contract.emitting uses assembly (Provider.sol#564-587)\n\t- Provider.sol#566-587\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 589,
          "vulnerability_to_line": 622,
          "vulnerability_code": "  function log(bytes32 _data) conditions(validEvent, validEvent) internal pure {\n\n    assembly {\n\n      // Get pointer to buffer length -\n\n      let ptr := add(0x20, mload(0xc0))\n\n      // Push 0 to the end of the buffer - event will have 0 topics\n\n      mstore(add(0x20, add(ptr, mload(ptr))), 0)\n\n      // If _data is zero, set data size to 0 in buffer and push -\n\n      if eq(_data, 0) {\n\n        mstore(add(0x40, add(ptr, mload(ptr))), 0)\n\n        // Increment buffer length - 0x40 plus the original length\n\n        mstore(ptr, add(0x40, mload(ptr)))\n\n      }\n\n      // If _data is not zero, set size to 0x20 and push to buffer -\n\n      if iszero(eq(_data, 0)) {\n\n        // Push data size (0x20) to the end of the buffer\n\n        mstore(add(0x40, add(ptr, mload(ptr))), 0x20)\n\n        // Push data to the end of the buffer\n\n        mstore(add(0x60, add(ptr, mload(ptr))), _data)\n\n        // Increment buffer length - 0x60 plus the original length\n\n        mstore(ptr, add(0x60, mload(ptr)))\n\n      }\n\n      // Increment EMITS action length -\n\n      mstore(\n\n        mload(sub(ptr, 0x20)),\n\n        add(1, mload(mload(sub(ptr, 0x20))))\n\n      )\n\n      // Update number of events pushed to buffer -\n\n      mstore(0x140, add(1, mload(0x140)))\n\n      // If the free-memory pointer does not point beyond the buffer's current size, update it\n\n      if lt(mload(0x40), add(0x20, add(ptr, mload(ptr)))) {\n\n        mstore(0x40, add(0x20, add(ptr, mload(ptr))))\n\n      }\n\n    }\n",
          "message": "Contract.log uses assembly (Provider.sol#589-622)\n\t- Provider.sol#590-622\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 624,
          "vulnerability_to_line": 659,
          "vulnerability_code": "  function log(bytes32[1] memory _topics, bytes32 _data) conditions(validEvent, validEvent) internal pure {\n\n    assembly {\n\n      // Get pointer to buffer length -\n\n      let ptr := add(0x20, mload(0xc0))\n\n      // Push 1 to the end of the buffer - event will have 1 topic\n\n      mstore(add(0x20, add(ptr, mload(ptr))), 1)\n\n      // Push topic to end of buffer\n\n      mstore(add(0x40, add(ptr, mload(ptr))), mload(_topics))\n\n      // If _data is zero, set data size to 0 in buffer and push -\n\n      if eq(_data, 0) {\n\n        mstore(add(0x60, add(ptr, mload(ptr))), 0)\n\n        // Increment buffer length - 0x60 plus the original length\n\n        mstore(ptr, add(0x60, mload(ptr)))\n\n      }\n\n      // If _data is not zero, set size to 0x20 and push to buffer -\n\n      if iszero(eq(_data, 0)) {\n\n        // Push data size (0x20) to the end of the buffer\n\n        mstore(add(0x60, add(ptr, mload(ptr))), 0x20)\n\n        // Push data to the end of the buffer\n\n        mstore(add(0x80, add(ptr, mload(ptr))), _data)\n\n        // Increment buffer length - 0x80 plus the original length\n\n        mstore(ptr, add(0x80, mload(ptr)))\n\n      }\n\n      // Increment EMITS action length -\n\n      mstore(\n\n        mload(sub(ptr, 0x20)),\n\n        add(1, mload(mload(sub(ptr, 0x20))))\n\n      )\n\n      // Update number of events pushed to buffer -\n\n      mstore(0x140, add(1, mload(0x140)))\n\n      // If the free-memory pointer does not point beyond the buffer's current size, update it\n\n      if lt(mload(0x40), add(0x20, add(ptr, mload(ptr)))) {\n\n        mstore(0x40, add(0x20, add(ptr, mload(ptr))))\n\n      }\n\n    }\n",
          "message": "Contract.log uses assembly (Provider.sol#624-659)\n\t- Provider.sol#625-659\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 661,
          "vulnerability_to_line": 697,
          "vulnerability_code": "  function log(bytes32[2] memory _topics, bytes32 _data) conditions(validEvent, validEvent) internal pure {\n\n    assembly {\n\n      // Get pointer to buffer length -\n\n      let ptr := add(0x20, mload(0xc0))\n\n      // Push 2 to the end of the buffer - event will have 2 topics\n\n      mstore(add(0x20, add(ptr, mload(ptr))), 2)\n\n      // Push topics to end of buffer\n\n      mstore(add(0x40, add(ptr, mload(ptr))), mload(_topics))\n\n      mstore(add(0x60, add(ptr, mload(ptr))), mload(add(0x20, _topics)))\n\n      // If _data is zero, set data size to 0 in buffer and push -\n\n      if eq(_data, 0) {\n\n        mstore(add(0x80, add(ptr, mload(ptr))), 0)\n\n        // Increment buffer length - 0x80 plus the original length\n\n        mstore(ptr, add(0x80, mload(ptr)))\n\n      }\n\n      // If _data is not zero, set size to 0x20 and push to buffer -\n\n      if iszero(eq(_data, 0)) {\n\n        // Push data size (0x20) to the end of the buffer\n\n        mstore(add(0x80, add(ptr, mload(ptr))), 0x20)\n\n        // Push data to the end of the buffer\n\n        mstore(add(0xa0, add(ptr, mload(ptr))), _data)\n\n        // Increment buffer length - 0xa0 plus the original length\n\n        mstore(ptr, add(0xa0, mload(ptr)))\n\n      }\n\n      // Increment EMITS action length -\n\n      mstore(\n\n        mload(sub(ptr, 0x20)),\n\n        add(1, mload(mload(sub(ptr, 0x20))))\n\n      )\n\n      // Update number of events pushed to buffer -\n\n      mstore(0x140, add(1, mload(0x140)))\n\n      // If the free-memory pointer does not point beyond the buffer's current size, update it\n\n      if lt(mload(0x40), add(0x20, add(ptr, mload(ptr)))) {\n\n        mstore(0x40, add(0x20, add(ptr, mload(ptr))))\n\n      }\n\n    }\n",
          "message": "Contract.log uses assembly (Provider.sol#661-697)\n\t- Provider.sol#662-697\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 699,
          "vulnerability_to_line": 736,
          "vulnerability_code": "  function log(bytes32[3] memory _topics, bytes32 _data) conditions(validEvent, validEvent) internal pure {\n\n    assembly {\n\n      // Get pointer to buffer length -\n\n      let ptr := add(0x20, mload(0xc0))\n\n      // Push 3 to the end of the buffer - event will have 3 topics\n\n      mstore(add(0x20, add(ptr, mload(ptr))), 3)\n\n      // Push topics to end of buffer\n\n      mstore(add(0x40, add(ptr, mload(ptr))), mload(_topics))\n\n      mstore(add(0x60, add(ptr, mload(ptr))), mload(add(0x20, _topics)))\n\n      mstore(add(0x80, add(ptr, mload(ptr))), mload(add(0x40, _topics)))\n\n      // If _data is zero, set data size to 0 in buffer and push -\n\n      if eq(_data, 0) {\n\n        mstore(add(0xa0, add(ptr, mload(ptr))), 0)\n\n        // Increment buffer length - 0xa0 plus the original length\n\n        mstore(ptr, add(0xa0, mload(ptr)))\n\n      }\n\n      // If _data is not zero, set size to 0x20 and push to buffer -\n\n      if iszero(eq(_data, 0)) {\n\n        // Push data size (0x20) to the end of the buffer\n\n        mstore(add(0xa0, add(ptr, mload(ptr))), 0x20)\n\n        // Push data to the end of the buffer\n\n        mstore(add(0xc0, add(ptr, mload(ptr))), _data)\n\n        // Increment buffer length - 0xc0 plus the original length\n\n        mstore(ptr, add(0xc0, mload(ptr)))\n\n      }\n\n      // Increment EMITS action length -\n\n      mstore(\n\n        mload(sub(ptr, 0x20)),\n\n        add(1, mload(mload(sub(ptr, 0x20))))\n\n      )\n\n      // Update number of events pushed to buffer -\n\n      mstore(0x140, add(1, mload(0x140)))\n\n      // If the free-memory pointer does not point beyond the buffer's current size, update it\n\n      if lt(mload(0x40), add(0x20, add(ptr, mload(ptr)))) {\n\n        mstore(0x40, add(0x20, add(ptr, mload(ptr))))\n\n      }\n\n    }\n",
          "message": "Contract.log uses assembly (Provider.sol#699-736)\n\t- Provider.sol#700-736\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 738,
          "vulnerability_to_line": 776,
          "vulnerability_code": "  function log(bytes32[4] memory _topics, bytes32 _data) conditions(validEvent, validEvent) internal pure {\n\n    assembly {\n\n      // Get pointer to buffer length -\n\n      let ptr := add(0x20, mload(0xc0))\n\n      // Push 4 to the end of the buffer - event will have 4 topics\n\n      mstore(add(0x20, add(ptr, mload(ptr))), 4)\n\n      // Push topics to end of buffer\n\n      mstore(add(0x40, add(ptr, mload(ptr))), mload(_topics))\n\n      mstore(add(0x60, add(ptr, mload(ptr))), mload(add(0x20, _topics)))\n\n      mstore(add(0x80, add(ptr, mload(ptr))), mload(add(0x40, _topics)))\n\n      mstore(add(0xa0, add(ptr, mload(ptr))), mload(add(0x60, _topics)))\n\n      // If _data is zero, set data size to 0 in buffer and push -\n\n      if eq(_data, 0) {\n\n        mstore(add(0xc0, add(ptr, mload(ptr))), 0)\n\n        // Increment buffer length - 0xc0 plus the original length\n\n        mstore(ptr, add(0xc0, mload(ptr)))\n\n      }\n\n      // If _data is not zero, set size to 0x20 and push to buffer -\n\n      if iszero(eq(_data, 0)) {\n\n        // Push data size (0x20) to the end of the buffer\n\n        mstore(add(0xc0, add(ptr, mload(ptr))), 0x20)\n\n        // Push data to the end of the buffer\n\n        mstore(add(0xe0, add(ptr, mload(ptr))), _data)\n\n        // Increment buffer length - 0xe0 plus the original length\n\n        mstore(ptr, add(0xe0, mload(ptr)))\n\n      }\n\n      // Increment EMITS action length -\n\n      mstore(\n\n        mload(sub(ptr, 0x20)),\n\n        add(1, mload(mload(sub(ptr, 0x20))))\n\n      )\n\n      // Update number of events pushed to buffer -\n\n      mstore(0x140, add(1, mload(0x140)))\n\n      // If the free-memory pointer does not point beyond the buffer's current size, update it\n\n      if lt(mload(0x40), add(0x20, add(ptr, mload(ptr)))) {\n\n        mstore(0x40, add(0x20, add(ptr, mload(ptr))))\n\n      }\n\n    }\n",
          "message": "Contract.log uses assembly (Provider.sol#738-776)\n\t- Provider.sol#739-776\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 780,
          "vulnerability_to_line": 803,
          "vulnerability_code": "  function paying() conditions(validPayBuff, isPaying) internal pure {\n\n    bytes4 action_req = PAYS;\n\n    assembly {\n\n      // Get pointer to buffer length -\n\n      let ptr := add(0x20, mload(0xc0))\n\n      // Push requestor to the end of buffer, as well as to the 'current action' slot -\n\n      mstore(add(0x20, add(ptr, mload(ptr))), action_req)\n\n      mstore(0xe0, action_req)\n\n      // Push '0' to the end of the 4 bytes just pushed - this will be the length of the PAYS action\n\n      mstore(add(0x24, add(ptr, mload(ptr))), 0)\n\n      // Increment buffer length - 0x24 plus the previous length\n\n      mstore(ptr, add(0x24, mload(ptr)))\n\n      // Set the current action being executed (PAYS) -\n\n      mstore(0xe0, action_req)\n\n      // Set the expected next function - PAY_AMT\n\n      mstore(0x100, 8)\n\n      // Set a pointer to the length of the current request within the buffer\n\n      mstore(sub(ptr, 0x20), add(ptr, mload(ptr)))\n\n      // If the free-memory pointer does not point beyond the buffer's current size, update it\n\n      if lt(mload(0x40), add(0x20, add(ptr, mload(ptr)))) {\n\n        mstore(0x40, add(0x20, add(ptr, mload(ptr))))\n\n      }\n\n    }\n",
          "message": "Contract.paying uses assembly (Provider.sol#780-803)\n\t- Provider.sol#782-803\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 806,
          "vulnerability_to_line": 829,
          "vulnerability_code": "  function pay(uint _amount) conditions(validPayAmt, validPayDest) internal pure returns (uint) {\n\n    assembly {\n\n      // Get pointer to buffer length -\n\n      let ptr := add(0x20, mload(0xc0))\n\n      // Push payment amount to the end of the buffer -\n\n      mstore(add(0x20, add(ptr, mload(ptr))), _amount)\n\n      // Increment buffer length - 0x20 plus the previous length\n\n      mstore(ptr, add(0x20, mload(ptr)))\n\n      // Set the expected next function - PAY_DEST\n\n      mstore(0x100, 7)\n\n      // Increment PAYS action length -\n\n      mstore(\n\n        mload(sub(ptr, 0x20)),\n\n        add(1, mload(mload(sub(ptr, 0x20))))\n\n      )\n\n      // Update number of payment destinations to be pushed to -\n\n      mstore(0x160, add(1, mload(0x160)))\n\n      // If the free-memory pointer does not point beyond the buffer's current size, update it\n\n      if lt(mload(0x40), add(0x20, add(ptr, mload(ptr)))) {\n\n        mstore(0x40, add(0x20, add(ptr, mload(ptr))))\n\n      }\n\n    }\n\n    return _amount;\n",
          "message": "Contract.pay uses assembly (Provider.sol#806-829)\n\t- Provider.sol#807-828\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 832,
          "vulnerability_to_line": 847,
          "vulnerability_code": "  function toAcc(uint, address _dest) conditions(validPayDest, validPayAmt) internal pure {\n\n    assembly {\n\n      // Get pointer to buffer length -\n\n      let ptr := add(0x20, mload(0xc0))\n\n      // Push payment destination to the end of the buffer -\n\n      mstore(add(0x20, add(ptr, mload(ptr))), _dest)\n\n      // Increment buffer length - 0x20 plus the previous length\n\n      mstore(ptr, add(0x20, mload(ptr)))\n\n      // Set the expected next function - PAY_AMT\n\n      mstore(0x100, 8)\n\n      // If the free-memory pointer does not point beyond the buffer's current size, update it\n\n      if lt(mload(0x40), add(0x20, add(ptr, mload(ptr)))) {\n\n        mstore(0x40, add(0x20, add(ptr, mload(ptr))))\n\n      }\n\n    }\n",
          "message": "Contract.toAcc uses assembly (Provider.sol#832-847)\n\t- Provider.sol#833-847\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 850,
          "vulnerability_to_line": 852,
          "vulnerability_code": "  function expected() private pure returns (NextFunction next) {\n\n    assembly { next := mload(0x100) }\n",
          "message": "Contract.expected uses assembly (Provider.sol#850-852)\n\t- Provider.sol#851-852\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 855,
          "vulnerability_to_line": 861,
          "vulnerability_code": "  function emitted() internal pure returns (uint num_emitted) {\n\n    if (buffPtr() == bytes32(0))\n\n      return 0;\n\n\n\n    // Load number emitted from buffer -\n\n    assembly { num_emitted := mload(0x140) }\n",
          "message": "Contract.emitted uses assembly (Provider.sol#855-861)\n\t- Provider.sol#860-861\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 864,
          "vulnerability_to_line": 870,
          "vulnerability_code": "  function stored() internal pure returns (uint num_stored) {\n\n    if (buffPtr() == bytes32(0))\n\n      return 0;\n\n\n\n    // Load number stored from buffer -\n\n    assembly { num_stored := mload(0x120) }\n",
          "message": "Contract.stored uses assembly (Provider.sol#864-870)\n\t- Provider.sol#869-870\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 873,
          "vulnerability_to_line": 879,
          "vulnerability_code": "  function paid() internal pure returns (uint num_paid) {\n\n    if (buffPtr() == bytes32(0))\n\n      return 0;\n\n\n\n    // Load number paid from buffer -\n\n    assembly { num_paid := mload(0x160) }\n",
          "message": "Contract.paid uses assembly (Provider.sol#873-879)\n\t- Provider.sol#878-879\n"
        },
        {
          "name": "solc-version",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.23;\n",
          "message": "Detected issues with version pragma in Provider.sol:\n\t- pragma solidity^0.4.23 (Provider.sol#3): it allows old versions\n\t- pragma solidity^0.4.23 (Provider.sol#46): it allows old versions\n\t- pragma solidity^0.4.23 (Provider.sol#884): it allows old versions\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 71,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function authorize(address _script_exec) internal view {\n",
          "message": "Parameter '_script_exec' of Contract.authorize (Provider.sol#71) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 149,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function checks(function () pure _check) conditions(validState, validState) internal pure {\n",
          "message": "Parameter '_check' of Contract.checks (Provider.sol#149) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 291,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function read(bytes32 _location) internal view returns (bytes32 data) {\n",
          "message": "Parameter '_location' of Contract.read (Provider.sol#291) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 390,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function set(bytes32 _field) conditions(validStoreDest, validStoreVal) internal pure returns (bytes32) {\n",
          "message": "Parameter '_field' of Contract.set (Provider.sol#390) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 416,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function to(bytes32, bytes32 _val) conditions(validStoreVal, validStoreDest) internal pure {\n",
          "message": "Parameter '' of Contract.to (Provider.sol#416) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 434,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function to(bytes32 _field, uint _val) internal pure {\n",
          "message": "Parameter '_field' of Contract.to (Provider.sol#434) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 434,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function to(bytes32 _field, uint _val) internal pure {\n",
          "message": "Parameter '_val' of Contract.to (Provider.sol#434) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 439,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function to(bytes32 _field, address _val) internal pure {\n",
          "message": "Parameter '_field' of Contract.to (Provider.sol#439) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 439,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function to(bytes32 _field, address _val) internal pure {\n",
          "message": "Parameter '_val' of Contract.to (Provider.sol#439) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 444,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function to(bytes32 _field, bool _val) internal pure {\n",
          "message": "Parameter '_field' of Contract.to (Provider.sol#444) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 444,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function to(bytes32 _field, bool _val) internal pure {\n",
          "message": "Parameter '_val' of Contract.to (Provider.sol#444) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 451,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function increase(bytes32 _field) conditions(validStoreDest, validStoreVal) internal view returns (bytes32 val) {\n",
          "message": "Parameter '_field' of Contract.increase (Provider.sol#451) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 479,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function decrease(bytes32 _field) conditions(validStoreDest, validStoreVal) internal view returns (bytes32 val) {\n",
          "message": "Parameter '_field' of Contract.decrease (Provider.sol#479) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 507,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function by(bytes32 _val, uint _amt) conditions(validStoreVal, validStoreDest) internal pure {\n",
          "message": "Parameter '_val' of Contract.by (Provider.sol#507) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 507,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function by(bytes32 _val, uint _amt) conditions(validStoreVal, validStoreDest) internal pure {\n",
          "message": "Parameter '_amt' of Contract.by (Provider.sol#507) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 534,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function byMaximum(bytes32 _val, uint _amt) conditions(validStoreVal, validStoreDest) internal pure {\n",
          "message": "Parameter '_val' of Contract.byMaximum (Provider.sol#534) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 534,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function byMaximum(bytes32 _val, uint _amt) conditions(validStoreVal, validStoreDest) internal pure {\n",
          "message": "Parameter '_amt' of Contract.byMaximum (Provider.sol#534) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 806,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function pay(uint _amount) conditions(validPayAmt, validPayDest) internal pure returns (uint) {\n",
          "message": "Parameter '_amount' of Contract.pay (Provider.sol#806) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 832,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function toAcc(uint, address _dest) conditions(validPayDest, validPayAmt) internal pure {\n",
          "message": "Parameter '' of Contract.toAcc (Provider.sol#832) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 895,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function appBase(bytes32 _app) internal pure returns (bytes32)\n",
          "message": "Parameter '_app' of Provider.appBase (Provider.sol#895) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 899,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function appVersionList(bytes32 _app) internal pure returns (bytes32)\n",
          "message": "Parameter '_app' of Provider.appVersionList (Provider.sol#899) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 903,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function versionBase(bytes32 _app, bytes32 _version) internal pure returns (bytes32)\n",
          "message": "Parameter '_app' of Provider.versionBase (Provider.sol#903) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 903,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function versionBase(bytes32 _app, bytes32 _version) internal pure returns (bytes32)\n",
          "message": "Parameter '_version' of Provider.versionBase (Provider.sol#903) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 907,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function versionIndex(bytes32 _app, bytes32 _version) internal pure returns (bytes32)\n",
          "message": "Parameter '_app' of Provider.versionIndex (Provider.sol#907) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 907,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function versionIndex(bytes32 _app, bytes32 _version) internal pure returns (bytes32)\n",
          "message": "Parameter '_version' of Provider.versionIndex (Provider.sol#907) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 911,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function versionSelectors(bytes32 _app, bytes32 _version) internal pure returns (bytes32)\n",
          "message": "Parameter '_app' of Provider.versionSelectors (Provider.sol#911) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 911,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function versionSelectors(bytes32 _app, bytes32 _version) internal pure returns (bytes32)\n",
          "message": "Parameter '_version' of Provider.versionSelectors (Provider.sol#911) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 915,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function versionAddresses(bytes32 _app, bytes32 _version) internal pure returns (bytes32)\n",
          "message": "Parameter '_app' of Provider.versionAddresses (Provider.sol#915) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 915,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function versionAddresses(bytes32 _app, bytes32 _version) internal pure returns (bytes32)\n",
          "message": "Parameter '_version' of Provider.versionAddresses (Provider.sol#915) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 919,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function previousVersion(bytes32 _app, bytes32 _version) internal pure returns (bytes32)\n",
          "message": "Parameter '_app' of Provider.previousVersion (Provider.sol#919) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 919,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function previousVersion(bytes32 _app, bytes32 _version) internal pure returns (bytes32)\n",
          "message": "Parameter '_version' of Provider.previousVersion (Provider.sol#919) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 923,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function appVersionListAt(bytes32 _app, uint _index) internal pure returns (bytes32)\n",
          "message": "Parameter '_app' of Provider.appVersionListAt (Provider.sol#923) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 923,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function appVersionListAt(bytes32 _app, uint _index) internal pure returns (bytes32)\n",
          "message": "Parameter '_index' of Provider.appVersionListAt (Provider.sol#923) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 927,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function registerApp(bytes32 _app, address _index, bytes4[] _selectors, address[] _implementations) external view {\n",
          "message": "Parameter '_app' of Provider.registerApp (Provider.sol#927) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 927,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function registerApp(bytes32 _app, address _index, bytes4[] _selectors, address[] _implementations) external view {\n",
          "message": "Parameter '_index' of Provider.registerApp (Provider.sol#927) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 927,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function registerApp(bytes32 _app, address _index, bytes4[] _selectors, address[] _implementations) external view {\n",
          "message": "Parameter '_selectors' of Provider.registerApp (Provider.sol#927) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 927,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function registerApp(bytes32 _app, address _index, bytes4[] _selectors, address[] _implementations) external view {\n",
          "message": "Parameter '_implementations' of Provider.registerApp (Provider.sol#927) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 982,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function registerAppVersion(bytes32 _app, bytes32 _version, address _index, bytes4[] _selectors, address[] _implementations) external view {\n",
          "message": "Parameter '_app' of Provider.registerAppVersion (Provider.sol#982) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 982,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function registerAppVersion(bytes32 _app, bytes32 _version, address _index, bytes4[] _selectors, address[] _implementations) external view {\n",
          "message": "Parameter '_version' of Provider.registerAppVersion (Provider.sol#982) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 982,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function registerAppVersion(bytes32 _app, bytes32 _version, address _index, bytes4[] _selectors, address[] _implementations) external view {\n",
          "message": "Parameter '_index' of Provider.registerAppVersion (Provider.sol#982) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 982,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function registerAppVersion(bytes32 _app, bytes32 _version, address _index, bytes4[] _selectors, address[] _implementations) external view {\n",
          "message": "Parameter '_selectors' of Provider.registerAppVersion (Provider.sol#982) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 982,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function registerAppVersion(bytes32 _app, bytes32 _version, address _index, bytes4[] _selectors, address[] _implementations) external view {\n",
          "message": "Parameter '_implementations' of Provider.registerAppVersion (Provider.sol#982) is not in mixedCase\n"
        },
        {
          "name": "unused-state",
          "vulnerability_from_line": 301,
          "vulnerability_to_line": null,
          "vulnerability_code": "  bytes4 internal constant THROWS = bytes4(keccak256('Error(string)'));\n",
          "message": "Contract.THROWS (Provider.sol#301) is never used in Contract\n"
        }
      ]
    },
    "smartcheck": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 74,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require(freeMem() == 0x80, \"Memory allocated prior to execution\");\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 122,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require(freeMem() == 0x80, \"Memory allocated prior to execution\");\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 158,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require(ptr >= 0x180, \"Invalid buffer pointer\");\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 173,
          "vulnerability_to_line": null,
          "vulnerability_code": "    if (freeMem() < 0x180)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 176,
          "vulnerability_to_line": null,
          "vulnerability_code": "    if (buffPtr() != 0 && buffPtr() < 0x180)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 970,
          "vulnerability_to_line": null,
          "vulnerability_code": "    for (uint i = 0; i < _selectors.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 1017,
          "vulnerability_to_line": null,
          "vulnerability_code": "    for (uint i = 0; i < _selectors.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
          "vulnerability_from_line": 183,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function buffPtr() private pure returns (bytes32 ptr) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
          "vulnerability_from_line": 188,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function freeMem() private pure returns (bytes32 ptr) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
          "vulnerability_from_line": 276,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function execID() internal pure returns (bytes32 exec_id) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
          "vulnerability_from_line": 282,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function sender() internal pure returns (address addr) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
          "vulnerability_from_line": 850,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function expected() private pure returns (NextFunction next) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 970,
          "vulnerability_to_line": null,
          "vulnerability_code": "    for (uint i = 0; i < _selectors.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 1017,
          "vulnerability_to_line": null,
          "vulnerability_code": "    for (uint i = 0; i < _selectors.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.23;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 46,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.23;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 884,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.23;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_REVERT_REQUIRE",
          "vulnerability_from_line": 106,
          "vulnerability_to_line": null,
          "vulnerability_code": "    if (!authorized)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_REVERT_REQUIRE",
          "vulnerability_from_line": 173,
          "vulnerability_to_line": null,
          "vulnerability_code": "    if (freeMem() < 0x180)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_REVERT_REQUIRE",
          "vulnerability_from_line": 176,
          "vulnerability_to_line": null,
          "vulnerability_code": "    if (buffPtr() != 0 && buffPtr() < 0x180)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_REVERT_REQUIRE",
          "vulnerability_from_line": 202,
          "vulnerability_to_line": null,
          "vulnerability_code": "    if (currentAction() != STORES)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_REVERT_REQUIRE",
          "vulnerability_from_line": 208,
          "vulnerability_to_line": null,
          "vulnerability_code": "    if (currentAction() != EMITS)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_REVERT_REQUIRE",
          "vulnerability_from_line": 214,
          "vulnerability_to_line": null,
          "vulnerability_code": "    if (currentAction() != PAYS)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_REVERT_REQUIRE",
          "vulnerability_from_line": 242,
          "vulnerability_to_line": null,
          "vulnerability_code": "    if (stored() != 0 || currentAction() == STORES)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_REVERT_REQUIRE",
          "vulnerability_from_line": 254,
          "vulnerability_to_line": null,
          "vulnerability_code": "    if (emitted() != 0 || currentAction() == EMITS)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_REVERT_REQUIRE",
          "vulnerability_from_line": 266,
          "vulnerability_to_line": null,
          "vulnerability_code": "    if (paid() != 0 || currentAction() == PAYS)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_REVERT_REQUIRE",
          "vulnerability_from_line": 311,
          "vulnerability_to_line": null,
          "vulnerability_code": "    if (expected() != NextFunction.STORE_DEST)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_REVERT_REQUIRE",
          "vulnerability_from_line": 321,
          "vulnerability_to_line": null,
          "vulnerability_code": "    if (\n",
          "message": null
        },
        {
          "name": "SOLIDITY_REVERT_REQUIRE",
          "vulnerability_from_line": 334,
          "vulnerability_to_line": null,
          "vulnerability_code": "    if (expected() != NextFunction.PAY_DEST)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_REVERT_REQUIRE",
          "vulnerability_from_line": 344,
          "vulnerability_to_line": null,
          "vulnerability_code": "    if (expected() != NextFunction.PAY_AMT)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_REVERT_REQUIRE",
          "vulnerability_from_line": 354,
          "vulnerability_to_line": null,
          "vulnerability_code": "    if (expected() != NextFunction.EMIT_LOG)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_REVERT_REQUIRE",
          "vulnerability_from_line": 512,
          "vulnerability_to_line": null,
          "vulnerability_code": "    else if (expected() == NextFunction.VAL_DEC)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_REVERT_REQUIRE",
          "vulnerability_from_line": 537,
          "vulnerability_to_line": null,
          "vulnerability_code": "    if (expected() == NextFunction.VAL_DEC) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_REVERT_REQUIRE",
          "vulnerability_from_line": 932,
          "vulnerability_to_line": null,
          "vulnerability_code": "    if (Contract.read(appBase(_app)) != bytes32(0))\n",
          "message": null
        },
        {
          "name": "SOLIDITY_REVERT_REQUIRE",
          "vulnerability_from_line": 935,
          "vulnerability_to_line": null,
          "vulnerability_code": "    if (_selectors.length != _implementations.length || _selectors.length == 0)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_REVERT_REQUIRE",
          "vulnerability_from_line": 988,
          "vulnerability_to_line": null,
          "vulnerability_code": "    if (Contract.read(appBase(_app)) == bytes32(0))\n",
          "message": null
        },
        {
          "name": "SOLIDITY_REVERT_REQUIRE",
          "vulnerability_from_line": 991,
          "vulnerability_to_line": null,
          "vulnerability_code": "    if (Contract.read(versionBase(_app, _version)) != bytes32(0))\n",
          "message": null
        },
        {
          "name": "SOLIDITY_REVERT_REQUIRE",
          "vulnerability_from_line": 994,
          "vulnerability_to_line": null,
          "vulnerability_code": "    if (\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SAFEMATH",
          "vulnerability_from_line": 50,
          "vulnerability_to_line": null,
          "vulnerability_code": "  using SafeMath for uint;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 155,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function commit() conditions(validState, none) internal pure {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 172,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function validState() private pure {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 183,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function buffPtr() private pure returns (bytes32 ptr) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 188,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function freeMem() private pure returns (bytes32 ptr) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 193,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function currentAction() private pure returns (bytes4 action) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 219,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function startBuffer() private pure {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 276,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function execID() internal pure returns (bytes32 exec_id) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 282,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function sender() internal pure returns (address addr) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 363,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function storing() conditions(validStoreBuff, isStoring) internal pure {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 390,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function set(bytes32 _field) conditions(validStoreDest, validStoreVal) internal pure returns (bytes32) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 416,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function to(bytes32, bytes32 _val) conditions(validStoreVal, validStoreDest) internal pure {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 507,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function by(bytes32 _val, uint _amt) conditions(validStoreVal, validStoreDest) internal pure {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 534,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function byMaximum(bytes32 _val, uint _amt) conditions(validStoreVal, validStoreDest) internal pure {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 564,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function emitting() conditions(validEmitBuff, isEmitting) internal pure {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 589,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function log(bytes32 _data) conditions(validEvent, validEvent) internal pure {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 624,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function log(bytes32[1] memory _topics, bytes32 _data) conditions(validEvent, validEvent) internal pure {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 661,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function log(bytes32[2] memory _topics, bytes32 _data) conditions(validEvent, validEvent) internal pure {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 699,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function log(bytes32[3] memory _topics, bytes32 _data) conditions(validEvent, validEvent) internal pure {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 738,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function log(bytes32[4] memory _topics, bytes32 _data) conditions(validEvent, validEvent) internal pure {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 780,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function paying() conditions(validPayBuff, isPaying) internal pure {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 806,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function pay(uint _amount) conditions(validPayAmt, validPayDest) internal pure returns (uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 832,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function toAcc(uint, address _dest) conditions(validPayDest, validPayAmt) internal pure {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 850,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function expected() private pure returns (NextFunction next) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 855,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function emitted() internal pure returns (uint num_emitted) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 864,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function stored() internal pure returns (uint num_stored) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 873,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function paid() internal pure returns (uint num_paid) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 891,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function registeredApps() internal pure returns (bytes32)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 895,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function appBase(bytes32 _app) internal pure returns (bytes32)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
          "vulnerability_from_line": 71,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function authorize(address _script_exec) internal view {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
          "vulnerability_from_line": 119,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function initialize() internal view {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
          "vulnerability_from_line": 291,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function read(bytes32 _location) internal view returns (bytes32 data) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
          "vulnerability_from_line": 451,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function increase(bytes32 _field) conditions(validStoreDest, validStoreVal) internal view returns (bytes32 val) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
          "vulnerability_from_line": 479,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function decrease(bytes32 _field) conditions(validStoreDest, validStoreVal) internal view returns (bytes32 val) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 292,
          "vulnerability_to_line": null,
          "vulnerability_code": "    data = keccak256(_location, execID());\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 453,
          "vulnerability_to_line": null,
          "vulnerability_code": "    val = keccak256(_field, execID());\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 481,
          "vulnerability_to_line": null,
          "vulnerability_code": "    val = keccak256(_field, execID());\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 892,
          "vulnerability_to_line": null,
          "vulnerability_code": "    { return keccak256(bytes32(Contract.sender()), 'app_list'); }\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 896,
          "vulnerability_to_line": null,
          "vulnerability_code": "    { return keccak256(_app, keccak256(bytes32(Contract.sender()), 'app_base')); }\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 896,
          "vulnerability_to_line": null,
          "vulnerability_code": "    { return keccak256(_app, keccak256(bytes32(Contract.sender()), 'app_base')); }\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 900,
          "vulnerability_to_line": null,
          "vulnerability_code": "    { return keccak256('versions', appBase(_app)); }\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 904,
          "vulnerability_to_line": null,
          "vulnerability_code": "    { return keccak256(_version, 'version', appBase(_app)); }\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 908,
          "vulnerability_to_line": null,
          "vulnerability_code": "    { return keccak256('index', versionBase(_app, _version)); }\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 912,
          "vulnerability_to_line": null,
          "vulnerability_code": "    { return keccak256('selectors', versionBase(_app, _version)); }\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 916,
          "vulnerability_to_line": null,
          "vulnerability_code": "    { return keccak256('addresses', versionBase(_app, _version)); }\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 920,
          "vulnerability_to_line": null,
          "vulnerability_code": "    { return keccak256(\"previous version\", versionBase(_app, _version)); }\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 77,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 95,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 124,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 160,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 184,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly { ptr := mload(0xc0) }\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 189,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly { ptr := mload(0x40) }\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 197,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly { action := mload(0xe0) }\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 220,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 277,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly { exec_id := mload(0x80) }\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 283,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly { addr := mload(0xa0) }\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 293,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly { data := sload(data) }\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 365,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 391,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 417,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 454,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 482,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 517,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 546,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 566,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 590,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 625,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 662,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 700,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 739,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 782,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 807,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 833,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 851,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly { next := mload(0x100) }\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 860,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly { num_emitted := mload(0x140) }\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 869,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly { num_stored := mload(0x120) }\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 878,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly { num_paid := mload(0x160) }\n",
          "message": null
        }
      ]
    },
    "oyente": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": []
    },
    "mythril": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": []
    },
    "osiris": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": []
    }
  }
}