{
  "smartbugs_completed": true,
  "analyzer_results": {
    "semgrep": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 272,
          "vulnerability_to_line": null,
          "vulnerability_code": "    for (uint i = 0; i < selectors.length; i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 481,
          "vulnerability_to_line": null,
          "vulnerability_code": "      uint log_size = 32 + (32 * (1 + topics.length)) + data.length;\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 481,
          "vulnerability_to_line": null,
          "vulnerability_code": "      uint log_size = 32 + (32 * (1 + topics.length)) + data.length;\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 587,
          "vulnerability_to_line": null,
          "vulnerability_code": "    for (uint i = 0; i < _locations.length; i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 272,
          "vulnerability_to_line": null,
          "vulnerability_code": "    for (uint i = 0; i < selectors.length; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 587,
          "vulnerability_to_line": null,
          "vulnerability_code": "    for (uint i = 0; i < _locations.length; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 77,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require(_sender != 0 && _app_name != 0 && _provider != 0 && _registry_id != 0 && _calldata.length >= 4, 'invalid input');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 93,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require(address(index).delegatecall(_calldata) == false, 'Unsafe execution');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 125,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require(target != address(0), 'Uninitialized application');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 131,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require(address(target).delegatecall(_calldata) == false, 'Unsafe execution');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 136,
          "vulnerability_to_line": null,
          "vulnerability_code": "      revert('No state change occured');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 198,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require(ptr_bound >= _ptr + 64, 'Malformed returndata - invalid size');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 206,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(n_emitted == 0, 'Duplicate action: EMITS');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 211,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(n_emitted != 0, 'Unfulfilled action: EMITS');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 214,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(n_stored == 0, 'Duplicate action: STORES');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 219,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(n_stored != 0, 'Unfulfilled action: STORES');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 222,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(n_paid == 0, 'Duplicate action: PAYS');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 227,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(n_paid != 0, 'Unfulfilled action: PAYS');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 230,
          "vulnerability_to_line": null,
          "vulnerability_code": "        revert('Malformed returndata - unknown action');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 249,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require(index != address(0) && index != address(this), 'Registry application not found');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 255,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require(version != bytes32(0), 'Invalid version name');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 264,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require(index != address(0), 'Invalid index address');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 266,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require(selectors.length == implementations.length && selectors.length != 0, 'Invalid implementation length');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 273,
          "vulnerability_to_line": null,
          "vulnerability_code": "      require(selectors[i] != 0 && implementations[i] != 0, 'invalid input - expected nonzero implementation');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 400,
          "vulnerability_to_line": null,
          "vulnerability_code": "        revert('PAYS: invalid destination');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 77,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require(_sender != 0 && _app_name != 0 && _provider != 0 && _registry_id != 0 && _calldata.length >= 4, 'invalid input');\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 121,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require(_calldata.length >= 4 && _sender != address(0) && _exec_id != bytes32(0));\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 249,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require(index != address(0) && index != address(this), 'Registry application not found');\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 266,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require(selectors.length == implementations.length && selectors.length != 0, 'Invalid implementation length');\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 273,
          "vulnerability_to_line": null,
          "vulnerability_code": "      require(selectors[i] != 0 && implementations[i] != 0, 'invalid input - expected nonzero implementation');\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 135,
          "vulnerability_to_line": null,
          "vulnerability_code": "    if (n_emitted == 0 && n_paid == 0 && n_stored == 0)\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 136,
          "vulnerability_to_line": null,
          "vulnerability_code": "      revert('No state change occured');\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 272,
          "vulnerability_to_line": null,
          "vulnerability_code": "    for (uint i = 0; i < selectors.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 404,
          "vulnerability_to_line": null,
          "vulnerability_code": "      n_paid++;\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 445,
          "vulnerability_to_line": null,
          "vulnerability_code": "      n_stored++;\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 536,
          "vulnerability_to_line": null,
          "vulnerability_code": "      n_emitted++;\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 587,
          "vulnerability_to_line": null,
          "vulnerability_code": "    for (uint i = 0; i < _locations.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 198,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require(ptr_bound >= _ptr + 64, 'Malformed returndata - invalid size');\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 230,
          "vulnerability_to_line": null,
          "vulnerability_code": "        revert('Malformed returndata - unknown action');\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 273,
          "vulnerability_to_line": null,
          "vulnerability_code": "      require(selectors[i] != 0 && implementations[i] != 0, 'invalid input - expected nonzero implementation');\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        }
      ]
    },
    "slither": {
      "successfull_analysis": true,
      "errors": [
        "EXIT_CODE_84"
      ],
      "vulnerability_findings": [
        {
          "name": "arbitrary-send",
          "vulnerability_from_line": 75,
          "vulnerability_to_line": 106,
          "vulnerability_code": "  function createInstance(address _sender, bytes32 _app_name, address _provider, bytes32 _registry_id, bytes _calldata) external payable returns (bytes32 new_exec_id, bytes32 version) {\n\n    // Ensure valid input -\n\n    require(_sender != 0 && _app_name != 0 && _provider != 0 && _registry_id != 0 && _calldata.length >= 4, 'invalid input');\n\n\n\n    // Create new exec id by incrementing the nonce -\n\n    new_exec_id = keccak256(++nonce);\n\n\n\n    // Sanity check - verify that this exec id is not linked to an existing application -\n\n    assert(getIndex(new_exec_id) == address(0));\n\n\n\n    // Set the allowed addresses and selectors for the new instance, from the script registry -\n\n    address index;\n\n    (index, version) = setImplementation(new_exec_id, _app_name, _provider, _registry_id);\n\n\n\n    // Set the exec id and sender addresses for the target application -\n\n    setContext(new_exec_id, _sender);\n\n\n\n    // Execute application, create a new exec id, and commit the returned data to storage -\n\n    require(address(index).delegatecall(_calldata) == false, 'Unsafe execution');\n\n    // Get data returned from call revert and perform requested actions -\n\n    executeAppReturn(new_exec_id);\n\n\n\n    // Emit event\n\n    emit ApplicationInitialized(new_exec_id, index, msg.sender);\n\n\n\n    // If execution reaches this point, newly generated exec id should be valid -\n\n    assert(new_exec_id != bytes32(0));\n\n\n\n    // Ensure that any additional balance is transferred back to the sender -\n\n    if (address(this).balance > 0)\n\n      address(msg.sender).transfer(address(this).balance);\n",
          "message": "AbstractStorage.createInstance (AbstractStorage.sol#75-106) sends eth to arbitrary user\n\tDangerous calls:\n\t- address(msg.sender).transfer(address(this).balance) (AbstractStorage.sol#105)\n"
        },
        {
          "name": "arbitrary-send",
          "vulnerability_from_line": 119,
          "vulnerability_to_line": 144,
          "vulnerability_code": "  function exec(address _sender, bytes32 _exec_id, bytes _calldata) external payable returns (uint n_emitted, uint n_paid, uint n_stored) {\n\n    // Ensure valid input and input size - minimum 4 bytes\n\n    require(_calldata.length >= 4 && _sender != address(0) && _exec_id != bytes32(0));\n\n\n\n    // Get the target address associated with the given exec id\n\n    address target = getTarget(_exec_id, getSelector(_calldata));\n\n    require(target != address(0), 'Uninitialized application');\n\n\n\n    // Set the exec id and sender addresses for the target application -\n\n    setContext(_exec_id, _sender);\n\n\n\n    // Execute application and commit returned data to storage -\n\n    require(address(target).delegatecall(_calldata) == false, 'Unsafe execution');\n\n    (n_emitted, n_paid, n_stored) = executeAppReturn(_exec_id);\n\n\n\n    // If no events were emitted, no wei was forwarded, and no storage was changed, revert -\n\n    if (n_emitted == 0 && n_paid == 0 && n_stored == 0)\n\n      revert('No state change occured');\n\n\n\n    // Emit event -\n\n    emit ApplicationExecution(_exec_id, target);\n\n\n\n    // Ensure that any additional balance is transferred back to the sender -\n\n    if (address(this).balance > 0)\n\n      address(msg.sender).transfer(address(this).balance);\n",
          "message": "AbstractStorage.exec (AbstractStorage.sol#119-144) sends eth to arbitrary user\n\tDangerous calls:\n\t- address(msg.sender).transfer(address(this).balance) (AbstractStorage.sol#143)\n"
        },
        {
          "name": "controlled-delegatecall",
          "vulnerability_from_line": 75,
          "vulnerability_to_line": 106,
          "vulnerability_code": "  function createInstance(address _sender, bytes32 _app_name, address _provider, bytes32 _registry_id, bytes _calldata) external payable returns (bytes32 new_exec_id, bytes32 version) {\n\n    // Ensure valid input -\n\n    require(_sender != 0 && _app_name != 0 && _provider != 0 && _registry_id != 0 && _calldata.length >= 4, 'invalid input');\n\n\n\n    // Create new exec id by incrementing the nonce -\n\n    new_exec_id = keccak256(++nonce);\n\n\n\n    // Sanity check - verify that this exec id is not linked to an existing application -\n\n    assert(getIndex(new_exec_id) == address(0));\n\n\n\n    // Set the allowed addresses and selectors for the new instance, from the script registry -\n\n    address index;\n\n    (index, version) = setImplementation(new_exec_id, _app_name, _provider, _registry_id);\n\n\n\n    // Set the exec id and sender addresses for the target application -\n\n    setContext(new_exec_id, _sender);\n\n\n\n    // Execute application, create a new exec id, and commit the returned data to storage -\n\n    require(address(index).delegatecall(_calldata) == false, 'Unsafe execution');\n\n    // Get data returned from call revert and perform requested actions -\n\n    executeAppReturn(new_exec_id);\n\n\n\n    // Emit event\n\n    emit ApplicationInitialized(new_exec_id, index, msg.sender);\n\n\n\n    // If execution reaches this point, newly generated exec id should be valid -\n\n    assert(new_exec_id != bytes32(0));\n\n\n\n    // Ensure that any additional balance is transferred back to the sender -\n\n    if (address(this).balance > 0)\n\n      address(msg.sender).transfer(address(this).balance);\n",
          "message": "AbstractStorage.createInstance (AbstractStorage.sol#75-106) uses delegatecall to a input-controlled function id\n\trequire(bool,string)(address(index).delegatecall(_calldata) == false,Unsafe execution) (AbstractStorage.sol#93)\n"
        },
        {
          "name": "controlled-delegatecall",
          "vulnerability_from_line": 119,
          "vulnerability_to_line": 144,
          "vulnerability_code": "  function exec(address _sender, bytes32 _exec_id, bytes _calldata) external payable returns (uint n_emitted, uint n_paid, uint n_stored) {\n\n    // Ensure valid input and input size - minimum 4 bytes\n\n    require(_calldata.length >= 4 && _sender != address(0) && _exec_id != bytes32(0));\n\n\n\n    // Get the target address associated with the given exec id\n\n    address target = getTarget(_exec_id, getSelector(_calldata));\n\n    require(target != address(0), 'Uninitialized application');\n\n\n\n    // Set the exec id and sender addresses for the target application -\n\n    setContext(_exec_id, _sender);\n\n\n\n    // Execute application and commit returned data to storage -\n\n    require(address(target).delegatecall(_calldata) == false, 'Unsafe execution');\n\n    (n_emitted, n_paid, n_stored) = executeAppReturn(_exec_id);\n\n\n\n    // If no events were emitted, no wei was forwarded, and no storage was changed, revert -\n\n    if (n_emitted == 0 && n_paid == 0 && n_stored == 0)\n\n      revert('No state change occured');\n\n\n\n    // Emit event -\n\n    emit ApplicationExecution(_exec_id, target);\n\n\n\n    // Ensure that any additional balance is transferred back to the sender -\n\n    if (address(this).balance > 0)\n\n      address(msg.sender).transfer(address(this).balance);\n",
          "message": "AbstractStorage.exec (AbstractStorage.sol#119-144) uses delegatecall to a input-controlled function id\n\trequire(bool,string)(address(target).delegatecall(_calldata) == false,Unsafe execution) (AbstractStorage.sol#131)\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 283,
          "vulnerability_to_line": 288,
          "vulnerability_code": "  function getIndex(bytes32 _exec_id) public view returns (address) {\n\n    bytes32 seed = APP_IDX_ADDR;\n\n    function (bytes32, bytes32) view returns (address) getter;\n\n    assembly { getter := readMap }\n\n    return getter(_exec_id, seed);\n",
          "message": "AbstractStorage.getIndex (AbstractStorage.sol#283-288) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 291,
          "vulnerability_to_line": 296,
          "vulnerability_code": "  function getTarget(bytes32 _exec_id, bytes4 _selector) public view returns (address) {\n\n    bytes32 seed = keccak256(_selector, 'implementation');\n\n    function (bytes32, bytes32) view returns (address) getter;\n\n    assembly { getter := readMap }\n\n    return getter(_exec_id, seed);\n",
          "message": "AbstractStorage.getTarget (AbstractStorage.sol#291-296) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 319,
          "vulnerability_to_line": 326,
          "vulnerability_code": "  function getSelector(bytes memory _calldata) internal pure returns (bytes4 sel) {\n\n    assembly {\n\n      sel := and(\n\n        mload(add(0x20, _calldata)),\n\n        0xffffffff00000000000000000000000000000000000000000000000000000000\n\n      )\n\n    }\n",
          "message": "AbstractStorage.getSelector (AbstractStorage.sol#319-326) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 335,
          "vulnerability_to_line": 352,
          "vulnerability_code": "  function getReturnedData() internal pure returns (uint ptr_bounds, uint _returndata_ptr) {\n\n    assembly {\n\n      // returndatasize must be minimum 96 bytes (offset, length, and requestor)\n\n      if lt(returndatasize, 0x60) {\n\n        mstore(0, 'Insufficient return size')\n\n        revert(0, 0x20)\n\n      }\n\n      // Get memory location to which returndata will be copied\n\n      _returndata_ptr := msize\n\n      // Copy returned data to pointer location\n\n      returndatacopy(_returndata_ptr, 0, returndatasize)\n\n      // Get maximum memory location value for returndata\n\n      ptr_bounds := add(_returndata_ptr, returndatasize)\n\n      // Set new free-memory pointer to point after the returndata in memory\n\n      // Returndata is automatically 32-bytes padded\n\n      mstore(0x40, add(0x20, ptr_bounds))\n\n    }\n",
          "message": "AbstractStorage.getReturnedData (AbstractStorage.sol#335-352) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 360,
          "vulnerability_to_line": 362,
          "vulnerability_code": "  function getLength(uint _ptr) internal pure returns (uint length) {\n\n    assembly { length := mload(_ptr) }\n",
          "message": "AbstractStorage.getLength (AbstractStorage.sol#360-362) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 365,
          "vulnerability_to_line": 368,
          "vulnerability_code": "  function doThrow(uint _ptr) internal pure {\n\n    assert(getAction(_ptr) == THROWS);\n\n    assembly { revert(_ptr, returndatasize) }\n",
          "message": "AbstractStorage.doThrow (AbstractStorage.sol#365-368) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 544,
          "vulnerability_to_line": 549,
          "vulnerability_code": "  function getAction(uint _ptr) internal pure returns (bytes4 action) {\n\n    assembly {\n\n      // Get the first 4 bytes stored at the pointer, and clean the rest of the bytes remaining\n\n      action := and(mload(_ptr), 0xffffffff00000000000000000000000000000000000000000000000000000000)\n\n    }\n",
          "message": "AbstractStorage.getAction (AbstractStorage.sol#544-549) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 575,
          "vulnerability_to_line": 578,
          "vulnerability_code": "  function read(bytes32 _exec_id, bytes32 _location) public view returns (bytes32 data_read) {\n\n    _location = keccak256(_location, _exec_id);\n\n    assembly { data_read := sload(_location) }\n",
          "message": "AbstractStorage.read (AbstractStorage.sol#575-578) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 585,
          "vulnerability_to_line": 593,
          "vulnerability_code": "  function readMulti(bytes32 _exec_id, bytes32[] _locations) public view returns (bytes32[] data_read) {\n\n    data_read = new bytes32[](_locations.length);\n\n    for (uint i = 0; i < _locations.length; i++) {\n\n      bytes32 location = keccak256(_locations[i], _exec_id);\n\n      bytes32 val;\n\n      assembly { val := sload(location) }\n\n      data_read[i] = val;\n\n    }\n",
          "message": "AbstractStorage.readMulti (AbstractStorage.sol#585-593) is declared view but contains assembly code\n"
        },
        {
          "name": "uninitialized-local",
          "vulnerability_from_line": 202,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bytes4 action;\n",
          "message": "action in AbstractStorage.executeAppReturn (AbstractStorage.sol#202) is a local variable never initialiazed\n"
        },
        {
          "name": "calls-loop",
          "vulnerability_from_line": 403,
          "vulnerability_to_line": null,
          "vulnerability_code": "      address(pay_to).transfer(amt);\n",
          "message": "AbstractStorage.doPay has external calls inside a loop:\n\t- address(pay_to).transfer(amt) (AbstractStorage.sol#403)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 75,
          "vulnerability_to_line": 106,
          "vulnerability_code": "  function createInstance(address _sender, bytes32 _app_name, address _provider, bytes32 _registry_id, bytes _calldata) external payable returns (bytes32 new_exec_id, bytes32 version) {\n\n    // Ensure valid input -\n\n    require(_sender != 0 && _app_name != 0 && _provider != 0 && _registry_id != 0 && _calldata.length >= 4, 'invalid input');\n\n\n\n    // Create new exec id by incrementing the nonce -\n\n    new_exec_id = keccak256(++nonce);\n\n\n\n    // Sanity check - verify that this exec id is not linked to an existing application -\n\n    assert(getIndex(new_exec_id) == address(0));\n\n\n\n    // Set the allowed addresses and selectors for the new instance, from the script registry -\n\n    address index;\n\n    (index, version) = setImplementation(new_exec_id, _app_name, _provider, _registry_id);\n\n\n\n    // Set the exec id and sender addresses for the target application -\n\n    setContext(new_exec_id, _sender);\n\n\n\n    // Execute application, create a new exec id, and commit the returned data to storage -\n\n    require(address(index).delegatecall(_calldata) == false, 'Unsafe execution');\n\n    // Get data returned from call revert and perform requested actions -\n\n    executeAppReturn(new_exec_id);\n\n\n\n    // Emit event\n\n    emit ApplicationInitialized(new_exec_id, index, msg.sender);\n\n\n\n    // If execution reaches this point, newly generated exec id should be valid -\n\n    assert(new_exec_id != bytes32(0));\n\n\n\n    // Ensure that any additional balance is transferred back to the sender -\n\n    if (address(this).balance > 0)\n\n      address(msg.sender).transfer(address(this).balance);\n",
          "message": "Reentrancy in AbstractStorage.createInstance (AbstractStorage.sol#75-106):\n\tExternal calls:\n\t- (index,version) = setImplementation(new_exec_id,_app_name,_provider,_registry_id) (AbstractStorage.sol#87)\n\tState variables written after the call(s):\n\t- exec_id (AbstractStorage.sol#90)\n\t- sender (AbstractStorage.sol#90)\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 283,
          "vulnerability_to_line": 288,
          "vulnerability_code": "  function getIndex(bytes32 _exec_id) public view returns (address) {\n\n    bytes32 seed = APP_IDX_ADDR;\n\n    function (bytes32, bytes32) view returns (address) getter;\n\n    assembly { getter := readMap }\n\n    return getter(_exec_id, seed);\n",
          "message": "AbstractStorage.getIndex uses assembly (AbstractStorage.sol#283-288)\n\t- AbstractStorage.sol#286-287\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 291,
          "vulnerability_to_line": 296,
          "vulnerability_code": "  function getTarget(bytes32 _exec_id, bytes4 _selector) public view returns (address) {\n\n    bytes32 seed = keccak256(_selector, 'implementation');\n\n    function (bytes32, bytes32) view returns (address) getter;\n\n    assembly { getter := readMap }\n\n    return getter(_exec_id, seed);\n",
          "message": "AbstractStorage.getTarget uses assembly (AbstractStorage.sol#291-296)\n\t- AbstractStorage.sol#294-295\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 306,
          "vulnerability_to_line": 310,
          "vulnerability_code": "  function put(bytes32 _exec_id, bytes32 _seed, bytes32 _val) internal {\n\n    function (bytes32, bytes32, bytes32) puts;\n\n    assembly { puts := putMap }\n\n    puts(_exec_id, _seed, _val);\n",
          "message": "AbstractStorage.put uses assembly (AbstractStorage.sol#306-310)\n\t- AbstractStorage.sol#308-309\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 319,
          "vulnerability_to_line": 326,
          "vulnerability_code": "  function getSelector(bytes memory _calldata) internal pure returns (bytes4 sel) {\n\n    assembly {\n\n      sel := and(\n\n        mload(add(0x20, _calldata)),\n\n        0xffffffff00000000000000000000000000000000000000000000000000000000\n\n      )\n\n    }\n",
          "message": "AbstractStorage.getSelector uses assembly (AbstractStorage.sol#319-326)\n\t- AbstractStorage.sol#320-326\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 335,
          "vulnerability_to_line": 352,
          "vulnerability_code": "  function getReturnedData() internal pure returns (uint ptr_bounds, uint _returndata_ptr) {\n\n    assembly {\n\n      // returndatasize must be minimum 96 bytes (offset, length, and requestor)\n\n      if lt(returndatasize, 0x60) {\n\n        mstore(0, 'Insufficient return size')\n\n        revert(0, 0x20)\n\n      }\n\n      // Get memory location to which returndata will be copied\n\n      _returndata_ptr := msize\n\n      // Copy returned data to pointer location\n\n      returndatacopy(_returndata_ptr, 0, returndatasize)\n\n      // Get maximum memory location value for returndata\n\n      ptr_bounds := add(_returndata_ptr, returndatasize)\n\n      // Set new free-memory pointer to point after the returndata in memory\n\n      // Returndata is automatically 32-bytes padded\n\n      mstore(0x40, add(0x20, ptr_bounds))\n\n    }\n",
          "message": "AbstractStorage.getReturnedData uses assembly (AbstractStorage.sol#335-352)\n\t- AbstractStorage.sol#336-352\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 360,
          "vulnerability_to_line": 362,
          "vulnerability_code": "  function getLength(uint _ptr) internal pure returns (uint length) {\n\n    assembly { length := mload(_ptr) }\n",
          "message": "AbstractStorage.getLength uses assembly (AbstractStorage.sol#360-362)\n\t- AbstractStorage.sol#361-362\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 365,
          "vulnerability_to_line": 368,
          "vulnerability_code": "  function doThrow(uint _ptr) internal pure {\n\n    assert(getAction(_ptr) == THROWS);\n\n    assembly { revert(_ptr, returndatasize) }\n",
          "message": "AbstractStorage.doThrow uses assembly (AbstractStorage.sol#365-368)\n\t- AbstractStorage.sol#367-368\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 381,
          "vulnerability_to_line": 412,
          "vulnerability_code": "  function doPay(bytes32 _exec_id, uint _ptr, uint _ptr_bound) internal returns (uint ptr, uint n_paid) {\n\n    // Ensure ETH was sent with the call\n\n    require(msg.value > 0);\n\n    assert(getAction(_ptr) == PAYS);\n\n    _ptr += 4;\n\n    // Get number of destinations\n\n    uint num_destinations = getLength(_ptr);\n\n    _ptr += 32;\n\n    address pay_to;\n\n    uint amt;\n\n    // Loop over PAYS actions and process each one\n\n    while (_ptr <= _ptr_bound && n_paid < num_destinations) {\n\n      // Get the payment destination and amount from the pointer\n\n      assembly {\n\n        amt := mload(_ptr)\n\n        pay_to := mload(add(0x20, _ptr))\n\n      }\n\n      // Invalid address was passed as a payment destination - throw\n\n      if (pay_to == address(0) || pay_to == address(this))\n\n        revert('PAYS: invalid destination');\n\n\n\n      // Forward ETH and increment n_paid\n\n      address(pay_to).transfer(amt);\n\n      n_paid++;\n\n      // Increment pointer\n\n      _ptr += 64;\n\n      // Emit event\n\n      emit DeliveredPayment(_exec_id, pay_to, amt);\n\n    }\n\n    ptr = _ptr;\n\n    assert(n_paid == num_destinations);\n",
          "message": "AbstractStorage.doPay uses assembly (AbstractStorage.sol#381-412)\n\t- AbstractStorage.sol#394-399\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 427,
          "vulnerability_to_line": 450,
          "vulnerability_code": "  function doStore(uint _ptr, uint _ptr_bound, bytes32 _exec_id) internal returns (uint ptr, uint n_stored) {\n\n    assert(getAction(_ptr) == STORES && _exec_id != bytes32(0));\n\n    _ptr += 4;\n\n    // Get number of locations to which data will be stored\n\n    uint num_locations = getLength(_ptr);\n\n    _ptr += 32;\n\n    bytes32 location;\n\n    bytes32 value;\n\n    // Loop over STORES actions and process each one\n\n    while (_ptr <= _ptr_bound && n_stored < num_locations) {\n\n      // Get storage location and value to store from the pointer\n\n      assembly {\n\n        location := mload(_ptr)\n\n        value := mload(add(0x20, _ptr))\n\n      }\n\n      // Store the data to the location hashed with the exec id\n\n      store(_exec_id, location, value);\n\n      // Increment n_stored and pointer\n\n      n_stored++;\n\n      _ptr += 64;\n\n    }\n\n    ptr = _ptr;\n\n    require(n_stored == num_locations);\n",
          "message": "AbstractStorage.doStore uses assembly (AbstractStorage.sol#427-450)\n\t- AbstractStorage.sol#438-443\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 465,
          "vulnerability_to_line": 541,
          "vulnerability_code": "  function doEmit(uint _ptr, uint _ptr_bound) internal returns (uint ptr, uint n_emitted) {\n\n    assert(getAction(_ptr) == EMITS);\n\n    _ptr += 4;\n\n    // Converts number of events that will be emitted\n\n    uint num_events = getLength(_ptr);\n\n    _ptr += 32;\n\n    bytes32[] memory topics;\n\n    bytes memory data;\n\n    // Loop over EMITS actions and process each one\n\n    while (_ptr <= _ptr_bound && n_emitted < num_events) {\n\n      // Get array of topics and additional data from the pointer\n\n      assembly {\n\n        topics := _ptr\n\n        data := add(add(_ptr, 0x20), mul(0x20, mload(topics)))\n\n      }\n\n      // Get size of the Event's data in memory\n\n      uint log_size = 32 + (32 * (1 + topics.length)) + data.length;\n\n      assembly {\n\n        switch mload(topics)                // topics.length\n\n          case 0 {\n\n            // Log Event.data array with no topics\n\n            log0(\n\n              add(0x20, data),              // data(ptr)\n\n              mload(data)                   // data.length\n\n            )\n\n          }\n\n          case 1 {\n\n            // Log Event.data array with 1 topic\n\n            log1(\n\n              add(0x20, data),              // data(ptr)\n\n              mload(data),                  // data.length\n\n              mload(add(0x20, topics))      // topics[0]\n\n            )\n\n          }\n\n          case 2 {\n\n            // Log Event.data array with 2 topics\n\n            log2(\n\n              add(0x20, data),              // data(ptr)\n\n              mload(data),                  // data.length\n\n              mload(add(0x20, topics)),     // topics[0]\n\n              mload(add(0x40, topics))      // topics[1]\n\n            )\n\n          }\n\n          case 3 {\n\n            // Log Event.data array with 3 topics\n\n            log3(\n\n              add(0x20, data),              // data(ptr)\n\n              mload(data),                  // data.length\n\n              mload(add(0x20, topics)),     // topics[0]\n\n              mload(add(0x40, topics)),     // topics[1]\n\n              mload(add(0x60, topics))      // topics[2]\n\n            )\n\n          }\n\n          case 4 {\n\n            // Log Event.data array with 4 topics\n\n            log4(\n\n              add(0x20, data),              // data(ptr)\n\n              mload(data),                  // data.length\n\n              mload(add(0x20, topics)),     // topics[0]\n\n              mload(add(0x40, topics)),     // topics[1]\n\n              mload(add(0x60, topics)),     // topics[2]\n\n              mload(add(0x80, topics))      // topics[3]\n\n            )\n\n          }\n\n          default {\n\n            // Events must have 4 or fewer topics\n\n            mstore(0, 'EMITS: invalid topic count')\n\n            revert(0, 0x20)\n\n          }\n\n      }\n\n      // Event emitted - increment n_emitted and pointer\n\n      n_emitted++;\n\n      _ptr += log_size;\n\n    }\n\n    ptr = _ptr;\n\n    require(n_emitted == num_events);\n",
          "message": "AbstractStorage.doEmit uses assembly (AbstractStorage.sol#465-541)\n\t- AbstractStorage.sol#476-481\n\t- AbstractStorage.sol#482-536\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 544,
          "vulnerability_to_line": 549,
          "vulnerability_code": "  function getAction(uint _ptr) internal pure returns (bytes4 action) {\n\n    assembly {\n\n      // Get the first 4 bytes stored at the pointer, and clean the rest of the bytes remaining\n\n      action := and(mload(_ptr), 0xffffffff00000000000000000000000000000000000000000000000000000000)\n\n    }\n",
          "message": "AbstractStorage.getAction uses assembly (AbstractStorage.sol#544-549)\n\t- AbstractStorage.sol#545-549\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 561,
          "vulnerability_to_line": 566,
          "vulnerability_code": "  function store(bytes32 _exec_id, bytes32 _location, bytes32 _data) internal {\n\n    // Get true location to store data to - hash of location hashed with exec id\n\n    _location = keccak256(_location, _exec_id);\n\n    // Store data at location\n\n    assembly { sstore(_location, _data) }\n",
          "message": "AbstractStorage.store uses assembly (AbstractStorage.sol#561-566)\n\t- AbstractStorage.sol#565-566\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 575,
          "vulnerability_to_line": 578,
          "vulnerability_code": "  function read(bytes32 _exec_id, bytes32 _location) public view returns (bytes32 data_read) {\n\n    _location = keccak256(_location, _exec_id);\n\n    assembly { data_read := sload(_location) }\n",
          "message": "AbstractStorage.read uses assembly (AbstractStorage.sol#575-578)\n\t- AbstractStorage.sol#577-578\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 585,
          "vulnerability_to_line": 593,
          "vulnerability_code": "  function readMulti(bytes32 _exec_id, bytes32[] _locations) public view returns (bytes32[] data_read) {\n\n    data_read = new bytes32[](_locations.length);\n\n    for (uint i = 0; i < _locations.length; i++) {\n\n      bytes32 location = keccak256(_locations[i], _exec_id);\n\n      bytes32 val;\n\n      assembly { val := sload(location) }\n\n      data_read[i] = val;\n\n    }\n",
          "message": "AbstractStorage.readMulti uses assembly (AbstractStorage.sol#585-593)\n\t- AbstractStorage.sol#590-591\n"
        },
        {
          "name": "solc-version",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.23;\n",
          "message": "Detected issues with version pragma in AbstractStorage.sol:\n\t- pragma solidity^0.4.23 (AbstractStorage.sol#3): it allows old versions\n\t- pragma solidity^0.4.23 (AbstractStorage.sol#14): it allows old versions\n"
        },
        {
          "name": "low-level-calls",
          "vulnerability_from_line": 75,
          "vulnerability_to_line": 106,
          "vulnerability_code": "  function createInstance(address _sender, bytes32 _app_name, address _provider, bytes32 _registry_id, bytes _calldata) external payable returns (bytes32 new_exec_id, bytes32 version) {\n\n    // Ensure valid input -\n\n    require(_sender != 0 && _app_name != 0 && _provider != 0 && _registry_id != 0 && _calldata.length >= 4, 'invalid input');\n\n\n\n    // Create new exec id by incrementing the nonce -\n\n    new_exec_id = keccak256(++nonce);\n\n\n\n    // Sanity check - verify that this exec id is not linked to an existing application -\n\n    assert(getIndex(new_exec_id) == address(0));\n\n\n\n    // Set the allowed addresses and selectors for the new instance, from the script registry -\n\n    address index;\n\n    (index, version) = setImplementation(new_exec_id, _app_name, _provider, _registry_id);\n\n\n\n    // Set the exec id and sender addresses for the target application -\n\n    setContext(new_exec_id, _sender);\n\n\n\n    // Execute application, create a new exec id, and commit the returned data to storage -\n\n    require(address(index).delegatecall(_calldata) == false, 'Unsafe execution');\n\n    // Get data returned from call revert and perform requested actions -\n\n    executeAppReturn(new_exec_id);\n\n\n\n    // Emit event\n\n    emit ApplicationInitialized(new_exec_id, index, msg.sender);\n\n\n\n    // If execution reaches this point, newly generated exec id should be valid -\n\n    assert(new_exec_id != bytes32(0));\n\n\n\n    // Ensure that any additional balance is transferred back to the sender -\n\n    if (address(this).balance > 0)\n\n      address(msg.sender).transfer(address(this).balance);\n",
          "message": "Low level call in AbstractStorage.createInstance (AbstractStorage.sol#75-106):\n\t-require(bool,string)(address(index).delegatecall(_calldata) == false,Unsafe execution) AbstractStorage.sol#93\n"
        },
        {
          "name": "low-level-calls",
          "vulnerability_from_line": 119,
          "vulnerability_to_line": 144,
          "vulnerability_code": "  function exec(address _sender, bytes32 _exec_id, bytes _calldata) external payable returns (uint n_emitted, uint n_paid, uint n_stored) {\n\n    // Ensure valid input and input size - minimum 4 bytes\n\n    require(_calldata.length >= 4 && _sender != address(0) && _exec_id != bytes32(0));\n\n\n\n    // Get the target address associated with the given exec id\n\n    address target = getTarget(_exec_id, getSelector(_calldata));\n\n    require(target != address(0), 'Uninitialized application');\n\n\n\n    // Set the exec id and sender addresses for the target application -\n\n    setContext(_exec_id, _sender);\n\n\n\n    // Execute application and commit returned data to storage -\n\n    require(address(target).delegatecall(_calldata) == false, 'Unsafe execution');\n\n    (n_emitted, n_paid, n_stored) = executeAppReturn(_exec_id);\n\n\n\n    // If no events were emitted, no wei was forwarded, and no storage was changed, revert -\n\n    if (n_emitted == 0 && n_paid == 0 && n_stored == 0)\n\n      revert('No state change occured');\n\n\n\n    // Emit event -\n\n    emit ApplicationExecution(_exec_id, target);\n\n\n\n    // Ensure that any additional balance is transferred back to the sender -\n\n    if (address(this).balance > 0)\n\n      address(msg.sender).transfer(address(this).balance);\n",
          "message": "Low level call in AbstractStorage.exec (AbstractStorage.sol#119-144):\n\t-require(bool,string)(address(target).delegatecall(_calldata) == false,Unsafe execution) AbstractStorage.sol#131\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 6,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function getLatestVersion(address stor_addr, bytes32 exec_id, address provider, bytes32 app_name)\n",
          "message": "Parameter 'stor_addr' of RegistryInterface.getLatestVersion (AbstractStorage.sol#6) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 6,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function getLatestVersion(address stor_addr, bytes32 exec_id, address provider, bytes32 app_name)\n",
          "message": "Parameter 'exec_id' of RegistryInterface.getLatestVersion (AbstractStorage.sol#6) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 6,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function getLatestVersion(address stor_addr, bytes32 exec_id, address provider, bytes32 app_name)\n",
          "message": "Parameter 'app_name' of RegistryInterface.getLatestVersion (AbstractStorage.sol#6) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 8,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function getVersionImplementation(address stor_addr, bytes32 exec_id, address provider, bytes32 app_name, bytes32 version_name)\n",
          "message": "Parameter 'stor_addr' of RegistryInterface.getVersionImplementation (AbstractStorage.sol#8) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 8,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function getVersionImplementation(address stor_addr, bytes32 exec_id, address provider, bytes32 app_name, bytes32 version_name)\n",
          "message": "Parameter 'exec_id' of RegistryInterface.getVersionImplementation (AbstractStorage.sol#8) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 8,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function getVersionImplementation(address stor_addr, bytes32 exec_id, address provider, bytes32 app_name, bytes32 version_name)\n",
          "message": "Parameter 'app_name' of RegistryInterface.getVersionImplementation (AbstractStorage.sol#8) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 8,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function getVersionImplementation(address stor_addr, bytes32 exec_id, address provider, bytes32 app_name, bytes32 version_name)\n",
          "message": "Parameter 'version_name' of RegistryInterface.getVersionImplementation (AbstractStorage.sol#8) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 54,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function createRegistry(address _registry_idx, address _implementation) external returns (bytes32) {\n",
          "message": "Parameter '_registry_idx' of AbstractStorage.createRegistry (AbstractStorage.sol#54) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 54,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function createRegistry(address _registry_idx, address _implementation) external returns (bytes32) {\n",
          "message": "Parameter '_implementation' of AbstractStorage.createRegistry (AbstractStorage.sol#54) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 75,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function createInstance(address _sender, bytes32 _app_name, address _provider, bytes32 _registry_id, bytes _calldata) external payable returns (bytes32 new_exec_id, bytes32 version) {\n",
          "message": "Parameter '_sender' of AbstractStorage.createInstance (AbstractStorage.sol#75) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 75,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function createInstance(address _sender, bytes32 _app_name, address _provider, bytes32 _registry_id, bytes _calldata) external payable returns (bytes32 new_exec_id, bytes32 version) {\n",
          "message": "Parameter '_app_name' of AbstractStorage.createInstance (AbstractStorage.sol#75) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 75,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function createInstance(address _sender, bytes32 _app_name, address _provider, bytes32 _registry_id, bytes _calldata) external payable returns (bytes32 new_exec_id, bytes32 version) {\n",
          "message": "Parameter '_provider' of AbstractStorage.createInstance (AbstractStorage.sol#75) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 75,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function createInstance(address _sender, bytes32 _app_name, address _provider, bytes32 _registry_id, bytes _calldata) external payable returns (bytes32 new_exec_id, bytes32 version) {\n",
          "message": "Parameter '_registry_id' of AbstractStorage.createInstance (AbstractStorage.sol#75) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 75,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function createInstance(address _sender, bytes32 _app_name, address _provider, bytes32 _registry_id, bytes _calldata) external payable returns (bytes32 new_exec_id, bytes32 version) {\n",
          "message": "Parameter '_calldata' of AbstractStorage.createInstance (AbstractStorage.sol#75) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 119,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function exec(address _sender, bytes32 _exec_id, bytes _calldata) external payable returns (uint n_emitted, uint n_paid, uint n_stored) {\n",
          "message": "Parameter '_sender' of AbstractStorage.exec (AbstractStorage.sol#119) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 119,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function exec(address _sender, bytes32 _exec_id, bytes _calldata) external payable returns (uint n_emitted, uint n_paid, uint n_stored) {\n",
          "message": "Parameter '_exec_id' of AbstractStorage.exec (AbstractStorage.sol#119) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 119,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function exec(address _sender, bytes32 _exec_id, bytes _calldata) external payable returns (uint n_emitted, uint n_paid, uint n_stored) {\n",
          "message": "Parameter '_calldata' of AbstractStorage.exec (AbstractStorage.sol#119) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 185,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function executeAppReturn(bytes32 _exec_id) internal returns (uint n_emitted, uint n_paid, uint n_stored) {\n",
          "message": "Parameter '_exec_id' of AbstractStorage.executeAppReturn (AbstractStorage.sol#185) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 246,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function setImplementation(bytes32 _new_exec_id, bytes32 _app_name, address _provider, bytes32 _registry_id) internal returns (address index, bytes32 version) {\n",
          "message": "Parameter '_new_exec_id' of AbstractStorage.setImplementation (AbstractStorage.sol#246) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 246,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function setImplementation(bytes32 _new_exec_id, bytes32 _app_name, address _provider, bytes32 _registry_id) internal returns (address index, bytes32 version) {\n",
          "message": "Parameter '_app_name' of AbstractStorage.setImplementation (AbstractStorage.sol#246) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 246,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function setImplementation(bytes32 _new_exec_id, bytes32 _app_name, address _provider, bytes32 _registry_id) internal returns (address index, bytes32 version) {\n",
          "message": "Parameter '_provider' of AbstractStorage.setImplementation (AbstractStorage.sol#246) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 246,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function setImplementation(bytes32 _new_exec_id, bytes32 _app_name, address _provider, bytes32 _registry_id) internal returns (address index, bytes32 version) {\n",
          "message": "Parameter '_registry_id' of AbstractStorage.setImplementation (AbstractStorage.sol#246) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 283,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function getIndex(bytes32 _exec_id) public view returns (address) {\n",
          "message": "Parameter '_exec_id' of AbstractStorage.getIndex (AbstractStorage.sol#283) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 291,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function getTarget(bytes32 _exec_id, bytes4 _selector) public view returns (address) {\n",
          "message": "Parameter '_exec_id' of AbstractStorage.getTarget (AbstractStorage.sol#291) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 291,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function getTarget(bytes32 _exec_id, bytes4 _selector) public view returns (address) {\n",
          "message": "Parameter '_selector' of AbstractStorage.getTarget (AbstractStorage.sol#291) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 301,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function readMap(Map storage _map, bytes32 _seed) internal view returns (bytes32) {\n",
          "message": "Parameter '_map' of AbstractStorage.readMap (AbstractStorage.sol#301) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 301,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function readMap(Map storage _map, bytes32 _seed) internal view returns (bytes32) {\n",
          "message": "Parameter '_seed' of AbstractStorage.readMap (AbstractStorage.sol#301) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 306,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function put(bytes32 _exec_id, bytes32 _seed, bytes32 _val) internal {\n",
          "message": "Parameter '_exec_id' of AbstractStorage.put (AbstractStorage.sol#306) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 306,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function put(bytes32 _exec_id, bytes32 _seed, bytes32 _val) internal {\n",
          "message": "Parameter '_seed' of AbstractStorage.put (AbstractStorage.sol#306) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 306,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function put(bytes32 _exec_id, bytes32 _seed, bytes32 _val) internal {\n",
          "message": "Parameter '_val' of AbstractStorage.put (AbstractStorage.sol#306) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 313,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function putMap(Map storage _map, bytes32 _seed, bytes32 _val) internal {\n",
          "message": "Parameter '_map' of AbstractStorage.putMap (AbstractStorage.sol#313) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 313,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function putMap(Map storage _map, bytes32 _seed, bytes32 _val) internal {\n",
          "message": "Parameter '_seed' of AbstractStorage.putMap (AbstractStorage.sol#313) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 313,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function putMap(Map storage _map, bytes32 _seed, bytes32 _val) internal {\n",
          "message": "Parameter '_val' of AbstractStorage.putMap (AbstractStorage.sol#313) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 365,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function doThrow(uint _ptr) internal pure {\n",
          "message": "Parameter '_ptr' of AbstractStorage.doThrow (AbstractStorage.sol#365) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 381,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function doPay(bytes32 _exec_id, uint _ptr, uint _ptr_bound) internal returns (uint ptr, uint n_paid) {\n",
          "message": "Parameter '_exec_id' of AbstractStorage.doPay (AbstractStorage.sol#381) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 381,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function doPay(bytes32 _exec_id, uint _ptr, uint _ptr_bound) internal returns (uint ptr, uint n_paid) {\n",
          "message": "Parameter '_ptr' of AbstractStorage.doPay (AbstractStorage.sol#381) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 381,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function doPay(bytes32 _exec_id, uint _ptr, uint _ptr_bound) internal returns (uint ptr, uint n_paid) {\n",
          "message": "Parameter '_ptr_bound' of AbstractStorage.doPay (AbstractStorage.sol#381) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 427,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function doStore(uint _ptr, uint _ptr_bound, bytes32 _exec_id) internal returns (uint ptr, uint n_stored) {\n",
          "message": "Parameter '_ptr' of AbstractStorage.doStore (AbstractStorage.sol#427) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 427,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function doStore(uint _ptr, uint _ptr_bound, bytes32 _exec_id) internal returns (uint ptr, uint n_stored) {\n",
          "message": "Parameter '_ptr_bound' of AbstractStorage.doStore (AbstractStorage.sol#427) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 427,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function doStore(uint _ptr, uint _ptr_bound, bytes32 _exec_id) internal returns (uint ptr, uint n_stored) {\n",
          "message": "Parameter '_exec_id' of AbstractStorage.doStore (AbstractStorage.sol#427) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 465,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function doEmit(uint _ptr, uint _ptr_bound) internal returns (uint ptr, uint n_emitted) {\n",
          "message": "Parameter '_ptr' of AbstractStorage.doEmit (AbstractStorage.sol#465) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 465,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function doEmit(uint _ptr, uint _ptr_bound) internal returns (uint ptr, uint n_emitted) {\n",
          "message": "Parameter '_ptr_bound' of AbstractStorage.doEmit (AbstractStorage.sol#465) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 553,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function setContext(bytes32 _exec_id, address _sender) internal {\n",
          "message": "Parameter '_exec_id' of AbstractStorage.setContext (AbstractStorage.sol#553) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 553,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function setContext(bytes32 _exec_id, address _sender) internal {\n",
          "message": "Parameter '_sender' of AbstractStorage.setContext (AbstractStorage.sol#553) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 561,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function store(bytes32 _exec_id, bytes32 _location, bytes32 _data) internal {\n",
          "message": "Parameter '_exec_id' of AbstractStorage.store (AbstractStorage.sol#561) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 561,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function store(bytes32 _exec_id, bytes32 _location, bytes32 _data) internal {\n",
          "message": "Parameter '_location' of AbstractStorage.store (AbstractStorage.sol#561) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 575,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function read(bytes32 _exec_id, bytes32 _location) public view returns (bytes32 data_read) {\n",
          "message": "Parameter '_exec_id' of AbstractStorage.read (AbstractStorage.sol#575) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 575,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function read(bytes32 _exec_id, bytes32 _location) public view returns (bytes32 data_read) {\n",
          "message": "Parameter '_location' of AbstractStorage.read (AbstractStorage.sol#575) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 585,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function readMulti(bytes32 _exec_id, bytes32[] _locations) public view returns (bytes32[] data_read) {\n",
          "message": "Parameter '_exec_id' of AbstractStorage.readMulti (AbstractStorage.sol#585) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 585,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function readMulti(bytes32 _exec_id, bytes32[] _locations) public view returns (bytes32[] data_read) {\n",
          "message": "Parameter '_locations' of AbstractStorage.readMulti (AbstractStorage.sol#585) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 20,
          "vulnerability_to_line": null,
          "vulnerability_code": "  bytes32 private exec_id;\n",
          "message": "Variable 'AbstractStorage.exec_id' (AbstractStorage.sol#20) is not in mixedCase\n"
        }
      ]
    },
    "smartcheck": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 272,
          "vulnerability_to_line": null,
          "vulnerability_code": "    for (uint i = 0; i < selectors.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 587,
          "vulnerability_to_line": null,
          "vulnerability_code": "    for (uint i = 0; i < _locations.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
          "vulnerability_from_line": 319,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function getSelector(bytes memory _calldata) internal pure returns (bytes4 sel) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
          "vulnerability_from_line": 335,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function getReturnedData() internal pure returns (uint ptr_bounds, uint _returndata_ptr) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
          "vulnerability_from_line": 360,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function getLength(uint _ptr) internal pure returns (uint length) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
          "vulnerability_from_line": 381,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function doPay(bytes32 _exec_id, uint _ptr, uint _ptr_bound) internal returns (uint ptr, uint n_paid) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
          "vulnerability_from_line": 427,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function doStore(uint _ptr, uint _ptr_bound, bytes32 _exec_id) internal returns (uint ptr, uint n_stored) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
          "vulnerability_from_line": 465,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function doEmit(uint _ptr, uint _ptr_bound) internal returns (uint ptr, uint n_emitted) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
          "vulnerability_from_line": 544,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function getAction(uint _ptr) internal pure returns (bytes4 action) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
          "vulnerability_from_line": 575,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function read(bytes32 _exec_id, bytes32 _location) public view returns (bytes32 data_read) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 272,
          "vulnerability_to_line": null,
          "vulnerability_code": "    for (uint i = 0; i < selectors.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 587,
          "vulnerability_to_line": null,
          "vulnerability_code": "    for (uint i = 0; i < _locations.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 392,
          "vulnerability_to_line": null,
          "vulnerability_code": "    while (_ptr <= _ptr_bound && n_paid < num_destinations) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 436,
          "vulnerability_to_line": null,
          "vulnerability_code": "    while (_ptr <= _ptr_bound && n_stored < num_locations) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 474,
          "vulnerability_to_line": null,
          "vulnerability_code": "    while (_ptr <= _ptr_bound && n_emitted < num_events) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 203,
          "vulnerability_to_line": null,
          "vulnerability_code": "    while (_ptr <= ptr_bound && (action = getAction(_ptr)) != 0x0) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.23;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 14,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.23;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 20,
          "vulnerability_to_line": null,
          "vulnerability_code": "  bytes32 private exec_id;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 21,
          "vulnerability_to_line": null,
          "vulnerability_code": "  address private sender;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 24,
          "vulnerability_to_line": null,
          "vulnerability_code": "  uint private nonce;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_REVERT_REQUIRE",
          "vulnerability_from_line": 135,
          "vulnerability_to_line": null,
          "vulnerability_code": "    if (n_emitted == 0 && n_paid == 0 && n_stored == 0)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_REVERT_REQUIRE",
          "vulnerability_from_line": 220,
          "vulnerability_to_line": null,
          "vulnerability_code": "      } else if (action == PAYS) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_REVERT_REQUIRE",
          "vulnerability_from_line": 399,
          "vulnerability_to_line": null,
          "vulnerability_code": "      if (pay_to == address(0) || pay_to == address(this))\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 319,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function getSelector(bytes memory _calldata) internal pure returns (bytes4 sel) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 335,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function getReturnedData() internal pure returns (uint ptr_bounds, uint _returndata_ptr) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 360,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function getLength(uint _ptr) internal pure returns (uint length) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 365,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function doThrow(uint _ptr) internal pure {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 544,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function getAction(uint _ptr) internal pure returns (bytes4 action) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
          "vulnerability_from_line": 283,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function getIndex(bytes32 _exec_id) public view returns (address) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
          "vulnerability_from_line": 291,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function getTarget(bytes32 _exec_id, bytes4 _selector) public view returns (address) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
          "vulnerability_from_line": 575,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function read(bytes32 _exec_id, bytes32 _location) public view returns (bytes32 data_read) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
          "vulnerability_from_line": 585,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function readMulti(bytes32 _exec_id, bytes32[] _locations) public view returns (bytes32[] data_read) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 185,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function executeAppReturn(bytes32 _exec_id) internal returns (uint n_emitted, uint n_paid, uint n_stored) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 246,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function setImplementation(bytes32 _new_exec_id, bytes32 _app_name, address _provider, bytes32 _registry_id) internal returns (address index, bytes32 version) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 335,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function getReturnedData() internal pure returns (uint ptr_bounds, uint _returndata_ptr) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 381,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function doPay(bytes32 _exec_id, uint _ptr, uint _ptr_bound) internal returns (uint ptr, uint n_paid) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 427,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function doStore(uint _ptr, uint _ptr_bound, bytes32 _exec_id) internal returns (uint ptr, uint n_stored) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 465,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function doEmit(uint _ptr, uint _ptr_bound) internal returns (uint ptr, uint n_emitted) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_TRANSFER_IN_LOOP",
          "vulnerability_from_line": 392,
          "vulnerability_to_line": null,
          "vulnerability_code": "    while (_ptr <= _ptr_bound && n_paid < num_destinations) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 56,
          "vulnerability_to_line": null,
          "vulnerability_code": "    put(new_exec_id, keccak256(msg.sender, EXEC_PERMISSIONS), bytes32(1));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 58,
          "vulnerability_to_line": null,
          "vulnerability_code": "    put(new_exec_id, keccak256(REG_APP, 'implementation'), bytes32(_implementation));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 59,
          "vulnerability_to_line": null,
          "vulnerability_code": "    put(new_exec_id, keccak256(REG_APP_VER, 'implementation'), bytes32(_implementation));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 274,
          "vulnerability_to_line": null,
          "vulnerability_code": "      seed = keccak256(selectors[i], 'implementation');\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 292,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bytes32 seed = keccak256(_selector, 'implementation');\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 563,
          "vulnerability_to_line": null,
          "vulnerability_code": "    _location = keccak256(_location, _exec_id);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 576,
          "vulnerability_to_line": null,
          "vulnerability_code": "    _location = keccak256(_location, _exec_id);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 588,
          "vulnerability_to_line": null,
          "vulnerability_code": "      bytes32 location = keccak256(_locations[i], _exec_id);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 585,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function readMulti(bytes32 _exec_id, bytes32[] _locations) public view returns (bytes32[] data_read) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 585,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function readMulti(bytes32 _exec_id, bytes32[] _locations) public view returns (bytes32[] data_read) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 286,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly { getter := readMap }\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 294,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly { getter := readMap }\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 308,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly { puts := putMap }\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 320,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 336,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 361,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly { length := mload(_ptr) }\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 367,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly { revert(_ptr, returndatasize) }\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 394,
          "vulnerability_to_line": null,
          "vulnerability_code": "      assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 438,
          "vulnerability_to_line": null,
          "vulnerability_code": "      assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 476,
          "vulnerability_to_line": null,
          "vulnerability_code": "      assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 482,
          "vulnerability_to_line": null,
          "vulnerability_code": "      assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 545,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 565,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly { sstore(_location, _data) }\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 577,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly { data_read := sload(_location) }\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 590,
          "vulnerability_to_line": null,
          "vulnerability_code": "      assembly { val := sload(location) }\n",
          "message": null
        }
      ]
    },
    "oyente": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "Integer Overflow",
          "vulnerability_from_line": 55,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bytes32 new_exec_id = keccak256(++nonce);\n",
          "message": null
        }
      ]
    },
    "mythril": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": []
    },
    "osiris": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "Overflow bugs",
          "vulnerability_from_line": 55,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bytes32 new_exec_id = keccak256(++nonce);\n",
          "message": null
        },
        {
          "name": "Overflow bugs",
          "vulnerability_from_line": 80,
          "vulnerability_to_line": null,
          "vulnerability_code": "    new_exec_id = keccak256(++nonce);\n",
          "message": null
        }
      ]
    }
  }
}