{
  "smartbugs_completed": true,
  "analyzer_results": {
    "semgrep": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 280,
          "vulnerability_to_line": null,
          "vulnerability_code": "    for (uint i = 0; i < selectors.length; i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 491,
          "vulnerability_to_line": null,
          "vulnerability_code": "      uint log_size = 32 + (32 * (1 + topics.length)) + data.length;\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 491,
          "vulnerability_to_line": null,
          "vulnerability_code": "      uint log_size = 32 + (32 * (1 + topics.length)) + data.length;\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 597,
          "vulnerability_to_line": null,
          "vulnerability_code": "    for (uint i = 0; i < _locations.length; i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 280,
          "vulnerability_to_line": null,
          "vulnerability_code": "    for (uint i = 0; i < selectors.length; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 597,
          "vulnerability_to_line": null,
          "vulnerability_code": "    for (uint i = 0; i < _locations.length; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 85,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require(_sender != 0 && _app_name != 0 && _provider != 0 && _registry_id != 0 && _calldata.length >= 4, 'invalid input');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 101,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require(address(index).delegatecall(_calldata) == false, 'Unsafe execution');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 133,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require(target != address(0), 'Uninitialized application');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 139,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require(address(target).delegatecall(_calldata) == false, 'Unsafe execution');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 144,
          "vulnerability_to_line": null,
          "vulnerability_code": "      revert('No state change occured');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 206,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require(ptr_bound >= _ptr + 64, 'Malformed returndata - invalid size');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 214,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(n_emitted == 0, 'Duplicate action: EMITS');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 219,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(n_emitted != 0, 'Unfulfilled action: EMITS');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 222,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(n_stored == 0, 'Duplicate action: STORES');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 227,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(n_stored != 0, 'Unfulfilled action: STORES');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 230,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(n_paid == 0, 'Duplicate action: PAYS');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 235,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(n_paid != 0, 'Unfulfilled action: PAYS');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 238,
          "vulnerability_to_line": null,
          "vulnerability_code": "        revert('Malformed returndata - unknown action');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 257,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require(index != address(0) && index != address(this), 'Registry application not found');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 263,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require(version != bytes32(0), 'Invalid version name');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 272,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require(index != address(0), 'Invalid index address');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 274,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require(selectors.length == implementations.length && selectors.length != 0, 'Invalid implementation length');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 281,
          "vulnerability_to_line": null,
          "vulnerability_code": "      require(selectors[i] != 0 && implementations[i] != 0, 'invalid input - expected nonzero implementation');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 410,
          "vulnerability_to_line": null,
          "vulnerability_code": "        revert('PAYS: invalid destination');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 85,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require(_sender != 0 && _app_name != 0 && _provider != 0 && _registry_id != 0 && _calldata.length >= 4, 'invalid input');\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 129,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require(_calldata.length >= 4 && _sender != address(0) && _exec_id != bytes32(0));\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 257,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require(index != address(0) && index != address(this), 'Registry application not found');\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 274,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require(selectors.length == implementations.length && selectors.length != 0, 'Invalid implementation length');\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 281,
          "vulnerability_to_line": null,
          "vulnerability_code": "      require(selectors[i] != 0 && implementations[i] != 0, 'invalid input - expected nonzero implementation');\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 143,
          "vulnerability_to_line": null,
          "vulnerability_code": "    if (n_emitted == 0 && n_paid == 0 && n_stored == 0)\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 144,
          "vulnerability_to_line": null,
          "vulnerability_code": "      revert('No state change occured');\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 280,
          "vulnerability_to_line": null,
          "vulnerability_code": "    for (uint i = 0; i < selectors.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 414,
          "vulnerability_to_line": null,
          "vulnerability_code": "      n_paid++;\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 455,
          "vulnerability_to_line": null,
          "vulnerability_code": "      n_stored++;\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 546,
          "vulnerability_to_line": null,
          "vulnerability_code": "      n_emitted++;\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 597,
          "vulnerability_to_line": null,
          "vulnerability_code": "    for (uint i = 0; i < _locations.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 206,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require(ptr_bound >= _ptr + 64, 'Malformed returndata - invalid size');\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 238,
          "vulnerability_to_line": null,
          "vulnerability_code": "        revert('Malformed returndata - unknown action');\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 281,
          "vulnerability_to_line": null,
          "vulnerability_code": "      require(selectors[i] != 0 && implementations[i] != 0, 'invalid input - expected nonzero implementation');\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        }
      ]
    },
    "slither": {
      "successfull_analysis": true,
      "errors": [
        "EXIT_CODE_82"
      ],
      "vulnerability_findings": [
        {
          "name": "arbitrary-send",
          "vulnerability_from_line": 83,
          "vulnerability_to_line": 114,
          "vulnerability_code": "  function createInstance(address _sender, bytes32 _app_name, address _provider, bytes32 _registry_id, bytes _calldata) external payable returns (bytes32 new_exec_id, bytes32 version) {\n\n    // Ensure valid input -\n\n    require(_sender != 0 && _app_name != 0 && _provider != 0 && _registry_id != 0 && _calldata.length >= 4, 'invalid input');\n\n\n\n    // Create new exec id by incrementing the nonce -\n\n    new_exec_id = keccak256(++nonce);\n\n\n\n    // Sanity check - verify that this exec id is not linked to an existing application -\n\n    assert(getIndex(new_exec_id) == address(0));\n\n\n\n    // Set the allowed addresses and selectors for the new instance, from the script registry -\n\n    address index;\n\n    (index, version) = setImplementation(new_exec_id, _app_name, _provider, _registry_id);\n\n\n\n    // Set the exec id and sender addresses for the target application -\n\n    setContext(new_exec_id, _sender);\n\n\n\n    // Execute application, create a new exec id, and commit the returned data to storage -\n\n    require(address(index).delegatecall(_calldata) == false, 'Unsafe execution');\n\n    // Get data returned from call revert and perform requested actions -\n\n    executeAppReturn(new_exec_id);\n\n\n\n    // Emit event\n\n    emit ApplicationInitialized(new_exec_id, index, msg.sender);\n\n\n\n    // If execution reaches this point, newly generated exec id should be valid -\n\n    assert(new_exec_id != bytes32(0));\n\n\n\n    // Ensure that any additional balance is transferred back to the sender -\n\n    if (address(this).balance > 0)\n\n      address(msg.sender).transfer(address(this).balance);\n",
          "message": "AbstractStorage.createInstance (AbstractStorage.sol#83-114) sends eth to arbitrary user\n\tDangerous calls:\n\t- address(msg.sender).transfer(address(this).balance) (AbstractStorage.sol#113)\n"
        },
        {
          "name": "arbitrary-send",
          "vulnerability_from_line": 127,
          "vulnerability_to_line": 152,
          "vulnerability_code": "  function exec(address _sender, bytes32 _exec_id, bytes _calldata) external payable returns (uint n_emitted, uint n_paid, uint n_stored) {\n\n    // Ensure valid input and input size - minimum 4 bytes\n\n    require(_calldata.length >= 4 && _sender != address(0) && _exec_id != bytes32(0));\n\n\n\n    // Get the target address associated with the given exec id\n\n    address target = getTarget(_exec_id, getSelector(_calldata));\n\n    require(target != address(0), 'Uninitialized application');\n\n\n\n    // Set the exec id and sender addresses for the target application -\n\n    setContext(_exec_id, _sender);\n\n\n\n    // Execute application and commit returned data to storage -\n\n    require(address(target).delegatecall(_calldata) == false, 'Unsafe execution');\n\n    (n_emitted, n_paid, n_stored) = executeAppReturn(_exec_id);\n\n\n\n    // If no events were emitted, no wei was forwarded, and no storage was changed, revert -\n\n    if (n_emitted == 0 && n_paid == 0 && n_stored == 0)\n\n      revert('No state change occured');\n\n\n\n    // Emit event -\n\n    emit ApplicationExecution(_exec_id, target);\n\n\n\n    // Ensure that any additional balance is transferred back to the sender -\n\n    if (address(this).balance > 0)\n\n      address(msg.sender).transfer(address(this).balance);\n",
          "message": "AbstractStorage.exec (AbstractStorage.sol#127-152) sends eth to arbitrary user\n\tDangerous calls:\n\t- address(msg.sender).transfer(address(this).balance) (AbstractStorage.sol#151)\n"
        },
        {
          "name": "controlled-delegatecall",
          "vulnerability_from_line": 83,
          "vulnerability_to_line": 114,
          "vulnerability_code": "  function createInstance(address _sender, bytes32 _app_name, address _provider, bytes32 _registry_id, bytes _calldata) external payable returns (bytes32 new_exec_id, bytes32 version) {\n\n    // Ensure valid input -\n\n    require(_sender != 0 && _app_name != 0 && _provider != 0 && _registry_id != 0 && _calldata.length >= 4, 'invalid input');\n\n\n\n    // Create new exec id by incrementing the nonce -\n\n    new_exec_id = keccak256(++nonce);\n\n\n\n    // Sanity check - verify that this exec id is not linked to an existing application -\n\n    assert(getIndex(new_exec_id) == address(0));\n\n\n\n    // Set the allowed addresses and selectors for the new instance, from the script registry -\n\n    address index;\n\n    (index, version) = setImplementation(new_exec_id, _app_name, _provider, _registry_id);\n\n\n\n    // Set the exec id and sender addresses for the target application -\n\n    setContext(new_exec_id, _sender);\n\n\n\n    // Execute application, create a new exec id, and commit the returned data to storage -\n\n    require(address(index).delegatecall(_calldata) == false, 'Unsafe execution');\n\n    // Get data returned from call revert and perform requested actions -\n\n    executeAppReturn(new_exec_id);\n\n\n\n    // Emit event\n\n    emit ApplicationInitialized(new_exec_id, index, msg.sender);\n\n\n\n    // If execution reaches this point, newly generated exec id should be valid -\n\n    assert(new_exec_id != bytes32(0));\n\n\n\n    // Ensure that any additional balance is transferred back to the sender -\n\n    if (address(this).balance > 0)\n\n      address(msg.sender).transfer(address(this).balance);\n",
          "message": "AbstractStorage.createInstance (AbstractStorage.sol#83-114) uses delegatecall to a input-controlled function id\n\trequire(bool,string)(address(index).delegatecall(_calldata) == false,Unsafe execution) (AbstractStorage.sol#101)\n"
        },
        {
          "name": "controlled-delegatecall",
          "vulnerability_from_line": 127,
          "vulnerability_to_line": 152,
          "vulnerability_code": "  function exec(address _sender, bytes32 _exec_id, bytes _calldata) external payable returns (uint n_emitted, uint n_paid, uint n_stored) {\n\n    // Ensure valid input and input size - minimum 4 bytes\n\n    require(_calldata.length >= 4 && _sender != address(0) && _exec_id != bytes32(0));\n\n\n\n    // Get the target address associated with the given exec id\n\n    address target = getTarget(_exec_id, getSelector(_calldata));\n\n    require(target != address(0), 'Uninitialized application');\n\n\n\n    // Set the exec id and sender addresses for the target application -\n\n    setContext(_exec_id, _sender);\n\n\n\n    // Execute application and commit returned data to storage -\n\n    require(address(target).delegatecall(_calldata) == false, 'Unsafe execution');\n\n    (n_emitted, n_paid, n_stored) = executeAppReturn(_exec_id);\n\n\n\n    // If no events were emitted, no wei was forwarded, and no storage was changed, revert -\n\n    if (n_emitted == 0 && n_paid == 0 && n_stored == 0)\n\n      revert('No state change occured');\n\n\n\n    // Emit event -\n\n    emit ApplicationExecution(_exec_id, target);\n\n\n\n    // Ensure that any additional balance is transferred back to the sender -\n\n    if (address(this).balance > 0)\n\n      address(msg.sender).transfer(address(this).balance);\n",
          "message": "AbstractStorage.exec (AbstractStorage.sol#127-152) uses delegatecall to a input-controlled function id\n\trequire(bool,string)(address(target).delegatecall(_calldata) == false,Unsafe execution) (AbstractStorage.sol#139)\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 291,
          "vulnerability_to_line": 296,
          "vulnerability_code": "  function getIndex(bytes32 _exec_id) public view returns (address) {\n\n    bytes32 seed = APP_IDX_ADDR;\n\n    function (bytes32, bytes32) view returns (address) getter;\n\n    assembly { getter := readMap }\n\n    return getter(_exec_id, seed);\n",
          "message": "AbstractStorage.getIndex (AbstractStorage.sol#291-296) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 299,
          "vulnerability_to_line": 304,
          "vulnerability_code": "  function getTarget(bytes32 _exec_id, bytes4 _selector) public view returns (address) {\n\n    bytes32 seed = keccak256(_selector, 'implementation');\n\n    function (bytes32, bytes32) view returns (address) getter;\n\n    assembly { getter := readMap }\n\n    return getter(_exec_id, seed);\n",
          "message": "AbstractStorage.getTarget (AbstractStorage.sol#299-304) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 327,
          "vulnerability_to_line": 334,
          "vulnerability_code": "  function getSelector(bytes memory _calldata) internal pure returns (bytes4 sel) {\n\n    assembly {\n\n      sel := and(\n\n        mload(add(0x20, _calldata)),\n\n        0xffffffff00000000000000000000000000000000000000000000000000000000\n\n      )\n\n    }\n",
          "message": "AbstractStorage.getSelector (AbstractStorage.sol#327-334) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 343,
          "vulnerability_to_line": 362,
          "vulnerability_code": "  function getReturnedData() internal pure returns (uint ptr_bounds, uint _returndata_ptr) {\n\n    assembly {\n\n      // returndatasize must be minimum 96 bytes (offset, length, and requestor)\n\n      if lt(returndatasize, 0x60) {\n\n        mstore(0, 0x20)\n\n        mstore(0x20, 24)\n\n        mstore(0x40, 'Insufficient return size')\n\n        revert(0, 0x60)\n\n      }\n\n      // Get memory location to which returndata will be copied\n\n      _returndata_ptr := msize\n\n      // Copy returned data to pointer location\n\n      returndatacopy(_returndata_ptr, 0, returndatasize)\n\n      // Get maximum memory location value for returndata\n\n      ptr_bounds := add(_returndata_ptr, returndatasize)\n\n      // Set new free-memory pointer to point after the returndata in memory\n\n      // Returndata is automatically 32-bytes padded\n\n      mstore(0x40, add(0x20, ptr_bounds))\n\n    }\n",
          "message": "AbstractStorage.getReturnedData (AbstractStorage.sol#343-362) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 370,
          "vulnerability_to_line": 372,
          "vulnerability_code": "  function getLength(uint _ptr) internal pure returns (uint length) {\n\n    assembly { length := mload(_ptr) }\n",
          "message": "AbstractStorage.getLength (AbstractStorage.sol#370-372) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 375,
          "vulnerability_to_line": 378,
          "vulnerability_code": "  function doThrow(uint _ptr) internal pure {\n\n    assert(getAction(_ptr) == THROWS);\n\n    assembly { revert(_ptr, returndatasize) }\n",
          "message": "AbstractStorage.doThrow (AbstractStorage.sol#375-378) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 554,
          "vulnerability_to_line": 559,
          "vulnerability_code": "  function getAction(uint _ptr) internal pure returns (bytes4 action) {\n\n    assembly {\n\n      // Get the first 4 bytes stored at the pointer, and clean the rest of the bytes remaining\n\n      action := and(mload(_ptr), 0xffffffff00000000000000000000000000000000000000000000000000000000)\n\n    }\n",
          "message": "AbstractStorage.getAction (AbstractStorage.sol#554-559) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 585,
          "vulnerability_to_line": 588,
          "vulnerability_code": "  function read(bytes32 _exec_id, bytes32 _location) public view returns (bytes32 data_read) {\n\n    _location = keccak256(_location, _exec_id);\n\n    assembly { data_read := sload(_location) }\n",
          "message": "AbstractStorage.read (AbstractStorage.sol#585-588) is declared view but contains assembly code\n"
        },
        {
          "name": "uninitialized-local",
          "vulnerability_from_line": 210,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bytes4 action;\n",
          "message": "action in AbstractStorage.executeAppReturn (AbstractStorage.sol#210) is a local variable never initialiazed\n"
        },
        {
          "name": "calls-loop",
          "vulnerability_from_line": 413,
          "vulnerability_to_line": null,
          "vulnerability_code": "      address(pay_to).transfer(amt);\n",
          "message": "AbstractStorage.doPay has external calls inside a loop:\n\t- address(pay_to).transfer(amt) (AbstractStorage.sol#413)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 83,
          "vulnerability_to_line": 114,
          "vulnerability_code": "  function createInstance(address _sender, bytes32 _app_name, address _provider, bytes32 _registry_id, bytes _calldata) external payable returns (bytes32 new_exec_id, bytes32 version) {\n\n    // Ensure valid input -\n\n    require(_sender != 0 && _app_name != 0 && _provider != 0 && _registry_id != 0 && _calldata.length >= 4, 'invalid input');\n\n\n\n    // Create new exec id by incrementing the nonce -\n\n    new_exec_id = keccak256(++nonce);\n\n\n\n    // Sanity check - verify that this exec id is not linked to an existing application -\n\n    assert(getIndex(new_exec_id) == address(0));\n\n\n\n    // Set the allowed addresses and selectors for the new instance, from the script registry -\n\n    address index;\n\n    (index, version) = setImplementation(new_exec_id, _app_name, _provider, _registry_id);\n\n\n\n    // Set the exec id and sender addresses for the target application -\n\n    setContext(new_exec_id, _sender);\n\n\n\n    // Execute application, create a new exec id, and commit the returned data to storage -\n\n    require(address(index).delegatecall(_calldata) == false, 'Unsafe execution');\n\n    // Get data returned from call revert and perform requested actions -\n\n    executeAppReturn(new_exec_id);\n\n\n\n    // Emit event\n\n    emit ApplicationInitialized(new_exec_id, index, msg.sender);\n\n\n\n    // If execution reaches this point, newly generated exec id should be valid -\n\n    assert(new_exec_id != bytes32(0));\n\n\n\n    // Ensure that any additional balance is transferred back to the sender -\n\n    if (address(this).balance > 0)\n\n      address(msg.sender).transfer(address(this).balance);\n",
          "message": "Reentrancy in AbstractStorage.createInstance (AbstractStorage.sol#83-114):\n\tExternal calls:\n\t- (index,version) = setImplementation(new_exec_id,_app_name,_provider,_registry_id) (AbstractStorage.sol#95)\n\tState variables written after the call(s):\n\t- exec_id (AbstractStorage.sol#98)\n\t- sender (AbstractStorage.sol#98)\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 291,
          "vulnerability_to_line": 296,
          "vulnerability_code": "  function getIndex(bytes32 _exec_id) public view returns (address) {\n\n    bytes32 seed = APP_IDX_ADDR;\n\n    function (bytes32, bytes32) view returns (address) getter;\n\n    assembly { getter := readMap }\n\n    return getter(_exec_id, seed);\n",
          "message": "AbstractStorage.getIndex uses assembly (AbstractStorage.sol#291-296)\n\t- AbstractStorage.sol#294-295\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 299,
          "vulnerability_to_line": 304,
          "vulnerability_code": "  function getTarget(bytes32 _exec_id, bytes4 _selector) public view returns (address) {\n\n    bytes32 seed = keccak256(_selector, 'implementation');\n\n    function (bytes32, bytes32) view returns (address) getter;\n\n    assembly { getter := readMap }\n\n    return getter(_exec_id, seed);\n",
          "message": "AbstractStorage.getTarget uses assembly (AbstractStorage.sol#299-304)\n\t- AbstractStorage.sol#302-303\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 314,
          "vulnerability_to_line": 318,
          "vulnerability_code": "  function put(bytes32 _exec_id, bytes32 _seed, bytes32 _val) internal {\n\n    function (bytes32, bytes32, bytes32) puts;\n\n    assembly { puts := putMap }\n\n    puts(_exec_id, _seed, _val);\n",
          "message": "AbstractStorage.put uses assembly (AbstractStorage.sol#314-318)\n\t- AbstractStorage.sol#316-317\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 327,
          "vulnerability_to_line": 334,
          "vulnerability_code": "  function getSelector(bytes memory _calldata) internal pure returns (bytes4 sel) {\n\n    assembly {\n\n      sel := and(\n\n        mload(add(0x20, _calldata)),\n\n        0xffffffff00000000000000000000000000000000000000000000000000000000\n\n      )\n\n    }\n",
          "message": "AbstractStorage.getSelector uses assembly (AbstractStorage.sol#327-334)\n\t- AbstractStorage.sol#328-334\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 343,
          "vulnerability_to_line": 362,
          "vulnerability_code": "  function getReturnedData() internal pure returns (uint ptr_bounds, uint _returndata_ptr) {\n\n    assembly {\n\n      // returndatasize must be minimum 96 bytes (offset, length, and requestor)\n\n      if lt(returndatasize, 0x60) {\n\n        mstore(0, 0x20)\n\n        mstore(0x20, 24)\n\n        mstore(0x40, 'Insufficient return size')\n\n        revert(0, 0x60)\n\n      }\n\n      // Get memory location to which returndata will be copied\n\n      _returndata_ptr := msize\n\n      // Copy returned data to pointer location\n\n      returndatacopy(_returndata_ptr, 0, returndatasize)\n\n      // Get maximum memory location value for returndata\n\n      ptr_bounds := add(_returndata_ptr, returndatasize)\n\n      // Set new free-memory pointer to point after the returndata in memory\n\n      // Returndata is automatically 32-bytes padded\n\n      mstore(0x40, add(0x20, ptr_bounds))\n\n    }\n",
          "message": "AbstractStorage.getReturnedData uses assembly (AbstractStorage.sol#343-362)\n\t- AbstractStorage.sol#344-362\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 370,
          "vulnerability_to_line": 372,
          "vulnerability_code": "  function getLength(uint _ptr) internal pure returns (uint length) {\n\n    assembly { length := mload(_ptr) }\n",
          "message": "AbstractStorage.getLength uses assembly (AbstractStorage.sol#370-372)\n\t- AbstractStorage.sol#371-372\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 375,
          "vulnerability_to_line": 378,
          "vulnerability_code": "  function doThrow(uint _ptr) internal pure {\n\n    assert(getAction(_ptr) == THROWS);\n\n    assembly { revert(_ptr, returndatasize) }\n",
          "message": "AbstractStorage.doThrow uses assembly (AbstractStorage.sol#375-378)\n\t- AbstractStorage.sol#377-378\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 391,
          "vulnerability_to_line": 422,
          "vulnerability_code": "  function doPay(bytes32 _exec_id, uint _ptr, uint _ptr_bound) internal returns (uint ptr, uint n_paid) {\n\n    // Ensure ETH was sent with the call\n\n    require(msg.value > 0);\n\n    assert(getAction(_ptr) == PAYS);\n\n    _ptr += 4;\n\n    // Get number of destinations\n\n    uint num_destinations = getLength(_ptr);\n\n    _ptr += 32;\n\n    address pay_to;\n\n    uint amt;\n\n    // Loop over PAYS actions and process each one\n\n    while (_ptr <= _ptr_bound && n_paid < num_destinations) {\n\n      // Get the payment destination and amount from the pointer\n\n      assembly {\n\n        amt := mload(_ptr)\n\n        pay_to := mload(add(0x20, _ptr))\n\n      }\n\n      // Invalid address was passed as a payment destination - throw\n\n      if (pay_to == address(0) || pay_to == address(this))\n\n        revert('PAYS: invalid destination');\n\n\n\n      // Forward ETH and increment n_paid\n\n      address(pay_to).transfer(amt);\n\n      n_paid++;\n\n      // Increment pointer\n\n      _ptr += 64;\n\n      // Emit event\n\n      emit DeliveredPayment(_exec_id, pay_to, amt);\n\n    }\n\n    ptr = _ptr;\n\n    assert(n_paid == num_destinations);\n",
          "message": "AbstractStorage.doPay uses assembly (AbstractStorage.sol#391-422)\n\t- AbstractStorage.sol#404-409\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 437,
          "vulnerability_to_line": 460,
          "vulnerability_code": "  function doStore(uint _ptr, uint _ptr_bound, bytes32 _exec_id) internal returns (uint ptr, uint n_stored) {\n\n    assert(getAction(_ptr) == STORES && _exec_id != bytes32(0));\n\n    _ptr += 4;\n\n    // Get number of locations to which data will be stored\n\n    uint num_locations = getLength(_ptr);\n\n    _ptr += 32;\n\n    bytes32 location;\n\n    bytes32 value;\n\n    // Loop over STORES actions and process each one\n\n    while (_ptr <= _ptr_bound && n_stored < num_locations) {\n\n      // Get storage location and value to store from the pointer\n\n      assembly {\n\n        location := mload(_ptr)\n\n        value := mload(add(0x20, _ptr))\n\n      }\n\n      // Store the data to the location hashed with the exec id\n\n      store(_exec_id, location, value);\n\n      // Increment n_stored and pointer\n\n      n_stored++;\n\n      _ptr += 64;\n\n    }\n\n    ptr = _ptr;\n\n    require(n_stored == num_locations);\n",
          "message": "AbstractStorage.doStore uses assembly (AbstractStorage.sol#437-460)\n\t- AbstractStorage.sol#448-453\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 475,
          "vulnerability_to_line": 551,
          "vulnerability_code": "  function doEmit(uint _ptr, uint _ptr_bound) internal returns (uint ptr, uint n_emitted) {\n\n    assert(getAction(_ptr) == EMITS);\n\n    _ptr += 4;\n\n    // Converts number of events that will be emitted\n\n    uint num_events = getLength(_ptr);\n\n    _ptr += 32;\n\n    bytes32[] memory topics;\n\n    bytes memory data;\n\n    // Loop over EMITS actions and process each one\n\n    while (_ptr <= _ptr_bound && n_emitted < num_events) {\n\n      // Get array of topics and additional data from the pointer\n\n      assembly {\n\n        topics := _ptr\n\n        data := add(add(_ptr, 0x20), mul(0x20, mload(topics)))\n\n      }\n\n      // Get size of the Event's data in memory\n\n      uint log_size = 32 + (32 * (1 + topics.length)) + data.length;\n\n      assembly {\n\n        switch mload(topics)                // topics.length\n\n          case 0 {\n\n            // Log Event.data array with no topics\n\n            log0(\n\n              add(0x20, data),              // data(ptr)\n\n              mload(data)                   // data.length\n\n            )\n\n          }\n\n          case 1 {\n\n            // Log Event.data array with 1 topic\n\n            log1(\n\n              add(0x20, data),              // data(ptr)\n\n              mload(data),                  // data.length\n\n              mload(add(0x20, topics))      // topics[0]\n\n            )\n\n          }\n\n          case 2 {\n\n            // Log Event.data array with 2 topics\n\n            log2(\n\n              add(0x20, data),              // data(ptr)\n\n              mload(data),                  // data.length\n\n              mload(add(0x20, topics)),     // topics[0]\n\n              mload(add(0x40, topics))      // topics[1]\n\n            )\n\n          }\n\n          case 3 {\n\n            // Log Event.data array with 3 topics\n\n            log3(\n\n              add(0x20, data),              // data(ptr)\n\n              mload(data),                  // data.length\n\n              mload(add(0x20, topics)),     // topics[0]\n\n              mload(add(0x40, topics)),     // topics[1]\n\n              mload(add(0x60, topics))      // topics[2]\n\n            )\n\n          }\n\n          case 4 {\n\n            // Log Event.data array with 4 topics\n\n            log4(\n\n              add(0x20, data),              // data(ptr)\n\n              mload(data),                  // data.length\n\n              mload(add(0x20, topics)),     // topics[0]\n\n              mload(add(0x40, topics)),     // topics[1]\n\n              mload(add(0x60, topics)),     // topics[2]\n\n              mload(add(0x80, topics))      // topics[3]\n\n            )\n\n          }\n\n          default {\n\n            // Events must have 4 or fewer topics\n\n            mstore(0, 'EMITS: invalid topic count')\n\n            revert(0, 0x20)\n\n          }\n\n      }\n\n      // Event emitted - increment n_emitted and pointer\n\n      n_emitted++;\n\n      _ptr += log_size;\n\n    }\n\n    ptr = _ptr;\n\n    require(n_emitted == num_events);\n",
          "message": "AbstractStorage.doEmit uses assembly (AbstractStorage.sol#475-551)\n\t- AbstractStorage.sol#486-491\n\t- AbstractStorage.sol#492-546\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 554,
          "vulnerability_to_line": 559,
          "vulnerability_code": "  function getAction(uint _ptr) internal pure returns (bytes4 action) {\n\n    assembly {\n\n      // Get the first 4 bytes stored at the pointer, and clean the rest of the bytes remaining\n\n      action := and(mload(_ptr), 0xffffffff00000000000000000000000000000000000000000000000000000000)\n\n    }\n",
          "message": "AbstractStorage.getAction uses assembly (AbstractStorage.sol#554-559)\n\t- AbstractStorage.sol#555-559\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 571,
          "vulnerability_to_line": 576,
          "vulnerability_code": "  function store(bytes32 _exec_id, bytes32 _location, bytes32 _data) internal {\n\n    // Get true location to store data to - hash of location hashed with exec id\n\n    _location = keccak256(_location, _exec_id);\n\n    // Store data at location\n\n    assembly { sstore(_location, _data) }\n",
          "message": "AbstractStorage.store uses assembly (AbstractStorage.sol#571-576)\n\t- AbstractStorage.sol#575-576\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 585,
          "vulnerability_to_line": 588,
          "vulnerability_code": "  function read(bytes32 _exec_id, bytes32 _location) public view returns (bytes32 data_read) {\n\n    _location = keccak256(_location, _exec_id);\n\n    assembly { data_read := sload(_location) }\n",
          "message": "AbstractStorage.read uses assembly (AbstractStorage.sol#585-588)\n\t- AbstractStorage.sol#587-588\n"
        },
        {
          "name": "solc-version",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.23;\n",
          "message": "Detected issues with version pragma in AbstractStorage.sol:\n\t- pragma solidity^0.4.23 (AbstractStorage.sol#3): it allows old versions\n\t- pragma solidity^0.4.23 (AbstractStorage.sol#14): it allows old versions\n"
        },
        {
          "name": "low-level-calls",
          "vulnerability_from_line": 83,
          "vulnerability_to_line": 114,
          "vulnerability_code": "  function createInstance(address _sender, bytes32 _app_name, address _provider, bytes32 _registry_id, bytes _calldata) external payable returns (bytes32 new_exec_id, bytes32 version) {\n\n    // Ensure valid input -\n\n    require(_sender != 0 && _app_name != 0 && _provider != 0 && _registry_id != 0 && _calldata.length >= 4, 'invalid input');\n\n\n\n    // Create new exec id by incrementing the nonce -\n\n    new_exec_id = keccak256(++nonce);\n\n\n\n    // Sanity check - verify that this exec id is not linked to an existing application -\n\n    assert(getIndex(new_exec_id) == address(0));\n\n\n\n    // Set the allowed addresses and selectors for the new instance, from the script registry -\n\n    address index;\n\n    (index, version) = setImplementation(new_exec_id, _app_name, _provider, _registry_id);\n\n\n\n    // Set the exec id and sender addresses for the target application -\n\n    setContext(new_exec_id, _sender);\n\n\n\n    // Execute application, create a new exec id, and commit the returned data to storage -\n\n    require(address(index).delegatecall(_calldata) == false, 'Unsafe execution');\n\n    // Get data returned from call revert and perform requested actions -\n\n    executeAppReturn(new_exec_id);\n\n\n\n    // Emit event\n\n    emit ApplicationInitialized(new_exec_id, index, msg.sender);\n\n\n\n    // If execution reaches this point, newly generated exec id should be valid -\n\n    assert(new_exec_id != bytes32(0));\n\n\n\n    // Ensure that any additional balance is transferred back to the sender -\n\n    if (address(this).balance > 0)\n\n      address(msg.sender).transfer(address(this).balance);\n",
          "message": "Low level call in AbstractStorage.createInstance (AbstractStorage.sol#83-114):\n\t-require(bool,string)(address(index).delegatecall(_calldata) == false,Unsafe execution) AbstractStorage.sol#101\n"
        },
        {
          "name": "low-level-calls",
          "vulnerability_from_line": 127,
          "vulnerability_to_line": 152,
          "vulnerability_code": "  function exec(address _sender, bytes32 _exec_id, bytes _calldata) external payable returns (uint n_emitted, uint n_paid, uint n_stored) {\n\n    // Ensure valid input and input size - minimum 4 bytes\n\n    require(_calldata.length >= 4 && _sender != address(0) && _exec_id != bytes32(0));\n\n\n\n    // Get the target address associated with the given exec id\n\n    address target = getTarget(_exec_id, getSelector(_calldata));\n\n    require(target != address(0), 'Uninitialized application');\n\n\n\n    // Set the exec id and sender addresses for the target application -\n\n    setContext(_exec_id, _sender);\n\n\n\n    // Execute application and commit returned data to storage -\n\n    require(address(target).delegatecall(_calldata) == false, 'Unsafe execution');\n\n    (n_emitted, n_paid, n_stored) = executeAppReturn(_exec_id);\n\n\n\n    // If no events were emitted, no wei was forwarded, and no storage was changed, revert -\n\n    if (n_emitted == 0 && n_paid == 0 && n_stored == 0)\n\n      revert('No state change occured');\n\n\n\n    // Emit event -\n\n    emit ApplicationExecution(_exec_id, target);\n\n\n\n    // Ensure that any additional balance is transferred back to the sender -\n\n    if (address(this).balance > 0)\n\n      address(msg.sender).transfer(address(this).balance);\n",
          "message": "Low level call in AbstractStorage.exec (AbstractStorage.sol#127-152):\n\t-require(bool,string)(address(target).delegatecall(_calldata) == false,Unsafe execution) AbstractStorage.sol#139\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 6,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function getLatestVersion(address stor_addr, bytes32 exec_id, address provider, bytes32 app_name)\n",
          "message": "Parameter 'stor_addr' of RegistryInterface.getLatestVersion (AbstractStorage.sol#6) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 6,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function getLatestVersion(address stor_addr, bytes32 exec_id, address provider, bytes32 app_name)\n",
          "message": "Parameter 'exec_id' of RegistryInterface.getLatestVersion (AbstractStorage.sol#6) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 6,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function getLatestVersion(address stor_addr, bytes32 exec_id, address provider, bytes32 app_name)\n",
          "message": "Parameter 'app_name' of RegistryInterface.getLatestVersion (AbstractStorage.sol#6) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 8,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function getVersionImplementation(address stor_addr, bytes32 exec_id, address provider, bytes32 app_name, bytes32 version_name)\n",
          "message": "Parameter 'stor_addr' of RegistryInterface.getVersionImplementation (AbstractStorage.sol#8) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 8,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function getVersionImplementation(address stor_addr, bytes32 exec_id, address provider, bytes32 app_name, bytes32 version_name)\n",
          "message": "Parameter 'exec_id' of RegistryInterface.getVersionImplementation (AbstractStorage.sol#8) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 8,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function getVersionImplementation(address stor_addr, bytes32 exec_id, address provider, bytes32 app_name, bytes32 version_name)\n",
          "message": "Parameter 'app_name' of RegistryInterface.getVersionImplementation (AbstractStorage.sol#8) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 8,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function getVersionImplementation(address stor_addr, bytes32 exec_id, address provider, bytes32 app_name, bytes32 version_name)\n",
          "message": "Parameter 'version_name' of RegistryInterface.getVersionImplementation (AbstractStorage.sol#8) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 58,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function createRegistry(address _registry_idx, address _implementation) external returns (bytes32) {\n",
          "message": "Parameter '_registry_idx' of AbstractStorage.createRegistry (AbstractStorage.sol#58) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 58,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function createRegistry(address _registry_idx, address _implementation) external returns (bytes32) {\n",
          "message": "Parameter '_implementation' of AbstractStorage.createRegistry (AbstractStorage.sol#58) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 83,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function createInstance(address _sender, bytes32 _app_name, address _provider, bytes32 _registry_id, bytes _calldata) external payable returns (bytes32 new_exec_id, bytes32 version) {\n",
          "message": "Parameter '_sender' of AbstractStorage.createInstance (AbstractStorage.sol#83) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 83,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function createInstance(address _sender, bytes32 _app_name, address _provider, bytes32 _registry_id, bytes _calldata) external payable returns (bytes32 new_exec_id, bytes32 version) {\n",
          "message": "Parameter '_app_name' of AbstractStorage.createInstance (AbstractStorage.sol#83) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 83,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function createInstance(address _sender, bytes32 _app_name, address _provider, bytes32 _registry_id, bytes _calldata) external payable returns (bytes32 new_exec_id, bytes32 version) {\n",
          "message": "Parameter '_provider' of AbstractStorage.createInstance (AbstractStorage.sol#83) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 83,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function createInstance(address _sender, bytes32 _app_name, address _provider, bytes32 _registry_id, bytes _calldata) external payable returns (bytes32 new_exec_id, bytes32 version) {\n",
          "message": "Parameter '_registry_id' of AbstractStorage.createInstance (AbstractStorage.sol#83) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 83,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function createInstance(address _sender, bytes32 _app_name, address _provider, bytes32 _registry_id, bytes _calldata) external payable returns (bytes32 new_exec_id, bytes32 version) {\n",
          "message": "Parameter '_calldata' of AbstractStorage.createInstance (AbstractStorage.sol#83) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 127,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function exec(address _sender, bytes32 _exec_id, bytes _calldata) external payable returns (uint n_emitted, uint n_paid, uint n_stored) {\n",
          "message": "Parameter '_sender' of AbstractStorage.exec (AbstractStorage.sol#127) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 127,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function exec(address _sender, bytes32 _exec_id, bytes _calldata) external payable returns (uint n_emitted, uint n_paid, uint n_stored) {\n",
          "message": "Parameter '_exec_id' of AbstractStorage.exec (AbstractStorage.sol#127) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 127,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function exec(address _sender, bytes32 _exec_id, bytes _calldata) external payable returns (uint n_emitted, uint n_paid, uint n_stored) {\n",
          "message": "Parameter '_calldata' of AbstractStorage.exec (AbstractStorage.sol#127) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 193,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function executeAppReturn(bytes32 _exec_id) internal returns (uint n_emitted, uint n_paid, uint n_stored) {\n",
          "message": "Parameter '_exec_id' of AbstractStorage.executeAppReturn (AbstractStorage.sol#193) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 254,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function setImplementation(bytes32 _new_exec_id, bytes32 _app_name, address _provider, bytes32 _registry_id) internal returns (address index, bytes32 version) {\n",
          "message": "Parameter '_new_exec_id' of AbstractStorage.setImplementation (AbstractStorage.sol#254) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 254,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function setImplementation(bytes32 _new_exec_id, bytes32 _app_name, address _provider, bytes32 _registry_id) internal returns (address index, bytes32 version) {\n",
          "message": "Parameter '_app_name' of AbstractStorage.setImplementation (AbstractStorage.sol#254) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 254,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function setImplementation(bytes32 _new_exec_id, bytes32 _app_name, address _provider, bytes32 _registry_id) internal returns (address index, bytes32 version) {\n",
          "message": "Parameter '_provider' of AbstractStorage.setImplementation (AbstractStorage.sol#254) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 254,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function setImplementation(bytes32 _new_exec_id, bytes32 _app_name, address _provider, bytes32 _registry_id) internal returns (address index, bytes32 version) {\n",
          "message": "Parameter '_registry_id' of AbstractStorage.setImplementation (AbstractStorage.sol#254) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 291,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function getIndex(bytes32 _exec_id) public view returns (address) {\n",
          "message": "Parameter '_exec_id' of AbstractStorage.getIndex (AbstractStorage.sol#291) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 299,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function getTarget(bytes32 _exec_id, bytes4 _selector) public view returns (address) {\n",
          "message": "Parameter '_exec_id' of AbstractStorage.getTarget (AbstractStorage.sol#299) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 299,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function getTarget(bytes32 _exec_id, bytes4 _selector) public view returns (address) {\n",
          "message": "Parameter '_selector' of AbstractStorage.getTarget (AbstractStorage.sol#299) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 309,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function readMap(Map storage _map, bytes32 _seed) internal view returns (bytes32) {\n",
          "message": "Parameter '_map' of AbstractStorage.readMap (AbstractStorage.sol#309) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 309,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function readMap(Map storage _map, bytes32 _seed) internal view returns (bytes32) {\n",
          "message": "Parameter '_seed' of AbstractStorage.readMap (AbstractStorage.sol#309) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 314,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function put(bytes32 _exec_id, bytes32 _seed, bytes32 _val) internal {\n",
          "message": "Parameter '_exec_id' of AbstractStorage.put (AbstractStorage.sol#314) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 314,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function put(bytes32 _exec_id, bytes32 _seed, bytes32 _val) internal {\n",
          "message": "Parameter '_seed' of AbstractStorage.put (AbstractStorage.sol#314) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 314,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function put(bytes32 _exec_id, bytes32 _seed, bytes32 _val) internal {\n",
          "message": "Parameter '_val' of AbstractStorage.put (AbstractStorage.sol#314) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 321,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function putMap(Map storage _map, bytes32 _seed, bytes32 _val) internal {\n",
          "message": "Parameter '_map' of AbstractStorage.putMap (AbstractStorage.sol#321) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 321,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function putMap(Map storage _map, bytes32 _seed, bytes32 _val) internal {\n",
          "message": "Parameter '_seed' of AbstractStorage.putMap (AbstractStorage.sol#321) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 321,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function putMap(Map storage _map, bytes32 _seed, bytes32 _val) internal {\n",
          "message": "Parameter '_val' of AbstractStorage.putMap (AbstractStorage.sol#321) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 375,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function doThrow(uint _ptr) internal pure {\n",
          "message": "Parameter '_ptr' of AbstractStorage.doThrow (AbstractStorage.sol#375) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 391,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function doPay(bytes32 _exec_id, uint _ptr, uint _ptr_bound) internal returns (uint ptr, uint n_paid) {\n",
          "message": "Parameter '_exec_id' of AbstractStorage.doPay (AbstractStorage.sol#391) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 391,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function doPay(bytes32 _exec_id, uint _ptr, uint _ptr_bound) internal returns (uint ptr, uint n_paid) {\n",
          "message": "Parameter '_ptr' of AbstractStorage.doPay (AbstractStorage.sol#391) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 391,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function doPay(bytes32 _exec_id, uint _ptr, uint _ptr_bound) internal returns (uint ptr, uint n_paid) {\n",
          "message": "Parameter '_ptr_bound' of AbstractStorage.doPay (AbstractStorage.sol#391) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 437,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function doStore(uint _ptr, uint _ptr_bound, bytes32 _exec_id) internal returns (uint ptr, uint n_stored) {\n",
          "message": "Parameter '_ptr' of AbstractStorage.doStore (AbstractStorage.sol#437) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 437,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function doStore(uint _ptr, uint _ptr_bound, bytes32 _exec_id) internal returns (uint ptr, uint n_stored) {\n",
          "message": "Parameter '_ptr_bound' of AbstractStorage.doStore (AbstractStorage.sol#437) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 437,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function doStore(uint _ptr, uint _ptr_bound, bytes32 _exec_id) internal returns (uint ptr, uint n_stored) {\n",
          "message": "Parameter '_exec_id' of AbstractStorage.doStore (AbstractStorage.sol#437) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 475,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function doEmit(uint _ptr, uint _ptr_bound) internal returns (uint ptr, uint n_emitted) {\n",
          "message": "Parameter '_ptr' of AbstractStorage.doEmit (AbstractStorage.sol#475) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 475,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function doEmit(uint _ptr, uint _ptr_bound) internal returns (uint ptr, uint n_emitted) {\n",
          "message": "Parameter '_ptr_bound' of AbstractStorage.doEmit (AbstractStorage.sol#475) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 563,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function setContext(bytes32 _exec_id, address _sender) internal {\n",
          "message": "Parameter '_exec_id' of AbstractStorage.setContext (AbstractStorage.sol#563) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 563,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function setContext(bytes32 _exec_id, address _sender) internal {\n",
          "message": "Parameter '_sender' of AbstractStorage.setContext (AbstractStorage.sol#563) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 571,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function store(bytes32 _exec_id, bytes32 _location, bytes32 _data) internal {\n",
          "message": "Parameter '_exec_id' of AbstractStorage.store (AbstractStorage.sol#571) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 571,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function store(bytes32 _exec_id, bytes32 _location, bytes32 _data) internal {\n",
          "message": "Parameter '_location' of AbstractStorage.store (AbstractStorage.sol#571) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 585,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function read(bytes32 _exec_id, bytes32 _location) public view returns (bytes32 data_read) {\n",
          "message": "Parameter '_exec_id' of AbstractStorage.read (AbstractStorage.sol#585) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 585,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function read(bytes32 _exec_id, bytes32 _location) public view returns (bytes32 data_read) {\n",
          "message": "Parameter '_location' of AbstractStorage.read (AbstractStorage.sol#585) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 595,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function readMulti(bytes32 _exec_id, bytes32[] _locations) public view returns (bytes32[] data_read) {\n",
          "message": "Parameter '_exec_id' of AbstractStorage.readMulti (AbstractStorage.sol#595) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 595,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function readMulti(bytes32 _exec_id, bytes32[] _locations) public view returns (bytes32[] data_read) {\n",
          "message": "Parameter '_locations' of AbstractStorage.readMulti (AbstractStorage.sol#595) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 20,
          "vulnerability_to_line": null,
          "vulnerability_code": "  bytes32 private exec_id;\n",
          "message": "Variable 'AbstractStorage.exec_id' (AbstractStorage.sol#20) is not in mixedCase\n"
        }
      ]
    },
    "smartcheck": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 280,
          "vulnerability_to_line": null,
          "vulnerability_code": "    for (uint i = 0; i < selectors.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 597,
          "vulnerability_to_line": null,
          "vulnerability_code": "    for (uint i = 0; i < _locations.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
          "vulnerability_from_line": 327,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function getSelector(bytes memory _calldata) internal pure returns (bytes4 sel) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
          "vulnerability_from_line": 343,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function getReturnedData() internal pure returns (uint ptr_bounds, uint _returndata_ptr) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
          "vulnerability_from_line": 370,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function getLength(uint _ptr) internal pure returns (uint length) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
          "vulnerability_from_line": 391,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function doPay(bytes32 _exec_id, uint _ptr, uint _ptr_bound) internal returns (uint ptr, uint n_paid) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
          "vulnerability_from_line": 437,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function doStore(uint _ptr, uint _ptr_bound, bytes32 _exec_id) internal returns (uint ptr, uint n_stored) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
          "vulnerability_from_line": 475,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function doEmit(uint _ptr, uint _ptr_bound) internal returns (uint ptr, uint n_emitted) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
          "vulnerability_from_line": 554,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function getAction(uint _ptr) internal pure returns (bytes4 action) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
          "vulnerability_from_line": 585,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function read(bytes32 _exec_id, bytes32 _location) public view returns (bytes32 data_read) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 280,
          "vulnerability_to_line": null,
          "vulnerability_code": "    for (uint i = 0; i < selectors.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 597,
          "vulnerability_to_line": null,
          "vulnerability_code": "    for (uint i = 0; i < _locations.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 402,
          "vulnerability_to_line": null,
          "vulnerability_code": "    while (_ptr <= _ptr_bound && n_paid < num_destinations) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 446,
          "vulnerability_to_line": null,
          "vulnerability_code": "    while (_ptr <= _ptr_bound && n_stored < num_locations) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 484,
          "vulnerability_to_line": null,
          "vulnerability_code": "    while (_ptr <= _ptr_bound && n_emitted < num_events) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 211,
          "vulnerability_to_line": null,
          "vulnerability_code": "    while (_ptr <= ptr_bound && (action = getAction(_ptr)) != 0x0) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.23;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 14,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.23;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 20,
          "vulnerability_to_line": null,
          "vulnerability_code": "  bytes32 private exec_id;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 21,
          "vulnerability_to_line": null,
          "vulnerability_code": "  address private sender;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 24,
          "vulnerability_to_line": null,
          "vulnerability_code": "  uint private nonce;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_REVERT_REQUIRE",
          "vulnerability_from_line": 143,
          "vulnerability_to_line": null,
          "vulnerability_code": "    if (n_emitted == 0 && n_paid == 0 && n_stored == 0)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_REVERT_REQUIRE",
          "vulnerability_from_line": 228,
          "vulnerability_to_line": null,
          "vulnerability_code": "      } else if (action == PAYS) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_REVERT_REQUIRE",
          "vulnerability_from_line": 409,
          "vulnerability_to_line": null,
          "vulnerability_code": "      if (pay_to == address(0) || pay_to == address(this))\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 327,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function getSelector(bytes memory _calldata) internal pure returns (bytes4 sel) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 343,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function getReturnedData() internal pure returns (uint ptr_bounds, uint _returndata_ptr) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 370,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function getLength(uint _ptr) internal pure returns (uint length) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 375,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function doThrow(uint _ptr) internal pure {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 554,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function getAction(uint _ptr) internal pure returns (bytes4 action) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
          "vulnerability_from_line": 291,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function getIndex(bytes32 _exec_id) public view returns (address) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
          "vulnerability_from_line": 299,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function getTarget(bytes32 _exec_id, bytes4 _selector) public view returns (address) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
          "vulnerability_from_line": 585,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function read(bytes32 _exec_id, bytes32 _location) public view returns (bytes32 data_read) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 193,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function executeAppReturn(bytes32 _exec_id) internal returns (uint n_emitted, uint n_paid, uint n_stored) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 254,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function setImplementation(bytes32 _new_exec_id, bytes32 _app_name, address _provider, bytes32 _registry_id) internal returns (address index, bytes32 version) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 343,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function getReturnedData() internal pure returns (uint ptr_bounds, uint _returndata_ptr) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 391,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function doPay(bytes32 _exec_id, uint _ptr, uint _ptr_bound) internal returns (uint ptr, uint n_paid) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 437,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function doStore(uint _ptr, uint _ptr_bound, bytes32 _exec_id) internal returns (uint ptr, uint n_stored) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 475,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function doEmit(uint _ptr, uint _ptr_bound) internal returns (uint ptr, uint n_emitted) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_TRANSFER_IN_LOOP",
          "vulnerability_from_line": 402,
          "vulnerability_to_line": null,
          "vulnerability_code": "    while (_ptr <= _ptr_bound && n_paid < num_destinations) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 60,
          "vulnerability_to_line": null,
          "vulnerability_code": "    put(new_exec_id, keccak256(msg.sender, EXEC_PERMISSIONS), bytes32(1));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 62,
          "vulnerability_to_line": null,
          "vulnerability_code": "    put(new_exec_id, keccak256(REG_APP, 'implementation'), bytes32(_implementation));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 63,
          "vulnerability_to_line": null,
          "vulnerability_code": "    put(new_exec_id, keccak256(REG_APP_VER, 'implementation'), bytes32(_implementation));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 64,
          "vulnerability_to_line": null,
          "vulnerability_code": "    put(new_exec_id, keccak256(UPDATE_INST_SEL, 'implementation'), bytes32(_implementation));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 65,
          "vulnerability_to_line": null,
          "vulnerability_code": "    put(new_exec_id, keccak256(UPDATE_EXEC_SEL, 'implementation'), bytes32(_implementation));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 282,
          "vulnerability_to_line": null,
          "vulnerability_code": "      seed = keccak256(selectors[i], 'implementation');\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 300,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bytes32 seed = keccak256(_selector, 'implementation');\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 573,
          "vulnerability_to_line": null,
          "vulnerability_code": "    _location = keccak256(_location, _exec_id);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 586,
          "vulnerability_to_line": null,
          "vulnerability_code": "    _location = keccak256(_location, _exec_id);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 595,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function readMulti(bytes32 _exec_id, bytes32[] _locations) public view returns (bytes32[] data_read) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 595,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function readMulti(bytes32 _exec_id, bytes32[] _locations) public view returns (bytes32[] data_read) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 294,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly { getter := readMap }\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 302,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly { getter := readMap }\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 316,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly { puts := putMap }\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 328,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 344,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 371,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly { length := mload(_ptr) }\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 377,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly { revert(_ptr, returndatasize) }\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 404,
          "vulnerability_to_line": null,
          "vulnerability_code": "      assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 448,
          "vulnerability_to_line": null,
          "vulnerability_code": "      assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 486,
          "vulnerability_to_line": null,
          "vulnerability_code": "      assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 492,
          "vulnerability_to_line": null,
          "vulnerability_code": "      assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 555,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 575,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly { sstore(_location, _data) }\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 587,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly { data_read := sload(_location) }\n",
          "message": null
        }
      ]
    },
    "oyente": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "Integer Overflow",
          "vulnerability_from_line": 59,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bytes32 new_exec_id = keccak256(++nonce);\n",
          "message": null
        }
      ]
    },
    "mythril": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": []
    },
    "osiris": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "Overflow bugs",
          "vulnerability_from_line": 59,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bytes32 new_exec_id = keccak256(++nonce);\n",
          "message": null
        },
        {
          "name": "Overflow bugs",
          "vulnerability_from_line": 88,
          "vulnerability_to_line": null,
          "vulnerability_code": "    new_exec_id = keccak256(++nonce);\n",
          "message": null
        }
      ]
    }
  }
}