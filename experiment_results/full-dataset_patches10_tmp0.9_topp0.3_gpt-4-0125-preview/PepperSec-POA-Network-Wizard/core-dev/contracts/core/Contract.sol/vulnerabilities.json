{
  "smartbugs_completed": true,
  "analyzer_results": {
    "semgrep": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 15,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require(c / a == b, \"Overflow - Multiplication\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 30,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require(b <= a, \"Underflow - Subtraction\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 39,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require(c >= a, \"Overflow - Addition\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 90,
          "vulnerability_to_line": null,
          "vulnerability_code": "      revert(\"Sender is not authorized as a script exec address\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 105,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require(freeMem() == 0x80, \"Memory allocated prior to execution\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 141,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require(ptr >= 0x180, \"Invalid buffer pointer\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 157,
          "vulnerability_to_line": null,
          "vulnerability_code": "      revert('Expected Contract.execute()');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 160,
          "vulnerability_to_line": null,
          "vulnerability_code": "      revert('Invalid buffer pointer');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 186,
          "vulnerability_to_line": null,
          "vulnerability_code": "      revert('Invalid current action - expected STORES');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 192,
          "vulnerability_to_line": null,
          "vulnerability_code": "      revert('Invalid current action - expected EMITS');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 198,
          "vulnerability_to_line": null,
          "vulnerability_code": "      revert('Invalid current action - expected PAYS');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 226,
          "vulnerability_to_line": null,
          "vulnerability_code": "      revert('Duplicate request - stores');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 238,
          "vulnerability_to_line": null,
          "vulnerability_code": "      revert('Duplicate request - emits');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 250,
          "vulnerability_to_line": null,
          "vulnerability_code": "      revert('Duplicate request - pays');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 261,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require(exec_id != bytes32(0), \"Execution id overwritten, or not read\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 267,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require(addr != address(0), \"Sender address overwritten, or not read\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 295,
          "vulnerability_to_line": null,
          "vulnerability_code": "      revert('Unexpected function order - expected storage destination to be pushed');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 308,
          "vulnerability_to_line": null,
          "vulnerability_code": "    ) revert('Unexpected function order - expected storage value to be pushed');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 318,
          "vulnerability_to_line": null,
          "vulnerability_code": "      revert('Unexpected function order - expected payment destination to be pushed');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 328,
          "vulnerability_to_line": null,
          "vulnerability_code": "      revert('Unexpected function order - expected payment amount to be pushed');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 338,
          "vulnerability_to_line": null,
          "vulnerability_code": "      revert('Unexpected function order - expected event to be pushed');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 486,
          "vulnerability_to_line": null,
          "vulnerability_code": "      revert('Expected VAL_INC or VAL_DEC');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 512,
          "vulnerability_to_line": null,
          "vulnerability_code": "      revert('Expected VAL_DEC');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 159,
          "vulnerability_to_line": null,
          "vulnerability_code": "    if (buffPtr() != 0 && buffPtr() < 0x180)\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 160,
          "vulnerability_to_line": null,
          "vulnerability_code": "      revert('Invalid buffer pointer');\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 304,
          "vulnerability_to_line": null,
          "vulnerability_code": "    if (\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 305,
          "vulnerability_to_line": null,
          "vulnerability_code": "      expected() != NextFunction.VAL_SET &&\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 306,
          "vulnerability_to_line": null,
          "vulnerability_code": "      expected() != NextFunction.VAL_INC &&\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 307,
          "vulnerability_to_line": null,
          "vulnerability_code": "      expected() != NextFunction.VAL_DEC\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 308,
          "vulnerability_to_line": null,
          "vulnerability_code": "    ) revert('Unexpected function order - expected storage value to be pushed');\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 90,
          "vulnerability_to_line": null,
          "vulnerability_code": "      revert(\"Sender is not authorized as a script exec address\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 105,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require(freeMem() == 0x80, \"Memory allocated prior to execution\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 186,
          "vulnerability_to_line": null,
          "vulnerability_code": "      revert('Invalid current action - expected STORES');\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 192,
          "vulnerability_to_line": null,
          "vulnerability_code": "      revert('Invalid current action - expected EMITS');\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 198,
          "vulnerability_to_line": null,
          "vulnerability_code": "      revert('Invalid current action - expected PAYS');\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 261,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require(exec_id != bytes32(0), \"Execution id overwritten, or not read\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 267,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require(addr != address(0), \"Sender address overwritten, or not read\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 295,
          "vulnerability_to_line": null,
          "vulnerability_code": "      revert('Unexpected function order - expected storage destination to be pushed');\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 308,
          "vulnerability_to_line": null,
          "vulnerability_code": "    ) revert('Unexpected function order - expected storage value to be pushed');\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 318,
          "vulnerability_to_line": null,
          "vulnerability_code": "      revert('Unexpected function order - expected payment destination to be pushed');\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 328,
          "vulnerability_to_line": null,
          "vulnerability_code": "      revert('Unexpected function order - expected payment amount to be pushed');\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 338,
          "vulnerability_to_line": null,
          "vulnerability_code": "      revert('Unexpected function order - expected event to be pushed');\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        }
      ]
    },
    "slither": {
      "successfull_analysis": true,
      "errors": [
        "EXIT_CODE_83"
      ],
      "vulnerability_findings": [
        {
          "name": "constant-function",
          "vulnerability_from_line": 71,
          "vulnerability_to_line": 91,
          "vulnerability_code": "  function authorize(address _script_exec) internal view {\n\n    // Initialize memory\n\n    initialize();\n\n\n\n    // Check that the sender is authorized as a script exec contract for this exec id\n\n    bytes32 perms = EXEC_PERMISSIONS;\n\n    bool authorized;\n\n    assembly {\n\n      // Place the script exec address at 0, and the exec permissions seed after it\n\n      mstore(0, _script_exec)\n\n      mstore(0x20, perms)\n\n      // Hash the resulting 0x34 bytes, and place back into memory at 0\n\n      mstore(0, keccak256(0x0c, 0x34))\n\n      // Place the exec id after the hash -\n\n      mstore(0x20, mload(0x80))\n\n      // Hash the previous hash with the execution id, and check the result\n\n      authorized := sload(keccak256(0, 0x40))\n\n    }\n\n    if (!authorized)\n\n      revert(\"Sender is not authorized as a script exec address\");\n",
          "message": "Contract.authorize (Contract.sol#71-91) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 102,
          "vulnerability_to_line": 122,
          "vulnerability_code": "  function initialize() internal view {\n\n    // No memory should have been allocated yet - expect the free memory pointer\n\n    // to point to 0x80 - and throw if it does not\n\n    require(freeMem() == 0x80, \"Memory allocated prior to execution\");\n\n    // Next, set up memory for execution\n\n    assembly {\n\n      mstore(0x80, sload(0))     // Execution id, read from storage\n\n      mstore(0xa0, sload(1))     // Original sender address, read from storage\n\n      mstore(0xc0, 0)            // Pointer to storage buffer\n\n      mstore(0xe0, 0)            // Bytes4 value of the current action requestor being used\n\n      mstore(0x100, 0)           // Enum representing the next type of function to be called (when pushing to buffer)\n\n      mstore(0x120, 0)           // Number of storage slots written to in buffer\n\n      mstore(0x140, 0)           // Number of events pushed to buffer\n\n      mstore(0x160, 0)           // Number of payment destinations pushed to buffer\n\n\n\n      // Update free memory pointer -\n\n      mstore(0x40, 0x180)\n\n    }\n\n    // Ensure that the sender and execution id returned from storage are expected values -\n\n    assert(execID() != bytes32(0) && sender() != address(0));\n",
          "message": "Contract.initialize (Contract.sol#102-122) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 138,
          "vulnerability_to_line": 150,
          "vulnerability_code": "  function commit() conditions(validState, none) internal pure {\n\n    // Check value of storage buffer pointer - should be at least 0x180\n\n    bytes32 ptr = buffPtr();\n\n    require(ptr >= 0x180, \"Invalid buffer pointer\");\n\n\n\n    assembly {\n\n      // Get the size of the buffer\n\n      let size := mload(add(0x20, ptr))\n\n      mstore(ptr, 0x20) // Place dynamic data offset before buffer\n\n      // Revert to storage\n\n      revert(ptr, add(0x40, size))\n\n    }\n",
          "message": "Contract.commit (Contract.sol#138-150) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 166,
          "vulnerability_to_line": 168,
          "vulnerability_code": "  function buffPtr() private pure returns (bytes32 ptr) {\n\n    assembly { ptr := mload(0xc0) }\n",
          "message": "Contract.buffPtr (Contract.sol#166-168) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 171,
          "vulnerability_to_line": 173,
          "vulnerability_code": "  function freeMem() private pure returns (bytes32 ptr) {\n\n    assembly { ptr := mload(0x40) }\n",
          "message": "Contract.freeMem (Contract.sol#171-173) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 176,
          "vulnerability_to_line": 181,
          "vulnerability_code": "  function currentAction() private pure returns (bytes4 action) {\n\n    if (buffPtr() == bytes32(0))\n\n      return bytes4(0);\n\n\n\n    assembly { action := mload(0xe0) }\n",
          "message": "Contract.currentAction (Contract.sol#176-181) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 202,
          "vulnerability_to_line": 215,
          "vulnerability_code": "  function startBuffer() private pure {\n\n    assembly {\n\n      // Get a pointer to free memory, and place at 0xc0 (storage buffer pointer)\n\n      let ptr := msize()\n\n      mstore(0xc0, ptr)\n\n      // Clear bytes at pointer -\n\n      mstore(ptr, 0)            // temp ptr\n\n      mstore(add(0x20, ptr), 0) // buffer length\n\n      // Update free memory pointer -\n\n      mstore(0x40, add(0x40, ptr))\n\n      // Set expected next function to 'NONE' -\n\n      mstore(0x100, 1)\n\n    }\n",
          "message": "Contract.startBuffer (Contract.sol#202-215) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 259,
          "vulnerability_to_line": 262,
          "vulnerability_code": "  function execID() internal pure returns (bytes32 exec_id) {\n\n    assembly { exec_id := mload(0x80) }\n\n    require(exec_id != bytes32(0), \"Execution id overwritten, or not read\");\n",
          "message": "Contract.execID (Contract.sol#259-262) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 265,
          "vulnerability_to_line": 268,
          "vulnerability_code": "  function sender() internal pure returns (address addr) {\n\n    assembly { addr := mload(0xa0) }\n\n    require(addr != address(0), \"Sender address overwritten, or not read\");\n",
          "message": "Contract.sender (Contract.sol#265-268) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 274,
          "vulnerability_to_line": 277,
          "vulnerability_code": "  function read(bytes32 _location) internal view returns (bytes32 data) {\n\n    data = keccak256(_location, execID());\n\n    assembly { data := sload(data) }\n",
          "message": "Contract.read (Contract.sol#274-277) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 346,
          "vulnerability_to_line": 366,
          "vulnerability_code": "  function storing() conditions(validStoreBuff, isStoring) internal pure {\n\n    bytes4 action_req = STORES;\n\n    assembly {\n\n      // Get pointer to buffer length -\n\n      let ptr := add(0x20, mload(0xc0))\n\n      // Push requestor to the end of buffer, as well as to the 'current action' slot -\n\n      mstore(add(0x20, add(ptr, mload(ptr))), action_req)\n\n      // Push '0' to the end of the 4 bytes just pushed - this will be the length of the STORES action\n\n      mstore(add(0x24, add(ptr, mload(ptr))), 0)\n\n      // Increment buffer length - 0x24 plus the previous length\n\n      mstore(ptr, add(0x24, mload(ptr)))\n\n      // Set the current action being executed (STORES) -\n\n      mstore(0xe0, action_req)\n\n      // Set the expected next function - STORE_DEST\n\n      mstore(0x100, 2)\n\n      // Set a pointer to the length of the current request within the buffer\n\n      mstore(sub(ptr, 0x20), add(ptr, mload(ptr)))\n\n    }\n\n    // Update free memory pointer\n\n    setFreeMem();\n",
          "message": "Contract.storing (Contract.sol#346-366) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 369,
          "vulnerability_to_line": 390,
          "vulnerability_code": "  function set(bytes32 _field) conditions(validStoreDest, validStoreVal) internal pure returns (bytes32) {\n\n    assembly {\n\n      // Get pointer to buffer length -\n\n      let ptr := add(0x20, mload(0xc0))\n\n      // Push storage destination to the end of the buffer -\n\n      mstore(add(0x20, add(ptr, mload(ptr))), _field)\n\n      // Increment buffer length - 0x20 plus the previous length\n\n      mstore(ptr, add(0x20, mload(ptr)))\n\n      // Set the expected next function - VAL_SET\n\n      mstore(0x100, 3)\n\n      // Increment STORES action length -\n\n      mstore(\n\n        mload(sub(ptr, 0x20)),\n\n        add(1, mload(mload(sub(ptr, 0x20))))\n\n      )\n\n      // Update number of storage slots pushed to -\n\n      mstore(0x120, add(1, mload(0x120)))\n\n    }\n\n    // Update free memory pointer\n\n    setFreeMem();\n\n    return _field;\n",
          "message": "Contract.set (Contract.sol#369-390) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 393,
          "vulnerability_to_line": 406,
          "vulnerability_code": "  function to(bytes32, bytes32 _val) conditions(validStoreVal, validStoreDest) internal pure {\n\n    assembly {\n\n      // Get pointer to buffer length -\n\n      let ptr := add(0x20, mload(0xc0))\n\n      // Push storage value to the end of the buffer -\n\n      mstore(add(0x20, add(ptr, mload(ptr))), _val)\n\n      // Increment buffer length - 0x20 plus the previous length\n\n      mstore(ptr, add(0x20, mload(ptr)))\n\n      // Set the expected next function - STORE_DEST\n\n      mstore(0x100, 2)\n\n    }\n\n    // Update free memory pointer\n\n    setFreeMem();\n",
          "message": "Contract.to (Contract.sol#393-406) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 426,
          "vulnerability_to_line": 450,
          "vulnerability_code": "  function increase(bytes32 _field) conditions(validStoreDest, validStoreVal) internal view returns (bytes32 val) {\n\n    // Read value stored at the location in storage -\n\n    val = keccak256(_field, execID());\n\n    assembly {\n\n      val := sload(val)\n\n      // Get pointer to buffer length -\n\n      let ptr := add(0x20, mload(0xc0))\n\n      // Push storage destination to the end of the buffer -\n\n      mstore(add(0x20, add(ptr, mload(ptr))), _field)\n\n      // Increment buffer length - 0x20 plus the previous length\n\n      mstore(ptr, add(0x20, mload(ptr)))\n\n      // Set the expected next function - VAL_INC\n\n      mstore(0x100, 4)\n\n      // Increment STORES action length -\n\n      mstore(\n\n        mload(sub(ptr, 0x20)),\n\n        add(1, mload(mload(sub(ptr, 0x20))))\n\n      )\n\n      // Update number of storage slots pushed to -\n\n      mstore(0x120, add(1, mload(0x120)))\n\n    }\n\n    // Update free memory pointer\n\n    setFreeMem();\n\n    return val;\n",
          "message": "Contract.increase (Contract.sol#426-450) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 452,
          "vulnerability_to_line": 476,
          "vulnerability_code": "  function decrease(bytes32 _field) conditions(validStoreDest, validStoreVal) internal view returns (bytes32 val) {\n\n    // Read value stored at the location in storage -\n\n    val = keccak256(_field, execID());\n\n    assembly {\n\n      val := sload(val)\n\n      // Get pointer to buffer length -\n\n      let ptr := add(0x20, mload(0xc0))\n\n      // Push storage destination to the end of the buffer -\n\n      mstore(add(0x20, add(ptr, mload(ptr))), _field)\n\n      // Increment buffer length - 0x20 plus the previous length\n\n      mstore(ptr, add(0x20, mload(ptr)))\n\n      // Set the expected next function - VAL_DEC\n\n      mstore(0x100, 5)\n\n      // Increment STORES action length -\n\n      mstore(\n\n        mload(sub(ptr, 0x20)),\n\n        add(1, mload(mload(sub(ptr, 0x20))))\n\n      )\n\n      // Update number of storage slots pushed to -\n\n      mstore(0x120, add(1, mload(0x120)))\n\n    }\n\n    // Update free memory pointer\n\n    setFreeMem();\n\n    return val;\n",
          "message": "Contract.decrease (Contract.sol#452-476) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 478,
          "vulnerability_to_line": 500,
          "vulnerability_code": "  function by(bytes32 _val, uint _amt) conditions(validStoreVal, validStoreDest) internal pure {\n\n    // Check the expected function type - if it is VAL_INC, perform safe-add on the value\n\n    // If it is VAL_DEC, perform safe-sub on the value\n\n    if (expected() == NextFunction.VAL_INC)\n\n      _amt = _amt.add(uint(_val));\n\n    else if (expected() == NextFunction.VAL_DEC)\n\n      _amt = uint(_val).sub(_amt);\n\n    else\n\n      revert('Expected VAL_INC or VAL_DEC');\n\n\n\n    assembly {\n\n      // Get pointer to buffer length -\n\n      let ptr := add(0x20, mload(0xc0))\n\n      // Push storage value to the end of the buffer -\n\n      mstore(add(0x20, add(ptr, mload(ptr))), _amt)\n\n      // Increment buffer length - 0x20 plus the previous length\n\n      mstore(ptr, add(0x20, mload(ptr)))\n\n      // Set the expected next function - STORE_DEST\n\n      mstore(0x100, 2)\n\n    }\n\n    // Update free memory pointer\n\n    setFreeMem();\n",
          "message": "Contract.by (Contract.sol#478-500) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 503,
          "vulnerability_to_line": 527,
          "vulnerability_code": "  function byMaximum(bytes32 _val, uint _amt) conditions(validStoreVal, validStoreDest) internal pure {\n\n    // Check the expected function type - if it is VAL_DEC, set the new amount to the difference of\n\n    // _val and _amt, to a minimum of 0\n\n    if (expected() == NextFunction.VAL_DEC) {\n\n      if (_amt >= uint(_val))\n\n        _amt = 0;\n\n      else\n\n        _amt = uint(_val).sub(_amt);\n\n    } else {\n\n      revert('Expected VAL_DEC');\n\n    }\n\n\n\n    assembly {\n\n      // Get pointer to buffer length -\n\n      let ptr := add(0x20, mload(0xc0))\n\n      // Push storage value to the end of the buffer -\n\n      mstore(add(0x20, add(ptr, mload(ptr))), _amt)\n\n      // Increment buffer length - 0x20 plus the previous length\n\n      mstore(ptr, add(0x20, mload(ptr)))\n\n      // Set the expected next function - STORE_DEST\n\n      mstore(0x100, 2)\n\n    }\n\n    // Update free memory pointer\n\n    setFreeMem();\n",
          "message": "Contract.byMaximum (Contract.sol#503-527) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 531,
          "vulnerability_to_line": 551,
          "vulnerability_code": "  function emitting() conditions(validEmitBuff, isEmitting) internal pure {\n\n    bytes4 action_req = EMITS;\n\n    assembly {\n\n      // Get pointer to buffer length -\n\n      let ptr := add(0x20, mload(0xc0))\n\n      // Push requestor to the end of buffer, as well as to the 'current action' slot -\n\n      mstore(add(0x20, add(ptr, mload(ptr))), action_req)\n\n      // Push '0' to the end of the 4 bytes just pushed - this will be the length of the EMITS action\n\n      mstore(add(0x24, add(ptr, mload(ptr))), 0)\n\n      // Increment buffer length - 0x24 plus the previous length\n\n      mstore(ptr, add(0x24, mload(ptr)))\n\n      // Set the current action being executed (EMITS) -\n\n      mstore(0xe0, action_req)\n\n      // Set the expected next function - EMIT_LOG\n\n      mstore(0x100, 6)\n\n      // Set a pointer to the length of the current request within the buffer\n\n      mstore(sub(ptr, 0x20), add(ptr, mload(ptr)))\n\n    }\n\n    // Update free memory pointer\n\n    setFreeMem();\n",
          "message": "Contract.emitting (Contract.sol#531-551) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 553,
          "vulnerability_to_line": 584,
          "vulnerability_code": "  function log(bytes32 _data) conditions(validEvent, validEvent) internal pure {\n\n    assembly {\n\n      // Get pointer to buffer length -\n\n      let ptr := add(0x20, mload(0xc0))\n\n      // Push 0 to the end of the buffer - event will have 0 topics\n\n      mstore(add(0x20, add(ptr, mload(ptr))), 0)\n\n      // If _data is zero, set data size to 0 in buffer and push -\n\n      if eq(_data, 0) {\n\n        mstore(add(0x40, add(ptr, mload(ptr))), 0)\n\n        // Increment buffer length - 0x40 plus the original length\n\n        mstore(ptr, add(0x40, mload(ptr)))\n\n      }\n\n      // If _data is not zero, set size to 0x20 and push to buffer -\n\n      if iszero(eq(_data, 0)) {\n\n        // Push data size (0x20) to the end of the buffer\n\n        mstore(add(0x40, add(ptr, mload(ptr))), 0x20)\n\n        // Push data to the end of the buffer\n\n        mstore(add(0x60, add(ptr, mload(ptr))), _data)\n\n        // Increment buffer length - 0x60 plus the original length\n\n        mstore(ptr, add(0x60, mload(ptr)))\n\n      }\n\n      // Increment EMITS action length -\n\n      mstore(\n\n        mload(sub(ptr, 0x20)),\n\n        add(1, mload(mload(sub(ptr, 0x20))))\n\n      )\n\n      // Update number of events pushed to buffer -\n\n      mstore(0x140, add(1, mload(0x140)))\n\n    }\n\n    // Update free memory pointer\n\n    setFreeMem();\n",
          "message": "Contract.log (Contract.sol#553-584) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 586,
          "vulnerability_to_line": 619,
          "vulnerability_code": "  function log(bytes32[1] memory _topics, bytes32 _data) conditions(validEvent, validEvent) internal pure {\n\n    assembly {\n\n      // Get pointer to buffer length -\n\n      let ptr := add(0x20, mload(0xc0))\n\n      // Push 1 to the end of the buffer - event will have 1 topic\n\n      mstore(add(0x20, add(ptr, mload(ptr))), 1)\n\n      // Push topic to end of buffer\n\n      mstore(add(0x40, add(ptr, mload(ptr))), mload(_topics))\n\n      // If _data is zero, set data size to 0 in buffer and push -\n\n      if eq(_data, 0) {\n\n        mstore(add(0x60, add(ptr, mload(ptr))), 0)\n\n        // Increment buffer length - 0x60 plus the original length\n\n        mstore(ptr, add(0x60, mload(ptr)))\n\n      }\n\n      // If _data is not zero, set size to 0x20 and push to buffer -\n\n      if iszero(eq(_data, 0)) {\n\n        // Push data size (0x20) to the end of the buffer\n\n        mstore(add(0x60, add(ptr, mload(ptr))), 0x20)\n\n        // Push data to the end of the buffer\n\n        mstore(add(0x80, add(ptr, mload(ptr))), _data)\n\n        // Increment buffer length - 0x80 plus the original length\n\n        mstore(ptr, add(0x80, mload(ptr)))\n\n      }\n\n      // Increment EMITS action length -\n\n      mstore(\n\n        mload(sub(ptr, 0x20)),\n\n        add(1, mload(mload(sub(ptr, 0x20))))\n\n      )\n\n      // Update number of events pushed to buffer -\n\n      mstore(0x140, add(1, mload(0x140)))\n\n    }\n\n    // Update free memory pointer\n\n    setFreeMem();\n",
          "message": "Contract.log (Contract.sol#586-619) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 621,
          "vulnerability_to_line": 655,
          "vulnerability_code": "  function log(bytes32[2] memory _topics, bytes32 _data) conditions(validEvent, validEvent) internal pure {\n\n    assembly {\n\n      // Get pointer to buffer length -\n\n      let ptr := add(0x20, mload(0xc0))\n\n      // Push 2 to the end of the buffer - event will have 2 topics\n\n      mstore(add(0x20, add(ptr, mload(ptr))), 2)\n\n      // Push topics to end of buffer\n\n      mstore(add(0x40, add(ptr, mload(ptr))), mload(_topics))\n\n      mstore(add(0x60, add(ptr, mload(ptr))), mload(add(0x20, _topics)))\n\n      // If _data is zero, set data size to 0 in buffer and push -\n\n      if eq(_data, 0) {\n\n        mstore(add(0x80, add(ptr, mload(ptr))), 0)\n\n        // Increment buffer length - 0x80 plus the original length\n\n        mstore(ptr, add(0x80, mload(ptr)))\n\n      }\n\n      // If _data is not zero, set size to 0x20 and push to buffer -\n\n      if iszero(eq(_data, 0)) {\n\n        // Push data size (0x20) to the end of the buffer\n\n        mstore(add(0x80, add(ptr, mload(ptr))), 0x20)\n\n        // Push data to the end of the buffer\n\n        mstore(add(0xa0, add(ptr, mload(ptr))), _data)\n\n        // Increment buffer length - 0xa0 plus the original length\n\n        mstore(ptr, add(0xa0, mload(ptr)))\n\n      }\n\n      // Increment EMITS action length -\n\n      mstore(\n\n        mload(sub(ptr, 0x20)),\n\n        add(1, mload(mload(sub(ptr, 0x20))))\n\n      )\n\n      // Update number of events pushed to buffer -\n\n      mstore(0x140, add(1, mload(0x140)))\n\n    }\n\n    // Update free memory pointer\n\n    setFreeMem();\n",
          "message": "Contract.log (Contract.sol#621-655) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 657,
          "vulnerability_to_line": 692,
          "vulnerability_code": "  function log(bytes32[3] memory _topics, bytes32 _data) conditions(validEvent, validEvent) internal pure {\n\n    assembly {\n\n      // Get pointer to buffer length -\n\n      let ptr := add(0x20, mload(0xc0))\n\n      // Push 3 to the end of the buffer - event will have 3 topics\n\n      mstore(add(0x20, add(ptr, mload(ptr))), 3)\n\n      // Push topics to end of buffer\n\n      mstore(add(0x40, add(ptr, mload(ptr))), mload(_topics))\n\n      mstore(add(0x60, add(ptr, mload(ptr))), mload(add(0x20, _topics)))\n\n      mstore(add(0x80, add(ptr, mload(ptr))), mload(add(0x40, _topics)))\n\n      // If _data is zero, set data size to 0 in buffer and push -\n\n      if eq(_data, 0) {\n\n        mstore(add(0xa0, add(ptr, mload(ptr))), 0)\n\n        // Increment buffer length - 0xa0 plus the original length\n\n        mstore(ptr, add(0xa0, mload(ptr)))\n\n      }\n\n      // If _data is not zero, set size to 0x20 and push to buffer -\n\n      if iszero(eq(_data, 0)) {\n\n        // Push data size (0x20) to the end of the buffer\n\n        mstore(add(0xa0, add(ptr, mload(ptr))), 0x20)\n\n        // Push data to the end of the buffer\n\n        mstore(add(0xc0, add(ptr, mload(ptr))), _data)\n\n        // Increment buffer length - 0xc0 plus the original length\n\n        mstore(ptr, add(0xc0, mload(ptr)))\n\n      }\n\n      // Increment EMITS action length -\n\n      mstore(\n\n        mload(sub(ptr, 0x20)),\n\n        add(1, mload(mload(sub(ptr, 0x20))))\n\n      )\n\n      // Update number of events pushed to buffer -\n\n      mstore(0x140, add(1, mload(0x140)))\n\n    }\n\n    // Update free memory pointer\n\n    setFreeMem();\n",
          "message": "Contract.log (Contract.sol#657-692) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 694,
          "vulnerability_to_line": 730,
          "vulnerability_code": "  function log(bytes32[4] memory _topics, bytes32 _data) conditions(validEvent, validEvent) internal pure {\n\n    assembly {\n\n      // Get pointer to buffer length -\n\n      let ptr := add(0x20, mload(0xc0))\n\n      // Push 4 to the end of the buffer - event will have 4 topics\n\n      mstore(add(0x20, add(ptr, mload(ptr))), 4)\n\n      // Push topics to end of buffer\n\n      mstore(add(0x40, add(ptr, mload(ptr))), mload(_topics))\n\n      mstore(add(0x60, add(ptr, mload(ptr))), mload(add(0x20, _topics)))\n\n      mstore(add(0x80, add(ptr, mload(ptr))), mload(add(0x40, _topics)))\n\n      mstore(add(0xa0, add(ptr, mload(ptr))), mload(add(0x60, _topics)))\n\n      // If _data is zero, set data size to 0 in buffer and push -\n\n      if eq(_data, 0) {\n\n        mstore(add(0xc0, add(ptr, mload(ptr))), 0)\n\n        // Increment buffer length - 0xc0 plus the original length\n\n        mstore(ptr, add(0xc0, mload(ptr)))\n\n      }\n\n      // If _data is not zero, set size to 0x20 and push to buffer -\n\n      if iszero(eq(_data, 0)) {\n\n        // Push data size (0x20) to the end of the buffer\n\n        mstore(add(0xc0, add(ptr, mload(ptr))), 0x20)\n\n        // Push data to the end of the buffer\n\n        mstore(add(0xe0, add(ptr, mload(ptr))), _data)\n\n        // Increment buffer length - 0xe0 plus the original length\n\n        mstore(ptr, add(0xe0, mload(ptr)))\n\n      }\n\n      // Increment EMITS action length -\n\n      mstore(\n\n        mload(sub(ptr, 0x20)),\n\n        add(1, mload(mload(sub(ptr, 0x20))))\n\n      )\n\n      // Update number of events pushed to buffer -\n\n      mstore(0x140, add(1, mload(0x140)))\n\n    }\n\n    // Update free memory pointer\n\n    setFreeMem();\n",
          "message": "Contract.log (Contract.sol#694-730) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 734,
          "vulnerability_to_line": 754,
          "vulnerability_code": "  function paying() conditions(validPayBuff, isPaying) internal pure {\n\n    bytes4 action_req = PAYS;\n\n    assembly {\n\n      // Get pointer to buffer length -\n\n      let ptr := add(0x20, mload(0xc0))\n\n      // Push requestor to the end of buffer, as well as to the 'current action' slot -\n\n      mstore(add(0x20, add(ptr, mload(ptr))), action_req)\n\n      // Push '0' to the end of the 4 bytes just pushed - this will be the length of the PAYS action\n\n      mstore(add(0x24, add(ptr, mload(ptr))), 0)\n\n      // Increment buffer length - 0x24 plus the previous length\n\n      mstore(ptr, add(0x24, mload(ptr)))\n\n      // Set the current action being executed (PAYS) -\n\n      mstore(0xe0, action_req)\n\n      // Set the expected next function - PAY_AMT\n\n      mstore(0x100, 8)\n\n      // Set a pointer to the length of the current request within the buffer\n\n      mstore(sub(ptr, 0x20), add(ptr, mload(ptr)))\n\n    }\n\n    // Update free memory pointer\n\n    setFreeMem();\n",
          "message": "Contract.paying (Contract.sol#734-754) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 757,
          "vulnerability_to_line": 778,
          "vulnerability_code": "  function pay(uint _amount) conditions(validPayAmt, validPayDest) internal pure returns (uint) {\n\n    assembly {\n\n      // Get pointer to buffer length -\n\n      let ptr := add(0x20, mload(0xc0))\n\n      // Push payment amount to the end of the buffer -\n\n      mstore(add(0x20, add(ptr, mload(ptr))), _amount)\n\n      // Increment buffer length - 0x20 plus the previous length\n\n      mstore(ptr, add(0x20, mload(ptr)))\n\n      // Set the expected next function - PAY_DEST\n\n      mstore(0x100, 7)\n\n      // Increment PAYS action length -\n\n      mstore(\n\n        mload(sub(ptr, 0x20)),\n\n        add(1, mload(mload(sub(ptr, 0x20))))\n\n      )\n\n      // Update number of payment destinations to be pushed to -\n\n      mstore(0x160, add(1, mload(0x160)))\n\n    }\n\n    // Update free memory pointer\n\n    setFreeMem();\n\n    return _amount;\n",
          "message": "Contract.pay (Contract.sol#757-778) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 781,
          "vulnerability_to_line": 794,
          "vulnerability_code": "  function toAcc(uint, address _dest) conditions(validPayDest, validPayAmt) internal pure {\n\n    assembly {\n\n      // Get pointer to buffer length -\n\n      let ptr := add(0x20, mload(0xc0))\n\n      // Push payment destination to the end of the buffer -\n\n      mstore(add(0x20, add(ptr, mload(ptr))), _dest)\n\n      // Increment buffer length - 0x20 plus the previous length\n\n      mstore(ptr, add(0x20, mload(ptr)))\n\n      // Set the expected next function - PAY_AMT\n\n      mstore(0x100, 8)\n\n    }\n\n    // Update free memory pointer\n\n    setFreeMem();\n",
          "message": "Contract.toAcc (Contract.sol#781-794) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 797,
          "vulnerability_to_line": 799,
          "vulnerability_code": "  function setFreeMem() private pure {\n\n    assembly { mstore(0x40, msize) }\n",
          "message": "Contract.setFreeMem (Contract.sol#797-799) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 802,
          "vulnerability_to_line": 804,
          "vulnerability_code": "  function expected() private pure returns (NextFunction next) {\n\n    assembly { next := mload(0x100) }\n",
          "message": "Contract.expected (Contract.sol#802-804) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 807,
          "vulnerability_to_line": 813,
          "vulnerability_code": "  function emitted() internal pure returns (uint num_emitted) {\n\n    if (buffPtr() == bytes32(0))\n\n      return 0;\n\n\n\n    // Load number emitted from buffer -\n\n    assembly { num_emitted := mload(0x140) }\n",
          "message": "Contract.emitted (Contract.sol#807-813) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 816,
          "vulnerability_to_line": 822,
          "vulnerability_code": "  function stored() internal pure returns (uint num_stored) {\n\n    if (buffPtr() == bytes32(0))\n\n      return 0;\n\n\n\n    // Load number stored from buffer -\n\n    assembly { num_stored := mload(0x120) }\n",
          "message": "Contract.stored (Contract.sol#816-822) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 825,
          "vulnerability_to_line": 831,
          "vulnerability_code": "  function paid() internal pure returns (uint num_paid) {\n\n    if (buffPtr() == bytes32(0))\n\n      return 0;\n\n\n\n    // Load number paid from buffer -\n\n    assembly { num_paid := mload(0x160) }\n",
          "message": "Contract.paid (Contract.sol#825-831) is declared view but contains assembly code\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 71,
          "vulnerability_to_line": 91,
          "vulnerability_code": "  function authorize(address _script_exec) internal view {\n\n    // Initialize memory\n\n    initialize();\n\n\n\n    // Check that the sender is authorized as a script exec contract for this exec id\n\n    bytes32 perms = EXEC_PERMISSIONS;\n\n    bool authorized;\n\n    assembly {\n\n      // Place the script exec address at 0, and the exec permissions seed after it\n\n      mstore(0, _script_exec)\n\n      mstore(0x20, perms)\n\n      // Hash the resulting 0x34 bytes, and place back into memory at 0\n\n      mstore(0, keccak256(0x0c, 0x34))\n\n      // Place the exec id after the hash -\n\n      mstore(0x20, mload(0x80))\n\n      // Hash the previous hash with the execution id, and check the result\n\n      authorized := sload(keccak256(0, 0x40))\n\n    }\n\n    if (!authorized)\n\n      revert(\"Sender is not authorized as a script exec address\");\n",
          "message": "Contract.authorize uses assembly (Contract.sol#71-91)\n\t- Contract.sol#78-89\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 102,
          "vulnerability_to_line": 122,
          "vulnerability_code": "  function initialize() internal view {\n\n    // No memory should have been allocated yet - expect the free memory pointer\n\n    // to point to 0x80 - and throw if it does not\n\n    require(freeMem() == 0x80, \"Memory allocated prior to execution\");\n\n    // Next, set up memory for execution\n\n    assembly {\n\n      mstore(0x80, sload(0))     // Execution id, read from storage\n\n      mstore(0xa0, sload(1))     // Original sender address, read from storage\n\n      mstore(0xc0, 0)            // Pointer to storage buffer\n\n      mstore(0xe0, 0)            // Bytes4 value of the current action requestor being used\n\n      mstore(0x100, 0)           // Enum representing the next type of function to be called (when pushing to buffer)\n\n      mstore(0x120, 0)           // Number of storage slots written to in buffer\n\n      mstore(0x140, 0)           // Number of events pushed to buffer\n\n      mstore(0x160, 0)           // Number of payment destinations pushed to buffer\n\n\n\n      // Update free memory pointer -\n\n      mstore(0x40, 0x180)\n\n    }\n\n    // Ensure that the sender and execution id returned from storage are expected values -\n\n    assert(execID() != bytes32(0) && sender() != address(0));\n",
          "message": "Contract.initialize uses assembly (Contract.sol#102-122)\n\t- Contract.sol#107-121\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 138,
          "vulnerability_to_line": 150,
          "vulnerability_code": "  function commit() conditions(validState, none) internal pure {\n\n    // Check value of storage buffer pointer - should be at least 0x180\n\n    bytes32 ptr = buffPtr();\n\n    require(ptr >= 0x180, \"Invalid buffer pointer\");\n\n\n\n    assembly {\n\n      // Get the size of the buffer\n\n      let size := mload(add(0x20, ptr))\n\n      mstore(ptr, 0x20) // Place dynamic data offset before buffer\n\n      // Revert to storage\n\n      revert(ptr, add(0x40, size))\n\n    }\n",
          "message": "Contract.commit uses assembly (Contract.sol#138-150)\n\t- Contract.sol#143-150\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 166,
          "vulnerability_to_line": 168,
          "vulnerability_code": "  function buffPtr() private pure returns (bytes32 ptr) {\n\n    assembly { ptr := mload(0xc0) }\n",
          "message": "Contract.buffPtr uses assembly (Contract.sol#166-168)\n\t- Contract.sol#167-168\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 171,
          "vulnerability_to_line": 173,
          "vulnerability_code": "  function freeMem() private pure returns (bytes32 ptr) {\n\n    assembly { ptr := mload(0x40) }\n",
          "message": "Contract.freeMem uses assembly (Contract.sol#171-173)\n\t- Contract.sol#172-173\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 176,
          "vulnerability_to_line": 181,
          "vulnerability_code": "  function currentAction() private pure returns (bytes4 action) {\n\n    if (buffPtr() == bytes32(0))\n\n      return bytes4(0);\n\n\n\n    assembly { action := mload(0xe0) }\n",
          "message": "Contract.currentAction uses assembly (Contract.sol#176-181)\n\t- Contract.sol#180-181\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 202,
          "vulnerability_to_line": 215,
          "vulnerability_code": "  function startBuffer() private pure {\n\n    assembly {\n\n      // Get a pointer to free memory, and place at 0xc0 (storage buffer pointer)\n\n      let ptr := msize()\n\n      mstore(0xc0, ptr)\n\n      // Clear bytes at pointer -\n\n      mstore(ptr, 0)            // temp ptr\n\n      mstore(add(0x20, ptr), 0) // buffer length\n\n      // Update free memory pointer -\n\n      mstore(0x40, add(0x40, ptr))\n\n      // Set expected next function to 'NONE' -\n\n      mstore(0x100, 1)\n\n    }\n",
          "message": "Contract.startBuffer uses assembly (Contract.sol#202-215)\n\t- Contract.sol#203-215\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 259,
          "vulnerability_to_line": 262,
          "vulnerability_code": "  function execID() internal pure returns (bytes32 exec_id) {\n\n    assembly { exec_id := mload(0x80) }\n\n    require(exec_id != bytes32(0), \"Execution id overwritten, or not read\");\n",
          "message": "Contract.execID uses assembly (Contract.sol#259-262)\n\t- Contract.sol#260-261\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 265,
          "vulnerability_to_line": 268,
          "vulnerability_code": "  function sender() internal pure returns (address addr) {\n\n    assembly { addr := mload(0xa0) }\n\n    require(addr != address(0), \"Sender address overwritten, or not read\");\n",
          "message": "Contract.sender uses assembly (Contract.sol#265-268)\n\t- Contract.sol#266-267\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 274,
          "vulnerability_to_line": 277,
          "vulnerability_code": "  function read(bytes32 _location) internal view returns (bytes32 data) {\n\n    data = keccak256(_location, execID());\n\n    assembly { data := sload(data) }\n",
          "message": "Contract.read uses assembly (Contract.sol#274-277)\n\t- Contract.sol#276-277\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 346,
          "vulnerability_to_line": 366,
          "vulnerability_code": "  function storing() conditions(validStoreBuff, isStoring) internal pure {\n\n    bytes4 action_req = STORES;\n\n    assembly {\n\n      // Get pointer to buffer length -\n\n      let ptr := add(0x20, mload(0xc0))\n\n      // Push requestor to the end of buffer, as well as to the 'current action' slot -\n\n      mstore(add(0x20, add(ptr, mload(ptr))), action_req)\n\n      // Push '0' to the end of the 4 bytes just pushed - this will be the length of the STORES action\n\n      mstore(add(0x24, add(ptr, mload(ptr))), 0)\n\n      // Increment buffer length - 0x24 plus the previous length\n\n      mstore(ptr, add(0x24, mload(ptr)))\n\n      // Set the current action being executed (STORES) -\n\n      mstore(0xe0, action_req)\n\n      // Set the expected next function - STORE_DEST\n\n      mstore(0x100, 2)\n\n      // Set a pointer to the length of the current request within the buffer\n\n      mstore(sub(ptr, 0x20), add(ptr, mload(ptr)))\n\n    }\n\n    // Update free memory pointer\n\n    setFreeMem();\n",
          "message": "Contract.storing uses assembly (Contract.sol#346-366)\n\t- Contract.sol#348-365\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 369,
          "vulnerability_to_line": 390,
          "vulnerability_code": "  function set(bytes32 _field) conditions(validStoreDest, validStoreVal) internal pure returns (bytes32) {\n\n    assembly {\n\n      // Get pointer to buffer length -\n\n      let ptr := add(0x20, mload(0xc0))\n\n      // Push storage destination to the end of the buffer -\n\n      mstore(add(0x20, add(ptr, mload(ptr))), _field)\n\n      // Increment buffer length - 0x20 plus the previous length\n\n      mstore(ptr, add(0x20, mload(ptr)))\n\n      // Set the expected next function - VAL_SET\n\n      mstore(0x100, 3)\n\n      // Increment STORES action length -\n\n      mstore(\n\n        mload(sub(ptr, 0x20)),\n\n        add(1, mload(mload(sub(ptr, 0x20))))\n\n      )\n\n      // Update number of storage slots pushed to -\n\n      mstore(0x120, add(1, mload(0x120)))\n\n    }\n\n    // Update free memory pointer\n\n    setFreeMem();\n\n    return _field;\n",
          "message": "Contract.set uses assembly (Contract.sol#369-390)\n\t- Contract.sol#370-388\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 393,
          "vulnerability_to_line": 406,
          "vulnerability_code": "  function to(bytes32, bytes32 _val) conditions(validStoreVal, validStoreDest) internal pure {\n\n    assembly {\n\n      // Get pointer to buffer length -\n\n      let ptr := add(0x20, mload(0xc0))\n\n      // Push storage value to the end of the buffer -\n\n      mstore(add(0x20, add(ptr, mload(ptr))), _val)\n\n      // Increment buffer length - 0x20 plus the previous length\n\n      mstore(ptr, add(0x20, mload(ptr)))\n\n      // Set the expected next function - STORE_DEST\n\n      mstore(0x100, 2)\n\n    }\n\n    // Update free memory pointer\n\n    setFreeMem();\n",
          "message": "Contract.to uses assembly (Contract.sol#393-406)\n\t- Contract.sol#394-405\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 426,
          "vulnerability_to_line": 450,
          "vulnerability_code": "  function increase(bytes32 _field) conditions(validStoreDest, validStoreVal) internal view returns (bytes32 val) {\n\n    // Read value stored at the location in storage -\n\n    val = keccak256(_field, execID());\n\n    assembly {\n\n      val := sload(val)\n\n      // Get pointer to buffer length -\n\n      let ptr := add(0x20, mload(0xc0))\n\n      // Push storage destination to the end of the buffer -\n\n      mstore(add(0x20, add(ptr, mload(ptr))), _field)\n\n      // Increment buffer length - 0x20 plus the previous length\n\n      mstore(ptr, add(0x20, mload(ptr)))\n\n      // Set the expected next function - VAL_INC\n\n      mstore(0x100, 4)\n\n      // Increment STORES action length -\n\n      mstore(\n\n        mload(sub(ptr, 0x20)),\n\n        add(1, mload(mload(sub(ptr, 0x20))))\n\n      )\n\n      // Update number of storage slots pushed to -\n\n      mstore(0x120, add(1, mload(0x120)))\n\n    }\n\n    // Update free memory pointer\n\n    setFreeMem();\n\n    return val;\n",
          "message": "Contract.increase uses assembly (Contract.sol#426-450)\n\t- Contract.sol#429-448\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 452,
          "vulnerability_to_line": 476,
          "vulnerability_code": "  function decrease(bytes32 _field) conditions(validStoreDest, validStoreVal) internal view returns (bytes32 val) {\n\n    // Read value stored at the location in storage -\n\n    val = keccak256(_field, execID());\n\n    assembly {\n\n      val := sload(val)\n\n      // Get pointer to buffer length -\n\n      let ptr := add(0x20, mload(0xc0))\n\n      // Push storage destination to the end of the buffer -\n\n      mstore(add(0x20, add(ptr, mload(ptr))), _field)\n\n      // Increment buffer length - 0x20 plus the previous length\n\n      mstore(ptr, add(0x20, mload(ptr)))\n\n      // Set the expected next function - VAL_DEC\n\n      mstore(0x100, 5)\n\n      // Increment STORES action length -\n\n      mstore(\n\n        mload(sub(ptr, 0x20)),\n\n        add(1, mload(mload(sub(ptr, 0x20))))\n\n      )\n\n      // Update number of storage slots pushed to -\n\n      mstore(0x120, add(1, mload(0x120)))\n\n    }\n\n    // Update free memory pointer\n\n    setFreeMem();\n\n    return val;\n",
          "message": "Contract.decrease uses assembly (Contract.sol#452-476)\n\t- Contract.sol#455-474\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 478,
          "vulnerability_to_line": 500,
          "vulnerability_code": "  function by(bytes32 _val, uint _amt) conditions(validStoreVal, validStoreDest) internal pure {\n\n    // Check the expected function type - if it is VAL_INC, perform safe-add on the value\n\n    // If it is VAL_DEC, perform safe-sub on the value\n\n    if (expected() == NextFunction.VAL_INC)\n\n      _amt = _amt.add(uint(_val));\n\n    else if (expected() == NextFunction.VAL_DEC)\n\n      _amt = uint(_val).sub(_amt);\n\n    else\n\n      revert('Expected VAL_INC or VAL_DEC');\n\n\n\n    assembly {\n\n      // Get pointer to buffer length -\n\n      let ptr := add(0x20, mload(0xc0))\n\n      // Push storage value to the end of the buffer -\n\n      mstore(add(0x20, add(ptr, mload(ptr))), _amt)\n\n      // Increment buffer length - 0x20 plus the previous length\n\n      mstore(ptr, add(0x20, mload(ptr)))\n\n      // Set the expected next function - STORE_DEST\n\n      mstore(0x100, 2)\n\n    }\n\n    // Update free memory pointer\n\n    setFreeMem();\n",
          "message": "Contract.by uses assembly (Contract.sol#478-500)\n\t- Contract.sol#488-499\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 503,
          "vulnerability_to_line": 527,
          "vulnerability_code": "  function byMaximum(bytes32 _val, uint _amt) conditions(validStoreVal, validStoreDest) internal pure {\n\n    // Check the expected function type - if it is VAL_DEC, set the new amount to the difference of\n\n    // _val and _amt, to a minimum of 0\n\n    if (expected() == NextFunction.VAL_DEC) {\n\n      if (_amt >= uint(_val))\n\n        _amt = 0;\n\n      else\n\n        _amt = uint(_val).sub(_amt);\n\n    } else {\n\n      revert('Expected VAL_DEC');\n\n    }\n\n\n\n    assembly {\n\n      // Get pointer to buffer length -\n\n      let ptr := add(0x20, mload(0xc0))\n\n      // Push storage value to the end of the buffer -\n\n      mstore(add(0x20, add(ptr, mload(ptr))), _amt)\n\n      // Increment buffer length - 0x20 plus the previous length\n\n      mstore(ptr, add(0x20, mload(ptr)))\n\n      // Set the expected next function - STORE_DEST\n\n      mstore(0x100, 2)\n\n    }\n\n    // Update free memory pointer\n\n    setFreeMem();\n",
          "message": "Contract.byMaximum uses assembly (Contract.sol#503-527)\n\t- Contract.sol#515-526\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 531,
          "vulnerability_to_line": 551,
          "vulnerability_code": "  function emitting() conditions(validEmitBuff, isEmitting) internal pure {\n\n    bytes4 action_req = EMITS;\n\n    assembly {\n\n      // Get pointer to buffer length -\n\n      let ptr := add(0x20, mload(0xc0))\n\n      // Push requestor to the end of buffer, as well as to the 'current action' slot -\n\n      mstore(add(0x20, add(ptr, mload(ptr))), action_req)\n\n      // Push '0' to the end of the 4 bytes just pushed - this will be the length of the EMITS action\n\n      mstore(add(0x24, add(ptr, mload(ptr))), 0)\n\n      // Increment buffer length - 0x24 plus the previous length\n\n      mstore(ptr, add(0x24, mload(ptr)))\n\n      // Set the current action being executed (EMITS) -\n\n      mstore(0xe0, action_req)\n\n      // Set the expected next function - EMIT_LOG\n\n      mstore(0x100, 6)\n\n      // Set a pointer to the length of the current request within the buffer\n\n      mstore(sub(ptr, 0x20), add(ptr, mload(ptr)))\n\n    }\n\n    // Update free memory pointer\n\n    setFreeMem();\n",
          "message": "Contract.emitting uses assembly (Contract.sol#531-551)\n\t- Contract.sol#533-550\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 553,
          "vulnerability_to_line": 584,
          "vulnerability_code": "  function log(bytes32 _data) conditions(validEvent, validEvent) internal pure {\n\n    assembly {\n\n      // Get pointer to buffer length -\n\n      let ptr := add(0x20, mload(0xc0))\n\n      // Push 0 to the end of the buffer - event will have 0 topics\n\n      mstore(add(0x20, add(ptr, mload(ptr))), 0)\n\n      // If _data is zero, set data size to 0 in buffer and push -\n\n      if eq(_data, 0) {\n\n        mstore(add(0x40, add(ptr, mload(ptr))), 0)\n\n        // Increment buffer length - 0x40 plus the original length\n\n        mstore(ptr, add(0x40, mload(ptr)))\n\n      }\n\n      // If _data is not zero, set size to 0x20 and push to buffer -\n\n      if iszero(eq(_data, 0)) {\n\n        // Push data size (0x20) to the end of the buffer\n\n        mstore(add(0x40, add(ptr, mload(ptr))), 0x20)\n\n        // Push data to the end of the buffer\n\n        mstore(add(0x60, add(ptr, mload(ptr))), _data)\n\n        // Increment buffer length - 0x60 plus the original length\n\n        mstore(ptr, add(0x60, mload(ptr)))\n\n      }\n\n      // Increment EMITS action length -\n\n      mstore(\n\n        mload(sub(ptr, 0x20)),\n\n        add(1, mload(mload(sub(ptr, 0x20))))\n\n      )\n\n      // Update number of events pushed to buffer -\n\n      mstore(0x140, add(1, mload(0x140)))\n\n    }\n\n    // Update free memory pointer\n\n    setFreeMem();\n",
          "message": "Contract.log uses assembly (Contract.sol#553-584)\n\t- Contract.sol#554-583\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 586,
          "vulnerability_to_line": 619,
          "vulnerability_code": "  function log(bytes32[1] memory _topics, bytes32 _data) conditions(validEvent, validEvent) internal pure {\n\n    assembly {\n\n      // Get pointer to buffer length -\n\n      let ptr := add(0x20, mload(0xc0))\n\n      // Push 1 to the end of the buffer - event will have 1 topic\n\n      mstore(add(0x20, add(ptr, mload(ptr))), 1)\n\n      // Push topic to end of buffer\n\n      mstore(add(0x40, add(ptr, mload(ptr))), mload(_topics))\n\n      // If _data is zero, set data size to 0 in buffer and push -\n\n      if eq(_data, 0) {\n\n        mstore(add(0x60, add(ptr, mload(ptr))), 0)\n\n        // Increment buffer length - 0x60 plus the original length\n\n        mstore(ptr, add(0x60, mload(ptr)))\n\n      }\n\n      // If _data is not zero, set size to 0x20 and push to buffer -\n\n      if iszero(eq(_data, 0)) {\n\n        // Push data size (0x20) to the end of the buffer\n\n        mstore(add(0x60, add(ptr, mload(ptr))), 0x20)\n\n        // Push data to the end of the buffer\n\n        mstore(add(0x80, add(ptr, mload(ptr))), _data)\n\n        // Increment buffer length - 0x80 plus the original length\n\n        mstore(ptr, add(0x80, mload(ptr)))\n\n      }\n\n      // Increment EMITS action length -\n\n      mstore(\n\n        mload(sub(ptr, 0x20)),\n\n        add(1, mload(mload(sub(ptr, 0x20))))\n\n      )\n\n      // Update number of events pushed to buffer -\n\n      mstore(0x140, add(1, mload(0x140)))\n\n    }\n\n    // Update free memory pointer\n\n    setFreeMem();\n",
          "message": "Contract.log uses assembly (Contract.sol#586-619)\n\t- Contract.sol#587-618\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 621,
          "vulnerability_to_line": 655,
          "vulnerability_code": "  function log(bytes32[2] memory _topics, bytes32 _data) conditions(validEvent, validEvent) internal pure {\n\n    assembly {\n\n      // Get pointer to buffer length -\n\n      let ptr := add(0x20, mload(0xc0))\n\n      // Push 2 to the end of the buffer - event will have 2 topics\n\n      mstore(add(0x20, add(ptr, mload(ptr))), 2)\n\n      // Push topics to end of buffer\n\n      mstore(add(0x40, add(ptr, mload(ptr))), mload(_topics))\n\n      mstore(add(0x60, add(ptr, mload(ptr))), mload(add(0x20, _topics)))\n\n      // If _data is zero, set data size to 0 in buffer and push -\n\n      if eq(_data, 0) {\n\n        mstore(add(0x80, add(ptr, mload(ptr))), 0)\n\n        // Increment buffer length - 0x80 plus the original length\n\n        mstore(ptr, add(0x80, mload(ptr)))\n\n      }\n\n      // If _data is not zero, set size to 0x20 and push to buffer -\n\n      if iszero(eq(_data, 0)) {\n\n        // Push data size (0x20) to the end of the buffer\n\n        mstore(add(0x80, add(ptr, mload(ptr))), 0x20)\n\n        // Push data to the end of the buffer\n\n        mstore(add(0xa0, add(ptr, mload(ptr))), _data)\n\n        // Increment buffer length - 0xa0 plus the original length\n\n        mstore(ptr, add(0xa0, mload(ptr)))\n\n      }\n\n      // Increment EMITS action length -\n\n      mstore(\n\n        mload(sub(ptr, 0x20)),\n\n        add(1, mload(mload(sub(ptr, 0x20))))\n\n      )\n\n      // Update number of events pushed to buffer -\n\n      mstore(0x140, add(1, mload(0x140)))\n\n    }\n\n    // Update free memory pointer\n\n    setFreeMem();\n",
          "message": "Contract.log uses assembly (Contract.sol#621-655)\n\t- Contract.sol#622-654\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 657,
          "vulnerability_to_line": 692,
          "vulnerability_code": "  function log(bytes32[3] memory _topics, bytes32 _data) conditions(validEvent, validEvent) internal pure {\n\n    assembly {\n\n      // Get pointer to buffer length -\n\n      let ptr := add(0x20, mload(0xc0))\n\n      // Push 3 to the end of the buffer - event will have 3 topics\n\n      mstore(add(0x20, add(ptr, mload(ptr))), 3)\n\n      // Push topics to end of buffer\n\n      mstore(add(0x40, add(ptr, mload(ptr))), mload(_topics))\n\n      mstore(add(0x60, add(ptr, mload(ptr))), mload(add(0x20, _topics)))\n\n      mstore(add(0x80, add(ptr, mload(ptr))), mload(add(0x40, _topics)))\n\n      // If _data is zero, set data size to 0 in buffer and push -\n\n      if eq(_data, 0) {\n\n        mstore(add(0xa0, add(ptr, mload(ptr))), 0)\n\n        // Increment buffer length - 0xa0 plus the original length\n\n        mstore(ptr, add(0xa0, mload(ptr)))\n\n      }\n\n      // If _data is not zero, set size to 0x20 and push to buffer -\n\n      if iszero(eq(_data, 0)) {\n\n        // Push data size (0x20) to the end of the buffer\n\n        mstore(add(0xa0, add(ptr, mload(ptr))), 0x20)\n\n        // Push data to the end of the buffer\n\n        mstore(add(0xc0, add(ptr, mload(ptr))), _data)\n\n        // Increment buffer length - 0xc0 plus the original length\n\n        mstore(ptr, add(0xc0, mload(ptr)))\n\n      }\n\n      // Increment EMITS action length -\n\n      mstore(\n\n        mload(sub(ptr, 0x20)),\n\n        add(1, mload(mload(sub(ptr, 0x20))))\n\n      )\n\n      // Update number of events pushed to buffer -\n\n      mstore(0x140, add(1, mload(0x140)))\n\n    }\n\n    // Update free memory pointer\n\n    setFreeMem();\n",
          "message": "Contract.log uses assembly (Contract.sol#657-692)\n\t- Contract.sol#658-691\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 694,
          "vulnerability_to_line": 730,
          "vulnerability_code": "  function log(bytes32[4] memory _topics, bytes32 _data) conditions(validEvent, validEvent) internal pure {\n\n    assembly {\n\n      // Get pointer to buffer length -\n\n      let ptr := add(0x20, mload(0xc0))\n\n      // Push 4 to the end of the buffer - event will have 4 topics\n\n      mstore(add(0x20, add(ptr, mload(ptr))), 4)\n\n      // Push topics to end of buffer\n\n      mstore(add(0x40, add(ptr, mload(ptr))), mload(_topics))\n\n      mstore(add(0x60, add(ptr, mload(ptr))), mload(add(0x20, _topics)))\n\n      mstore(add(0x80, add(ptr, mload(ptr))), mload(add(0x40, _topics)))\n\n      mstore(add(0xa0, add(ptr, mload(ptr))), mload(add(0x60, _topics)))\n\n      // If _data is zero, set data size to 0 in buffer and push -\n\n      if eq(_data, 0) {\n\n        mstore(add(0xc0, add(ptr, mload(ptr))), 0)\n\n        // Increment buffer length - 0xc0 plus the original length\n\n        mstore(ptr, add(0xc0, mload(ptr)))\n\n      }\n\n      // If _data is not zero, set size to 0x20 and push to buffer -\n\n      if iszero(eq(_data, 0)) {\n\n        // Push data size (0x20) to the end of the buffer\n\n        mstore(add(0xc0, add(ptr, mload(ptr))), 0x20)\n\n        // Push data to the end of the buffer\n\n        mstore(add(0xe0, add(ptr, mload(ptr))), _data)\n\n        // Increment buffer length - 0xe0 plus the original length\n\n        mstore(ptr, add(0xe0, mload(ptr)))\n\n      }\n\n      // Increment EMITS action length -\n\n      mstore(\n\n        mload(sub(ptr, 0x20)),\n\n        add(1, mload(mload(sub(ptr, 0x20))))\n\n      )\n\n      // Update number of events pushed to buffer -\n\n      mstore(0x140, add(1, mload(0x140)))\n\n    }\n\n    // Update free memory pointer\n\n    setFreeMem();\n",
          "message": "Contract.log uses assembly (Contract.sol#694-730)\n\t- Contract.sol#695-729\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 734,
          "vulnerability_to_line": 754,
          "vulnerability_code": "  function paying() conditions(validPayBuff, isPaying) internal pure {\n\n    bytes4 action_req = PAYS;\n\n    assembly {\n\n      // Get pointer to buffer length -\n\n      let ptr := add(0x20, mload(0xc0))\n\n      // Push requestor to the end of buffer, as well as to the 'current action' slot -\n\n      mstore(add(0x20, add(ptr, mload(ptr))), action_req)\n\n      // Push '0' to the end of the 4 bytes just pushed - this will be the length of the PAYS action\n\n      mstore(add(0x24, add(ptr, mload(ptr))), 0)\n\n      // Increment buffer length - 0x24 plus the previous length\n\n      mstore(ptr, add(0x24, mload(ptr)))\n\n      // Set the current action being executed (PAYS) -\n\n      mstore(0xe0, action_req)\n\n      // Set the expected next function - PAY_AMT\n\n      mstore(0x100, 8)\n\n      // Set a pointer to the length of the current request within the buffer\n\n      mstore(sub(ptr, 0x20), add(ptr, mload(ptr)))\n\n    }\n\n    // Update free memory pointer\n\n    setFreeMem();\n",
          "message": "Contract.paying uses assembly (Contract.sol#734-754)\n\t- Contract.sol#736-753\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 757,
          "vulnerability_to_line": 778,
          "vulnerability_code": "  function pay(uint _amount) conditions(validPayAmt, validPayDest) internal pure returns (uint) {\n\n    assembly {\n\n      // Get pointer to buffer length -\n\n      let ptr := add(0x20, mload(0xc0))\n\n      // Push payment amount to the end of the buffer -\n\n      mstore(add(0x20, add(ptr, mload(ptr))), _amount)\n\n      // Increment buffer length - 0x20 plus the previous length\n\n      mstore(ptr, add(0x20, mload(ptr)))\n\n      // Set the expected next function - PAY_DEST\n\n      mstore(0x100, 7)\n\n      // Increment PAYS action length -\n\n      mstore(\n\n        mload(sub(ptr, 0x20)),\n\n        add(1, mload(mload(sub(ptr, 0x20))))\n\n      )\n\n      // Update number of payment destinations to be pushed to -\n\n      mstore(0x160, add(1, mload(0x160)))\n\n    }\n\n    // Update free memory pointer\n\n    setFreeMem();\n\n    return _amount;\n",
          "message": "Contract.pay uses assembly (Contract.sol#757-778)\n\t- Contract.sol#758-776\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 781,
          "vulnerability_to_line": 794,
          "vulnerability_code": "  function toAcc(uint, address _dest) conditions(validPayDest, validPayAmt) internal pure {\n\n    assembly {\n\n      // Get pointer to buffer length -\n\n      let ptr := add(0x20, mload(0xc0))\n\n      // Push payment destination to the end of the buffer -\n\n      mstore(add(0x20, add(ptr, mload(ptr))), _dest)\n\n      // Increment buffer length - 0x20 plus the previous length\n\n      mstore(ptr, add(0x20, mload(ptr)))\n\n      // Set the expected next function - PAY_AMT\n\n      mstore(0x100, 8)\n\n    }\n\n    // Update free memory pointer\n\n    setFreeMem();\n",
          "message": "Contract.toAcc uses assembly (Contract.sol#781-794)\n\t- Contract.sol#782-793\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 797,
          "vulnerability_to_line": 799,
          "vulnerability_code": "  function setFreeMem() private pure {\n\n    assembly { mstore(0x40, msize) }\n",
          "message": "Contract.setFreeMem uses assembly (Contract.sol#797-799)\n\t- Contract.sol#798-799\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 802,
          "vulnerability_to_line": 804,
          "vulnerability_code": "  function expected() private pure returns (NextFunction next) {\n\n    assembly { next := mload(0x100) }\n",
          "message": "Contract.expected uses assembly (Contract.sol#802-804)\n\t- Contract.sol#803-804\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 807,
          "vulnerability_to_line": 813,
          "vulnerability_code": "  function emitted() internal pure returns (uint num_emitted) {\n\n    if (buffPtr() == bytes32(0))\n\n      return 0;\n\n\n\n    // Load number emitted from buffer -\n\n    assembly { num_emitted := mload(0x140) }\n",
          "message": "Contract.emitted uses assembly (Contract.sol#807-813)\n\t- Contract.sol#812-813\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 816,
          "vulnerability_to_line": 822,
          "vulnerability_code": "  function stored() internal pure returns (uint num_stored) {\n\n    if (buffPtr() == bytes32(0))\n\n      return 0;\n\n\n\n    // Load number stored from buffer -\n\n    assembly { num_stored := mload(0x120) }\n",
          "message": "Contract.stored uses assembly (Contract.sol#816-822)\n\t- Contract.sol#821-822\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 825,
          "vulnerability_to_line": 831,
          "vulnerability_code": "  function paid() internal pure returns (uint num_paid) {\n\n    if (buffPtr() == bytes32(0))\n\n      return 0;\n\n\n\n    // Load number paid from buffer -\n\n    assembly { num_paid := mload(0x160) }\n",
          "message": "Contract.paid uses assembly (Contract.sol#825-831)\n\t- Contract.sol#830-831\n"
        },
        {
          "name": "solc-version",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.23;\n",
          "message": "Detected issues with version pragma in Contract.sol:\n\t- pragma solidity^0.4.23 (Contract.sol#3): it allows old versions\n\t- pragma solidity^0.4.23 (Contract.sol#46): it allows old versions\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 71,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function authorize(address _script_exec) internal view {\n",
          "message": "Parameter '_script_exec' of Contract.authorize (Contract.sol#71) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 132,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function checks(function () pure _check) conditions(validState, validState) internal pure {\n",
          "message": "Parameter '_check' of Contract.checks (Contract.sol#132) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 274,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function read(bytes32 _location) internal view returns (bytes32 data) {\n",
          "message": "Parameter '_location' of Contract.read (Contract.sol#274) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 369,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function set(bytes32 _field) conditions(validStoreDest, validStoreVal) internal pure returns (bytes32) {\n",
          "message": "Parameter '_field' of Contract.set (Contract.sol#369) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 393,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function to(bytes32, bytes32 _val) conditions(validStoreVal, validStoreDest) internal pure {\n",
          "message": "Parameter '' of Contract.to (Contract.sol#393) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 409,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function to(bytes32 _field, uint _val) internal pure {\n",
          "message": "Parameter '_field' of Contract.to (Contract.sol#409) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 409,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function to(bytes32 _field, uint _val) internal pure {\n",
          "message": "Parameter '_val' of Contract.to (Contract.sol#409) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 414,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function to(bytes32 _field, address _val) internal pure {\n",
          "message": "Parameter '_field' of Contract.to (Contract.sol#414) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 414,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function to(bytes32 _field, address _val) internal pure {\n",
          "message": "Parameter '_val' of Contract.to (Contract.sol#414) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 419,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function to(bytes32 _field, bool _val) internal pure {\n",
          "message": "Parameter '_field' of Contract.to (Contract.sol#419) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 419,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function to(bytes32 _field, bool _val) internal pure {\n",
          "message": "Parameter '_val' of Contract.to (Contract.sol#419) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 426,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function increase(bytes32 _field) conditions(validStoreDest, validStoreVal) internal view returns (bytes32 val) {\n",
          "message": "Parameter '_field' of Contract.increase (Contract.sol#426) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 452,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function decrease(bytes32 _field) conditions(validStoreDest, validStoreVal) internal view returns (bytes32 val) {\n",
          "message": "Parameter '_field' of Contract.decrease (Contract.sol#452) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 478,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function by(bytes32 _val, uint _amt) conditions(validStoreVal, validStoreDest) internal pure {\n",
          "message": "Parameter '_val' of Contract.by (Contract.sol#478) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 478,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function by(bytes32 _val, uint _amt) conditions(validStoreVal, validStoreDest) internal pure {\n",
          "message": "Parameter '_amt' of Contract.by (Contract.sol#478) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 503,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function byMaximum(bytes32 _val, uint _amt) conditions(validStoreVal, validStoreDest) internal pure {\n",
          "message": "Parameter '_val' of Contract.byMaximum (Contract.sol#503) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 503,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function byMaximum(bytes32 _val, uint _amt) conditions(validStoreVal, validStoreDest) internal pure {\n",
          "message": "Parameter '_amt' of Contract.byMaximum (Contract.sol#503) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 757,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function pay(uint _amount) conditions(validPayAmt, validPayDest) internal pure returns (uint) {\n",
          "message": "Parameter '_amount' of Contract.pay (Contract.sol#757) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 781,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function toAcc(uint, address _dest) conditions(validPayDest, validPayAmt) internal pure {\n",
          "message": "Parameter '' of Contract.toAcc (Contract.sol#781) is not in mixedCase\n"
        },
        {
          "name": "unused-state",
          "vulnerability_from_line": 284,
          "vulnerability_to_line": null,
          "vulnerability_code": "  bytes4 internal constant THROWS = bytes4(keccak256('Error(string)'));\n",
          "message": "Contract.THROWS (Contract.sol#284) is never used in Contract\n"
        }
      ]
    },
    "smartcheck": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 105,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require(freeMem() == 0x80, \"Memory allocated prior to execution\");\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 141,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require(ptr >= 0x180, \"Invalid buffer pointer\");\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 156,
          "vulnerability_to_line": null,
          "vulnerability_code": "    if (freeMem() < 0x180)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 159,
          "vulnerability_to_line": null,
          "vulnerability_code": "    if (buffPtr() != 0 && buffPtr() < 0x180)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
          "vulnerability_from_line": 166,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function buffPtr() private pure returns (bytes32 ptr) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
          "vulnerability_from_line": 171,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function freeMem() private pure returns (bytes32 ptr) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
          "vulnerability_from_line": 259,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function execID() internal pure returns (bytes32 exec_id) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
          "vulnerability_from_line": 265,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function sender() internal pure returns (address addr) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
          "vulnerability_from_line": 802,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function expected() private pure returns (NextFunction next) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.23;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 46,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.23;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_REVERT_REQUIRE",
          "vulnerability_from_line": 89,
          "vulnerability_to_line": null,
          "vulnerability_code": "    if (!authorized)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_REVERT_REQUIRE",
          "vulnerability_from_line": 156,
          "vulnerability_to_line": null,
          "vulnerability_code": "    if (freeMem() < 0x180)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_REVERT_REQUIRE",
          "vulnerability_from_line": 159,
          "vulnerability_to_line": null,
          "vulnerability_code": "    if (buffPtr() != 0 && buffPtr() < 0x180)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_REVERT_REQUIRE",
          "vulnerability_from_line": 185,
          "vulnerability_to_line": null,
          "vulnerability_code": "    if (currentAction() != STORES)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_REVERT_REQUIRE",
          "vulnerability_from_line": 191,
          "vulnerability_to_line": null,
          "vulnerability_code": "    if (currentAction() != EMITS)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_REVERT_REQUIRE",
          "vulnerability_from_line": 197,
          "vulnerability_to_line": null,
          "vulnerability_code": "    if (currentAction() != PAYS)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_REVERT_REQUIRE",
          "vulnerability_from_line": 225,
          "vulnerability_to_line": null,
          "vulnerability_code": "    if (stored() != 0 || currentAction() == STORES)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_REVERT_REQUIRE",
          "vulnerability_from_line": 237,
          "vulnerability_to_line": null,
          "vulnerability_code": "    if (emitted() != 0 || currentAction() == EMITS)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_REVERT_REQUIRE",
          "vulnerability_from_line": 249,
          "vulnerability_to_line": null,
          "vulnerability_code": "    if (paid() != 0 || currentAction() == PAYS)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_REVERT_REQUIRE",
          "vulnerability_from_line": 294,
          "vulnerability_to_line": null,
          "vulnerability_code": "    if (expected() != NextFunction.STORE_DEST)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_REVERT_REQUIRE",
          "vulnerability_from_line": 304,
          "vulnerability_to_line": null,
          "vulnerability_code": "    if (\n",
          "message": null
        },
        {
          "name": "SOLIDITY_REVERT_REQUIRE",
          "vulnerability_from_line": 317,
          "vulnerability_to_line": null,
          "vulnerability_code": "    if (expected() != NextFunction.PAY_DEST)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_REVERT_REQUIRE",
          "vulnerability_from_line": 327,
          "vulnerability_to_line": null,
          "vulnerability_code": "    if (expected() != NextFunction.PAY_AMT)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_REVERT_REQUIRE",
          "vulnerability_from_line": 337,
          "vulnerability_to_line": null,
          "vulnerability_code": "    if (expected() != NextFunction.EMIT_LOG)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_REVERT_REQUIRE",
          "vulnerability_from_line": 483,
          "vulnerability_to_line": null,
          "vulnerability_code": "    else if (expected() == NextFunction.VAL_DEC)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_REVERT_REQUIRE",
          "vulnerability_from_line": 506,
          "vulnerability_to_line": null,
          "vulnerability_code": "    if (expected() == NextFunction.VAL_DEC) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SAFEMATH",
          "vulnerability_from_line": 50,
          "vulnerability_to_line": null,
          "vulnerability_code": "  using SafeMath for uint;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 138,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function commit() conditions(validState, none) internal pure {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 155,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function validState() private pure {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 166,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function buffPtr() private pure returns (bytes32 ptr) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 171,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function freeMem() private pure returns (bytes32 ptr) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 176,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function currentAction() private pure returns (bytes4 action) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 202,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function startBuffer() private pure {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 259,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function execID() internal pure returns (bytes32 exec_id) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 265,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function sender() internal pure returns (address addr) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 346,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function storing() conditions(validStoreBuff, isStoring) internal pure {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 369,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function set(bytes32 _field) conditions(validStoreDest, validStoreVal) internal pure returns (bytes32) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 393,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function to(bytes32, bytes32 _val) conditions(validStoreVal, validStoreDest) internal pure {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 478,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function by(bytes32 _val, uint _amt) conditions(validStoreVal, validStoreDest) internal pure {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 503,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function byMaximum(bytes32 _val, uint _amt) conditions(validStoreVal, validStoreDest) internal pure {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 531,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function emitting() conditions(validEmitBuff, isEmitting) internal pure {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 553,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function log(bytes32 _data) conditions(validEvent, validEvent) internal pure {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 586,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function log(bytes32[1] memory _topics, bytes32 _data) conditions(validEvent, validEvent) internal pure {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 621,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function log(bytes32[2] memory _topics, bytes32 _data) conditions(validEvent, validEvent) internal pure {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 657,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function log(bytes32[3] memory _topics, bytes32 _data) conditions(validEvent, validEvent) internal pure {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 694,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function log(bytes32[4] memory _topics, bytes32 _data) conditions(validEvent, validEvent) internal pure {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 734,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function paying() conditions(validPayBuff, isPaying) internal pure {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 757,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function pay(uint _amount) conditions(validPayAmt, validPayDest) internal pure returns (uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 781,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function toAcc(uint, address _dest) conditions(validPayDest, validPayAmt) internal pure {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 797,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function setFreeMem() private pure {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 802,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function expected() private pure returns (NextFunction next) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 807,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function emitted() internal pure returns (uint num_emitted) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 816,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function stored() internal pure returns (uint num_stored) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 825,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function paid() internal pure returns (uint num_paid) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
          "vulnerability_from_line": 71,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function authorize(address _script_exec) internal view {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
          "vulnerability_from_line": 102,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function initialize() internal view {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
          "vulnerability_from_line": 274,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function read(bytes32 _location) internal view returns (bytes32 data) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
          "vulnerability_from_line": 426,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function increase(bytes32 _field) conditions(validStoreDest, validStoreVal) internal view returns (bytes32 val) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
          "vulnerability_from_line": 452,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function decrease(bytes32 _field) conditions(validStoreDest, validStoreVal) internal view returns (bytes32 val) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 275,
          "vulnerability_to_line": null,
          "vulnerability_code": "    data = keccak256(_location, execID());\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 428,
          "vulnerability_to_line": null,
          "vulnerability_code": "    val = keccak256(_field, execID());\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 454,
          "vulnerability_to_line": null,
          "vulnerability_code": "    val = keccak256(_field, execID());\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 78,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 107,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 143,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 167,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly { ptr := mload(0xc0) }\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 172,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly { ptr := mload(0x40) }\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 180,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly { action := mload(0xe0) }\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 203,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 260,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly { exec_id := mload(0x80) }\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 266,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly { addr := mload(0xa0) }\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 276,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly { data := sload(data) }\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 348,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 370,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 394,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 429,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 455,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 488,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 515,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 533,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 554,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 587,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 622,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 658,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 695,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 736,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 758,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 782,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 798,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly { mstore(0x40, msize) }\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 803,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly { next := mload(0x100) }\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 812,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly { num_emitted := mload(0x140) }\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 821,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly { num_stored := mload(0x120) }\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 830,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly { num_paid := mload(0x160) }\n",
          "message": null
        }
      ]
    },
    "oyente": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": []
    },
    "mythril": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": []
    },
    "osiris": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": []
    }
  }
}