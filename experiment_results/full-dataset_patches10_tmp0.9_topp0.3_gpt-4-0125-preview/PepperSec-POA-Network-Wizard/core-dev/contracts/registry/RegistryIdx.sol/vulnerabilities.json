{
  "smartbugs_completed": true,
  "analyzer_results": {
    "semgrep": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 15,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require(c / a == b, \"Overflow - Multiplication\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 30,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require(b <= a, \"Underflow - Subtraction\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 39,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require(c >= a, \"Overflow - Addition\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 90,
          "vulnerability_to_line": null,
          "vulnerability_code": "      revert(\"Sender is not authorized as a script exec address\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 105,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require(freeMem() == 0x80, \"Memory allocated prior to execution\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 141,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require(ptr >= 0x180, \"Invalid buffer pointer\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 157,
          "vulnerability_to_line": null,
          "vulnerability_code": "      revert('Expected Contract.execute()');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 160,
          "vulnerability_to_line": null,
          "vulnerability_code": "      revert('Invalid buffer pointer');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 186,
          "vulnerability_to_line": null,
          "vulnerability_code": "      revert('Invalid current action - expected STORES');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 192,
          "vulnerability_to_line": null,
          "vulnerability_code": "      revert('Invalid current action - expected EMITS');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 198,
          "vulnerability_to_line": null,
          "vulnerability_code": "      revert('Invalid current action - expected PAYS');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 226,
          "vulnerability_to_line": null,
          "vulnerability_code": "      revert('Duplicate request - stores');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 238,
          "vulnerability_to_line": null,
          "vulnerability_code": "      revert('Duplicate request - emits');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 250,
          "vulnerability_to_line": null,
          "vulnerability_code": "      revert('Duplicate request - pays');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 261,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require(exec_id != bytes32(0), \"Execution id overwritten, or not read\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 267,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require(addr != address(0), \"Sender address overwritten, or not read\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 295,
          "vulnerability_to_line": null,
          "vulnerability_code": "      revert('Unexpected function order - expected storage destination to be pushed');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 308,
          "vulnerability_to_line": null,
          "vulnerability_code": "    ) revert('Unexpected function order - expected storage value to be pushed');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 318,
          "vulnerability_to_line": null,
          "vulnerability_code": "      revert('Unexpected function order - expected payment destination to be pushed');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 328,
          "vulnerability_to_line": null,
          "vulnerability_code": "      revert('Unexpected function order - expected payment amount to be pushed');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 338,
          "vulnerability_to_line": null,
          "vulnerability_code": "      revert('Unexpected function order - expected event to be pushed');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 486,
          "vulnerability_to_line": null,
          "vulnerability_code": "      revert('Expected VAL_INC or VAL_DEC');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 512,
          "vulnerability_to_line": null,
          "vulnerability_code": "      revert('Expected VAL_DEC');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 159,
          "vulnerability_to_line": null,
          "vulnerability_code": "    if (buffPtr() != 0 && buffPtr() < 0x180)\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 160,
          "vulnerability_to_line": null,
          "vulnerability_code": "      revert('Invalid buffer pointer');\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 304,
          "vulnerability_to_line": null,
          "vulnerability_code": "    if (\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 305,
          "vulnerability_to_line": null,
          "vulnerability_code": "      expected() != NextFunction.VAL_SET &&\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 306,
          "vulnerability_to_line": null,
          "vulnerability_code": "      expected() != NextFunction.VAL_INC &&\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 307,
          "vulnerability_to_line": null,
          "vulnerability_code": "      expected() != NextFunction.VAL_DEC\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 308,
          "vulnerability_to_line": null,
          "vulnerability_code": "    ) revert('Unexpected function order - expected storage value to be pushed');\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 927,
          "vulnerability_to_line": null,
          "vulnerability_code": "    for (uint i = 1; i <= length; i++)\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 941,
          "vulnerability_to_line": null,
          "vulnerability_code": "    for (uint i = 1; i <= length; i++)\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 971,
          "vulnerability_to_line": null,
          "vulnerability_code": "    for (uint i = 1; i <= length; i++)\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 977,
          "vulnerability_to_line": null,
          "vulnerability_code": "    for (i = 1; i <= length; i++)\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 90,
          "vulnerability_to_line": null,
          "vulnerability_code": "      revert(\"Sender is not authorized as a script exec address\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 105,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require(freeMem() == 0x80, \"Memory allocated prior to execution\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 186,
          "vulnerability_to_line": null,
          "vulnerability_code": "      revert('Invalid current action - expected STORES');\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 192,
          "vulnerability_to_line": null,
          "vulnerability_code": "      revert('Invalid current action - expected EMITS');\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 198,
          "vulnerability_to_line": null,
          "vulnerability_code": "      revert('Invalid current action - expected PAYS');\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 261,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require(exec_id != bytes32(0), \"Execution id overwritten, or not read\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 267,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require(addr != address(0), \"Sender address overwritten, or not read\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 295,
          "vulnerability_to_line": null,
          "vulnerability_code": "      revert('Unexpected function order - expected storage destination to be pushed');\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 308,
          "vulnerability_to_line": null,
          "vulnerability_code": "    ) revert('Unexpected function order - expected storage value to be pushed');\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 318,
          "vulnerability_to_line": null,
          "vulnerability_code": "      revert('Unexpected function order - expected payment destination to be pushed');\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 328,
          "vulnerability_to_line": null,
          "vulnerability_code": "      revert('Unexpected function order - expected payment amount to be pushed');\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 338,
          "vulnerability_to_line": null,
          "vulnerability_code": "      revert('Unexpected function order - expected event to be pushed');\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        }
      ]
    },
    "slither": {
      "successfull_analysis": true,
      "errors": [
        "DOCKER_INVOCATION_PROBLEM"
      ],
      "vulnerability_findings": [
        {
          "name": "constant-function",
          "vulnerability_from_line": 71,
          "vulnerability_to_line": 91,
          "vulnerability_code": "  function authorize(address _script_exec) internal view {\n\n    // Initialize memory\n\n    initialize();\n\n\n\n    // Check that the sender is authorized as a script exec contract for this exec id\n\n    bytes32 perms = EXEC_PERMISSIONS;\n\n    bool authorized;\n\n    assembly {\n\n      // Place the script exec address at 0, and the exec permissions seed after it\n\n      mstore(0, _script_exec)\n\n      mstore(0x20, perms)\n\n      // Hash the resulting 0x34 bytes, and place back into memory at 0\n\n      mstore(0, keccak256(0x0c, 0x34))\n\n      // Place the exec id after the hash -\n\n      mstore(0x20, mload(0x80))\n\n      // Hash the previous hash with the execution id, and check the result\n\n      authorized := sload(keccak256(0, 0x40))\n\n    }\n\n    if (!authorized)\n\n      revert(\"Sender is not authorized as a script exec address\");\n",
          "message": "Contract.authorize (RegistryIdx.sol#71-91) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 102,
          "vulnerability_to_line": 122,
          "vulnerability_code": "  function initialize() internal view {\n\n    // No memory should have been allocated yet - expect the free memory pointer\n\n    // to point to 0x80 - and throw if it does not\n\n    require(freeMem() == 0x80, \"Memory allocated prior to execution\");\n\n    // Next, set up memory for execution\n\n    assembly {\n\n      mstore(0x80, sload(0))     // Execution id, read from storage\n\n      mstore(0xa0, sload(1))     // Original sender address, read from storage\n\n      mstore(0xc0, 0)            // Pointer to storage buffer\n\n      mstore(0xe0, 0)            // Bytes4 value of the current action requestor being used\n\n      mstore(0x100, 0)           // Enum representing the next type of function to be called (when pushing to buffer)\n\n      mstore(0x120, 0)           // Number of storage slots written to in buffer\n\n      mstore(0x140, 0)           // Number of events pushed to buffer\n\n      mstore(0x160, 0)           // Number of payment destinations pushed to buffer\n\n\n\n      // Update free memory pointer -\n\n      mstore(0x40, 0x180)\n\n    }\n\n    // Ensure that the sender and execution id returned from storage are expected values -\n\n    assert(execID() != bytes32(0) && sender() != address(0));\n",
          "message": "Contract.initialize (RegistryIdx.sol#102-122) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 138,
          "vulnerability_to_line": 150,
          "vulnerability_code": "  function commit() conditions(validState, none) internal pure {\n\n    // Check value of storage buffer pointer - should be at least 0x180\n\n    bytes32 ptr = buffPtr();\n\n    require(ptr >= 0x180, \"Invalid buffer pointer\");\n\n\n\n    assembly {\n\n      // Get the size of the buffer\n\n      let size := mload(add(0x20, ptr))\n\n      mstore(ptr, 0x20) // Place dynamic data offset before buffer\n\n      // Revert to storage\n\n      revert(ptr, add(0x40, size))\n\n    }\n",
          "message": "Contract.commit (RegistryIdx.sol#138-150) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 166,
          "vulnerability_to_line": 168,
          "vulnerability_code": "  function buffPtr() private pure returns (bytes32 ptr) {\n\n    assembly { ptr := mload(0xc0) }\n",
          "message": "Contract.buffPtr (RegistryIdx.sol#166-168) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 171,
          "vulnerability_to_line": 173,
          "vulnerability_code": "  function freeMem() private pure returns (bytes32 ptr) {\n\n    assembly { ptr := mload(0x40) }\n",
          "message": "Contract.freeMem (RegistryIdx.sol#171-173) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 176,
          "vulnerability_to_line": 181,
          "vulnerability_code": "  function currentAction() private pure returns (bytes4 action) {\n\n    if (buffPtr() == bytes32(0))\n\n      return bytes4(0);\n\n\n\n    assembly { action := mload(0xe0) }\n",
          "message": "Contract.currentAction (RegistryIdx.sol#176-181) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 202,
          "vulnerability_to_line": 215,
          "vulnerability_code": "  function startBuffer() private pure {\n\n    assembly {\n\n      // Get a pointer to free memory, and place at 0xc0 (storage buffer pointer)\n\n      let ptr := msize()\n\n      mstore(0xc0, ptr)\n\n      // Clear bytes at pointer -\n\n      mstore(ptr, 0)            // temp ptr\n\n      mstore(add(0x20, ptr), 0) // buffer length\n\n      // Update free memory pointer -\n\n      mstore(0x40, add(0x40, ptr))\n\n      // Set expected next function to 'NONE' -\n\n      mstore(0x100, 1)\n\n    }\n",
          "message": "Contract.startBuffer (RegistryIdx.sol#202-215) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 259,
          "vulnerability_to_line": 262,
          "vulnerability_code": "  function execID() internal pure returns (bytes32 exec_id) {\n\n    assembly { exec_id := mload(0x80) }\n\n    require(exec_id != bytes32(0), \"Execution id overwritten, or not read\");\n",
          "message": "Contract.execID (RegistryIdx.sol#259-262) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 265,
          "vulnerability_to_line": 268,
          "vulnerability_code": "  function sender() internal pure returns (address addr) {\n\n    assembly { addr := mload(0xa0) }\n\n    require(addr != address(0), \"Sender address overwritten, or not read\");\n",
          "message": "Contract.sender (RegistryIdx.sol#265-268) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 274,
          "vulnerability_to_line": 277,
          "vulnerability_code": "  function read(bytes32 _location) internal view returns (bytes32 data) {\n\n    data = keccak256(_location, execID());\n\n    assembly { data := sload(data) }\n",
          "message": "Contract.read (RegistryIdx.sol#274-277) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 346,
          "vulnerability_to_line": 366,
          "vulnerability_code": "  function storing() conditions(validStoreBuff, isStoring) internal pure {\n\n    bytes4 action_req = STORES;\n\n    assembly {\n\n      // Get pointer to buffer length -\n\n      let ptr := add(0x20, mload(0xc0))\n\n      // Push requestor to the end of buffer, as well as to the 'current action' slot -\n\n      mstore(add(0x20, add(ptr, mload(ptr))), action_req)\n\n      // Push '0' to the end of the 4 bytes just pushed - this will be the length of the STORES action\n\n      mstore(add(0x24, add(ptr, mload(ptr))), 0)\n\n      // Increment buffer length - 0x24 plus the previous length\n\n      mstore(ptr, add(0x24, mload(ptr)))\n\n      // Set the current action being executed (STORES) -\n\n      mstore(0xe0, action_req)\n\n      // Set the expected next function - STORE_DEST\n\n      mstore(0x100, 2)\n\n      // Set a pointer to the length of the current request within the buffer\n\n      mstore(sub(ptr, 0x20), add(ptr, mload(ptr)))\n\n    }\n\n    // Update free memory pointer\n\n    setFreeMem();\n",
          "message": "Contract.storing (RegistryIdx.sol#346-366) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 369,
          "vulnerability_to_line": 390,
          "vulnerability_code": "  function set(bytes32 _field) conditions(validStoreDest, validStoreVal) internal pure returns (bytes32) {\n\n    assembly {\n\n      // Get pointer to buffer length -\n\n      let ptr := add(0x20, mload(0xc0))\n\n      // Push storage destination to the end of the buffer -\n\n      mstore(add(0x20, add(ptr, mload(ptr))), _field)\n\n      // Increment buffer length - 0x20 plus the previous length\n\n      mstore(ptr, add(0x20, mload(ptr)))\n\n      // Set the expected next function - VAL_SET\n\n      mstore(0x100, 3)\n\n      // Increment STORES action length -\n\n      mstore(\n\n        mload(sub(ptr, 0x20)),\n\n        add(1, mload(mload(sub(ptr, 0x20))))\n\n      )\n\n      // Update number of storage slots pushed to -\n\n      mstore(0x120, add(1, mload(0x120)))\n\n    }\n\n    // Update free memory pointer\n\n    setFreeMem();\n\n    return _field;\n",
          "message": "Contract.set (RegistryIdx.sol#369-390) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 393,
          "vulnerability_to_line": 406,
          "vulnerability_code": "  function to(bytes32, bytes32 _val) conditions(validStoreVal, validStoreDest) internal pure {\n\n    assembly {\n\n      // Get pointer to buffer length -\n\n      let ptr := add(0x20, mload(0xc0))\n\n      // Push storage value to the end of the buffer -\n\n      mstore(add(0x20, add(ptr, mload(ptr))), _val)\n\n      // Increment buffer length - 0x20 plus the previous length\n\n      mstore(ptr, add(0x20, mload(ptr)))\n\n      // Set the expected next function - STORE_DEST\n\n      mstore(0x100, 2)\n\n    }\n\n    // Update free memory pointer\n\n    setFreeMem();\n",
          "message": "Contract.to (RegistryIdx.sol#393-406) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 426,
          "vulnerability_to_line": 450,
          "vulnerability_code": "  function increase(bytes32 _field) conditions(validStoreDest, validStoreVal) internal view returns (bytes32 val) {\n\n    // Read value stored at the location in storage -\n\n    val = keccak256(_field, execID());\n\n    assembly {\n\n      val := sload(val)\n\n      // Get pointer to buffer length -\n\n      let ptr := add(0x20, mload(0xc0))\n\n      // Push storage destination to the end of the buffer -\n\n      mstore(add(0x20, add(ptr, mload(ptr))), _field)\n\n      // Increment buffer length - 0x20 plus the previous length\n\n      mstore(ptr, add(0x20, mload(ptr)))\n\n      // Set the expected next function - VAL_INC\n\n      mstore(0x100, 4)\n\n      // Increment STORES action length -\n\n      mstore(\n\n        mload(sub(ptr, 0x20)),\n\n        add(1, mload(mload(sub(ptr, 0x20))))\n\n      )\n\n      // Update number of storage slots pushed to -\n\n      mstore(0x120, add(1, mload(0x120)))\n\n    }\n\n    // Update free memory pointer\n\n    setFreeMem();\n\n    return val;\n",
          "message": "Contract.increase (RegistryIdx.sol#426-450) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 452,
          "vulnerability_to_line": 476,
          "vulnerability_code": "  function decrease(bytes32 _field) conditions(validStoreDest, validStoreVal) internal view returns (bytes32 val) {\n\n    // Read value stored at the location in storage -\n\n    val = keccak256(_field, execID());\n\n    assembly {\n\n      val := sload(val)\n\n      // Get pointer to buffer length -\n\n      let ptr := add(0x20, mload(0xc0))\n\n      // Push storage destination to the end of the buffer -\n\n      mstore(add(0x20, add(ptr, mload(ptr))), _field)\n\n      // Increment buffer length - 0x20 plus the previous length\n\n      mstore(ptr, add(0x20, mload(ptr)))\n\n      // Set the expected next function - VAL_DEC\n\n      mstore(0x100, 5)\n\n      // Increment STORES action length -\n\n      mstore(\n\n        mload(sub(ptr, 0x20)),\n\n        add(1, mload(mload(sub(ptr, 0x20))))\n\n      )\n\n      // Update number of storage slots pushed to -\n\n      mstore(0x120, add(1, mload(0x120)))\n\n    }\n\n    // Update free memory pointer\n\n    setFreeMem();\n\n    return val;\n",
          "message": "Contract.decrease (RegistryIdx.sol#452-476) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 478,
          "vulnerability_to_line": 500,
          "vulnerability_code": "  function by(bytes32 _val, uint _amt) conditions(validStoreVal, validStoreDest) internal pure {\n\n    // Check the expected function type - if it is VAL_INC, perform safe-add on the value\n\n    // If it is VAL_DEC, perform safe-sub on the value\n\n    if (expected() == NextFunction.VAL_INC)\n\n      _amt = _amt.add(uint(_val));\n\n    else if (expected() == NextFunction.VAL_DEC)\n\n      _amt = uint(_val).sub(_amt);\n\n    else\n\n      revert('Expected VAL_INC or VAL_DEC');\n\n\n\n    assembly {\n\n      // Get pointer to buffer length -\n\n      let ptr := add(0x20, mload(0xc0))\n\n      // Push storage value to the end of the buffer -\n\n      mstore(add(0x20, add(ptr, mload(ptr))), _amt)\n\n      // Increment buffer length - 0x20 plus the previous length\n\n      mstore(ptr, add(0x20, mload(ptr)))\n\n      // Set the expected next function - STORE_DEST\n\n      mstore(0x100, 2)\n\n    }\n\n    // Update free memory pointer\n\n    setFreeMem();\n",
          "message": "Contract.by (RegistryIdx.sol#478-500) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 503,
          "vulnerability_to_line": 527,
          "vulnerability_code": "  function byMaximum(bytes32 _val, uint _amt) conditions(validStoreVal, validStoreDest) internal pure {\n\n    // Check the expected function type - if it is VAL_DEC, set the new amount to the difference of\n\n    // _val and _amt, to a minimum of 0\n\n    if (expected() == NextFunction.VAL_DEC) {\n\n      if (_amt >= uint(_val))\n\n        _amt = 0;\n\n      else\n\n        _amt = uint(_val).sub(_amt);\n\n    } else {\n\n      revert('Expected VAL_DEC');\n\n    }\n\n\n\n    assembly {\n\n      // Get pointer to buffer length -\n\n      let ptr := add(0x20, mload(0xc0))\n\n      // Push storage value to the end of the buffer -\n\n      mstore(add(0x20, add(ptr, mload(ptr))), _amt)\n\n      // Increment buffer length - 0x20 plus the previous length\n\n      mstore(ptr, add(0x20, mload(ptr)))\n\n      // Set the expected next function - STORE_DEST\n\n      mstore(0x100, 2)\n\n    }\n\n    // Update free memory pointer\n\n    setFreeMem();\n",
          "message": "Contract.byMaximum (RegistryIdx.sol#503-527) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 531,
          "vulnerability_to_line": 551,
          "vulnerability_code": "  function emitting() conditions(validEmitBuff, isEmitting) internal pure {\n\n    bytes4 action_req = EMITS;\n\n    assembly {\n\n      // Get pointer to buffer length -\n\n      let ptr := add(0x20, mload(0xc0))\n\n      // Push requestor to the end of buffer, as well as to the 'current action' slot -\n\n      mstore(add(0x20, add(ptr, mload(ptr))), action_req)\n\n      // Push '0' to the end of the 4 bytes just pushed - this will be the length of the EMITS action\n\n      mstore(add(0x24, add(ptr, mload(ptr))), 0)\n\n      // Increment buffer length - 0x24 plus the previous length\n\n      mstore(ptr, add(0x24, mload(ptr)))\n\n      // Set the current action being executed (EMITS) -\n\n      mstore(0xe0, action_req)\n\n      // Set the expected next function - EMIT_LOG\n\n      mstore(0x100, 6)\n\n      // Set a pointer to the length of the current request within the buffer\n\n      mstore(sub(ptr, 0x20), add(ptr, mload(ptr)))\n\n    }\n\n    // Update free memory pointer\n\n    setFreeMem();\n",
          "message": "Contract.emitting (RegistryIdx.sol#531-551) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 553,
          "vulnerability_to_line": 584,
          "vulnerability_code": "  function log(bytes32 _data) conditions(validEvent, validEvent) internal pure {\n\n    assembly {\n\n      // Get pointer to buffer length -\n\n      let ptr := add(0x20, mload(0xc0))\n\n      // Push 0 to the end of the buffer - event will have 0 topics\n\n      mstore(add(0x20, add(ptr, mload(ptr))), 0)\n\n      // If _data is zero, set data size to 0 in buffer and push -\n\n      if eq(_data, 0) {\n\n        mstore(add(0x40, add(ptr, mload(ptr))), 0)\n\n        // Increment buffer length - 0x40 plus the original length\n\n        mstore(ptr, add(0x40, mload(ptr)))\n\n      }\n\n      // If _data is not zero, set size to 0x20 and push to buffer -\n\n      if iszero(eq(_data, 0)) {\n\n        // Push data size (0x20) to the end of the buffer\n\n        mstore(add(0x40, add(ptr, mload(ptr))), 0x20)\n\n        // Push data to the end of the buffer\n\n        mstore(add(0x60, add(ptr, mload(ptr))), _data)\n\n        // Increment buffer length - 0x60 plus the original length\n\n        mstore(ptr, add(0x60, mload(ptr)))\n\n      }\n\n      // Increment EMITS action length -\n\n      mstore(\n\n        mload(sub(ptr, 0x20)),\n\n        add(1, mload(mload(sub(ptr, 0x20))))\n\n      )\n\n      // Update number of events pushed to buffer -\n\n      mstore(0x140, add(1, mload(0x140)))\n\n    }\n\n    // Update free memory pointer\n\n    setFreeMem();\n",
          "message": "Contract.log (RegistryIdx.sol#553-584) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 586,
          "vulnerability_to_line": 619,
          "vulnerability_code": "  function log(bytes32[1] memory _topics, bytes32 _data) conditions(validEvent, validEvent) internal pure {\n\n    assembly {\n\n      // Get pointer to buffer length -\n\n      let ptr := add(0x20, mload(0xc0))\n\n      // Push 1 to the end of the buffer - event will have 1 topic\n\n      mstore(add(0x20, add(ptr, mload(ptr))), 1)\n\n      // Push topic to end of buffer\n\n      mstore(add(0x40, add(ptr, mload(ptr))), mload(_topics))\n\n      // If _data is zero, set data size to 0 in buffer and push -\n\n      if eq(_data, 0) {\n\n        mstore(add(0x60, add(ptr, mload(ptr))), 0)\n\n        // Increment buffer length - 0x60 plus the original length\n\n        mstore(ptr, add(0x60, mload(ptr)))\n\n      }\n\n      // If _data is not zero, set size to 0x20 and push to buffer -\n\n      if iszero(eq(_data, 0)) {\n\n        // Push data size (0x20) to the end of the buffer\n\n        mstore(add(0x60, add(ptr, mload(ptr))), 0x20)\n\n        // Push data to the end of the buffer\n\n        mstore(add(0x80, add(ptr, mload(ptr))), _data)\n\n        // Increment buffer length - 0x80 plus the original length\n\n        mstore(ptr, add(0x80, mload(ptr)))\n\n      }\n\n      // Increment EMITS action length -\n\n      mstore(\n\n        mload(sub(ptr, 0x20)),\n\n        add(1, mload(mload(sub(ptr, 0x20))))\n\n      )\n\n      // Update number of events pushed to buffer -\n\n      mstore(0x140, add(1, mload(0x140)))\n\n    }\n\n    // Update free memory pointer\n\n    setFreeMem();\n",
          "message": "Contract.log (RegistryIdx.sol#586-619) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 621,
          "vulnerability_to_line": 655,
          "vulnerability_code": "  function log(bytes32[2] memory _topics, bytes32 _data) conditions(validEvent, validEvent) internal pure {\n\n    assembly {\n\n      // Get pointer to buffer length -\n\n      let ptr := add(0x20, mload(0xc0))\n\n      // Push 2 to the end of the buffer - event will have 2 topics\n\n      mstore(add(0x20, add(ptr, mload(ptr))), 2)\n\n      // Push topics to end of buffer\n\n      mstore(add(0x40, add(ptr, mload(ptr))), mload(_topics))\n\n      mstore(add(0x60, add(ptr, mload(ptr))), mload(add(0x20, _topics)))\n\n      // If _data is zero, set data size to 0 in buffer and push -\n\n      if eq(_data, 0) {\n\n        mstore(add(0x80, add(ptr, mload(ptr))), 0)\n\n        // Increment buffer length - 0x80 plus the original length\n\n        mstore(ptr, add(0x80, mload(ptr)))\n\n      }\n\n      // If _data is not zero, set size to 0x20 and push to buffer -\n\n      if iszero(eq(_data, 0)) {\n\n        // Push data size (0x20) to the end of the buffer\n\n        mstore(add(0x80, add(ptr, mload(ptr))), 0x20)\n\n        // Push data to the end of the buffer\n\n        mstore(add(0xa0, add(ptr, mload(ptr))), _data)\n\n        // Increment buffer length - 0xa0 plus the original length\n\n        mstore(ptr, add(0xa0, mload(ptr)))\n\n      }\n\n      // Increment EMITS action length -\n\n      mstore(\n\n        mload(sub(ptr, 0x20)),\n\n        add(1, mload(mload(sub(ptr, 0x20))))\n\n      )\n\n      // Update number of events pushed to buffer -\n\n      mstore(0x140, add(1, mload(0x140)))\n\n    }\n\n    // Update free memory pointer\n\n    setFreeMem();\n",
          "message": "Contract.log (RegistryIdx.sol#621-655) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 657,
          "vulnerability_to_line": 692,
          "vulnerability_code": "  function log(bytes32[3] memory _topics, bytes32 _data) conditions(validEvent, validEvent) internal pure {\n\n    assembly {\n\n      // Get pointer to buffer length -\n\n      let ptr := add(0x20, mload(0xc0))\n\n      // Push 3 to the end of the buffer - event will have 3 topics\n\n      mstore(add(0x20, add(ptr, mload(ptr))), 3)\n\n      // Push topics to end of buffer\n\n      mstore(add(0x40, add(ptr, mload(ptr))), mload(_topics))\n\n      mstore(add(0x60, add(ptr, mload(ptr))), mload(add(0x20, _topics)))\n\n      mstore(add(0x80, add(ptr, mload(ptr))), mload(add(0x40, _topics)))\n\n      // If _data is zero, set data size to 0 in buffer and push -\n\n      if eq(_data, 0) {\n\n        mstore(add(0xa0, add(ptr, mload(ptr))), 0)\n\n        // Increment buffer length - 0xa0 plus the original length\n\n        mstore(ptr, add(0xa0, mload(ptr)))\n\n      }\n\n      // If _data is not zero, set size to 0x20 and push to buffer -\n\n      if iszero(eq(_data, 0)) {\n\n        // Push data size (0x20) to the end of the buffer\n\n        mstore(add(0xa0, add(ptr, mload(ptr))), 0x20)\n\n        // Push data to the end of the buffer\n\n        mstore(add(0xc0, add(ptr, mload(ptr))), _data)\n\n        // Increment buffer length - 0xc0 plus the original length\n\n        mstore(ptr, add(0xc0, mload(ptr)))\n\n      }\n\n      // Increment EMITS action length -\n\n      mstore(\n\n        mload(sub(ptr, 0x20)),\n\n        add(1, mload(mload(sub(ptr, 0x20))))\n\n      )\n\n      // Update number of events pushed to buffer -\n\n      mstore(0x140, add(1, mload(0x140)))\n\n    }\n\n    // Update free memory pointer\n\n    setFreeMem();\n",
          "message": "Contract.log (RegistryIdx.sol#657-692) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 694,
          "vulnerability_to_line": 730,
          "vulnerability_code": "  function log(bytes32[4] memory _topics, bytes32 _data) conditions(validEvent, validEvent) internal pure {\n\n    assembly {\n\n      // Get pointer to buffer length -\n\n      let ptr := add(0x20, mload(0xc0))\n\n      // Push 4 to the end of the buffer - event will have 4 topics\n\n      mstore(add(0x20, add(ptr, mload(ptr))), 4)\n\n      // Push topics to end of buffer\n\n      mstore(add(0x40, add(ptr, mload(ptr))), mload(_topics))\n\n      mstore(add(0x60, add(ptr, mload(ptr))), mload(add(0x20, _topics)))\n\n      mstore(add(0x80, add(ptr, mload(ptr))), mload(add(0x40, _topics)))\n\n      mstore(add(0xa0, add(ptr, mload(ptr))), mload(add(0x60, _topics)))\n\n      // If _data is zero, set data size to 0 in buffer and push -\n\n      if eq(_data, 0) {\n\n        mstore(add(0xc0, add(ptr, mload(ptr))), 0)\n\n        // Increment buffer length - 0xc0 plus the original length\n\n        mstore(ptr, add(0xc0, mload(ptr)))\n\n      }\n\n      // If _data is not zero, set size to 0x20 and push to buffer -\n\n      if iszero(eq(_data, 0)) {\n\n        // Push data size (0x20) to the end of the buffer\n\n        mstore(add(0xc0, add(ptr, mload(ptr))), 0x20)\n\n        // Push data to the end of the buffer\n\n        mstore(add(0xe0, add(ptr, mload(ptr))), _data)\n\n        // Increment buffer length - 0xe0 plus the original length\n\n        mstore(ptr, add(0xe0, mload(ptr)))\n\n      }\n\n      // Increment EMITS action length -\n\n      mstore(\n\n        mload(sub(ptr, 0x20)),\n\n        add(1, mload(mload(sub(ptr, 0x20))))\n\n      )\n\n      // Update number of events pushed to buffer -\n\n      mstore(0x140, add(1, mload(0x140)))\n\n    }\n\n    // Update free memory pointer\n\n    setFreeMem();\n",
          "message": "Contract.log (RegistryIdx.sol#694-730) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 734,
          "vulnerability_to_line": 754,
          "vulnerability_code": "  function paying() conditions(validPayBuff, isPaying) internal pure {\n\n    bytes4 action_req = PAYS;\n\n    assembly {\n\n      // Get pointer to buffer length -\n\n      let ptr := add(0x20, mload(0xc0))\n\n      // Push requestor to the end of buffer, as well as to the 'current action' slot -\n\n      mstore(add(0x20, add(ptr, mload(ptr))), action_req)\n\n      // Push '0' to the end of the 4 bytes just pushed - this will be the length of the PAYS action\n\n      mstore(add(0x24, add(ptr, mload(ptr))), 0)\n\n      // Increment buffer length - 0x24 plus the previous length\n\n      mstore(ptr, add(0x24, mload(ptr)))\n\n      // Set the current action being executed (PAYS) -\n\n      mstore(0xe0, action_req)\n\n      // Set the expected next function - PAY_AMT\n\n      mstore(0x100, 8)\n\n      // Set a pointer to the length of the current request within the buffer\n\n      mstore(sub(ptr, 0x20), add(ptr, mload(ptr)))\n\n    }\n\n    // Update free memory pointer\n\n    setFreeMem();\n",
          "message": "Contract.paying (RegistryIdx.sol#734-754) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 757,
          "vulnerability_to_line": 778,
          "vulnerability_code": "  function pay(uint _amount) conditions(validPayAmt, validPayDest) internal pure returns (uint) {\n\n    assembly {\n\n      // Get pointer to buffer length -\n\n      let ptr := add(0x20, mload(0xc0))\n\n      // Push payment amount to the end of the buffer -\n\n      mstore(add(0x20, add(ptr, mload(ptr))), _amount)\n\n      // Increment buffer length - 0x20 plus the previous length\n\n      mstore(ptr, add(0x20, mload(ptr)))\n\n      // Set the expected next function - PAY_DEST\n\n      mstore(0x100, 7)\n\n      // Increment PAYS action length -\n\n      mstore(\n\n        mload(sub(ptr, 0x20)),\n\n        add(1, mload(mload(sub(ptr, 0x20))))\n\n      )\n\n      // Update number of payment destinations to be pushed to -\n\n      mstore(0x160, add(1, mload(0x160)))\n\n    }\n\n    // Update free memory pointer\n\n    setFreeMem();\n\n    return _amount;\n",
          "message": "Contract.pay (RegistryIdx.sol#757-778) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 781,
          "vulnerability_to_line": 794,
          "vulnerability_code": "  function toAcc(uint, address _dest) conditions(validPayDest, validPayAmt) internal pure {\n\n    assembly {\n\n      // Get pointer to buffer length -\n\n      let ptr := add(0x20, mload(0xc0))\n\n      // Push payment destination to the end of the buffer -\n\n      mstore(add(0x20, add(ptr, mload(ptr))), _dest)\n\n      // Increment buffer length - 0x20 plus the previous length\n\n      mstore(ptr, add(0x20, mload(ptr)))\n\n      // Set the expected next function - PAY_AMT\n\n      mstore(0x100, 8)\n\n    }\n\n    // Update free memory pointer\n\n    setFreeMem();\n",
          "message": "Contract.toAcc (RegistryIdx.sol#781-794) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 797,
          "vulnerability_to_line": 799,
          "vulnerability_code": "  function setFreeMem() private pure {\n\n    assembly { mstore(0x40, msize) }\n",
          "message": "Contract.setFreeMem (RegistryIdx.sol#797-799) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 802,
          "vulnerability_to_line": 804,
          "vulnerability_code": "  function expected() private pure returns (NextFunction next) {\n\n    assembly { next := mload(0x100) }\n",
          "message": "Contract.expected (RegistryIdx.sol#802-804) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 807,
          "vulnerability_to_line": 813,
          "vulnerability_code": "  function emitted() internal pure returns (uint num_emitted) {\n\n    if (buffPtr() == bytes32(0))\n\n      return 0;\n\n\n\n    // Load number emitted from buffer -\n\n    assembly { num_emitted := mload(0x140) }\n",
          "message": "Contract.emitted (RegistryIdx.sol#807-813) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 816,
          "vulnerability_to_line": 822,
          "vulnerability_code": "  function stored() internal pure returns (uint num_stored) {\n\n    if (buffPtr() == bytes32(0))\n\n      return 0;\n\n\n\n    // Load number stored from buffer -\n\n    assembly { num_stored := mload(0x120) }\n",
          "message": "Contract.stored (RegistryIdx.sol#816-822) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 825,
          "vulnerability_to_line": 831,
          "vulnerability_code": "  function paid() internal pure returns (uint num_paid) {\n\n    if (buffPtr() == bytes32(0))\n\n      return 0;\n\n\n\n    // Load number paid from buffer -\n\n    assembly { num_paid := mload(0x160) }\n",
          "message": "Contract.paid (RegistryIdx.sol#825-831) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 849,
          "vulnerability_to_line": 851,
          "vulnerability_code": "  function toBytes4Arr(bytes32[] memory _arr) internal pure returns (bytes4[] memory _conv) {\n\n    assembly { _conv := _arr }\n",
          "message": "ArrayUtils.toBytes4Arr (RegistryIdx.sol#849-851) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 853,
          "vulnerability_to_line": 855,
          "vulnerability_code": "  function toAddressArr(bytes32[] memory _arr) internal pure returns (address[] memory _conv) {\n\n    assembly { _conv := _arr }\n",
          "message": "ArrayUtils.toAddressArr (RegistryIdx.sol#853-855) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 857,
          "vulnerability_to_line": 859,
          "vulnerability_code": "  function toUintArr(bytes32[] memory _arr) internal pure returns (uint[] memory _conv) {\n\n    assembly { _conv := _arr }\n",
          "message": "ArrayUtils.toUintArr (RegistryIdx.sol#857-859) is declared view but contains assembly code\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 71,
          "vulnerability_to_line": 91,
          "vulnerability_code": "  function authorize(address _script_exec) internal view {\n\n    // Initialize memory\n\n    initialize();\n\n\n\n    // Check that the sender is authorized as a script exec contract for this exec id\n\n    bytes32 perms = EXEC_PERMISSIONS;\n\n    bool authorized;\n\n    assembly {\n\n      // Place the script exec address at 0, and the exec permissions seed after it\n\n      mstore(0, _script_exec)\n\n      mstore(0x20, perms)\n\n      // Hash the resulting 0x34 bytes, and place back into memory at 0\n\n      mstore(0, keccak256(0x0c, 0x34))\n\n      // Place the exec id after the hash -\n\n      mstore(0x20, mload(0x80))\n\n      // Hash the previous hash with the execution id, and check the result\n\n      authorized := sload(keccak256(0, 0x40))\n\n    }\n\n    if (!authorized)\n\n      revert(\"Sender is not authorized as a script exec address\");\n",
          "message": "Contract.authorize uses assembly (RegistryIdx.sol#71-91)\n\t- RegistryIdx.sol#78-89\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 102,
          "vulnerability_to_line": 122,
          "vulnerability_code": "  function initialize() internal view {\n\n    // No memory should have been allocated yet - expect the free memory pointer\n\n    // to point to 0x80 - and throw if it does not\n\n    require(freeMem() == 0x80, \"Memory allocated prior to execution\");\n\n    // Next, set up memory for execution\n\n    assembly {\n\n      mstore(0x80, sload(0))     // Execution id, read from storage\n\n      mstore(0xa0, sload(1))     // Original sender address, read from storage\n\n      mstore(0xc0, 0)            // Pointer to storage buffer\n\n      mstore(0xe0, 0)            // Bytes4 value of the current action requestor being used\n\n      mstore(0x100, 0)           // Enum representing the next type of function to be called (when pushing to buffer)\n\n      mstore(0x120, 0)           // Number of storage slots written to in buffer\n\n      mstore(0x140, 0)           // Number of events pushed to buffer\n\n      mstore(0x160, 0)           // Number of payment destinations pushed to buffer\n\n\n\n      // Update free memory pointer -\n\n      mstore(0x40, 0x180)\n\n    }\n\n    // Ensure that the sender and execution id returned from storage are expected values -\n\n    assert(execID() != bytes32(0) && sender() != address(0));\n",
          "message": "Contract.initialize uses assembly (RegistryIdx.sol#102-122)\n\t- RegistryIdx.sol#107-121\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 138,
          "vulnerability_to_line": 150,
          "vulnerability_code": "  function commit() conditions(validState, none) internal pure {\n\n    // Check value of storage buffer pointer - should be at least 0x180\n\n    bytes32 ptr = buffPtr();\n\n    require(ptr >= 0x180, \"Invalid buffer pointer\");\n\n\n\n    assembly {\n\n      // Get the size of the buffer\n\n      let size := mload(add(0x20, ptr))\n\n      mstore(ptr, 0x20) // Place dynamic data offset before buffer\n\n      // Revert to storage\n\n      revert(ptr, add(0x40, size))\n\n    }\n",
          "message": "Contract.commit uses assembly (RegistryIdx.sol#138-150)\n\t- RegistryIdx.sol#143-150\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 166,
          "vulnerability_to_line": 168,
          "vulnerability_code": "  function buffPtr() private pure returns (bytes32 ptr) {\n\n    assembly { ptr := mload(0xc0) }\n",
          "message": "Contract.buffPtr uses assembly (RegistryIdx.sol#166-168)\n\t- RegistryIdx.sol#167-168\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 171,
          "vulnerability_to_line": 173,
          "vulnerability_code": "  function freeMem() private pure returns (bytes32 ptr) {\n\n    assembly { ptr := mload(0x40) }\n",
          "message": "Contract.freeMem uses assembly (RegistryIdx.sol#171-173)\n\t- RegistryIdx.sol#172-173\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 176,
          "vulnerability_to_line": 181,
          "vulnerability_code": "  function currentAction() private pure returns (bytes4 action) {\n\n    if (buffPtr() == bytes32(0))\n\n      return bytes4(0);\n\n\n\n    assembly { action := mload(0xe0) }\n",
          "message": "Contract.currentAction uses assembly (RegistryIdx.sol#176-181)\n\t- RegistryIdx.sol#180-181\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 202,
          "vulnerability_to_line": 215,
          "vulnerability_code": "  function startBuffer() private pure {\n\n    assembly {\n\n      // Get a pointer to free memory, and place at 0xc0 (storage buffer pointer)\n\n      let ptr := msize()\n\n      mstore(0xc0, ptr)\n\n      // Clear bytes at pointer -\n\n      mstore(ptr, 0)            // temp ptr\n\n      mstore(add(0x20, ptr), 0) // buffer length\n\n      // Update free memory pointer -\n\n      mstore(0x40, add(0x40, ptr))\n\n      // Set expected next function to 'NONE' -\n\n      mstore(0x100, 1)\n\n    }\n",
          "message": "Contract.startBuffer uses assembly (RegistryIdx.sol#202-215)\n\t- RegistryIdx.sol#203-215\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 259,
          "vulnerability_to_line": 262,
          "vulnerability_code": "  function execID() internal pure returns (bytes32 exec_id) {\n\n    assembly { exec_id := mload(0x80) }\n\n    require(exec_id != bytes32(0), \"Execution id overwritten, or not read\");\n",
          "message": "Contract.execID uses assembly (RegistryIdx.sol#259-262)\n\t- RegistryIdx.sol#260-261\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 265,
          "vulnerability_to_line": 268,
          "vulnerability_code": "  function sender() internal pure returns (address addr) {\n\n    assembly { addr := mload(0xa0) }\n\n    require(addr != address(0), \"Sender address overwritten, or not read\");\n",
          "message": "Contract.sender uses assembly (RegistryIdx.sol#265-268)\n\t- RegistryIdx.sol#266-267\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 274,
          "vulnerability_to_line": 277,
          "vulnerability_code": "  function read(bytes32 _location) internal view returns (bytes32 data) {\n\n    data = keccak256(_location, execID());\n\n    assembly { data := sload(data) }\n",
          "message": "Contract.read uses assembly (RegistryIdx.sol#274-277)\n\t- RegistryIdx.sol#276-277\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 346,
          "vulnerability_to_line": 366,
          "vulnerability_code": "  function storing() conditions(validStoreBuff, isStoring) internal pure {\n\n    bytes4 action_req = STORES;\n\n    assembly {\n\n      // Get pointer to buffer length -\n\n      let ptr := add(0x20, mload(0xc0))\n\n      // Push requestor to the end of buffer, as well as to the 'current action' slot -\n\n      mstore(add(0x20, add(ptr, mload(ptr))), action_req)\n\n      // Push '0' to the end of the 4 bytes just pushed - this will be the length of the STORES action\n\n      mstore(add(0x24, add(ptr, mload(ptr))), 0)\n\n      // Increment buffer length - 0x24 plus the previous length\n\n      mstore(ptr, add(0x24, mload(ptr)))\n\n      // Set the current action being executed (STORES) -\n\n      mstore(0xe0, action_req)\n\n      // Set the expected next function - STORE_DEST\n\n      mstore(0x100, 2)\n\n      // Set a pointer to the length of the current request within the buffer\n\n      mstore(sub(ptr, 0x20), add(ptr, mload(ptr)))\n\n    }\n\n    // Update free memory pointer\n\n    setFreeMem();\n",
          "message": "Contract.storing uses assembly (RegistryIdx.sol#346-366)\n\t- RegistryIdx.sol#348-365\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 369,
          "vulnerability_to_line": 390,
          "vulnerability_code": "  function set(bytes32 _field) conditions(validStoreDest, validStoreVal) internal pure returns (bytes32) {\n\n    assembly {\n\n      // Get pointer to buffer length -\n\n      let ptr := add(0x20, mload(0xc0))\n\n      // Push storage destination to the end of the buffer -\n\n      mstore(add(0x20, add(ptr, mload(ptr))), _field)\n\n      // Increment buffer length - 0x20 plus the previous length\n\n      mstore(ptr, add(0x20, mload(ptr)))\n\n      // Set the expected next function - VAL_SET\n\n      mstore(0x100, 3)\n\n      // Increment STORES action length -\n\n      mstore(\n\n        mload(sub(ptr, 0x20)),\n\n        add(1, mload(mload(sub(ptr, 0x20))))\n\n      )\n\n      // Update number of storage slots pushed to -\n\n      mstore(0x120, add(1, mload(0x120)))\n\n    }\n\n    // Update free memory pointer\n\n    setFreeMem();\n\n    return _field;\n",
          "message": "Contract.set uses assembly (RegistryIdx.sol#369-390)\n\t- RegistryIdx.sol#370-388\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 393,
          "vulnerability_to_line": 406,
          "vulnerability_code": "  function to(bytes32, bytes32 _val) conditions(validStoreVal, validStoreDest) internal pure {\n\n    assembly {\n\n      // Get pointer to buffer length -\n\n      let ptr := add(0x20, mload(0xc0))\n\n      // Push storage value to the end of the buffer -\n\n      mstore(add(0x20, add(ptr, mload(ptr))), _val)\n\n      // Increment buffer length - 0x20 plus the previous length\n\n      mstore(ptr, add(0x20, mload(ptr)))\n\n      // Set the expected next function - STORE_DEST\n\n      mstore(0x100, 2)\n\n    }\n\n    // Update free memory pointer\n\n    setFreeMem();\n",
          "message": "Contract.to uses assembly (RegistryIdx.sol#393-406)\n\t- RegistryIdx.sol#394-405\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 426,
          "vulnerability_to_line": 450,
          "vulnerability_code": "  function increase(bytes32 _field) conditions(validStoreDest, validStoreVal) internal view returns (bytes32 val) {\n\n    // Read value stored at the location in storage -\n\n    val = keccak256(_field, execID());\n\n    assembly {\n\n      val := sload(val)\n\n      // Get pointer to buffer length -\n\n      let ptr := add(0x20, mload(0xc0))\n\n      // Push storage destination to the end of the buffer -\n\n      mstore(add(0x20, add(ptr, mload(ptr))), _field)\n\n      // Increment buffer length - 0x20 plus the previous length\n\n      mstore(ptr, add(0x20, mload(ptr)))\n\n      // Set the expected next function - VAL_INC\n\n      mstore(0x100, 4)\n\n      // Increment STORES action length -\n\n      mstore(\n\n        mload(sub(ptr, 0x20)),\n\n        add(1, mload(mload(sub(ptr, 0x20))))\n\n      )\n\n      // Update number of storage slots pushed to -\n\n      mstore(0x120, add(1, mload(0x120)))\n\n    }\n\n    // Update free memory pointer\n\n    setFreeMem();\n\n    return val;\n",
          "message": "Contract.increase uses assembly (RegistryIdx.sol#426-450)\n\t- RegistryIdx.sol#429-448\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 452,
          "vulnerability_to_line": 476,
          "vulnerability_code": "  function decrease(bytes32 _field) conditions(validStoreDest, validStoreVal) internal view returns (bytes32 val) {\n\n    // Read value stored at the location in storage -\n\n    val = keccak256(_field, execID());\n\n    assembly {\n\n      val := sload(val)\n\n      // Get pointer to buffer length -\n\n      let ptr := add(0x20, mload(0xc0))\n\n      // Push storage destination to the end of the buffer -\n\n      mstore(add(0x20, add(ptr, mload(ptr))), _field)\n\n      // Increment buffer length - 0x20 plus the previous length\n\n      mstore(ptr, add(0x20, mload(ptr)))\n\n      // Set the expected next function - VAL_DEC\n\n      mstore(0x100, 5)\n\n      // Increment STORES action length -\n\n      mstore(\n\n        mload(sub(ptr, 0x20)),\n\n        add(1, mload(mload(sub(ptr, 0x20))))\n\n      )\n\n      // Update number of storage slots pushed to -\n\n      mstore(0x120, add(1, mload(0x120)))\n\n    }\n\n    // Update free memory pointer\n\n    setFreeMem();\n\n    return val;\n",
          "message": "Contract.decrease uses assembly (RegistryIdx.sol#452-476)\n\t- RegistryIdx.sol#455-474\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 478,
          "vulnerability_to_line": 500,
          "vulnerability_code": "  function by(bytes32 _val, uint _amt) conditions(validStoreVal, validStoreDest) internal pure {\n\n    // Check the expected function type - if it is VAL_INC, perform safe-add on the value\n\n    // If it is VAL_DEC, perform safe-sub on the value\n\n    if (expected() == NextFunction.VAL_INC)\n\n      _amt = _amt.add(uint(_val));\n\n    else if (expected() == NextFunction.VAL_DEC)\n\n      _amt = uint(_val).sub(_amt);\n\n    else\n\n      revert('Expected VAL_INC or VAL_DEC');\n\n\n\n    assembly {\n\n      // Get pointer to buffer length -\n\n      let ptr := add(0x20, mload(0xc0))\n\n      // Push storage value to the end of the buffer -\n\n      mstore(add(0x20, add(ptr, mload(ptr))), _amt)\n\n      // Increment buffer length - 0x20 plus the previous length\n\n      mstore(ptr, add(0x20, mload(ptr)))\n\n      // Set the expected next function - STORE_DEST\n\n      mstore(0x100, 2)\n\n    }\n\n    // Update free memory pointer\n\n    setFreeMem();\n",
          "message": "Contract.by uses assembly (RegistryIdx.sol#478-500)\n\t- RegistryIdx.sol#488-499\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 503,
          "vulnerability_to_line": 527,
          "vulnerability_code": "  function byMaximum(bytes32 _val, uint _amt) conditions(validStoreVal, validStoreDest) internal pure {\n\n    // Check the expected function type - if it is VAL_DEC, set the new amount to the difference of\n\n    // _val and _amt, to a minimum of 0\n\n    if (expected() == NextFunction.VAL_DEC) {\n\n      if (_amt >= uint(_val))\n\n        _amt = 0;\n\n      else\n\n        _amt = uint(_val).sub(_amt);\n\n    } else {\n\n      revert('Expected VAL_DEC');\n\n    }\n\n\n\n    assembly {\n\n      // Get pointer to buffer length -\n\n      let ptr := add(0x20, mload(0xc0))\n\n      // Push storage value to the end of the buffer -\n\n      mstore(add(0x20, add(ptr, mload(ptr))), _amt)\n\n      // Increment buffer length - 0x20 plus the previous length\n\n      mstore(ptr, add(0x20, mload(ptr)))\n\n      // Set the expected next function - STORE_DEST\n\n      mstore(0x100, 2)\n\n    }\n\n    // Update free memory pointer\n\n    setFreeMem();\n",
          "message": "Contract.byMaximum uses assembly (RegistryIdx.sol#503-527)\n\t- RegistryIdx.sol#515-526\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 531,
          "vulnerability_to_line": 551,
          "vulnerability_code": "  function emitting() conditions(validEmitBuff, isEmitting) internal pure {\n\n    bytes4 action_req = EMITS;\n\n    assembly {\n\n      // Get pointer to buffer length -\n\n      let ptr := add(0x20, mload(0xc0))\n\n      // Push requestor to the end of buffer, as well as to the 'current action' slot -\n\n      mstore(add(0x20, add(ptr, mload(ptr))), action_req)\n\n      // Push '0' to the end of the 4 bytes just pushed - this will be the length of the EMITS action\n\n      mstore(add(0x24, add(ptr, mload(ptr))), 0)\n\n      // Increment buffer length - 0x24 plus the previous length\n\n      mstore(ptr, add(0x24, mload(ptr)))\n\n      // Set the current action being executed (EMITS) -\n\n      mstore(0xe0, action_req)\n\n      // Set the expected next function - EMIT_LOG\n\n      mstore(0x100, 6)\n\n      // Set a pointer to the length of the current request within the buffer\n\n      mstore(sub(ptr, 0x20), add(ptr, mload(ptr)))\n\n    }\n\n    // Update free memory pointer\n\n    setFreeMem();\n",
          "message": "Contract.emitting uses assembly (RegistryIdx.sol#531-551)\n\t- RegistryIdx.sol#533-550\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 553,
          "vulnerability_to_line": 584,
          "vulnerability_code": "  function log(bytes32 _data) conditions(validEvent, validEvent) internal pure {\n\n    assembly {\n\n      // Get pointer to buffer length -\n\n      let ptr := add(0x20, mload(0xc0))\n\n      // Push 0 to the end of the buffer - event will have 0 topics\n\n      mstore(add(0x20, add(ptr, mload(ptr))), 0)\n\n      // If _data is zero, set data size to 0 in buffer and push -\n\n      if eq(_data, 0) {\n\n        mstore(add(0x40, add(ptr, mload(ptr))), 0)\n\n        // Increment buffer length - 0x40 plus the original length\n\n        mstore(ptr, add(0x40, mload(ptr)))\n\n      }\n\n      // If _data is not zero, set size to 0x20 and push to buffer -\n\n      if iszero(eq(_data, 0)) {\n\n        // Push data size (0x20) to the end of the buffer\n\n        mstore(add(0x40, add(ptr, mload(ptr))), 0x20)\n\n        // Push data to the end of the buffer\n\n        mstore(add(0x60, add(ptr, mload(ptr))), _data)\n\n        // Increment buffer length - 0x60 plus the original length\n\n        mstore(ptr, add(0x60, mload(ptr)))\n\n      }\n\n      // Increment EMITS action length -\n\n      mstore(\n\n        mload(sub(ptr, 0x20)),\n\n        add(1, mload(mload(sub(ptr, 0x20))))\n\n      )\n\n      // Update number of events pushed to buffer -\n\n      mstore(0x140, add(1, mload(0x140)))\n\n    }\n\n    // Update free memory pointer\n\n    setFreeMem();\n",
          "message": "Contract.log uses assembly (RegistryIdx.sol#553-584)\n\t- RegistryIdx.sol#554-583\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 586,
          "vulnerability_to_line": 619,
          "vulnerability_code": "  function log(bytes32[1] memory _topics, bytes32 _data) conditions(validEvent, validEvent) internal pure {\n\n    assembly {\n\n      // Get pointer to buffer length -\n\n      let ptr := add(0x20, mload(0xc0))\n\n      // Push 1 to the end of the buffer - event will have 1 topic\n\n      mstore(add(0x20, add(ptr, mload(ptr))), 1)\n\n      // Push topic to end of buffer\n\n      mstore(add(0x40, add(ptr, mload(ptr))), mload(_topics))\n\n      // If _data is zero, set data size to 0 in buffer and push -\n\n      if eq(_data, 0) {\n\n        mstore(add(0x60, add(ptr, mload(ptr))), 0)\n\n        // Increment buffer length - 0x60 plus the original length\n\n        mstore(ptr, add(0x60, mload(ptr)))\n\n      }\n\n      // If _data is not zero, set size to 0x20 and push to buffer -\n\n      if iszero(eq(_data, 0)) {\n\n        // Push data size (0x20) to the end of the buffer\n\n        mstore(add(0x60, add(ptr, mload(ptr))), 0x20)\n\n        // Push data to the end of the buffer\n\n        mstore(add(0x80, add(ptr, mload(ptr))), _data)\n\n        // Increment buffer length - 0x80 plus the original length\n\n        mstore(ptr, add(0x80, mload(ptr)))\n\n      }\n\n      // Increment EMITS action length -\n\n      mstore(\n\n        mload(sub(ptr, 0x20)),\n\n        add(1, mload(mload(sub(ptr, 0x20))))\n\n      )\n\n      // Update number of events pushed to buffer -\n\n      mstore(0x140, add(1, mload(0x140)))\n\n    }\n\n    // Update free memory pointer\n\n    setFreeMem();\n",
          "message": "Contract.log uses assembly (RegistryIdx.sol#586-619)\n\t- RegistryIdx.sol#587-618\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 621,
          "vulnerability_to_line": 655,
          "vulnerability_code": "  function log(bytes32[2] memory _topics, bytes32 _data) conditions(validEvent, validEvent) internal pure {\n\n    assembly {\n\n      // Get pointer to buffer length -\n\n      let ptr := add(0x20, mload(0xc0))\n\n      // Push 2 to the end of the buffer - event will have 2 topics\n\n      mstore(add(0x20, add(ptr, mload(ptr))), 2)\n\n      // Push topics to end of buffer\n\n      mstore(add(0x40, add(ptr, mload(ptr))), mload(_topics))\n\n      mstore(add(0x60, add(ptr, mload(ptr))), mload(add(0x20, _topics)))\n\n      // If _data is zero, set data size to 0 in buffer and push -\n\n      if eq(_data, 0) {\n\n        mstore(add(0x80, add(ptr, mload(ptr))), 0)\n\n        // Increment buffer length - 0x80 plus the original length\n\n        mstore(ptr, add(0x80, mload(ptr)))\n\n      }\n\n      // If _data is not zero, set size to 0x20 and push to buffer -\n\n      if iszero(eq(_data, 0)) {\n\n        // Push data size (0x20) to the end of the buffer\n\n        mstore(add(0x80, add(ptr, mload(ptr))), 0x20)\n\n        // Push data to the end of the buffer\n\n        mstore(add(0xa0, add(ptr, mload(ptr))), _data)\n\n        // Increment buffer length - 0xa0 plus the original length\n\n        mstore(ptr, add(0xa0, mload(ptr)))\n\n      }\n\n      // Increment EMITS action length -\n\n      mstore(\n\n        mload(sub(ptr, 0x20)),\n\n        add(1, mload(mload(sub(ptr, 0x20))))\n\n      )\n\n      // Update number of events pushed to buffer -\n\n      mstore(0x140, add(1, mload(0x140)))\n\n    }\n\n    // Update free memory pointer\n\n    setFreeMem();\n",
          "message": "Contract.log uses assembly (RegistryIdx.sol#621-655)\n\t- RegistryIdx.sol#622-654\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 657,
          "vulnerability_to_line": 692,
          "vulnerability_code": "  function log(bytes32[3] memory _topics, bytes32 _data) conditions(validEvent, validEvent) internal pure {\n\n    assembly {\n\n      // Get pointer to buffer length -\n\n      let ptr := add(0x20, mload(0xc0))\n\n      // Push 3 to the end of the buffer - event will have 3 topics\n\n      mstore(add(0x20, add(ptr, mload(ptr))), 3)\n\n      // Push topics to end of buffer\n\n      mstore(add(0x40, add(ptr, mload(ptr))), mload(_topics))\n\n      mstore(add(0x60, add(ptr, mload(ptr))), mload(add(0x20, _topics)))\n\n      mstore(add(0x80, add(ptr, mload(ptr))), mload(add(0x40, _topics)))\n\n      // If _data is zero, set data size to 0 in buffer and push -\n\n      if eq(_data, 0) {\n\n        mstore(add(0xa0, add(ptr, mload(ptr))), 0)\n\n        // Increment buffer length - 0xa0 plus the original length\n\n        mstore(ptr, add(0xa0, mload(ptr)))\n\n      }\n\n      // If _data is not zero, set size to 0x20 and push to buffer -\n\n      if iszero(eq(_data, 0)) {\n\n        // Push data size (0x20) to the end of the buffer\n\n        mstore(add(0xa0, add(ptr, mload(ptr))), 0x20)\n\n        // Push data to the end of the buffer\n\n        mstore(add(0xc0, add(ptr, mload(ptr))), _data)\n\n        // Increment buffer length - 0xc0 plus the original length\n\n        mstore(ptr, add(0xc0, mload(ptr)))\n\n      }\n\n      // Increment EMITS action length -\n\n      mstore(\n\n        mload(sub(ptr, 0x20)),\n\n        add(1, mload(mload(sub(ptr, 0x20))))\n\n      )\n\n      // Update number of events pushed to buffer -\n\n      mstore(0x140, add(1, mload(0x140)))\n\n    }\n\n    // Update free memory pointer\n\n    setFreeMem();\n",
          "message": "Contract.log uses assembly (RegistryIdx.sol#657-692)\n\t- RegistryIdx.sol#658-691\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 694,
          "vulnerability_to_line": 730,
          "vulnerability_code": "  function log(bytes32[4] memory _topics, bytes32 _data) conditions(validEvent, validEvent) internal pure {\n\n    assembly {\n\n      // Get pointer to buffer length -\n\n      let ptr := add(0x20, mload(0xc0))\n\n      // Push 4 to the end of the buffer - event will have 4 topics\n\n      mstore(add(0x20, add(ptr, mload(ptr))), 4)\n\n      // Push topics to end of buffer\n\n      mstore(add(0x40, add(ptr, mload(ptr))), mload(_topics))\n\n      mstore(add(0x60, add(ptr, mload(ptr))), mload(add(0x20, _topics)))\n\n      mstore(add(0x80, add(ptr, mload(ptr))), mload(add(0x40, _topics)))\n\n      mstore(add(0xa0, add(ptr, mload(ptr))), mload(add(0x60, _topics)))\n\n      // If _data is zero, set data size to 0 in buffer and push -\n\n      if eq(_data, 0) {\n\n        mstore(add(0xc0, add(ptr, mload(ptr))), 0)\n\n        // Increment buffer length - 0xc0 plus the original length\n\n        mstore(ptr, add(0xc0, mload(ptr)))\n\n      }\n\n      // If _data is not zero, set size to 0x20 and push to buffer -\n\n      if iszero(eq(_data, 0)) {\n\n        // Push data size (0x20) to the end of the buffer\n\n        mstore(add(0xc0, add(ptr, mload(ptr))), 0x20)\n\n        // Push data to the end of the buffer\n\n        mstore(add(0xe0, add(ptr, mload(ptr))), _data)\n\n        // Increment buffer length - 0xe0 plus the original length\n\n        mstore(ptr, add(0xe0, mload(ptr)))\n\n      }\n\n      // Increment EMITS action length -\n\n      mstore(\n\n        mload(sub(ptr, 0x20)),\n\n        add(1, mload(mload(sub(ptr, 0x20))))\n\n      )\n\n      // Update number of events pushed to buffer -\n\n      mstore(0x140, add(1, mload(0x140)))\n\n    }\n\n    // Update free memory pointer\n\n    setFreeMem();\n",
          "message": "Contract.log uses assembly (RegistryIdx.sol#694-730)\n\t- RegistryIdx.sol#695-729\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 734,
          "vulnerability_to_line": 754,
          "vulnerability_code": "  function paying() conditions(validPayBuff, isPaying) internal pure {\n\n    bytes4 action_req = PAYS;\n\n    assembly {\n\n      // Get pointer to buffer length -\n\n      let ptr := add(0x20, mload(0xc0))\n\n      // Push requestor to the end of buffer, as well as to the 'current action' slot -\n\n      mstore(add(0x20, add(ptr, mload(ptr))), action_req)\n\n      // Push '0' to the end of the 4 bytes just pushed - this will be the length of the PAYS action\n\n      mstore(add(0x24, add(ptr, mload(ptr))), 0)\n\n      // Increment buffer length - 0x24 plus the previous length\n\n      mstore(ptr, add(0x24, mload(ptr)))\n\n      // Set the current action being executed (PAYS) -\n\n      mstore(0xe0, action_req)\n\n      // Set the expected next function - PAY_AMT\n\n      mstore(0x100, 8)\n\n      // Set a pointer to the length of the current request within the buffer\n\n      mstore(sub(ptr, 0x20), add(ptr, mload(ptr)))\n\n    }\n\n    // Update free memory pointer\n\n    setFreeMem();\n",
          "message": "Contract.paying uses assembly (RegistryIdx.sol#734-754)\n\t- RegistryIdx.sol#736-753\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 757,
          "vulnerability_to_line": 778,
          "vulnerability_code": "  function pay(uint _amount) conditions(validPayAmt, validPayDest) internal pure returns (uint) {\n\n    assembly {\n\n      // Get pointer to buffer length -\n\n      let ptr := add(0x20, mload(0xc0))\n\n      // Push payment amount to the end of the buffer -\n\n      mstore(add(0x20, add(ptr, mload(ptr))), _amount)\n\n      // Increment buffer length - 0x20 plus the previous length\n\n      mstore(ptr, add(0x20, mload(ptr)))\n\n      // Set the expected next function - PAY_DEST\n\n      mstore(0x100, 7)\n\n      // Increment PAYS action length -\n\n      mstore(\n\n        mload(sub(ptr, 0x20)),\n\n        add(1, mload(mload(sub(ptr, 0x20))))\n\n      )\n\n      // Update number of payment destinations to be pushed to -\n\n      mstore(0x160, add(1, mload(0x160)))\n\n    }\n\n    // Update free memory pointer\n\n    setFreeMem();\n\n    return _amount;\n",
          "message": "Contract.pay uses assembly (RegistryIdx.sol#757-778)\n\t- RegistryIdx.sol#758-776\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 781,
          "vulnerability_to_line": 794,
          "vulnerability_code": "  function toAcc(uint, address _dest) conditions(validPayDest, validPayAmt) internal pure {\n\n    assembly {\n\n      // Get pointer to buffer length -\n\n      let ptr := add(0x20, mload(0xc0))\n\n      // Push payment destination to the end of the buffer -\n\n      mstore(add(0x20, add(ptr, mload(ptr))), _dest)\n\n      // Increment buffer length - 0x20 plus the previous length\n\n      mstore(ptr, add(0x20, mload(ptr)))\n\n      // Set the expected next function - PAY_AMT\n\n      mstore(0x100, 8)\n\n    }\n\n    // Update free memory pointer\n\n    setFreeMem();\n",
          "message": "Contract.toAcc uses assembly (RegistryIdx.sol#781-794)\n\t- RegistryIdx.sol#782-793\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 797,
          "vulnerability_to_line": 799,
          "vulnerability_code": "  function setFreeMem() private pure {\n\n    assembly { mstore(0x40, msize) }\n",
          "message": "Contract.setFreeMem uses assembly (RegistryIdx.sol#797-799)\n\t- RegistryIdx.sol#798-799\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 802,
          "vulnerability_to_line": 804,
          "vulnerability_code": "  function expected() private pure returns (NextFunction next) {\n\n    assembly { next := mload(0x100) }\n",
          "message": "Contract.expected uses assembly (RegistryIdx.sol#802-804)\n\t- RegistryIdx.sol#803-804\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 807,
          "vulnerability_to_line": 813,
          "vulnerability_code": "  function emitted() internal pure returns (uint num_emitted) {\n\n    if (buffPtr() == bytes32(0))\n\n      return 0;\n\n\n\n    // Load number emitted from buffer -\n\n    assembly { num_emitted := mload(0x140) }\n",
          "message": "Contract.emitted uses assembly (RegistryIdx.sol#807-813)\n\t- RegistryIdx.sol#812-813\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 816,
          "vulnerability_to_line": 822,
          "vulnerability_code": "  function stored() internal pure returns (uint num_stored) {\n\n    if (buffPtr() == bytes32(0))\n\n      return 0;\n\n\n\n    // Load number stored from buffer -\n\n    assembly { num_stored := mload(0x120) }\n",
          "message": "Contract.stored uses assembly (RegistryIdx.sol#816-822)\n\t- RegistryIdx.sol#821-822\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 825,
          "vulnerability_to_line": 831,
          "vulnerability_code": "  function paid() internal pure returns (uint num_paid) {\n\n    if (buffPtr() == bytes32(0))\n\n      return 0;\n\n\n\n    // Load number paid from buffer -\n\n    assembly { num_paid := mload(0x160) }\n",
          "message": "Contract.paid uses assembly (RegistryIdx.sol#825-831)\n\t- RegistryIdx.sol#830-831\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 849,
          "vulnerability_to_line": 851,
          "vulnerability_code": "  function toBytes4Arr(bytes32[] memory _arr) internal pure returns (bytes4[] memory _conv) {\n\n    assembly { _conv := _arr }\n",
          "message": "ArrayUtils.toBytes4Arr uses assembly (RegistryIdx.sol#849-851)\n\t- RegistryIdx.sol#850-851\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 853,
          "vulnerability_to_line": 855,
          "vulnerability_code": "  function toAddressArr(bytes32[] memory _arr) internal pure returns (address[] memory _conv) {\n\n    assembly { _conv := _arr }\n",
          "message": "ArrayUtils.toAddressArr uses assembly (RegistryIdx.sol#853-855)\n\t- RegistryIdx.sol#854-855\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 857,
          "vulnerability_to_line": 859,
          "vulnerability_code": "  function toUintArr(bytes32[] memory _arr) internal pure returns (uint[] memory _conv) {\n\n    assembly { _conv := _arr }\n",
          "message": "ArrayUtils.toUintArr uses assembly (RegistryIdx.sol#857-859)\n\t- RegistryIdx.sol#858-859\n"
        },
        {
          "name": "solc-version",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.23;\n",
          "message": "Detected issues with version pragma in RegistryIdx.sol:\n\t- pragma solidity^0.4.23 (RegistryIdx.sol#3): it allows old versions\n\t- pragma solidity^0.4.23 (RegistryIdx.sol#46): it allows old versions\n\t- pragma solidity^0.4.23 (RegistryIdx.sol#836): it allows old versions\n\t- pragma solidity^0.4.23 (RegistryIdx.sol#845): it allows old versions\n\t- pragma solidity^0.4.23 (RegistryIdx.sol#864): it allows old versions\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 71,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function authorize(address _script_exec) internal view {\n",
          "message": "Parameter '_script_exec' of Contract.authorize (RegistryIdx.sol#71) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 132,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function checks(function () pure _check) conditions(validState, validState) internal pure {\n",
          "message": "Parameter '_check' of Contract.checks (RegistryIdx.sol#132) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 274,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function read(bytes32 _location) internal view returns (bytes32 data) {\n",
          "message": "Parameter '_location' of Contract.read (RegistryIdx.sol#274) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 369,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function set(bytes32 _field) conditions(validStoreDest, validStoreVal) internal pure returns (bytes32) {\n",
          "message": "Parameter '_field' of Contract.set (RegistryIdx.sol#369) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 393,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function to(bytes32, bytes32 _val) conditions(validStoreVal, validStoreDest) internal pure {\n",
          "message": "Parameter '' of Contract.to (RegistryIdx.sol#393) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 409,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function to(bytes32 _field, uint _val) internal pure {\n",
          "message": "Parameter '_field' of Contract.to (RegistryIdx.sol#409) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 409,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function to(bytes32 _field, uint _val) internal pure {\n",
          "message": "Parameter '_val' of Contract.to (RegistryIdx.sol#409) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 414,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function to(bytes32 _field, address _val) internal pure {\n",
          "message": "Parameter '_field' of Contract.to (RegistryIdx.sol#414) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 414,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function to(bytes32 _field, address _val) internal pure {\n",
          "message": "Parameter '_val' of Contract.to (RegistryIdx.sol#414) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 419,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function to(bytes32 _field, bool _val) internal pure {\n",
          "message": "Parameter '_field' of Contract.to (RegistryIdx.sol#419) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 419,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function to(bytes32 _field, bool _val) internal pure {\n",
          "message": "Parameter '_val' of Contract.to (RegistryIdx.sol#419) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 426,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function increase(bytes32 _field) conditions(validStoreDest, validStoreVal) internal view returns (bytes32 val) {\n",
          "message": "Parameter '_field' of Contract.increase (RegistryIdx.sol#426) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 452,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function decrease(bytes32 _field) conditions(validStoreDest, validStoreVal) internal view returns (bytes32 val) {\n",
          "message": "Parameter '_field' of Contract.decrease (RegistryIdx.sol#452) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 478,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function by(bytes32 _val, uint _amt) conditions(validStoreVal, validStoreDest) internal pure {\n",
          "message": "Parameter '_val' of Contract.by (RegistryIdx.sol#478) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 478,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function by(bytes32 _val, uint _amt) conditions(validStoreVal, validStoreDest) internal pure {\n",
          "message": "Parameter '_amt' of Contract.by (RegistryIdx.sol#478) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 503,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function byMaximum(bytes32 _val, uint _amt) conditions(validStoreVal, validStoreDest) internal pure {\n",
          "message": "Parameter '_val' of Contract.byMaximum (RegistryIdx.sol#503) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 503,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function byMaximum(bytes32 _val, uint _amt) conditions(validStoreVal, validStoreDest) internal pure {\n",
          "message": "Parameter '_amt' of Contract.byMaximum (RegistryIdx.sol#503) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 757,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function pay(uint _amount) conditions(validPayAmt, validPayDest) internal pure returns (uint) {\n",
          "message": "Parameter '_amount' of Contract.pay (RegistryIdx.sol#757) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 781,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function toAcc(uint, address _dest) conditions(validPayDest, validPayAmt) internal pure {\n",
          "message": "Parameter '' of Contract.toAcc (RegistryIdx.sol#781) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 839,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function read(bytes32 exec_id, bytes32 location) external view returns (bytes32 data);\n",
          "message": "Parameter 'exec_id' of GetterInterface.read (RegistryIdx.sol#839) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 840,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function readMulti(bytes32 exec_id, bytes32[] locations) external view returns (bytes32[] data);\n",
          "message": "Parameter 'exec_id' of GetterInterface.readMulti (RegistryIdx.sol#840) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 876,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function execPermissions(address _exec) internal pure returns (bytes32)\n",
          "message": "Parameter '_exec' of RegistryIdx.execPermissions (RegistryIdx.sol#876) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 892,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function registeredApps(address _provider) internal pure returns (bytes32)\n",
          "message": "Parameter '_provider' of RegistryIdx.registeredApps (RegistryIdx.sol#892) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 896,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function appBase(bytes32 _app, address _provider) internal pure returns (bytes32)\n",
          "message": "Parameter '_app' of RegistryIdx.appBase (RegistryIdx.sol#896) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 896,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function appBase(bytes32 _app, address _provider) internal pure returns (bytes32)\n",
          "message": "Parameter '_provider' of RegistryIdx.appBase (RegistryIdx.sol#896) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 900,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function appVersionList(bytes32 _app, address _provider) internal pure returns (bytes32)\n",
          "message": "Parameter '_app' of RegistryIdx.appVersionList (RegistryIdx.sol#900) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 900,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function appVersionList(bytes32 _app, address _provider) internal pure returns (bytes32)\n",
          "message": "Parameter '_provider' of RegistryIdx.appVersionList (RegistryIdx.sol#900) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 904,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function versionBase(bytes32 _app, bytes32 _version, address _provider) internal pure returns (bytes32)\n",
          "message": "Parameter '_app' of RegistryIdx.versionBase (RegistryIdx.sol#904) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 904,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function versionBase(bytes32 _app, bytes32 _version, address _provider) internal pure returns (bytes32)\n",
          "message": "Parameter '_version' of RegistryIdx.versionBase (RegistryIdx.sol#904) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 904,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function versionBase(bytes32 _app, bytes32 _version, address _provider) internal pure returns (bytes32)\n",
          "message": "Parameter '_provider' of RegistryIdx.versionBase (RegistryIdx.sol#904) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 908,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function versionIndex(bytes32 _app, bytes32 _version, address _provider) internal pure returns (bytes32)\n",
          "message": "Parameter '_app' of RegistryIdx.versionIndex (RegistryIdx.sol#908) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 908,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function versionIndex(bytes32 _app, bytes32 _version, address _provider) internal pure returns (bytes32)\n",
          "message": "Parameter '_version' of RegistryIdx.versionIndex (RegistryIdx.sol#908) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 908,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function versionIndex(bytes32 _app, bytes32 _version, address _provider) internal pure returns (bytes32)\n",
          "message": "Parameter '_provider' of RegistryIdx.versionIndex (RegistryIdx.sol#908) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 912,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function versionSelectors(bytes32 _app, bytes32 _version, address _provider) internal pure returns (bytes32)\n",
          "message": "Parameter '_app' of RegistryIdx.versionSelectors (RegistryIdx.sol#912) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 912,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function versionSelectors(bytes32 _app, bytes32 _version, address _provider) internal pure returns (bytes32)\n",
          "message": "Parameter '_version' of RegistryIdx.versionSelectors (RegistryIdx.sol#912) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 912,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function versionSelectors(bytes32 _app, bytes32 _version, address _provider) internal pure returns (bytes32)\n",
          "message": "Parameter '_provider' of RegistryIdx.versionSelectors (RegistryIdx.sol#912) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 916,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function versionAddresses(bytes32 _app, bytes32 _version, address _provider) internal pure returns (bytes32)\n",
          "message": "Parameter '_app' of RegistryIdx.versionAddresses (RegistryIdx.sol#916) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 916,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function versionAddresses(bytes32 _app, bytes32 _version, address _provider) internal pure returns (bytes32)\n",
          "message": "Parameter '_version' of RegistryIdx.versionAddresses (RegistryIdx.sol#916) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 916,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function versionAddresses(bytes32 _app, bytes32 _version, address _provider) internal pure returns (bytes32)\n",
          "message": "Parameter '_provider' of RegistryIdx.versionAddresses (RegistryIdx.sol#916) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 920,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function getApplications(address _storage, bytes32 _exec_id, address _provider) external view returns (bytes32[] memory) {\n",
          "message": "Parameter '_storage' of RegistryIdx.getApplications (RegistryIdx.sol#920) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 920,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function getApplications(address _storage, bytes32 _exec_id, address _provider) external view returns (bytes32[] memory) {\n",
          "message": "Parameter '_exec_id' of RegistryIdx.getApplications (RegistryIdx.sol#920) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 920,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function getApplications(address _storage, bytes32 _exec_id, address _provider) external view returns (bytes32[] memory) {\n",
          "message": "Parameter '_provider' of RegistryIdx.getApplications (RegistryIdx.sol#920) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 934,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function getVersions(address _storage, bytes32 _exec_id, address _provider, bytes32 _app) external view returns (bytes32[] memory) {\n",
          "message": "Parameter '_storage' of RegistryIdx.getVersions (RegistryIdx.sol#934) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 934,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function getVersions(address _storage, bytes32 _exec_id, address _provider, bytes32 _app) external view returns (bytes32[] memory) {\n",
          "message": "Parameter '_exec_id' of RegistryIdx.getVersions (RegistryIdx.sol#934) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 934,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function getVersions(address _storage, bytes32 _exec_id, address _provider, bytes32 _app) external view returns (bytes32[] memory) {\n",
          "message": "Parameter '_provider' of RegistryIdx.getVersions (RegistryIdx.sol#934) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 934,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function getVersions(address _storage, bytes32 _exec_id, address _provider, bytes32 _app) external view returns (bytes32[] memory) {\n",
          "message": "Parameter '_app' of RegistryIdx.getVersions (RegistryIdx.sol#934) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 948,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function getLatestVersion(address _storage, bytes32 _exec_id, address _provider, bytes32 _app) external view returns (bytes32) {\n",
          "message": "Parameter '_storage' of RegistryIdx.getLatestVersion (RegistryIdx.sol#948) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 948,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function getLatestVersion(address _storage, bytes32 _exec_id, address _provider, bytes32 _app) external view returns (bytes32) {\n",
          "message": "Parameter '_exec_id' of RegistryIdx.getLatestVersion (RegistryIdx.sol#948) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 948,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function getLatestVersion(address _storage, bytes32 _exec_id, address _provider, bytes32 _app) external view returns (bytes32) {\n",
          "message": "Parameter '_provider' of RegistryIdx.getLatestVersion (RegistryIdx.sol#948) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 948,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function getLatestVersion(address _storage, bytes32 _exec_id, address _provider, bytes32 _app) external view returns (bytes32) {\n",
          "message": "Parameter '_app' of RegistryIdx.getLatestVersion (RegistryIdx.sol#948) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 960,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function getVersionImplementation(address _storage, bytes32 _exec_id, address _provider, bytes32 _app, bytes32 _version) external view\n",
          "message": "Parameter '_storage' of RegistryIdx.getVersionImplementation (RegistryIdx.sol#960) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 960,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function getVersionImplementation(address _storage, bytes32 _exec_id, address _provider, bytes32 _app, bytes32 _version) external view\n",
          "message": "Parameter '_exec_id' of RegistryIdx.getVersionImplementation (RegistryIdx.sol#960) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 960,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function getVersionImplementation(address _storage, bytes32 _exec_id, address _provider, bytes32 _app, bytes32 _version) external view\n",
          "message": "Parameter '_provider' of RegistryIdx.getVersionImplementation (RegistryIdx.sol#960) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 960,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function getVersionImplementation(address _storage, bytes32 _exec_id, address _provider, bytes32 _app, bytes32 _version) external view\n",
          "message": "Parameter '_app' of RegistryIdx.getVersionImplementation (RegistryIdx.sol#960) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 960,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function getVersionImplementation(address _storage, bytes32 _exec_id, address _provider, bytes32 _app, bytes32 _version) external view\n",
          "message": "Parameter '_version' of RegistryIdx.getVersionImplementation (RegistryIdx.sol#960) is not in mixedCase\n"
        },
        {
          "name": "unused-state",
          "vulnerability_from_line": 284,
          "vulnerability_to_line": null,
          "vulnerability_code": "  bytes4 internal constant THROWS = bytes4(keccak256('Error(string)'));\n",
          "message": "Contract.THROWS (RegistryIdx.sol#284) is never used in Contract\n"
        }
      ]
    },
    "smartcheck": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 105,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require(freeMem() == 0x80, \"Memory allocated prior to execution\");\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 141,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require(ptr >= 0x180, \"Invalid buffer pointer\");\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 156,
          "vulnerability_to_line": null,
          "vulnerability_code": "    if (freeMem() < 0x180)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 159,
          "vulnerability_to_line": null,
          "vulnerability_code": "    if (buffPtr() != 0 && buffPtr() < 0x180)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
          "vulnerability_from_line": 166,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function buffPtr() private pure returns (bytes32 ptr) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
          "vulnerability_from_line": 171,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function freeMem() private pure returns (bytes32 ptr) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
          "vulnerability_from_line": 259,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function execID() internal pure returns (bytes32 exec_id) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
          "vulnerability_from_line": 265,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function sender() internal pure returns (address addr) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
          "vulnerability_from_line": 802,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function expected() private pure returns (NextFunction next) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
          "vulnerability_from_line": 849,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function toBytes4Arr(bytes32[] memory _arr) internal pure returns (bytes4[] memory _conv) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
          "vulnerability_from_line": 853,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function toAddressArr(bytes32[] memory _arr) internal pure returns (address[] memory _conv) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
          "vulnerability_from_line": 857,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function toUintArr(bytes32[] memory _arr) internal pure returns (uint[] memory _conv) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.23;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 46,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.23;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 836,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.23;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 845,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.23;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 864,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.23;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_REVERT_REQUIRE",
          "vulnerability_from_line": 89,
          "vulnerability_to_line": null,
          "vulnerability_code": "    if (!authorized)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_REVERT_REQUIRE",
          "vulnerability_from_line": 156,
          "vulnerability_to_line": null,
          "vulnerability_code": "    if (freeMem() < 0x180)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_REVERT_REQUIRE",
          "vulnerability_from_line": 159,
          "vulnerability_to_line": null,
          "vulnerability_code": "    if (buffPtr() != 0 && buffPtr() < 0x180)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_REVERT_REQUIRE",
          "vulnerability_from_line": 185,
          "vulnerability_to_line": null,
          "vulnerability_code": "    if (currentAction() != STORES)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_REVERT_REQUIRE",
          "vulnerability_from_line": 191,
          "vulnerability_to_line": null,
          "vulnerability_code": "    if (currentAction() != EMITS)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_REVERT_REQUIRE",
          "vulnerability_from_line": 197,
          "vulnerability_to_line": null,
          "vulnerability_code": "    if (currentAction() != PAYS)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_REVERT_REQUIRE",
          "vulnerability_from_line": 225,
          "vulnerability_to_line": null,
          "vulnerability_code": "    if (stored() != 0 || currentAction() == STORES)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_REVERT_REQUIRE",
          "vulnerability_from_line": 237,
          "vulnerability_to_line": null,
          "vulnerability_code": "    if (emitted() != 0 || currentAction() == EMITS)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_REVERT_REQUIRE",
          "vulnerability_from_line": 249,
          "vulnerability_to_line": null,
          "vulnerability_code": "    if (paid() != 0 || currentAction() == PAYS)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_REVERT_REQUIRE",
          "vulnerability_from_line": 294,
          "vulnerability_to_line": null,
          "vulnerability_code": "    if (expected() != NextFunction.STORE_DEST)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_REVERT_REQUIRE",
          "vulnerability_from_line": 304,
          "vulnerability_to_line": null,
          "vulnerability_code": "    if (\n",
          "message": null
        },
        {
          "name": "SOLIDITY_REVERT_REQUIRE",
          "vulnerability_from_line": 317,
          "vulnerability_to_line": null,
          "vulnerability_code": "    if (expected() != NextFunction.PAY_DEST)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_REVERT_REQUIRE",
          "vulnerability_from_line": 327,
          "vulnerability_to_line": null,
          "vulnerability_code": "    if (expected() != NextFunction.PAY_AMT)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_REVERT_REQUIRE",
          "vulnerability_from_line": 337,
          "vulnerability_to_line": null,
          "vulnerability_code": "    if (expected() != NextFunction.EMIT_LOG)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_REVERT_REQUIRE",
          "vulnerability_from_line": 483,
          "vulnerability_to_line": null,
          "vulnerability_code": "    else if (expected() == NextFunction.VAL_DEC)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_REVERT_REQUIRE",
          "vulnerability_from_line": 506,
          "vulnerability_to_line": null,
          "vulnerability_code": "    if (expected() == NextFunction.VAL_DEC) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SAFEMATH",
          "vulnerability_from_line": 50,
          "vulnerability_to_line": null,
          "vulnerability_code": "  using SafeMath for uint;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 138,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function commit() conditions(validState, none) internal pure {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 155,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function validState() private pure {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 166,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function buffPtr() private pure returns (bytes32 ptr) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 171,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function freeMem() private pure returns (bytes32 ptr) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 176,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function currentAction() private pure returns (bytes4 action) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 202,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function startBuffer() private pure {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 259,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function execID() internal pure returns (bytes32 exec_id) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 265,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function sender() internal pure returns (address addr) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 346,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function storing() conditions(validStoreBuff, isStoring) internal pure {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 369,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function set(bytes32 _field) conditions(validStoreDest, validStoreVal) internal pure returns (bytes32) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 393,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function to(bytes32, bytes32 _val) conditions(validStoreVal, validStoreDest) internal pure {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 478,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function by(bytes32 _val, uint _amt) conditions(validStoreVal, validStoreDest) internal pure {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 503,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function byMaximum(bytes32 _val, uint _amt) conditions(validStoreVal, validStoreDest) internal pure {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 531,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function emitting() conditions(validEmitBuff, isEmitting) internal pure {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 553,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function log(bytes32 _data) conditions(validEvent, validEvent) internal pure {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 586,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function log(bytes32[1] memory _topics, bytes32 _data) conditions(validEvent, validEvent) internal pure {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 621,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function log(bytes32[2] memory _topics, bytes32 _data) conditions(validEvent, validEvent) internal pure {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 657,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function log(bytes32[3] memory _topics, bytes32 _data) conditions(validEvent, validEvent) internal pure {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 694,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function log(bytes32[4] memory _topics, bytes32 _data) conditions(validEvent, validEvent) internal pure {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 734,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function paying() conditions(validPayBuff, isPaying) internal pure {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 757,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function pay(uint _amount) conditions(validPayAmt, validPayDest) internal pure returns (uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 781,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function toAcc(uint, address _dest) conditions(validPayDest, validPayAmt) internal pure {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 797,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function setFreeMem() private pure {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 802,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function expected() private pure returns (NextFunction next) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 807,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function emitted() internal pure returns (uint num_emitted) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 816,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function stored() internal pure returns (uint num_stored) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 825,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function paid() internal pure returns (uint num_paid) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 849,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function toBytes4Arr(bytes32[] memory _arr) internal pure returns (bytes4[] memory _conv) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 853,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function toAddressArr(bytes32[] memory _arr) internal pure returns (address[] memory _conv) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 857,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function toUintArr(bytes32[] memory _arr) internal pure returns (uint[] memory _conv) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
          "vulnerability_from_line": 71,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function authorize(address _script_exec) internal view {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
          "vulnerability_from_line": 102,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function initialize() internal view {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
          "vulnerability_from_line": 274,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function read(bytes32 _location) internal view returns (bytes32 data) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
          "vulnerability_from_line": 426,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function increase(bytes32 _field) conditions(validStoreDest, validStoreVal) internal view returns (bytes32 val) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
          "vulnerability_from_line": 452,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function decrease(bytes32 _field) conditions(validStoreDest, validStoreVal) internal view returns (bytes32 val) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 275,
          "vulnerability_to_line": null,
          "vulnerability_code": "    data = keccak256(_location, execID());\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 428,
          "vulnerability_to_line": null,
          "vulnerability_code": "    val = keccak256(_field, execID());\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 454,
          "vulnerability_to_line": null,
          "vulnerability_code": "    val = keccak256(_field, execID());\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 877,
          "vulnerability_to_line": null,
          "vulnerability_code": "    { return keccak256(_exec, EXEC_PERMISSIONS); }\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 893,
          "vulnerability_to_line": null,
          "vulnerability_code": "    { return keccak256(bytes32(_provider), 'app_list'); }\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 897,
          "vulnerability_to_line": null,
          "vulnerability_code": "    { return keccak256(_app, keccak256(bytes32(_provider), 'app_base')); }\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 897,
          "vulnerability_to_line": null,
          "vulnerability_code": "    { return keccak256(_app, keccak256(bytes32(_provider), 'app_base')); }\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 901,
          "vulnerability_to_line": null,
          "vulnerability_code": "    { return keccak256('versions', appBase(_app, _provider)); }\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 905,
          "vulnerability_to_line": null,
          "vulnerability_code": "    { return keccak256(_version, 'version', appBase(_app, _provider)); }\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 909,
          "vulnerability_to_line": null,
          "vulnerability_code": "    { return keccak256('index', versionBase(_app, _version, _provider)); }\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 913,
          "vulnerability_to_line": null,
          "vulnerability_code": "    { return keccak256('selectors', versionBase(_app, _version, _provider)); }\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 917,
          "vulnerability_to_line": null,
          "vulnerability_code": "    { return keccak256('addresses', versionBase(_app, _version, _provider)); }\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 78,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 107,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 143,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 167,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly { ptr := mload(0xc0) }\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 172,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly { ptr := mload(0x40) }\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 180,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly { action := mload(0xe0) }\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 203,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 260,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly { exec_id := mload(0x80) }\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 266,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly { addr := mload(0xa0) }\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 276,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly { data := sload(data) }\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 348,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 370,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 394,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 429,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 455,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 488,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 515,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 533,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 554,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 587,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 622,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 658,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 695,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 736,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 758,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 782,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 798,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly { mstore(0x40, msize) }\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 803,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly { next := mload(0x100) }\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 812,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly { num_emitted := mload(0x140) }\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 821,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly { num_stored := mload(0x120) }\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 830,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly { num_paid := mload(0x160) }\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 850,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly { _conv := _arr }\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 854,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly { _conv := _arr }\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 858,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly { _conv := _arr }\n",
          "message": null
        }
      ]
    },
    "oyente": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": []
    },
    "mythril": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "External Call To User-Supplied Address (SWC 107)",
          "vulnerability_from_line": 952,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint length = uint(target.read(_exec_id, bytes32(seed)));\n",
          "message": "A call to a user-supplied address is executed.\nAn external message call to an address specified by the caller is executed. Note that the callee account might contain arbitrary code and could re-enter any function within this contract. Reentering the contract in an intermediate state may lead to unexpected behaviour. Make sure that no state modifications are executed after this call and/or reentrancy guards are in place.\nClassification: SWC-107"
        },
        {
          "name": "External Call To User-Supplied Address (SWC 107)",
          "vulnerability_from_line": 956,
          "vulnerability_to_line": null,
          "vulnerability_code": "    return target.read(_exec_id, bytes32(seed));\n",
          "message": "A call to a user-supplied address is executed.\nAn external message call to an address specified by the caller is executed. Note that the callee account might contain arbitrary code and could re-enter any function within this contract. Reentering the contract in an intermediate state may lead to unexpected behaviour. Make sure that no state modifications are executed after this call and/or reentrancy guards are in place.\nClassification: SWC-107"
        },
        {
          "name": "Multiple Calls in a Single Transaction (SWC 113)",
          "vulnerability_from_line": 956,
          "vulnerability_to_line": null,
          "vulnerability_code": "    return target.read(_exec_id, bytes32(seed));\n",
          "message": "Multiple calls are executed in the same transaction.\nThis call is executed following another call within the same transaction. It is possible that the call never gets executed if a prior call fails permanently. This might be caused intentionally by a malicious callee. If possible, refactor the code such that each transaction only executes one external call or make sure that all callees can be trusted (i.e. they\u2019re part of your own codebase).\nClassification: SWC-113"
        }
      ]
    },
    "osiris": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": []
    }
  }
}