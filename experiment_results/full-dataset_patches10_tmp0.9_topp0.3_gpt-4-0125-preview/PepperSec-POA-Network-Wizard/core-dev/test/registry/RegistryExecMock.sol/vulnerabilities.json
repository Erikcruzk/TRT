{
  "smartbugs_completed": true,
  "analyzer_results": {
    "semgrep": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 75,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require(app_storage == 0, \"ScriptExec already configured\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 76,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require(_app_storage != 0, 'Invalid input');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 159,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require(_app_name != 0 && _init_calldata.length >= 4, 'invalid input');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 297,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require(success, 'Execution failed');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 323,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require(_index != 0 && _implementation != 0, 'Invalid input');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 329,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require(exec_id != 0, 'Invalid response from storage');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 355,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require(_app_name != 0 && _index != 0, 'Invalid input');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 356,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require(_selectors.length == _implementations.length && _selectors.length != 0, 'Invalid input');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 358,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require(app_storage != 0 && registry_exec_id != 0 && provider != 0, 'Invalid state');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 367,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require(emitted == 0 && paid == 0 && stored != 0, 'Invalid state change');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 380,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require(_app_name != 0 && _version_name != 0 && _index != 0, 'Invalid input');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 381,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require(_selectors.length == _implementations.length && _selectors.length != 0, 'Invalid input');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 383,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require(app_storage != 0 && registry_exec_id != 0 && provider != 0, 'Invalid state');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 392,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require(emitted == 0 && paid == 0 && stored != 0, 'Invalid state change');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 407,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require(_exec_id != 0 && msg.sender == deployed_by[_exec_id], 'invalid sender or input');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 432,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require(success, 'Execution failed');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 444,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require(latest_version != 0, 'invalid latest version');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 476,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require(success, 'Execution failed');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 159,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require(_app_name != 0 && _init_calldata.length >= 4, 'invalid input');\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 276,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require(\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 277,
          "vulnerability_to_line": null,
          "vulnerability_code": "      sel != this.registerApp.selector &&\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 278,
          "vulnerability_to_line": null,
          "vulnerability_code": "      sel != this.registerAppVersion.selector &&\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 279,
          "vulnerability_to_line": null,
          "vulnerability_code": "      sel != UPDATE_INST_SEL &&\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 280,
          "vulnerability_to_line": null,
          "vulnerability_code": "      sel != UPDATE_EXEC_SEL\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 281,
          "vulnerability_to_line": null,
          "vulnerability_code": "    );\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 323,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require(_index != 0 && _implementation != 0, 'Invalid input');\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 355,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require(_app_name != 0 && _index != 0, 'Invalid input');\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 356,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require(_selectors.length == _implementations.length && _selectors.length != 0, 'Invalid input');\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 358,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require(app_storage != 0 && registry_exec_id != 0 && provider != 0, 'Invalid state');\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 367,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require(emitted == 0 && paid == 0 && stored != 0, 'Invalid state change');\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 380,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require(_app_name != 0 && _version_name != 0 && _index != 0, 'Invalid input');\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 381,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require(_selectors.length == _implementations.length && _selectors.length != 0, 'Invalid input');\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 383,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require(app_storage != 0 && registry_exec_id != 0 && provider != 0, 'Invalid state');\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 392,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require(emitted == 0 && paid == 0 && stored != 0, 'Invalid state change');\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 407,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require(_exec_id != 0 && msg.sender == deployed_by[_exec_id], 'invalid sender or input');\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        }
      ]
    },
    "slither": {
      "successfull_analysis": true,
      "errors": [
        "EXIT_CODE_80"
      ],
      "vulnerability_findings": [
        {
          "name": "arbitrary-send",
          "vulnerability_from_line": 272,
          "vulnerability_to_line": 301,
          "vulnerability_code": "  function exec(bytes32 _exec_id, bytes _calldata) external payable returns (bool success) {\n\n    // Get function selector from calldata -\n\n    bytes4 sel = getSelector(_calldata);\n\n    // Ensure no registry functions are being called -\n\n    require(\n\n      sel != this.registerApp.selector &&\n\n      sel != this.registerAppVersion.selector &&\n\n      sel != UPDATE_INST_SEL &&\n\n      sel != UPDATE_EXEC_SEL\n\n    );\n\n\n\n    // Call 'exec' in AbstractStorage, passing in the sender's address, the app exec id, and the calldata to forward -\n\n    if (address(app_storage).call.value(msg.value)(abi.encodeWithSelector(\n\n      EXEC_SEL, msg.sender, _exec_id, _calldata\n\n    )) == false) {\n\n      // Call failed - emit error message from storage and return 'false'\n\n      checkErrors(_exec_id);\n\n      // Return unspent wei to sender\n\n      address(msg.sender).transfer(address(this).balance);\n\n      return false;\n\n    }\n\n\n\n    // Get returned data\n\n    success = checkReturn();\n\n    // If execution failed,\n\n    require(success, 'Execution failed');\n\n\n\n    // Transfer any returned wei back to the sender\n\n    address(msg.sender).transfer(address(this).balance);\n",
          "message": "RegistryExecMock.exec (RegistryExecMock.sol#272-301) sends eth to arbitrary user\n\tDangerous calls:\n\t- address(msg.sender).transfer(address(this).balance) (RegistryExecMock.sol#290)\n\t- address(msg.sender).transfer(address(this).balance) (RegistryExecMock.sol#300)\n"
        },
        {
          "name": "shadowing-state",
          "vulnerability_from_line": 263,
          "vulnerability_to_line": null,
          "vulnerability_code": "  bytes4 internal constant EXEC_SEL = bytes4(keccak256('exec(address,bytes32,bytes)'));\n",
          "message": "RegistryExecMock.EXEC_SEL (RegistryExecMock.sol#263) shadows:\n\t- ScriptExecMock.EXEC_SEL (RegistryExecMock.sol#87)\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 101,
          "vulnerability_to_line": 106,
          "vulnerability_code": "  function getAction(uint _ptr) internal pure returns (bytes4 action) {\n\n    assembly {\n\n      // Get the first 4 bytes stored at the pointer, and clean the rest of the bytes remaining\n\n      action := and(mload(_ptr), 0xffffffff00000000000000000000000000000000000000000000000000000000)\n\n    }\n",
          "message": "ScriptExecMock.getAction (RegistryExecMock.sol#101-106) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 132,
          "vulnerability_to_line": 146,
          "vulnerability_code": "  function checkReturn() internal pure returns (bool success) {\n\n    success = false;\n\n    assembly {\n\n      // returndata size must be 0x60 bytes\n\n      if eq(returndatasize, 0x60) {\n\n        // Copy returned data to pointer and check that at least one value is nonzero\n\n        let ptr := mload(0x40)\n\n        returndatacopy(ptr, 0, returndatasize)\n\n        if iszero(iszero(mload(ptr))) { success := 1 }\n\n        if iszero(iszero(mload(add(0x20, ptr)))) { success := 1 }\n\n        if iszero(iszero(mload(add(0x40, ptr)))) { success := 1 }\n\n      }\n\n    }\n\n    return success;\n",
          "message": "ScriptExecMock.checkReturn (RegistryExecMock.sol#132-146) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 304,
          "vulnerability_to_line": 311,
          "vulnerability_code": "  function getSelector(bytes memory _calldata) internal pure returns (bytes4 selector) {\n\n    assembly {\n\n      selector := and(\n\n        mload(add(0x20, _calldata)),\n\n        0xffffffff00000000000000000000000000000000000000000000000000000000\n\n      )\n\n    }\n",
          "message": "RegistryExecMock.getSelector (RegistryExecMock.sol#304-311) is declared view but contains assembly code\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 405,
          "vulnerability_to_line": 447,
          "vulnerability_code": "  function updateAppInstance(bytes32 _exec_id) external returns (bool success) {\n\n    // Validate input. Only the original deployer can update an application -\n\n    require(_exec_id != 0 && msg.sender == deployed_by[_exec_id], 'invalid sender or input');\n\n\n\n    // Get instance metadata from exec id -\n\n    Instance memory inst = instance_info[_exec_id];\n\n\n\n    // Call 'exec' in AbstractStorage, passing in the sender's address, the execution id, and\n\n    // the calldata to update the application -\n\n    if(address(app_storage).call(\n\n      abi.encodeWithSelector(EXEC_SEL,            // 'exec' selector\n\n        inst.current_provider,                    // application provider address\n\n        _exec_id,                                 // execution id to update\n\n        abi.encodeWithSelector(UPDATE_INST_SEL,   // calldata for Registry updateInstance function\n\n          inst.app_name,                          // name of the applcation used by the instance\n\n          inst.version_name,                      // name of the current version of the application\n\n          inst.current_registry_exec_id           // registry exec id when the instance was instantiated\n\n        )\n\n      )\n\n    ) == false) {\n\n      // Call failed - emit error message from storage and return 'false'\n\n      checkErrors(_exec_id);\n\n      return false;\n\n    }\n\n    // Check returned data to ensure state was correctly changed in AbstractStorage -\n\n    success = checkReturn();\n\n    // If execution failed, revert state and return an error message -\n\n    require(success, 'Execution failed');\n\n\n\n    // If execution was successful, the version was updated. Get the latest version\n\n    // and set the exec id instance info -\n\n    address registry_idx = StorageInterface(app_storage).getIndex(inst.current_registry_exec_id);\n\n    bytes32 latest_version  = RegistryInterface(registry_idx).getLatestVersion(\n\n      app_storage,\n\n      inst.current_registry_exec_id,\n\n      inst.current_provider,\n\n      inst.app_name\n\n    );\n\n    // Ensure nonzero latest version -\n\n    require(latest_version != 0, 'invalid latest version');\n\n    // Set current version -\n\n    instance_info[_exec_id].version_name = latest_version;\n",
          "message": "Reentrancy in RegistryExecMock.updateAppInstance (RegistryExecMock.sol#405-447):\n\tExternal calls:\n\t- registry_idx = StorageInterface(app_storage).getIndex(inst.current_registry_exec_id) (RegistryExecMock.sol#436)\n\t- latest_version = RegistryInterface(registry_idx).getLatestVersion(app_storage,inst.current_registry_exec_id,inst.current_provider,inst.app_name) (RegistryExecMock.sol#437-442)\n\tState variables written after the call(s):\n\t- instance_info (RegistryExecMock.sol#446)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 158,
          "vulnerability_to_line": 173,
          "vulnerability_code": "  function createAppInstance(bytes32 _app_name, bytes _init_calldata) external returns (bytes32 exec_id, bytes32 version) {\n\n    require(_app_name != 0 && _init_calldata.length >= 4, 'invalid input');\n\n    (exec_id, version) = StorageInterface(app_storage).createInstance(\n\n      msg.sender, _app_name, provider, registry_exec_id, _init_calldata\n\n    );\n\n    // Set various app metadata values -\n\n    deployed_by[exec_id] = msg.sender;\n\n    app_instances[_app_name].push(exec_id);\n\n    Instance memory inst = Instance(\n\n      provider, registry_exec_id, exec_id, _app_name, version\n\n    );\n\n    instance_info[exec_id] = inst;\n\n    deployed_instances[msg.sender].push(inst);\n\n    // Emit event -\n\n    emit AppInstanceCreated(msg.sender, exec_id, _app_name, version);\n",
          "message": "Reentrancy in ScriptExecMock.createAppInstance (RegistryExecMock.sol#158-173):\n\tExternal calls:\n\t- (exec_id,version) = StorageInterface(app_storage).createInstance(msg.sender,_app_name,provider,registry_exec_id,_init_calldata) (RegistryExecMock.sol#160-162)\n\tState variables written after the call(s):\n\t- app_instances (RegistryExecMock.sol#165)\n\t- deployed_by (RegistryExecMock.sol#164)\n\t- deployed_instances (RegistryExecMock.sol#170)\n\t- instance_info (RegistryExecMock.sol#169)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 321,
          "vulnerability_to_line": 344,
          "vulnerability_code": "  function createRegistryInstance(address _index, address _implementation) external onlyAdmin() returns (bytes32 exec_id) {\n\n    // Validate input -\n\n    require(_index != 0 && _implementation != 0, 'Invalid input');\n\n\n\n    // Creates a registry from storage and returns the registry exec id -\n\n    exec_id = StorageInterface(app_storage).createRegistry(_index, _implementation);\n\n\n\n    // Ensure a valid execution id returned from storage -\n\n    require(exec_id != 0, 'Invalid response from storage');\n\n\n\n    // If there is not already a default registry exec id set, set it\n\n    if (registry_exec_id == 0)\n\n      registry_exec_id = exec_id;\n\n\n\n    // Create Registry struct in memory -\n\n    Registry memory reg = Registry(_index, _implementation);\n\n\n\n    // Set various app metadata values -\n\n    deployed_by[exec_id] = msg.sender;\n\n    registry_instance_info[exec_id] = reg;\n\n    deployed_registry_instances[msg.sender].push(reg);\n\n    // Emit event -\n\n    emit RegistryInstanceCreated(msg.sender, exec_id, _index, _implementation);\n",
          "message": "Reentrancy in RegistryExecMock.createRegistryInstance (RegistryExecMock.sol#321-344):\n\tExternal calls:\n\t- exec_id = StorageInterface(app_storage).createRegistry(_index,_implementation) (RegistryExecMock.sol#326)\n\tState variables written after the call(s):\n\t- deployed_by (RegistryExecMock.sol#339)\n\t- deployed_registry_instances (RegistryExecMock.sol#341)\n\t- registry_exec_id (RegistryExecMock.sol#333)\n\t- registry_instance_info (RegistryExecMock.sol#340)\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 101,
          "vulnerability_to_line": 106,
          "vulnerability_code": "  function getAction(uint _ptr) internal pure returns (bytes4 action) {\n\n    assembly {\n\n      // Get the first 4 bytes stored at the pointer, and clean the rest of the bytes remaining\n\n      action := and(mload(_ptr), 0xffffffff00000000000000000000000000000000000000000000000000000000)\n\n    }\n",
          "message": "ScriptExecMock.getAction uses assembly (RegistryExecMock.sol#101-106)\n\t- RegistryExecMock.sol#102-106\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 109,
          "vulnerability_to_line": 129,
          "vulnerability_code": "  function checkErrors(bytes32 _exec_id) internal {\n\n    // If the returned data begins with selector 'Error(string)', get the contained message -\n\n    string memory message;\n\n    bytes4 err_sel = ERR;\n\n    assembly {\n\n      // Get pointer to free memory, place returned data at pointer, and update free memory pointer\n\n      let ptr := mload(0x40)\n\n      returndatacopy(ptr, 0, returndatasize)\n\n      mstore(0x40, add(ptr, returndatasize))\n\n\n\n      // Check value at pointer for equality with Error selector -\n\n      if eq(mload(ptr), and(err_sel, 0xffffffff00000000000000000000000000000000000000000000000000000000)) {\n\n        message := add(0x24, ptr)\n\n      }\n\n    }\n\n    // If no returned message exists, emit a default error message. Otherwise, emit the error message\n\n    if (bytes(message).length == 0)\n\n      emit StorageException(_exec_id, \"No error recieved\");\n\n    else\n\n      emit StorageException(_exec_id, message);\n",
          "message": "ScriptExecMock.checkErrors uses assembly (RegistryExecMock.sol#109-129)\n\t- RegistryExecMock.sol#113-125\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 132,
          "vulnerability_to_line": 146,
          "vulnerability_code": "  function checkReturn() internal pure returns (bool success) {\n\n    success = false;\n\n    assembly {\n\n      // returndata size must be 0x60 bytes\n\n      if eq(returndatasize, 0x60) {\n\n        // Copy returned data to pointer and check that at least one value is nonzero\n\n        let ptr := mload(0x40)\n\n        returndatacopy(ptr, 0, returndatasize)\n\n        if iszero(iszero(mload(ptr))) { success := 1 }\n\n        if iszero(iszero(mload(add(0x20, ptr)))) { success := 1 }\n\n        if iszero(iszero(mload(add(0x40, ptr)))) { success := 1 }\n\n      }\n\n    }\n\n    return success;\n",
          "message": "ScriptExecMock.checkReturn uses assembly (RegistryExecMock.sol#132-146)\n\t- RegistryExecMock.sol#134-145\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 304,
          "vulnerability_to_line": 311,
          "vulnerability_code": "  function getSelector(bytes memory _calldata) internal pure returns (bytes4 selector) {\n\n    assembly {\n\n      selector := and(\n\n        mload(add(0x20, _calldata)),\n\n        0xffffffff00000000000000000000000000000000000000000000000000000000\n\n      )\n\n    }\n",
          "message": "RegistryExecMock.getSelector uses assembly (RegistryExecMock.sol#304-311)\n\t- RegistryExecMock.sol#305-311\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 66,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function () public payable { }\n",
          "message": "ScriptExecMock.fallback (RegistryExecMock.sol#66) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 74,
          "vulnerability_to_line": 83,
          "vulnerability_code": "  function configure(address _exec_admin, address _app_storage, address _provider) public {\n\n    require(app_storage == 0, \"ScriptExec already configured\");\n\n    require(_app_storage != 0, 'Invalid input');\n\n    exec_admin = _exec_admin;\n\n    app_storage = _app_storage;\n\n    provider = _provider;\n\n\n\n    if (exec_admin == 0)\n\n      exec_admin = msg.sender;\n",
          "message": "ScriptExecMock.configure (RegistryExecMock.sol#74-83) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 181,
          "vulnerability_to_line": 183,
          "vulnerability_code": "  function setRegistryExecID(bytes32 _exec_id) public onlyAdmin() {\n\n    registry_exec_id = _exec_id;\n",
          "message": "ScriptExecMock.setRegistryExecID (RegistryExecMock.sol#181-183) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 189,
          "vulnerability_to_line": 191,
          "vulnerability_code": "  function setProvider(address _provider) public onlyAdmin() {\n\n    provider = _provider;\n",
          "message": "ScriptExecMock.setProvider (RegistryExecMock.sol#189-191) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 194,
          "vulnerability_to_line": 197,
          "vulnerability_code": "  function setAdmin(address _admin) public onlyAdmin() {\n\n    require(_admin != 0);\n\n    exec_admin = _admin;\n",
          "message": "ScriptExecMock.setAdmin (RegistryExecMock.sol#194-197) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 202,
          "vulnerability_to_line": 204,
          "vulnerability_code": "  function getInstances(bytes32 _app_name) public view returns (bytes32[] memory) {\n\n    return app_instances[_app_name];\n",
          "message": "ScriptExecMock.getInstances (RegistryExecMock.sol#202-204) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 211,
          "vulnerability_to_line": 213,
          "vulnerability_code": "  function getDeployedLength(address _deployer) public view returns (uint) {\n\n    return deployed_instances[_deployer].length;\n",
          "message": "ScriptExecMock.getDeployedLength (RegistryExecMock.sol#211-213) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 223,
          "vulnerability_to_line": 226,
          "vulnerability_code": "  function getRegistryImplementation() public view returns (address index, address implementation) {\n\n    index = StorageInterface(app_storage).getIndex(registry_exec_id);\n\n    implementation = StorageInterface(app_storage).getTarget(registry_exec_id, REGISTER_APP_SEL);\n",
          "message": "ScriptExecMock.getRegistryImplementation (RegistryExecMock.sol#223-226) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 235,
          "vulnerability_to_line": 242,
          "vulnerability_code": "  function getInstanceImplementation(bytes32 _exec_id) public view\n\n  returns (address index, bytes4[] memory functions, address[] memory implementations) {\n\n    Instance memory app = instance_info[_exec_id];\n\n    index = StorageInterface(app_storage).getIndex(app.current_registry_exec_id);\n\n    (index, functions, implementations) = RegistryInterface(index).getVersionImplementation(\n\n      app_storage, app.current_registry_exec_id, app.current_provider, app.app_name, app.version_name\n\n    );\n",
          "message": "ScriptExecMock.getInstanceImplementation (RegistryExecMock.sol#235-242) should be declared external\n"
        },
        {
          "name": "solc-version",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.23;\n",
          "message": "Detected issues with version pragma in RegistryExecMock.sol:\n\t- pragma solidity^0.4.23 (RegistryExecMock.sol#3): it allows old versions\n"
        },
        {
          "name": "low-level-calls",
          "vulnerability_from_line": 272,
          "vulnerability_to_line": 301,
          "vulnerability_code": "  function exec(bytes32 _exec_id, bytes _calldata) external payable returns (bool success) {\n\n    // Get function selector from calldata -\n\n    bytes4 sel = getSelector(_calldata);\n\n    // Ensure no registry functions are being called -\n\n    require(\n\n      sel != this.registerApp.selector &&\n\n      sel != this.registerAppVersion.selector &&\n\n      sel != UPDATE_INST_SEL &&\n\n      sel != UPDATE_EXEC_SEL\n\n    );\n\n\n\n    // Call 'exec' in AbstractStorage, passing in the sender's address, the app exec id, and the calldata to forward -\n\n    if (address(app_storage).call.value(msg.value)(abi.encodeWithSelector(\n\n      EXEC_SEL, msg.sender, _exec_id, _calldata\n\n    )) == false) {\n\n      // Call failed - emit error message from storage and return 'false'\n\n      checkErrors(_exec_id);\n\n      // Return unspent wei to sender\n\n      address(msg.sender).transfer(address(this).balance);\n\n      return false;\n\n    }\n\n\n\n    // Get returned data\n\n    success = checkReturn();\n\n    // If execution failed,\n\n    require(success, 'Execution failed');\n\n\n\n    // Transfer any returned wei back to the sender\n\n    address(msg.sender).transfer(address(this).balance);\n",
          "message": "Low level call in RegistryExecMock.exec (RegistryExecMock.sol#272-301):\n\t-address(app_storage).call.value(msg.value)(abi.encodeWithSelector(EXEC_SEL,msg.sender,_exec_id,_calldata)) == false RegistryExecMock.sol#284-292\n"
        },
        {
          "name": "low-level-calls",
          "vulnerability_from_line": 405,
          "vulnerability_to_line": 447,
          "vulnerability_code": "  function updateAppInstance(bytes32 _exec_id) external returns (bool success) {\n\n    // Validate input. Only the original deployer can update an application -\n\n    require(_exec_id != 0 && msg.sender == deployed_by[_exec_id], 'invalid sender or input');\n\n\n\n    // Get instance metadata from exec id -\n\n    Instance memory inst = instance_info[_exec_id];\n\n\n\n    // Call 'exec' in AbstractStorage, passing in the sender's address, the execution id, and\n\n    // the calldata to update the application -\n\n    if(address(app_storage).call(\n\n      abi.encodeWithSelector(EXEC_SEL,            // 'exec' selector\n\n        inst.current_provider,                    // application provider address\n\n        _exec_id,                                 // execution id to update\n\n        abi.encodeWithSelector(UPDATE_INST_SEL,   // calldata for Registry updateInstance function\n\n          inst.app_name,                          // name of the applcation used by the instance\n\n          inst.version_name,                      // name of the current version of the application\n\n          inst.current_registry_exec_id           // registry exec id when the instance was instantiated\n\n        )\n\n      )\n\n    ) == false) {\n\n      // Call failed - emit error message from storage and return 'false'\n\n      checkErrors(_exec_id);\n\n      return false;\n\n    }\n\n    // Check returned data to ensure state was correctly changed in AbstractStorage -\n\n    success = checkReturn();\n\n    // If execution failed, revert state and return an error message -\n\n    require(success, 'Execution failed');\n\n\n\n    // If execution was successful, the version was updated. Get the latest version\n\n    // and set the exec id instance info -\n\n    address registry_idx = StorageInterface(app_storage).getIndex(inst.current_registry_exec_id);\n\n    bytes32 latest_version  = RegistryInterface(registry_idx).getLatestVersion(\n\n      app_storage,\n\n      inst.current_registry_exec_id,\n\n      inst.current_provider,\n\n      inst.app_name\n\n    );\n\n    // Ensure nonzero latest version -\n\n    require(latest_version != 0, 'invalid latest version');\n\n    // Set current version -\n\n    instance_info[_exec_id].version_name = latest_version;\n",
          "message": "Low level call in RegistryExecMock.updateAppInstance (RegistryExecMock.sol#405-447):\n\t-address(app_storage).call(abi.encodeWithSelector(EXEC_SEL,inst.current_provider,_exec_id,abi.encodeWithSelector(UPDATE_INST_SEL,inst.app_name,inst.version_name,inst.current_registry_exec_id))) == false RegistryExecMock.sol#414-428\n"
        },
        {
          "name": "low-level-calls",
          "vulnerability_from_line": 459,
          "vulnerability_to_line": 477,
          "vulnerability_code": "  function updateAppExec(bytes32 _exec_id, address _new_exec_addr) external returns (bool success) {\n\n    // Call 'exec' in AbstractStorage, passing in the sender's address, the execution id, and\n\n    // the calldata to migrate the script exec address -\n\n    if(address(app_storage).call(\n\n      abi.encodeWithSelector(EXEC_SEL,                            // 'exec' selector\n\n        msg.sender,                                               // sender address\n\n        _exec_id,                                                 // execution id to update\n\n        abi.encodeWithSelector(UPDATE_EXEC_SEL, _new_exec_addr)   // calldata for Registry updateExec\n\n      )\n\n    ) == false) {\n\n      // Call failed - emit error message from storage and return 'false'\n\n      checkErrors(_exec_id);\n\n      return false;\n\n    }\n\n    // Check returned data to ensure state was correctly changed in AbstractStorage -\n\n    success = checkReturn();\n\n    // If execution failed, revert state and return an error message -\n\n    require(success, 'Execution failed');\n",
          "message": "Low level call in RegistryExecMock.updateAppExec (RegistryExecMock.sol#459-477):\n\t-address(app_storage).call(abi.encodeWithSelector(EXEC_SEL,msg.sender,_exec_id,abi.encodeWithSelector(UPDATE_EXEC_SEL,_new_exec_addr))) == false RegistryExecMock.sol#462-472\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 6,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function getTarget(bytes32 exec_id, bytes4 selector)\n",
          "message": "Parameter 'exec_id' of StorageInterface.getTarget (RegistryExecMock.sol#6) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 8,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function getIndex(bytes32 exec_id) external view returns (address index);\n",
          "message": "Parameter 'exec_id' of StorageInterface.getIndex (RegistryExecMock.sol#8) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 9,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function createInstance(address sender, bytes32 app_name, address provider, bytes32 registry_exec_id, bytes calldata)\n",
          "message": "Parameter 'app_name' of StorageInterface.createInstance (RegistryExecMock.sol#9) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 9,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function createInstance(address sender, bytes32 app_name, address provider, bytes32 registry_exec_id, bytes calldata)\n",
          "message": "Parameter 'registry_exec_id' of StorageInterface.createInstance (RegistryExecMock.sol#9) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 11,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function updateInstance(address _sender, bytes32 _exec_id, bytes32 _app_name, address _provider, bytes32 _registry_id) external\n",
          "message": "Parameter '_exec_id' of StorageInterface.updateInstance (RegistryExecMock.sol#11) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 11,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function updateInstance(address _sender, bytes32 _exec_id, bytes32 _app_name, address _provider, bytes32 _registry_id) external\n",
          "message": "Parameter '_app_name' of StorageInterface.updateInstance (RegistryExecMock.sol#11) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 11,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function updateInstance(address _sender, bytes32 _exec_id, bytes32 _app_name, address _provider, bytes32 _registry_id) external\n",
          "message": "Parameter '_registry_id' of StorageInterface.updateInstance (RegistryExecMock.sol#11) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 13,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function updateExec(bytes32 exec_id, address new_exec) external;\n",
          "message": "Parameter 'exec_id' of StorageInterface.updateExec (RegistryExecMock.sol#13) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 13,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function updateExec(bytes32 exec_id, address new_exec) external;\n",
          "message": "Parameter 'new_exec' of StorageInterface.updateExec (RegistryExecMock.sol#13) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 15,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function exec(address sender, bytes32 exec_id, bytes calldata)\n",
          "message": "Parameter 'exec_id' of StorageInterface.exec (RegistryExecMock.sol#15) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 20,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function getLatestVersion(address stor_addr, bytes32 exec_id, address provider, bytes32 app_name)\n",
          "message": "Parameter 'stor_addr' of RegistryInterface.getLatestVersion (RegistryExecMock.sol#20) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 20,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function getLatestVersion(address stor_addr, bytes32 exec_id, address provider, bytes32 app_name)\n",
          "message": "Parameter 'exec_id' of RegistryInterface.getLatestVersion (RegistryExecMock.sol#20) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 20,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function getLatestVersion(address stor_addr, bytes32 exec_id, address provider, bytes32 app_name)\n",
          "message": "Parameter 'app_name' of RegistryInterface.getLatestVersion (RegistryExecMock.sol#20) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 22,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function getVersionImplementation(address stor_addr, bytes32 exec_id, address provider, bytes32 app_name, bytes32 version_name)\n",
          "message": "Parameter 'stor_addr' of RegistryInterface.getVersionImplementation (RegistryExecMock.sol#22) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 22,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function getVersionImplementation(address stor_addr, bytes32 exec_id, address provider, bytes32 app_name, bytes32 version_name)\n",
          "message": "Parameter 'exec_id' of RegistryInterface.getVersionImplementation (RegistryExecMock.sol#22) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 22,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function getVersionImplementation(address stor_addr, bytes32 exec_id, address provider, bytes32 app_name, bytes32 version_name)\n",
          "message": "Parameter 'app_name' of RegistryInterface.getVersionImplementation (RegistryExecMock.sol#22) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 22,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function getVersionImplementation(address stor_addr, bytes32 exec_id, address provider, bytes32 app_name, bytes32 version_name)\n",
          "message": "Parameter 'version_name' of RegistryInterface.getVersionImplementation (RegistryExecMock.sol#22) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 74,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function configure(address _exec_admin, address _app_storage, address _provider) public {\n",
          "message": "Parameter '_exec_admin' of ScriptExecMock.configure (RegistryExecMock.sol#74) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 74,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function configure(address _exec_admin, address _app_storage, address _provider) public {\n",
          "message": "Parameter '_app_storage' of ScriptExecMock.configure (RegistryExecMock.sol#74) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 74,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function configure(address _exec_admin, address _app_storage, address _provider) public {\n",
          "message": "Parameter '_provider' of ScriptExecMock.configure (RegistryExecMock.sol#74) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 96,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function exec(bytes32 _exec_id, bytes _calldata) external payable returns (bool success);\n",
          "message": "Parameter '_exec_id' of ScriptExecMock.exec (RegistryExecMock.sol#96) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 109,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function checkErrors(bytes32 _exec_id) internal {\n",
          "message": "Parameter '_exec_id' of ScriptExecMock.checkErrors (RegistryExecMock.sol#109) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 158,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function createAppInstance(bytes32 _app_name, bytes _init_calldata) external returns (bytes32 exec_id, bytes32 version) {\n",
          "message": "Parameter '_app_name' of ScriptExecMock.createAppInstance (RegistryExecMock.sol#158) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 158,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function createAppInstance(bytes32 _app_name, bytes _init_calldata) external returns (bytes32 exec_id, bytes32 version) {\n",
          "message": "Parameter '_init_calldata' of ScriptExecMock.createAppInstance (RegistryExecMock.sol#158) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 181,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function setRegistryExecID(bytes32 _exec_id) public onlyAdmin() {\n",
          "message": "Parameter '_exec_id' of ScriptExecMock.setRegistryExecID (RegistryExecMock.sol#181) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 189,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function setProvider(address _provider) public onlyAdmin() {\n",
          "message": "Parameter '_provider' of ScriptExecMock.setProvider (RegistryExecMock.sol#189) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 194,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function setAdmin(address _admin) public onlyAdmin() {\n",
          "message": "Parameter '_admin' of ScriptExecMock.setAdmin (RegistryExecMock.sol#194) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 202,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function getInstances(bytes32 _app_name) public view returns (bytes32[] memory) {\n",
          "message": "Parameter '_app_name' of ScriptExecMock.getInstances (RegistryExecMock.sol#202) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 211,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function getDeployedLength(address _deployer) public view returns (uint) {\n",
          "message": "Parameter '_deployer' of ScriptExecMock.getDeployedLength (RegistryExecMock.sol#211) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 235,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function getInstanceImplementation(bytes32 _exec_id) public view\n",
          "message": "Parameter '_exec_id' of ScriptExecMock.getInstanceImplementation (RegistryExecMock.sol#235) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 30,
          "vulnerability_to_line": null,
          "vulnerability_code": "  address public app_storage;\n",
          "message": "Variable 'ScriptExecMock.app_storage' (RegistryExecMock.sol#30) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 32,
          "vulnerability_to_line": null,
          "vulnerability_code": "  bytes32 public registry_exec_id;\n",
          "message": "Variable 'ScriptExecMock.registry_exec_id' (RegistryExecMock.sol#32) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 33,
          "vulnerability_to_line": null,
          "vulnerability_code": "  address public exec_admin;\n",
          "message": "Variable 'ScriptExecMock.exec_admin' (RegistryExecMock.sol#33) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 46,
          "vulnerability_to_line": null,
          "vulnerability_code": "  mapping (bytes32 => address) public deployed_by;\n",
          "message": "Variable 'ScriptExecMock.deployed_by' (RegistryExecMock.sol#46) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 48,
          "vulnerability_to_line": null,
          "vulnerability_code": "  mapping (bytes32 => Instance) public instance_info;\n",
          "message": "Variable 'ScriptExecMock.instance_info' (RegistryExecMock.sol#48) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 50,
          "vulnerability_to_line": null,
          "vulnerability_code": "  mapping (address => Instance[]) public deployed_instances;\n",
          "message": "Variable 'ScriptExecMock.deployed_instances' (RegistryExecMock.sol#50) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 52,
          "vulnerability_to_line": null,
          "vulnerability_code": "  mapping (bytes32 => bytes32[]) public app_instances;\n",
          "message": "Variable 'ScriptExecMock.app_instances' (RegistryExecMock.sol#52) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 272,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function exec(bytes32 _exec_id, bytes _calldata) external payable returns (bool success) {\n",
          "message": "Parameter '_exec_id' of RegistryExecMock.exec (RegistryExecMock.sol#272) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 272,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function exec(bytes32 _exec_id, bytes _calldata) external payable returns (bool success) {\n",
          "message": "Parameter '_calldata' of RegistryExecMock.exec (RegistryExecMock.sol#272) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 321,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function createRegistryInstance(address _index, address _implementation) external onlyAdmin() returns (bytes32 exec_id) {\n",
          "message": "Parameter '_index' of RegistryExecMock.createRegistryInstance (RegistryExecMock.sol#321) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 321,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function createRegistryInstance(address _index, address _implementation) external onlyAdmin() returns (bytes32 exec_id) {\n",
          "message": "Parameter '_implementation' of RegistryExecMock.createRegistryInstance (RegistryExecMock.sol#321) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 353,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function registerApp(bytes32 _app_name, address _index, bytes4[] _selectors, address[] _implementations) external onlyAdmin() {\n",
          "message": "Parameter '_app_name' of RegistryExecMock.registerApp (RegistryExecMock.sol#353) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 353,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function registerApp(bytes32 _app_name, address _index, bytes4[] _selectors, address[] _implementations) external onlyAdmin() {\n",
          "message": "Parameter '_index' of RegistryExecMock.registerApp (RegistryExecMock.sol#353) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 353,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function registerApp(bytes32 _app_name, address _index, bytes4[] _selectors, address[] _implementations) external onlyAdmin() {\n",
          "message": "Parameter '_selectors' of RegistryExecMock.registerApp (RegistryExecMock.sol#353) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 353,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function registerApp(bytes32 _app_name, address _index, bytes4[] _selectors, address[] _implementations) external onlyAdmin() {\n",
          "message": "Parameter '_implementations' of RegistryExecMock.registerApp (RegistryExecMock.sol#353) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 378,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function registerAppVersion(bytes32 _app_name, bytes32 _version_name, address _index, bytes4[] _selectors, address[] _implementations) external onlyAdmin() {\n",
          "message": "Parameter '_app_name' of RegistryExecMock.registerAppVersion (RegistryExecMock.sol#378) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 378,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function registerAppVersion(bytes32 _app_name, bytes32 _version_name, address _index, bytes4[] _selectors, address[] _implementations) external onlyAdmin() {\n",
          "message": "Parameter '_version_name' of RegistryExecMock.registerAppVersion (RegistryExecMock.sol#378) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 378,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function registerAppVersion(bytes32 _app_name, bytes32 _version_name, address _index, bytes4[] _selectors, address[] _implementations) external onlyAdmin() {\n",
          "message": "Parameter '_index' of RegistryExecMock.registerAppVersion (RegistryExecMock.sol#378) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 378,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function registerAppVersion(bytes32 _app_name, bytes32 _version_name, address _index, bytes4[] _selectors, address[] _implementations) external onlyAdmin() {\n",
          "message": "Parameter '_selectors' of RegistryExecMock.registerAppVersion (RegistryExecMock.sol#378) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 378,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function registerAppVersion(bytes32 _app_name, bytes32 _version_name, address _index, bytes4[] _selectors, address[] _implementations) external onlyAdmin() {\n",
          "message": "Parameter '_implementations' of RegistryExecMock.registerAppVersion (RegistryExecMock.sol#378) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 405,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function updateAppInstance(bytes32 _exec_id) external returns (bool success) {\n",
          "message": "Parameter '_exec_id' of RegistryExecMock.updateAppInstance (RegistryExecMock.sol#405) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 459,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function updateAppExec(bytes32 _exec_id, address _new_exec_addr) external returns (bool success) {\n",
          "message": "Parameter '_exec_id' of RegistryExecMock.updateAppExec (RegistryExecMock.sol#459) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 459,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function updateAppExec(bytes32 _exec_id, address _new_exec_addr) external returns (bool success) {\n",
          "message": "Parameter '_new_exec_addr' of RegistryExecMock.updateAppExec (RegistryExecMock.sol#459) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 253,
          "vulnerability_to_line": null,
          "vulnerability_code": "  mapping (bytes32 => Registry) public registry_instance_info;\n",
          "message": "Variable 'RegistryExecMock.registry_instance_info' (RegistryExecMock.sol#253) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 255,
          "vulnerability_to_line": null,
          "vulnerability_code": "  mapping (address => Registry[]) public deployed_registry_instances;\n",
          "message": "Variable 'RegistryExecMock.deployed_registry_instances' (RegistryExecMock.sol#255) is not in mixedCase\n"
        }
      ]
    },
    "smartcheck": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
          "vulnerability_from_line": 101,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function getAction(uint _ptr) internal pure returns (bytes4 action) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
          "vulnerability_from_line": 304,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function getSelector(bytes memory _calldata) internal pure returns (bytes4 selector) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_LOCKED_MONEY",
          "vulnerability_from_line": 26,
          "vulnerability_to_line": null,
          "vulnerability_code": "contract ScriptExecMock {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.23;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 101,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function getAction(uint _ptr) internal pure returns (bytes4 action) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 132,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function checkReturn() internal pure returns (bool success) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 304,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function getSelector(bytes memory _calldata) internal pure returns (bytes4 selector) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 66,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function () public payable { }\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 102,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 113,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 134,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 305,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly {\n",
          "message": null
        }
      ]
    },
    "oyente": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "Integer Overflow",
          "vulnerability_from_line": 340,
          "vulnerability_to_line": null,
          "vulnerability_code": "    registry_instance_info[exec_id] = reg;\n",
          "message": null
        }
      ]
    },
    "mythril": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "Integer Arithmetic Bugs (SWC 101)",
          "vulnerability_from_line": 272,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function exec(bytes32 _exec_id, bytes _calldata) external payable returns (bool success) {\n",
          "message": "The arithmetic operator can overflow.\nIt is possible to cause an integer overflow or underflow in the arithmetic operation. \nClassification: SWC-101"
        },
        {
          "name": "Integer Arithmetic Bugs (SWC 101)",
          "vulnerability_from_line": 274,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bytes4 sel = getSelector(_calldata);\n",
          "message": "The arithmetic operator can overflow.\nIt is possible to cause an integer overflow or underflow in the arithmetic operation. \nClassification: SWC-101"
        },
        {
          "name": "Integer Arithmetic Bugs (SWC 101)",
          "vulnerability_from_line": 284,
          "vulnerability_to_line": null,
          "vulnerability_code": "    if (address(app_storage).call.value(msg.value)(abi.encodeWithSelector(\n",
          "message": "The arithmetic operator can overflow.\nIt is possible to cause an integer overflow or underflow in the arithmetic operation. \nClassification: SWC-101"
        },
        {
          "name": "Multiple Calls in a Single Transaction (SWC 113)",
          "vulnerability_from_line": 290,
          "vulnerability_to_line": null,
          "vulnerability_code": "      address(msg.sender).transfer(address(this).balance);\n",
          "message": "Multiple calls are executed in the same transaction.\nThis call is executed following another call within the same transaction. It is possible that the call never gets executed if a prior call fails permanently. This might be caused intentionally by a malicious callee. If possible, refactor the code such that each transaction only executes one external call or make sure that all callees can be trusted (i.e. they\u2019re part of your own codebase).\nClassification: SWC-113"
        },
        {
          "name": "Exception State (SWC 110)",
          "vulnerability_from_line": 255,
          "vulnerability_to_line": null,
          "vulnerability_code": "  mapping (address => Registry[]) public deployed_registry_instances;\n",
          "message": "An assertion violation was triggered.\nIt is possible to trigger an assertion violation. Note that Solidity assert() statements should only be used to check invariants. Review the transaction trace generated for this issue and either make sure your program logic is correct, or use require() instead of assert() if your goal is to constrain user inputs or enforce preconditions. Remember to validate inputs from both callers (for instance, via passed arguments) and callees (for instance, via return values).\nClassification: SWC-110"
        },
        {
          "name": "Exception State (SWC 110)",
          "vulnerability_from_line": 50,
          "vulnerability_to_line": null,
          "vulnerability_code": "  mapping (address => Instance[]) public deployed_instances;\n",
          "message": "An assertion violation was triggered.\nIt is possible to trigger an assertion violation. Note that Solidity assert() statements should only be used to check invariants. Review the transaction trace generated for this issue and either make sure your program logic is correct, or use require() instead of assert() if your goal is to constrain user inputs or enforce preconditions. Remember to validate inputs from both callers (for instance, via passed arguments) and callees (for instance, via return values).\nClassification: SWC-110"
        },
        {
          "name": "Exception State (SWC 110)",
          "vulnerability_from_line": 52,
          "vulnerability_to_line": null,
          "vulnerability_code": "  mapping (bytes32 => bytes32[]) public app_instances;\n",
          "message": "An assertion violation was triggered.\nIt is possible to trigger an assertion violation. Note that Solidity assert() statements should only be used to check invariants. Review the transaction trace generated for this issue and either make sure your program logic is correct, or use require() instead of assert() if your goal is to constrain user inputs or enforce preconditions. Remember to validate inputs from both callers (for instance, via passed arguments) and callees (for instance, via return values).\nClassification: SWC-110"
        }
      ]
    },
    "osiris": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "Overflow bugs",
          "vulnerability_from_line": 1,
          "vulnerability_to_line": null,
          "vulnerability_code": "// File: ../sc_datasets/DAppSCAN/PepperSec-POA-Network-Wizard/core-dev/test/registry/RegistryExecMock.sol\n",
          "message": null
        },
        {
          "name": "Overflow bugs",
          "vulnerability_from_line": 160,
          "vulnerability_to_line": null,
          "vulnerability_code": "    (exec_id, version) = StorageInterface(app_storage).createInstance(\n",
          "message": null
        },
        {
          "name": "Overflow bugs",
          "vulnerability_from_line": 202,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function getInstances(bytes32 _app_name) public view returns (bytes32[] memory) {\n",
          "message": null
        },
        {
          "name": "Overflow bugs",
          "vulnerability_from_line": 203,
          "vulnerability_to_line": null,
          "vulnerability_code": "    return app_instances[_app_name];\n",
          "message": null
        },
        {
          "name": "Reentrancy bug",
          "vulnerability_from_line": 284,
          "vulnerability_to_line": null,
          "vulnerability_code": "    if (address(app_storage).call.value(msg.value)(abi.encodeWithSelector(\n",
          "message": null
        },
        {
          "name": "Truncation bugs",
          "vulnerability_from_line": 284,
          "vulnerability_to_line": null,
          "vulnerability_code": "    if (address(app_storage).call.value(msg.value)(abi.encodeWithSelector(\n",
          "message": null
        },
        {
          "name": "Underflow bugs",
          "vulnerability_from_line": 1,
          "vulnerability_to_line": null,
          "vulnerability_code": "// File: ../sc_datasets/DAppSCAN/PepperSec-POA-Network-Wizard/core-dev/test/registry/RegistryExecMock.sol\n",
          "message": null
        },
        {
          "name": "Underflow bugs",
          "vulnerability_from_line": 160,
          "vulnerability_to_line": null,
          "vulnerability_code": "    (exec_id, version) = StorageInterface(app_storage).createInstance(\n",
          "message": null
        }
      ]
    }
  }
}