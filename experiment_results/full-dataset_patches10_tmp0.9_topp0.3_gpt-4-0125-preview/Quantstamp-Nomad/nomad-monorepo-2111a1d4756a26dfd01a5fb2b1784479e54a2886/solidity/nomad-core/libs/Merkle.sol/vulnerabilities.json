{
  "smartbugs_completed": true,
  "analyzer_results": {
    "semgrep": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 36,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 i = 0; i < TREE_DEPTH; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 62,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 i = 0; i < TREE_DEPTH; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 134,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 i = 0; i < TREE_DEPTH; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 32,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_tree.count < MAX_LEAVES, \"merkle tree full\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 36,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 i = 0; i < TREE_DEPTH; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 62,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 i = 0; i < TREE_DEPTH; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 134,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 i = 0; i < TREE_DEPTH; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        }
      ]
    },
    "slither": {
      "successfull_analysis": true,
      "errors": [
        "EXIT_CODE_9"
      ],
      "vulnerability_findings": [
        {
          "name": "solc-version",
          "vulnerability_from_line": 4,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity >=0.6.11;\n",
          "message": "Detected issues with version pragma in Merkle.sol:\n\t- pragma solidity>=0.6.11 (Merkle.sol#4): it allows old versions\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 31,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function insert(Tree storage _tree, bytes32 _node) internal {\n",
          "message": "Parameter '_tree' of MerkleLib.insert (Merkle.sol#31) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 31,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function insert(Tree storage _tree, bytes32 _node) internal {\n",
          "message": "Parameter '_node' of MerkleLib.insert (Merkle.sol#31) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 55,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function rootWithCtx(Tree storage _tree, bytes32[TREE_DEPTH] memory _zeroes)\n",
          "message": "Parameter '_tree' of MerkleLib.rootWithCtx (Merkle.sol#55) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 55,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function rootWithCtx(Tree storage _tree, bytes32[TREE_DEPTH] memory _zeroes)\n",
          "message": "Parameter '_zeroes' of MerkleLib.rootWithCtx (Merkle.sol#55) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 74,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function root(Tree storage _tree) internal view returns (bytes32) {\n",
          "message": "Parameter '_tree' of MerkleLib.root (Merkle.sol#74) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 128,
          "vulnerability_to_line": null,
          "vulnerability_code": "        bytes32 _item,\n",
          "message": "Parameter '_item' of MerkleLib.branchRoot (Merkle.sol#128) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 129,
          "vulnerability_to_line": null,
          "vulnerability_code": "        bytes32[TREE_DEPTH] memory _branch,\n",
          "message": "Parameter '_branch' of MerkleLib.branchRoot (Merkle.sol#129) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 130,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint256 _index\n",
          "message": "Parameter '_index' of MerkleLib.branchRoot (Merkle.sol#130) is not in mixedCase\n"
        }
      ]
    },
    "smartcheck": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 63,
          "vulnerability_to_line": null,
          "vulnerability_code": "            uint256 _ithBit = (_index >> i) & 0x01;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 135,
          "vulnerability_to_line": null,
          "vulnerability_code": "            uint256 _ithBit = (_index >> i) & 0x01;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 4,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity >=0.6.11;\n",
          "message": null
        }
      ]
    },
    "oyente": {
      "successfull_analysis": false,
      "errors": [
        "exception (IndexError: pop from empty list)"
      ],
      "vulnerability_findings": []
    },
    "mythril": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "Exception State (SWC 110)",
          "vulnerability_from_line": null,
          "vulnerability_to_line": null,
          "vulnerability_code": null,
          "message": "An assertion violation was triggered.\nIt is possible to trigger an assertion violation. Note that Solidity assert() statements should only be used to check invariants. Review the transaction trace generated for this issue and either make sure your program logic is correct, or use require() instead of assert() if your goal is to constrain user inputs or enforce preconditions. Remember to validate inputs from both callers (for instance, via passed arguments) and callees (for instance, via return values). This issue is reported for internal compiler generated code.\nClassification: SWC-110"
        }
      ]
    },
    "osiris": {
      "successfull_analysis": false,
      "errors": [
        "Solidity compilation failed"
      ],
      "vulnerability_findings": []
    }
  }
}