{
  "smartbugs_completed": true,
  "analyzer_results": {
    "semgrep": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "use-ownable2step",
          "vulnerability_from_line": 615,
          "vulnerability_to_line": null,
          "vulnerability_code": "contract Pausable is Ownable {\n",
          "message": "By demanding that the receiver of the owner permissions actively accept via a contract call of its own,  `Ownable2Step` and `Ownable2StepUpgradeable` prevent the contract ownership from accidentally being transferred  to an address that cannot handle it."
        },
        {
          "name": "use-ownable2step",
          "vulnerability_from_line": 681,
          "vulnerability_to_line": null,
          "vulnerability_code": "contract TheAbyssDAICO is Ownable, SafeMath, Pausable, ISimpleCrowdsale {\n",
          "message": "By demanding that the receiver of the owner permissions actively accept via a contract call of its own,  `Ownable2Step` and `Ownable2StepUpgradeable` prevent the contract ownership from accidentally being transferred  to an address that cannot handle it."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 126,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(uint256 i = 0; i < owners.length; i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 131,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(uint256 j = 0; j < _owners.length; j++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 547,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(uint256 i = 0; i < walletTokens[msg.sender].length; i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "init-variables-with-default-value",
          "vulnerability_from_line": 260,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bool public allowTransfers = false;\n",
          "message": "Uninitialized variables are assigned with the types default value. Explicitly initializing a variable with its default value costs unnecessary gas."
        },
        {
          "name": "init-variables-with-default-value",
          "vulnerability_from_line": 261,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bool public issuanceFinished = false;\n",
          "message": "Uninitialized variables are assigned with the types default value. Explicitly initializing a variable with its default value costs unnecessary gas."
        },
        {
          "name": "init-variables-with-default-value",
          "vulnerability_from_line": 619,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bool public paused = false;\n",
          "message": "Uninitialized variables are assigned with the types default value. Explicitly initializing a variable with its default value costs unnecessary gas."
        },
        {
          "name": "init-variables-with-default-value",
          "vulnerability_from_line": 713,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint256 public tokenPriceNum = 0;\n",
          "message": "Uninitialized variables are assigned with the types default value. Explicitly initializing a variable with its default value costs unnecessary gas."
        },
        {
          "name": "init-variables-with-default-value",
          "vulnerability_from_line": 714,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint256 public tokenPriceDenom = 0;\n",
          "message": "Uninitialized variables are assigned with the types default value. Explicitly initializing a variable with its default value costs unnecessary gas."
        },
        {
          "name": "init-variables-with-default-value",
          "vulnerability_from_line": 734,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint256 public totalEtherContributed = 0;\n",
          "message": "Uninitialized variables are assigned with the types default value. Explicitly initializing a variable with its default value costs unnecessary gas."
        },
        {
          "name": "init-variables-with-default-value",
          "vulnerability_from_line": 735,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint256 public rawTokenSupply = 0;\n",
          "message": "Uninitialized variables are assigned with the types default value. Explicitly initializing a variable with its default value costs unnecessary gas."
        },
        {
          "name": "init-variables-with-default-value",
          "vulnerability_from_line": 742,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint256 public totalBNBContributed = 0;\n",
          "message": "Uninitialized variables are assigned with the types default value. Explicitly initializing a variable with its default value costs unnecessary gas."
        },
        {
          "name": "init-variables-with-default-value",
          "vulnerability_from_line": 744,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint256 public hardCap = 0; // World hard cap will be set right before Token Sale\n",
          "message": "Uninitialized variables are assigned with the types default value. Explicitly initializing a variable with its default value costs unnecessary gas."
        },
        {
          "name": "init-variables-with-default-value",
          "vulnerability_from_line": 745,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint256 public softCap = 0; // World soft cap will be set right before Token Sale\n",
          "message": "Uninitialized variables are assigned with the types default value. Explicitly initializing a variable with its default value costs unnecessary gas."
        },
        {
          "name": "init-variables-with-default-value",
          "vulnerability_from_line": 747,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bool public bnbRefundEnabled = false;\n",
          "message": "Uninitialized variables are assigned with the types default value. Explicitly initializing a variable with its default value costs unnecessary gas."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 126,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(uint256 i = 0; i < owners.length; i++) {\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 127,
          "vulnerability_to_line": null,
          "vulnerability_code": "            ownerByAddress[owners[i]] = false;\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 127,
          "vulnerability_to_line": null,
          "vulnerability_code": "            ownerByAddress[owners[i]] = false;\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 132,
          "vulnerability_to_line": null,
          "vulnerability_code": "            ownerByAddress[_owners[j]] = true;\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 547,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(uint256 i = 0; i < walletTokens[msg.sender].length; i++) {\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 548,
          "vulnerability_to_line": null,
          "vulnerability_code": "            if(!walletTokens[msg.sender][i].released && now >= walletTokens[msg.sender][i].lockEndTime) {\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 548,
          "vulnerability_to_line": null,
          "vulnerability_code": "            if(!walletTokens[msg.sender][i].released && now >= walletTokens[msg.sender][i].lockEndTime) {\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 549,
          "vulnerability_to_line": null,
          "vulnerability_code": "                walletTokens[msg.sender][i].released = true;\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 550,
          "vulnerability_to_line": null,
          "vulnerability_code": "                token.transfer(msg.sender, walletTokens[msg.sender][i].amount);\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 550,
          "vulnerability_to_line": null,
          "vulnerability_code": "                token.transfer(msg.sender, walletTokens[msg.sender][i].amount);\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 551,
          "vulnerability_to_line": null,
          "vulnerability_code": "                TokensUnlocked(msg.sender, walletTokens[msg.sender][i].amount);\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 126,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(uint256 i = 0; i < owners.length; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 131,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(uint256 j = 0; j < _owners.length; j++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 547,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(uint256 i = 0; i < walletTokens[msg.sender].length; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 206,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value);\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 438,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(now >= limitEndDate || !isLimitEnabled || (!limitedWallets[_from] && !limitedWallets[_to]));\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 769,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(now >= SALE_START_TIME && now <= SALE_END_TIME);\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 856,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(tokenPriceNum == 0 && tokenPriceDenom == 0);\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 857,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_tokenPriceNum > 0 && _tokenPriceDenom > 0);\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 315,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if(hasListener() && success) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 316,
          "vulnerability_to_line": null,
          "vulnerability_code": "            eventListener.onTokenTransfer(msg.sender, _to, _value);\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 317,
          "vulnerability_to_line": null,
          "vulnerability_code": "        }\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 323,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if(hasListener() && success) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 324,
          "vulnerability_to_line": null,
          "vulnerability_code": "            eventListener.onTokenTransfer(_from, _to, _value);\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 325,
          "vulnerability_to_line": null,
          "vulnerability_code": "        }\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 548,
          "vulnerability_to_line": null,
          "vulnerability_code": "            if(!walletTokens[msg.sender][i].released && now >= walletTokens[msg.sender][i].lockEndTime) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 549,
          "vulnerability_to_line": null,
          "vulnerability_code": "                walletTokens[msg.sender][i].released = true;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 550,
          "vulnerability_to_line": null,
          "vulnerability_code": "                token.transfer(msg.sender, walletTokens[msg.sender][i].amount);\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 551,
          "vulnerability_to_line": null,
          "vulnerability_code": "                TokensUnlocked(msg.sender, walletTokens[msg.sender][i].amount);\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 552,
          "vulnerability_to_line": null,
          "vulnerability_code": "            }\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 818,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if(whiteList[msg.sender] && msg.value >= ETHER_MIN_CONTRIB) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 819,
          "vulnerability_to_line": null,
          "vulnerability_code": "            if(now <= MAX_CONTRIB_CHECK_END_TIME && currentUserContribution > ETHER_MAX_CONTRIB ) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 820,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    return false;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 821,
          "vulnerability_to_line": null,
          "vulnerability_code": "            }\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 822,
          "vulnerability_to_line": null,
          "vulnerability_code": "            return true;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 823,
          "vulnerability_to_line": null,
          "vulnerability_code": "\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 824,
          "vulnerability_to_line": null,
          "vulnerability_code": "        }\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 819,
          "vulnerability_to_line": null,
          "vulnerability_code": "            if(now <= MAX_CONTRIB_CHECK_END_TIME && currentUserContribution > ETHER_MAX_CONTRIB ) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 820,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    return false;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 821,
          "vulnerability_to_line": null,
          "vulnerability_code": "            }\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 825,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if(privilegedList[msg.sender] && msg.value >= ETHER_MIN_CONTRIB_PRIVATE) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 826,
          "vulnerability_to_line": null,
          "vulnerability_code": "            if(now <= MAX_CONTRIB_CHECK_END_TIME && currentUserContribution > ETHER_MAX_CONTRIB_PRIVATE ) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 827,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    return false;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 828,
          "vulnerability_to_line": null,
          "vulnerability_code": "            }\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 829,
          "vulnerability_to_line": null,
          "vulnerability_code": "            return true;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 830,
          "vulnerability_to_line": null,
          "vulnerability_code": "        }\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 826,
          "vulnerability_to_line": null,
          "vulnerability_code": "            if(now <= MAX_CONTRIB_CHECK_END_TIME && currentUserContribution > ETHER_MAX_CONTRIB_PRIVATE ) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 827,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    return false;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 828,
          "vulnerability_to_line": null,
          "vulnerability_code": "            }\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 832,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if(token.limitedWallets(msg.sender) && msg.value >= ETHER_MIN_CONTRIB_USA) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 833,
          "vulnerability_to_line": null,
          "vulnerability_code": "            if(now <= MAX_CONTRIB_CHECK_END_TIME && currentUserContribution > ETHER_MAX_CONTRIB_USA) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 834,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    return false;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 835,
          "vulnerability_to_line": null,
          "vulnerability_code": "            }\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 836,
          "vulnerability_to_line": null,
          "vulnerability_code": "            return true;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 837,
          "vulnerability_to_line": null,
          "vulnerability_code": "        }\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 833,
          "vulnerability_to_line": null,
          "vulnerability_code": "            if(now <= MAX_CONTRIB_CHECK_END_TIME && currentUserContribution > ETHER_MAX_CONTRIB_USA) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 834,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    return false;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 835,
          "vulnerability_to_line": null,
          "vulnerability_code": "            }\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 894,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if(!whiteList[msg.sender] && !privilegedList[msg.sender]) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 895,
          "vulnerability_to_line": null,
          "vulnerability_code": "            return false;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 896,
          "vulnerability_to_line": null,
          "vulnerability_code": "        }\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 1104,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if(\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 1105,
          "vulnerability_to_line": null,
          "vulnerability_code": "            (totalEtherContributed >= safeSub(hardCap, ETHER_MIN_CONTRIB_USA) && totalBNBContributed >= safeSub(BNB_HARD_CAP, BNB_MIN_CONTRIB)) ||\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 1106,
          "vulnerability_to_line": null,
          "vulnerability_code": "            (now >= SALE_END_TIME && totalEtherContributed >= softCap)\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 1107,
          "vulnerability_to_line": null,
          "vulnerability_code": "        ) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 1108,
          "vulnerability_to_line": null,
          "vulnerability_code": "            fund.onCrowdsaleEnd();\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 1109,
          "vulnerability_to_line": null,
          "vulnerability_code": "            reservationFund.onCrowdsaleEnd();\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 1110,
          "vulnerability_to_line": null,
          "vulnerability_code": "            // BNB transfer\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 1111,
          "vulnerability_to_line": null,
          "vulnerability_code": "            bnbToken.transfer(bnbTokenWallet, bnbToken.balanceOf(address(this)));\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 1112,
          "vulnerability_to_line": null,
          "vulnerability_code": "\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 1113,
          "vulnerability_to_line": null,
          "vulnerability_code": "            // Referral\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 126,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(uint256 i = 0; i < owners.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 131,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(uint256 j = 0; j < _owners.length; j++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 547,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(uint256 i = 0; i < walletTokens[msg.sender].length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        }
      ]
    },
    "slither": {
      "successfull_analysis": true,
      "errors": [
        "EXIT_CODE_115"
      ],
      "vulnerability_findings": [
        {
          "name": "unused-return",
          "vulnerability_from_line": 544,
          "vulnerability_to_line": 554,
          "vulnerability_code": "    function releaseTokens() public {\n\n        require(walletTokens[msg.sender].length > 0);\n\n\n\n        for(uint256 i = 0; i < walletTokens[msg.sender].length; i++) {\n\n            if(!walletTokens[msg.sender][i].released && now >= walletTokens[msg.sender][i].lockEndTime) {\n\n                walletTokens[msg.sender][i].released = true;\n\n                token.transfer(msg.sender, walletTokens[msg.sender][i].amount);\n\n                TokensUnlocked(msg.sender, walletTokens[msg.sender][i].amount);\n\n            }\n\n        }\n",
          "message": "LockedTokens.releaseTokens (Crowdsale.sol#544-554) does not use the value returned by external calls:\n\t-token.transfer(msg.sender,walletTokens[msg.sender][i].amount) (Crowdsale.sol#550)\n"
        },
        {
          "name": "unused-return",
          "vulnerability_from_line": 1019,
          "vulnerability_to_line": 1047,
          "vulnerability_code": "    function processBNBContribution() public whenNotPaused checkTime checkBNBContribution {\n\n        bool additionalBonusApplied = false;\n\n        uint256 bonusNum = 0;\n\n        uint256 bonusDenom = 100;\n\n        (bonusNum, bonusDenom) = getBonus();\n\n        uint256 amountBNB = bnbToken.allowance(msg.sender, address(this));\n\n        bnbToken.transferFrom(msg.sender, address(this), amountBNB);\n\n        bnbContributions[msg.sender] = safeAdd(bnbContributions[msg.sender], amountBNB);\n\n\n\n        uint256 tokenBonusAmount = 0;\n\n        uint256 tokenAmount = safeDiv(safeMul(amountBNB, BNB_TOKEN_PRICE_NUM), BNB_TOKEN_PRICE_DENOM);\n\n        rawTokenSupply = safeAdd(rawTokenSupply, tokenAmount);\n\n        if(bonusNum > 0) {\n\n            tokenBonusAmount = safeDiv(safeMul(tokenAmount, bonusNum), bonusDenom);\n\n        }\n\n\n\n        if(additionalBonusOwnerState[msg.sender] ==  AdditionalBonusState.Active) {\n\n            additionalBonusOwnerState[msg.sender] = AdditionalBonusState.Applied;\n\n            uint256 additionalBonus = safeDiv(safeMul(tokenAmount, ADDITIONAL_BONUS_NUM), ADDITIONAL_BONUS_DENOM);\n\n            tokenBonusAmount = safeAdd(tokenBonusAmount, additionalBonus);\n\n            additionalBonusApplied = true;\n\n        }\n\n\n\n        uint256 tokenTotalAmount = safeAdd(tokenAmount, tokenBonusAmount);\n\n        token.issue(msg.sender, tokenTotalAmount);\n\n        totalBNBContributed = safeAdd(totalBNBContributed, amountBNB);\n\n\n\n        LogBNBContribution(msg.sender, amountBNB, tokenAmount, tokenBonusAmount, additionalBonusApplied, now);\n",
          "message": "TheAbyssDAICO.processBNBContribution (Crowdsale.sol#1019-1047) does not use the value returned by external calls:\n\t-bnbToken.transferFrom(msg.sender,address(this),amountBNB) (Crowdsale.sol#1025)\n"
        },
        {
          "name": "unused-return",
          "vulnerability_from_line": 1103,
          "vulnerability_to_line": 1150,
          "vulnerability_code": "    function finalizeCrowdsale() public onlyOwner {\n\n        if(\n\n            (totalEtherContributed >= safeSub(hardCap, ETHER_MIN_CONTRIB_USA) && totalBNBContributed >= safeSub(BNB_HARD_CAP, BNB_MIN_CONTRIB)) ||\n\n            (now >= SALE_END_TIME && totalEtherContributed >= softCap)\n\n        ) {\n\n            fund.onCrowdsaleEnd();\n\n            reservationFund.onCrowdsaleEnd();\n\n            // BNB transfer\n\n            bnbToken.transfer(bnbTokenWallet, bnbToken.balanceOf(address(this)));\n\n\n\n            // Referral\n\n            uint256 referralTokenAmount = safeDiv(rawTokenSupply, 10);\n\n            token.issue(referralTokenWallet, referralTokenAmount);\n\n\n\n            // Foundation\n\n            uint256 foundationTokenAmount = safeDiv(token.totalSupply(), 2); // 20%\n\n            lockedTokens.addTokens(foundationTokenWallet, foundationTokenAmount, now + 365 days);\n\n\n\n            uint256 suppliedTokenAmount = token.totalSupply();\n\n\n\n            // Reserve\n\n            uint256 reservedTokenAmount = safeDiv(safeMul(suppliedTokenAmount, 3), 10); // 18%\n\n            token.issue(address(lockedTokens), reservedTokenAmount);\n\n            lockedTokens.addTokens(reserveTokenWallet, reservedTokenAmount, now + 183 days);\n\n\n\n            // Advisors\n\n            uint256 advisorsTokenAmount = safeDiv(suppliedTokenAmount, 10); // 6%\n\n            token.issue(advisorsTokenWallet, advisorsTokenAmount);\n\n\n\n            // Company\n\n            uint256 companyTokenAmount = safeDiv(suppliedTokenAmount, 4); // 15%\n\n            token.issue(address(lockedTokens), companyTokenAmount);\n\n            lockedTokens.addTokens(companyTokenWallet, companyTokenAmount, now + 730 days);\n\n\n\n            // Bounty\n\n            uint256 bountyTokenAmount = safeDiv(suppliedTokenAmount, 60); // 1%\n\n            token.issue(bountyTokenWallet, bountyTokenAmount);\n\n\n\n            token.setAllowTransfers(true);\n\n\n\n        } else if(now >= SALE_END_TIME) {\n\n            // Enable fund`s crowdsale refund if soft cap is not reached\n\n            fund.enableCrowdsaleRefund();\n\n            reservationFund.onCrowdsaleEnd();\n\n            bnbRefundEnabled = true;\n\n        }\n\n        token.finishIssuance();\n",
          "message": "TheAbyssDAICO.finalizeCrowdsale (Crowdsale.sol#1103-1150) does not use the value returned by external calls:\n\t-bnbToken.transfer(bnbTokenWallet,bnbToken.balanceOf(address(this))) (Crowdsale.sol#1111)\n\t-token.finishIssuance() (Crowdsale.sol#1149)\n"
        },
        {
          "name": "unused-return",
          "vulnerability_from_line": 1155,
          "vulnerability_to_line": 1162,
          "vulnerability_code": "    function refundBNBContributor() public {\n\n        require(bnbRefundEnabled);\n\n        require(bnbContributions[msg.sender] > 0);\n\n        uint256 amount = bnbContributions[msg.sender];\n\n        bnbContributions[msg.sender] = 0;\n\n        bnbToken.transfer(msg.sender, amount);\n\n        token.destroy(msg.sender, token.balanceOf(msg.sender));\n",
          "message": "TheAbyssDAICO.refundBNBContributor (Crowdsale.sol#1155-1162) does not use the value returned by external calls:\n\t-bnbToken.transfer(msg.sender,amount) (Crowdsale.sol#1160)\n"
        },
        {
          "name": "calls-loop",
          "vulnerability_from_line": 550,
          "vulnerability_to_line": null,
          "vulnerability_code": "                token.transfer(msg.sender, walletTokens[msg.sender][i].amount);\n",
          "message": "LockedTokens.releaseTokens has external calls inside a loop:\n\t- token.transfer(msg.sender,walletTokens[msg.sender][i].amount) (Crowdsale.sol#550)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 927,
          "vulnerability_to_line": 949,
          "vulnerability_code": "    function addToLists(\n\n        address _wallet,\n\n        bool isInWhiteList,\n\n        bool isInPrivilegedList,\n\n        bool isInLimitedList,\n\n        bool hasAdditionalBonus\n\n    ) public onlyOwner {\n\n        if(isInWhiteList) {\n\n            whiteList[_wallet] = true;\n\n        }\n\n        if(isInPrivilegedList) {\n\n            privilegedList[_wallet] = true;\n\n        }\n\n        if(isInLimitedList) {\n\n            token.addLimitedWalletAddress(_wallet);\n\n        }\n\n        if(hasAdditionalBonus) {\n\n            additionalBonusOwnerState[_wallet] = AdditionalBonusState.Active;\n\n        }\n\n        if(reservationFund.canCompleteContribution(_wallet)) {\n\n            reservationFund.completeContribution(_wallet);\n\n        }\n",
          "message": "Reentrancy in TheAbyssDAICO.addToLists (Crowdsale.sol#927-949):\n\tExternal calls:\n\t- token.addLimitedWalletAddress(_wallet) (Crowdsale.sol#941)\n\tState variables written after the call(s):\n\t- additionalBonusOwnerState (Crowdsale.sol#944)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 1103,
          "vulnerability_to_line": 1150,
          "vulnerability_code": "    function finalizeCrowdsale() public onlyOwner {\n\n        if(\n\n            (totalEtherContributed >= safeSub(hardCap, ETHER_MIN_CONTRIB_USA) && totalBNBContributed >= safeSub(BNB_HARD_CAP, BNB_MIN_CONTRIB)) ||\n\n            (now >= SALE_END_TIME && totalEtherContributed >= softCap)\n\n        ) {\n\n            fund.onCrowdsaleEnd();\n\n            reservationFund.onCrowdsaleEnd();\n\n            // BNB transfer\n\n            bnbToken.transfer(bnbTokenWallet, bnbToken.balanceOf(address(this)));\n\n\n\n            // Referral\n\n            uint256 referralTokenAmount = safeDiv(rawTokenSupply, 10);\n\n            token.issue(referralTokenWallet, referralTokenAmount);\n\n\n\n            // Foundation\n\n            uint256 foundationTokenAmount = safeDiv(token.totalSupply(), 2); // 20%\n\n            lockedTokens.addTokens(foundationTokenWallet, foundationTokenAmount, now + 365 days);\n\n\n\n            uint256 suppliedTokenAmount = token.totalSupply();\n\n\n\n            // Reserve\n\n            uint256 reservedTokenAmount = safeDiv(safeMul(suppliedTokenAmount, 3), 10); // 18%\n\n            token.issue(address(lockedTokens), reservedTokenAmount);\n\n            lockedTokens.addTokens(reserveTokenWallet, reservedTokenAmount, now + 183 days);\n\n\n\n            // Advisors\n\n            uint256 advisorsTokenAmount = safeDiv(suppliedTokenAmount, 10); // 6%\n\n            token.issue(advisorsTokenWallet, advisorsTokenAmount);\n\n\n\n            // Company\n\n            uint256 companyTokenAmount = safeDiv(suppliedTokenAmount, 4); // 15%\n\n            token.issue(address(lockedTokens), companyTokenAmount);\n\n            lockedTokens.addTokens(companyTokenWallet, companyTokenAmount, now + 730 days);\n\n\n\n            // Bounty\n\n            uint256 bountyTokenAmount = safeDiv(suppliedTokenAmount, 60); // 1%\n\n            token.issue(bountyTokenWallet, bountyTokenAmount);\n\n\n\n            token.setAllowTransfers(true);\n\n\n\n        } else if(now >= SALE_END_TIME) {\n\n            // Enable fund`s crowdsale refund if soft cap is not reached\n\n            fund.enableCrowdsaleRefund();\n\n            reservationFund.onCrowdsaleEnd();\n\n            bnbRefundEnabled = true;\n\n        }\n\n        token.finishIssuance();\n",
          "message": "Reentrancy in TheAbyssDAICO.finalizeCrowdsale (Crowdsale.sol#1103-1150):\n\tExternal calls:\n\t- fund.enableCrowdsaleRefund() (Crowdsale.sol#1145)\n\t- reservationFund.onCrowdsaleEnd() (Crowdsale.sol#1146)\n\tState variables written after the call(s):\n\t- bnbRefundEnabled (Crowdsale.sol#1147)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 1019,
          "vulnerability_to_line": 1047,
          "vulnerability_code": "    function processBNBContribution() public whenNotPaused checkTime checkBNBContribution {\n\n        bool additionalBonusApplied = false;\n\n        uint256 bonusNum = 0;\n\n        uint256 bonusDenom = 100;\n\n        (bonusNum, bonusDenom) = getBonus();\n\n        uint256 amountBNB = bnbToken.allowance(msg.sender, address(this));\n\n        bnbToken.transferFrom(msg.sender, address(this), amountBNB);\n\n        bnbContributions[msg.sender] = safeAdd(bnbContributions[msg.sender], amountBNB);\n\n\n\n        uint256 tokenBonusAmount = 0;\n\n        uint256 tokenAmount = safeDiv(safeMul(amountBNB, BNB_TOKEN_PRICE_NUM), BNB_TOKEN_PRICE_DENOM);\n\n        rawTokenSupply = safeAdd(rawTokenSupply, tokenAmount);\n\n        if(bonusNum > 0) {\n\n            tokenBonusAmount = safeDiv(safeMul(tokenAmount, bonusNum), bonusDenom);\n\n        }\n\n\n\n        if(additionalBonusOwnerState[msg.sender] ==  AdditionalBonusState.Active) {\n\n            additionalBonusOwnerState[msg.sender] = AdditionalBonusState.Applied;\n\n            uint256 additionalBonus = safeDiv(safeMul(tokenAmount, ADDITIONAL_BONUS_NUM), ADDITIONAL_BONUS_DENOM);\n\n            tokenBonusAmount = safeAdd(tokenBonusAmount, additionalBonus);\n\n            additionalBonusApplied = true;\n\n        }\n\n\n\n        uint256 tokenTotalAmount = safeAdd(tokenAmount, tokenBonusAmount);\n\n        token.issue(msg.sender, tokenTotalAmount);\n\n        totalBNBContributed = safeAdd(totalBNBContributed, amountBNB);\n\n\n\n        LogBNBContribution(msg.sender, amountBNB, tokenAmount, tokenBonusAmount, additionalBonusApplied, now);\n",
          "message": "Reentrancy in TheAbyssDAICO.processBNBContribution (Crowdsale.sol#1019-1047):\n\tExternal calls:\n\t- amountBNB = bnbToken.allowance(msg.sender,address(this)) (Crowdsale.sol#1024)\n\t- bnbToken.transferFrom(msg.sender,address(this),amountBNB) (Crowdsale.sol#1025)\n\tState variables written after the call(s):\n\t- additionalBonusOwnerState (Crowdsale.sol#1036)\n\t- bnbContributions (Crowdsale.sol#1026)\n\t- rawTokenSupply (Crowdsale.sol#1030)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 1019,
          "vulnerability_to_line": 1047,
          "vulnerability_code": "    function processBNBContribution() public whenNotPaused checkTime checkBNBContribution {\n\n        bool additionalBonusApplied = false;\n\n        uint256 bonusNum = 0;\n\n        uint256 bonusDenom = 100;\n\n        (bonusNum, bonusDenom) = getBonus();\n\n        uint256 amountBNB = bnbToken.allowance(msg.sender, address(this));\n\n        bnbToken.transferFrom(msg.sender, address(this), amountBNB);\n\n        bnbContributions[msg.sender] = safeAdd(bnbContributions[msg.sender], amountBNB);\n\n\n\n        uint256 tokenBonusAmount = 0;\n\n        uint256 tokenAmount = safeDiv(safeMul(amountBNB, BNB_TOKEN_PRICE_NUM), BNB_TOKEN_PRICE_DENOM);\n\n        rawTokenSupply = safeAdd(rawTokenSupply, tokenAmount);\n\n        if(bonusNum > 0) {\n\n            tokenBonusAmount = safeDiv(safeMul(tokenAmount, bonusNum), bonusDenom);\n\n        }\n\n\n\n        if(additionalBonusOwnerState[msg.sender] ==  AdditionalBonusState.Active) {\n\n            additionalBonusOwnerState[msg.sender] = AdditionalBonusState.Applied;\n\n            uint256 additionalBonus = safeDiv(safeMul(tokenAmount, ADDITIONAL_BONUS_NUM), ADDITIONAL_BONUS_DENOM);\n\n            tokenBonusAmount = safeAdd(tokenBonusAmount, additionalBonus);\n\n            additionalBonusApplied = true;\n\n        }\n\n\n\n        uint256 tokenTotalAmount = safeAdd(tokenAmount, tokenBonusAmount);\n\n        token.issue(msg.sender, tokenTotalAmount);\n\n        totalBNBContributed = safeAdd(totalBNBContributed, amountBNB);\n\n\n\n        LogBNBContribution(msg.sender, amountBNB, tokenAmount, tokenBonusAmount, additionalBonusApplied, now);\n",
          "message": "Reentrancy in TheAbyssDAICO.processBNBContribution (Crowdsale.sol#1019-1047):\n\tExternal calls:\n\t- amountBNB = bnbToken.allowance(msg.sender,address(this)) (Crowdsale.sol#1024)\n\t- bnbToken.transferFrom(msg.sender,address(this),amountBNB) (Crowdsale.sol#1025)\n\t- token.issue(msg.sender,tokenTotalAmount) (Crowdsale.sol#1043)\n\tState variables written after the call(s):\n\t- totalBNBContributed (Crowdsale.sol#1044)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 1090,
          "vulnerability_to_line": 1098,
          "vulnerability_code": "    function processPayment(address contributor, uint256 etherAmount, uint256 tokenAmount, uint256 tokenBonusAmount, bool additionalBonusApplied) internal {\n\n        uint256 tokenTotalAmount = safeAdd(tokenAmount, tokenBonusAmount);\n\n\n\n        token.issue(contributor, tokenTotalAmount);\n\n        fund.processContribution.value(etherAmount)(contributor);\n\n        totalEtherContributed = safeAdd(totalEtherContributed, etherAmount);\n\n        userTotalContributed[contributor] = safeAdd(userTotalContributed[contributor], etherAmount);\n\n        LogContribution(contributor, etherAmount, tokenAmount, tokenBonusAmount, additionalBonusApplied, now);\n",
          "message": "Reentrancy in TheAbyssDAICO.processPayment (Crowdsale.sol#1090-1098):\n\tExternal calls:\n\t- token.issue(contributor,tokenTotalAmount) (Crowdsale.sol#1093)\n\t- fund.processContribution.value(etherAmount)(contributor) (Crowdsale.sol#1094)\n\tExternal calls sending eth:\n\t- fund.processContribution.value(etherAmount)(contributor) (Crowdsale.sol#1094)\n\tState variables written after the call(s):\n\t- totalEtherContributed (Crowdsale.sol#1095)\n\t- userTotalContributed (Crowdsale.sol#1096)\n"
        },
        {
          "name": "constable-states",
          "vulnerability_from_line": 74,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint8 public decimals;\n",
          "message": "IERC20Token.decimals should be constant (Crowdsale.sol#74)\nIERC20Token.name should be constant (Crowdsale.sol#72)\nIERC20Token.symbol should be constant (Crowdsale.sol#73)\nTheAbyssDAICO.BNB_HARD_CAP should be constant (Crowdsale.sol#739)\nTheAbyssDAICO.BNB_MIN_CONTRIB should be constant (Crowdsale.sol#740)\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 215,
          "vulnerability_to_line": 217,
          "vulnerability_code": "    function balanceOf(address _owner) public constant returns (uint256) {\n\n        return balances[_owner];\n",
          "message": "ERC20Token.balanceOf (Crowdsale.sol#215-217) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 77,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function balanceOf(address _owner) public constant returns (uint256 balance);\n",
          "message": "IERC20Token.balanceOf (Crowdsale.sol#77) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 225,
          "vulnerability_to_line": 227,
          "vulnerability_code": "    function allowance(address _owner, address _spender) public constant returns (uint256) {\n\n      return allowed[_owner][_spender];\n",
          "message": "ERC20Token.allowance (Crowdsale.sol#225-227) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 81,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function allowance(address _owner, address _spender)  public constant returns (uint256 remaining);\n",
          "message": "IERC20Token.allowance (Crowdsale.sol#81) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 119,
          "vulnerability_to_line": 123,
          "vulnerability_code": "    function setOwners(address[] _owners) public {\n\n        require(msg.sender == manager);\n\n        _setOwners(_owners);\n\n\n",
          "message": "MultiOwnable.setOwners (Crowdsale.sol#119-123) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 138,
          "vulnerability_to_line": 140,
          "vulnerability_code": "    function getOwners() public constant returns (address[]) {\n\n        return owners;\n",
          "message": "MultiOwnable.getOwners (Crowdsale.sol#138-140) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 245,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function onTokenTransfer(address _from, address _to, uint256 _value) public;\n",
          "message": "ITokenEventListener.onTokenTransfer (Crowdsale.sol#245) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 305,
          "vulnerability_to_line": 311,
          "vulnerability_code": "    function setListener(address _listener) public onlyOwner {\n\n        if(_listener != address(0)) {\n\n            eventListener = ITokenEventListener(_listener);\n\n        } else {\n\n            delete eventListener;\n\n        }\n",
          "message": "ManagedToken.setListener (Crowdsale.sol#305-311) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 373,
          "vulnerability_to_line": 377,
          "vulnerability_code": "    function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n\n        allowed[msg.sender][_spender] = safeAdd(allowed[msg.sender][_spender], _addedValue);\n\n        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n\n        return true;\n",
          "message": "ManagedToken.increaseApproval (Crowdsale.sol#373-377) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 389,
          "vulnerability_to_line": 398,
          "vulnerability_code": "    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n\n        uint oldValue = allowed[msg.sender][_spender];\n\n        if (_subtractedValue > oldValue) {\n\n            allowed[msg.sender][_spender] = 0;\n\n        } else {\n\n            allowed[msg.sender][_spender] = safeSub(oldValue, _subtractedValue);\n\n        }\n\n        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n\n        return true;\n",
          "message": "ManagedToken.decreaseApproval (Crowdsale.sol#389-398) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 404,
          "vulnerability_to_line": 408,
          "vulnerability_code": "    function finishIssuance() public onlyOwner returns (bool) {\n\n        issuanceFinished = true;\n\n        IssuanceFinished();\n\n        return true;\n",
          "message": "ManagedToken.finishIssuance (Crowdsale.sol#404-408) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 465,
          "vulnerability_to_line": 468,
          "vulnerability_code": "    function addLimitedWalletAddress(address _wallet) public {\n\n        require(msg.sender == limitedWalletsManager || ownerByAddress[msg.sender]);\n\n        limitedWallets[_wallet] = true;\n",
          "message": "TransferLimitedToken.addLimitedWalletAddress (Crowdsale.sol#465-468) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 474,
          "vulnerability_to_line": 476,
          "vulnerability_code": "    function delLimitedWalletAddress(address _wallet) public onlyManager {\n\n        limitedWallets[_wallet] = false;\n",
          "message": "TransferLimitedToken.delLimitedWalletAddress (Crowdsale.sol#474-476) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 481,
          "vulnerability_to_line": 483,
          "vulnerability_code": "    function disableLimit() public onlyManager {\n\n        isLimitEnabled = false;\n",
          "message": "TransferLimitedToken.disableLimit (Crowdsale.sol#481-483) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 544,
          "vulnerability_to_line": 554,
          "vulnerability_code": "    function releaseTokens() public {\n\n        require(walletTokens[msg.sender].length > 0);\n\n\n\n        for(uint256 i = 0; i < walletTokens[msg.sender].length; i++) {\n\n            if(!walletTokens[msg.sender][i].released && now >= walletTokens[msg.sender][i].lockEndTime) {\n\n                walletTokens[msg.sender][i].released = true;\n\n                token.transfer(msg.sender, walletTokens[msg.sender][i].amount);\n\n                TokensUnlocked(msg.sender, walletTokens[msg.sender][i].amount);\n\n            }\n\n        }\n",
          "message": "LockedTokens.releaseTokens (Crowdsale.sol#544-554) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 591,
          "vulnerability_to_line": 594,
          "vulnerability_code": "    function transferOwnership(address _newOwner) public onlyOwner {\n\n        require(_newOwner != owner);\n\n        newOwner = _newOwner;\n",
          "message": "Ownable.transferOwnership (Crowdsale.sol#591-594) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 599,
          "vulnerability_to_line": 604,
          "vulnerability_code": "    function confirmOwnership() public {\n\n        require(msg.sender == newOwner);\n\n        OwnershipTransferred(owner, newOwner);\n\n        owner = newOwner;\n\n        newOwner = 0x0;\n",
          "message": "Ownable.confirmOwnership (Crowdsale.sol#599-604) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 641,
          "vulnerability_to_line": 644,
          "vulnerability_code": "    function pause() onlyOwner whenNotPaused public {\n\n        paused = true;\n\n        Pause();\n",
          "message": "Pausable.pause (Crowdsale.sol#641-644) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 649,
          "vulnerability_to_line": 652,
          "vulnerability_code": "    function unpause() onlyOwner whenPaused public {\n\n        paused = false;\n\n        Unpause();\n",
          "message": "Pausable.unpause (Crowdsale.sol#649-652) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 855,
          "vulnerability_to_line": 860,
          "vulnerability_code": "    function setTokenPrice(uint256 _tokenPriceNum, uint256 _tokenPriceDenom) public onlyOwner {\n\n        require(tokenPriceNum == 0 && tokenPriceDenom == 0);\n\n        require(_tokenPriceNum > 0 && _tokenPriceDenom > 0);\n\n        tokenPriceNum = _tokenPriceNum;\n\n        tokenPriceDenom = _tokenPriceDenom;\n",
          "message": "TheAbyssDAICO.setTokenPrice (Crowdsale.sol#855-860) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 866,
          "vulnerability_to_line": 869,
          "vulnerability_code": "    function setHardCap(uint256 _hardCap) public onlyOwner {\n\n        require(hardCap == 0);\n\n        hardCap = _hardCap;\n",
          "message": "TheAbyssDAICO.setHardCap (Crowdsale.sol#866-869) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 875,
          "vulnerability_to_line": 878,
          "vulnerability_code": "    function setSoftCap(uint256 _softCap) public onlyOwner {\n\n        require(softCap == 0);\n\n        softCap = _softCap;\n",
          "message": "TheAbyssDAICO.setSoftCap (Crowdsale.sol#875-878) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 927,
          "vulnerability_to_line": 949,
          "vulnerability_code": "    function addToLists(\n\n        address _wallet,\n\n        bool isInWhiteList,\n\n        bool isInPrivilegedList,\n\n        bool isInLimitedList,\n\n        bool hasAdditionalBonus\n\n    ) public onlyOwner {\n\n        if(isInWhiteList) {\n\n            whiteList[_wallet] = true;\n\n        }\n\n        if(isInPrivilegedList) {\n\n            privilegedList[_wallet] = true;\n\n        }\n\n        if(isInLimitedList) {\n\n            token.addLimitedWalletAddress(_wallet);\n\n        }\n\n        if(hasAdditionalBonus) {\n\n            additionalBonusOwnerState[_wallet] = AdditionalBonusState.Active;\n\n        }\n\n        if(reservationFund.canCompleteContribution(_wallet)) {\n\n            reservationFund.completeContribution(_wallet);\n\n        }\n",
          "message": "TheAbyssDAICO.addToLists (Crowdsale.sol#927-949) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 954,
          "vulnerability_to_line": 956,
          "vulnerability_code": "    function addToWhiteList(address _wallet) public onlyOwner {\n\n        whiteList[_wallet] = true;\n",
          "message": "TheAbyssDAICO.addToWhiteList (Crowdsale.sol#954-956) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 961,
          "vulnerability_to_line": 963,
          "vulnerability_code": "    function addAdditionalBonusMember(address _wallet) public onlyOwner {\n\n        additionalBonusOwnerState[_wallet] = AdditionalBonusState.Active;\n",
          "message": "TheAbyssDAICO.addAdditionalBonusMember (Crowdsale.sol#961-963) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 968,
          "vulnerability_to_line": 970,
          "vulnerability_code": "    function addToPrivilegedList(address _wallet) public onlyOwner {\n\n        privilegedList[_wallet] = true;\n",
          "message": "TheAbyssDAICO.addToPrivilegedList (Crowdsale.sol#968-970) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 975,
          "vulnerability_to_line": 977,
          "vulnerability_code": "    function setLockedTokens(address lockedTokensAddress) public onlyOwner {\n\n        lockedTokens = LockedTokens(lockedTokensAddress);\n",
          "message": "TheAbyssDAICO.setLockedTokens (Crowdsale.sol#975-977) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 982,
          "vulnerability_to_line": 988,
          "vulnerability_code": "    function () payable public whenNotPaused {\n\n        if(whiteList[msg.sender] || privilegedList[msg.sender] || token.limitedWallets(msg.sender)) {\n\n            processContribution(msg.sender, msg.value);\n\n        } else {\n\n            processReservationContribution(msg.sender, msg.value);\n\n        }\n",
          "message": "TheAbyssDAICO.fallback (Crowdsale.sol#982-988) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 1019,
          "vulnerability_to_line": 1047,
          "vulnerability_code": "    function processBNBContribution() public whenNotPaused checkTime checkBNBContribution {\n\n        bool additionalBonusApplied = false;\n\n        uint256 bonusNum = 0;\n\n        uint256 bonusDenom = 100;\n\n        (bonusNum, bonusDenom) = getBonus();\n\n        uint256 amountBNB = bnbToken.allowance(msg.sender, address(this));\n\n        bnbToken.transferFrom(msg.sender, address(this), amountBNB);\n\n        bnbContributions[msg.sender] = safeAdd(bnbContributions[msg.sender], amountBNB);\n\n\n\n        uint256 tokenBonusAmount = 0;\n\n        uint256 tokenAmount = safeDiv(safeMul(amountBNB, BNB_TOKEN_PRICE_NUM), BNB_TOKEN_PRICE_DENOM);\n\n        rawTokenSupply = safeAdd(rawTokenSupply, tokenAmount);\n\n        if(bonusNum > 0) {\n\n            tokenBonusAmount = safeDiv(safeMul(tokenAmount, bonusNum), bonusDenom);\n\n        }\n\n\n\n        if(additionalBonusOwnerState[msg.sender] ==  AdditionalBonusState.Active) {\n\n            additionalBonusOwnerState[msg.sender] = AdditionalBonusState.Applied;\n\n            uint256 additionalBonus = safeDiv(safeMul(tokenAmount, ADDITIONAL_BONUS_NUM), ADDITIONAL_BONUS_DENOM);\n\n            tokenBonusAmount = safeAdd(tokenBonusAmount, additionalBonus);\n\n            additionalBonusApplied = true;\n\n        }\n\n\n\n        uint256 tokenTotalAmount = safeAdd(tokenAmount, tokenBonusAmount);\n\n        token.issue(msg.sender, tokenTotalAmount);\n\n        totalBNBContributed = safeAdd(totalBNBContributed, amountBNB);\n\n\n\n        LogBNBContribution(msg.sender, amountBNB, tokenAmount, tokenBonusAmount, additionalBonusApplied, now);\n",
          "message": "TheAbyssDAICO.processBNBContribution (Crowdsale.sol#1019-1047) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 1103,
          "vulnerability_to_line": 1150,
          "vulnerability_code": "    function finalizeCrowdsale() public onlyOwner {\n\n        if(\n\n            (totalEtherContributed >= safeSub(hardCap, ETHER_MIN_CONTRIB_USA) && totalBNBContributed >= safeSub(BNB_HARD_CAP, BNB_MIN_CONTRIB)) ||\n\n            (now >= SALE_END_TIME && totalEtherContributed >= softCap)\n\n        ) {\n\n            fund.onCrowdsaleEnd();\n\n            reservationFund.onCrowdsaleEnd();\n\n            // BNB transfer\n\n            bnbToken.transfer(bnbTokenWallet, bnbToken.balanceOf(address(this)));\n\n\n\n            // Referral\n\n            uint256 referralTokenAmount = safeDiv(rawTokenSupply, 10);\n\n            token.issue(referralTokenWallet, referralTokenAmount);\n\n\n\n            // Foundation\n\n            uint256 foundationTokenAmount = safeDiv(token.totalSupply(), 2); // 20%\n\n            lockedTokens.addTokens(foundationTokenWallet, foundationTokenAmount, now + 365 days);\n\n\n\n            uint256 suppliedTokenAmount = token.totalSupply();\n\n\n\n            // Reserve\n\n            uint256 reservedTokenAmount = safeDiv(safeMul(suppliedTokenAmount, 3), 10); // 18%\n\n            token.issue(address(lockedTokens), reservedTokenAmount);\n\n            lockedTokens.addTokens(reserveTokenWallet, reservedTokenAmount, now + 183 days);\n\n\n\n            // Advisors\n\n            uint256 advisorsTokenAmount = safeDiv(suppliedTokenAmount, 10); // 6%\n\n            token.issue(advisorsTokenWallet, advisorsTokenAmount);\n\n\n\n            // Company\n\n            uint256 companyTokenAmount = safeDiv(suppliedTokenAmount, 4); // 15%\n\n            token.issue(address(lockedTokens), companyTokenAmount);\n\n            lockedTokens.addTokens(companyTokenWallet, companyTokenAmount, now + 730 days);\n\n\n\n            // Bounty\n\n            uint256 bountyTokenAmount = safeDiv(suppliedTokenAmount, 60); // 1%\n\n            token.issue(bountyTokenWallet, bountyTokenAmount);\n\n\n\n            token.setAllowTransfers(true);\n\n\n\n        } else if(now >= SALE_END_TIME) {\n\n            // Enable fund`s crowdsale refund if soft cap is not reached\n\n            fund.enableCrowdsaleRefund();\n\n            reservationFund.onCrowdsaleEnd();\n\n            bnbRefundEnabled = true;\n\n        }\n\n        token.finishIssuance();\n",
          "message": "TheAbyssDAICO.finalizeCrowdsale (Crowdsale.sol#1103-1150) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 1155,
          "vulnerability_to_line": 1162,
          "vulnerability_code": "    function refundBNBContributor() public {\n\n        require(bnbRefundEnabled);\n\n        require(bnbContributions[msg.sender] > 0);\n\n        uint256 amount = bnbContributions[msg.sender];\n\n        bnbContributions[msg.sender] = 0;\n\n        bnbToken.transfer(msg.sender, amount);\n\n        token.destroy(msg.sender, token.balanceOf(msg.sender));\n",
          "message": "TheAbyssDAICO.refundBNBContributor (Crowdsale.sol#1155-1162) should be declared external\n"
        },
        {
          "name": "solc-version",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.21;\n",
          "message": "Detected issues with version pragma in Crowdsale.sol:\n\t- pragma solidity^0.4.21 (Crowdsale.sol#3): it allows old versions\n\t- pragma solidity^0.4.21 (Crowdsale.sol#27): it allows old versions\n\t- pragma solidity^0.4.21 (Crowdsale.sol#64): it allows old versions\n\t- pragma solidity^0.4.21 (Crowdsale.sol#89): it allows old versions\n\t- pragma solidity^0.4.21 (Crowdsale.sol#145): it allows old versions\n\t- pragma solidity^0.4.21 (Crowdsale.sol#183): it allows old versions\n\t- pragma solidity^0.4.21 (Crowdsale.sol#232): it allows old versions\n\t- pragma solidity^0.4.21 (Crowdsale.sol#250): it allows old versions\n\t- pragma solidity^0.4.21 (Crowdsale.sol#413): it allows old versions\n\t- pragma solidity^0.4.21 (Crowdsale.sol#500): it allows old versions\n\t- pragma solidity^0.4.21 (Crowdsale.sol#559): it allows old versions\n\t- pragma solidity^0.4.21 (Crowdsale.sol#609): it allows old versions\n\t- pragma solidity^0.4.21 (Crowdsale.sol#657): it allows old versions\n\t- pragma solidity^0.4.21 (Crowdsale.sol#672): it allows old versions\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 112,
          "vulnerability_to_line": 114,
          "vulnerability_code": "    function MultiOwnable() public {\n\n        manager = msg.sender;\n",
          "message": "Function 'MultiOwnable.MultiOwnable' (Crowdsale.sol#112-114) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 119,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setOwners(address[] _owners) public {\n",
          "message": "Parameter '_owners' of MultiOwnable.setOwners (Crowdsale.sol#119) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 125,
          "vulnerability_to_line": 136,
          "vulnerability_code": "    function _setOwners(address[] _owners) internal {\n\n        for(uint256 i = 0; i < owners.length; i++) {\n\n            ownerByAddress[owners[i]] = false;\n\n        }\n\n\n\n\n\n        for(uint256 j = 0; j < _owners.length; j++) {\n\n            ownerByAddress[_owners[j]] = true;\n\n        }\n\n        owners = _owners;\n\n        SetOwners(_owners);\n",
          "message": "Function 'MultiOwnable._setOwners' (Crowdsale.sol#125-136) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 125,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setOwners(address[] _owners) internal {\n",
          "message": "Parameter '_owners' of MultiOwnable._setOwners (Crowdsale.sol#125) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 155,
          "vulnerability_to_line": 156,
          "vulnerability_code": "    function SafeMath() public {\n",
          "message": "Function 'SafeMath.SafeMath' (Crowdsale.sol#155-156) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 215,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function balanceOf(address _owner) public constant returns (uint256) {\n",
          "message": "Parameter '_owner' of ERC20Token.balanceOf (Crowdsale.sol#215) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 194,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function transfer(address _to, uint256 _value) public returns (bool) {\n",
          "message": "Parameter '_to' of ERC20Token.transfer (Crowdsale.sol#194) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 194,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function transfer(address _to, uint256 _value) public returns (bool) {\n",
          "message": "Parameter '_value' of ERC20Token.transfer (Crowdsale.sol#194) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 204,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n",
          "message": "Parameter '_from' of ERC20Token.transferFrom (Crowdsale.sol#204) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 204,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n",
          "message": "Parameter '_to' of ERC20Token.transferFrom (Crowdsale.sol#204) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 204,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n",
          "message": "Parameter '_value' of ERC20Token.transferFrom (Crowdsale.sol#204) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 219,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function approve(address _spender, uint256 _value) public returns (bool) {\n",
          "message": "Parameter '_spender' of ERC20Token.approve (Crowdsale.sol#219) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 219,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function approve(address _spender, uint256 _value) public returns (bool) {\n",
          "message": "Parameter '_value' of ERC20Token.approve (Crowdsale.sol#219) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 225,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function allowance(address _owner, address _spender) public constant returns (uint256) {\n",
          "message": "Parameter '_owner' of ERC20Token.allowance (Crowdsale.sol#225) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 225,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function allowance(address _owner, address _spender) public constant returns (uint256) {\n",
          "message": "Parameter '_spender' of ERC20Token.allowance (Crowdsale.sol#225) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 313,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function transfer(address _to, uint256 _value) public transfersAllowed returns (bool) {\n",
          "message": "Parameter '_to' of ManagedToken.transfer (Crowdsale.sol#313) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 313,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function transfer(address _to, uint256 _value) public transfersAllowed returns (bool) {\n",
          "message": "Parameter '_value' of ManagedToken.transfer (Crowdsale.sol#313) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 321,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function transferFrom(address _from, address _to, uint256 _value) public transfersAllowed returns (bool) {\n",
          "message": "Parameter '_from' of ManagedToken.transferFrom (Crowdsale.sol#321) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 321,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function transferFrom(address _from, address _to, uint256 _value) public transfersAllowed returns (bool) {\n",
          "message": "Parameter '_to' of ManagedToken.transferFrom (Crowdsale.sol#321) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 321,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function transferFrom(address _from, address _to, uint256 _value) public transfersAllowed returns (bool) {\n",
          "message": "Parameter '_value' of ManagedToken.transferFrom (Crowdsale.sol#321) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 285,
          "vulnerability_to_line": 290,
          "vulnerability_code": "    function ManagedToken(address _listener, address[] _owners) public {\n\n        if(_listener != address(0)) {\n\n            eventListener = ITokenEventListener(_listener);\n\n        }\n\n        _setOwners(_owners);\n",
          "message": "Function 'ManagedToken.ManagedToken' (Crowdsale.sol#285-290) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 285,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function ManagedToken(address _listener, address[] _owners) public {\n",
          "message": "Parameter '_listener' of ManagedToken.ManagedToken (Crowdsale.sol#285) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 285,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function ManagedToken(address _listener, address[] _owners) public {\n",
          "message": "Parameter '_owners' of ManagedToken.ManagedToken (Crowdsale.sol#285) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 296,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setAllowTransfers(bool _allowTransfers) external onlyOwner {\n",
          "message": "Parameter '_allowTransfers' of ManagedToken.setAllowTransfers (Crowdsale.sol#296) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 305,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setListener(address _listener) public onlyOwner {\n",
          "message": "Parameter '_listener' of ManagedToken.setListener (Crowdsale.sol#305) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 341,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function issue(address _to, uint256 _value) external onlyOwner canIssue {\n",
          "message": "Parameter '_to' of ManagedToken.issue (Crowdsale.sol#341) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 341,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function issue(address _to, uint256 _value) external onlyOwner canIssue {\n",
          "message": "Parameter '_value' of ManagedToken.issue (Crowdsale.sol#341) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 354,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function destroy(address _from, uint256 _value) external {\n",
          "message": "Parameter '_from' of ManagedToken.destroy (Crowdsale.sol#354) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 354,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function destroy(address _from, uint256 _value) external {\n",
          "message": "Parameter '_value' of ManagedToken.destroy (Crowdsale.sol#354) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 373,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n",
          "message": "Parameter '_spender' of ManagedToken.increaseApproval (Crowdsale.sol#373) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 373,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n",
          "message": "Parameter '_addedValue' of ManagedToken.increaseApproval (Crowdsale.sol#373) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 389,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n",
          "message": "Parameter '_spender' of ManagedToken.decreaseApproval (Crowdsale.sol#389) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 389,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n",
          "message": "Parameter '_subtractedValue' of ManagedToken.decreaseApproval (Crowdsale.sol#389) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 485,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function transfer(address _to, uint256 _value) public canTransfer(msg.sender, _to) returns (bool) {\n",
          "message": "Parameter '_to' of TransferLimitedToken.transfer (Crowdsale.sol#485) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 485,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function transfer(address _to, uint256 _value) public canTransfer(msg.sender, _to) returns (bool) {\n",
          "message": "Parameter '_value' of TransferLimitedToken.transfer (Crowdsale.sol#485) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 489,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function transferFrom(address _from, address _to, uint256 _value) public canTransfer(_from, _to) returns (bool) {\n",
          "message": "Parameter '_from' of TransferLimitedToken.transferFrom (Crowdsale.sol#489) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 489,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function transferFrom(address _from, address _to, uint256 _value) public canTransfer(_from, _to) returns (bool) {\n",
          "message": "Parameter '_to' of TransferLimitedToken.transferFrom (Crowdsale.sol#489) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 489,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function transferFrom(address _from, address _to, uint256 _value) public canTransfer(_from, _to) returns (bool) {\n",
          "message": "Parameter '_value' of TransferLimitedToken.transferFrom (Crowdsale.sol#489) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 493,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function approve(address _spender, uint256 _value) public canTransfer(msg.sender, _spender) returns (bool) {\n",
          "message": "Parameter '_spender' of TransferLimitedToken.approve (Crowdsale.sol#493) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 493,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function approve(address _spender, uint256 _value) public canTransfer(msg.sender, _spender) returns (bool) {\n",
          "message": "Parameter '_value' of TransferLimitedToken.approve (Crowdsale.sol#493) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 449,
          "vulnerability_to_line": 459,
          "vulnerability_code": "    function TransferLimitedToken(\n\n        uint256 _limitStartDate,\n\n        address _listener,\n\n        address[] _owners,\n\n        address _limitedWalletsManager\n\n    ) public ManagedToken(_listener, _owners)\n\n    {\n\n        limitEndDate = _limitStartDate + LIMIT_TRANSFERS_PERIOD;\n\n        isLimitEnabled = true;\n\n        limitedWalletsManager = _limitedWalletsManager;\n",
          "message": "Function 'TransferLimitedToken.TransferLimitedToken' (Crowdsale.sol#449-459) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 450,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint256 _limitStartDate,\n",
          "message": "Parameter '_limitStartDate' of TransferLimitedToken.TransferLimitedToken (Crowdsale.sol#450) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 453,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address _limitedWalletsManager\n",
          "message": "Parameter '_limitedWalletsManager' of TransferLimitedToken.TransferLimitedToken (Crowdsale.sol#453) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 465,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function addLimitedWalletAddress(address _wallet) public {\n",
          "message": "Parameter '_wallet' of TransferLimitedToken.addLimitedWalletAddress (Crowdsale.sol#465) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 474,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function delLimitedWalletAddress(address _wallet) public onlyManager {\n",
          "message": "Parameter '_wallet' of TransferLimitedToken.delLimitedWalletAddress (Crowdsale.sol#474) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 525,
          "vulnerability_to_line": 528,
          "vulnerability_code": "    function LockedTokens(IERC20Token _token, address _crowdsaleAddress) public {\n\n        token = _token;\n\n        crowdsaleAddress = _crowdsaleAddress;\n",
          "message": "Function 'LockedTokens.LockedTokens' (Crowdsale.sol#525-528) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 525,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function LockedTokens(IERC20Token _token, address _crowdsaleAddress) public {\n",
          "message": "Parameter '_token' of LockedTokens.LockedTokens (Crowdsale.sol#525) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 525,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function LockedTokens(IERC20Token _token, address _crowdsaleAddress) public {\n",
          "message": "Parameter '_crowdsaleAddress' of LockedTokens.LockedTokens (Crowdsale.sol#525) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 536,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function addTokens(address _to, uint256 _amount, uint256 _lockEndTime) external {\n",
          "message": "Parameter '_to' of LockedTokens.addTokens (Crowdsale.sol#536) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 536,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function addTokens(address _to, uint256 _amount, uint256 _lockEndTime) external {\n",
          "message": "Parameter '_amount' of LockedTokens.addTokens (Crowdsale.sol#536) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 536,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function addTokens(address _to, uint256 _amount, uint256 _lockEndTime) external {\n",
          "message": "Parameter '_lockEndTime' of LockedTokens.addTokens (Crowdsale.sol#536) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 575,
          "vulnerability_to_line": 577,
          "vulnerability_code": "    function Ownable(address _owner) public {\n\n        owner = _owner == address(0) ? msg.sender : _owner;\n",
          "message": "Function 'Ownable.Ownable' (Crowdsale.sol#575-577) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 575,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function Ownable(address _owner) public {\n",
          "message": "Parameter '_owner' of Ownable.Ownable (Crowdsale.sol#575) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 591,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function transferOwnership(address _newOwner) public onlyOwner {\n",
          "message": "Parameter '_newOwner' of Ownable.transferOwnership (Crowdsale.sol#591) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 773,
          "vulnerability_to_line": 803,
          "vulnerability_code": "    function TheAbyssDAICO(\n\n        address bnbTokenAddress,\n\n        address tokenAddress,\n\n        address fundAddress,\n\n        address reservationFundAddress,\n\n        address _bnbTokenWallet,\n\n        address _referralTokenWallet,\n\n        address _foundationTokenWallet,\n\n        address _advisorsTokenWallet,\n\n        address _companyTokenWallet,\n\n        address _reserveTokenWallet,\n\n        address _bountyTokenWallet,\n\n        address _owner\n\n    ) public\n\n        Ownable(_owner)\n\n    {\n\n        require(tokenAddress != address(0));\n\n\n\n        bnbToken = IERC20Token(bnbTokenAddress);\n\n        token = TransferLimitedToken(tokenAddress);\n\n        fund = ICrowdsaleFund(fundAddress);\n\n        reservationFund = ICrowdsaleReservationFund(reservationFundAddress);\n\n\n\n        bnbTokenWallet = _bnbTokenWallet;\n\n        referralTokenWallet = _referralTokenWallet;\n\n        foundationTokenWallet = _foundationTokenWallet;\n\n        advisorsTokenWallet = _advisorsTokenWallet;\n\n        companyTokenWallet = _companyTokenWallet;\n\n        reserveTokenWallet = _reserveTokenWallet;\n\n        bountyTokenWallet = _bountyTokenWallet;\n",
          "message": "Function 'TheAbyssDAICO.TheAbyssDAICO' (Crowdsale.sol#773-803) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 778,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address _bnbTokenWallet,\n",
          "message": "Parameter '_bnbTokenWallet' of TheAbyssDAICO.TheAbyssDAICO (Crowdsale.sol#778) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 779,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address _referralTokenWallet,\n",
          "message": "Parameter '_referralTokenWallet' of TheAbyssDAICO.TheAbyssDAICO (Crowdsale.sol#779) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 780,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address _foundationTokenWallet,\n",
          "message": "Parameter '_foundationTokenWallet' of TheAbyssDAICO.TheAbyssDAICO (Crowdsale.sol#780) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 781,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address _advisorsTokenWallet,\n",
          "message": "Parameter '_advisorsTokenWallet' of TheAbyssDAICO.TheAbyssDAICO (Crowdsale.sol#781) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 782,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address _companyTokenWallet,\n",
          "message": "Parameter '_companyTokenWallet' of TheAbyssDAICO.TheAbyssDAICO (Crowdsale.sol#782) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 783,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address _reserveTokenWallet,\n",
          "message": "Parameter '_reserveTokenWallet' of TheAbyssDAICO.TheAbyssDAICO (Crowdsale.sol#783) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 784,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address _bountyTokenWallet,\n",
          "message": "Parameter '_bountyTokenWallet' of TheAbyssDAICO.TheAbyssDAICO (Crowdsale.sol#784) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 855,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setTokenPrice(uint256 _tokenPriceNum, uint256 _tokenPriceDenom) public onlyOwner {\n",
          "message": "Parameter '_tokenPriceNum' of TheAbyssDAICO.setTokenPrice (Crowdsale.sol#855) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 855,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setTokenPrice(uint256 _tokenPriceNum, uint256 _tokenPriceDenom) public onlyOwner {\n",
          "message": "Parameter '_tokenPriceDenom' of TheAbyssDAICO.setTokenPrice (Crowdsale.sol#855) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 866,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setHardCap(uint256 _hardCap) public onlyOwner {\n",
          "message": "Parameter '_hardCap' of TheAbyssDAICO.setHardCap (Crowdsale.sol#866) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 875,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setSoftCap(uint256 _softCap) public onlyOwner {\n",
          "message": "Parameter '_softCap' of TheAbyssDAICO.setSoftCap (Crowdsale.sol#875) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 928,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address _wallet,\n",
          "message": "Parameter '_wallet' of TheAbyssDAICO.addToLists (Crowdsale.sol#928) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 954,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function addToWhiteList(address _wallet) public onlyOwner {\n",
          "message": "Parameter '_wallet' of TheAbyssDAICO.addToWhiteList (Crowdsale.sol#954) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 961,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function addAdditionalBonusMember(address _wallet) public onlyOwner {\n",
          "message": "Parameter '_wallet' of TheAbyssDAICO.addAdditionalBonusMember (Crowdsale.sol#961) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 968,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function addToPrivilegedList(address _wallet) public onlyOwner {\n",
          "message": "Parameter '_wallet' of TheAbyssDAICO.addToPrivilegedList (Crowdsale.sol#968) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 739,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint256 public BNB_HARD_CAP = 300000 ether; // 300K BNB\n",
          "message": "Variable 'TheAbyssDAICO.BNB_HARD_CAP' (Crowdsale.sol#739) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 740,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint256 public BNB_MIN_CONTRIB = 1000 ether; // 1K BNB\n",
          "message": "Variable 'TheAbyssDAICO.BNB_MIN_CONTRIB' (Crowdsale.sol#740) is not in mixedCase\n"
        }
      ]
    },
    "smartcheck": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 603,
          "vulnerability_to_line": null,
          "vulnerability_code": "        newOwner = 0x0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
          "vulnerability_from_line": 77,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function balanceOf(address _owner) public constant returns (uint256 balance);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
          "vulnerability_from_line": 81,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function allowance(address _owner, address _spender)  public constant returns (uint256 remaining);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
          "vulnerability_from_line": 138,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getOwners() public constant returns (address[]) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
          "vulnerability_from_line": 215,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function balanceOf(address _owner) public constant returns (uint256) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
          "vulnerability_from_line": 225,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function allowance(address _owner, address _spender) public constant returns (uint256) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
          "vulnerability_from_line": 908,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getBonus() internal constant returns (uint256, uint256) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ERC20_APPROVE",
          "vulnerability_from_line": 219,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function approve(address _spender, uint256 _value) public returns (bool) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ERC20_APPROVE",
          "vulnerability_from_line": 493,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function approve(address _spender, uint256 _value) public canTransfer(msg.sender, _spender) returns (bool) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 126,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(uint256 i = 0; i < owners.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 131,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(uint256 j = 0; j < _owners.length; j++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 547,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(uint256 i = 0; i < walletTokens[msg.sender].length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 126,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(uint256 i = 0; i < owners.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 131,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(uint256 j = 0; j < _owners.length; j++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 547,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(uint256 i = 0; i < walletTokens[msg.sender].length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_OVERPOWERED_ROLE",
          "vulnerability_from_line": 119,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setOwners(address[] _owners) public {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_OVERPOWERED_ROLE",
          "vulnerability_from_line": 296,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setAllowTransfers(bool _allowTransfers) external onlyOwner {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_OVERPOWERED_ROLE",
          "vulnerability_from_line": 305,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setListener(address _listener) public onlyOwner {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_OVERPOWERED_ROLE",
          "vulnerability_from_line": 855,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setTokenPrice(uint256 _tokenPriceNum, uint256 _tokenPriceDenom) public onlyOwner {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_OVERPOWERED_ROLE",
          "vulnerability_from_line": 866,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setHardCap(uint256 _hardCap) public onlyOwner {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_OVERPOWERED_ROLE",
          "vulnerability_from_line": 875,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setSoftCap(uint256 _softCap) public onlyOwner {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_OVERPOWERED_ROLE",
          "vulnerability_from_line": 975,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setLockedTokens(address lockedTokensAddress) public onlyOwner {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.21;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 27,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.21;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 64,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.21;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 89,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.21;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 145,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.21;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 183,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.21;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 232,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.21;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 250,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.21;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 413,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.21;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 500,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.21;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 559,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.21;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 609,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.21;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 657,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.21;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 672,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.21;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 908,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getBonus() internal constant returns (uint256, uint256) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 982,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function () payable public whenNotPaused {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 119,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setOwners(address[] _owners) public {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 125,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setOwners(address[] _owners) internal {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 138,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getOwners() public constant returns (address[]) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 285,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function ManagedToken(address _listener, address[] _owners) public {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 452,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address[] _owners,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 245,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function onTokenTransfer(address _from, address _to, uint256 _value) public;\n",
          "message": null
        }
      ]
    },
    "oyente": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "Integer Overflow",
          "vulnerability_from_line": 175,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint256 c = a + b;\n",
          "message": null
        },
        {
          "name": "Integer Underflow",
          "vulnerability_from_line": 72,
          "vulnerability_to_line": null,
          "vulnerability_code": "    string public name;\n",
          "message": null
        },
        {
          "name": "Integer Overflow",
          "vulnerability_from_line": 518,
          "vulnerability_to_line": null,
          "vulnerability_code": "    mapping(address => Tokens[]) public walletTokens;\n",
          "message": null
        },
        {
          "name": "Integer Overflow",
          "vulnerability_from_line": 119,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setOwners(address[] _owners) public {\n",
          "message": null
        },
        {
          "name": "Integer Underflow",
          "vulnerability_from_line": 72,
          "vulnerability_to_line": null,
          "vulnerability_code": "    string public name;\n",
          "message": null
        },
        {
          "name": "Integer Overflow",
          "vulnerability_from_line": 119,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setOwners(address[] _owners) public {\n",
          "message": null
        },
        {
          "name": "Integer Overflow",
          "vulnerability_from_line": 119,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setOwners(address[] _owners) public {\n",
          "message": null
        },
        {
          "name": "Integer Underflow",
          "vulnerability_from_line": 72,
          "vulnerability_to_line": null,
          "vulnerability_code": "    string public name;\n",
          "message": null
        }
      ]
    },
    "mythril": {
      "successfull_analysis": false,
      "errors": [
        "DOCKER_TIMEOUT"
      ],
      "vulnerability_findings": []
    },
    "osiris": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "Overflow bugs",
          "vulnerability_from_line": 1,
          "vulnerability_to_line": null,
          "vulnerability_code": "// File: ../sc_datasets/DAppSCAN/New_Alchemy_Security_Audit-The Abyss DAICO Smart Contract Audit (New)/abyss-daico-21d6232a802cd966b86629cadeac0b7f3816f719/fund/ICrowdsaleFund.sol\n",
          "message": null
        }
      ]
    }
  }
}