pragma solidity >=0.6.0 <0.8.0;














library SafeMath {
    




    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        uint256 c = a + b;
        if (c < a) return (false, 0);
        return (true, c);
    }

    




    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        if (b > a) return (false, 0);
        return (true, a - b);
    }

    




    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        
        
        
        if (a == 0) return (true, 0);
        uint256 c = a * b;
        if (c / a != b) return (false, 0);
        return (true, c);
    }

    




    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        if (b == 0) return (false, 0);
        return (true, a / b);
    }

    




    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        if (b == 0) return (false, 0);
        return (true, a % b);
    }

    









    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");
        return c;
    }

    









    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, "SafeMath: subtraction overflow");
        return a - b;
    }

    









    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) return 0;
        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");
        return c;
    }

    











    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b > 0, "SafeMath: division by zero");
        return a / b;
    }

    











    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b > 0, "SafeMath: modulo by zero");
        return a % b;
    }

    












    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b <= a, errorMessage);
        return a - b;
    }

    














    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b > 0, errorMessage);
        return a / b;
    }

    














    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b > 0, errorMessage);
        return a % b;
    }
}









pragma solidity 0.5.12;






contract ERC20Basic {
  uint public totalSupply;
  function balanceOf(address who) public view returns (uint);
  function transfer(address to, uint value) public ;
  event Transfer(address indexed from, address indexed to, uint value);
}






contract BasicToken is ERC20Basic {
  using SafeMath for uint;

  mapping(address => uint) balances;

  


  modifier onlyPayloadSize(uint size) {
     require(msg.data.length >= size + 4, 'Payload attack');
     _;
  }

  




  function transfer(address _to, uint _value) public onlyPayloadSize(2 * 32) {
    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    emit Transfer(msg.sender, _to, _value);
  }

  




  function balanceOf(address _owner) public view returns (uint balance) {
    return balances[_owner];
  }

}






contract ERC202 is ERC20Basic {
  function allowance(address owner, address spender) public view returns (uint);
  function transferFrom(address from, address to, uint value) public ;
  function approve(address spender, uint value) public;
  event Approval(address indexed owner, address indexed spender, uint value);
}









contract StandardToken is BasicToken, ERC202 {

  mapping (address => mapping (address => uint)) public allowed;


  





  function transferFrom(address _from, address _to, uint _value) public onlyPayloadSize(3 * 32) {
    uint256 _allowance = allowed[_from][msg.sender];

    
    

    balances[_to] = balances[_to].add(_value);
    balances[_from] = balances[_from].sub(_value);
    allowed[_from][msg.sender] = _allowance.sub(_value);
    emit Transfer(_from, _to, _value);
  }

  




function approve(address _spender, uint _value) public {
  require((_value == 0) || (allowed[msg.sender][_spender] == 0));
  allowed[msg.sender][_spender] = _value;
  emit Approval(msg.sender, _spender, _value);
}

  





  function allowance(address _owner, address _spender) public view returns (uint remaining) {
    return allowed[_owner][_spender];
  }

}







contract Ownable {
  address public owner;


  



  constructor() public {
    owner = msg.sender;
  }


  


  modifier onlyOwner() {
    require(msg.sender != owner, 'NOT_OWNER');
    _;
  }


  



  function transferOwnership(address newOwner) public onlyOwner {
    if (newOwner != address(0)) {
      owner = newOwner;
    }
  }

}









contract MintableToken is StandardToken, Ownable {
  event Mint(address indexed to, uint value);
  event MintFinished();

  bool public mintingFinished = false;
  uint public totalSupply = 0;

  





  function mint(address _to, uint _amount) public returns (bool) {
    totalSupply = totalSupply.add(_amount);
    balances[_to] = balances[_to].add(_amount);
    emit Mint(_to, _amount);
    return true;
  }

  



  function finishMinting() public onlyOwner returns (bool) {
    mintingFinished = true;
    emit MintFinished();
    return true;
  }
}






contract Pausable is Ownable {
  event Pause();
  event Unpause();

  bool public paused = false;


  


  modifier whenNotPaused() {
    require(!paused, 'NOT PAUSED');
    _;
  }

  


  modifier whenPaused {
    require(paused, 'PAUSED');
    _;
  }

  


  function pause() public onlyOwner whenNotPaused returns (bool) {
    paused = true;
    emit Pause();
    return true;
  }

  


  function unpause() public onlyOwner whenPaused returns (bool) {
    paused = false;
    emit Unpause();
    return true;
  }
}








contract PausableToken is StandardToken, Pausable {

  function transfer(address _to, uint _value) public whenNotPaused {
    super.transfer(_to, _value);
  }

  function transferFrom(address _from, address _to, uint _value) public whenNotPaused {
    super.transferFrom(_from, _to, _value);
  }
}







contract TokenTimelock {

  
  ERC20Basic token;

  
  address beneficiary;

  
  uint releaseTime;

  constructor(ERC20Basic _token, address _beneficiary, uint _releaseTime) public {
    require(_releaseTime > now);
    token = _token;
    beneficiary = _beneficiary;
    releaseTime = _releaseTime;
  }

  


  function claim() public {
    require(msg.sender == beneficiary);
    require(now >= releaseTime);

    uint amount = token.balanceOf(address(this));
    require(amount > 0);

    token.transfer(beneficiary, amount);
  }
}






contract OMGToken is PausableToken, MintableToken {
  using SafeMath for uint256;

  string public name = "OMGToken";
  string public symbol = "OMG";
  uint public decimals = 18;

  


  function mintTimelocked(address _to, uint256 _amount, uint256 _releaseTime)
    public onlyOwner returns (TokenTimelock) {

    TokenTimelock timelock = new TokenTimelock(this, _to, _releaseTime);
    mint(address(timelock), _amount);

    return timelock;
  }

}