pragma solidity ^0.8.0;











abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }
}






pragma solidity ^0.8.0;













abstract contract Ownable is Context {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    


    constructor() {
        _transferOwnership(_msgSender());
    }

    


    modifier onlyOwner() {
        _checkOwner();
        _;
    }

    


    function owner() public view virtual returns (address) {
        return _owner;
    }

    


    function _checkOwner() internal view virtual {
        require(owner() == _msgSender(), "Ownable: caller is not the owner");
    }

    






    function renounceOwnership() public virtual onlyOwner {
        _transferOwnership(address(0));
    }

    



    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        _transferOwnership(newOwner);
    }

    



    function _transferOwnership(address newOwner) internal virtual {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}






pragma solidity ^0.8.0;




interface IERC20 {
    





    event Transfer(address indexed from, address indexed to, uint256 value);

    



    event Approval(address indexed owner, address indexed spender, uint256 value);

    


    function totalSupply() external view returns (uint256);

    


    function balanceOf(address account) external view returns (uint256);

    






    function transfer(address to, uint256 amount) external returns (bool);

    






    function allowance(address owner, address spender) external view returns (uint256);

    













    function approve(address spender, uint256 amount) external returns (bool);

    








    function transferFrom(address from, address to, uint256 amount) external returns (bool);
}






pragma solidity ^0.8.0;









interface IERC20Permit {
    




















    function permit(
        address owner,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external;

    






    function nonces(address owner) external view returns (uint256);

    


    
    function DOMAIN_SEPARATOR() external view returns (bytes32);
}






pragma solidity ^0.8.1;




library Address {
    





























    function isContract(address account) internal view returns (bool) {
        
        
        

        return account.code.length > 0;
    }

    















    function sendValue(address payable recipient, uint256 amount) internal {
        require(address(this).balance >= amount, "Address: insufficient balance");

        (bool success, ) = recipient.call{value: amount}("");
        require(success, "Address: unable to send value, recipient may have reverted");
    }

    

















    function functionCall(address target, bytes memory data) internal returns (bytes memory) {
        return functionCallWithValue(target, data, 0, "Address: low-level call failed");
    }

    





    function functionCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal returns (bytes memory) {
        return functionCallWithValue(target, data, 0, errorMessage);
    }

    










    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {
        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
    }

    





    function functionCallWithValue(
        address target,
        bytes memory data,
        uint256 value,
        string memory errorMessage
    ) internal returns (bytes memory) {
        require(address(this).balance >= value, "Address: insufficient balance for call");
        (bool success, bytes memory returndata) = target.call{value: value}(data);
        return verifyCallResultFromTarget(target, success, returndata, errorMessage);
    }

    





    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
        return functionStaticCall(target, data, "Address: low-level static call failed");
    }

    





    function functionStaticCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal view returns (bytes memory) {
        (bool success, bytes memory returndata) = target.staticcall(data);
        return verifyCallResultFromTarget(target, success, returndata, errorMessage);
    }

    





    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {
        return functionDelegateCall(target, data, "Address: low-level delegate call failed");
    }

    





    function functionDelegateCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal returns (bytes memory) {
        (bool success, bytes memory returndata) = target.delegatecall(data);
        return verifyCallResultFromTarget(target, success, returndata, errorMessage);
    }

    





    function verifyCallResultFromTarget(
        address target,
        bool success,
        bytes memory returndata,
        string memory errorMessage
    ) internal view returns (bytes memory) {
        if (success) {
            if (returndata.length == 0) {
                
                
                require(isContract(target), "Address: call to non-contract");
            }
            return returndata;
        } else {
            _revert(returndata, errorMessage);
        }
    }

    





    function verifyCallResult(
        bool success,
        bytes memory returndata,
        string memory errorMessage
    ) internal pure returns (bytes memory) {
        if (success) {
            return returndata;
        } else {
            _revert(returndata, errorMessage);
        }
    }

    function _revert(bytes memory returndata, string memory errorMessage) private pure {
        
        if (returndata.length > 0) {
            
            
            assembly {
                let returndata_size := mload(returndata)
                revert(add(32, returndata), returndata_size)
            }
        } else {
            revert(errorMessage);
        }
    }
}






pragma solidity ^0.8.0;












library SafeERC20 {
    using Address for address;

    



    function safeTransfer(IERC20 token, address to, uint256 value) internal {
        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
    }

    



    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {
        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
    }

    






    function safeApprove(IERC20 token, address spender, uint256 value) internal {
        
        
        
        require(
            (value == 0) || (token.allowance(address(this), spender) == 0),
            "SafeERC20: approve from non-zero to non-zero allowance"
        );
        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
    }

    



    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {
        uint256 oldAllowance = token.allowance(address(this), spender);
        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));
    }

    



    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {
        unchecked {
            uint256 oldAllowance = token.allowance(address(this), spender);
            require(oldAllowance >= value, "SafeERC20: decreased allowance below zero");
            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));
        }
    }

    




    function forceApprove(IERC20 token, address spender, uint256 value) internal {
        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);

        if (!_callOptionalReturnBool(token, approvalCall)) {
            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));
            _callOptionalReturn(token, approvalCall);
        }
    }

    



    function safePermit(
        IERC20Permit token,
        address owner,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) internal {
        uint256 nonceBefore = token.nonces(owner);
        token.permit(owner, spender, value, deadline, v, r, s);
        uint256 nonceAfter = token.nonces(owner);
        require(nonceAfter == nonceBefore + 1, "SafeERC20: permit did not succeed");
    }

    





    function _callOptionalReturn(IERC20 token, bytes memory data) private {
        
        
        

        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");
        require(returndata.length == 0 || abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");
    }

    







    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {
        
        
        

        (bool success, bytes memory returndata) = address(token).call(data);
        return
            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));
    }
}






pragma solidity ^0.8.0;

















abstract contract ReentrancyGuard {
    
    
    
    
    

    
    
    
    
    
    uint256 private constant _NOT_ENTERED = 1;
    uint256 private constant _ENTERED = 2;

    uint256 private _status;

    constructor() {
        _status = _NOT_ENTERED;
    }

    






    modifier nonReentrant() {
        _nonReentrantBefore();
        _;
        _nonReentrantAfter();
    }

    function _nonReentrantBefore() private {
        
        require(_status != _ENTERED, "ReentrancyGuard: reentrant call");

        
        _status = _ENTERED;
    }

    function _nonReentrantAfter() private {
        
        
        _status = _NOT_ENTERED;
    }

    



    function _reentrancyGuardEntered() internal view returns (bool) {
        return _status == _ENTERED;
    }
}





pragma solidity ^0.8.0;














function beginMigration() public onlyOwner {
    require(hasRole(DEFAULT_ADMIN_ROLE, _msgSender()), "Must have admin role to migrate");
    _pause();
}





pragma solidity ^0.8.0;




interface IUniswapV2Router02 {
  function swapExactTokensForTokensSupportingFeeOnTransferTokens(
    uint256 amountIn,
    uint256 amountOutMin,
    address[] calldata path,
    address to,
    uint256 deadline
  ) external;
}





contract Converter is Ownable, ReentrancyGuard, TokenPaymentSplitter {
  using SafeERC20 for IERC20;

  address public wETH;

  address public swapToToken;

  address public immutable uniRouter;

  uint256 public triggerFee;

  mapping(address => address[]) private tokenPathMapping;

  event ConvertAndTransfer(
    address triggerAccount,
    address swapFromToken,
    address swapToToken,
    uint256 amountTokenFrom,
    uint256 amountTokenTo,
    address[] recievedAddresses
  );

  event DrainTo(address[] tokens, address dest);

  constructor(
    address _wETH,
    address _swapToToken,
    address _uniRouter,
    uint256 _triggerFee,
    address[] memory _payees,
    uint256[] memory _shares
  ) TokenPaymentSplitter(_payees, _shares) {
    wETH = _wETH;
    swapToToken = _swapToToken;
    uniRouter = _uniRouter;
    setTriggerFee(_triggerFee);
  }

  


  function setWETH(address _swapWETH) public onlyOwner {
    require(_swapWETH != address(0), "MUST_BE_VALID_ADDRESS");
    wETH = _swapWETH;
  }

  


  function setSwapToToken(address _swapToToken) public onlyOwner {
    require(_swapToToken != address(0), "MUST_BE_VALID_ADDRESS");
    swapToToken = _swapToToken;
  }

  


  function setTriggerFee(uint256 _triggerFee) public onlyOwner {
    require(_triggerFee <= 100, "FEE_TOO_HIGH");
    triggerFee = _triggerFee;
  }

  


  function setTokenPath(address _token, address[] memory _tokenPath)
    public
    onlyOwner
  {
    uint256 pathLength = _tokenPath.length;
    for (uint256 i = 0; i < pathLength; i++) {
      tokenPathMapping[_token].push(_tokenPath[i]);
    }
  }

  




  function convertAndTransfer(address _swapFromToken, uint256 _amountOutMin)
    public
    onlyOwner
    nonReentrant
  {
    
    require(_payees.length >= 1, "PAYEES_MUST_BE_SET");
    
    require(_amountOutMin > 0, "INVALID_AMOUNT_OUT");
    
    uint256 tokenBalance = _balanceOfErc20(_swapFromToken);
    
    require(tokenBalance > 0, "NO_BALANCE_TO_CONVERT");
    
    if (_swapFromToken != swapToToken) {
      address[] memory path;
      if (tokenPathMapping[_swapFromToken].length > 0) {
        path = getTokenPath(_swapFromToken);
      } else {
        tokenPathMapping[_swapFromToken].push(_swapFromToken);
        tokenPathMapping[_swapFromToken].push(wETH);
        if (swapToToken != wETH) {
          tokenPathMapping[_swapFromToken].push(swapToToken);
        }
        path = getTokenPath(_swapFromToken);
      }
      
      _approveErc20(_swapFromToken, tokenBalance);
      
      IUniswapV2Router02(uniRouter)
        .swapExactTokensForTokensSupportingFeeOnTransferTokens(
          tokenBalance,
          _amountOutMin,
          path,
          address(this),
          block.timestamp
        );
    }
    
    uint256 totalPayeeAmount = _balanceOfErc20(swapToToken);
    
    if (triggerFee > 0) {
      uint256 triggerFeeAmount = (totalPayeeAmount * triggerFee) / 100;
      _transferErc20(msg.sender, swapToToken, triggerFeeAmount);
      totalPayeeAmount = totalPayeeAmount - triggerFeeAmount;
    }
    
    for (uint256 i = 0; i < _payees.length; i++) {
      uint256 payeeAmount = (totalPayeeAmount * _shares[_payees[i]]) /
        _totalShares;
      _transferErc20(_payees[i], swapToToken, payeeAmount);
    }
    emit ConvertAndTransfer(
      msg.sender,
      _swapFromToken,
      swapToToken,
      tokenBalance,
      totalPayeeAmount,
      _payees
    );
  }

  




  function drainTo(address _transferTo, address[] calldata _tokens)
    public
    onlyOwner
  {
    for (uint256 i = 0; i < _tokens.length; i++) {
      uint256 balance = _balanceOfErc20(_tokens[i]);
      if (balance > 0) {
        _transferErc20(_transferTo, _tokens[i], balance);
      }
    }
    emit DrainTo(_tokens, _transferTo);
  }

  




  function addPayee(address _account, uint256 _shares) public onlyOwner {
    _addPayee(_account, _shares);
  }

  




  function removePayee(address _account, uint256 _index) public onlyOwner {
    _removePayee(_account, _index);
  }

  


  function getTokenPath(address _token)
    public
    view
    onlyOwner
    returns (address[] memory)
  {
    return tokenPathMapping[_token];
  }

  





  function _approveErc20(address _tokenToApprove, uint256 _amount) internal {
    require(
      IERC20(_tokenToApprove).approve(address(uniRouter), _amount),
      "APPROVE_FAILED"
    );
  }

  






  function _transferErc20(
    address _recipient,
    address _tokenContract,
    uint256 _transferAmount
  ) internal {
    IERC20(_tokenContract).safeTransfer(_recipient, _transferAmount);
  }

  




  function _balanceOfErc20(address _tokenToBalanceOf)
    internal
    view
    returns (uint256)
  {
    IERC20 erc;
    erc = IERC20(_tokenToBalanceOf);
    uint256 tokenBalance = erc.balanceOf(address(this));
    return tokenBalance;
  }
}