{
  "smartbugs_completed": true,
  "analyzer_results": {
    "semgrep": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 125,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(false, \"Failed to calculate legendre.\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 89,
          "vulnerability_to_line": null,
          "vulnerability_code": "            for (m = 0; m < r; m++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        }
      ]
    },
    "slither": {
      "successfull_analysis": true,
      "errors": [
        "EXIT_CODE_3"
      ],
      "vulnerability_findings": [
        {
          "name": "constant-function",
          "vulnerability_from_line": 12,
          "vulnerability_to_line": 35,
          "vulnerability_code": "    function modExp(uint256 base, uint256 exponent, uint256 p)\n\n        internal\n\n        view returns(uint256)\n\n    {\n\n        uint256[1] memory output;\n\n        /* solium-disable-next-line */\n\n        assembly {\n\n            // Args for the precompile: [<length_of_BASE> <length_of_EXPONENT>\n\n            // <length_of_MODULUS> <BASE> <EXPONENT> <MODULUS>]\n\n            let args := mload(0x40)\n\n            mstore(args, 0x20)\n\n            mstore(add(args, 0x20), 0x20)\n\n            mstore(add(args, 0x40), 0x20)\n\n            mstore(add(args, 0x60), base)\n\n            mstore(add(args, 0x80), exponent)\n\n            mstore(add(args, 0xa0), p)\n\n\n\n            // 0x05 is the modular exponent contract address\n\n            if iszero(staticcall(not(0), 0x05, args, 0xc0, output, 0x20)) {\n\n                revert(0, 0)\n\n            }\n\n        }\n\n        return output[0];\n",
          "message": "ModUtils.modExp (ModUtils.sol#12-35) is declared view but contains assembly code\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 12,
          "vulnerability_to_line": 35,
          "vulnerability_code": "    function modExp(uint256 base, uint256 exponent, uint256 p)\n\n        internal\n\n        view returns(uint256)\n\n    {\n\n        uint256[1] memory output;\n\n        /* solium-disable-next-line */\n\n        assembly {\n\n            // Args for the precompile: [<length_of_BASE> <length_of_EXPONENT>\n\n            // <length_of_MODULUS> <BASE> <EXPONENT> <MODULUS>]\n\n            let args := mload(0x40)\n\n            mstore(args, 0x20)\n\n            mstore(add(args, 0x20), 0x20)\n\n            mstore(add(args, 0x40), 0x20)\n\n            mstore(add(args, 0x60), base)\n\n            mstore(add(args, 0x80), exponent)\n\n            mstore(add(args, 0xa0), p)\n\n\n\n            // 0x05 is the modular exponent contract address\n\n            if iszero(staticcall(not(0), 0x05, args, 0xc0, output, 0x20)) {\n\n                revert(0, 0)\n\n            }\n\n        }\n\n        return output[0];\n",
          "message": "ModUtils.modExp uses assembly (ModUtils.sol#12-35)\n\t- ModUtils.sol#18-33\n"
        },
        {
          "name": "solc-version",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.4;\n",
          "message": "Detected issues with version pragma in ModUtils.sol:\n\t- pragma solidity^0.5.4 (ModUtils.sol#3): it allows old versions\n"
        }
      ]
    },
    "smartcheck": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 85,
          "vulnerability_to_line": null,
          "vulnerability_code": "        while (true) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 73,
          "vulnerability_to_line": null,
          "vulnerability_code": "        while (legendre(n, p) != -1) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.4;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
          "vulnerability_from_line": 12,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function modExp(uint256 base, uint256 exponent, uint256 p)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 18,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        }
      ]
    },
    "oyente": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": []
    },
    "mythril": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": []
    },
    "osiris": {
      "successfull_analysis": false,
      "errors": [
        "Solidity compilation failed"
      ],
      "vulnerability_findings": []
    }
  }
}