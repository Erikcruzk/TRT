{
  "smartbugs_completed": true,
  "analyzer_results": {
    "semgrep": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 103,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 i = 0; i < _owners.length; i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 230,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 i = 0; i < owners.length; i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "inefficient-state-variable-increment",
          "vulnerability_from_line": 252,
          "vulnerability_to_line": null,
          "vulnerability_code": "        transactionCount += 1;\n",
          "message": "<x> += <y> costs more gas than <x> = <x> + <y> for state variables."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 102,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor(address[] memory _owners, uint256 _required) public validRequirement(_owners.length, _required) {\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 103,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 i = 0; i < _owners.length; i++) {\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 104,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(!isOwner[_owners[i]] && _owners[i] != address(0));\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 105,
          "vulnerability_to_line": null,
          "vulnerability_code": "            isOwner[_owners[i]] = true;\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 106,
          "vulnerability_to_line": null,
          "vulnerability_code": "        }\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 107,
          "vulnerability_to_line": null,
          "vulnerability_code": "        owners = _owners;\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 108,
          "vulnerability_to_line": null,
          "vulnerability_code": "        required = _required;\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 109,
          "vulnerability_to_line": null,
          "vulnerability_code": "    }\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 104,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(!isOwner[_owners[i]] && _owners[i] != address(0));\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 105,
          "vulnerability_to_line": null,
          "vulnerability_code": "            isOwner[_owners[i]] = true;\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 230,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 i = 0; i < owners.length; i++) {\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 231,
          "vulnerability_to_line": null,
          "vulnerability_code": "            if (confirmations[transactionId][owners[i]]) count += 1;\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 231,
          "vulnerability_to_line": null,
          "vulnerability_code": "            if (confirmations[transactionId][owners[i]]) count += 1;\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 232,
          "vulnerability_to_line": null,
          "vulnerability_code": "            if (count == required) return true;\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 103,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 i = 0; i < _owners.length; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 230,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 i = 0; i < owners.length; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 308,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(to > from && transactionCount >= to, \"MultiSigWallet: function input `to` or `from` is not valid\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 87,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(ownerCount <= MAX_OWNER_COUNT && _required <= ownerCount && _required != 0 && ownerCount != 0);\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 104,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(!isOwner[_owners[i]] && _owners[i] != address(0));\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 308,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(to > from && transactionCount >= to, \"MultiSigWallet: function input `to` or `from` is not valid\");\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 271,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 i = 0; i < transactionCount; i++) if ((pending && !transactions[i].executed) || (executed && transactions[i].executed)) count += 1;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 313,
          "vulnerability_to_line": null,
          "vulnerability_code": "            if ((pending && !transactions[i].executed) || (executed && transactions[i].executed)) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 314,
          "vulnerability_to_line": null,
          "vulnerability_code": "                transactionIdsTemp[count] = i;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 315,
          "vulnerability_to_line": null,
          "vulnerability_code": "                count += 1;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 316,
          "vulnerability_to_line": null,
          "vulnerability_code": "            }\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 103,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 i = 0; i < _owners.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 123,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 i = 0; i < owners.length - 1; i++)\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 137,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 i = 0; i < owners.length; i++)\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 230,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 i = 0; i < owners.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 263,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 i = 0; i < owners.length; i++) if (confirmations[transactionId][owners[i]]) count += 1;\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 271,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 i = 0; i < transactionCount; i++) if ((pending && !transactions[i].executed) || (executed && transactions[i].executed)) count += 1;\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 287,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (i = 0; i < owners.length; i++)\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 293,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (i = 0; i < count; i++) _confirmations[i] = confirmationsTemp[i];\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 312,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (i = from; i < to; i++)\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 318,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (i = 0; i < count; i++) _transactionIds[i] = transactionIdsTemp[i];\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 308,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(to > from && transactionCount >= to, \"MultiSigWallet: function input `to` or `from` is not valid\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        }
      ]
    },
    "slither": {
      "successfull_analysis": true,
      "errors": [
        "EXIT_CODE_19"
      ],
      "vulnerability_findings": [
        {
          "name": "locked-ether",
          "vulnerability_from_line": 92,
          "vulnerability_to_line": 94,
          "vulnerability_code": "    fallback() external payable {\n\n        if (msg.value > 0) emit Deposit(msg.sender, msg.value);\n",
          "message": "Contract locking ether found in MultiSigWallet.sol:\n\tContract MultiSigWallet has payable functions:\n\t - fallback (MultiSigWallet.sol#92-94)\n\tBut does not have a function to withdraw the ether\n"
        },
        {
          "name": "unused-return",
          "vulnerability_from_line": 121,
          "vulnerability_to_line": 131,
          "vulnerability_code": "    function removeOwner(address owner) public onlyWallet ownerExists(owner) {\n\n        isOwner[owner] = false;\n\n        for (uint256 i = 0; i < owners.length - 1; i++)\n\n            if (owners[i] == owner) {\n\n                owners[i] = owners[owners.length - 1];\n\n                break;\n\n            }\n\n        owners.pop();\n\n        if (required > owners.length) changeRequirement(owners.length);\n\n        emit OwnerRemoval(owner);\n",
          "message": "MultiSigWallet.removeOwner (MultiSigWallet.sol#121-131) does not use the value returned by external calls:\n\t-owners.pop() (MultiSigWallet.sol#128)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 121,
          "vulnerability_to_line": 131,
          "vulnerability_code": "    function removeOwner(address owner) public onlyWallet ownerExists(owner) {\n\n        isOwner[owner] = false;\n\n        for (uint256 i = 0; i < owners.length - 1; i++)\n\n            if (owners[i] == owner) {\n\n                owners[i] = owners[owners.length - 1];\n\n                break;\n\n            }\n\n        owners.pop();\n\n        if (required > owners.length) changeRequirement(owners.length);\n\n        emit OwnerRemoval(owner);\n",
          "message": "Reentrancy in MultiSigWallet.removeOwner (MultiSigWallet.sol#121-131):\n\tExternal calls:\n\t- owners.pop() (MultiSigWallet.sol#128)\n\tState variables written after the call(s):\n\t- required (MultiSigWallet.sol#129)\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 200,
          "vulnerability_to_line": 223,
          "vulnerability_code": "    function external_call(\n\n        address destination,\n\n        uint256 value,\n\n        uint256 dataLength,\n\n        bytes memory data\n\n    ) internal returns (bool) {\n\n        bool result;\n\n        assembly {\n\n            let x := mload(0x40) // \"Allocate\" memory for output (0x40 is where \"free memory\" pointer is stored by convention)\n\n            let d := add(data, 32) // First 32 bytes are the padded length of data, so exclude that\n\n            result := call(\n\n                sub(gas(), 34710), // 34710 is the value that solidity is currently emitting\n\n                // It includes callGas (700) + callVeryLow (3, to pay for SUB) + callValueTransferGas (9000) +\n\n                // callNewAccountGas (25000, in case the destination address does not exist and needs creating)\n\n                destination,\n\n                value,\n\n                d,\n\n                dataLength, // Size of the input (in bytes) - this is what fixes the padding problem\n\n                x,\n\n                0 // Output is ignored, therefore the output size is zero\n\n            )\n\n        }\n\n        return result;\n",
          "message": "MultiSigWallet.external_call uses assembly (MultiSigWallet.sol#200-223)\n\t- MultiSigWallet.sol#207-221\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 113,
          "vulnerability_to_line": 117,
          "vulnerability_code": "    function addOwner(address owner) public onlyWallet ownerDoesNotExist(owner) notNull(owner) validRequirement(owners.length + 1, required) {\n\n        isOwner[owner] = true;\n\n        owners.push(owner);\n\n        emit OwnerAddition(owner);\n",
          "message": "MultiSigWallet.addOwner (MultiSigWallet.sol#113-117) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 121,
          "vulnerability_to_line": 131,
          "vulnerability_code": "    function removeOwner(address owner) public onlyWallet ownerExists(owner) {\n\n        isOwner[owner] = false;\n\n        for (uint256 i = 0; i < owners.length - 1; i++)\n\n            if (owners[i] == owner) {\n\n                owners[i] = owners[owners.length - 1];\n\n                break;\n\n            }\n\n        owners.pop();\n\n        if (required > owners.length) changeRequirement(owners.length);\n\n        emit OwnerRemoval(owner);\n",
          "message": "MultiSigWallet.removeOwner (MultiSigWallet.sol#121-131) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 136,
          "vulnerability_to_line": 146,
          "vulnerability_code": "    function replaceOwner(address owner, address newOwner) public onlyWallet ownerExists(owner) ownerDoesNotExist(newOwner) {\n\n        for (uint256 i = 0; i < owners.length; i++)\n\n            if (owners[i] == owner) {\n\n                owners[i] = newOwner;\n\n                break;\n\n            }\n\n        isOwner[owner] = false;\n\n        isOwner[newOwner] = true;\n\n        emit OwnerRemoval(owner);\n\n        emit OwnerAddition(newOwner);\n",
          "message": "MultiSigWallet.replaceOwner (MultiSigWallet.sol#136-146) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 160,
          "vulnerability_to_line": 167,
          "vulnerability_code": "    function submitTransaction(\n\n        address destination,\n\n        uint256 value,\n\n        bytes memory data\n\n    ) public returns (uint256 transactionId) {\n\n        transactionId = addTransaction(destination, value, data);\n\n        confirmTransaction(transactionId);\n",
          "message": "MultiSigWallet.submitTransaction (MultiSigWallet.sol#160-167) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 179,
          "vulnerability_to_line": 182,
          "vulnerability_code": "    function revokeConfirmation(uint256 transactionId) public ownerExists(msg.sender) confirmed(transactionId, msg.sender) notExecuted(transactionId) {\n\n        confirmations[transactionId][msg.sender] = false;\n\n        emit Revocation(msg.sender, transactionId);\n",
          "message": "MultiSigWallet.revokeConfirmation (MultiSigWallet.sol#179-182) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 262,
          "vulnerability_to_line": 264,
          "vulnerability_code": "    function getConfirmationCount(uint256 transactionId) public view returns (uint256 count) {\n\n        for (uint256 i = 0; i < owners.length; i++) if (confirmations[transactionId][owners[i]]) count += 1;\n",
          "message": "MultiSigWallet.getConfirmationCount (MultiSigWallet.sol#262-264) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 270,
          "vulnerability_to_line": 272,
          "vulnerability_code": "    function getTransactionCount(bool pending, bool executed) public view returns (uint256 count) {\n\n        for (uint256 i = 0; i < transactionCount; i++) if ((pending && !transactions[i].executed) || (executed && transactions[i].executed)) count += 1;\n",
          "message": "MultiSigWallet.getTransactionCount (MultiSigWallet.sol#270-272) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 276,
          "vulnerability_to_line": 278,
          "vulnerability_code": "    function getOwners() public view returns (address[] memory) {\n\n        return owners;\n",
          "message": "MultiSigWallet.getOwners (MultiSigWallet.sol#276-278) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 283,
          "vulnerability_to_line": 294,
          "vulnerability_code": "    function getConfirmations(uint256 transactionId) public view returns (address[] memory _confirmations) {\n\n        address[] memory confirmationsTemp = new address[](owners.length);\n\n        uint256 count = 0;\n\n        uint256 i;\n\n        for (i = 0; i < owners.length; i++)\n\n            if (confirmations[transactionId][owners[i]]) {\n\n                confirmationsTemp[count] = owners[i];\n\n                count += 1;\n\n            }\n\n        _confirmations = new address[](count);\n\n        for (i = 0; i < count; i++) _confirmations[i] = confirmationsTemp[i];\n",
          "message": "MultiSigWallet.getConfirmations (MultiSigWallet.sol#283-294) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 302,
          "vulnerability_to_line": 319,
          "vulnerability_code": "    function getTransactionIds(\n\n        uint256 from,\n\n        uint256 to,\n\n        bool pending,\n\n        bool executed\n\n    ) public view returns (uint256[] memory _transactionIds) {\n\n        require(to > from && transactionCount >= to, \"MultiSigWallet: function input `to` or `from` is not valid\");\n\n        uint256[] memory transactionIdsTemp = new uint256[](to - from);\n\n        uint256 count = 0;\n\n        uint256 i;\n\n        for (i = from; i < to; i++)\n\n            if ((pending && !transactions[i].executed) || (executed && transactions[i].executed)) {\n\n                transactionIdsTemp[count] = i;\n\n                count += 1;\n\n            }\n\n        _transactionIds = new uint256[](count);\n\n        for (i = 0; i < count; i++) _transactionIds[i] = transactionIdsTemp[i];\n",
          "message": "MultiSigWallet.getTransactionIds (MultiSigWallet.sol#302-319) should be declared external\n"
        },
        {
          "name": "solc-version",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity 0.6.12;\n",
          "message": "Detected issues with version pragma in MultiSigWallet.sol:\n\t- pragma solidity0.6.12 (MultiSigWallet.sol#3): it allows old versions\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 102,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor(address[] memory _owners, uint256 _required) public validRequirement(_owners.length, _required) {\n",
          "message": "Parameter '_owners' of MultiSigWallet. (MultiSigWallet.sol#102) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 102,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor(address[] memory _owners, uint256 _required) public validRequirement(_owners.length, _required) {\n",
          "message": "Parameter '_required' of MultiSigWallet. (MultiSigWallet.sol#102) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 150,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function changeRequirement(uint256 _required) public onlyWallet validRequirement(owners.length, _required) {\n",
          "message": "Parameter '_required' of MultiSigWallet.changeRequirement (MultiSigWallet.sol#150) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 200,
          "vulnerability_to_line": 223,
          "vulnerability_code": "    function external_call(\n\n        address destination,\n\n        uint256 value,\n\n        uint256 dataLength,\n\n        bytes memory data\n\n    ) internal returns (bool) {\n\n        bool result;\n\n        assembly {\n\n            let x := mload(0x40) // \"Allocate\" memory for output (0x40 is where \"free memory\" pointer is stored by convention)\n\n            let d := add(data, 32) // First 32 bytes are the padded length of data, so exclude that\n\n            result := call(\n\n                sub(gas(), 34710), // 34710 is the value that solidity is currently emitting\n\n                // It includes callGas (700) + callVeryLow (3, to pay for SUB) + callValueTransferGas (9000) +\n\n                // callNewAccountGas (25000, in case the destination address does not exist and needs creating)\n\n                destination,\n\n                value,\n\n                d,\n\n                dataLength, // Size of the input (in bytes) - this is what fixes the padding problem\n\n                x,\n\n                0 // Output is ignored, therefore the output size is zero\n\n            )\n\n        }\n\n        return result;\n",
          "message": "Function 'MultiSigWallet.external_call' (MultiSigWallet.sol#200-223) is not in mixedCase\n"
        }
      ]
    },
    "smartcheck": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 92,
          "vulnerability_to_line": null,
          "vulnerability_code": "    fallback() external payable {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 93,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (msg.value > 0) emit Deposit(msg.sender, msg.value);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 93,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (msg.value > 0) emit Deposit(msg.sender, msg.value);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 93,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (msg.value > 0) emit Deposit(msg.sender, msg.value);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 93,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (msg.value > 0) emit Deposit(msg.sender, msg.value);\n",
          "message": null
        }
      ]
    },
    "oyente": {
      "successfull_analysis": false,
      "errors": [
        "exception (RuntimeError: Source map error, unknown name(SHR) or instr_name(INVALID))"
      ],
      "vulnerability_findings": []
    },
    "mythril": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": []
    },
    "osiris": {
      "successfull_analysis": false,
      "errors": [
        "Solidity compilation failed"
      ],
      "vulnerability_findings": []
    }
  }
}