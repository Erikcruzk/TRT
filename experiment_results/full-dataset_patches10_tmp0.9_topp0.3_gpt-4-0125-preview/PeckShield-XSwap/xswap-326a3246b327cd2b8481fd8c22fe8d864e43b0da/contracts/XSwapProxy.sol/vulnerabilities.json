{
  "smartbugs_completed": true,
  "analyzer_results": {
    "semgrep": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 344,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor(address _implementation, bytes memory _data) public AdminUpgradeabilityProxy(_implementation, msg.sender, _data) {\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 345,
          "vulnerability_to_line": null,
          "vulnerability_code": "    }\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 155,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require(OpenZeppelinUpgradesAddress.isContract(newImplementation), \"Cannot set a proxy implementation to a non-contract address\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 254,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require(newAdmin != address(0), \"Cannot change the admin of a proxy to the zero address\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 309,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require(msg.sender != _admin(), \"Cannot call fallback function from the proxy admin\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 155,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require(OpenZeppelinUpgradesAddress.isContract(newImplementation), \"Cannot set a proxy implementation to a non-contract address\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 254,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require(newAdmin != address(0), \"Cannot change the admin of a proxy to the zero address\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 309,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require(msg.sender != _admin(), \"Cannot call fallback function from the proxy admin\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        }
      ]
    },
    "slither": {
      "successfull_analysis": true,
      "errors": [
        "EXIT_CODE_30"
      ],
      "vulnerability_findings": [
        {
          "name": "controlled-delegatecall",
          "vulnerability_from_line": 183,
          "vulnerability_to_line": 190,
          "vulnerability_code": "  constructor(address _logic, bytes memory _data) public payable {\n\n    assert(IMPLEMENTATION_SLOT == bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1));\n\n    _setImplementation(_logic);\n\n    if(_data.length > 0) {\n\n      (bool success,) = _logic.delegatecall(_data);\n\n      require(success);\n\n    }\n",
          "message": "UpgradeabilityProxy.constructor (XSwapProxy.sol#183-190) uses delegatecall to a input-controlled function id\n\t(success) = _logic.delegatecall(_data) (XSwapProxy.sol#187)\n"
        },
        {
          "name": "controlled-delegatecall",
          "vulnerability_from_line": 277,
          "vulnerability_to_line": 281,
          "vulnerability_code": "  function upgradeToAndCall(address newImplementation, bytes calldata data) payable external ifAdmin {\n\n    _upgradeTo(newImplementation);\n\n    (bool success,) = newImplementation.delegatecall(data);\n\n    require(success);\n",
          "message": "BaseAdminUpgradeabilityProxy.upgradeToAndCall (XSwapProxy.sol#277-281) uses delegatecall to a input-controlled function id\n\t(success) = newImplementation.delegatecall(data) (XSwapProxy.sol#279)\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 91,
          "vulnerability_to_line": 102,
          "vulnerability_code": "    function isContract(address account) internal view returns (bool) {\n\n        uint256 size;\n\n        // XXX Currently there is no better way to check if there is a contract in an address\n\n        // than to check the size of the code at that address.\n\n        // See https://ethereum.stackexchange.com/a/14016/36603\n\n        // for more details about how this works.\n\n        // TODO Check this again before the Serenity release, because all addresses will be\n\n        // contracts then.\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly { size := extcodesize(account) }\n\n        return size > 0;\n",
          "message": "OpenZeppelinUpgradesAddress.isContract (XSwapProxy.sol#91-102) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 134,
          "vulnerability_to_line": 139,
          "vulnerability_code": "  function _implementation() internal view returns (address impl) {\n\n    bytes32 slot = IMPLEMENTATION_SLOT;\n\n    assembly {\n\n      impl := sload(slot)\n\n    }\n",
          "message": "BaseUpgradeabilityProxy._implementation (XSwapProxy.sol#134-139) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 286,
          "vulnerability_to_line": 291,
          "vulnerability_code": "  function _admin() internal view returns (address adm) {\n\n    bytes32 slot = ADMIN_SLOT;\n\n    assembly {\n\n      adm := sload(slot)\n\n    }\n",
          "message": "BaseAdminUpgradeabilityProxy._admin (XSwapProxy.sol#286-291) is declared view but contains assembly code\n"
        },
        {
          "name": "shadowing-local",
          "vulnerability_from_line": 333,
          "vulnerability_to_line": null,
          "vulnerability_code": "  constructor(address _logic, address _admin, bytes memory _data) UpgradeabilityProxy(_logic, _data) public payable {\n",
          "message": "AdminUpgradeabilityProxy.constructor._admin (local variable @ XSwapProxy.sol#333) shadows:\n\t- BaseAdminUpgradeabilityProxy._admin (function @ XSwapProxy.sol#286-291)\n"
        },
        {
          "name": "shadowing-local",
          "vulnerability_from_line": 344,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor(address _implementation, bytes memory _data) public AdminUpgradeabilityProxy(_implementation, msg.sender, _data) {\n",
          "message": "XSwapProxy.constructor._implementation (local variable @ XSwapProxy.sol#344) shadows:\n\t- BaseUpgradeabilityProxy._implementation (function @ XSwapProxy.sol#134-139)\n\t- Proxy._implementation (function @ XSwapProxy.sol#24)\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 32,
          "vulnerability_to_line": 51,
          "vulnerability_code": "  function _delegate(address implementation) internal {\n\n    assembly {\n\n      // Copy msg.data. We take full control of memory in this inline assembly\n\n      // block because it will not return to Solidity code. We overwrite the\n\n      // Solidity scratch pad at memory position 0.\n\n      calldatacopy(0, 0, calldatasize)\n\n\n\n      // Call the implementation.\n\n      // out and outsize are 0 because we don't know the size yet.\n\n      let result := delegatecall(gas, implementation, 0, calldatasize, 0, 0)\n\n\n\n      // Copy the returned data.\n\n      returndatacopy(0, 0, returndatasize)\n\n\n\n      switch result\n\n      // delegatecall returns 0 on error.\n\n      case 0 { revert(0, returndatasize) }\n\n      default { return(0, returndatasize) }\n\n    }\n",
          "message": "Proxy._delegate uses assembly (XSwapProxy.sol#32-51)\n\t- XSwapProxy.sol#33-50\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 91,
          "vulnerability_to_line": 102,
          "vulnerability_code": "    function isContract(address account) internal view returns (bool) {\n\n        uint256 size;\n\n        // XXX Currently there is no better way to check if there is a contract in an address\n\n        // than to check the size of the code at that address.\n\n        // See https://ethereum.stackexchange.com/a/14016/36603\n\n        // for more details about how this works.\n\n        // TODO Check this again before the Serenity release, because all addresses will be\n\n        // contracts then.\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly { size := extcodesize(account) }\n\n        return size > 0;\n",
          "message": "OpenZeppelinUpgradesAddress.isContract uses assembly (XSwapProxy.sol#91-102)\n\t- XSwapProxy.sol#100\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 134,
          "vulnerability_to_line": 139,
          "vulnerability_code": "  function _implementation() internal view returns (address impl) {\n\n    bytes32 slot = IMPLEMENTATION_SLOT;\n\n    assembly {\n\n      impl := sload(slot)\n\n    }\n",
          "message": "BaseUpgradeabilityProxy._implementation uses assembly (XSwapProxy.sol#134-139)\n\t- XSwapProxy.sol#136-138\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 154,
          "vulnerability_to_line": 162,
          "vulnerability_code": "  function _setImplementation(address newImplementation) internal {\n\n    require(OpenZeppelinUpgradesAddress.isContract(newImplementation), \"Cannot set a proxy implementation to a non-contract address\");\n\n\n\n    bytes32 slot = IMPLEMENTATION_SLOT;\n\n\n\n    assembly {\n\n      sstore(slot, newImplementation)\n\n    }\n",
          "message": "BaseUpgradeabilityProxy._setImplementation uses assembly (XSwapProxy.sol#154-162)\n\t- XSwapProxy.sol#159-161\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 286,
          "vulnerability_to_line": 291,
          "vulnerability_code": "  function _admin() internal view returns (address adm) {\n\n    bytes32 slot = ADMIN_SLOT;\n\n    assembly {\n\n      adm := sload(slot)\n\n    }\n",
          "message": "BaseAdminUpgradeabilityProxy._admin uses assembly (XSwapProxy.sol#286-291)\n\t- XSwapProxy.sol#288-290\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 297,
          "vulnerability_to_line": 303,
          "vulnerability_code": "  function _setAdmin(address newAdmin) internal {\n\n    bytes32 slot = ADMIN_SLOT;\n\n\n\n    assembly {\n\n      sstore(slot, newAdmin)\n\n    }\n",
          "message": "BaseAdminUpgradeabilityProxy._setAdmin uses assembly (XSwapProxy.sol#297-303)\n\t- XSwapProxy.sol#300-302\n"
        },
        {
          "name": "pragma",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.4;\n",
          "message": "Different versions of Solidity is used in XSwapProxy.sol:\n\t- Version used: ['^0.5.0', '^0.5.4']\n\t- XSwapProxy.sol#3 declares pragma solidity^0.5.4\n\t- XSwapProxy.sol#73 declares pragma solidity^0.5.0\n\t- XSwapProxy.sol#107 declares pragma solidity^0.5.4\n\t- XSwapProxy.sol#167 declares pragma solidity^0.5.4\n\t- XSwapProxy.sol#195 declares pragma solidity^0.5.4\n\t- XSwapProxy.sol#316 declares pragma solidity^0.5.4\n\t- XSwapProxy.sol#341 declares pragma solidity^0.5.4\n"
        },
        {
          "name": "solc-version",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.4;\n",
          "message": "Detected issues with version pragma in XSwapProxy.sol:\n\t- pragma solidity^0.5.4 (XSwapProxy.sol#3): it allows old versions\n\t- pragma solidity^0.5.0 (XSwapProxy.sol#73): it allows old versions\n\t- pragma solidity^0.5.4 (XSwapProxy.sol#107): it allows old versions\n\t- pragma solidity^0.5.4 (XSwapProxy.sol#167): it allows old versions\n\t- pragma solidity^0.5.4 (XSwapProxy.sol#195): it allows old versions\n\t- pragma solidity^0.5.4 (XSwapProxy.sol#316): it allows old versions\n\t- pragma solidity^0.5.4 (XSwapProxy.sol#341): it allows old versions\n"
        },
        {
          "name": "low-level-calls",
          "vulnerability_from_line": 183,
          "vulnerability_to_line": 190,
          "vulnerability_code": "  constructor(address _logic, bytes memory _data) public payable {\n\n    assert(IMPLEMENTATION_SLOT == bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1));\n\n    _setImplementation(_logic);\n\n    if(_data.length > 0) {\n\n      (bool success,) = _logic.delegatecall(_data);\n\n      require(success);\n\n    }\n",
          "message": "Low level call in UpgradeabilityProxy.constructor (XSwapProxy.sol#183-190):\n\t-(success) = _logic.delegatecall(_data) XSwapProxy.sol#187\n"
        },
        {
          "name": "low-level-calls",
          "vulnerability_from_line": 277,
          "vulnerability_to_line": 281,
          "vulnerability_code": "  function upgradeToAndCall(address newImplementation, bytes calldata data) payable external ifAdmin {\n\n    _upgradeTo(newImplementation);\n\n    (bool success,) = newImplementation.delegatecall(data);\n\n    require(success);\n",
          "message": "Low level call in BaseAdminUpgradeabilityProxy.upgradeToAndCall (XSwapProxy.sol#277-281):\n\t-(success) = newImplementation.delegatecall(data) XSwapProxy.sol#279\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 24,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function _implementation() internal view returns (address);\n",
          "message": "Function 'Proxy._implementation' (XSwapProxy.sol#24) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 32,
          "vulnerability_to_line": 51,
          "vulnerability_code": "  function _delegate(address implementation) internal {\n\n    assembly {\n\n      // Copy msg.data. We take full control of memory in this inline assembly\n\n      // block because it will not return to Solidity code. We overwrite the\n\n      // Solidity scratch pad at memory position 0.\n\n      calldatacopy(0, 0, calldatasize)\n\n\n\n      // Call the implementation.\n\n      // out and outsize are 0 because we don't know the size yet.\n\n      let result := delegatecall(gas, implementation, 0, calldatasize, 0, 0)\n\n\n\n      // Copy the returned data.\n\n      returndatacopy(0, 0, returndatasize)\n\n\n\n      switch result\n\n      // delegatecall returns 0 on error.\n\n      case 0 { revert(0, returndatasize) }\n\n      default { return(0, returndatasize) }\n\n    }\n",
          "message": "Function 'Proxy._delegate' (XSwapProxy.sol#32-51) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 58,
          "vulnerability_to_line": 59,
          "vulnerability_code": "  function _willFallback() internal {\n",
          "message": "Function 'Proxy._willFallback' (XSwapProxy.sol#58-59) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 65,
          "vulnerability_to_line": 68,
          "vulnerability_code": "  function _fallback() internal {\n\n    _willFallback();\n\n    _delegate(_implementation());\n",
          "message": "Function 'Proxy._fallback' (XSwapProxy.sol#65-68) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 134,
          "vulnerability_to_line": 139,
          "vulnerability_code": "  function _implementation() internal view returns (address impl) {\n\n    bytes32 slot = IMPLEMENTATION_SLOT;\n\n    assembly {\n\n      impl := sload(slot)\n\n    }\n",
          "message": "Function 'BaseUpgradeabilityProxy._implementation' (XSwapProxy.sol#134-139) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 145,
          "vulnerability_to_line": 148,
          "vulnerability_code": "  function _upgradeTo(address newImplementation) internal {\n\n    _setImplementation(newImplementation);\n\n    emit Upgraded(newImplementation);\n",
          "message": "Function 'BaseUpgradeabilityProxy._upgradeTo' (XSwapProxy.sol#145-148) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 154,
          "vulnerability_to_line": 162,
          "vulnerability_code": "  function _setImplementation(address newImplementation) internal {\n\n    require(OpenZeppelinUpgradesAddress.isContract(newImplementation), \"Cannot set a proxy implementation to a non-contract address\");\n\n\n\n    bytes32 slot = IMPLEMENTATION_SLOT;\n\n\n\n    assembly {\n\n      sstore(slot, newImplementation)\n\n    }\n",
          "message": "Function 'BaseUpgradeabilityProxy._setImplementation' (XSwapProxy.sol#154-162) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 183,
          "vulnerability_to_line": null,
          "vulnerability_code": "  constructor(address _logic, bytes memory _data) public payable {\n",
          "message": "Parameter '_logic' of UpgradeabilityProxy. (XSwapProxy.sol#183) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 183,
          "vulnerability_to_line": null,
          "vulnerability_code": "  constructor(address _logic, bytes memory _data) public payable {\n",
          "message": "Parameter '_data' of UpgradeabilityProxy. (XSwapProxy.sol#183) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 308,
          "vulnerability_to_line": 311,
          "vulnerability_code": "  function _willFallback() internal {\n\n    require(msg.sender != _admin(), \"Cannot call fallback function from the proxy admin\");\n\n    super._willFallback();\n",
          "message": "Function 'BaseAdminUpgradeabilityProxy._willFallback' (XSwapProxy.sol#308-311) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 286,
          "vulnerability_to_line": 291,
          "vulnerability_code": "  function _admin() internal view returns (address adm) {\n\n    bytes32 slot = ADMIN_SLOT;\n\n    assembly {\n\n      adm := sload(slot)\n\n    }\n",
          "message": "Function 'BaseAdminUpgradeabilityProxy._admin' (XSwapProxy.sol#286-291) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 297,
          "vulnerability_to_line": 303,
          "vulnerability_code": "  function _setAdmin(address newAdmin) internal {\n\n    bytes32 slot = ADMIN_SLOT;\n\n\n\n    assembly {\n\n      sstore(slot, newAdmin)\n\n    }\n",
          "message": "Function 'BaseAdminUpgradeabilityProxy._setAdmin' (XSwapProxy.sol#297-303) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 333,
          "vulnerability_to_line": null,
          "vulnerability_code": "  constructor(address _logic, address _admin, bytes memory _data) UpgradeabilityProxy(_logic, _data) public payable {\n",
          "message": "Parameter '_admin' of AdminUpgradeabilityProxy. (XSwapProxy.sol#333) is not in mixedCase\n"
        }
      ]
    },
    "smartcheck": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
          "vulnerability_from_line": 134,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function _implementation() internal view returns (address impl) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
          "vulnerability_from_line": 286,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function _admin() internal view returns (address adm) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_LOCKED_MONEY",
          "vulnerability_from_line": 12,
          "vulnerability_to_line": null,
          "vulnerability_code": "contract Proxy {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_LOCKED_MONEY",
          "vulnerability_from_line": 174,
          "vulnerability_to_line": null,
          "vulnerability_code": "contract UpgradeabilityProxy is BaseUpgradeabilityProxy {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_LOCKED_MONEY",
          "vulnerability_from_line": 205,
          "vulnerability_to_line": null,
          "vulnerability_code": "contract BaseAdminUpgradeabilityProxy is BaseUpgradeabilityProxy {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_LOCKED_MONEY",
          "vulnerability_from_line": 323,
          "vulnerability_to_line": null,
          "vulnerability_code": "contract AdminUpgradeabilityProxy is BaseAdminUpgradeabilityProxy, UpgradeabilityProxy {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.4;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 73,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 107,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.4;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 167,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.4;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 195,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.4;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 316,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.4;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 341,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.4;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
          "vulnerability_from_line": 91,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function isContract(address account) internal view returns (bool) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
          "vulnerability_from_line": 134,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function _implementation() internal view returns (address impl) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
          "vulnerability_from_line": 286,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function _admin() internal view returns (address adm) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UNCHECKED_CALL",
          "vulnerability_from_line": 279,
          "vulnerability_to_line": null,
          "vulnerability_code": "    (bool success,) = newImplementation.delegatecall(data);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 33,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 136,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 159,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 288,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 300,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly {\n",
          "message": null
        }
      ]
    },
    "oyente": {
      "successfull_analysis": false,
      "errors": [
        "exception (RuntimeError: Source map error, unknown name(SHR) or instr_name(INVALID))"
      ],
      "vulnerability_findings": []
    },
    "mythril": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "Delegatecall to user-supplied address (SWC 112)",
          "vulnerability_from_line": 279,
          "vulnerability_to_line": null,
          "vulnerability_code": "    (bool success,) = newImplementation.delegatecall(data);\n",
          "message": "The contract delegates execution to another contract with a user-supplied address.\nThe smart contract delegates execution to a user-supplied address.This could allow an attacker to execute arbitrary code in the context of this contract account and manipulate the state of the contract account or execute actions on its behalf.\nClassification: SWC-112"
        },
        {
          "name": "Delegatecall to user-supplied address (SWC 112)",
          "vulnerability_from_line": 41,
          "vulnerability_to_line": null,
          "vulnerability_code": "      let result := delegatecall(gas, implementation, 0, calldatasize, 0, 0)\n",
          "message": "The contract delegates execution to another contract with a user-supplied address.\nThe smart contract delegates execution to a user-supplied address.This could allow an attacker to execute arbitrary code in the context of this contract account and manipulate the state of the contract account or execute actions on its behalf.\nClassification: SWC-112"
        },
        {
          "name": "Delegatecall to user-supplied address (SWC 112)",
          "vulnerability_from_line": 41,
          "vulnerability_to_line": null,
          "vulnerability_code": "      let result := delegatecall(gas, implementation, 0, calldatasize, 0, 0)\n",
          "message": "The contract delegates execution to another contract with a user-supplied address.\nThe smart contract delegates execution to a user-supplied address.This could allow an attacker to execute arbitrary code in the context of this contract account and manipulate the state of the contract account or execute actions on its behalf.\nClassification: SWC-112"
        }
      ]
    },
    "osiris": {
      "successfull_analysis": false,
      "errors": [
        "Solidity compilation failed"
      ],
      "vulnerability_findings": []
    }
  }
}