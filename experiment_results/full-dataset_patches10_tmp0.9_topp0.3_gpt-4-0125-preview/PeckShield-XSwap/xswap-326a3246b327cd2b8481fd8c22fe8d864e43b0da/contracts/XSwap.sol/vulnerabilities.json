{
  "smartbugs_completed": true,
  "analyzer_results": {
    "semgrep": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 35,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor() public {\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 36,
          "vulnerability_to_line": null,
          "vulnerability_code": "        owner = msg.sender;\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 37,
          "vulnerability_to_line": null,
          "vulnerability_code": "        emit LogSetOwner(msg.sender);\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 38,
          "vulnerability_to_line": null,
          "vulnerability_code": "    }\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 178,
          "vulnerability_to_line": null,
          "vulnerability_code": "\tconstructor() public {\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 179,
          "vulnerability_to_line": null,
          "vulnerability_code": "\t}\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 47,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(newOwner_ != owner, \"TransferOwnership: the same owner.\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 52,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == newOwner, \"AcceptOwnership: only new owner do this.\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 68,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(isOwner(msg.sender), \"ds-auth-non-owner\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 77,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(isAuthorized(msg.sender, msg.sig), \"ds-auth-unauthorized\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 144,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require((z = x + y) >= x, \"ds-math-add-overflow\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 147,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require((z = x - y) <= x, \"ds-math-sub-underflow\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 150,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(y == 0 || (z = x * y) / y == x, \"ds-math-mul-overflow\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 153,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(y > 0, \"ds-math-div-overflow\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 182,
          "vulnerability_to_line": null,
          "vulnerability_code": "\t\trequire(actived == false, \"already actived.\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 195,
          "vulnerability_to_line": null,
          "vulnerability_code": "\t\trequire(isOpen, \"not open\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 196,
          "vulnerability_to_line": null,
          "vulnerability_code": "\t\trequire(prices[_input][_output] != 0, \"invalid token address\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 197,
          "vulnerability_to_line": null,
          "vulnerability_code": "\t\trequire(decimals[_input] != 0, \"input decimal not setteled\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 198,
          "vulnerability_to_line": null,
          "vulnerability_code": "\t\trequire(decimals[_output] != 0, \"output decimal not setteled\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 236,
          "vulnerability_to_line": null,
          "vulnerability_code": "\t\trequire(!supportLending[_token], \"the token is already supported lending\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 260,
          "vulnerability_to_line": null,
          "vulnerability_code": "\t\trequire(supportLending[_token], \"the token doesnt support lending\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 298,
          "vulnerability_to_line": null,
          "vulnerability_code": "\t\trequire(_decimals <= 18, \"not supported decimal\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 47,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(newOwner_ != owner, \"TransferOwnership: the same owner.\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 52,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == newOwner, \"AcceptOwnership: only new owner do this.\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 236,
          "vulnerability_to_line": null,
          "vulnerability_code": "\t\trequire(!supportLending[_token], \"the token is already supported lending\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        }
      ]
    },
    "slither": {
      "successfull_analysis": true,
      "errors": [
        "EXIT_CODE_64"
      ],
      "vulnerability_findings": [
        {
          "name": "erc20-interface",
          "vulnerability_from_line": 107,
          "vulnerability_to_line": 113,
          "vulnerability_code": "interface NonStandardIERC20Token {\n\n    function balanceOf(address _owner) external view returns (uint);\n\n    function allowance(address _owner, address _spender) external view returns (uint);\n\n    function transfer(address _to, uint _value) external;\n\n    function transferFrom(address _from, address _to, uint _value) external;\n\n    function approve(address _spender, uint _value) external;\n",
          "message": "NonStandardIERC20Token (XSwap.sol#107-113) has incorrect ERC20 function interface(s):\n\t-transfer (XSwap.sol#110)\n\t-transferFrom (XSwap.sol#111)\n\t-approve (XSwap.sol#112)\n"
        },
        {
          "name": "unused-return",
          "vulnerability_from_line": 194,
          "vulnerability_to_line": 223,
          "vulnerability_code": "\tfunction trade(address _input, address _output, uint256 _inputAmount, address _receiver) public returns (bool) {\n\n\t\trequire(isOpen, \"not open\");\n\n\t\trequire(prices[_input][_output] != 0, \"invalid token address\");\n\n\t\trequire(decimals[_input] != 0, \"input decimal not setteled\");\n\n\t\trequire(decimals[_output] != 0, \"output decimal not setteled\");\n\n\n\n\t\tNonStandardIERC20Token(_input).transferFrom(msg.sender, address(this), _inputAmount);\n\n\t\tif(supportLending[_input]) {\n\n\t\t\tif (_input == dai) {\n\n\t\t\t\tIChai(chai).join(address(this), _inputAmount);\n\n\t\t\t\tILendFMe(lendFMe).supply(chai, IERC20Token(chai).balanceOf(address(this)));\n\n\t\t\t}\n\n\t\t\telse\n\n\t\t\t\tILendFMe(lendFMe).supply(_input, _inputAmount);\n\n\t\t}\n\n\t\tuint256 _tokenAmount = normalizeToken(_input, _inputAmount).mul(prices[_input][_output]).div(OFFSET);\n\n\t\tuint256 _fee = _tokenAmount.mul(fee[_input][_output]).div(OFFSET);\n\n\t\tuint256 _amountToUser = _tokenAmount.sub(_fee);\n\n\n\n\t\tif(supportLending[_output]) {\n\n\t\t\tif (_output == dai) {\n\n\t\t\t\tILendFMe(lendFMe).withdraw(chai, _amountToUser); //assume chai / dai >= 1;\n\n\t\t\t\tIChai(chai).draw(address(this), _amountToUser);\n\n\t\t\t}\n\n\t\t\telse\n\n\t\t\t\tILendFMe(lendFMe).withdraw(_output, denormalizedToken(_output, _amountToUser));\n\n\t\t}\n\n\t\tNonStandardIERC20Token(_output).transfer(_receiver, denormalizedToken(_output, _amountToUser));\n\n\t\treturn true;\n",
          "message": "XSwap.trade (XSwap.sol#194-223) does not use the value returned by external calls:\n\t-ILendFMe(lendFMe).supply(chai,IERC20Token(chai).balanceOf(address(this))) (XSwap.sol#204)\n\t-ILendFMe(lendFMe).supply(_input,_inputAmount) (XSwap.sol#207)\n\t-ILendFMe(lendFMe).withdraw(chai,_amountToUser) (XSwap.sol#215)\n\t-ILendFMe(lendFMe).withdraw(_output,denormalizedToken(_output,_amountToUser)) (XSwap.sol#219)\n"
        },
        {
          "name": "unused-return",
          "vulnerability_from_line": 235,
          "vulnerability_to_line": 257,
          "vulnerability_code": "\tfunction enableLending(address _token) public auth returns (bool) {\n\n\t\trequire(!supportLending[_token], \"the token is already supported lending\");\n\n\t\tsupportLending[_token] = true;\n\n\n\n\t\tif (_token == dai) {\n\n\t\t\tIERC20Token(_token).approve(chai, uint256(-1));\n\n\t\t\tIERC20Token(chai).approve(lendFMe, uint256(-1));\n\n\t\t}\n\n\t\telse {\n\n\t\t\tNonStandardIERC20Token(_token).approve(lendFMe, uint256(-1));\n\n\t\t}\n\n\n\n\t\tuint256 _balance = NonStandardIERC20Token(_token).balanceOf(address(this));\n\n\t\tif(_balance > 0) {\n\n\t\t\tif (_token == dai) {\n\n\t\t\t\tIChai(chai).join(address(this), _balance);\n\n\t\t\t\tILendFMe(lendFMe).supply(chai, IERC20Token(chai).balanceOf(address(this)));\n\n\t\t\t}\n\n\t\t\telse\n\n\t\t\t\tILendFMe(lendFMe).supply(_token, _balance);\n\n\t\t}\n\n\t\treturn true;\n",
          "message": "XSwap.enableLending (XSwap.sol#235-257) does not use the value returned by external calls:\n\t-IERC20Token(_token).approve(chai,uint256(- 1)) (XSwap.sol#240)\n\t-IERC20Token(chai).approve(lendFMe,uint256(- 1)) (XSwap.sol#241)\n\t-ILendFMe(lendFMe).supply(chai,IERC20Token(chai).balanceOf(address(this))) (XSwap.sol#251)\n\t-ILendFMe(lendFMe).supply(_token,_balance) (XSwap.sol#254)\n"
        },
        {
          "name": "unused-return",
          "vulnerability_from_line": 259,
          "vulnerability_to_line": 271,
          "vulnerability_code": "\tfunction disableLending(address _token) public auth returns (bool) {\n\n\t\trequire(supportLending[_token], \"the token doesnt support lending\");\n\n\t\tsupportLending[_token] = false;\n\n\n\n\t\tif (_token == dai) {\n\n\t\t\tILendFMe(lendFMe).withdraw(chai, uint256(-1));\n\n\t\t\tIChai(chai).exit(address(this), IERC20Token(chai).balanceOf(address(this)));\n\n\t\t}\n\n\t\telse\n\n\t\t\tILendFMe(lendFMe).withdraw(_token, uint256(-1));\n\n\n\n\t\treturn true;\n",
          "message": "XSwap.disableLending (XSwap.sol#259-271) does not use the value returned by external calls:\n\t-ILendFMe(lendFMe).withdraw(chai,uint256(- 1)) (XSwap.sol#264)\n\t-ILendFMe(lendFMe).withdraw(_token,uint256(- 1)) (XSwap.sol#268)\n"
        },
        {
          "name": "unused-return",
          "vulnerability_from_line": 308,
          "vulnerability_to_line": 323,
          "vulnerability_code": "\tfunction transferOut(address _token, address _receiver, uint256 _amount) external auth returns (bool) {\n\n\t\tif(supportLending[_token]) {\n\n\t\t\tif (_token == dai) {\n\n\t\t\t\tILendFMe(lendFMe).withdraw(chai, _amount);\n\n\t\t\t\tIChai(chai).draw(address(this), _amount);\n\n\t\t\t}\n\n\t\t\telse\n\n\t\t\t\tILendFMe(lendFMe).withdraw(_token, _amount);\n\n\t\t}\n\n\t\tuint256 _balance = NonStandardIERC20Token(_token).balanceOf(address(this));\n\n\t\tif(_balance >= _amount) {\n\n\t\t\tNonStandardIERC20Token(_token).transfer(_receiver, _amount);\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn false;\n",
          "message": "XSwap.transferOut (XSwap.sol#308-323) does not use the value returned by external calls:\n\t-ILendFMe(lendFMe).withdraw(chai,_amount) (XSwap.sol#311)\n\t-ILendFMe(lendFMe).withdraw(_token,_amount) (XSwap.sol#315)\n"
        },
        {
          "name": "unused-return",
          "vulnerability_from_line": 325,
          "vulnerability_to_line": 340,
          "vulnerability_code": "\tfunction transferOutALL(address _token, address _receiver) external auth returns (bool) {\n\n\t\tif(supportLending[_token]) {\n\n\t\t\tif (_token == dai) {\n\n\t\t\t\tILendFMe(lendFMe).withdraw(chai, uint256(-1));\n\n\t\t\t\tIChai(chai).exit(address(this), IERC20Token(chai).balanceOf(address(this)));\n\n\t\t\t}\n\n\t\t\telse\n\n\t\t\t\tILendFMe(lendFMe).withdraw(_token, uint256(-1));\n\n\t\t}\n\n\t\tuint256 _balance = NonStandardIERC20Token(_token).balanceOf(address(this));\n\n\t\tif(_balance > 0) {\n\n\t\t\tNonStandardIERC20Token(_token).transfer(_receiver, _balance);\n\n\t\t}\n\n\n\n\t\treturn true;\n",
          "message": "XSwap.transferOutALL (XSwap.sol#325-340) does not use the value returned by external calls:\n\t-ILendFMe(lendFMe).withdraw(chai,uint256(- 1)) (XSwap.sol#328)\n\t-ILendFMe(lendFMe).withdraw(_token,uint256(- 1)) (XSwap.sol#332)\n"
        },
        {
          "name": "unused-return",
          "vulnerability_from_line": 342,
          "vulnerability_to_line": 353,
          "vulnerability_code": "\tfunction transferIn(address _token, uint256 _amount) external auth returns (bool) {\n\n\t\tNonStandardIERC20Token(_token).transferFrom(msg.sender, address(this), _amount);\n\n\t\tif(supportLending[_token]) {\n\n\t\t\tif (_token == dai) {\n\n\t\t\t\tIChai(chai).join(address(this), NonStandardIERC20Token(dai).balanceOf(address(this)));\n\n\t\t\t\tILendFMe(lendFMe).supply(chai, IERC20Token(chai).balanceOf(address(this)));\n\n\t\t\t}\n\n\t\t\telse\n\n\t\t\t\tILendFMe(lendFMe).supply(_token, NonStandardIERC20Token(_token).balanceOf(address(this)));\n\n\t\t}\n\n\t    return true;\n",
          "message": "XSwap.transferIn (XSwap.sol#342-353) does not use the value returned by external calls:\n\t-ILendFMe(lendFMe).supply(chai,IERC20Token(chai).balanceOf(address(this))) (XSwap.sol#347)\n\t-ILendFMe(lendFMe).supply(_token,NonStandardIERC20Token(_token).balanceOf(address(this))) (XSwap.sol#350)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 274,
          "vulnerability_to_line": 278,
          "vulnerability_code": "\tfunction createPair(address _input, address _output, uint256 _priceInOut, uint256 _priceOutIn, uint256 _fee) external auth returns (bool) {\n\n\t\tsetPrices(_input, _output, _priceInOut, _priceOutIn);\n\n\t\tsetFee(_input, _output, _fee);\n\n\t\treturn true;\n",
          "message": "Reentrancy in XSwap.createPair (XSwap.sol#274-278):\n\tExternal calls:\n\t- setPrices(_input,_output,_priceInOut,_priceOutIn) (XSwap.sol#275)\n\t- setFee(_input,_output,_fee) (XSwap.sol#276)\n\tState variables written after the call(s):\n\t- fee (XSwap.sol#276)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 280,
          "vulnerability_to_line": 284,
          "vulnerability_code": "\tfunction setPrices(address _input, address _output, uint256 _priceInOut, uint256 _priceOutIn) public auth returns (bool) {\n\n\t\tsetPrices(_input, _output, _priceInOut);\n\n\t\tsetPrices(_output, _input, _priceOutIn);\n\n\t\treturn true;\n",
          "message": "Reentrancy in XSwap.setPrices (XSwap.sol#280-284):\n\tExternal calls:\n\t- setPrices(_input,_output,_priceInOut) (XSwap.sol#281)\n\t- setPrices(_output,_input,_priceOutIn) (XSwap.sol#282)\n\tState variables written after the call(s):\n\t- prices (XSwap.sol#282)\n"
        },
        {
          "name": "constable-states",
          "vulnerability_from_line": 167,
          "vulnerability_to_line": null,
          "vulnerability_code": "\taddress private chai = 0x8a5C1BD4D75e168a4f65eB902c289400B90FD980;\n",
          "message": "XSwap.chai should be constant (XSwap.sol#167)\nXSwap.dai should be constant (XSwap.sol#168)\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 19,
          "vulnerability_to_line": 21,
          "vulnerability_code": "    function canCall(\n\n        address src, address dst, bytes4 sig\n",
          "message": "DSAuthority.canCall (XSwap.sol#19-21) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 41,
          "vulnerability_to_line": 44,
          "vulnerability_code": "    function disableOwnership() public onlyOwner {\n\n        owner = address(0);\n\n        emit OwnerUpdate(msg.sender, owner);\n",
          "message": "DSAuth.disableOwnership (XSwap.sol#41-44) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 46,
          "vulnerability_to_line": 49,
          "vulnerability_code": "    function transferOwnership(address newOwner_) public onlyOwner {\n\n        require(newOwner_ != owner, \"TransferOwnership: the same owner.\");\n\n        newOwner = newOwner_;\n",
          "message": "DSAuth.transferOwnership (XSwap.sol#46-49) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 51,
          "vulnerability_to_line": 56,
          "vulnerability_code": "    function acceptOwnership() public {\n\n        require(msg.sender == newOwner, \"AcceptOwnership: only new owner do this.\");\n\n        emit OwnerUpdate(owner, newOwner);\n\n        owner = newOwner;\n\n        newOwner = address(0x0);\n",
          "message": "DSAuth.acceptOwnership (XSwap.sol#51-56) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 59,
          "vulnerability_to_line": 65,
          "vulnerability_code": "    function setAuthority(DSAuthority authority_)\n\n        public\n\n        onlyOwner\n\n    {\n\n        authority = authority_;\n\n        emit LogSetAuthority(address(authority));\n",
          "message": "DSAuth.setAuthority (XSwap.sol#59-65) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 181,
          "vulnerability_to_line": 187,
          "vulnerability_code": "\tfunction active(address _lendFMe) public {\n\n\t\trequire(actived == false, \"already actived.\");\n\n\t\towner = msg.sender;\n\n\t\tisOpen = true;\n\n\t\tlendFMe = _lendFMe;\n\n\t\tactived = true;\n",
          "message": "XSwap.active (XSwap.sol#181-187) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 190,
          "vulnerability_to_line": 192,
          "vulnerability_code": "\tfunction trade(address _input, address _output, uint256 _inputAmount) public returns (bool) {\n\n\t\treturn trade(_input, _output, _inputAmount, msg.sender);\n",
          "message": "XSwap.trade (XSwap.sol#190-192) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 225,
          "vulnerability_to_line": 228,
          "vulnerability_code": "\tfunction getTokenLiquidation(address _token) public view returns (uint256) {\n\n\t\tuint256 balanceInDefi = ILendFMe(lendFMe).getSupplyBalance(address(this), _token);\n\n\t\treturn balanceInDefi.add(NonStandardIERC20Token(_token).balanceOf(address(this)));\n",
          "message": "XSwap.getTokenLiquidation (XSwap.sol#225-228) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 230,
          "vulnerability_to_line": 233,
          "vulnerability_code": "\tfunction setLendFMe(address _lendFMe) public auth returns (bool) {\n\n\t\tlendFMe = _lendFMe;\n\n\t\treturn true;\n",
          "message": "XSwap.setLendFMe (XSwap.sol#230-233) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 235,
          "vulnerability_to_line": 257,
          "vulnerability_code": "\tfunction enableLending(address _token) public auth returns (bool) {\n\n\t\trequire(!supportLending[_token], \"the token is already supported lending\");\n\n\t\tsupportLending[_token] = true;\n\n\n\n\t\tif (_token == dai) {\n\n\t\t\tIERC20Token(_token).approve(chai, uint256(-1));\n\n\t\t\tIERC20Token(chai).approve(lendFMe, uint256(-1));\n\n\t\t}\n\n\t\telse {\n\n\t\t\tNonStandardIERC20Token(_token).approve(lendFMe, uint256(-1));\n\n\t\t}\n\n\n\n\t\tuint256 _balance = NonStandardIERC20Token(_token).balanceOf(address(this));\n\n\t\tif(_balance > 0) {\n\n\t\t\tif (_token == dai) {\n\n\t\t\t\tIChai(chai).join(address(this), _balance);\n\n\t\t\t\tILendFMe(lendFMe).supply(chai, IERC20Token(chai).balanceOf(address(this)));\n\n\t\t\t}\n\n\t\t\telse\n\n\t\t\t\tILendFMe(lendFMe).supply(_token, _balance);\n\n\t\t}\n\n\t\treturn true;\n",
          "message": "XSwap.enableLending (XSwap.sol#235-257) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 259,
          "vulnerability_to_line": 271,
          "vulnerability_code": "\tfunction disableLending(address _token) public auth returns (bool) {\n\n\t\trequire(supportLending[_token], \"the token doesnt support lending\");\n\n\t\tsupportLending[_token] = false;\n\n\n\n\t\tif (_token == dai) {\n\n\t\t\tILendFMe(lendFMe).withdraw(chai, uint256(-1));\n\n\t\t\tIChai(chai).exit(address(this), IERC20Token(chai).balanceOf(address(this)));\n\n\t\t}\n\n\t\telse\n\n\t\t\tILendFMe(lendFMe).withdraw(_token, uint256(-1));\n\n\n\n\t\treturn true;\n",
          "message": "XSwap.disableLending (XSwap.sol#259-271) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 297,
          "vulnerability_to_line": 301,
          "vulnerability_code": "\tfunction setTokenDecimals(address _token, uint256 _decimals) public auth returns (bool){\n\n\t\trequire(_decimals <= 18, \"not supported decimal\");\n\n\t\tdecimals[_token] = _decimals;\n\n\t\treturn true;\n",
          "message": "XSwap.setTokenDecimals (XSwap.sol#297-301) should be declared external\n"
        },
        {
          "name": "solc-version",
          "vulnerability_from_line": 16,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.4;\n",
          "message": "Detected issues with version pragma in XSwap.sol:\n\t- pragma solidity^0.5.4 (XSwap.sol#16): it allows old versions\n\t- pragma solidity^0.5.4 (XSwap.sol#96): it allows old versions\n\t- pragma solidity^0.5.4 (XSwap.sol#117): it allows old versions\n\t- pragma solidity^0.5.4 (XSwap.sol#127): it allows old versions\n\t- pragma solidity^0.5.4 (XSwap.sol#137): it allows old versions\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 181,
          "vulnerability_to_line": null,
          "vulnerability_code": "\tfunction active(address _lendFMe) public {\n",
          "message": "Parameter '_lendFMe' of XSwap.active (XSwap.sol#181) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 190,
          "vulnerability_to_line": null,
          "vulnerability_code": "\tfunction trade(address _input, address _output, uint256 _inputAmount) public returns (bool) {\n",
          "message": "Parameter '_input' of XSwap.trade (XSwap.sol#190) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 190,
          "vulnerability_to_line": null,
          "vulnerability_code": "\tfunction trade(address _input, address _output, uint256 _inputAmount) public returns (bool) {\n",
          "message": "Parameter '_output' of XSwap.trade (XSwap.sol#190) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 190,
          "vulnerability_to_line": null,
          "vulnerability_code": "\tfunction trade(address _input, address _output, uint256 _inputAmount) public returns (bool) {\n",
          "message": "Parameter '_inputAmount' of XSwap.trade (XSwap.sol#190) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 194,
          "vulnerability_to_line": null,
          "vulnerability_code": "\tfunction trade(address _input, address _output, uint256 _inputAmount, address _receiver) public returns (bool) {\n",
          "message": "Parameter '_input' of XSwap.trade (XSwap.sol#194) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 194,
          "vulnerability_to_line": null,
          "vulnerability_code": "\tfunction trade(address _input, address _output, uint256 _inputAmount, address _receiver) public returns (bool) {\n",
          "message": "Parameter '_output' of XSwap.trade (XSwap.sol#194) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 194,
          "vulnerability_to_line": null,
          "vulnerability_code": "\tfunction trade(address _input, address _output, uint256 _inputAmount, address _receiver) public returns (bool) {\n",
          "message": "Parameter '_inputAmount' of XSwap.trade (XSwap.sol#194) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 194,
          "vulnerability_to_line": null,
          "vulnerability_code": "\tfunction trade(address _input, address _output, uint256 _inputAmount, address _receiver) public returns (bool) {\n",
          "message": "Parameter '_receiver' of XSwap.trade (XSwap.sol#194) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 225,
          "vulnerability_to_line": null,
          "vulnerability_code": "\tfunction getTokenLiquidation(address _token) public view returns (uint256) {\n",
          "message": "Parameter '_token' of XSwap.getTokenLiquidation (XSwap.sol#225) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 230,
          "vulnerability_to_line": null,
          "vulnerability_code": "\tfunction setLendFMe(address _lendFMe) public auth returns (bool) {\n",
          "message": "Parameter '_lendFMe' of XSwap.setLendFMe (XSwap.sol#230) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 235,
          "vulnerability_to_line": null,
          "vulnerability_code": "\tfunction enableLending(address _token) public auth returns (bool) {\n",
          "message": "Parameter '_token' of XSwap.enableLending (XSwap.sol#235) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 259,
          "vulnerability_to_line": null,
          "vulnerability_code": "\tfunction disableLending(address _token) public auth returns (bool) {\n",
          "message": "Parameter '_token' of XSwap.disableLending (XSwap.sol#259) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 274,
          "vulnerability_to_line": null,
          "vulnerability_code": "\tfunction createPair(address _input, address _output, uint256 _priceInOut, uint256 _priceOutIn, uint256 _fee) external auth returns (bool) {\n",
          "message": "Parameter '_input' of XSwap.createPair (XSwap.sol#274) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 274,
          "vulnerability_to_line": null,
          "vulnerability_code": "\tfunction createPair(address _input, address _output, uint256 _priceInOut, uint256 _priceOutIn, uint256 _fee) external auth returns (bool) {\n",
          "message": "Parameter '_output' of XSwap.createPair (XSwap.sol#274) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 274,
          "vulnerability_to_line": null,
          "vulnerability_code": "\tfunction createPair(address _input, address _output, uint256 _priceInOut, uint256 _priceOutIn, uint256 _fee) external auth returns (bool) {\n",
          "message": "Parameter '_priceInOut' of XSwap.createPair (XSwap.sol#274) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 274,
          "vulnerability_to_line": null,
          "vulnerability_code": "\tfunction createPair(address _input, address _output, uint256 _priceInOut, uint256 _priceOutIn, uint256 _fee) external auth returns (bool) {\n",
          "message": "Parameter '_priceOutIn' of XSwap.createPair (XSwap.sol#274) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 274,
          "vulnerability_to_line": null,
          "vulnerability_code": "\tfunction createPair(address _input, address _output, uint256 _priceInOut, uint256 _priceOutIn, uint256 _fee) external auth returns (bool) {\n",
          "message": "Parameter '_fee' of XSwap.createPair (XSwap.sol#274) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 280,
          "vulnerability_to_line": null,
          "vulnerability_code": "\tfunction setPrices(address _input, address _output, uint256 _priceInOut, uint256 _priceOutIn) public auth returns (bool) {\n",
          "message": "Parameter '_input' of XSwap.setPrices (XSwap.sol#280) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 280,
          "vulnerability_to_line": null,
          "vulnerability_code": "\tfunction setPrices(address _input, address _output, uint256 _priceInOut, uint256 _priceOutIn) public auth returns (bool) {\n",
          "message": "Parameter '_output' of XSwap.setPrices (XSwap.sol#280) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 280,
          "vulnerability_to_line": null,
          "vulnerability_code": "\tfunction setPrices(address _input, address _output, uint256 _priceInOut, uint256 _priceOutIn) public auth returns (bool) {\n",
          "message": "Parameter '_priceInOut' of XSwap.setPrices (XSwap.sol#280) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 280,
          "vulnerability_to_line": null,
          "vulnerability_code": "\tfunction setPrices(address _input, address _output, uint256 _priceInOut, uint256 _priceOutIn) public auth returns (bool) {\n",
          "message": "Parameter '_priceOutIn' of XSwap.setPrices (XSwap.sol#280) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 286,
          "vulnerability_to_line": null,
          "vulnerability_code": "\tfunction setPrices(address _input, address _output, uint256 _price) public auth returns (bool) {\n",
          "message": "Parameter '_input' of XSwap.setPrices (XSwap.sol#286) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 286,
          "vulnerability_to_line": null,
          "vulnerability_code": "\tfunction setPrices(address _input, address _output, uint256 _price) public auth returns (bool) {\n",
          "message": "Parameter '_output' of XSwap.setPrices (XSwap.sol#286) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 286,
          "vulnerability_to_line": null,
          "vulnerability_code": "\tfunction setPrices(address _input, address _output, uint256 _price) public auth returns (bool) {\n",
          "message": "Parameter '_price' of XSwap.setPrices (XSwap.sol#286) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 291,
          "vulnerability_to_line": null,
          "vulnerability_code": "\tfunction setFee(address _input, address _output, uint256 _fee) public auth returns (bool) {\n",
          "message": "Parameter '_input' of XSwap.setFee (XSwap.sol#291) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 291,
          "vulnerability_to_line": null,
          "vulnerability_code": "\tfunction setFee(address _input, address _output, uint256 _fee) public auth returns (bool) {\n",
          "message": "Parameter '_output' of XSwap.setFee (XSwap.sol#291) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 291,
          "vulnerability_to_line": null,
          "vulnerability_code": "\tfunction setFee(address _input, address _output, uint256 _fee) public auth returns (bool) {\n",
          "message": "Parameter '_fee' of XSwap.setFee (XSwap.sol#291) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 297,
          "vulnerability_to_line": null,
          "vulnerability_code": "\tfunction setTokenDecimals(address _token, uint256 _decimals) public auth returns (bool){\n",
          "message": "Parameter '_token' of XSwap.setTokenDecimals (XSwap.sol#297) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 297,
          "vulnerability_to_line": null,
          "vulnerability_code": "\tfunction setTokenDecimals(address _token, uint256 _decimals) public auth returns (bool){\n",
          "message": "Parameter '_decimals' of XSwap.setTokenDecimals (XSwap.sol#297) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 303,
          "vulnerability_to_line": null,
          "vulnerability_code": "\tfunction emergencyStop(bool _open) external auth returns (bool) {\n",
          "message": "Parameter '_open' of XSwap.emergencyStop (XSwap.sol#303) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 308,
          "vulnerability_to_line": null,
          "vulnerability_code": "\tfunction transferOut(address _token, address _receiver, uint256 _amount) external auth returns (bool) {\n",
          "message": "Parameter '_token' of XSwap.transferOut (XSwap.sol#308) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 308,
          "vulnerability_to_line": null,
          "vulnerability_code": "\tfunction transferOut(address _token, address _receiver, uint256 _amount) external auth returns (bool) {\n",
          "message": "Parameter '_receiver' of XSwap.transferOut (XSwap.sol#308) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 308,
          "vulnerability_to_line": null,
          "vulnerability_code": "\tfunction transferOut(address _token, address _receiver, uint256 _amount) external auth returns (bool) {\n",
          "message": "Parameter '_amount' of XSwap.transferOut (XSwap.sol#308) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 325,
          "vulnerability_to_line": null,
          "vulnerability_code": "\tfunction transferOutALL(address _token, address _receiver) external auth returns (bool) {\n",
          "message": "Parameter '_token' of XSwap.transferOutALL (XSwap.sol#325) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 325,
          "vulnerability_to_line": null,
          "vulnerability_code": "\tfunction transferOutALL(address _token, address _receiver) external auth returns (bool) {\n",
          "message": "Parameter '_receiver' of XSwap.transferOutALL (XSwap.sol#325) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 342,
          "vulnerability_to_line": null,
          "vulnerability_code": "\tfunction transferIn(address _token, uint256 _amount) external auth returns (bool) {\n",
          "message": "Parameter '_token' of XSwap.transferIn (XSwap.sol#342) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 342,
          "vulnerability_to_line": null,
          "vulnerability_code": "\tfunction transferIn(address _token, uint256 _amount) external auth returns (bool) {\n",
          "message": "Parameter '_amount' of XSwap.transferIn (XSwap.sol#342) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 355,
          "vulnerability_to_line": null,
          "vulnerability_code": "\tfunction normalizeToken(address _token, uint256 _amount) internal view returns (uint256) {\n",
          "message": "Parameter '_token' of XSwap.normalizeToken (XSwap.sol#355) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 355,
          "vulnerability_to_line": null,
          "vulnerability_code": "\tfunction normalizeToken(address _token, uint256 _amount) internal view returns (uint256) {\n",
          "message": "Parameter '_amount' of XSwap.normalizeToken (XSwap.sol#355) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 360,
          "vulnerability_to_line": null,
          "vulnerability_code": "\tfunction denormalizedToken(address _token, uint256 _amount) internal view returns (uint256) {\n",
          "message": "Parameter '_token' of XSwap.denormalizedToken (XSwap.sol#360) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 360,
          "vulnerability_to_line": null,
          "vulnerability_code": "\tfunction denormalizedToken(address _token, uint256 _amount) internal view returns (uint256) {\n",
          "message": "Parameter '_amount' of XSwap.denormalizedToken (XSwap.sol#360) is not in mixedCase\n"
        }
      ]
    },
    "smartcheck": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 167,
          "vulnerability_to_line": null,
          "vulnerability_code": "\taddress private chai = 0x8a5C1BD4D75e168a4f65eB902c289400B90FD980;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 168,
          "vulnerability_to_line": null,
          "vulnerability_code": "\taddress private dai  = 0xA3A59273494BB5B8F0a8FAcf21B3f666A47d6140;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 42,
          "vulnerability_to_line": null,
          "vulnerability_code": "        owner = address(0);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 55,
          "vulnerability_to_line": null,
          "vulnerability_code": "        newOwner = address(0x0);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_OVERPOWERED_ROLE",
          "vulnerability_from_line": 59,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setAuthority(DSAuthority authority_)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 16,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.4;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 96,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.4;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 117,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.4;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 127,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.4;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 137,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.4;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 167,
          "vulnerability_to_line": null,
          "vulnerability_code": "\taddress private chai = 0x8a5C1BD4D75e168a4f65eB902c289400B90FD980;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 168,
          "vulnerability_to_line": null,
          "vulnerability_code": "\taddress private dai  = 0xA3A59273494BB5B8F0a8FAcf21B3f666A47d6140;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 170,
          "vulnerability_to_line": null,
          "vulnerability_code": "\tbool private actived;\n",
          "message": null
        }
      ]
    },
    "oyente": {
      "successfull_analysis": false,
      "errors": [
        "exception (IndexError: pop from empty list)"
      ],
      "vulnerability_findings": []
    },
    "mythril": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "External Call To User-Supplied Address (SWC 107)",
          "vulnerability_from_line": 319,
          "vulnerability_to_line": null,
          "vulnerability_code": "\t\t\tNonStandardIERC20Token(_token).transfer(_receiver, _amount);\n",
          "message": "A call to a user-supplied address is executed.\nAn external message call to an address specified by the caller is executed. Note that the callee account might contain arbitrary code and could re-enter any function within this contract. Reentering the contract in an intermediate state may lead to unexpected behaviour. Make sure that no state modifications are executed after this call and/or reentrancy guards are in place.\nClassification: SWC-107"
        },
        {
          "name": "Multiple Calls in a Single Transaction (SWC 113)",
          "vulnerability_from_line": 319,
          "vulnerability_to_line": null,
          "vulnerability_code": "\t\t\tNonStandardIERC20Token(_token).transfer(_receiver, _amount);\n",
          "message": "Multiple calls are executed in the same transaction.\nThis call is executed following another call within the same transaction. It is possible that the call never gets executed if a prior call fails permanently. This might be caused intentionally by a malicious callee. If possible, refactor the code such that each transaction only executes one external call or make sure that all callees can be trusted (i.e. they\u2019re part of your own codebase).\nClassification: SWC-113"
        },
        {
          "name": "External Call To User-Supplied Address (SWC 107)",
          "vulnerability_from_line": 336,
          "vulnerability_to_line": null,
          "vulnerability_code": "\t\t\tNonStandardIERC20Token(_token).transfer(_receiver, _balance);\n",
          "message": "A call to a user-supplied address is executed.\nAn external message call to an address specified by the caller is executed. Note that the callee account might contain arbitrary code and could re-enter any function within this contract. Reentering the contract in an intermediate state may lead to unexpected behaviour. Make sure that no state modifications are executed after this call and/or reentrancy guards are in place.\nClassification: SWC-107"
        },
        {
          "name": "Multiple Calls in a Single Transaction (SWC 113)",
          "vulnerability_from_line": 336,
          "vulnerability_to_line": null,
          "vulnerability_code": "\t\t\tNonStandardIERC20Token(_token).transfer(_receiver, _balance);\n",
          "message": "Multiple calls are executed in the same transaction.\nThis call is executed following another call within the same transaction. It is possible that the call never gets executed if a prior call fails permanently. This might be caused intentionally by a malicious callee. If possible, refactor the code such that each transaction only executes one external call or make sure that all callees can be trusted (i.e. they\u2019re part of your own codebase).\nClassification: SWC-113"
        },
        {
          "name": "State access after external call (SWC 107)",
          "vulnerability_from_line": 241,
          "vulnerability_to_line": null,
          "vulnerability_code": "\t\t\tIERC20Token(chai).approve(lendFMe, uint256(-1));\n",
          "message": "Read of persistent state following external call\nThe contract account state is accessed after an external call to a fixed address. To prevent reentrancy issues, consider accessing the state only before the call, especially if the callee is untrusted. Alternatively, a reentrancy lock can be used to prevent untrusted callees from re-entering the contract in an intermediate state.\nClassification: SWC-107"
        },
        {
          "name": "State access after external call (SWC 107)",
          "vulnerability_from_line": 241,
          "vulnerability_to_line": null,
          "vulnerability_code": "\t\t\tIERC20Token(chai).approve(lendFMe, uint256(-1));\n",
          "message": "Read of persistent state following external call\nThe contract account state is accessed after an external call to a fixed address. To prevent reentrancy issues, consider accessing the state only before the call, especially if the callee is untrusted. Alternatively, a reentrancy lock can be used to prevent untrusted callees from re-entering the contract in an intermediate state.\nClassification: SWC-107"
        },
        {
          "name": "Multiple Calls in a Single Transaction (SWC 113)",
          "vulnerability_from_line": 241,
          "vulnerability_to_line": null,
          "vulnerability_code": "\t\t\tIERC20Token(chai).approve(lendFMe, uint256(-1));\n",
          "message": "Multiple calls are executed in the same transaction.\nThis call is executed following another call within the same transaction. It is possible that the call never gets executed if a prior call fails permanently. This might be caused intentionally by a malicious callee. If possible, refactor the code such that each transaction only executes one external call or make sure that all callees can be trusted (i.e. they\u2019re part of your own codebase).\nClassification: SWC-113"
        },
        {
          "name": "State access after external call (SWC 107)",
          "vulnerability_from_line": 241,
          "vulnerability_to_line": null,
          "vulnerability_code": "\t\t\tIERC20Token(chai).approve(lendFMe, uint256(-1));\n",
          "message": "Write to persistent state following external call\nThe contract account state is accessed after an external call to a fixed address. To prevent reentrancy issues, consider accessing the state only before the call, especially if the callee is untrusted. Alternatively, a reentrancy lock can be used to prevent untrusted callees from re-entering the contract in an intermediate state.\nClassification: SWC-107"
        },
        {
          "name": "External Call To User-Supplied Address (SWC 107)",
          "vulnerability_from_line": 244,
          "vulnerability_to_line": null,
          "vulnerability_code": "\t\t\tNonStandardIERC20Token(_token).approve(lendFMe, uint256(-1));\n",
          "message": "A call to a user-supplied address is executed.\nAn external message call to an address specified by the caller is executed. Note that the callee account might contain arbitrary code and could re-enter any function within this contract. Reentering the contract in an intermediate state may lead to unexpected behaviour. Make sure that no state modifications are executed after this call and/or reentrancy guards are in place.\nClassification: SWC-107"
        },
        {
          "name": "Multiple Calls in a Single Transaction (SWC 113)",
          "vulnerability_from_line": 247,
          "vulnerability_to_line": null,
          "vulnerability_code": "\t\tuint256 _balance = NonStandardIERC20Token(_token).balanceOf(address(this));\n",
          "message": "Multiple calls are executed in the same transaction.\nThis call is executed following another call within the same transaction. It is possible that the call never gets executed if a prior call fails permanently. This might be caused intentionally by a malicious callee. If possible, refactor the code such that each transaction only executes one external call or make sure that all callees can be trusted (i.e. they\u2019re part of your own codebase).\nClassification: SWC-113"
        },
        {
          "name": "State access after external call (SWC 107)",
          "vulnerability_from_line": 249,
          "vulnerability_to_line": null,
          "vulnerability_code": "\t\t\tif (_token == dai) {\n",
          "message": "Read of persistent state following external call\nThe contract account state is accessed after an external call to a user defined address. To prevent reentrancy issues, consider accessing the state only before the call, especially if the callee is untrusted. Alternatively, a reentrancy lock can be used to prevent untrusted callees from re-entering the contract in an intermediate state.\nClassification: SWC-107"
        },
        {
          "name": "State access after external call (SWC 107)",
          "vulnerability_from_line": 250,
          "vulnerability_to_line": null,
          "vulnerability_code": "\t\t\t\tIChai(chai).join(address(this), _balance);\n",
          "message": "Read of persistent state following external call\nThe contract account state is accessed after an external call to a fixed address. To prevent reentrancy issues, consider accessing the state only before the call, especially if the callee is untrusted. Alternatively, a reentrancy lock can be used to prevent untrusted callees from re-entering the contract in an intermediate state.\nClassification: SWC-107"
        },
        {
          "name": "State access after external call (SWC 107)",
          "vulnerability_from_line": 250,
          "vulnerability_to_line": null,
          "vulnerability_code": "\t\t\t\tIChai(chai).join(address(this), _balance);\n",
          "message": "Write to persistent state following external call\nThe contract account state is accessed after an external call to a fixed address. To prevent reentrancy issues, consider accessing the state only before the call, especially if the callee is untrusted. Alternatively, a reentrancy lock can be used to prevent untrusted callees from re-entering the contract in an intermediate state.\nClassification: SWC-107"
        },
        {
          "name": "State access after external call (SWC 107)",
          "vulnerability_from_line": 251,
          "vulnerability_to_line": null,
          "vulnerability_code": "\t\t\t\tILendFMe(lendFMe).supply(chai, IERC20Token(chai).balanceOf(address(this)));\n",
          "message": "Read of persistent state following external call\nThe contract account state is accessed after an external call to a fixed address. To prevent reentrancy issues, consider accessing the state only before the call, especially if the callee is untrusted. Alternatively, a reentrancy lock can be used to prevent untrusted callees from re-entering the contract in an intermediate state.\nClassification: SWC-107"
        },
        {
          "name": "State access after external call (SWC 107)",
          "vulnerability_from_line": 251,
          "vulnerability_to_line": null,
          "vulnerability_code": "\t\t\t\tILendFMe(lendFMe).supply(chai, IERC20Token(chai).balanceOf(address(this)));\n",
          "message": "Read of persistent state following external call\nThe contract account state is accessed after an external call to a fixed address. To prevent reentrancy issues, consider accessing the state only before the call, especially if the callee is untrusted. Alternatively, a reentrancy lock can be used to prevent untrusted callees from re-entering the contract in an intermediate state.\nClassification: SWC-107"
        },
        {
          "name": "State access after external call (SWC 107)",
          "vulnerability_from_line": 251,
          "vulnerability_to_line": null,
          "vulnerability_code": "\t\t\t\tILendFMe(lendFMe).supply(chai, IERC20Token(chai).balanceOf(address(this)));\n",
          "message": "Read of persistent state following external call\nThe contract account state is accessed after an external call to a fixed address. To prevent reentrancy issues, consider accessing the state only before the call, especially if the callee is untrusted. Alternatively, a reentrancy lock can be used to prevent untrusted callees from re-entering the contract in an intermediate state.\nClassification: SWC-107"
        },
        {
          "name": "State access after external call (SWC 107)",
          "vulnerability_from_line": 251,
          "vulnerability_to_line": null,
          "vulnerability_code": "\t\t\t\tILendFMe(lendFMe).supply(chai, IERC20Token(chai).balanceOf(address(this)));\n",
          "message": "Write to persistent state following external call\nThe contract account state is accessed after an external call to a fixed address. To prevent reentrancy issues, consider accessing the state only before the call, especially if the callee is untrusted. Alternatively, a reentrancy lock can be used to prevent untrusted callees from re-entering the contract in an intermediate state.\nClassification: SWC-107"
        },
        {
          "name": "State access after external call (SWC 107)",
          "vulnerability_from_line": 254,
          "vulnerability_to_line": null,
          "vulnerability_code": "\t\t\t\tILendFMe(lendFMe).supply(_token, _balance);\n",
          "message": "Read of persistent state following external call\nThe contract account state is accessed after an external call to a user defined address. To prevent reentrancy issues, consider accessing the state only before the call, especially if the callee is untrusted. Alternatively, a reentrancy lock can be used to prevent untrusted callees from re-entering the contract in an intermediate state.\nClassification: SWC-107"
        },
        {
          "name": "State access after external call (SWC 107)",
          "vulnerability_from_line": 254,
          "vulnerability_to_line": null,
          "vulnerability_code": "\t\t\t\tILendFMe(lendFMe).supply(_token, _balance);\n",
          "message": "Write to persistent state following external call\nThe contract account state is accessed after an external call to a user defined address. To prevent reentrancy issues, consider accessing the state only before the call, especially if the callee is untrusted. Alternatively, a reentrancy lock can be used to prevent untrusted callees from re-entering the contract in an intermediate state.\nClassification: SWC-107"
        },
        {
          "name": "External Call To User-Supplied Address (SWC 107)",
          "vulnerability_from_line": 343,
          "vulnerability_to_line": null,
          "vulnerability_code": "\t\tNonStandardIERC20Token(_token).transferFrom(msg.sender, address(this), _amount);\n",
          "message": "A call to a user-supplied address is executed.\nAn external message call to an address specified by the caller is executed. Note that the callee account might contain arbitrary code and could re-enter any function within this contract. Reentering the contract in an intermediate state may lead to unexpected behaviour. Make sure that no state modifications are executed after this call and/or reentrancy guards are in place.\nClassification: SWC-107"
        },
        {
          "name": "State access after external call (SWC 107)",
          "vulnerability_from_line": 344,
          "vulnerability_to_line": null,
          "vulnerability_code": "\t\tif(supportLending[_token]) {\n",
          "message": "Read of persistent state following external call\nThe contract account state is accessed after an external call to a user defined address. To prevent reentrancy issues, consider accessing the state only before the call, especially if the callee is untrusted. Alternatively, a reentrancy lock can be used to prevent untrusted callees from re-entering the contract in an intermediate state.\nClassification: SWC-107"
        }
      ]
    },
    "osiris": {
      "successfull_analysis": false,
      "errors": [
        "Solidity compilation failed"
      ],
      "vulnerability_findings": []
    }
  }
}