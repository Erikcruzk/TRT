{
  "smartbugs_completed": true,
  "analyzer_results": {
    "semgrep": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 339,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor ()\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 340,
          "vulnerability_to_line": null,
          "vulnerability_code": "        public\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 341,
          "vulnerability_to_line": null,
          "vulnerability_code": "    {\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 342,
          "vulnerability_to_line": null,
          "vulnerability_code": "        EIP712_DOMAIN_HASH = keccak256(abi.encode(\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 343,
          "vulnerability_to_line": null,
          "vulnerability_code": "            EIP712_DOMAIN_SEPARATOR_SCHEMA_HASH,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 344,
          "vulnerability_to_line": null,
          "vulnerability_code": "            keccak256(bytes(EIP712_DOMAIN_NAME)),\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 345,
          "vulnerability_to_line": null,
          "vulnerability_code": "            keccak256(bytes(EIP712_DOMAIN_VERSION)),\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 346,
          "vulnerability_to_line": null,
          "vulnerability_code": "            address(this)\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 347,
          "vulnerability_to_line": null,
          "vulnerability_code": "        ));\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 348,
          "vulnerability_to_line": null,
          "vulnerability_code": "    }\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 461,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor() public {}\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 448,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(_signer != address(0x0), \"signer address cannot be 0\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 449,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(result, \"signature recovery failed\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 447,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (!(result && (_signer != address(0x0)))) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 448,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(_signer != address(0x0), \"signer address cannot be 0\");\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 449,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(result, \"signature recovery failed\");\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 450,
          "vulnerability_to_line": null,
          "vulnerability_code": "        }\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        }
      ]
    },
    "slither": {
      "successfull_analysis": true,
      "errors": [
        "EXIT_CODE_13"
      ],
      "vulnerability_findings": [
        {
          "name": "constant-function",
          "vulnerability_from_line": 25,
          "vulnerability_to_line": 305,
          "vulnerability_code": "    function encodeAndExit() internal pure {\n\n        assembly {\n\n            // set up initial variables\n\n            let notes := add(0x104, calldataload(0x144))\n\n            let n := calldataload(notes)\n\n            let inputOwners := add(0x124, calldataload(0x164)) // one word after input owners = 1st\n\n            let outputOwners := add(0x124, calldataload(0x184)) // one word after outputOwners = 1st\n\n            let metadata := add(0x144, calldataload(0x1a4)) // two words after metadata = 1st\n\n\n\n            // memory map of `proofOutputs`\n\n\n\n            // `returndata` starts at 0x160\n\n            // `proofOutputs` starts at 0x180\n\n            // 0x160 - 0x180 = relative offset in returndata to first bytes argument (0x20)\n\n            // 0x180 - 0x1a0 = byte length of `proofOutputs`\n\n            // 0x1a0 - 0x1c0 = number of `proofOutputs` entries (2)\n\n            // 0x1c0 - 0x1e0 = relative memory offset between `v` and start of `proofOutput`\n\n\n\n            // `proofOutput A` - t, starts at 0x1e0\n\n            // 0x1e0 - 0x200 = length of `proofOutputA`\n\n            // 0x200 - 0x220 = relative offset between `t` and `inputNotes`\n\n            // 0x220 - 0x240 = relative offset between `t` and `outputNotes`\n\n            // 0x240 - 0x260 = `publicOwner`\n\n            // 0x260 - 0x280 = `publicValue`\n\n            // 0x280 - 0x2a0 = `challenge`\n\n\n\n            // `inputNotes A` starts at 0x2a0\n\n            // structure of `inputNotes` and `outputNotes`\n\n            // 0x00 - 0x20 = byte length of notes array\n\n            // 0x20 - 0x40 = number of notes `i`\n\n            // the next `i` consecutive blocks of 0x20-sized memory contain relative offset between\n\n            // start of notes array and the location of the `note`\n\n\n\n            // `proofOutput B` - r\n\n            // 0x00 - 0x20 = length of `proofOutput B`\n\n            // 0x20 - 0x40 = relative offset between `r` and `inputNotes`\n\n            // 0x40 - 0x60 = relative offset between `r` and `outputNotes`\n\n            // 0x60 - 0x80 = `publicOwner`\n\n            // 0x80 - 0xa0 = `publicValue`\n\n            // 0xa0 - 0xc0 = `challenge`\n\n\n\n            // 'inputNotes B'\n\n            // structure of `inputNotes` and `outputNotes`\n\n            // 0x00 - 0x20 = byte length of notes array\n\n            // 0x20 - 0x40 = number of notes `i`\n\n            // the next `i` consecutive blocks of 0x20-sized memory contain relative offset between\n\n            // start of notes array and the location of the `note`\n\n\n\n            // structure of a `note`\n\n            // 0x00 - 0x20 = size of `note`\n\n            // 0x20 - 0x40 = `noteType`\n\n            // 0x40 - 0x60 = `owner`\n\n            // 0x60 - 0x80 = `noteHash`\n\n            // 0x80 - 0xa0 = size of note `data`\n\n            // 0xa0 - 0xc0 = compressed note coordinate `gamma` (part of `data`)\n\n            // 0xc0 - 0xe0 = compressed note coordinate `sigma` (part of `data`)\n\n            // 0xe0 - ???? = remaining note metadata\n\n\n\n            // `proofOutputs` must form a monolithic block of memory that we can return.\n\n            // `s` points to the memory location of the start of the current note\n\n            // `inputPtr` points to the start of the current `notes` dynamic bytes array\n\n\n\n            // length of proofOutputs is at s\n\n            mstore(0x1a0, 0x02)                            // there are two proofOutput objects for a join-split fluid\n\n            mstore(0x1c0, 0x80)                            // offset to 1st proof\n\n            // 0x1e0 = offset to 2nd proof\n\n            // length of proofOutput is at s + 0x60\n\n            mstore(0x220, 0xc0)                            // location of inputNotes\n\n            mstore(0x260, 0x00)                            // publicOwner is 0\n\n            mstore(0x280, 0x00)                            // publicValue is 0\n\n\n\n            mstore(0x2a0, calldataload(0x124))\n\n\n\n            // set note pointer, offsetting lookup indices for each input note\n\n\n\n            /////////////////// PROOF OUTPUT A: START OF INPUT NOTES //////////////////\n\n            // 0x2c0 = number of bytes in `inputNotes` (leave blank for now)\n\n            // 0x2e0 = number of input notes\n\n            mstore(0x2e0, 0x01)\n\n\n\n            // 0x300 = relative offset to 1st input note (0x60)\n\n            mstore(0x300, 0x60)\n\n\n\n            // Start of inputNote[0]\n\n            // get pointer to metadata\n\n            let metadataIndex := calldataload(metadata)\n\n\n\n            // copy note data to 0x20 - 0xa0\n\n            mstore(0x00, 0x01)\n\n            calldatacopy(0x20, add(notes, 0x120), 0x80) // get gamma, sigma\n\n\n\n            // store note length in `s` = 0x320\n\n            mstore(0x320, 0xc0)\n\n            // store note type (UXTO type, 0x01) in `s + 0x20`\n\n            mstore(0x340, 0x01)\n\n            // store the owner of the note in `s + 0x40`\n\n            mstore(0x360, calldataload(outputOwners))\n\n            // store note hash\n\n            mstore(0x380, keccak256(0x00, 0xa0))\n\n            // store noteData length in `s + 0x80`\n\n            mstore(0x3a0, 0x40)\n\n            // store compressed note coordinate gamma in `s + 0xa0`\n\n            mstore(\n\n                0x3c0,\n\n                or(\n\n                    mload(0x20),\n\n                    shl(255, and(mload(0x40), 0x01))\n\n                )\n\n            )\n\n            // store compressed note coordinate sigma in `s + 0xc0`\n\n            mstore(\n\n                0x3e0,\n\n                or(\n\n                    mload(0x60),\n\n                    shl(255, and(mload(0x80), 0x01))\n\n                )\n\n            )\n\n            // inputNote, so no metaData to store\n\n\n\n            // store relative memory offset to outputNotes\n\n            mstore(0x240, 0x200)\n\n            // store the length of inputNotes at 0x2c0\n\n            mstore(0x2c0, 0x120)\n\n            ///////////////// PROOF OUTPUT A: START OF OUTPUT NOTES (1) ///////////////////\n\n\n\n            // transition between input and output notes\n\n\n\n            // 0x400 + metadataLength = byte length of output notes (0x120)\n\n            // 0x420 + metadataLength = # of output notes (1)\n\n            // 0x440 + metadataLength = offset to outputNotes[0] (0x60)\n\n            let metadataLength := calldataload(add(metadataIndex, sub(metadata, 0x40)))\n\n\n\n            mstore(0x400, add(0x120, metadataLength)) // store length of output notes\n\n            mstore(0x420, 0x01) // store number of output notes\n\n            mstore(0x440, 0x60) // store offset to outputNotes[0]\n\n\n\n            // construct note hash\n\n            // copy 1st note note to 0x20 - 0xa0\n\n            calldatacopy(0x20, add(notes, 0x60), 0x80) // get gamma, sigma\n\n\n\n            // store note length in `s`\n\n            mstore(0x460, add(0xc0, metadataLength))\n\n            // store note type (UXTO type, 0x01) in `s + 0x20`\n\n            mstore(0x480, 0x01)\n\n            // store note owner in `s + 0x40`\n\n            mstore(0x4a0, calldataload(inputOwners))\n\n            // store note hash in `s + 0x60`\n\n            mstore(0x4c0, keccak256(0x00, 0xa0))\n\n            // store note metadata length in `s + 0x80` (just the coordinates)\n\n            mstore(0x4e0, add(0x40, metadataLength))\n\n            // store compressed note coordinate gamma in `s + 0xa0`\n\n            mstore(\n\n                0x500,\n\n                or(\n\n                    mload(0x20),\n\n                    shl(255, and(mload(0x40), 0x01))\n\n                )\n\n            )\n\n            // store compressed note coordinate sigma in `s + 0xc0`\n\n            mstore(\n\n                0x520,\n\n                or(\n\n                    mload(0x60),\n\n                    shl(255, and(mload(0x80), 0x01))\n\n                )\n\n            )\n\n\n\n            calldatacopy(0x540, add(metadataIndex, sub(metadata, 0x20)), metadataLength)\n\n\n\n            // compute the relative offset to index this note in our returndata\n\n            mstore(add(0x440, 0), 0x60) // relative offset to note\n\n\n\n            // now we need to transition between first and second proofOutput\n\n            // s is going to point to the end of the outputNotes array\n\n            // so, s is our absolute pointer to the start of the 2nd proofOutputs entry\n\n            // we know that 'proofOutputs' starts at 0x180\n\n            // so (s - 0x180) = relative offset to second proofOutputs entry\n\n            let startOfProofOutput := add(0x540, metadataLength)\n\n\n\n            // proofOutput[0].length = start of proofOutput[1] - start of proofOutput[0] - 0x20\n\n            // proofOutput[0].length = (0x540 + metadataLength) - 0x200 - 0x20 = 0x320 + metadataLength\n\n            mstore(0x200, add(0x320, metadataLength)) // length of proofOutput\n\n            mstore(0x1e0, add(0x3c0, metadataLength)) // offset to get to second proofOutput\n\n\n\n            // s points to the start of proofOutputs[0]\n\n            let s := startOfProofOutput\n\n            mstore(add(s, 0x20), 0xc0)   // location of inputNotes\n\n            mstore(add(s, 0x40), 0x100)  // location of outputNotes\n\n            mstore(add(s, 0x60), 0x00)   // publicOwner\n\n            mstore(add(s, 0x80), 0x00)   // publicValue\n\n\n\n            // compute challenge = kecck256(challenge)\n\n            mstore(0x20, calldataload(0x124))\n\n            mstore(add(s, 0xa0), keccak256(0x20, 0x20)) // challenge\n\n            // 0x00 length of proofOutput\n\n            // 0x20 location of inputNotes\n\n            // 0x40 location of outputNotes\n\n            // 0x60 publicOwner\n\n            // 0x80 publicValue\n\n            // 0xa0 = inputNoteData\n\n            mstore(add(s, 0xc0), 0x20) // length of input notes array (1 word)\n\n            mstore(add(s, 0xe0), 0x00) // number of entries (0 words)\n\n\n\n            // set notesPtr = proofOutputs[1].outputNotes\n\n            let notesPtr := add(s, 0x100)\n\n\n\n            // s + 0x20 = number of notes = n - 2\n\n            mstore(add(notesPtr, 0x20), sub(n, 2))\n\n\n\n            // set s to point to proofOutputs[1].outputNotes[0]\n\n            s := add(add(s, 0x140), mul(0x20, sub(n, 2)))\n\n\n\n            // Output notes:\n\n            // first output note needs to go into the first proofOutput object\n\n            // second output note onwards, needs to go into the second proofOutput object\n\n            for { let i := 0x02 } lt(i, n) { i := add(i, 0x01) } {\n\n\n\n            /////////////////// START OF PROOF OUTPUT B  ////////////////////\n\n\n\n                // get pointer to metadata\n\n                metadataIndex := calldataload(add(metadata, mul(sub(i, 0x01), 0x20)))\n\n                // get size of metadata\n\n                metadataLength := calldataload(add(sub(metadata, 0x40), metadataIndex))\n\n\n\n                mstore(0x00, 0x01)\n\n                // copy note data to 0x20 - 0xa0\n\n                calldatacopy(\n\n                    0x20,\n\n                    add(add(notes, 0x60), mul(i, 0xc0)),\n\n                    0x80\n\n                ) // get gamma, sigma\n\n\n\n                // store note length in `s`\n\n                mstore(s, add(0xc0, metadataLength))\n\n                // store note type (UXTO type, 0x01) in `s + 0x20`\n\n                mstore(add(s, 0x20), 0x01)\n\n                // store the owner of the note in `s + 0x40`\n\n                mstore(add(s, 0x40), calldataload(add(outputOwners, mul(sub(i, 0x01), 0x20))))\n\n                // store note hash\n\n                mstore(add(s, 0x60), keccak256(0x00, 0xa0))\n\n                // store note metadata length if `s + 0x80`\n\n                mstore(add(s, 0x80), add(0x40, metadataLength))\n\n                // store compressed note coordinate gamma in `s + 0xa0`\n\n                mstore(\n\n                    add(s, 0xa0),\n\n                    or(\n\n                        mload(0x20),\n\n                        shl(255, and(mload(0x40), 0x01))\n\n                    )\n\n                )\n\n                // store compressed note coordinate sigma in `s + 0xc0`\n\n                mstore(\n\n                    add(s, 0xc0),\n\n                    or(\n\n                        mload(0x60),\n\n                        shl(255, and(mload(0x80), 0x01))\n\n                    )\n\n                )\n\n                // copy metadata into `s + 0xe0`\n\n                calldatacopy(add(s, 0xe0), add(metadataIndex, sub(metadata, 0x20)), metadataLength)\n\n                // compute the relative offset to index this note in our returndata\n\n                mstore(add(notesPtr, mul(i, 0x20)), sub(s, notesPtr)) // relative offset to note\n\n\n\n                // increase s by note length\n\n                s := add(s, add(mload(s), 0x20))\n\n            }\n\n\n\n            // inputPtr used to point to start of inputNotes for proofOutputs[0]\n\n            // now we want inputPtr to point to start of inputNotes for proofOutputs[1]\n\n            // 1. length of proofOutput\n\n            // 2. length of outputNotes\n\n            // length of outputNotes = s - inputPtr, stored at inputPtr\n\n            mstore(notesPtr, sub(sub(s, notesPtr), 0x20)) // store length of outputNotes at start of outputNotes\n\n            // length of proofOutput\n\n            let proofOutputLength := sub(s, startOfProofOutput)\n\n            mstore(startOfProofOutput, sub(proofOutputLength, 0x20))\n\n            mstore(0x180, sub(s, 0x1a0)) // store length of proofOutputs at 0x100\n\n            mstore(0x160, 0x20)\n\n            return(0x160, sub(s, 0x160)) // return the final byte array\n\n        }\n",
          "message": "JoinSplitFluidABIEncoder.encodeAndExit (JoinSplitFluid.sol#25-305) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 353,
          "vulnerability_to_line": 379,
          "vulnerability_code": "    function hashEIP712Message(bytes32 _hashStruct)\n\n        internal\n\n        view\n\n        returns (bytes32 _result)\n\n    {\n\n        bytes32 eip712DomainHash = EIP712_DOMAIN_HASH;\n\n\n\n        // Assembly for more efficient computing:\n\n        // keccak256(abi.encodePacked(\n\n        //     EIP191_HEADER,\n\n        //     EIP712_DOMAIN_HASH,\n\n        //     hashStruct\n\n        // ));\n\n\n\n        assembly {\n\n            // Load free memory pointer. We're not going to use it - we're going to overwrite it!\n\n            // We need 0x60 bytes of memory for this hash,\n\n            // cheaper to overwrite the free memory pointer at 0x40, and then replace it, than allocating free memory\n\n            let memPtr := mload(0x40)\n\n            mstore(0x00, 0x1901)               // EIP191 header\n\n            mstore(0x20, eip712DomainHash)     // EIP712 domain hash\n\n            mstore(0x40, _hashStruct)          // Hash of struct\n\n            _result := keccak256(0x1e, 0x42)   // compute hash\n\n            // replace memory pointer\n\n            mstore(0x40, memPtr)\n\n        }\n",
          "message": "LibEIP712.hashEIP712Message (JoinSplitFluid.sol#353-379) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 385,
          "vulnerability_to_line": 451,
          "vulnerability_code": "    function recoverSignature(\n\n        bytes32 _message,\n\n        bytes memory _signature\n\n    ) internal view returns (address _signer) {\n\n        bool result;\n\n        assembly {\n\n            // Here's a little trick we can pull. We expect `_signature` to be a byte array, of length 0x60, with\n\n            // 'v', 'r' and 's' located linearly in memory. Preceeding this is the length parameter of `_signature`.\n\n            // We *replace* the length param with the signature msg to get a memory block formatted for the precompile\n\n            // load length as a temporary variable\n\n\n\n            let byteLength := mload(_signature)\n\n\n\n            // store the signature message\n\n            mstore(_signature, _message)\n\n\n\n            // load 'v' - we need it for a condition check\n\n            let v := mload(add(_signature, 0x60))\n\n            v := shr(248, v) // bitshifting, to resemble padLeft\n\n\n\n            /**\n\n            * Original memory map for input to precompile\n\n            *\n\n            * _signature : _signature + 0x20            message \n\n            * _signature + 0x20 : _signature + 0x40     r\n\n            * _signature + 0x40 : _signature + 0x60     s\n\n            * _signature + 0x60 : _signature + 0x80     v\n\n\n\n            * Desired memory map for input to precompile\n\n            *\n\n            * _signature : _signature + 0x20            message \n\n            * _signature + 0x20 : _signature + 0x40     v\n\n            * _signature + 0x40 : _signature + 0x60     r\n\n            * _signature + 0x60 : _signature + 0x80     s\n\n            */\n\n\n\n            // move s to v position\n\n            mstore(add(_signature, 0x60), mload(add(_signature, 0x40)))\n\n            // move r to s position\n\n            mstore(add(_signature, 0x40), mload(add(_signature, 0x20)))\n\n            // move v to r position\n\n            mstore(add(_signature, 0x20), v)\n\n            result := and(\n\n                and(\n\n                    // validate signature length == 0x41 or 0x60 bytes. \n\n                    // will be 0x41 if one signature was provided, 0x60 if multiple signatures \n\n                    // have been provided - due to the relevant signature creation functions\n\n                    or(eq(byteLength, 0x41), eq(byteLength, 0x60)),\n\n                    // validate v == 27 or v == 28\n\n                    or(eq(v, 27), eq(v, 28))\n\n                ),\n\n                // validate call to precompile succeeds\n\n                staticcall(gas, 0x01, _signature, 0x80, _signature, 0x20) \n\n            )\n\n            // save the _signer only if the first word in _signature is not `_message` anymore\n\n            switch eq(_message, mload(_signature))\n\n            case 0 {\n\n                _signer := mload(_signature)\n\n            }\n\n            mstore(_signature, byteLength) // and put the byte length back where it belongs\n\n        }\n\n        // wrap Failure States in a single if test, so that happy path only has 1 conditional jump\n\n        if (!(result && (_signer != address(0x0)))) {\n\n            require(_signer != address(0x0), \"signer address cannot be 0\");\n\n            require(result, \"signature recovery failed\");\n\n        }\n",
          "message": "LibEIP712.recoverSignature (JoinSplitFluid.sol#385-451) is declared view but contains assembly code\n"
        },
        {
          "name": "locked-ether",
          "vulnerability_from_line": 501,
          "vulnerability_to_line": 839,
          "vulnerability_code": "    function() external payable {\n\n        assembly {\n\n            // We don't check for function signatures,\n\n            // there's only one function that ever gets called: validateJoinSplitFluid()\n\n            // We still assume calldata is offset by 4 bytes so that we can represent this contract\n\n            // through a compatible ABI\n\n            validateJoinSplitFluid()\n\n\n\n            /**\n\n             * New calldata map\n\n             * 0x04:0x24      = calldata location of proofData byte array\n\n             * 0x24:0x44      = message sender\n\n             * 0x44:0x64      = h_x\n\n             * 0x64:0x84      = h_y\n\n             * 0x84:0xa4      = t2_x0\n\n             * 0xa4:0xc4      = t2_x1\n\n             * 0xc4:0xe4      = t2_y0\n\n             * 0xe4:0x104     = t2_y1\n\n             * 0x104:0x124    = length of proofData byte array\n\n             * 0x124:0x144    = challenge\n\n             * 0x144:0x164    = offset in byte array to notes\n\n             * 0x164:0x184    = offset in byte array to inputOwners\n\n             * 0x184:0x1a4    = offset in byte array to outputOwners\n\n             * 0x1a4:0x1c4    = offset in byte array to metadata\n\n             */\n\n            function validateJoinSplitFluid() {\n\n                mstore(0x80, calldataload(0x44))\n\n                mstore(0xa0, calldataload(0x64))\n\n                let notes := add(0x104, calldataload(0x144)) // get the length of notes\n\n                let m := 1\n\n                let n := calldataload(notes)\n\n                let gen_order := 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001\n\n                let challenge := mod(calldataload(0x124), gen_order)\n\n\n\n\n\n                // validate m < n\n\n                if gt(m, n) {\n\n                    mstore(0x00, 404)\n\n                    revert(0x00, 0x20)\n\n                }\n\n\n\n                if eq(m, n) {\n\n                    mstore(0x00, 404)\n\n                    revert(0x00, 0x20)\n\n                }\n\n\n\n                let kn := 0\n\n\n\n                // add sender final hash table\n\n                mstore(0x2a0, calldataload(0x24))\n\n                mstore(0x2c0, 0) // add kPublic = 0 to hash table\n\n                mstore(0x2e0, m) // add m to final hash table\n\n\n\n                hashCommitments(notes, n)  // notes = length of proof data array, n = number of notes\n\n                let b := add(0x300, mul(n, 0x80))\n\n\n\n\n\n                // Iterate over every note and calculate the blinding factor B_i = \\gamma_i^{kBar}h^{aBar}\\sigma_i^{-c}.\n\n                // We use the AZTEC protocol pairing optimization to reduce the number of pairing comparisons to 1,\n\n                //  which adds some minor alterations\n\n                for { let i := 0 } lt(i, n) { i := add(i, 0x01) } {\n\n\n\n                // Get the calldata index of this note\n\n                let noteIndex := add(add(notes, 0x20), mul(i, 0xc0))\n\n\n\n                // Define variables k, a and c.\n\n                // If i <= m then\n\n                //   k = kBar_i\n\n                //   a = aBar_i\n\n                //   c = challenge\n\n                // If i > m then we add a modification for the pairing optimization\n\n                //   k = kBar_i * x_i\n\n                //   a = aBar_i * x_i\n\n                //   c = challenge * x_i\n\n                // Set j = i - (m + 1).\n\n                // x_0 = 1\n\n                // x_1 = keccak256(input string)\n\n                // all other x_{j} = keccak256(x_{j-1})\n\n                // The reason for doing this is that the point  \\sigma_i^{-cx_j} can be re-used in the pairing check\n\n                // Instead of validating e(\\gamma_i, t_2) == e(\\sigma_i, g_2) for all i = [m+1,\\ldots,n]\n\n                // We validate e(\\Pi_{i=m+1}^{n}\\gamma_i^{-cx_j}, t_2) == e(\\Pi_{i=m+1}^{n}\\sigma_i^{cx_j}, g_2).\n\n                // x_j is a pseudorandom variable whose entropy source is the input string, allowing for\n\n                // a sum of commitment points to be evaluated in one pairing comparison\n\n                let k\n\n                let a := calldataload(add(noteIndex, 0x20))\n\n                let c := challenge\n\n\n\n                switch eq(add(i, 0x01), n)\n\n                    case 1 {\n\n                        k := kn\n\n                    }\n\n                    case 0 { k := calldataload(noteIndex) }\n\n\n\n\n\n                // Check this commitment is well formed...\n\n                validateCommitment(noteIndex, k, a)\n\n\n\n\n\n                // If i > m then this is an output note.\n\n                // Set k = kx_j, a = ax_j, c = cx_j, where j = i - (m+1)\n\n                switch gt(add(i, 0x01), m)\n\n                case 1 {\n\n                    // before we update k, update kn = \\sum_{i=0}^{m-1}k_i - \\sum_{i=m}^{n-1}k_i\n\n                    kn := addmod(kn, sub(gen_order, k), gen_order)\n\n                    let x := mod(mload(0x00), gen_order)\n\n                    k := mulmod(k, x, gen_order)\n\n                    a := mulmod(a, x, gen_order)\n\n                    c := mulmod(challenge, x, gen_order)\n\n\n\n                    // calculate x_{j+1}\n\n                    mstore(0x00, keccak256(0x00, 0x20))\n\n                }\n\n\n\n                case 0 {\n\n\n\n                    // nothing to do here except update kn = \\sum_{i=0}^{m-1}k_i - \\sum_{i=m}^{n-1}k_i\n\n                    kn := addmod(kn, k, gen_order)\n\n                }\n\n\n\n                // Calculate the G1 element \\gamma_i^{k}h^{a}\\sigma_i^{-c} = B_i\n\n                // Memory map:\n\n                // 0x20: \\gamma_iX\n\n                // 0x40: \\gamma_iY\n\n                // 0x60: k_i\n\n                // 0x80: hX\n\n                // 0xa0: hY\n\n                // 0xc0: a_i\n\n                // 0xe0: \\sigma_iX\n\n                // 0x100: \\sigma_iY\n\n                // 0x120: -c\n\n                calldatacopy(0xe0, add(noteIndex, 0x80), 0x40)\n\n                calldatacopy(0x20, add(noteIndex, 0x40), 0x40)\n\n                mstore(0x120, sub(gen_order, c))\n\n                mstore(0x60, k)\n\n                mstore(0xc0, a)\n\n\n\n                // Call bn128 scalar multiplication precompiles\n\n                // Represent point + multiplication scalar in 3 consecutive blocks of memory\n\n                // Store \\sigma_i^{-c} at 0x1a0:0x200\n\n                // Store \\gamma_i^{k} at 0x120:0x160\n\n                // Store h^{a} at 0x160:0x1a0\n\n                let result := staticcall(gas, 7, 0xe0, 0x60, 0x1a0, 0x40)\n\n                result := and(result, staticcall(gas, 7, 0x20, 0x60, 0x120, 0x40))\n\n                result := and(result, staticcall(gas, 7, 0x80, 0x60, 0x160, 0x40))\n\n\n\n                // Call bn128 group addition precompiles\n\n                // \\gamma_i^{k} and h^{a} in memory block 0x120:0x1a0\n\n                // Store result of addition at 0x160:0x1a0\n\n                result := and(result, staticcall(gas, 6, 0x120, 0x80, 0x160, 0x40))\n\n\n\n                // \\gamma_i^{k}h^{a} and \\sigma^{-c} in memory block 0x160:0x1e0\n\n                // Store resulting point B at memory index b\n\n                result := and(result, staticcall(gas, 6, 0x160, 0x80, b, 0x40))\n\n\n\n                // We have \\sigma^{-c} at 0x1a0:0x200\n\n                // And \\sigma_{acc} at 0x1e0:0x200\n\n                // If i = m + 1 (i.e. first output note)\n\n                // then we set \\gamma_{acc} and \\sigma_{acc} to \\gamma_i, -\\sigma_i\n\n                if eq(i, m) {\n\n                    mstore(0x260, mload(0x20))\n\n                    mstore(0x280, mload(0x40))\n\n                    mstore(0x1e0, mload(0xe0))\n\n                    mstore(0x200, sub(0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47, mload(0x100)))\n\n                }\n\n\n\n                // If i > m + 1 (i.e. subsequent output notes)\n\n                // then we add \\sigma^{-c} and \\sigma_{acc} and store result at \\sigma_{acc} (0x1e0:0x200)\n\n                // we then calculate \\gamma^{cx} and add into \\gamma_{acc}\n\n                if gt(i, m) {\n\n                    mstore(0x60, c)\n\n                    result := and(result, staticcall(gas, 7, 0x20, 0x60, 0x220, 0x40))\n\n\n\n                    // \\gamma_i^{cx} now at 0x220:0x260, \\gamma_{acc} is at 0x260:0x2a0\n\n                    result := and(result, staticcall(gas, 6, 0x220, 0x80, 0x260, 0x40))\n\n\n\n                    // add \\sigma_i^{-cx} and \\sigma_{acc} into \\sigma_{acc} at 0x1e0\n\n                    result := and(result, staticcall(gas, 6, 0x1a0, 0x80, 0x1e0, 0x40))\n\n                }\n\n\n\n\n\n                // throw transaction if any calls to precompiled contracts failed\n\n                if iszero(result) { mstore(0x00, 400) revert(0x00, 0x20) }\n\n                    b := add(b, 0x40) // increase B pointer by 2 words\n\n                }\n\n\n\n                // If the AZTEC protocol is implemented correctly then any input notes were previously outputs of\n\n                // a JoinSplitFluid transaction. We can inductively assume that all input notes\n\n                // are well-formed AZTEC commitments and do not need to validate the implicit range proof\n\n                // This is not the case for any output commitments, so if (m < n) call validatePairing()\n\n                if lt(m, n) {\n\n                    validatePairing(0x84)\n\n                }\n\n\n\n\n\n                // We now have the note commitments and the calculated blinding factors in a block of memory\n\n                // starting at 0x2a0, of size (b - 0x2a0).\n\n                // Hash this block to reconstruct the initial challenge and validate that they match\n\n\n\n                let expected := mod(keccak256(0x2a0, sub(b, 0x2a0)), gen_order)\n\n\n\n                if iszero(eq(expected, challenge)) {\n\n\n\n                    // No! Bad! No soup for you!\n\n                    mstore(0x00, 404)\n\n                    revert(0x00, 0x20)\n\n                }\n\n\n\n                // Great! All done. This is a valid proof, so fall through out of the assembly block\n\n                // so that we can call `ABIEncoder.encodeAndExit`\n\n\n\n            }\n\n\n\n\n\n            /**\n\n             * @dev evaluate if e(P1, t2) . e(P2, g2) == 0.\n\n             * @notice we don't hard-code t2 so that contracts that call this library can use\n\n             * different trusted setups.\n\n             **/\n\n            function validatePairing(t2) {\n\n                let field_order := 0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47\n\n                let t2_x_1 := calldataload(t2)\n\n                let t2_x_2 := calldataload(add(t2, 0x20))\n\n                let t2_y_1 := calldataload(add(t2, 0x40))\n\n                let t2_y_2 := calldataload(add(t2, 0x60))\n\n\n\n                // check provided setup pubkey is not zero or g2\n\n                if or(or(or(or(or(or(or(\n\n                    iszero(t2_x_1),\n\n                    iszero(t2_x_2)),\n\n                    iszero(t2_y_1)),\n\n                    iszero(t2_y_2)),\n\n                    eq(t2_x_1, 0x1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6ed)),\n\n                    eq(t2_x_2, 0x198e9393920d483a7260bfb731fb5d25f1aa493335a9e71297e485b7aef312c2)),\n\n                    eq(t2_y_1, 0x12c85ea5db8c6deb4aab71808dcb408fe3d1e7690c43d37b4ce6cc0166fa7daa)),\n\n                    eq(t2_y_2, 0x90689d0585ff075ec9e99ad690c3395bc4b313370b38ef355acdadcd122975b))\n\n                {\n\n                    mstore(0x00, 400)\n\n                    revert(0x00, 0x20)\n\n                }\n\n\n\n                // store coords in memory\n\n                // indices are a bit off, scipr lab's libff limb ordering (c0, c1) is opposite\n\n                // to what precompile expects\n\n                // We can overwrite the memory we used previously as this function is called at the\n\n                // end of the validation routine.\n\n                mstore(0x20, mload(0x1e0)) // sigma accumulator x\n\n                mstore(0x40, mload(0x200)) // sigma accumulator y\n\n                mstore(0x80, 0x1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6ed)\n\n                mstore(0x60, 0x198e9393920d483a7260bfb731fb5d25f1aa493335a9e71297e485b7aef312c2)\n\n                mstore(0xc0, 0x12c85ea5db8c6deb4aab71808dcb408fe3d1e7690c43d37b4ce6cc0166fa7daa)\n\n                mstore(0xa0, 0x90689d0585ff075ec9e99ad690c3395bc4b313370b38ef355acdadcd122975b)\n\n                mstore(0xe0, mload(0x260)) // gamma accumulator x\n\n                mstore(0x100, mload(0x280)) // gamma accumulator y\n\n                mstore(0x140, t2_x_1)\n\n                mstore(0x120, t2_x_2)\n\n                mstore(0x180, t2_y_1)\n\n                mstore(0x160, t2_y_2)\n\n\n\n                let success := staticcall(gas, 8, 0x20, 0x180, 0x20, 0x20)\n\n\n\n                if or(iszero(success), iszero(mload(0x20))) {\n\n                    mstore(0x00, 400)\n\n                    revert(0x00, 0x20)\n\n                }\n\n\n\n            }\n\n\n\n            /**\n\n             * @dev check that this note's points are on the altbn128 curve(y^2 = x^3 + 3)\n\n             * and that signatures 'k' and 'a' are modulo the order of the curve.\n\n             * Transaction throws if this is not the case.\n\n             * @param note the calldata loation of the note\n\n             **/\n\n            function validateCommitment(note, k, a) {\n\n                let gen_order := 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001\n\n                let field_order := 0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47\n\n                let gammaX := calldataload(add(note, 0x40))\n\n                let gammaY := calldataload(add(note, 0x60))\n\n                let sigmaX := calldataload(add(note, 0x80))\n\n                let sigmaY := calldataload(add(note, 0xa0))\n\n                if iszero(\n\n                    and(\n\n                        and(\n\n                        and(\n\n                            eq(mod(a, gen_order), a), // a is modulo generator order?\n\n                            gt(a, 1)                  // can't be 0 or 1 either!\n\n                        ),\n\n                        and(\n\n                            eq(mod(k, gen_order), k), // k is modulo generator order?\n\n                            gt(k, 1)                  // and not 0 or 1\n\n                        )\n\n                        ),\n\n                        and(\n\n                        eq( // y^2 ?= x^3 + 3\n\n                            addmod(\n\n                                mulmod(mulmod(sigmaX, sigmaX, field_order), sigmaX, field_order),\n\n                                3,\n\n                                field_order\n\n                            ),\n\n                            mulmod(sigmaY, sigmaY, field_order)\n\n                        ),\n\n                        eq( // y^2 ?= x^3 + 3\n\n                            addmod(\n\n                                mulmod(mulmod(gammaX, gammaX, field_order), gammaX, field_order),\n\n                                3,\n\n                                field_order\n\n                            ),\n\n                            mulmod(gammaY, gammaY, field_order)\n\n                        )\n\n                        )\n\n                    )\n\n                ) {\n\n                    mstore(0x00, 400)\n\n                    revert(0x00, 0x20)\n\n                }\n\n            }\n\n\n\n            /**\n\n             * @dev Calculate the keccak256 hash of the commitments for both input notes and output notes.\n\n             * This is used both as an input to validate the challenge `c` and also to\n\n             * generate pseudorandom relationships\n\n             * between commitments for different outputNotes, so that we can combine them\n\n             * into a single multi-exponentiation for the purposes of validating the bilinear pairing relationships.\n\n             * @param notes calldata location notes\n\n             * @param n number of notes\n\n             **/\n\n            function hashCommitments(notes, n) {\n\n                for { let i := 0 } lt(i, n) { i := add(i, 0x01) } {\n\n                let index := add(add(notes, mul(i, 0xc0)), 0x60)\n\n                calldatacopy(add(0x300, mul(i, 0x80)), index, 0x80)\n\n                }\n\n                mstore(0x00, keccak256(0x300, mul(n, 0x80)))\n\n            }\n\n        }\n\n\n\n        // if we've reached here, we've validated the join-split transaction and haven't thrown an error.\n\n        // Encode the output according to the ACE standard and exit.\n\n        JoinSplitFluidABIEncoder.encodeAndExit();\n",
          "message": "Contract locking ether found in JoinSplitFluid.sol:\n\tContract JoinSplitFluid has payable functions:\n\t - fallback (JoinSplitFluid.sol#501-839)\n\tBut does not have a function to withdraw the ether\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 25,
          "vulnerability_to_line": 305,
          "vulnerability_code": "    function encodeAndExit() internal pure {\n\n        assembly {\n\n            // set up initial variables\n\n            let notes := add(0x104, calldataload(0x144))\n\n            let n := calldataload(notes)\n\n            let inputOwners := add(0x124, calldataload(0x164)) // one word after input owners = 1st\n\n            let outputOwners := add(0x124, calldataload(0x184)) // one word after outputOwners = 1st\n\n            let metadata := add(0x144, calldataload(0x1a4)) // two words after metadata = 1st\n\n\n\n            // memory map of `proofOutputs`\n\n\n\n            // `returndata` starts at 0x160\n\n            // `proofOutputs` starts at 0x180\n\n            // 0x160 - 0x180 = relative offset in returndata to first bytes argument (0x20)\n\n            // 0x180 - 0x1a0 = byte length of `proofOutputs`\n\n            // 0x1a0 - 0x1c0 = number of `proofOutputs` entries (2)\n\n            // 0x1c0 - 0x1e0 = relative memory offset between `v` and start of `proofOutput`\n\n\n\n            // `proofOutput A` - t, starts at 0x1e0\n\n            // 0x1e0 - 0x200 = length of `proofOutputA`\n\n            // 0x200 - 0x220 = relative offset between `t` and `inputNotes`\n\n            // 0x220 - 0x240 = relative offset between `t` and `outputNotes`\n\n            // 0x240 - 0x260 = `publicOwner`\n\n            // 0x260 - 0x280 = `publicValue`\n\n            // 0x280 - 0x2a0 = `challenge`\n\n\n\n            // `inputNotes A` starts at 0x2a0\n\n            // structure of `inputNotes` and `outputNotes`\n\n            // 0x00 - 0x20 = byte length of notes array\n\n            // 0x20 - 0x40 = number of notes `i`\n\n            // the next `i` consecutive blocks of 0x20-sized memory contain relative offset between\n\n            // start of notes array and the location of the `note`\n\n\n\n            // `proofOutput B` - r\n\n            // 0x00 - 0x20 = length of `proofOutput B`\n\n            // 0x20 - 0x40 = relative offset between `r` and `inputNotes`\n\n            // 0x40 - 0x60 = relative offset between `r` and `outputNotes`\n\n            // 0x60 - 0x80 = `publicOwner`\n\n            // 0x80 - 0xa0 = `publicValue`\n\n            // 0xa0 - 0xc0 = `challenge`\n\n\n\n            // 'inputNotes B'\n\n            // structure of `inputNotes` and `outputNotes`\n\n            // 0x00 - 0x20 = byte length of notes array\n\n            // 0x20 - 0x40 = number of notes `i`\n\n            // the next `i` consecutive blocks of 0x20-sized memory contain relative offset between\n\n            // start of notes array and the location of the `note`\n\n\n\n            // structure of a `note`\n\n            // 0x00 - 0x20 = size of `note`\n\n            // 0x20 - 0x40 = `noteType`\n\n            // 0x40 - 0x60 = `owner`\n\n            // 0x60 - 0x80 = `noteHash`\n\n            // 0x80 - 0xa0 = size of note `data`\n\n            // 0xa0 - 0xc0 = compressed note coordinate `gamma` (part of `data`)\n\n            // 0xc0 - 0xe0 = compressed note coordinate `sigma` (part of `data`)\n\n            // 0xe0 - ???? = remaining note metadata\n\n\n\n            // `proofOutputs` must form a monolithic block of memory that we can return.\n\n            // `s` points to the memory location of the start of the current note\n\n            // `inputPtr` points to the start of the current `notes` dynamic bytes array\n\n\n\n            // length of proofOutputs is at s\n\n            mstore(0x1a0, 0x02)                            // there are two proofOutput objects for a join-split fluid\n\n            mstore(0x1c0, 0x80)                            // offset to 1st proof\n\n            // 0x1e0 = offset to 2nd proof\n\n            // length of proofOutput is at s + 0x60\n\n            mstore(0x220, 0xc0)                            // location of inputNotes\n\n            mstore(0x260, 0x00)                            // publicOwner is 0\n\n            mstore(0x280, 0x00)                            // publicValue is 0\n\n\n\n            mstore(0x2a0, calldataload(0x124))\n\n\n\n            // set note pointer, offsetting lookup indices for each input note\n\n\n\n            /////////////////// PROOF OUTPUT A: START OF INPUT NOTES //////////////////\n\n            // 0x2c0 = number of bytes in `inputNotes` (leave blank for now)\n\n            // 0x2e0 = number of input notes\n\n            mstore(0x2e0, 0x01)\n\n\n\n            // 0x300 = relative offset to 1st input note (0x60)\n\n            mstore(0x300, 0x60)\n\n\n\n            // Start of inputNote[0]\n\n            // get pointer to metadata\n\n            let metadataIndex := calldataload(metadata)\n\n\n\n            // copy note data to 0x20 - 0xa0\n\n            mstore(0x00, 0x01)\n\n            calldatacopy(0x20, add(notes, 0x120), 0x80) // get gamma, sigma\n\n\n\n            // store note length in `s` = 0x320\n\n            mstore(0x320, 0xc0)\n\n            // store note type (UXTO type, 0x01) in `s + 0x20`\n\n            mstore(0x340, 0x01)\n\n            // store the owner of the note in `s + 0x40`\n\n            mstore(0x360, calldataload(outputOwners))\n\n            // store note hash\n\n            mstore(0x380, keccak256(0x00, 0xa0))\n\n            // store noteData length in `s + 0x80`\n\n            mstore(0x3a0, 0x40)\n\n            // store compressed note coordinate gamma in `s + 0xa0`\n\n            mstore(\n\n                0x3c0,\n\n                or(\n\n                    mload(0x20),\n\n                    shl(255, and(mload(0x40), 0x01))\n\n                )\n\n            )\n\n            // store compressed note coordinate sigma in `s + 0xc0`\n\n            mstore(\n\n                0x3e0,\n\n                or(\n\n                    mload(0x60),\n\n                    shl(255, and(mload(0x80), 0x01))\n\n                )\n\n            )\n\n            // inputNote, so no metaData to store\n\n\n\n            // store relative memory offset to outputNotes\n\n            mstore(0x240, 0x200)\n\n            // store the length of inputNotes at 0x2c0\n\n            mstore(0x2c0, 0x120)\n\n            ///////////////// PROOF OUTPUT A: START OF OUTPUT NOTES (1) ///////////////////\n\n\n\n            // transition between input and output notes\n\n\n\n            // 0x400 + metadataLength = byte length of output notes (0x120)\n\n            // 0x420 + metadataLength = # of output notes (1)\n\n            // 0x440 + metadataLength = offset to outputNotes[0] (0x60)\n\n            let metadataLength := calldataload(add(metadataIndex, sub(metadata, 0x40)))\n\n\n\n            mstore(0x400, add(0x120, metadataLength)) // store length of output notes\n\n            mstore(0x420, 0x01) // store number of output notes\n\n            mstore(0x440, 0x60) // store offset to outputNotes[0]\n\n\n\n            // construct note hash\n\n            // copy 1st note note to 0x20 - 0xa0\n\n            calldatacopy(0x20, add(notes, 0x60), 0x80) // get gamma, sigma\n\n\n\n            // store note length in `s`\n\n            mstore(0x460, add(0xc0, metadataLength))\n\n            // store note type (UXTO type, 0x01) in `s + 0x20`\n\n            mstore(0x480, 0x01)\n\n            // store note owner in `s + 0x40`\n\n            mstore(0x4a0, calldataload(inputOwners))\n\n            // store note hash in `s + 0x60`\n\n            mstore(0x4c0, keccak256(0x00, 0xa0))\n\n            // store note metadata length in `s + 0x80` (just the coordinates)\n\n            mstore(0x4e0, add(0x40, metadataLength))\n\n            // store compressed note coordinate gamma in `s + 0xa0`\n\n            mstore(\n\n                0x500,\n\n                or(\n\n                    mload(0x20),\n\n                    shl(255, and(mload(0x40), 0x01))\n\n                )\n\n            )\n\n            // store compressed note coordinate sigma in `s + 0xc0`\n\n            mstore(\n\n                0x520,\n\n                or(\n\n                    mload(0x60),\n\n                    shl(255, and(mload(0x80), 0x01))\n\n                )\n\n            )\n\n\n\n            calldatacopy(0x540, add(metadataIndex, sub(metadata, 0x20)), metadataLength)\n\n\n\n            // compute the relative offset to index this note in our returndata\n\n            mstore(add(0x440, 0), 0x60) // relative offset to note\n\n\n\n            // now we need to transition between first and second proofOutput\n\n            // s is going to point to the end of the outputNotes array\n\n            // so, s is our absolute pointer to the start of the 2nd proofOutputs entry\n\n            // we know that 'proofOutputs' starts at 0x180\n\n            // so (s - 0x180) = relative offset to second proofOutputs entry\n\n            let startOfProofOutput := add(0x540, metadataLength)\n\n\n\n            // proofOutput[0].length = start of proofOutput[1] - start of proofOutput[0] - 0x20\n\n            // proofOutput[0].length = (0x540 + metadataLength) - 0x200 - 0x20 = 0x320 + metadataLength\n\n            mstore(0x200, add(0x320, metadataLength)) // length of proofOutput\n\n            mstore(0x1e0, add(0x3c0, metadataLength)) // offset to get to second proofOutput\n\n\n\n            // s points to the start of proofOutputs[0]\n\n            let s := startOfProofOutput\n\n            mstore(add(s, 0x20), 0xc0)   // location of inputNotes\n\n            mstore(add(s, 0x40), 0x100)  // location of outputNotes\n\n            mstore(add(s, 0x60), 0x00)   // publicOwner\n\n            mstore(add(s, 0x80), 0x00)   // publicValue\n\n\n\n            // compute challenge = kecck256(challenge)\n\n            mstore(0x20, calldataload(0x124))\n\n            mstore(add(s, 0xa0), keccak256(0x20, 0x20)) // challenge\n\n            // 0x00 length of proofOutput\n\n            // 0x20 location of inputNotes\n\n            // 0x40 location of outputNotes\n\n            // 0x60 publicOwner\n\n            // 0x80 publicValue\n\n            // 0xa0 = inputNoteData\n\n            mstore(add(s, 0xc0), 0x20) // length of input notes array (1 word)\n\n            mstore(add(s, 0xe0), 0x00) // number of entries (0 words)\n\n\n\n            // set notesPtr = proofOutputs[1].outputNotes\n\n            let notesPtr := add(s, 0x100)\n\n\n\n            // s + 0x20 = number of notes = n - 2\n\n            mstore(add(notesPtr, 0x20), sub(n, 2))\n\n\n\n            // set s to point to proofOutputs[1].outputNotes[0]\n\n            s := add(add(s, 0x140), mul(0x20, sub(n, 2)))\n\n\n\n            // Output notes:\n\n            // first output note needs to go into the first proofOutput object\n\n            // second output note onwards, needs to go into the second proofOutput object\n\n            for { let i := 0x02 } lt(i, n) { i := add(i, 0x01) } {\n\n\n\n            /////////////////// START OF PROOF OUTPUT B  ////////////////////\n\n\n\n                // get pointer to metadata\n\n                metadataIndex := calldataload(add(metadata, mul(sub(i, 0x01), 0x20)))\n\n                // get size of metadata\n\n                metadataLength := calldataload(add(sub(metadata, 0x40), metadataIndex))\n\n\n\n                mstore(0x00, 0x01)\n\n                // copy note data to 0x20 - 0xa0\n\n                calldatacopy(\n\n                    0x20,\n\n                    add(add(notes, 0x60), mul(i, 0xc0)),\n\n                    0x80\n\n                ) // get gamma, sigma\n\n\n\n                // store note length in `s`\n\n                mstore(s, add(0xc0, metadataLength))\n\n                // store note type (UXTO type, 0x01) in `s + 0x20`\n\n                mstore(add(s, 0x20), 0x01)\n\n                // store the owner of the note in `s + 0x40`\n\n                mstore(add(s, 0x40), calldataload(add(outputOwners, mul(sub(i, 0x01), 0x20))))\n\n                // store note hash\n\n                mstore(add(s, 0x60), keccak256(0x00, 0xa0))\n\n                // store note metadata length if `s + 0x80`\n\n                mstore(add(s, 0x80), add(0x40, metadataLength))\n\n                // store compressed note coordinate gamma in `s + 0xa0`\n\n                mstore(\n\n                    add(s, 0xa0),\n\n                    or(\n\n                        mload(0x20),\n\n                        shl(255, and(mload(0x40), 0x01))\n\n                    )\n\n                )\n\n                // store compressed note coordinate sigma in `s + 0xc0`\n\n                mstore(\n\n                    add(s, 0xc0),\n\n                    or(\n\n                        mload(0x60),\n\n                        shl(255, and(mload(0x80), 0x01))\n\n                    )\n\n                )\n\n                // copy metadata into `s + 0xe0`\n\n                calldatacopy(add(s, 0xe0), add(metadataIndex, sub(metadata, 0x20)), metadataLength)\n\n                // compute the relative offset to index this note in our returndata\n\n                mstore(add(notesPtr, mul(i, 0x20)), sub(s, notesPtr)) // relative offset to note\n\n\n\n                // increase s by note length\n\n                s := add(s, add(mload(s), 0x20))\n\n            }\n\n\n\n            // inputPtr used to point to start of inputNotes for proofOutputs[0]\n\n            // now we want inputPtr to point to start of inputNotes for proofOutputs[1]\n\n            // 1. length of proofOutput\n\n            // 2. length of outputNotes\n\n            // length of outputNotes = s - inputPtr, stored at inputPtr\n\n            mstore(notesPtr, sub(sub(s, notesPtr), 0x20)) // store length of outputNotes at start of outputNotes\n\n            // length of proofOutput\n\n            let proofOutputLength := sub(s, startOfProofOutput)\n\n            mstore(startOfProofOutput, sub(proofOutputLength, 0x20))\n\n            mstore(0x180, sub(s, 0x1a0)) // store length of proofOutputs at 0x100\n\n            mstore(0x160, 0x20)\n\n            return(0x160, sub(s, 0x160)) // return the final byte array\n\n        }\n",
          "message": "JoinSplitFluidABIEncoder.encodeAndExit uses assembly (JoinSplitFluid.sol#25-305)\n\t- JoinSplitFluid.sol#26-304\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 353,
          "vulnerability_to_line": 379,
          "vulnerability_code": "    function hashEIP712Message(bytes32 _hashStruct)\n\n        internal\n\n        view\n\n        returns (bytes32 _result)\n\n    {\n\n        bytes32 eip712DomainHash = EIP712_DOMAIN_HASH;\n\n\n\n        // Assembly for more efficient computing:\n\n        // keccak256(abi.encodePacked(\n\n        //     EIP191_HEADER,\n\n        //     EIP712_DOMAIN_HASH,\n\n        //     hashStruct\n\n        // ));\n\n\n\n        assembly {\n\n            // Load free memory pointer. We're not going to use it - we're going to overwrite it!\n\n            // We need 0x60 bytes of memory for this hash,\n\n            // cheaper to overwrite the free memory pointer at 0x40, and then replace it, than allocating free memory\n\n            let memPtr := mload(0x40)\n\n            mstore(0x00, 0x1901)               // EIP191 header\n\n            mstore(0x20, eip712DomainHash)     // EIP712 domain hash\n\n            mstore(0x40, _hashStruct)          // Hash of struct\n\n            _result := keccak256(0x1e, 0x42)   // compute hash\n\n            // replace memory pointer\n\n            mstore(0x40, memPtr)\n\n        }\n",
          "message": "LibEIP712.hashEIP712Message uses assembly (JoinSplitFluid.sol#353-379)\n\t- JoinSplitFluid.sol#367-378\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 385,
          "vulnerability_to_line": 451,
          "vulnerability_code": "    function recoverSignature(\n\n        bytes32 _message,\n\n        bytes memory _signature\n\n    ) internal view returns (address _signer) {\n\n        bool result;\n\n        assembly {\n\n            // Here's a little trick we can pull. We expect `_signature` to be a byte array, of length 0x60, with\n\n            // 'v', 'r' and 's' located linearly in memory. Preceeding this is the length parameter of `_signature`.\n\n            // We *replace* the length param with the signature msg to get a memory block formatted for the precompile\n\n            // load length as a temporary variable\n\n\n\n            let byteLength := mload(_signature)\n\n\n\n            // store the signature message\n\n            mstore(_signature, _message)\n\n\n\n            // load 'v' - we need it for a condition check\n\n            let v := mload(add(_signature, 0x60))\n\n            v := shr(248, v) // bitshifting, to resemble padLeft\n\n\n\n            /**\n\n            * Original memory map for input to precompile\n\n            *\n\n            * _signature : _signature + 0x20            message \n\n            * _signature + 0x20 : _signature + 0x40     r\n\n            * _signature + 0x40 : _signature + 0x60     s\n\n            * _signature + 0x60 : _signature + 0x80     v\n\n\n\n            * Desired memory map for input to precompile\n\n            *\n\n            * _signature : _signature + 0x20            message \n\n            * _signature + 0x20 : _signature + 0x40     v\n\n            * _signature + 0x40 : _signature + 0x60     r\n\n            * _signature + 0x60 : _signature + 0x80     s\n\n            */\n\n\n\n            // move s to v position\n\n            mstore(add(_signature, 0x60), mload(add(_signature, 0x40)))\n\n            // move r to s position\n\n            mstore(add(_signature, 0x40), mload(add(_signature, 0x20)))\n\n            // move v to r position\n\n            mstore(add(_signature, 0x20), v)\n\n            result := and(\n\n                and(\n\n                    // validate signature length == 0x41 or 0x60 bytes. \n\n                    // will be 0x41 if one signature was provided, 0x60 if multiple signatures \n\n                    // have been provided - due to the relevant signature creation functions\n\n                    or(eq(byteLength, 0x41), eq(byteLength, 0x60)),\n\n                    // validate v == 27 or v == 28\n\n                    or(eq(v, 27), eq(v, 28))\n\n                ),\n\n                // validate call to precompile succeeds\n\n                staticcall(gas, 0x01, _signature, 0x80, _signature, 0x20) \n\n            )\n\n            // save the _signer only if the first word in _signature is not `_message` anymore\n\n            switch eq(_message, mload(_signature))\n\n            case 0 {\n\n                _signer := mload(_signature)\n\n            }\n\n            mstore(_signature, byteLength) // and put the byte length back where it belongs\n\n        }\n\n        // wrap Failure States in a single if test, so that happy path only has 1 conditional jump\n\n        if (!(result && (_signer != address(0x0)))) {\n\n            require(_signer != address(0x0), \"signer address cannot be 0\");\n\n            require(result, \"signature recovery failed\");\n\n        }\n",
          "message": "LibEIP712.recoverSignature uses assembly (JoinSplitFluid.sol#385-451)\n\t- JoinSplitFluid.sol#390-445\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 501,
          "vulnerability_to_line": 839,
          "vulnerability_code": "    function() external payable {\n\n        assembly {\n\n            // We don't check for function signatures,\n\n            // there's only one function that ever gets called: validateJoinSplitFluid()\n\n            // We still assume calldata is offset by 4 bytes so that we can represent this contract\n\n            // through a compatible ABI\n\n            validateJoinSplitFluid()\n\n\n\n            /**\n\n             * New calldata map\n\n             * 0x04:0x24      = calldata location of proofData byte array\n\n             * 0x24:0x44      = message sender\n\n             * 0x44:0x64      = h_x\n\n             * 0x64:0x84      = h_y\n\n             * 0x84:0xa4      = t2_x0\n\n             * 0xa4:0xc4      = t2_x1\n\n             * 0xc4:0xe4      = t2_y0\n\n             * 0xe4:0x104     = t2_y1\n\n             * 0x104:0x124    = length of proofData byte array\n\n             * 0x124:0x144    = challenge\n\n             * 0x144:0x164    = offset in byte array to notes\n\n             * 0x164:0x184    = offset in byte array to inputOwners\n\n             * 0x184:0x1a4    = offset in byte array to outputOwners\n\n             * 0x1a4:0x1c4    = offset in byte array to metadata\n\n             */\n\n            function validateJoinSplitFluid() {\n\n                mstore(0x80, calldataload(0x44))\n\n                mstore(0xa0, calldataload(0x64))\n\n                let notes := add(0x104, calldataload(0x144)) // get the length of notes\n\n                let m := 1\n\n                let n := calldataload(notes)\n\n                let gen_order := 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001\n\n                let challenge := mod(calldataload(0x124), gen_order)\n\n\n\n\n\n                // validate m < n\n\n                if gt(m, n) {\n\n                    mstore(0x00, 404)\n\n                    revert(0x00, 0x20)\n\n                }\n\n\n\n                if eq(m, n) {\n\n                    mstore(0x00, 404)\n\n                    revert(0x00, 0x20)\n\n                }\n\n\n\n                let kn := 0\n\n\n\n                // add sender final hash table\n\n                mstore(0x2a0, calldataload(0x24))\n\n                mstore(0x2c0, 0) // add kPublic = 0 to hash table\n\n                mstore(0x2e0, m) // add m to final hash table\n\n\n\n                hashCommitments(notes, n)  // notes = length of proof data array, n = number of notes\n\n                let b := add(0x300, mul(n, 0x80))\n\n\n\n\n\n                // Iterate over every note and calculate the blinding factor B_i = \\gamma_i^{kBar}h^{aBar}\\sigma_i^{-c}.\n\n                // We use the AZTEC protocol pairing optimization to reduce the number of pairing comparisons to 1,\n\n                //  which adds some minor alterations\n\n                for { let i := 0 } lt(i, n) { i := add(i, 0x01) } {\n\n\n\n                // Get the calldata index of this note\n\n                let noteIndex := add(add(notes, 0x20), mul(i, 0xc0))\n\n\n\n                // Define variables k, a and c.\n\n                // If i <= m then\n\n                //   k = kBar_i\n\n                //   a = aBar_i\n\n                //   c = challenge\n\n                // If i > m then we add a modification for the pairing optimization\n\n                //   k = kBar_i * x_i\n\n                //   a = aBar_i * x_i\n\n                //   c = challenge * x_i\n\n                // Set j = i - (m + 1).\n\n                // x_0 = 1\n\n                // x_1 = keccak256(input string)\n\n                // all other x_{j} = keccak256(x_{j-1})\n\n                // The reason for doing this is that the point  \\sigma_i^{-cx_j} can be re-used in the pairing check\n\n                // Instead of validating e(\\gamma_i, t_2) == e(\\sigma_i, g_2) for all i = [m+1,\\ldots,n]\n\n                // We validate e(\\Pi_{i=m+1}^{n}\\gamma_i^{-cx_j}, t_2) == e(\\Pi_{i=m+1}^{n}\\sigma_i^{cx_j}, g_2).\n\n                // x_j is a pseudorandom variable whose entropy source is the input string, allowing for\n\n                // a sum of commitment points to be evaluated in one pairing comparison\n\n                let k\n\n                let a := calldataload(add(noteIndex, 0x20))\n\n                let c := challenge\n\n\n\n                switch eq(add(i, 0x01), n)\n\n                    case 1 {\n\n                        k := kn\n\n                    }\n\n                    case 0 { k := calldataload(noteIndex) }\n\n\n\n\n\n                // Check this commitment is well formed...\n\n                validateCommitment(noteIndex, k, a)\n\n\n\n\n\n                // If i > m then this is an output note.\n\n                // Set k = kx_j, a = ax_j, c = cx_j, where j = i - (m+1)\n\n                switch gt(add(i, 0x01), m)\n\n                case 1 {\n\n                    // before we update k, update kn = \\sum_{i=0}^{m-1}k_i - \\sum_{i=m}^{n-1}k_i\n\n                    kn := addmod(kn, sub(gen_order, k), gen_order)\n\n                    let x := mod(mload(0x00), gen_order)\n\n                    k := mulmod(k, x, gen_order)\n\n                    a := mulmod(a, x, gen_order)\n\n                    c := mulmod(challenge, x, gen_order)\n\n\n\n                    // calculate x_{j+1}\n\n                    mstore(0x00, keccak256(0x00, 0x20))\n\n                }\n\n\n\n                case 0 {\n\n\n\n                    // nothing to do here except update kn = \\sum_{i=0}^{m-1}k_i - \\sum_{i=m}^{n-1}k_i\n\n                    kn := addmod(kn, k, gen_order)\n\n                }\n\n\n\n                // Calculate the G1 element \\gamma_i^{k}h^{a}\\sigma_i^{-c} = B_i\n\n                // Memory map:\n\n                // 0x20: \\gamma_iX\n\n                // 0x40: \\gamma_iY\n\n                // 0x60: k_i\n\n                // 0x80: hX\n\n                // 0xa0: hY\n\n                // 0xc0: a_i\n\n                // 0xe0: \\sigma_iX\n\n                // 0x100: \\sigma_iY\n\n                // 0x120: -c\n\n                calldatacopy(0xe0, add(noteIndex, 0x80), 0x40)\n\n                calldatacopy(0x20, add(noteIndex, 0x40), 0x40)\n\n                mstore(0x120, sub(gen_order, c))\n\n                mstore(0x60, k)\n\n                mstore(0xc0, a)\n\n\n\n                // Call bn128 scalar multiplication precompiles\n\n                // Represent point + multiplication scalar in 3 consecutive blocks of memory\n\n                // Store \\sigma_i^{-c} at 0x1a0:0x200\n\n                // Store \\gamma_i^{k} at 0x120:0x160\n\n                // Store h^{a} at 0x160:0x1a0\n\n                let result := staticcall(gas, 7, 0xe0, 0x60, 0x1a0, 0x40)\n\n                result := and(result, staticcall(gas, 7, 0x20, 0x60, 0x120, 0x40))\n\n                result := and(result, staticcall(gas, 7, 0x80, 0x60, 0x160, 0x40))\n\n\n\n                // Call bn128 group addition precompiles\n\n                // \\gamma_i^{k} and h^{a} in memory block 0x120:0x1a0\n\n                // Store result of addition at 0x160:0x1a0\n\n                result := and(result, staticcall(gas, 6, 0x120, 0x80, 0x160, 0x40))\n\n\n\n                // \\gamma_i^{k}h^{a} and \\sigma^{-c} in memory block 0x160:0x1e0\n\n                // Store resulting point B at memory index b\n\n                result := and(result, staticcall(gas, 6, 0x160, 0x80, b, 0x40))\n\n\n\n                // We have \\sigma^{-c} at 0x1a0:0x200\n\n                // And \\sigma_{acc} at 0x1e0:0x200\n\n                // If i = m + 1 (i.e. first output note)\n\n                // then we set \\gamma_{acc} and \\sigma_{acc} to \\gamma_i, -\\sigma_i\n\n                if eq(i, m) {\n\n                    mstore(0x260, mload(0x20))\n\n                    mstore(0x280, mload(0x40))\n\n                    mstore(0x1e0, mload(0xe0))\n\n                    mstore(0x200, sub(0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47, mload(0x100)))\n\n                }\n\n\n\n                // If i > m + 1 (i.e. subsequent output notes)\n\n                // then we add \\sigma^{-c} and \\sigma_{acc} and store result at \\sigma_{acc} (0x1e0:0x200)\n\n                // we then calculate \\gamma^{cx} and add into \\gamma_{acc}\n\n                if gt(i, m) {\n\n                    mstore(0x60, c)\n\n                    result := and(result, staticcall(gas, 7, 0x20, 0x60, 0x220, 0x40))\n\n\n\n                    // \\gamma_i^{cx} now at 0x220:0x260, \\gamma_{acc} is at 0x260:0x2a0\n\n                    result := and(result, staticcall(gas, 6, 0x220, 0x80, 0x260, 0x40))\n\n\n\n                    // add \\sigma_i^{-cx} and \\sigma_{acc} into \\sigma_{acc} at 0x1e0\n\n                    result := and(result, staticcall(gas, 6, 0x1a0, 0x80, 0x1e0, 0x40))\n\n                }\n\n\n\n\n\n                // throw transaction if any calls to precompiled contracts failed\n\n                if iszero(result) { mstore(0x00, 400) revert(0x00, 0x20) }\n\n                    b := add(b, 0x40) // increase B pointer by 2 words\n\n                }\n\n\n\n                // If the AZTEC protocol is implemented correctly then any input notes were previously outputs of\n\n                // a JoinSplitFluid transaction. We can inductively assume that all input notes\n\n                // are well-formed AZTEC commitments and do not need to validate the implicit range proof\n\n                // This is not the case for any output commitments, so if (m < n) call validatePairing()\n\n                if lt(m, n) {\n\n                    validatePairing(0x84)\n\n                }\n\n\n\n\n\n                // We now have the note commitments and the calculated blinding factors in a block of memory\n\n                // starting at 0x2a0, of size (b - 0x2a0).\n\n                // Hash this block to reconstruct the initial challenge and validate that they match\n\n\n\n                let expected := mod(keccak256(0x2a0, sub(b, 0x2a0)), gen_order)\n\n\n\n                if iszero(eq(expected, challenge)) {\n\n\n\n                    // No! Bad! No soup for you!\n\n                    mstore(0x00, 404)\n\n                    revert(0x00, 0x20)\n\n                }\n\n\n\n                // Great! All done. This is a valid proof, so fall through out of the assembly block\n\n                // so that we can call `ABIEncoder.encodeAndExit`\n\n\n\n            }\n\n\n\n\n\n            /**\n\n             * @dev evaluate if e(P1, t2) . e(P2, g2) == 0.\n\n             * @notice we don't hard-code t2 so that contracts that call this library can use\n\n             * different trusted setups.\n\n             **/\n\n            function validatePairing(t2) {\n\n                let field_order := 0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47\n\n                let t2_x_1 := calldataload(t2)\n\n                let t2_x_2 := calldataload(add(t2, 0x20))\n\n                let t2_y_1 := calldataload(add(t2, 0x40))\n\n                let t2_y_2 := calldataload(add(t2, 0x60))\n\n\n\n                // check provided setup pubkey is not zero or g2\n\n                if or(or(or(or(or(or(or(\n\n                    iszero(t2_x_1),\n\n                    iszero(t2_x_2)),\n\n                    iszero(t2_y_1)),\n\n                    iszero(t2_y_2)),\n\n                    eq(t2_x_1, 0x1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6ed)),\n\n                    eq(t2_x_2, 0x198e9393920d483a7260bfb731fb5d25f1aa493335a9e71297e485b7aef312c2)),\n\n                    eq(t2_y_1, 0x12c85ea5db8c6deb4aab71808dcb408fe3d1e7690c43d37b4ce6cc0166fa7daa)),\n\n                    eq(t2_y_2, 0x90689d0585ff075ec9e99ad690c3395bc4b313370b38ef355acdadcd122975b))\n\n                {\n\n                    mstore(0x00, 400)\n\n                    revert(0x00, 0x20)\n\n                }\n\n\n\n                // store coords in memory\n\n                // indices are a bit off, scipr lab's libff limb ordering (c0, c1) is opposite\n\n                // to what precompile expects\n\n                // We can overwrite the memory we used previously as this function is called at the\n\n                // end of the validation routine.\n\n                mstore(0x20, mload(0x1e0)) // sigma accumulator x\n\n                mstore(0x40, mload(0x200)) // sigma accumulator y\n\n                mstore(0x80, 0x1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6ed)\n\n                mstore(0x60, 0x198e9393920d483a7260bfb731fb5d25f1aa493335a9e71297e485b7aef312c2)\n\n                mstore(0xc0, 0x12c85ea5db8c6deb4aab71808dcb408fe3d1e7690c43d37b4ce6cc0166fa7daa)\n\n                mstore(0xa0, 0x90689d0585ff075ec9e99ad690c3395bc4b313370b38ef355acdadcd122975b)\n\n                mstore(0xe0, mload(0x260)) // gamma accumulator x\n\n                mstore(0x100, mload(0x280)) // gamma accumulator y\n\n                mstore(0x140, t2_x_1)\n\n                mstore(0x120, t2_x_2)\n\n                mstore(0x180, t2_y_1)\n\n                mstore(0x160, t2_y_2)\n\n\n\n                let success := staticcall(gas, 8, 0x20, 0x180, 0x20, 0x20)\n\n\n\n                if or(iszero(success), iszero(mload(0x20))) {\n\n                    mstore(0x00, 400)\n\n                    revert(0x00, 0x20)\n\n                }\n\n\n\n            }\n\n\n\n            /**\n\n             * @dev check that this note's points are on the altbn128 curve(y^2 = x^3 + 3)\n\n             * and that signatures 'k' and 'a' are modulo the order of the curve.\n\n             * Transaction throws if this is not the case.\n\n             * @param note the calldata loation of the note\n\n             **/\n\n            function validateCommitment(note, k, a) {\n\n                let gen_order := 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001\n\n                let field_order := 0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47\n\n                let gammaX := calldataload(add(note, 0x40))\n\n                let gammaY := calldataload(add(note, 0x60))\n\n                let sigmaX := calldataload(add(note, 0x80))\n\n                let sigmaY := calldataload(add(note, 0xa0))\n\n                if iszero(\n\n                    and(\n\n                        and(\n\n                        and(\n\n                            eq(mod(a, gen_order), a), // a is modulo generator order?\n\n                            gt(a, 1)                  // can't be 0 or 1 either!\n\n                        ),\n\n                        and(\n\n                            eq(mod(k, gen_order), k), // k is modulo generator order?\n\n                            gt(k, 1)                  // and not 0 or 1\n\n                        )\n\n                        ),\n\n                        and(\n\n                        eq( // y^2 ?= x^3 + 3\n\n                            addmod(\n\n                                mulmod(mulmod(sigmaX, sigmaX, field_order), sigmaX, field_order),\n\n                                3,\n\n                                field_order\n\n                            ),\n\n                            mulmod(sigmaY, sigmaY, field_order)\n\n                        ),\n\n                        eq( // y^2 ?= x^3 + 3\n\n                            addmod(\n\n                                mulmod(mulmod(gammaX, gammaX, field_order), gammaX, field_order),\n\n                                3,\n\n                                field_order\n\n                            ),\n\n                            mulmod(gammaY, gammaY, field_order)\n\n                        )\n\n                        )\n\n                    )\n\n                ) {\n\n                    mstore(0x00, 400)\n\n                    revert(0x00, 0x20)\n\n                }\n\n            }\n\n\n\n            /**\n\n             * @dev Calculate the keccak256 hash of the commitments for both input notes and output notes.\n\n             * This is used both as an input to validate the challenge `c` and also to\n\n             * generate pseudorandom relationships\n\n             * between commitments for different outputNotes, so that we can combine them\n\n             * into a single multi-exponentiation for the purposes of validating the bilinear pairing relationships.\n\n             * @param notes calldata location notes\n\n             * @param n number of notes\n\n             **/\n\n            function hashCommitments(notes, n) {\n\n                for { let i := 0 } lt(i, n) { i := add(i, 0x01) } {\n\n                let index := add(add(notes, mul(i, 0xc0)), 0x60)\n\n                calldatacopy(add(0x300, mul(i, 0x80)), index, 0x80)\n\n                }\n\n                mstore(0x00, keccak256(0x300, mul(n, 0x80)))\n\n            }\n\n        }\n\n\n\n        // if we've reached here, we've validated the join-split transaction and haven't thrown an error.\n\n        // Encode the output according to the ACE standard and exit.\n\n        JoinSplitFluidABIEncoder.encodeAndExit();\n",
          "message": "JoinSplitFluid.fallback uses assembly (JoinSplitFluid.sol#501-839)\n\t- JoinSplitFluid.sol#502-834\n"
        },
        {
          "name": "solc-version",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
          "message": "Detected issues with version pragma in JoinSplitFluid.sol:\n\t- pragma solidity>=0.5.0<0.6.0 (JoinSplitFluid.sol#3): it allows old versions\n\t- pragma solidity>=0.5.0<0.6.0 (JoinSplitFluid.sol#310): it allows old versions\n\t- pragma solidity>=0.5.0<0.6.0 (JoinSplitFluid.sol#456): it allows old versions\n\t- pragma solidity>=0.5.0<0.6.0 (JoinSplitFluid.sol#476): it allows old versions\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 337,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bytes32 public EIP712_DOMAIN_HASH;\n",
          "message": "Variable 'LibEIP712.EIP712_DOMAIN_HASH' (JoinSplitFluid.sol#337) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 464,
          "vulnerability_to_line": null,
          "vulnerability_code": "        bytes calldata, // proof data\n",
          "message": "Parameter '' of JoinSplitFluidInterface.validateJoinSplitFluid (JoinSplitFluid.sol#464) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 465,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address, // sender address\n",
          "message": "Parameter '_scope_0' of JoinSplitFluidInterface.validateJoinSplitFluid (JoinSplitFluid.sol#465) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 466,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint[6] calldata // common reference string\n",
          "message": "Parameter '_scope_1' of JoinSplitFluidInterface.validateJoinSplitFluid (JoinSplitFluid.sol#466) is not in mixedCase\n"
        }
      ]
    },
    "smartcheck": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 447,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (!(result && (_signer != address(0x0)))) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 448,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(_signer != address(0x0), \"signer address cannot be 0\");\n",
          "message": null
        },
        {
          "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
          "vulnerability_from_line": 463,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function validateJoinSplitFluid(\n",
          "message": null
        },
        {
          "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
          "vulnerability_from_line": 353,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function hashEIP712Message(bytes32 _hashStruct)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
          "vulnerability_from_line": 385,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function recoverSignature(\n",
          "message": null
        },
        {
          "name": "SOLIDITY_LOCKED_MONEY",
          "vulnerability_from_line": 491,
          "vulnerability_to_line": null,
          "vulnerability_code": "contract JoinSplitFluid is LibEIP712 {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 310,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 310,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 456,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 456,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 476,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 476,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 25,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function encodeAndExit() internal pure {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
          "vulnerability_from_line": 353,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function hashEIP712Message(bytes32 _hashStruct)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
          "vulnerability_from_line": 385,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function recoverSignature(\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 26,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 367,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 390,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 502,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        }
      ]
    },
    "oyente": {
      "successfull_analysis": false,
      "errors": [
        "exception (RuntimeError: Source map error, unknown name(SHR) or instr_name(INVALID))"
      ],
      "vulnerability_findings": []
    },
    "mythril": {
      "successfull_analysis": false,
      "errors": [
        "Solc experienced a fatal error"
      ],
      "vulnerability_findings": []
    },
    "osiris": {
      "successfull_analysis": false,
      "errors": [
        "Solidity compilation failed"
      ],
      "vulnerability_findings": []
    }
  }
}