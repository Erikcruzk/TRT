{
  "smartbugs_completed": true,
  "analyzer_results": {
    "semgrep": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 63,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(valid, \"AZTEC array index is out of bounds\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 63,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(valid, \"AZTEC array index is out of bounds\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        }
      ]
    },
    "slither": {
      "successfull_analysis": true,
      "errors": [
        "EXIT_CODE_26"
      ],
      "vulnerability_findings": [
        {
          "name": "constant-function",
          "vulnerability_from_line": 20,
          "vulnerability_to_line": 28,
          "vulnerability_code": "    function getLength(bytes memory _proofOutputsOrNotes) internal pure returns (\n\n        uint len\n\n    ) {\n\n        assembly {\n\n            // first word = the raw byte length\n\n            // second word = the actual number of entries (hence the 0x20 offset)\n\n            len := mload(add(_proofOutputsOrNotes, 0x20))\n\n        }\n",
          "message": "NoteUtils.getLength (NoteUtilsTest.sol#20-28) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 36,
          "vulnerability_to_line": 64,
          "vulnerability_code": "    function get(bytes memory _proofOutputsOrNotes, uint _i) internal pure returns (\n\n        bytes memory out\n\n    ) {\n\n        bool valid;\n\n        assembly {\n\n            // check that i < the number of entries\n\n            valid := lt(\n\n                _i,\n\n                mload(add(_proofOutputsOrNotes, 0x20))\n\n            )\n\n            // memory map of the array is as follows:\n\n            // 0x00 - 0x20 : byte length of array\n\n            // 0x20 - 0x40 : n, the number of entries\n\n            // 0x40 - 0x40 + (0x20 * i) : relative memory offset to start of i'th entry (i <= n)\n\n\n\n            // Step 1: compute location of relative memory offset: _proofOutputsOrNotes + 0x40 + (0x20 * i) \n\n            // Step 2: loaded relative offset and add to _proofOutputsOrNotes to get absolute memory location\n\n            out := add(\n\n                mload(\n\n                    add(\n\n                        add(_proofOutputsOrNotes, 0x40),\n\n                        mul(_i, 0x20)\n\n                    )\n\n                ),\n\n                _proofOutputsOrNotes\n\n            )\n\n        }\n\n        require(valid, \"AZTEC array index is out of bounds\");\n",
          "message": "NoteUtils.get (NoteUtilsTest.sol#36-64) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 76,
          "vulnerability_to_line": 98,
          "vulnerability_code": "    function extractProofOutput(bytes memory _proofOutput) internal pure returns (\n\n        bytes memory inputNotes,\n\n        bytes memory outputNotes,\n\n        address publicOwner,\n\n        int256 publicValue\n\n    ) {\n\n        assembly {\n\n            // memory map of a proofOutput:\n\n            // 0x00 - 0x20 : byte length of proofOutput\n\n            // 0x20 - 0x40 : relative offset to inputNotes\n\n            // 0x40 - 0x60 : relative offset to outputNotes\n\n            // 0x60 - 0x80 : publicOwner\n\n            // 0x80 - 0xa0 : publicValue\n\n            // 0xa0 - 0xc0 : challenge\n\n            inputNotes := add(_proofOutput, mload(add(_proofOutput, 0x20)))\n\n            outputNotes := add(_proofOutput, mload(add(_proofOutput, 0x40)))\n\n            publicOwner := and(\n\n                mload(add(_proofOutput, 0x60)),\n\n                0xffffffffffffffffffffffffffffffffffffffff\n\n            )\n\n            publicValue := mload(add(_proofOutput, 0x80))\n\n        }\n",
          "message": "NoteUtils.extractProofOutput (NoteUtilsTest.sol#76-98) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 105,
          "vulnerability_to_line": 111,
          "vulnerability_code": "    function extractChallenge(bytes memory _proofOutput) internal pure returns (\n\n        bytes32 challenge\n\n    ) {\n\n        assembly {\n\n            challenge := mload(add(_proofOutput, 0xa0))\n\n        }\n",
          "message": "NoteUtils.extractChallenge (NoteUtilsTest.sol#105-111) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 120,
          "vulnerability_to_line": 139,
          "vulnerability_code": "    function extractNote(bytes memory _note) internal pure returns (\n\n            address owner,\n\n            bytes32 noteHash,\n\n            bytes memory metadata\n\n    ) {\n\n        assembly {\n\n            // memory map of a note:\n\n            // 0x00 - 0x20 : byte length of note\n\n            // 0x20 - 0x40 : note type\n\n            // 0x40 - 0x60 : owner\n\n            // 0x60 - 0x80 : noteHash\n\n            // 0x80 - 0xa0 : start of metadata byte array\n\n            owner := and(\n\n                mload(add(_note, 0x40)),\n\n                0xffffffffffffffffffffffffffffffffffffffff\n\n            )\n\n            noteHash := mload(add(_note, 0x60))\n\n            metadata := add(_note, 0x80)\n\n        }\n",
          "message": "NoteUtils.extractNote (NoteUtilsTest.sol#120-139) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 146,
          "vulnerability_to_line": 152,
          "vulnerability_code": "    function getNoteType(bytes memory _note) internal pure returns (\n\n        uint256 noteType\n\n    ) {\n\n        assembly {\n\n            noteType := mload(add(_note, 0x20))\n\n        }\n",
          "message": "NoteUtils.getNoteType (NoteUtilsTest.sol#146-152) is declared view but contains assembly code\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 20,
          "vulnerability_to_line": 28,
          "vulnerability_code": "    function getLength(bytes memory _proofOutputsOrNotes) internal pure returns (\n\n        uint len\n\n    ) {\n\n        assembly {\n\n            // first word = the raw byte length\n\n            // second word = the actual number of entries (hence the 0x20 offset)\n\n            len := mload(add(_proofOutputsOrNotes, 0x20))\n\n        }\n",
          "message": "NoteUtils.getLength uses assembly (NoteUtilsTest.sol#20-28)\n\t- NoteUtilsTest.sol#23-27\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 36,
          "vulnerability_to_line": 64,
          "vulnerability_code": "    function get(bytes memory _proofOutputsOrNotes, uint _i) internal pure returns (\n\n        bytes memory out\n\n    ) {\n\n        bool valid;\n\n        assembly {\n\n            // check that i < the number of entries\n\n            valid := lt(\n\n                _i,\n\n                mload(add(_proofOutputsOrNotes, 0x20))\n\n            )\n\n            // memory map of the array is as follows:\n\n            // 0x00 - 0x20 : byte length of array\n\n            // 0x20 - 0x40 : n, the number of entries\n\n            // 0x40 - 0x40 + (0x20 * i) : relative memory offset to start of i'th entry (i <= n)\n\n\n\n            // Step 1: compute location of relative memory offset: _proofOutputsOrNotes + 0x40 + (0x20 * i) \n\n            // Step 2: loaded relative offset and add to _proofOutputsOrNotes to get absolute memory location\n\n            out := add(\n\n                mload(\n\n                    add(\n\n                        add(_proofOutputsOrNotes, 0x40),\n\n                        mul(_i, 0x20)\n\n                    )\n\n                ),\n\n                _proofOutputsOrNotes\n\n            )\n\n        }\n\n        require(valid, \"AZTEC array index is out of bounds\");\n",
          "message": "NoteUtils.get uses assembly (NoteUtilsTest.sol#36-64)\n\t- NoteUtilsTest.sol#40-62\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 76,
          "vulnerability_to_line": 98,
          "vulnerability_code": "    function extractProofOutput(bytes memory _proofOutput) internal pure returns (\n\n        bytes memory inputNotes,\n\n        bytes memory outputNotes,\n\n        address publicOwner,\n\n        int256 publicValue\n\n    ) {\n\n        assembly {\n\n            // memory map of a proofOutput:\n\n            // 0x00 - 0x20 : byte length of proofOutput\n\n            // 0x20 - 0x40 : relative offset to inputNotes\n\n            // 0x40 - 0x60 : relative offset to outputNotes\n\n            // 0x60 - 0x80 : publicOwner\n\n            // 0x80 - 0xa0 : publicValue\n\n            // 0xa0 - 0xc0 : challenge\n\n            inputNotes := add(_proofOutput, mload(add(_proofOutput, 0x20)))\n\n            outputNotes := add(_proofOutput, mload(add(_proofOutput, 0x40)))\n\n            publicOwner := and(\n\n                mload(add(_proofOutput, 0x60)),\n\n                0xffffffffffffffffffffffffffffffffffffffff\n\n            )\n\n            publicValue := mload(add(_proofOutput, 0x80))\n\n        }\n",
          "message": "NoteUtils.extractProofOutput uses assembly (NoteUtilsTest.sol#76-98)\n\t- NoteUtilsTest.sol#82-97\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 105,
          "vulnerability_to_line": 111,
          "vulnerability_code": "    function extractChallenge(bytes memory _proofOutput) internal pure returns (\n\n        bytes32 challenge\n\n    ) {\n\n        assembly {\n\n            challenge := mload(add(_proofOutput, 0xa0))\n\n        }\n",
          "message": "NoteUtils.extractChallenge uses assembly (NoteUtilsTest.sol#105-111)\n\t- NoteUtilsTest.sol#108-110\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 120,
          "vulnerability_to_line": 139,
          "vulnerability_code": "    function extractNote(bytes memory _note) internal pure returns (\n\n            address owner,\n\n            bytes32 noteHash,\n\n            bytes memory metadata\n\n    ) {\n\n        assembly {\n\n            // memory map of a note:\n\n            // 0x00 - 0x20 : byte length of note\n\n            // 0x20 - 0x40 : note type\n\n            // 0x40 - 0x60 : owner\n\n            // 0x60 - 0x80 : noteHash\n\n            // 0x80 - 0xa0 : start of metadata byte array\n\n            owner := and(\n\n                mload(add(_note, 0x40)),\n\n                0xffffffffffffffffffffffffffffffffffffffff\n\n            )\n\n            noteHash := mload(add(_note, 0x60))\n\n            metadata := add(_note, 0x80)\n\n        }\n",
          "message": "NoteUtils.extractNote uses assembly (NoteUtilsTest.sol#120-139)\n\t- NoteUtilsTest.sol#125-138\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 146,
          "vulnerability_to_line": 152,
          "vulnerability_code": "    function getNoteType(bytes memory _note) internal pure returns (\n\n        uint256 noteType\n\n    ) {\n\n        assembly {\n\n            noteType := mload(add(_note, 0x20))\n\n        }\n",
          "message": "NoteUtils.getNoteType uses assembly (NoteUtilsTest.sol#146-152)\n\t- NoteUtilsTest.sol#149-151\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 175,
          "vulnerability_to_line": 179,
          "vulnerability_code": "    function getLength(bytes memory _proofOutputsOrNotes) public pure returns (\n\n        uint len\n\n    ) {\n\n        return _proofOutputsOrNotes.getLength();\n",
          "message": "NoteUtilsTest.getLength (NoteUtilsTest.sol#175-179) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 187,
          "vulnerability_to_line": 191,
          "vulnerability_code": "    function get(bytes memory _proofOutputsOrNotes, uint _i) public pure returns (\n\n        bytes memory out\n\n    ) {\n\n        return _proofOutputsOrNotes.get(_i);\n",
          "message": "NoteUtilsTest.get (NoteUtilsTest.sol#187-191) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 203,
          "vulnerability_to_line": 210,
          "vulnerability_code": "    function extractProofOutput(bytes memory _proofOutput) public pure returns (\n\n        bytes memory inputNotes,\n\n        bytes memory outputNotes,\n\n        address publicOwner,\n\n        int256 publicValue\n\n    ) {\n\n        return _proofOutput.extractProofOutput();\n",
          "message": "NoteUtilsTest.extractProofOutput (NoteUtilsTest.sol#203-210) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 217,
          "vulnerability_to_line": 221,
          "vulnerability_code": "    function extractChallenge(bytes memory _proofOutput) public pure returns (\n\n        bytes32 challenge\n\n    ) {\n\n        return _proofOutput.extractChallenge();\n",
          "message": "NoteUtilsTest.extractChallenge (NoteUtilsTest.sol#217-221) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 230,
          "vulnerability_to_line": 236,
          "vulnerability_code": "    function extractNote(bytes memory _note) public pure returns (\n\n        address owner,\n\n        bytes32 noteHash,\n\n        bytes memory metadata\n\n    ) {\n\n        return _note.extractNote();\n",
          "message": "NoteUtilsTest.extractNote (NoteUtilsTest.sol#230-236) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 243,
          "vulnerability_to_line": 247,
          "vulnerability_code": "    function getNoteType(bytes memory _note) public pure returns (\n\n        uint256 noteType\n\n    ) {\n\n        return _note.getNoteType();\n",
          "message": "NoteUtilsTest.getNoteType (NoteUtilsTest.sol#243-247) should be declared external\n"
        },
        {
          "name": "solc-version",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
          "message": "Detected issues with version pragma in NoteUtilsTest.sol:\n\t- pragma solidity>=0.5.0<0.6.0 (NoteUtilsTest.sol#3): it allows old versions\n\t- pragma solidity>=0.5.0<0.6.0 (NoteUtilsTest.sol#157): it allows old versions\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 175,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getLength(bytes memory _proofOutputsOrNotes) public pure returns (\n",
          "message": "Parameter '_proofOutputsOrNotes' of NoteUtilsTest.getLength (NoteUtilsTest.sol#175) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 187,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function get(bytes memory _proofOutputsOrNotes, uint _i) public pure returns (\n",
          "message": "Parameter '_proofOutputsOrNotes' of NoteUtilsTest.get (NoteUtilsTest.sol#187) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 187,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function get(bytes memory _proofOutputsOrNotes, uint _i) public pure returns (\n",
          "message": "Parameter '_i' of NoteUtilsTest.get (NoteUtilsTest.sol#187) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 203,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function extractProofOutput(bytes memory _proofOutput) public pure returns (\n",
          "message": "Parameter '_proofOutput' of NoteUtilsTest.extractProofOutput (NoteUtilsTest.sol#203) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 217,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function extractChallenge(bytes memory _proofOutput) public pure returns (\n",
          "message": "Parameter '_proofOutput' of NoteUtilsTest.extractChallenge (NoteUtilsTest.sol#217) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 230,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function extractNote(bytes memory _note) public pure returns (\n",
          "message": "Parameter '_note' of NoteUtilsTest.extractNote (NoteUtilsTest.sol#230) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 243,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getNoteType(bytes memory _note) public pure returns (\n",
          "message": "Parameter '_note' of NoteUtilsTest.getNoteType (NoteUtilsTest.sol#243) is not in mixedCase\n"
        }
      ]
    },
    "smartcheck": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
          "vulnerability_from_line": 20,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getLength(bytes memory _proofOutputsOrNotes) internal pure returns (\n",
          "message": null
        },
        {
          "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
          "vulnerability_from_line": 36,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function get(bytes memory _proofOutputsOrNotes, uint _i) internal pure returns (\n",
          "message": null
        },
        {
          "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
          "vulnerability_from_line": 76,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function extractProofOutput(bytes memory _proofOutput) internal pure returns (\n",
          "message": null
        },
        {
          "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
          "vulnerability_from_line": 105,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function extractChallenge(bytes memory _proofOutput) internal pure returns (\n",
          "message": null
        },
        {
          "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
          "vulnerability_from_line": 120,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function extractNote(bytes memory _note) internal pure returns (\n",
          "message": null
        },
        {
          "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
          "vulnerability_from_line": 146,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getNoteType(bytes memory _note) internal pure returns (\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 157,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 157,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 20,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getLength(bytes memory _proofOutputsOrNotes) internal pure returns (\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 36,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function get(bytes memory _proofOutputsOrNotes, uint _i) internal pure returns (\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 76,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function extractProofOutput(bytes memory _proofOutput) internal pure returns (\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 105,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function extractChallenge(bytes memory _proofOutput) internal pure returns (\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 120,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function extractNote(bytes memory _note) internal pure returns (\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 146,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getNoteType(bytes memory _note) internal pure returns (\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 76,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function extractProofOutput(bytes memory _proofOutput) internal pure returns (\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 120,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function extractNote(bytes memory _note) internal pure returns (\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 203,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function extractProofOutput(bytes memory _proofOutput) public pure returns (\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 230,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function extractNote(bytes memory _note) public pure returns (\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 23,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 40,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 82,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 108,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 125,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 149,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        }
      ]
    },
    "oyente": {
      "successfull_analysis": false,
      "errors": [
        "exception (IndexError: pop from empty list)"
      ],
      "vulnerability_findings": []
    },
    "mythril": {
      "successfull_analysis": false,
      "errors": [
        "Solc experienced a fatal error"
      ],
      "vulnerability_findings": []
    },
    "osiris": {
      "successfull_analysis": false,
      "errors": [
        "Solidity compilation failed"
      ],
      "vulnerability_findings": []
    }
  }
}