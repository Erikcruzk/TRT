{
  "smartbugs_completed": true,
  "analyzer_results": {
    "semgrep": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 32,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor ()\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 33,
          "vulnerability_to_line": null,
          "vulnerability_code": "        public\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 34,
          "vulnerability_to_line": null,
          "vulnerability_code": "    {\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 35,
          "vulnerability_to_line": null,
          "vulnerability_code": "        EIP712_DOMAIN_HASH = keccak256(abi.encode(\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 36,
          "vulnerability_to_line": null,
          "vulnerability_code": "            EIP712_DOMAIN_SEPARATOR_SCHEMA_HASH,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 37,
          "vulnerability_to_line": null,
          "vulnerability_code": "            keccak256(bytes(EIP712_DOMAIN_NAME)),\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 38,
          "vulnerability_to_line": null,
          "vulnerability_code": "            keccak256(bytes(EIP712_DOMAIN_VERSION)),\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 39,
          "vulnerability_to_line": null,
          "vulnerability_code": "            address(this)\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 40,
          "vulnerability_to_line": null,
          "vulnerability_code": "        ));\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 41,
          "vulnerability_to_line": null,
          "vulnerability_code": "    }\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 154,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor() public {}\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 141,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(_signer != address(0x0), \"signer address cannot be 0\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 142,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(result, \"signature recovery failed\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 140,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (!(result && (_signer != address(0x0)))) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 141,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(_signer != address(0x0), \"signer address cannot be 0\");\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 142,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(result, \"signature recovery failed\");\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 143,
          "vulnerability_to_line": null,
          "vulnerability_code": "        }\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        }
      ]
    },
    "slither": {
      "successfull_analysis": true,
      "errors": [
        "EXIT_CODE_9"
      ],
      "vulnerability_findings": [
        {
          "name": "constant-function",
          "vulnerability_from_line": 46,
          "vulnerability_to_line": 72,
          "vulnerability_code": "    function hashEIP712Message(bytes32 _hashStruct)\n\n        internal\n\n        view\n\n        returns (bytes32 _result)\n\n    {\n\n        bytes32 eip712DomainHash = EIP712_DOMAIN_HASH;\n\n\n\n        // Assembly for more efficient computing:\n\n        // keccak256(abi.encodePacked(\n\n        //     EIP191_HEADER,\n\n        //     EIP712_DOMAIN_HASH,\n\n        //     hashStruct\n\n        // ));\n\n\n\n        assembly {\n\n            // Load free memory pointer. We're not going to use it - we're going to overwrite it!\n\n            // We need 0x60 bytes of memory for this hash,\n\n            // cheaper to overwrite the free memory pointer at 0x40, and then replace it, than allocating free memory\n\n            let memPtr := mload(0x40)\n\n            mstore(0x00, 0x1901)               // EIP191 header\n\n            mstore(0x20, eip712DomainHash)     // EIP712 domain hash\n\n            mstore(0x40, _hashStruct)          // Hash of struct\n\n            _result := keccak256(0x1e, 0x42)   // compute hash\n\n            // replace memory pointer\n\n            mstore(0x40, memPtr)\n\n        }\n",
          "message": "LibEIP712.hashEIP712Message (JoinSplitFluidInterface.sol#46-72) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 78,
          "vulnerability_to_line": 144,
          "vulnerability_code": "    function recoverSignature(\n\n        bytes32 _message,\n\n        bytes memory _signature\n\n    ) internal view returns (address _signer) {\n\n        bool result;\n\n        assembly {\n\n            // Here's a little trick we can pull. We expect `_signature` to be a byte array, of length 0x60, with\n\n            // 'v', 'r' and 's' located linearly in memory. Preceeding this is the length parameter of `_signature`.\n\n            // We *replace* the length param with the signature msg to get a memory block formatted for the precompile\n\n            // load length as a temporary variable\n\n\n\n            let byteLength := mload(_signature)\n\n\n\n            // store the signature message\n\n            mstore(_signature, _message)\n\n\n\n            // load 'v' - we need it for a condition check\n\n            let v := mload(add(_signature, 0x60))\n\n            v := shr(248, v) // bitshifting, to resemble padLeft\n\n\n\n            /**\n\n            * Original memory map for input to precompile\n\n            *\n\n            * _signature : _signature + 0x20            message \n\n            * _signature + 0x20 : _signature + 0x40     r\n\n            * _signature + 0x40 : _signature + 0x60     s\n\n            * _signature + 0x60 : _signature + 0x80     v\n\n\n\n            * Desired memory map for input to precompile\n\n            *\n\n            * _signature : _signature + 0x20            message \n\n            * _signature + 0x20 : _signature + 0x40     v\n\n            * _signature + 0x40 : _signature + 0x60     r\n\n            * _signature + 0x60 : _signature + 0x80     s\n\n            */\n\n\n\n            // move s to v position\n\n            mstore(add(_signature, 0x60), mload(add(_signature, 0x40)))\n\n            // move r to s position\n\n            mstore(add(_signature, 0x40), mload(add(_signature, 0x20)))\n\n            // move v to r position\n\n            mstore(add(_signature, 0x20), v)\n\n            result := and(\n\n                and(\n\n                    // validate signature length == 0x41 or 0x60 bytes. \n\n                    // will be 0x41 if one signature was provided, 0x60 if multiple signatures \n\n                    // have been provided - due to the relevant signature creation functions\n\n                    or(eq(byteLength, 0x41), eq(byteLength, 0x60)),\n\n                    // validate v == 27 or v == 28\n\n                    or(eq(v, 27), eq(v, 28))\n\n                ),\n\n                // validate call to precompile succeeds\n\n                staticcall(gas, 0x01, _signature, 0x80, _signature, 0x20) \n\n            )\n\n            // save the _signer only if the first word in _signature is not `_message` anymore\n\n            switch eq(_message, mload(_signature))\n\n            case 0 {\n\n                _signer := mload(_signature)\n\n            }\n\n            mstore(_signature, byteLength) // and put the byte length back where it belongs\n\n        }\n\n        // wrap Failure States in a single if test, so that happy path only has 1 conditional jump\n\n        if (!(result && (_signer != address(0x0)))) {\n\n            require(_signer != address(0x0), \"signer address cannot be 0\");\n\n            require(result, \"signature recovery failed\");\n\n        }\n",
          "message": "LibEIP712.recoverSignature (JoinSplitFluidInterface.sol#78-144) is declared view but contains assembly code\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 46,
          "vulnerability_to_line": 72,
          "vulnerability_code": "    function hashEIP712Message(bytes32 _hashStruct)\n\n        internal\n\n        view\n\n        returns (bytes32 _result)\n\n    {\n\n        bytes32 eip712DomainHash = EIP712_DOMAIN_HASH;\n\n\n\n        // Assembly for more efficient computing:\n\n        // keccak256(abi.encodePacked(\n\n        //     EIP191_HEADER,\n\n        //     EIP712_DOMAIN_HASH,\n\n        //     hashStruct\n\n        // ));\n\n\n\n        assembly {\n\n            // Load free memory pointer. We're not going to use it - we're going to overwrite it!\n\n            // We need 0x60 bytes of memory for this hash,\n\n            // cheaper to overwrite the free memory pointer at 0x40, and then replace it, than allocating free memory\n\n            let memPtr := mload(0x40)\n\n            mstore(0x00, 0x1901)               // EIP191 header\n\n            mstore(0x20, eip712DomainHash)     // EIP712 domain hash\n\n            mstore(0x40, _hashStruct)          // Hash of struct\n\n            _result := keccak256(0x1e, 0x42)   // compute hash\n\n            // replace memory pointer\n\n            mstore(0x40, memPtr)\n\n        }\n",
          "message": "LibEIP712.hashEIP712Message uses assembly (JoinSplitFluidInterface.sol#46-72)\n\t- JoinSplitFluidInterface.sol#60-71\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 78,
          "vulnerability_to_line": 144,
          "vulnerability_code": "    function recoverSignature(\n\n        bytes32 _message,\n\n        bytes memory _signature\n\n    ) internal view returns (address _signer) {\n\n        bool result;\n\n        assembly {\n\n            // Here's a little trick we can pull. We expect `_signature` to be a byte array, of length 0x60, with\n\n            // 'v', 'r' and 's' located linearly in memory. Preceeding this is the length parameter of `_signature`.\n\n            // We *replace* the length param with the signature msg to get a memory block formatted for the precompile\n\n            // load length as a temporary variable\n\n\n\n            let byteLength := mload(_signature)\n\n\n\n            // store the signature message\n\n            mstore(_signature, _message)\n\n\n\n            // load 'v' - we need it for a condition check\n\n            let v := mload(add(_signature, 0x60))\n\n            v := shr(248, v) // bitshifting, to resemble padLeft\n\n\n\n            /**\n\n            * Original memory map for input to precompile\n\n            *\n\n            * _signature : _signature + 0x20            message \n\n            * _signature + 0x20 : _signature + 0x40     r\n\n            * _signature + 0x40 : _signature + 0x60     s\n\n            * _signature + 0x60 : _signature + 0x80     v\n\n\n\n            * Desired memory map for input to precompile\n\n            *\n\n            * _signature : _signature + 0x20            message \n\n            * _signature + 0x20 : _signature + 0x40     v\n\n            * _signature + 0x40 : _signature + 0x60     r\n\n            * _signature + 0x60 : _signature + 0x80     s\n\n            */\n\n\n\n            // move s to v position\n\n            mstore(add(_signature, 0x60), mload(add(_signature, 0x40)))\n\n            // move r to s position\n\n            mstore(add(_signature, 0x40), mload(add(_signature, 0x20)))\n\n            // move v to r position\n\n            mstore(add(_signature, 0x20), v)\n\n            result := and(\n\n                and(\n\n                    // validate signature length == 0x41 or 0x60 bytes. \n\n                    // will be 0x41 if one signature was provided, 0x60 if multiple signatures \n\n                    // have been provided - due to the relevant signature creation functions\n\n                    or(eq(byteLength, 0x41), eq(byteLength, 0x60)),\n\n                    // validate v == 27 or v == 28\n\n                    or(eq(v, 27), eq(v, 28))\n\n                ),\n\n                // validate call to precompile succeeds\n\n                staticcall(gas, 0x01, _signature, 0x80, _signature, 0x20) \n\n            )\n\n            // save the _signer only if the first word in _signature is not `_message` anymore\n\n            switch eq(_message, mload(_signature))\n\n            case 0 {\n\n                _signer := mload(_signature)\n\n            }\n\n            mstore(_signature, byteLength) // and put the byte length back where it belongs\n\n        }\n\n        // wrap Failure States in a single if test, so that happy path only has 1 conditional jump\n\n        if (!(result && (_signer != address(0x0)))) {\n\n            require(_signer != address(0x0), \"signer address cannot be 0\");\n\n            require(result, \"signature recovery failed\");\n\n        }\n",
          "message": "LibEIP712.recoverSignature uses assembly (JoinSplitFluidInterface.sol#78-144)\n\t- JoinSplitFluidInterface.sol#83-138\n"
        },
        {
          "name": "solc-version",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
          "message": "Detected issues with version pragma in JoinSplitFluidInterface.sol:\n\t- pragma solidity>=0.5.0<0.6.0 (JoinSplitFluidInterface.sol#3): it allows old versions\n\t- pragma solidity>=0.5.0<0.6.0 (JoinSplitFluidInterface.sol#149): it allows old versions\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 30,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bytes32 public EIP712_DOMAIN_HASH;\n",
          "message": "Variable 'LibEIP712.EIP712_DOMAIN_HASH' (JoinSplitFluidInterface.sol#30) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 157,
          "vulnerability_to_line": null,
          "vulnerability_code": "        bytes calldata, // proof data\n",
          "message": "Parameter '' of JoinSplitFluidInterface.validateJoinSplitFluid (JoinSplitFluidInterface.sol#157) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 158,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address, // sender address\n",
          "message": "Parameter '_scope_0' of JoinSplitFluidInterface.validateJoinSplitFluid (JoinSplitFluidInterface.sol#158) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 159,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint[6] calldata // common reference string\n",
          "message": "Parameter '_scope_1' of JoinSplitFluidInterface.validateJoinSplitFluid (JoinSplitFluidInterface.sol#159) is not in mixedCase\n"
        }
      ]
    },
    "smartcheck": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 140,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (!(result && (_signer != address(0x0)))) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 141,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(_signer != address(0x0), \"signer address cannot be 0\");\n",
          "message": null
        },
        {
          "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
          "vulnerability_from_line": 156,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function validateJoinSplitFluid(\n",
          "message": null
        },
        {
          "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
          "vulnerability_from_line": 46,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function hashEIP712Message(bytes32 _hashStruct)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
          "vulnerability_from_line": 78,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function recoverSignature(\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 149,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 149,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
          "vulnerability_from_line": 46,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function hashEIP712Message(bytes32 _hashStruct)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
          "vulnerability_from_line": 78,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function recoverSignature(\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 60,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 83,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        }
      ]
    },
    "oyente": {
      "successfull_analysis": false,
      "errors": [
        "exception (RuntimeError: Source map error, unknown name(SHR) or instr_name(INVALID))"
      ],
      "vulnerability_findings": []
    },
    "mythril": {
      "successfull_analysis": false,
      "errors": [
        "Solc experienced a fatal error"
      ],
      "vulnerability_findings": []
    },
    "osiris": {
      "successfull_analysis": false,
      "errors": [
        "Solidity compilation failed"
      ],
      "vulnerability_findings": []
    }
  }
}