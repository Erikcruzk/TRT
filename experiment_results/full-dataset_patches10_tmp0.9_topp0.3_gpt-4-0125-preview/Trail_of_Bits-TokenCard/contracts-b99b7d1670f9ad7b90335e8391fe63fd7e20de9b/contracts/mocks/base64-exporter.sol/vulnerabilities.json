{
  "smartbugs_completed": true,
  "analyzer_results": {
    "semgrep": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 35,
          "vulnerability_to_line": null,
          "vulnerability_code": "              v1 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 36,
          "vulnerability_to_line": null,
          "vulnerability_code": "              v2 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 37,
          "vulnerability_to_line": null,
          "vulnerability_code": "              v3 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 38,
          "vulnerability_to_line": null,
          "vulnerability_code": "              v4 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 26,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(length > 0  && length % 4 == 0, \"invalid base64 encoding\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 26,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(length > 0  && length % 4 == 0, \"invalid base64 encoding\");\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        }
      ]
    },
    "slither": {
      "successfull_analysis": true,
      "errors": [
        "EXIT_CODE_5"
      ],
      "vulnerability_findings": [
        {
          "name": "constant-function",
          "vulnerability_from_line": 16,
          "vulnerability_to_line": 63,
          "vulnerability_code": "    function _base64decode(bytes _encoded) internal pure returns (bytes) {\n\n        byte v1;\n\n        byte v2;\n\n        byte v3;\n\n        byte v4;\n\n        uint length = _encoded.length;\n\n        bytes memory result = new bytes(length);\n\n        uint index;\n\n\n\n        // base64 encoded strings can't be length 0 and they must be divisble by 4\n\n        require(length > 0  && length % 4 == 0, \"invalid base64 encoding\");\n\n\n\n          if (keccak256(abi.encodePacked(_encoded[length - 2])) == keccak256(\"=\")) {\n\n              length -= 2;\n\n          } else if (keccak256(abi.encodePacked(_encoded[length - 1])) == keccak256(\"=\")) {\n\n              length -= 1;\n\n          }\n\n          uint count = length >> 2 << 2;\n\n          for (uint i = 0; i < count;) {\n\n              v1 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\n\n              v2 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\n\n              v3 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\n\n              v4 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\n\n\n\n              result[index++] = (v1 << 2 | v2 >> 4) & 255;\n\n              result[index++] = (v2 << 4 | v3 >> 2) & 255;\n\n              result[index++] = (v3 << 6 | v4) & 255;\n\n          }\n\n          if (length - count == 2) {\n\n              v1 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\n\n              v2 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\n\n              result[index++] = (v1 << 2 | v2 >> 4) & 255;\n\n          } else if (length - count == 3) {\n\n              v1 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\n\n              v2 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\n\n              v3 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\n\n\n\n              result[index++] = (v1 << 2 | v2 >> 4) & 255;\n\n              result[index++] = (v2 << 4 | v3 >> 2) & 255;\n\n          }\n\n\n\n        // Set to correct length.\n\n        assembly {\n\n            mstore(result, index)\n\n        }\n\n\n\n        return result;\n",
          "message": "Base64._base64decode (base64-exporter.sol#16-63) is declared view but contains assembly code\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 16,
          "vulnerability_to_line": 63,
          "vulnerability_code": "    function _base64decode(bytes _encoded) internal pure returns (bytes) {\n\n        byte v1;\n\n        byte v2;\n\n        byte v3;\n\n        byte v4;\n\n        uint length = _encoded.length;\n\n        bytes memory result = new bytes(length);\n\n        uint index;\n\n\n\n        // base64 encoded strings can't be length 0 and they must be divisble by 4\n\n        require(length > 0  && length % 4 == 0, \"invalid base64 encoding\");\n\n\n\n          if (keccak256(abi.encodePacked(_encoded[length - 2])) == keccak256(\"=\")) {\n\n              length -= 2;\n\n          } else if (keccak256(abi.encodePacked(_encoded[length - 1])) == keccak256(\"=\")) {\n\n              length -= 1;\n\n          }\n\n          uint count = length >> 2 << 2;\n\n          for (uint i = 0; i < count;) {\n\n              v1 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\n\n              v2 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\n\n              v3 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\n\n              v4 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\n\n\n\n              result[index++] = (v1 << 2 | v2 >> 4) & 255;\n\n              result[index++] = (v2 << 4 | v3 >> 2) & 255;\n\n              result[index++] = (v3 << 6 | v4) & 255;\n\n          }\n\n          if (length - count == 2) {\n\n              v1 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\n\n              v2 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\n\n              result[index++] = (v1 << 2 | v2 >> 4) & 255;\n\n          } else if (length - count == 3) {\n\n              v1 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\n\n              v2 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\n\n              v3 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\n\n\n\n              result[index++] = (v1 << 2 | v2 >> 4) & 255;\n\n              result[index++] = (v2 << 4 | v3 >> 2) & 255;\n\n          }\n\n\n\n        // Set to correct length.\n\n        assembly {\n\n            mstore(result, index)\n\n        }\n\n\n\n        return result;\n",
          "message": "Base64._base64decode uses assembly (base64-exporter.sol#16-63)\n\t- base64-exporter.sol#58-62\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 16,
          "vulnerability_to_line": 63,
          "vulnerability_code": "    function _base64decode(bytes _encoded) internal pure returns (bytes) {\n\n        byte v1;\n\n        byte v2;\n\n        byte v3;\n\n        byte v4;\n\n        uint length = _encoded.length;\n\n        bytes memory result = new bytes(length);\n\n        uint index;\n\n\n\n        // base64 encoded strings can't be length 0 and they must be divisble by 4\n\n        require(length > 0  && length % 4 == 0, \"invalid base64 encoding\");\n\n\n\n          if (keccak256(abi.encodePacked(_encoded[length - 2])) == keccak256(\"=\")) {\n\n              length -= 2;\n\n          } else if (keccak256(abi.encodePacked(_encoded[length - 1])) == keccak256(\"=\")) {\n\n              length -= 1;\n\n          }\n\n          uint count = length >> 2 << 2;\n\n          for (uint i = 0; i < count;) {\n\n              v1 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\n\n              v2 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\n\n              v3 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\n\n              v4 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\n\n\n\n              result[index++] = (v1 << 2 | v2 >> 4) & 255;\n\n              result[index++] = (v2 << 4 | v3 >> 2) & 255;\n\n              result[index++] = (v3 << 6 | v4) & 255;\n\n          }\n\n          if (length - count == 2) {\n\n              v1 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\n\n              v2 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\n\n              result[index++] = (v1 << 2 | v2 >> 4) & 255;\n\n          } else if (length - count == 3) {\n\n              v1 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\n\n              v2 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\n\n              v3 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\n\n\n\n              result[index++] = (v1 << 2 | v2 >> 4) & 255;\n\n              result[index++] = (v2 << 4 | v3 >> 2) & 255;\n\n          }\n\n\n\n        // Set to correct length.\n\n        assembly {\n\n            mstore(result, index)\n\n        }\n\n\n\n        return result;\n",
          "message": "Function 'Base64._base64decode' (base64-exporter.sol#16-63) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 16,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _base64decode(bytes _encoded) internal pure returns (bytes) {\n",
          "message": "Parameter '_encoded' of Base64._base64decode (base64-exporter.sol#16) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 73,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function base64decode(bytes _encoded) external pure returns (bytes) {\n",
          "message": "Parameter '_encoded' of Base64Exporter.base64decode (base64-exporter.sol#73) is not in mixedCase\n"
        }
      ]
    },
    "smartcheck": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.25;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 68,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.25;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 16,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _base64decode(bytes _encoded) internal pure returns (bytes) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 16,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _base64decode(bytes _encoded) internal pure returns (bytes) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 16,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _base64decode(bytes _encoded) internal pure returns (bytes) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 58,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 12,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bytes constant BASE64_DECODE_CHAR = hex\"000000000000000000000000000000000000000000000000000000000000000000000000000000000000003e003e003f3435363738393a3b3c3d00000000000000000102030405060708090a0b0c0d0e0f10111213141516171819000000003f001a1b1c1d1e1f202122232425262728292a2b2c2d2e2f30313233\";\n",
          "message": null
        }
      ]
    },
    "oyente": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "Integer Overflow",
          "vulnerability_from_line": 73,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function base64decode(bytes _encoded) external pure returns (bytes) {\n",
          "message": null
        }
      ]
    },
    "mythril": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "Exception State (SWC 110)",
          "vulnerability_from_line": 34,
          "vulnerability_to_line": null,
          "vulnerability_code": "          for (uint i = 0; i < count;) {\n",
          "message": "An assertion violation was triggered.\nIt is possible to trigger an assertion violation. Note that Solidity assert() statements should only be used to check invariants. Review the transaction trace generated for this issue and either make sure your program logic is correct, or use require() instead of assert() if your goal is to constrain user inputs or enforce preconditions. Remember to validate inputs from both callers (for instance, via passed arguments) and callees (for instance, via return values).\nClassification: SWC-110"
        }
      ]
    },
    "osiris": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "Overflow bugs",
          "vulnerability_from_line": 28,
          "vulnerability_to_line": null,
          "vulnerability_code": "          if (keccak256(abi.encodePacked(_encoded[length - 2])) == keccak256(\"=\")) {\n",
          "message": null
        },
        {
          "name": "Overflow bugs",
          "vulnerability_from_line": 30,
          "vulnerability_to_line": null,
          "vulnerability_code": "          } else if (keccak256(abi.encodePacked(_encoded[length - 1])) == keccak256(\"=\")) {\n",
          "message": null
        },
        {
          "name": "Overflow bugs",
          "vulnerability_from_line": 35,
          "vulnerability_to_line": null,
          "vulnerability_code": "              v1 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\n",
          "message": null
        },
        {
          "name": "Overflow bugs",
          "vulnerability_from_line": 36,
          "vulnerability_to_line": null,
          "vulnerability_code": "              v2 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\n",
          "message": null
        },
        {
          "name": "Overflow bugs",
          "vulnerability_from_line": 37,
          "vulnerability_to_line": null,
          "vulnerability_code": "              v3 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\n",
          "message": null
        },
        {
          "name": "Overflow bugs",
          "vulnerability_from_line": 38,
          "vulnerability_to_line": null,
          "vulnerability_code": "              v4 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\n",
          "message": null
        },
        {
          "name": "Overflow bugs",
          "vulnerability_from_line": 45,
          "vulnerability_to_line": null,
          "vulnerability_code": "              v1 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\n",
          "message": null
        },
        {
          "name": "Overflow bugs",
          "vulnerability_from_line": 46,
          "vulnerability_to_line": null,
          "vulnerability_code": "              v2 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\n",
          "message": null
        },
        {
          "name": "Overflow bugs",
          "vulnerability_from_line": 49,
          "vulnerability_to_line": null,
          "vulnerability_code": "              v1 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\n",
          "message": null
        },
        {
          "name": "Overflow bugs",
          "vulnerability_from_line": 50,
          "vulnerability_to_line": null,
          "vulnerability_code": "              v2 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\n",
          "message": null
        },
        {
          "name": "Overflow bugs",
          "vulnerability_from_line": 51,
          "vulnerability_to_line": null,
          "vulnerability_code": "              v3 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\n",
          "message": null
        },
        {
          "name": "Truncation bugs",
          "vulnerability_from_line": 7,
          "vulnerability_to_line": null,
          "vulnerability_code": " * https://github.com/vcealicu/melonport-price-feed/blob/master/pricefeed/PriceFeed.sol\n",
          "message": null
        },
        {
          "name": "Truncation bugs",
          "vulnerability_from_line": 8,
          "vulnerability_to_line": null,
          "vulnerability_code": " */\n",
          "message": null
        },
        {
          "name": "Underflow bugs",
          "vulnerability_from_line": 6,
          "vulnerability_to_line": null,
          "vulnerability_code": " * This method was modified from the GPLv3 solidity code found in this repository\n",
          "message": null
        }
      ]
    }
  }
}