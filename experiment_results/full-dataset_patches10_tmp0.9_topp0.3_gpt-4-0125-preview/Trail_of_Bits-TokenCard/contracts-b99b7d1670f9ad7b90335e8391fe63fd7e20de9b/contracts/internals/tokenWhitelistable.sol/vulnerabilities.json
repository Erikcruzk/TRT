{
  "smartbugs_completed": true,
  "analyzer_results": {
    "semgrep": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "use-ownable2step",
          "vulnerability_from_line": 193,
          "vulnerability_to_line": null,
          "vulnerability_code": "contract Controller is IController, Ownable, Claimable {\n",
          "message": "By demanding that the receiver of the owner permissions actively accept via a contract call of its own,  `Ownable2Step` and `Ownable2StepUpgradeable` prevent the contract ownership from accidentally being transferred  to an address that cannot handle it."
        },
        {
          "name": "use-ownable2step",
          "vulnerability_from_line": 1607,
          "vulnerability_to_line": null,
          "vulnerability_code": "contract TokenWhitelist is ENSResolvable, Controllable, Ownable, Claimable {\n",
          "message": "By demanding that the receiver of the owner permissions actively accept via a contract call of its own,  `Ownable2Step` and `Ownable2StepUpgradeable` prevent the contract ownership from accidentally being transferred  to an address that cannot handle it."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 574,
          "vulnerability_to_line": null,
          "vulnerability_code": "            if ((contentType & contentTypes) != 0 && record.abis[contentType].length > 0) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 1464,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(i = 0; i < parts.length; i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 1467,
          "vulnerability_to_line": null,
          "vulnerability_code": "            if (i < parts.length - 1) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 1660,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < _tokens.length; i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 1686,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < _tokens.length; i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 1694,
          "vulnerability_to_line": null,
          "vulnerability_code": "            for (uint j = 0; j < _tokenAddressArray.length.sub(1); j++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 1696,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    _tokenAddressArray[j] = _tokenAddressArray[_tokenAddressArray.length.sub(1)];\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 1700,
          "vulnerability_to_line": null,
          "vulnerability_code": "            _tokenAddressArray.length--;\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 36,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor(address _account_, bool _transferable_) internal {\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 37,
          "vulnerability_to_line": null,
          "vulnerability_code": "        _owner = _account_;\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 38,
          "vulnerability_to_line": null,
          "vulnerability_code": "        _isTransferable = _transferable_;\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 39,
          "vulnerability_to_line": null,
          "vulnerability_code": "        // Emit the LockedOwnership event if no longer transferable.\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 40,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (!_isTransferable) {\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 41,
          "vulnerability_to_line": null,
          "vulnerability_code": "            emit LockedOwnership(_account_);\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 42,
          "vulnerability_to_line": null,
          "vulnerability_code": "        }\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 43,
          "vulnerability_to_line": null,
          "vulnerability_code": "        emit TransferredOwnership(address(0), _account_);\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 44,
          "vulnerability_to_line": null,
          "vulnerability_code": "    }\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 210,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor(address _ownerAddress_, bool _transferable_) Ownable(_ownerAddress_, _transferable_) public { }\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 454,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor(ENS ensAddr) public {\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 455,
          "vulnerability_to_line": null,
          "vulnerability_code": "        ens = ensAddr;\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 456,
          "vulnerability_to_line": null,
          "vulnerability_code": "    }\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 671,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor(address _ensReg_) internal {\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 672,
          "vulnerability_to_line": null,
          "vulnerability_code": "        _ensRegistry = _ensReg_;\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 673,
          "vulnerability_to_line": null,
          "vulnerability_code": "        _ens = ENS(_ensRegistry);\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 674,
          "vulnerability_to_line": null,
          "vulnerability_code": "    }\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 720,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor(bytes32 _controllerNameHash_) internal {\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 721,
          "vulnerability_to_line": null,
          "vulnerability_code": "        _controllerNode = _controllerNameHash_;\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 722,
          "vulnerability_to_line": null,
          "vulnerability_code": "    }\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 1644,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor(address _ens_, bytes32 _oracleNameHash_, bytes32 _controllerNameHash_, address _owner_, bool _transferable_, address _stabelcoinAddress_) ENSResolvable(_ens_) Controllable(_controllerNameHash_) Ownable(_owner_, _transferable_) public {\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 1645,
          "vulnerability_to_line": null,
          "vulnerability_code": "        _oracleNode = _oracleNameHash_;\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 1646,
          "vulnerability_to_line": null,
          "vulnerability_code": "        _stablecoin = _stabelcoinAddress_;\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 1647,
          "vulnerability_to_line": null,
          "vulnerability_code": "    }\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 1803,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor(bytes32 _tokenWhitelistNameHash_) internal {\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 1804,
          "vulnerability_to_line": null,
          "vulnerability_code": "        _tokenWhitelistNode = _tokenWhitelistNameHash_;\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 1805,
          "vulnerability_to_line": null,
          "vulnerability_code": "    }\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 1662,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(!_tokenInfoMap[_tokens[i]].available, \"token already available\");\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 1666,
          "vulnerability_to_line": null,
          "vulnerability_code": "            _tokenInfoMap[_tokens[i]] = Token({\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 1676,
          "vulnerability_to_line": null,
          "vulnerability_code": "            _tokenAddressArray.push(_tokens[i]);\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 1688,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(_tokenInfoMap[_tokens[i]].available, \"token is not available\");\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 1692,
          "vulnerability_to_line": null,
          "vulnerability_code": "            delete _tokenInfoMap[token];\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 1694,
          "vulnerability_to_line": null,
          "vulnerability_code": "            for (uint j = 0; j < _tokenAddressArray.length.sub(1); j++) {\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 1695,
          "vulnerability_to_line": null,
          "vulnerability_code": "                if (_tokenAddressArray[j] == token) {\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 1696,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    _tokenAddressArray[j] = _tokenAddressArray[_tokenAddressArray.length.sub(1)];\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 1696,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    _tokenAddressArray[j] = _tokenAddressArray[_tokenAddressArray.length.sub(1)];\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 1696,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    _tokenAddressArray[j] = _tokenAddressArray[_tokenAddressArray.length.sub(1)];\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 1700,
          "vulnerability_to_line": null,
          "vulnerability_code": "            _tokenAddressArray.length--;\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 1086,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 1; i < length; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 1660,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < _tokens.length; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 1686,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < _tokens.length; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 1694,
          "vulnerability_to_line": null,
          "vulnerability_code": "            for (uint j = 0; j < _tokenAddressArray.length.sub(1); j++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 48,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_isOwner(msg.sender), \"sender is not an owner\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 57,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_isTransferable, \"ownership is not transferable\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 59,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_account != address(0), \"owner cannot be set to zero address\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 83,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_isTransferable, \"ownership is not transferable\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 152,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(ERC20(_asset).transfer(_to, _amount), \"ERC20 token transfer was unsuccessful\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 214,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(isAdmin(msg.sender), \"sender is not an admin\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 220,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(isController(msg.sender), \"sender is not a controller\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 273,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(!_isAdmin[_account], \"provided account is already an admin\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 274,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(!_isController[_account], \"provided account is already a controller\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 275,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(!_isOwner(_account), \"provided account is already the owner\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 276,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_account != address(0), \"provided account is the zero address\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 284,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_isAdmin[_account], \"provided account is not an admin\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 292,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(!_isAdmin[_account], \"provided account is already an admin\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 293,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(!_isController[_account], \"provided account is already a controller\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 294,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(!_isOwner(_account), \"provided account is already the owner\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 295,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_account != address(0), \"provided account is the zero address\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 303,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_isController[_account], \"provided account is not a controller\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 726,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_isController(msg.sender), \"sender is not a controller\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1631,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require (_isController(msg.sender) || msg.sender == oracleAddress, \"either oracle or controller\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1658,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_tokens.length == _symbols.length && _tokens.length == _magnitude.length && _tokens.length == _loadable.length && _tokens.length == _loadable.length, \"parameter lengths do not match\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1662,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(!_tokenInfoMap[_tokens[i]].available, \"token already available\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1688,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(_tokenInfoMap[_tokens[i]].available, \"token is not available\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1712,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_tokenInfoMap[_token].available, \"token is not available\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 1658,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_tokens.length == _symbols.length && _tokens.length == _magnitude.length && _tokens.length == _loadable.length && _tokens.length == _loadable.length, \"parameter lengths do not match\");\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 574,
          "vulnerability_to_line": null,
          "vulnerability_code": "            if ((contentType & contentTypes) != 0 && record.abis[contentType].length > 0) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 575,
          "vulnerability_to_line": null,
          "vulnerability_code": "                data = record.abis[contentType];\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 576,
          "vulnerability_to_line": null,
          "vulnerability_code": "                return;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 577,
          "vulnerability_to_line": null,
          "vulnerability_code": "            }\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-prefix-decrement-not-postfix",
          "vulnerability_from_line": 286,
          "vulnerability_to_line": null,
          "vulnerability_code": "        _adminCount--;\n",
          "message": "Consider using the prefix decrement expression whenever the return value is not needed. The prefix decrement expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-decrement-not-postfix",
          "vulnerability_from_line": 305,
          "vulnerability_to_line": null,
          "vulnerability_code": "        _controllerCount--;\n",
          "message": "Consider using the prefix decrement expression whenever the return value is not needed. The prefix decrement expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-decrement-not-postfix",
          "vulnerability_from_line": 1281,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    ptr--;\n",
          "message": "Consider using the prefix decrement expression whenever the return value is not needed. The prefix decrement expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-decrement-not-postfix",
          "vulnerability_from_line": 1700,
          "vulnerability_to_line": null,
          "vulnerability_code": "            _tokenAddressArray.length--;\n",
          "message": "Consider using the prefix decrement expression whenever the return value is not needed. The prefix decrement expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 278,
          "vulnerability_to_line": null,
          "vulnerability_code": "        _adminCount++;\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 297,
          "vulnerability_to_line": null,
          "vulnerability_code": "        _controllerCount++;\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 920,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (l = 0; ptr < end; l++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 1086,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 1; i < length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 1241,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    ptr++;\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 1250,
          "vulnerability_to_line": null,
          "vulnerability_code": "                for (idx = 0; idx <= selflen - needlelen; idx++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 1413,
          "vulnerability_to_line": null,
          "vulnerability_code": "            cnt++;\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 1457,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(uint i = 0; i < parts.length; i++)\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 1464,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(i = 0; i < parts.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 1660,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < _tokens.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 1686,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < _tokens.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 1694,
          "vulnerability_to_line": null,
          "vulnerability_code": "            for (uint j = 0; j < _tokenAddressArray.length.sub(1); j++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 59,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_account != address(0), \"owner cannot be set to zero address\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 152,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(ERC20(_asset).transfer(_to, _amount), \"ERC20 token transfer was unsuccessful\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 273,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(!_isAdmin[_account], \"provided account is already an admin\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 274,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(!_isController[_account], \"provided account is already a controller\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 275,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(!_isOwner(_account), \"provided account is already the owner\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 276,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_account != address(0), \"provided account is the zero address\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 292,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(!_isAdmin[_account], \"provided account is already an admin\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 293,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(!_isController[_account], \"provided account is already a controller\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 294,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(!_isOwner(_account), \"provided account is already the owner\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 295,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_account != address(0), \"provided account is the zero address\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 303,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_isController[_account], \"provided account is not a controller\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        }
      ]
    },
    "slither": {
      "successfull_analysis": true,
      "errors": [
        "DOCKER_RECEIVED_SIGNAL_12"
      ],
      "vulnerability_findings": [
        {
          "name": "arbitrary-send",
          "vulnerability_from_line": 147,
          "vulnerability_to_line": 156,
          "vulnerability_code": "    function _claim(address _to, address _asset, uint _amount) internal {\n\n        // address(0) is used to denote ETH\n\n        if (_asset == address(0)) {\n\n            _to.transfer(_amount);\n\n        } else {\n\n            require(ERC20(_asset).transfer(_to, _amount), \"ERC20 token transfer was unsuccessful\");\n\n        }\n\n\n\n        emit Claimed(_to, _asset, _amount);\n",
          "message": "Claimable._claim (tokenWhitelistable.sol#147-156) sends eth to arbitrary user\n\tDangerous calls:\n\t- _to.transfer(_amount) (tokenWhitelistable.sol#150)\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 804,
          "vulnerability_to_line": 821,
          "vulnerability_code": "    function memcpy(uint dest, uint src, uint len) private pure {\n\n        // Copy word-length chunks while possible\n\n        for(; len >= 32; len -= 32) {\n\n            assembly {\n\n                mstore(dest, mload(src))\n\n            }\n\n            dest += 32;\n\n            src += 32;\n\n        }\n\n\n\n        // Copy remaining bytes\n\n        uint mask = 256 ** (32 - len) - 1;\n\n        assembly {\n\n            let srcpart := and(mload(src), not(mask))\n\n            let destpart := and(mload(dest), mask)\n\n            mstore(dest, or(destpart, srcpart))\n\n        }\n",
          "message": "strings.memcpy (tokenWhitelistable.sol#804-821) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 828,
          "vulnerability_to_line": 834,
          "vulnerability_code": "    function toSlice(string memory self) internal pure returns (slice memory) {\n\n        uint ptr;\n\n        assembly {\n\n            ptr := add(self, 0x20)\n\n        }\n\n        return slice(bytes(self).length, ptr);\n",
          "message": "strings.toSlice (tokenWhitelistable.sol#828-834) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 874,
          "vulnerability_to_line": 883,
          "vulnerability_code": "    function toSliceB32(bytes32 self) internal pure returns (slice memory ret) {\n\n        // Allocate space for `self` in memory, copy it there, and point ret at it\n\n        assembly {\n\n            let ptr := mload(0x40)\n\n            mstore(0x40, add(ptr, 0x20))\n\n            mstore(ptr, self)\n\n            mstore(add(ret, 0x20), ptr)\n\n        }\n\n        ret._len = len(self);\n",
          "message": "strings.toSliceB32 (tokenWhitelistable.sol#874-883) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 899,
          "vulnerability_to_line": 906,
          "vulnerability_code": "    function toString(slice memory self) internal pure returns (string memory) {\n\n        string memory ret = new string(self._len);\n\n        uint retptr;\n\n        assembly { retptr := add(ret, 32) }\n\n\n\n        memcpy(retptr, self._ptr, self._len);\n\n        return ret;\n",
          "message": "strings.toString (tokenWhitelistable.sol#899-906) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 916,
          "vulnerability_to_line": 937,
          "vulnerability_code": "    function len(slice memory self) internal pure returns (uint l) {\n\n        // Starting at ptr-31 means the LSB will be the byte we care about\n\n        uint ptr = self._ptr - 31;\n\n        uint end = ptr + self._len;\n\n        for (l = 0; ptr < end; l++) {\n\n            uint8 b;\n\n            assembly { b := and(mload(ptr), 0xFF) }\n\n            if (b < 0x80) {\n\n                ptr += 1;\n\n            } else if(b < 0xE0) {\n\n                ptr += 2;\n\n            } else if(b < 0xF0) {\n\n                ptr += 3;\n\n            } else if(b < 0xF8) {\n\n                ptr += 4;\n\n            } else if(b < 0xFC) {\n\n                ptr += 5;\n\n            } else {\n\n                ptr += 6;\n\n            }\n\n        }\n",
          "message": "strings.len (tokenWhitelistable.sol#916-937) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 957,
          "vulnerability_to_line": 985,
          "vulnerability_code": "    function compare(slice memory self, slice memory other) internal pure returns (int) {\n\n        uint shortest = self._len;\n\n        if (other._len < self._len)\n\n            shortest = other._len;\n\n\n\n        uint selfptr = self._ptr;\n\n        uint otherptr = other._ptr;\n\n        for (uint idx = 0; idx < shortest; idx += 32) {\n\n            uint a;\n\n            uint b;\n\n            assembly {\n\n                a := mload(selfptr)\n\n                b := mload(otherptr)\n\n            }\n\n            if (a != b) {\n\n                // Mask out irrelevant bytes and check again\n\n                uint256 mask = uint256(-1); // 0xffff...\n\n                if(shortest < 32) {\n\n                  mask = ~(2 ** (8 * (32 - shortest + idx)) - 1);\n\n                }\n\n                uint256 diff = (a & mask) - (b & mask);\n\n                if (diff != 0)\n\n                    return int(diff);\n\n            }\n\n            selfptr += 32;\n\n            otherptr += 32;\n\n        }\n\n        return int(self._len) - int(other._len);\n",
          "message": "strings.compare (tokenWhitelistable.sol#957-985) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 1004,
          "vulnerability_to_line": 1038,
          "vulnerability_code": "    function nextRune(slice memory self, slice memory rune) internal pure returns (slice memory) {\n\n        rune._ptr = self._ptr;\n\n\n\n        if (self._len == 0) {\n\n            rune._len = 0;\n\n            return rune;\n\n        }\n\n\n\n        uint l;\n\n        uint b;\n\n        // Load the first byte of the rune into the LSBs of b\n\n        assembly { b := and(mload(sub(mload(add(self, 32)), 31)), 0xFF) }\n\n        if (b < 0x80) {\n\n            l = 1;\n\n        } else if(b < 0xE0) {\n\n            l = 2;\n\n        } else if(b < 0xF0) {\n\n            l = 3;\n\n        } else {\n\n            l = 4;\n\n        }\n\n\n\n        // Check for truncated codepoints\n\n        if (l > self._len) {\n\n            rune._len = self._len;\n\n            self._ptr += self._len;\n\n            self._len = 0;\n\n            return rune;\n\n        }\n\n\n\n        self._ptr += l;\n\n        self._len -= l;\n\n        rune._len = l;\n\n        return rune;\n",
          "message": "strings.nextRune (tokenWhitelistable.sol#1004-1038) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 1055,
          "vulnerability_to_line": 1097,
          "vulnerability_code": "    function ord(slice memory self) internal pure returns (uint ret) {\n\n        if (self._len == 0) {\n\n            return 0;\n\n        }\n\n\n\n        uint word;\n\n        uint length;\n\n        uint divisor = 2 ** 248;\n\n\n\n        // Load the rune into the MSBs of b\n\n        assembly { word:= mload(mload(add(self, 32))) }\n\n        uint b = word / divisor;\n\n        if (b < 0x80) {\n\n            ret = b;\n\n            length = 1;\n\n        } else if(b < 0xE0) {\n\n            ret = b & 0x1F;\n\n            length = 2;\n\n        } else if(b < 0xF0) {\n\n            ret = b & 0x0F;\n\n            length = 3;\n\n        } else {\n\n            ret = b & 0x07;\n\n            length = 4;\n\n        }\n\n\n\n        // Check for truncated codepoints\n\n        if (length > self._len) {\n\n            return 0;\n\n        }\n\n\n\n        for (uint i = 1; i < length; i++) {\n\n            divisor = divisor / 256;\n\n            b = (word / divisor) & 0xFF;\n\n            if (b & 0xC0 != 0x80) {\n\n                // Invalid UTF-8 sequence\n\n                return 0;\n\n            }\n\n            ret = (ret * 64) | (b & 0x3F);\n\n        }\n\n\n\n        return ret;\n",
          "message": "strings.ord (tokenWhitelistable.sol#1055-1097) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 1104,
          "vulnerability_to_line": 1108,
          "vulnerability_code": "    function keccak(slice memory self) internal pure returns (bytes32 ret) {\n\n        assembly {\n\n            ret := keccak256(mload(add(self, 32)), mload(self))\n\n        }\n",
          "message": "strings.keccak (tokenWhitelistable.sol#1104-1108) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 1116,
          "vulnerability_to_line": 1133,
          "vulnerability_code": "    function startsWith(slice memory self, slice memory needle) internal pure returns (bool) {\n\n        if (self._len < needle._len) {\n\n            return false;\n\n        }\n\n\n\n        if (self._ptr == needle._ptr) {\n\n            return true;\n\n        }\n\n\n\n        bool equal;\n\n        assembly {\n\n            let length := mload(needle)\n\n            let selfptr := mload(add(self, 0x20))\n\n            let needleptr := mload(add(needle, 0x20))\n\n            equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\n\n        }\n\n        return equal;\n",
          "message": "strings.startsWith (tokenWhitelistable.sol#1116-1133) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 1142,
          "vulnerability_to_line": 1163,
          "vulnerability_code": "    function beyond(slice memory self, slice memory needle) internal pure returns (slice memory) {\n\n        if (self._len < needle._len) {\n\n            return self;\n\n        }\n\n\n\n        bool equal = true;\n\n        if (self._ptr != needle._ptr) {\n\n            assembly {\n\n                let length := mload(needle)\n\n                let selfptr := mload(add(self, 0x20))\n\n                let needleptr := mload(add(needle, 0x20))\n\n                equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\n\n            }\n\n        }\n\n\n\n        if (equal) {\n\n            self._len -= needle._len;\n\n            self._ptr += needle._len;\n\n        }\n\n\n\n        return self;\n",
          "message": "strings.beyond (tokenWhitelistable.sol#1142-1163) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 1171,
          "vulnerability_to_line": 1190,
          "vulnerability_code": "    function endsWith(slice memory self, slice memory needle) internal pure returns (bool) {\n\n        if (self._len < needle._len) {\n\n            return false;\n\n        }\n\n\n\n        uint selfptr = self._ptr + self._len - needle._len;\n\n\n\n        if (selfptr == needle._ptr) {\n\n            return true;\n\n        }\n\n\n\n        bool equal;\n\n        assembly {\n\n            let length := mload(needle)\n\n            let needleptr := mload(add(needle, 0x20))\n\n            equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\n\n        }\n\n\n\n        return equal;\n",
          "message": "strings.endsWith (tokenWhitelistable.sol#1171-1190) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 1199,
          "vulnerability_to_line": 1219,
          "vulnerability_code": "    function until(slice memory self, slice memory needle) internal pure returns (slice memory) {\n\n        if (self._len < needle._len) {\n\n            return self;\n\n        }\n\n\n\n        uint selfptr = self._ptr + self._len - needle._len;\n\n        bool equal = true;\n\n        if (selfptr != needle._ptr) {\n\n            assembly {\n\n                let length := mload(needle)\n\n                let needleptr := mload(add(needle, 0x20))\n\n                equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\n\n            }\n\n        }\n\n\n\n        if (equal) {\n\n            self._len -= needle._len;\n\n        }\n\n\n\n        return self;\n",
          "message": "strings.until (tokenWhitelistable.sol#1199-1219) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 1223,
          "vulnerability_to_line": 1260,
          "vulnerability_code": "    function findPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) {\n\n        uint ptr = selfptr;\n\n        uint idx;\n\n\n\n        if (needlelen <= selflen) {\n\n            if (needlelen <= 32) {\n\n                bytes32 mask = bytes32(~(2 ** (8 * (32 - needlelen)) - 1));\n\n\n\n                bytes32 needledata;\n\n                assembly { needledata := and(mload(needleptr), mask) }\n\n\n\n                uint end = selfptr + selflen - needlelen;\n\n                bytes32 ptrdata;\n\n                assembly { ptrdata := and(mload(ptr), mask) }\n\n\n\n                while (ptrdata != needledata) {\n\n                    if (ptr >= end)\n\n                        return selfptr + selflen;\n\n                    ptr++;\n\n                    assembly { ptrdata := and(mload(ptr), mask) }\n\n                }\n\n                return ptr;\n\n            } else {\n\n                // For long needles, use hashing\n\n                bytes32 hash;\n\n                assembly { hash := keccak256(needleptr, needlelen) }\n\n\n\n                for (idx = 0; idx <= selflen - needlelen; idx++) {\n\n                    bytes32 testHash;\n\n                    assembly { testHash := keccak256(ptr, needlelen) }\n\n                    if (hash == testHash)\n\n                        return ptr;\n\n                    ptr += 1;\n\n                }\n\n            }\n\n        }\n\n        return selfptr + selflen;\n",
          "message": "strings.findPtr (tokenWhitelistable.sol#1223-1260) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 1264,
          "vulnerability_to_line": 1300,
          "vulnerability_code": "    function rfindPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) {\n\n        uint ptr;\n\n\n\n        if (needlelen <= selflen) {\n\n            if (needlelen <= 32) {\n\n                bytes32 mask = bytes32(~(2 ** (8 * (32 - needlelen)) - 1));\n\n\n\n                bytes32 needledata;\n\n                assembly { needledata := and(mload(needleptr), mask) }\n\n\n\n                ptr = selfptr + selflen - needlelen;\n\n                bytes32 ptrdata;\n\n                assembly { ptrdata := and(mload(ptr), mask) }\n\n\n\n                while (ptrdata != needledata) {\n\n                    if (ptr <= selfptr)\n\n                        return selfptr;\n\n                    ptr--;\n\n                    assembly { ptrdata := and(mload(ptr), mask) }\n\n                }\n\n                return ptr + needlelen;\n\n            } else {\n\n                // For long needles, use hashing\n\n                bytes32 hash;\n\n                assembly { hash := keccak256(needleptr, needlelen) }\n\n                ptr = selfptr + (selflen - needlelen);\n\n                while (ptr >= selfptr) {\n\n                    bytes32 testHash;\n\n                    assembly { testHash := keccak256(ptr, needlelen) }\n\n                    if (hash == testHash)\n\n                        return ptr + needlelen;\n\n                    ptr -= 1;\n\n                }\n\n            }\n\n        }\n\n        return selfptr;\n",
          "message": "strings.rfindPtr (tokenWhitelistable.sol#1264-1300) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 1435,
          "vulnerability_to_line": 1442,
          "vulnerability_code": "    function concat(slice memory self, slice memory other) internal pure returns (string memory) {\n\n        string memory ret = new string(self._len + other._len);\n\n        uint retptr;\n\n        assembly { retptr := add(ret, 32) }\n\n        memcpy(retptr, self._ptr, self._len);\n\n        memcpy(retptr + self._len, other._ptr, other._len);\n\n        return ret;\n",
          "message": "strings.concat (tokenWhitelistable.sol#1435-1442) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 1452,
          "vulnerability_to_line": 1474,
          "vulnerability_code": "    function join(slice memory self, slice[] memory parts) internal pure returns (string memory) {\n\n        if (parts.length == 0)\n\n            return \"\";\n\n\n\n        uint length = self._len * (parts.length - 1);\n\n        for(uint i = 0; i < parts.length; i++)\n\n            length += parts[i]._len;\n\n\n\n        string memory ret = new string(length);\n\n        uint retptr;\n\n        assembly { retptr := add(ret, 32) }\n\n\n\n        for(i = 0; i < parts.length; i++) {\n\n            memcpy(retptr, parts[i]._ptr, parts[i]._len);\n\n            retptr += parts[i]._len;\n\n            if (i < parts.length - 1) {\n\n                memcpy(retptr, self._ptr, self._len);\n\n                retptr += self._len;\n\n            }\n\n        }\n\n\n\n        return ret;\n",
          "message": "strings.join (tokenWhitelistable.sol#1452-1474) is declared view but contains assembly code\n"
        },
        {
          "name": "uninitialized-local",
          "vulnerability_from_line": 842,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint ret;\n",
          "message": "ret in strings.len (tokenWhitelistable.sol#842) is a local variable never initialiazed\n"
        },
        {
          "name": "shadowing-local",
          "vulnerability_from_line": 361,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setSubnodeOwner(bytes32 node, bytes32 label, address owner) external;\n",
          "message": "ENS.setSubnodeOwner.owner (local variable @ tokenWhitelistable.sol#361) shadows:\n\t- ENS.owner (function @ tokenWhitelistable.sol#365)\n"
        },
        {
          "name": "shadowing-local",
          "vulnerability_from_line": 362,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setResolver(bytes32 node, address resolver) external;\n",
          "message": "ENS.setResolver.resolver (local variable @ tokenWhitelistable.sol#362) shadows:\n\t- ENS.resolver (function @ tokenWhitelistable.sol#366)\n"
        },
        {
          "name": "shadowing-local",
          "vulnerability_from_line": 363,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setOwner(bytes32 node, address owner) external;\n",
          "message": "ENS.setOwner.owner (local variable @ tokenWhitelistable.sol#363) shadows:\n\t- ENS.owner (function @ tokenWhitelistable.sol#365)\n"
        },
        {
          "name": "shadowing-local",
          "vulnerability_from_line": 364,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setTTL(bytes32 node, uint64 ttl) external;\n",
          "message": "ENS.setTTL.ttl (local variable @ tokenWhitelistable.sol#364) shadows:\n\t- ENS.ttl (function @ tokenWhitelistable.sol#367)\n"
        },
        {
          "name": "shadowing-local",
          "vulnerability_from_line": 464,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setAddr(bytes32 node, address addr) public only_owner(node) {\n",
          "message": "PublicResolver.setAddr.addr (local variable @ tokenWhitelistable.sol#464) shadows:\n\t- PublicResolver.addr (function @ tokenWhitelistable.sol#617-619)\n"
        },
        {
          "name": "shadowing-local",
          "vulnerability_from_line": 499,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setName(bytes32 node, string name) public only_owner(node) {\n",
          "message": "PublicResolver.setName.name (local variable @ tokenWhitelistable.sol#499) shadows:\n\t- PublicResolver.name (function @ tokenWhitelistable.sol#588-590)\n"
        },
        {
          "name": "shadowing-local",
          "vulnerability_from_line": 804,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function memcpy(uint dest, uint src, uint len) private pure {\n",
          "message": "strings.memcpy.len (local variable @ tokenWhitelistable.sol#804) shadows:\n\t- strings.len (function @ tokenWhitelistable.sol#841-865)\n\t- strings.len (function @ tokenWhitelistable.sol#916-937)\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 804,
          "vulnerability_to_line": 821,
          "vulnerability_code": "    function memcpy(uint dest, uint src, uint len) private pure {\n\n        // Copy word-length chunks while possible\n\n        for(; len >= 32; len -= 32) {\n\n            assembly {\n\n                mstore(dest, mload(src))\n\n            }\n\n            dest += 32;\n\n            src += 32;\n\n        }\n\n\n\n        // Copy remaining bytes\n\n        uint mask = 256 ** (32 - len) - 1;\n\n        assembly {\n\n            let srcpart := and(mload(src), not(mask))\n\n            let destpart := and(mload(dest), mask)\n\n            mstore(dest, or(destpart, srcpart))\n\n        }\n",
          "message": "strings.memcpy uses assembly (tokenWhitelistable.sol#804-821)\n\t- tokenWhitelistable.sol#807-810\n\t- tokenWhitelistable.sol#816-821\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 828,
          "vulnerability_to_line": 834,
          "vulnerability_code": "    function toSlice(string memory self) internal pure returns (slice memory) {\n\n        uint ptr;\n\n        assembly {\n\n            ptr := add(self, 0x20)\n\n        }\n\n        return slice(bytes(self).length, ptr);\n",
          "message": "strings.toSlice uses assembly (tokenWhitelistable.sol#828-834)\n\t- tokenWhitelistable.sol#830-833\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 874,
          "vulnerability_to_line": 883,
          "vulnerability_code": "    function toSliceB32(bytes32 self) internal pure returns (slice memory ret) {\n\n        // Allocate space for `self` in memory, copy it there, and point ret at it\n\n        assembly {\n\n            let ptr := mload(0x40)\n\n            mstore(0x40, add(ptr, 0x20))\n\n            mstore(ptr, self)\n\n            mstore(add(ret, 0x20), ptr)\n\n        }\n\n        ret._len = len(self);\n",
          "message": "strings.toSliceB32 uses assembly (tokenWhitelistable.sol#874-883)\n\t- tokenWhitelistable.sol#876-882\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 899,
          "vulnerability_to_line": 906,
          "vulnerability_code": "    function toString(slice memory self) internal pure returns (string memory) {\n\n        string memory ret = new string(self._len);\n\n        uint retptr;\n\n        assembly { retptr := add(ret, 32) }\n\n\n\n        memcpy(retptr, self._ptr, self._len);\n\n        return ret;\n",
          "message": "strings.toString uses assembly (tokenWhitelistable.sol#899-906)\n\t- tokenWhitelistable.sol#902-904\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 916,
          "vulnerability_to_line": 937,
          "vulnerability_code": "    function len(slice memory self) internal pure returns (uint l) {\n\n        // Starting at ptr-31 means the LSB will be the byte we care about\n\n        uint ptr = self._ptr - 31;\n\n        uint end = ptr + self._len;\n\n        for (l = 0; ptr < end; l++) {\n\n            uint8 b;\n\n            assembly { b := and(mload(ptr), 0xFF) }\n\n            if (b < 0x80) {\n\n                ptr += 1;\n\n            } else if(b < 0xE0) {\n\n                ptr += 2;\n\n            } else if(b < 0xF0) {\n\n                ptr += 3;\n\n            } else if(b < 0xF8) {\n\n                ptr += 4;\n\n            } else if(b < 0xFC) {\n\n                ptr += 5;\n\n            } else {\n\n                ptr += 6;\n\n            }\n\n        }\n",
          "message": "strings.len uses assembly (tokenWhitelistable.sol#916-937)\n\t- tokenWhitelistable.sol#922-923\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 957,
          "vulnerability_to_line": 985,
          "vulnerability_code": "    function compare(slice memory self, slice memory other) internal pure returns (int) {\n\n        uint shortest = self._len;\n\n        if (other._len < self._len)\n\n            shortest = other._len;\n\n\n\n        uint selfptr = self._ptr;\n\n        uint otherptr = other._ptr;\n\n        for (uint idx = 0; idx < shortest; idx += 32) {\n\n            uint a;\n\n            uint b;\n\n            assembly {\n\n                a := mload(selfptr)\n\n                b := mload(otherptr)\n\n            }\n\n            if (a != b) {\n\n                // Mask out irrelevant bytes and check again\n\n                uint256 mask = uint256(-1); // 0xffff...\n\n                if(shortest < 32) {\n\n                  mask = ~(2 ** (8 * (32 - shortest + idx)) - 1);\n\n                }\n\n                uint256 diff = (a & mask) - (b & mask);\n\n                if (diff != 0)\n\n                    return int(diff);\n\n            }\n\n            selfptr += 32;\n\n            otherptr += 32;\n\n        }\n\n        return int(self._len) - int(other._len);\n",
          "message": "strings.compare uses assembly (tokenWhitelistable.sol#957-985)\n\t- tokenWhitelistable.sol#967-971\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 1004,
          "vulnerability_to_line": 1038,
          "vulnerability_code": "    function nextRune(slice memory self, slice memory rune) internal pure returns (slice memory) {\n\n        rune._ptr = self._ptr;\n\n\n\n        if (self._len == 0) {\n\n            rune._len = 0;\n\n            return rune;\n\n        }\n\n\n\n        uint l;\n\n        uint b;\n\n        // Load the first byte of the rune into the LSBs of b\n\n        assembly { b := and(mload(sub(mload(add(self, 32)), 31)), 0xFF) }\n\n        if (b < 0x80) {\n\n            l = 1;\n\n        } else if(b < 0xE0) {\n\n            l = 2;\n\n        } else if(b < 0xF0) {\n\n            l = 3;\n\n        } else {\n\n            l = 4;\n\n        }\n\n\n\n        // Check for truncated codepoints\n\n        if (l > self._len) {\n\n            rune._len = self._len;\n\n            self._ptr += self._len;\n\n            self._len = 0;\n\n            return rune;\n\n        }\n\n\n\n        self._ptr += l;\n\n        self._len -= l;\n\n        rune._len = l;\n\n        return rune;\n",
          "message": "strings.nextRune uses assembly (tokenWhitelistable.sol#1004-1038)\n\t- tokenWhitelistable.sol#1015-1016\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 1055,
          "vulnerability_to_line": 1097,
          "vulnerability_code": "    function ord(slice memory self) internal pure returns (uint ret) {\n\n        if (self._len == 0) {\n\n            return 0;\n\n        }\n\n\n\n        uint word;\n\n        uint length;\n\n        uint divisor = 2 ** 248;\n\n\n\n        // Load the rune into the MSBs of b\n\n        assembly { word:= mload(mload(add(self, 32))) }\n\n        uint b = word / divisor;\n\n        if (b < 0x80) {\n\n            ret = b;\n\n            length = 1;\n\n        } else if(b < 0xE0) {\n\n            ret = b & 0x1F;\n\n            length = 2;\n\n        } else if(b < 0xF0) {\n\n            ret = b & 0x0F;\n\n            length = 3;\n\n        } else {\n\n            ret = b & 0x07;\n\n            length = 4;\n\n        }\n\n\n\n        // Check for truncated codepoints\n\n        if (length > self._len) {\n\n            return 0;\n\n        }\n\n\n\n        for (uint i = 1; i < length; i++) {\n\n            divisor = divisor / 256;\n\n            b = (word / divisor) & 0xFF;\n\n            if (b & 0xC0 != 0x80) {\n\n                // Invalid UTF-8 sequence\n\n                return 0;\n\n            }\n\n            ret = (ret * 64) | (b & 0x3F);\n\n        }\n\n\n\n        return ret;\n",
          "message": "strings.ord uses assembly (tokenWhitelistable.sol#1055-1097)\n\t- tokenWhitelistable.sol#1065-1066\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 1104,
          "vulnerability_to_line": 1108,
          "vulnerability_code": "    function keccak(slice memory self) internal pure returns (bytes32 ret) {\n\n        assembly {\n\n            ret := keccak256(mload(add(self, 32)), mload(self))\n\n        }\n",
          "message": "strings.keccak uses assembly (tokenWhitelistable.sol#1104-1108)\n\t- tokenWhitelistable.sol#1105-1108\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 1116,
          "vulnerability_to_line": 1133,
          "vulnerability_code": "    function startsWith(slice memory self, slice memory needle) internal pure returns (bool) {\n\n        if (self._len < needle._len) {\n\n            return false;\n\n        }\n\n\n\n        if (self._ptr == needle._ptr) {\n\n            return true;\n\n        }\n\n\n\n        bool equal;\n\n        assembly {\n\n            let length := mload(needle)\n\n            let selfptr := mload(add(self, 0x20))\n\n            let needleptr := mload(add(needle, 0x20))\n\n            equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\n\n        }\n\n        return equal;\n",
          "message": "strings.startsWith uses assembly (tokenWhitelistable.sol#1116-1133)\n\t- tokenWhitelistable.sol#1126-1132\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 1142,
          "vulnerability_to_line": 1163,
          "vulnerability_code": "    function beyond(slice memory self, slice memory needle) internal pure returns (slice memory) {\n\n        if (self._len < needle._len) {\n\n            return self;\n\n        }\n\n\n\n        bool equal = true;\n\n        if (self._ptr != needle._ptr) {\n\n            assembly {\n\n                let length := mload(needle)\n\n                let selfptr := mload(add(self, 0x20))\n\n                let needleptr := mload(add(needle, 0x20))\n\n                equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\n\n            }\n\n        }\n\n\n\n        if (equal) {\n\n            self._len -= needle._len;\n\n            self._ptr += needle._len;\n\n        }\n\n\n\n        return self;\n",
          "message": "strings.beyond uses assembly (tokenWhitelistable.sol#1142-1163)\n\t- tokenWhitelistable.sol#1149-1155\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 1171,
          "vulnerability_to_line": 1190,
          "vulnerability_code": "    function endsWith(slice memory self, slice memory needle) internal pure returns (bool) {\n\n        if (self._len < needle._len) {\n\n            return false;\n\n        }\n\n\n\n        uint selfptr = self._ptr + self._len - needle._len;\n\n\n\n        if (selfptr == needle._ptr) {\n\n            return true;\n\n        }\n\n\n\n        bool equal;\n\n        assembly {\n\n            let length := mload(needle)\n\n            let needleptr := mload(add(needle, 0x20))\n\n            equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\n\n        }\n\n\n\n        return equal;\n",
          "message": "strings.endsWith uses assembly (tokenWhitelistable.sol#1171-1190)\n\t- tokenWhitelistable.sol#1183-1189\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 1199,
          "vulnerability_to_line": 1219,
          "vulnerability_code": "    function until(slice memory self, slice memory needle) internal pure returns (slice memory) {\n\n        if (self._len < needle._len) {\n\n            return self;\n\n        }\n\n\n\n        uint selfptr = self._ptr + self._len - needle._len;\n\n        bool equal = true;\n\n        if (selfptr != needle._ptr) {\n\n            assembly {\n\n                let length := mload(needle)\n\n                let needleptr := mload(add(needle, 0x20))\n\n                equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\n\n            }\n\n        }\n\n\n\n        if (equal) {\n\n            self._len -= needle._len;\n\n        }\n\n\n\n        return self;\n",
          "message": "strings.until uses assembly (tokenWhitelistable.sol#1199-1219)\n\t- tokenWhitelistable.sol#1207-1212\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 1223,
          "vulnerability_to_line": 1260,
          "vulnerability_code": "    function findPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) {\n\n        uint ptr = selfptr;\n\n        uint idx;\n\n\n\n        if (needlelen <= selflen) {\n\n            if (needlelen <= 32) {\n\n                bytes32 mask = bytes32(~(2 ** (8 * (32 - needlelen)) - 1));\n\n\n\n                bytes32 needledata;\n\n                assembly { needledata := and(mload(needleptr), mask) }\n\n\n\n                uint end = selfptr + selflen - needlelen;\n\n                bytes32 ptrdata;\n\n                assembly { ptrdata := and(mload(ptr), mask) }\n\n\n\n                while (ptrdata != needledata) {\n\n                    if (ptr >= end)\n\n                        return selfptr + selflen;\n\n                    ptr++;\n\n                    assembly { ptrdata := and(mload(ptr), mask) }\n\n                }\n\n                return ptr;\n\n            } else {\n\n                // For long needles, use hashing\n\n                bytes32 hash;\n\n                assembly { hash := keccak256(needleptr, needlelen) }\n\n\n\n                for (idx = 0; idx <= selflen - needlelen; idx++) {\n\n                    bytes32 testHash;\n\n                    assembly { testHash := keccak256(ptr, needlelen) }\n\n                    if (hash == testHash)\n\n                        return ptr;\n\n                    ptr += 1;\n\n                }\n\n            }\n\n        }\n\n        return selfptr + selflen;\n",
          "message": "strings.findPtr uses assembly (tokenWhitelistable.sol#1223-1260)\n\t- tokenWhitelistable.sol#1232-1234\n\t- tokenWhitelistable.sol#1236-1238\n\t- tokenWhitelistable.sol#1242-1243\n\t- tokenWhitelistable.sol#1248-1250\n\t- tokenWhitelistable.sol#1252-1253\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 1264,
          "vulnerability_to_line": 1300,
          "vulnerability_code": "    function rfindPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) {\n\n        uint ptr;\n\n\n\n        if (needlelen <= selflen) {\n\n            if (needlelen <= 32) {\n\n                bytes32 mask = bytes32(~(2 ** (8 * (32 - needlelen)) - 1));\n\n\n\n                bytes32 needledata;\n\n                assembly { needledata := and(mload(needleptr), mask) }\n\n\n\n                ptr = selfptr + selflen - needlelen;\n\n                bytes32 ptrdata;\n\n                assembly { ptrdata := and(mload(ptr), mask) }\n\n\n\n                while (ptrdata != needledata) {\n\n                    if (ptr <= selfptr)\n\n                        return selfptr;\n\n                    ptr--;\n\n                    assembly { ptrdata := and(mload(ptr), mask) }\n\n                }\n\n                return ptr + needlelen;\n\n            } else {\n\n                // For long needles, use hashing\n\n                bytes32 hash;\n\n                assembly { hash := keccak256(needleptr, needlelen) }\n\n                ptr = selfptr + (selflen - needlelen);\n\n                while (ptr >= selfptr) {\n\n                    bytes32 testHash;\n\n                    assembly { testHash := keccak256(ptr, needlelen) }\n\n                    if (hash == testHash)\n\n                        return ptr + needlelen;\n\n                    ptr -= 1;\n\n                }\n\n            }\n\n        }\n\n        return selfptr;\n",
          "message": "strings.rfindPtr uses assembly (tokenWhitelistable.sol#1264-1300)\n\t- tokenWhitelistable.sol#1272-1274\n\t- tokenWhitelistable.sol#1276-1278\n\t- tokenWhitelistable.sol#1282-1283\n\t- tokenWhitelistable.sol#1288-1289\n\t- tokenWhitelistable.sol#1292-1293\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 1435,
          "vulnerability_to_line": 1442,
          "vulnerability_code": "    function concat(slice memory self, slice memory other) internal pure returns (string memory) {\n\n        string memory ret = new string(self._len + other._len);\n\n        uint retptr;\n\n        assembly { retptr := add(ret, 32) }\n\n        memcpy(retptr, self._ptr, self._len);\n\n        memcpy(retptr + self._len, other._ptr, other._len);\n\n        return ret;\n",
          "message": "strings.concat uses assembly (tokenWhitelistable.sol#1435-1442)\n\t- tokenWhitelistable.sol#1438-1439\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 1452,
          "vulnerability_to_line": 1474,
          "vulnerability_code": "    function join(slice memory self, slice[] memory parts) internal pure returns (string memory) {\n\n        if (parts.length == 0)\n\n            return \"\";\n\n\n\n        uint length = self._len * (parts.length - 1);\n\n        for(uint i = 0; i < parts.length; i++)\n\n            length += parts[i]._len;\n\n\n\n        string memory ret = new string(length);\n\n        uint retptr;\n\n        assembly { retptr := add(ret, 32) }\n\n\n\n        for(i = 0; i < parts.length; i++) {\n\n            memcpy(retptr, parts[i]._ptr, parts[i]._len);\n\n            retptr += parts[i]._len;\n\n            if (i < parts.length - 1) {\n\n                memcpy(retptr, self._ptr, self._len);\n\n                retptr += self._len;\n\n            }\n\n        }\n\n\n\n        return ret;\n",
          "message": "strings.join uses assembly (tokenWhitelistable.sol#1452-1474)\n\t- tokenWhitelistable.sol#1462-1464\n"
        },
        {
          "name": "pragma",
          "vulnerability_from_line": 21,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.25;\n",
          "message": "Different versions of Solidity is used in tokenWhitelistable.sol:\n\t- Version used: ['>=0.4.24', '^0.4.14', '^0.4.24', '^0.4.25']\n\t- tokenWhitelistable.sol#21 declares pragma solidity^0.4.25\n\t- tokenWhitelistable.sol#105 declares pragma solidity^0.4.25\n\t- tokenWhitelistable.sol#135 declares pragma solidity^0.4.25\n\t- tokenWhitelistable.sol#179 declares pragma solidity^0.4.25\n\t- tokenWhitelistable.sol#344 declares pragma solidity>=0.4.24\n\t- tokenWhitelistable.sol#401 declares pragma solidity^0.4.24\n\t- tokenWhitelistable.sol#658 declares pragma solidity^0.4.25\n\t- tokenWhitelistable.sol#710 declares pragma solidity^0.4.25\n\t- tokenWhitelistable.sol#796 declares pragma solidity^0.4.14\n\t- tokenWhitelistable.sol#1504 declares pragma solidity^0.4.24\n\t- tokenWhitelistable.sol#1590 declares pragma solidity^0.4.25\n\t- tokenWhitelistable.sol#1792 declares pragma solidity^0.4.25\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 92,
          "vulnerability_to_line": 94,
          "vulnerability_code": "    function owner() public view returns (address) {\n\n        return _owner;\n",
          "message": "Ownable.owner (tokenWhitelistable.sol#92-94) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 464,
          "vulnerability_to_line": 467,
          "vulnerability_code": "    function setAddr(bytes32 node, address addr) public only_owner(node) {\n\n        records[node].addr = addr;\n\n        emit AddrChanged(node, addr);\n",
          "message": "PublicResolver.setAddr (tokenWhitelistable.sol#464-467) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 477,
          "vulnerability_to_line": 480,
          "vulnerability_code": "    function setContent(bytes32 node, bytes32 hash) public only_owner(node) {\n\n        records[node].content = hash;\n\n        emit ContentChanged(node, hash);\n",
          "message": "PublicResolver.setContent (tokenWhitelistable.sol#477-480) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 488,
          "vulnerability_to_line": 491,
          "vulnerability_code": "    function setMultihash(bytes32 node, bytes hash) public only_owner(node) {\n\n        records[node].multihash = hash;\n\n        emit MultihashChanged(node, hash);\n",
          "message": "PublicResolver.setMultihash (tokenWhitelistable.sol#488-491) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 499,
          "vulnerability_to_line": 502,
          "vulnerability_code": "    function setName(bytes32 node, string name) public only_owner(node) {\n\n        records[node].name = name;\n\n        emit NameChanged(node, name);\n",
          "message": "PublicResolver.setName (tokenWhitelistable.sol#499-502) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 512,
          "vulnerability_to_line": 518,
          "vulnerability_code": "    function setABI(bytes32 node, uint256 contentType, bytes data) public only_owner(node) {\n\n        // Content types must be powers of 2\n\n        require(((contentType - 1) & contentType) == 0);\n\n        \n\n        records[node].abis[contentType] = data;\n\n        emit ABIChanged(node, contentType);\n",
          "message": "PublicResolver.setABI (tokenWhitelistable.sol#512-518) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 526,
          "vulnerability_to_line": 529,
          "vulnerability_code": "    function setPubkey(bytes32 node, bytes32 x, bytes32 y) public only_owner(node) {\n\n        records[node].pubkey = PublicKey(x, y);\n\n        emit PubkeyChanged(node, x, y);\n",
          "message": "PublicResolver.setPubkey (tokenWhitelistable.sol#526-529) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 538,
          "vulnerability_to_line": 541,
          "vulnerability_code": "    function setText(bytes32 node, string key, string value) public only_owner(node) {\n\n        records[node].text[key] = value;\n\n        emit TextChanged(node, key, key);\n",
          "message": "PublicResolver.setText (tokenWhitelistable.sol#538-541) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 549,
          "vulnerability_to_line": 551,
          "vulnerability_code": "    function text(bytes32 node, string key) public view returns (string) {\n\n        return records[node].text[key];\n",
          "message": "PublicResolver.text (tokenWhitelistable.sol#549-551) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 559,
          "vulnerability_to_line": 561,
          "vulnerability_code": "    function pubkey(bytes32 node) public view returns (bytes32 x, bytes32 y) {\n\n        return (records[node].pubkey.x, records[node].pubkey.y);\n",
          "message": "PublicResolver.pubkey (tokenWhitelistable.sol#559-561) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 571,
          "vulnerability_to_line": 580,
          "vulnerability_code": "    function ABI(bytes32 node, uint256 contentTypes) public view returns (uint256 contentType, bytes data) {\n\n        Record storage record = records[node];\n\n        for (contentType = 1; contentType <= contentTypes; contentType <<= 1) {\n\n            if ((contentType & contentTypes) != 0 && record.abis[contentType].length > 0) {\n\n                data = record.abis[contentType];\n\n                return;\n\n            }\n\n        }\n\n        contentType = 0;\n",
          "message": "PublicResolver.ABI (tokenWhitelistable.sol#571-580) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 588,
          "vulnerability_to_line": 590,
          "vulnerability_code": "    function name(bytes32 node) public view returns (string) {\n\n        return records[node].name;\n",
          "message": "PublicResolver.name (tokenWhitelistable.sol#588-590) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 599,
          "vulnerability_to_line": 601,
          "vulnerability_code": "    function content(bytes32 node) public view returns (bytes32) {\n\n        return records[node].content;\n",
          "message": "PublicResolver.content (tokenWhitelistable.sol#599-601) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 608,
          "vulnerability_to_line": 610,
          "vulnerability_code": "    function multihash(bytes32 node) public view returns (bytes) {\n\n        return records[node].multihash;\n",
          "message": "PublicResolver.multihash (tokenWhitelistable.sol#608-610) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 617,
          "vulnerability_to_line": 619,
          "vulnerability_code": "    function addr(bytes32 node) public view returns (address) {\n\n        return records[node].addr;\n",
          "message": "PublicResolver.addr (tokenWhitelistable.sol#617-619) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 626,
          "vulnerability_to_line": 635,
          "vulnerability_code": "    function supportsInterface(bytes4 interfaceID) public pure returns (bool) {\n\n        return interfaceID == ADDR_INTERFACE_ID ||\n\n        interfaceID == CONTENT_INTERFACE_ID ||\n\n        interfaceID == NAME_INTERFACE_ID ||\n\n        interfaceID == ABI_INTERFACE_ID ||\n\n        interfaceID == PUBKEY_INTERFACE_ID ||\n\n        interfaceID == TEXT_INTERFACE_ID ||\n\n        interfaceID == MULTIHASH_INTERFACE_ID ||\n\n        interfaceID == INTERFACE_META_ID;\n",
          "message": "PublicResolver.supportsInterface (tokenWhitelistable.sol#626-635) should be declared external\n"
        },
        {
          "name": "solc-version",
          "vulnerability_from_line": 796,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.14;\n",
          "message": "Detected issues with version pragma in tokenWhitelistable.sol:\n\t- pragma solidity^0.4.14 (tokenWhitelistable.sol#796): it allows old versions\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 36,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor(address _account_, bool _transferable_) internal {\n",
          "message": "Parameter '_account_' of Ownable. (tokenWhitelistable.sol#36) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 36,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor(address _account_, bool _transferable_) internal {\n",
          "message": "Parameter '_transferable_' of Ownable. (tokenWhitelistable.sol#36) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 55,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function transferOwnership(address _account, bool _transferable) external onlyOwner {\n",
          "message": "Parameter '_account' of Ownable.transferOwnership (tokenWhitelistable.sol#55) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 55,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function transferOwnership(address _account, bool _transferable) external onlyOwner {\n",
          "message": "Parameter '_transferable' of Ownable.transferOwnership (tokenWhitelistable.sol#55) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 98,
          "vulnerability_to_line": 100,
          "vulnerability_code": "    function _isOwner(address _address) internal view returns (bool) {\n\n        return _address == _owner;\n",
          "message": "Function 'Ownable._isOwner' (tokenWhitelistable.sol#98-100) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 98,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _isOwner(address _address) internal view returns (bool) {\n",
          "message": "Parameter '_address' of Ownable._isOwner (tokenWhitelistable.sol#98) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 109,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function approve(address, uint256) external returns (bool);\n",
          "message": "Parameter '' of ERC20.approve (tokenWhitelistable.sol#109) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 109,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function approve(address, uint256) external returns (bool);\n",
          "message": "Parameter '_scope_0' of ERC20.approve (tokenWhitelistable.sol#109) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 110,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function balanceOf(address) external view returns (uint);\n",
          "message": "Parameter '' of ERC20.balanceOf (tokenWhitelistable.sol#110) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 111,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function transfer(address, uint) external returns (bool);\n",
          "message": "Parameter '' of ERC20.transfer (tokenWhitelistable.sol#111) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 111,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function transfer(address, uint) external returns (bool);\n",
          "message": "Parameter '_scope_0' of ERC20.transfer (tokenWhitelistable.sol#111) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 147,
          "vulnerability_to_line": 156,
          "vulnerability_code": "    function _claim(address _to, address _asset, uint _amount) internal {\n\n        // address(0) is used to denote ETH\n\n        if (_asset == address(0)) {\n\n            _to.transfer(_amount);\n\n        } else {\n\n            require(ERC20(_asset).transfer(_to, _amount), \"ERC20 token transfer was unsuccessful\");\n\n        }\n\n\n\n        emit Claimed(_to, _asset, _amount);\n",
          "message": "Function 'Claimable._claim' (tokenWhitelistable.sol#147-156) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 147,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _claim(address _to, address _asset, uint _amount) internal {\n",
          "message": "Parameter '_to' of Claimable._claim (tokenWhitelistable.sol#147) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 147,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _claim(address _to, address _asset, uint _amount) internal {\n",
          "message": "Parameter '_asset' of Claimable._claim (tokenWhitelistable.sol#147) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 147,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _claim(address _to, address _asset, uint _amount) internal {\n",
          "message": "Parameter '_amount' of Claimable._claim (tokenWhitelistable.sol#147) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 184,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function isController(address) external view returns (bool);\n",
          "message": "Parameter '' of IController.isController (tokenWhitelistable.sol#184) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 267,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function isController(address _account) public view returns (bool) {\n",
          "message": "Parameter '_account' of Controller.isController (tokenWhitelistable.sol#267) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 226,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function addAdmin(address _account) external onlyOwner {\n",
          "message": "Parameter '_account' of Controller.addAdmin (tokenWhitelistable.sol#226) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 232,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function removeAdmin(address _account) external onlyOwner {\n",
          "message": "Parameter '_account' of Controller.removeAdmin (tokenWhitelistable.sol#232) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 243,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function addController(address _account) external onlyAdmin {\n",
          "message": "Parameter '_account' of Controller.addController (tokenWhitelistable.sol#243) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 249,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function removeController(address _account) external onlyAdmin {\n",
          "message": "Parameter '_account' of Controller.removeController (tokenWhitelistable.sol#249) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 261,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function isAdmin(address _account) public view returns (bool) {\n",
          "message": "Parameter '_account' of Controller.isAdmin (tokenWhitelistable.sol#261) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 272,
          "vulnerability_to_line": 280,
          "vulnerability_code": "    function _addAdmin(address _account) private {\n\n        require(!_isAdmin[_account], \"provided account is already an admin\");\n\n        require(!_isController[_account], \"provided account is already a controller\");\n\n        require(!_isOwner(_account), \"provided account is already the owner\");\n\n        require(_account != address(0), \"provided account is the zero address\");\n\n        _isAdmin[_account] = true;\n\n        _adminCount++;\n\n        emit AddedAdmin(msg.sender, _account);\n",
          "message": "Function 'Controller._addAdmin' (tokenWhitelistable.sol#272-280) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 272,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _addAdmin(address _account) private {\n",
          "message": "Parameter '_account' of Controller._addAdmin (tokenWhitelistable.sol#272) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 283,
          "vulnerability_to_line": 288,
          "vulnerability_code": "    function _removeAdmin(address _account) private {\n\n        require(_isAdmin[_account], \"provided account is not an admin\");\n\n        _isAdmin[_account] = false;\n\n        _adminCount--;\n\n        emit RemovedAdmin(msg.sender, _account);\n",
          "message": "Function 'Controller._removeAdmin' (tokenWhitelistable.sol#283-288) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 283,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _removeAdmin(address _account) private {\n",
          "message": "Parameter '_account' of Controller._removeAdmin (tokenWhitelistable.sol#283) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 291,
          "vulnerability_to_line": 299,
          "vulnerability_code": "    function _addController(address _account) private {\n\n        require(!_isAdmin[_account], \"provided account is already an admin\");\n\n        require(!_isController[_account], \"provided account is already a controller\");\n\n        require(!_isOwner(_account), \"provided account is already the owner\");\n\n        require(_account != address(0), \"provided account is the zero address\");\n\n        _isController[_account] = true;\n\n        _controllerCount++;\n\n        emit AddedController(msg.sender, _account);\n",
          "message": "Function 'Controller._addController' (tokenWhitelistable.sol#291-299) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 291,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _addController(address _account) private {\n",
          "message": "Parameter '_account' of Controller._addController (tokenWhitelistable.sol#291) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 302,
          "vulnerability_to_line": 307,
          "vulnerability_code": "    function _removeController(address _account) private {\n\n        require(_isController[_account], \"provided account is not a controller\");\n\n        _isController[_account] = false;\n\n        _controllerCount--;\n\n        emit RemovedController(msg.sender, _account);\n",
          "message": "Function 'Controller._removeController' (tokenWhitelistable.sol#302-307) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 302,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _removeController(address _account) private {\n",
          "message": "Parameter '_account' of Controller._removeController (tokenWhitelistable.sol#302) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 310,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function claim(address _to, address _asset, uint _amount) external onlyOwner {\n",
          "message": "Parameter '_to' of Controller.claim (tokenWhitelistable.sol#310) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 310,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function claim(address _to, address _asset, uint _amount) external onlyOwner {\n",
          "message": "Parameter '_asset' of Controller.claim (tokenWhitelistable.sol#310) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 310,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function claim(address _to, address _asset, uint _amount) external onlyOwner {\n",
          "message": "Parameter '_amount' of Controller.claim (tokenWhitelistable.sol#310) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 571,
          "vulnerability_to_line": 580,
          "vulnerability_code": "    function ABI(bytes32 node, uint256 contentTypes) public view returns (uint256 contentType, bytes data) {\n\n        Record storage record = records[node];\n\n        for (contentType = 1; contentType <= contentTypes; contentType <<= 1) {\n\n            if ((contentType & contentTypes) != 0 && record.abis[contentType].length > 0) {\n\n                data = record.abis[contentType];\n\n                return;\n\n            }\n\n        }\n\n        contentType = 0;\n",
          "message": "Function 'PublicResolver.ABI' (tokenWhitelistable.sol#571-580) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 445,
          "vulnerability_to_line": 448,
          "vulnerability_code": "    modifier only_owner(bytes32 node) {\n\n        require(ens.owner(node) == msg.sender);\n\n        _;\n",
          "message": "Modifier 'PublicResolver.only_owner' (tokenWhitelistable.sol#445-448) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 671,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor(address _ensReg_) internal {\n",
          "message": "Parameter '_ensReg_' of ENSResolvable. (tokenWhitelistable.sol#671) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 684,
          "vulnerability_to_line": 686,
          "vulnerability_code": "    function _ensResolve(bytes32 _nodeHash) internal view returns (address) {\n\n        return PublicResolver(_ens.resolver(_nodeHash)).addr(_nodeHash);\n",
          "message": "Function 'ENSResolvable._ensResolve' (tokenWhitelistable.sol#684-686) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 684,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _ensResolve(bytes32 _nodeHash) internal view returns (address) {\n",
          "message": "Parameter '_nodeHash' of ENSResolvable._ensResolve (tokenWhitelistable.sol#684) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 720,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor(bytes32 _controllerNameHash_) internal {\n",
          "message": "Parameter '_controllerNameHash_' of Controllable. (tokenWhitelistable.sol#720) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 736,
          "vulnerability_to_line": 738,
          "vulnerability_code": "    function _isController(address _account) internal view returns (bool) {\n\n        return IController(_ensResolve(_controllerNode)).isController(_account);\n",
          "message": "Function 'Controllable._isController' (tokenWhitelistable.sol#736-738) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 736,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _isController(address _account) internal view returns (bool) {\n",
          "message": "Parameter '_account' of Controllable._isController (tokenWhitelistable.sol#736) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 798,
          "vulnerability_to_line": 1475,
          "vulnerability_code": "library strings {\n\n    struct slice {\n\n        uint _len;\n\n        uint _ptr;\n\n    }\n\n\n\n    function memcpy(uint dest, uint src, uint len) private pure {\n\n        // Copy word-length chunks while possible\n\n        for(; len >= 32; len -= 32) {\n\n            assembly {\n\n                mstore(dest, mload(src))\n\n            }\n\n            dest += 32;\n\n            src += 32;\n\n        }\n\n\n\n        // Copy remaining bytes\n\n        uint mask = 256 ** (32 - len) - 1;\n\n        assembly {\n\n            let srcpart := and(mload(src), not(mask))\n\n            let destpart := and(mload(dest), mask)\n\n            mstore(dest, or(destpart, srcpart))\n\n        }\n\n    }\n\n\n\n    /*\n\n     * @dev Returns a slice containing the entire string.\n\n     * @param self The string to make a slice from.\n\n     * @return A newly allocated slice containing the entire string.\n\n     */\n\n    function toSlice(string memory self) internal pure returns (slice memory) {\n\n        uint ptr;\n\n        assembly {\n\n            ptr := add(self, 0x20)\n\n        }\n\n        return slice(bytes(self).length, ptr);\n\n    }\n\n\n\n    /*\n\n     * @dev Returns the length of a null-terminated bytes32 string.\n\n     * @param self The value to find the length of.\n\n     * @return The length of the string, from 0 to 32.\n\n     */\n\n    function len(bytes32 self) internal pure returns (uint) {\n\n        uint ret;\n\n        if (self == 0)\n\n            return 0;\n\n        if (self & 0xffffffffffffffffffffffffffffffff == 0) {\n\n            ret += 16;\n\n            self = bytes32(uint(self) / 0x100000000000000000000000000000000);\n\n        }\n\n        if (self & 0xffffffffffffffff == 0) {\n\n            ret += 8;\n\n            self = bytes32(uint(self) / 0x10000000000000000);\n\n        }\n\n        if (self & 0xffffffff == 0) {\n\n            ret += 4;\n\n            self = bytes32(uint(self) / 0x100000000);\n\n        }\n\n        if (self & 0xffff == 0) {\n\n            ret += 2;\n\n            self = bytes32(uint(self) / 0x10000);\n\n        }\n\n        if (self & 0xff == 0) {\n\n            ret += 1;\n\n        }\n\n        return 32 - ret;\n\n    }\n\n\n\n    /*\n\n     * @dev Returns a slice containing the entire bytes32, interpreted as a\n\n     *      null-terminated utf-8 string.\n\n     * @param self The bytes32 value to convert to a slice.\n\n     * @return A new slice containing the value of the input argument up to the\n\n     *         first null.\n\n     */\n\n    function toSliceB32(bytes32 self) internal pure returns (slice memory ret) {\n\n        // Allocate space for `self` in memory, copy it there, and point ret at it\n\n        assembly {\n\n            let ptr := mload(0x40)\n\n            mstore(0x40, add(ptr, 0x20))\n\n            mstore(ptr, self)\n\n            mstore(add(ret, 0x20), ptr)\n\n        }\n\n        ret._len = len(self);\n\n    }\n\n\n\n    /*\n\n     * @dev Returns a new slice containing the same data as the current slice.\n\n     * @param self The slice to copy.\n\n     * @return A new slice containing the same data as `self`.\n\n     */\n\n    function copy(slice memory self) internal pure returns (slice memory) {\n\n        return slice(self._len, self._ptr);\n\n    }\n\n\n\n    /*\n\n     * @dev Copies a slice to a new string.\n\n     * @param self The slice to copy.\n\n     * @return A newly allocated string containing the slice's text.\n\n     */\n\n    function toString(slice memory self) internal pure returns (string memory) {\n\n        string memory ret = new string(self._len);\n\n        uint retptr;\n\n        assembly { retptr := add(ret, 32) }\n\n\n\n        memcpy(retptr, self._ptr, self._len);\n\n        return ret;\n\n    }\n\n\n\n    /*\n\n     * @dev Returns the length in runes of the slice. Note that this operation\n\n     *      takes time proportional to the length of the slice; avoid using it\n\n     *      in loops, and call `slice.empty()` if you only need to know whether\n\n     *      the slice is empty or not.\n\n     * @param self The slice to operate on.\n\n     * @return The length of the slice in runes.\n\n     */\n\n    function len(slice memory self) internal pure returns (uint l) {\n\n        // Starting at ptr-31 means the LSB will be the byte we care about\n\n        uint ptr = self._ptr - 31;\n\n        uint end = ptr + self._len;\n\n        for (l = 0; ptr < end; l++) {\n\n            uint8 b;\n\n            assembly { b := and(mload(ptr), 0xFF) }\n\n            if (b < 0x80) {\n\n                ptr += 1;\n\n            } else if(b < 0xE0) {\n\n                ptr += 2;\n\n            } else if(b < 0xF0) {\n\n                ptr += 3;\n\n            } else if(b < 0xF8) {\n\n                ptr += 4;\n\n            } else if(b < 0xFC) {\n\n                ptr += 5;\n\n            } else {\n\n                ptr += 6;\n\n            }\n\n        }\n\n    }\n\n\n\n    /*\n\n     * @dev Returns true if the slice is empty (has a length of 0).\n\n     * @param self The slice to operate on.\n\n     * @return True if the slice is empty, False otherwise.\n\n     */\n\n    function empty(slice memory self) internal pure returns (bool) {\n\n        return self._len == 0;\n\n    }\n\n\n\n    /*\n\n     * @dev Returns a positive number if `other` comes lexicographically after\n\n     *      `self`, a negative number if it comes before, or zero if the\n\n     *      contents of the two slices are equal. Comparison is done per-rune,\n\n     *      on unicode codepoints.\n\n     * @param self The first slice to compare.\n\n     * @param other The second slice to compare.\n\n     * @return The result of the comparison.\n\n     */\n\n    function compare(slice memory self, slice memory other) internal pure returns (int) {\n\n        uint shortest = self._len;\n\n        if (other._len < self._len)\n\n            shortest = other._len;\n\n\n\n        uint selfptr = self._ptr;\n\n        uint otherptr = other._ptr;\n\n        for (uint idx = 0; idx < shortest; idx += 32) {\n\n            uint a;\n\n            uint b;\n\n            assembly {\n\n                a := mload(selfptr)\n\n                b := mload(otherptr)\n\n            }\n\n            if (a != b) {\n\n                // Mask out irrelevant bytes and check again\n\n                uint256 mask = uint256(-1); // 0xffff...\n\n                if(shortest < 32) {\n\n                  mask = ~(2 ** (8 * (32 - shortest + idx)) - 1);\n\n                }\n\n                uint256 diff = (a & mask) - (b & mask);\n\n                if (diff != 0)\n\n                    return int(diff);\n\n            }\n\n            selfptr += 32;\n\n            otherptr += 32;\n\n        }\n\n        return int(self._len) - int(other._len);\n\n    }\n\n\n\n    /*\n\n     * @dev Returns true if the two slices contain the same text.\n\n     * @param self The first slice to compare.\n\n     * @param self The second slice to compare.\n\n     * @return True if the slices are equal, false otherwise.\n\n     */\n\n    function equals(slice memory self, slice memory other) internal pure returns (bool) {\n\n        return compare(self, other) == 0;\n\n    }\n\n\n\n    /*\n\n     * @dev Extracts the first rune in the slice into `rune`, advancing the\n\n     *      slice to point to the next rune and returning `self`.\n\n     * @param self The slice to operate on.\n\n     * @param rune The slice that will contain the first rune.\n\n     * @return `rune`.\n\n     */\n\n    function nextRune(slice memory self, slice memory rune) internal pure returns (slice memory) {\n\n        rune._ptr = self._ptr;\n\n\n\n        if (self._len == 0) {\n\n            rune._len = 0;\n\n            return rune;\n\n        }\n\n\n\n        uint l;\n\n        uint b;\n\n        // Load the first byte of the rune into the LSBs of b\n\n        assembly { b := and(mload(sub(mload(add(self, 32)), 31)), 0xFF) }\n\n        if (b < 0x80) {\n\n            l = 1;\n\n        } else if(b < 0xE0) {\n\n            l = 2;\n\n        } else if(b < 0xF0) {\n\n            l = 3;\n\n        } else {\n\n            l = 4;\n\n        }\n\n\n\n        // Check for truncated codepoints\n\n        if (l > self._len) {\n\n            rune._len = self._len;\n\n            self._ptr += self._len;\n\n            self._len = 0;\n\n            return rune;\n\n        }\n\n\n\n        self._ptr += l;\n\n        self._len -= l;\n\n        rune._len = l;\n\n        return rune;\n\n    }\n\n\n\n    /*\n\n     * @dev Returns the first rune in the slice, advancing the slice to point\n\n     *      to the next rune.\n\n     * @param self The slice to operate on.\n\n     * @return A slice containing only the first rune from `self`.\n\n     */\n\n    function nextRune(slice memory self) internal pure returns (slice memory ret) {\n\n        nextRune(self, ret);\n\n    }\n\n\n\n    /*\n\n     * @dev Returns the number of the first codepoint in the slice.\n\n     * @param self The slice to operate on.\n\n     * @return The number of the first codepoint in the slice.\n\n     */\n\n    function ord(slice memory self) internal pure returns (uint ret) {\n\n        if (self._len == 0) {\n\n            return 0;\n\n        }\n\n\n\n        uint word;\n\n        uint length;\n\n        uint divisor = 2 ** 248;\n\n\n\n        // Load the rune into the MSBs of b\n\n        assembly { word:= mload(mload(add(self, 32))) }\n\n        uint b = word / divisor;\n\n        if (b < 0x80) {\n\n            ret = b;\n\n            length = 1;\n\n        } else if(b < 0xE0) {\n\n            ret = b & 0x1F;\n\n            length = 2;\n\n        } else if(b < 0xF0) {\n\n            ret = b & 0x0F;\n\n            length = 3;\n\n        } else {\n\n            ret = b & 0x07;\n\n            length = 4;\n\n        }\n\n\n\n        // Check for truncated codepoints\n\n        if (length > self._len) {\n\n            return 0;\n\n        }\n\n\n\n        for (uint i = 1; i < length; i++) {\n\n            divisor = divisor / 256;\n\n            b = (word / divisor) & 0xFF;\n\n            if (b & 0xC0 != 0x80) {\n\n                // Invalid UTF-8 sequence\n\n                return 0;\n\n            }\n\n            ret = (ret * 64) | (b & 0x3F);\n\n        }\n\n\n\n        return ret;\n\n    }\n\n\n\n    /*\n\n     * @dev Returns the keccak-256 hash of the slice.\n\n     * @param self The slice to hash.\n\n     * @return The hash of the slice.\n\n     */\n\n    function keccak(slice memory self) internal pure returns (bytes32 ret) {\n\n        assembly {\n\n            ret := keccak256(mload(add(self, 32)), mload(self))\n\n        }\n\n    }\n\n\n\n    /*\n\n     * @dev Returns true if `self` starts with `needle`.\n\n     * @param self The slice to operate on.\n\n     * @param needle The slice to search for.\n\n     * @return True if the slice starts with the provided text, false otherwise.\n\n     */\n\n    function startsWith(slice memory self, slice memory needle) internal pure returns (bool) {\n\n        if (self._len < needle._len) {\n\n            return false;\n\n        }\n\n\n\n        if (self._ptr == needle._ptr) {\n\n            return true;\n\n        }\n\n\n\n        bool equal;\n\n        assembly {\n\n            let length := mload(needle)\n\n            let selfptr := mload(add(self, 0x20))\n\n            let needleptr := mload(add(needle, 0x20))\n\n            equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\n\n        }\n\n        return equal;\n\n    }\n\n\n\n    /*\n\n     * @dev If `self` starts with `needle`, `needle` is removed from the\n\n     *      beginning of `self`. Otherwise, `self` is unmodified.\n\n     * @param self The slice to operate on.\n\n     * @param needle The slice to search for.\n\n     * @return `self`\n\n     */\n\n    function beyond(slice memory self, slice memory needle) internal pure returns (slice memory) {\n\n        if (self._len < needle._len) {\n\n            return self;\n\n        }\n\n\n\n        bool equal = true;\n\n        if (self._ptr != needle._ptr) {\n\n            assembly {\n\n                let length := mload(needle)\n\n                let selfptr := mload(add(self, 0x20))\n\n                let needleptr := mload(add(needle, 0x20))\n\n                equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\n\n            }\n\n        }\n\n\n\n        if (equal) {\n\n            self._len -= needle._len;\n\n            self._ptr += needle._len;\n\n        }\n\n\n\n        return self;\n\n    }\n\n\n\n    /*\n\n     * @dev Returns true if the slice ends with `needle`.\n\n     * @param self The slice to operate on.\n\n     * @param needle The slice to search for.\n\n     * @return True if the slice starts with the provided text, false otherwise.\n\n     */\n\n    function endsWith(slice memory self, slice memory needle) internal pure returns (bool) {\n\n        if (self._len < needle._len) {\n\n            return false;\n\n        }\n\n\n\n        uint selfptr = self._ptr + self._len - needle._len;\n\n\n\n        if (selfptr == needle._ptr) {\n\n            return true;\n\n        }\n\n\n\n        bool equal;\n\n        assembly {\n\n            let length := mload(needle)\n\n            let needleptr := mload(add(needle, 0x20))\n\n            equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\n\n        }\n\n\n\n        return equal;\n\n    }\n\n\n\n    /*\n\n     * @dev If `self` ends with `needle`, `needle` is removed from the\n\n     *      end of `self`. Otherwise, `self` is unmodified.\n\n     * @param self The slice to operate on.\n\n     * @param needle The slice to search for.\n\n     * @return `self`\n\n     */\n\n    function until(slice memory self, slice memory needle) internal pure returns (slice memory) {\n\n        if (self._len < needle._len) {\n\n            return self;\n\n        }\n\n\n\n        uint selfptr = self._ptr + self._len - needle._len;\n\n        bool equal = true;\n\n        if (selfptr != needle._ptr) {\n\n            assembly {\n\n                let length := mload(needle)\n\n                let needleptr := mload(add(needle, 0x20))\n\n                equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\n\n            }\n\n        }\n\n\n\n        if (equal) {\n\n            self._len -= needle._len;\n\n        }\n\n\n\n        return self;\n\n    }\n\n\n\n    // Returns the memory address of the first byte of the first occurrence of\n\n    // `needle` in `self`, or the first byte after `self` if not found.\n\n    function findPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) {\n\n        uint ptr = selfptr;\n\n        uint idx;\n\n\n\n        if (needlelen <= selflen) {\n\n            if (needlelen <= 32) {\n\n                bytes32 mask = bytes32(~(2 ** (8 * (32 - needlelen)) - 1));\n\n\n\n                bytes32 needledata;\n\n                assembly { needledata := and(mload(needleptr), mask) }\n\n\n\n                uint end = selfptr + selflen - needlelen;\n\n                bytes32 ptrdata;\n\n                assembly { ptrdata := and(mload(ptr), mask) }\n\n\n\n                while (ptrdata != needledata) {\n\n                    if (ptr >= end)\n\n                        return selfptr + selflen;\n\n                    ptr++;\n\n                    assembly { ptrdata := and(mload(ptr), mask) }\n\n                }\n\n                return ptr;\n\n            } else {\n\n                // For long needles, use hashing\n\n                bytes32 hash;\n\n                assembly { hash := keccak256(needleptr, needlelen) }\n\n\n\n                for (idx = 0; idx <= selflen - needlelen; idx++) {\n\n                    bytes32 testHash;\n\n                    assembly { testHash := keccak256(ptr, needlelen) }\n\n                    if (hash == testHash)\n\n                        return ptr;\n\n                    ptr += 1;\n\n                }\n\n            }\n\n        }\n\n        return selfptr + selflen;\n\n    }\n\n\n\n    // Returns the memory address of the first byte after the last occurrence of\n\n    // `needle` in `self`, or the address of `self` if not found.\n\n    function rfindPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) {\n\n        uint ptr;\n\n\n\n        if (needlelen <= selflen) {\n\n            if (needlelen <= 32) {\n\n                bytes32 mask = bytes32(~(2 ** (8 * (32 - needlelen)) - 1));\n\n\n\n                bytes32 needledata;\n\n                assembly { needledata := and(mload(needleptr), mask) }\n\n\n\n                ptr = selfptr + selflen - needlelen;\n\n                bytes32 ptrdata;\n\n                assembly { ptrdata := and(mload(ptr), mask) }\n\n\n\n                while (ptrdata != needledata) {\n\n                    if (ptr <= selfptr)\n\n                        return selfptr;\n\n                    ptr--;\n\n                    assembly { ptrdata := and(mload(ptr), mask) }\n\n                }\n\n                return ptr + needlelen;\n\n            } else {\n\n                // For long needles, use hashing\n\n                bytes32 hash;\n\n                assembly { hash := keccak256(needleptr, needlelen) }\n\n                ptr = selfptr + (selflen - needlelen);\n\n                while (ptr >= selfptr) {\n\n                    bytes32 testHash;\n\n                    assembly { testHash := keccak256(ptr, needlelen) }\n\n                    if (hash == testHash)\n\n                        return ptr + needlelen;\n\n                    ptr -= 1;\n\n                }\n\n            }\n\n        }\n\n        return selfptr;\n\n    }\n\n\n\n    /*\n\n     * @dev Modifies `self` to contain everything from the first occurrence of\n\n     *      `needle` to the end of the slice. `self` is set to the empty slice\n\n     *      if `needle` is not found.\n\n     * @param self The slice to search and modify.\n\n     * @param needle The text to search for.\n\n     * @return `self`.\n\n     */\n\n    function find(slice memory self, slice memory needle) internal pure returns (slice memory) {\n\n        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr);\n\n        self._len -= ptr - self._ptr;\n\n        self._ptr = ptr;\n\n        return self;\n\n    }\n\n\n\n    /*\n\n     * @dev Modifies `self` to contain the part of the string from the start of\n\n     *      `self` to the end of the first occurrence of `needle`. If `needle`\n\n     *      is not found, `self` is set to the empty slice.\n\n     * @param self The slice to search and modify.\n\n     * @param needle The text to search for.\n\n     * @return `self`.\n\n     */\n\n    function rfind(slice memory self, slice memory needle) internal pure returns (slice memory) {\n\n        uint ptr = rfindPtr(self._len, self._ptr, needle._len, needle._ptr);\n\n        self._len = ptr - self._ptr;\n\n        return self;\n\n    }\n\n\n\n    /*\n\n     * @dev Splits the slice, setting `self` to everything after the first\n\n     *      occurrence of `needle`, and `token` to everything before it. If\n\n     *      `needle` does not occur in `self`, `self` is set to the empty slice,\n\n     *      and `token` is set to the entirety of `self`.\n\n     * @param self The slice to split.\n\n     * @param needle The text to search for in `self`.\n\n     * @param token An output parameter to which the first token is written.\n\n     * @return `token`.\n\n     */\n\n    function split(slice memory self, slice memory needle, slice memory token) internal pure returns (slice memory) {\n\n        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr);\n\n        token._ptr = self._ptr;\n\n        token._len = ptr - self._ptr;\n\n        if (ptr == self._ptr + self._len) {\n\n            // Not found\n\n            self._len = 0;\n\n        } else {\n\n            self._len -= token._len + needle._len;\n\n            self._ptr = ptr + needle._len;\n\n        }\n\n        return token;\n\n    }\n\n\n\n    /*\n\n     * @dev Splits the slice, setting `self` to everything after the first\n\n     *      occurrence of `needle`, and returning everything before it. If\n\n     *      `needle` does not occur in `self`, `self` is set to the empty slice,\n\n     *      and the entirety of `self` is returned.\n\n     * @param self The slice to split.\n\n     * @param needle The text to search for in `self`.\n\n     * @return The part of `self` up to the first occurrence of `delim`.\n\n     */\n\n    function split(slice memory self, slice memory needle) internal pure returns (slice memory token) {\n\n        split(self, needle, token);\n\n    }\n\n\n\n    /*\n\n     * @dev Splits the slice, setting `self` to everything before the last\n\n     *      occurrence of `needle`, and `token` to everything after it. If\n\n     *      `needle` does not occur in `self`, `self` is set to the empty slice,\n\n     *      and `token` is set to the entirety of `self`.\n\n     * @param self The slice to split.\n\n     * @param needle The text to search for in `self`.\n\n     * @param token An output parameter to which the first token is written.\n\n     * @return `token`.\n\n     */\n\n    function rsplit(slice memory self, slice memory needle, slice memory token) internal pure returns (slice memory) {\n\n        uint ptr = rfindPtr(self._len, self._ptr, needle._len, needle._ptr);\n\n        token._ptr = ptr;\n\n        token._len = self._len - (ptr - self._ptr);\n\n        if (ptr == self._ptr) {\n\n            // Not found\n\n            self._len = 0;\n\n        } else {\n\n            self._len -= token._len + needle._len;\n\n        }\n\n        return token;\n\n    }\n\n\n\n    /*\n\n     * @dev Splits the slice, setting `self` to everything before the last\n\n     *      occurrence of `needle`, and returning everything after it. If\n\n     *      `needle` does not occur in `self`, `self` is set to the empty slice,\n\n     *      and the entirety of `self` is returned.\n\n     * @param self The slice to split.\n\n     * @param needle The text to search for in `self`.\n\n     * @return The part of `self` after the last occurrence of `delim`.\n\n     */\n\n    function rsplit(slice memory self, slice memory needle) internal pure returns (slice memory token) {\n\n        rsplit(self, needle, token);\n\n    }\n\n\n\n    /*\n\n     * @dev Counts the number of nonoverlapping occurrences of `needle` in `self`.\n\n     * @param self The slice to search.\n\n     * @param needle The text to search for in `self`.\n\n     * @return The number of occurrences of `needle` found in `self`.\n\n     */\n\n    function count(slice memory self, slice memory needle) internal pure returns (uint cnt) {\n\n        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr) + needle._len;\n\n        while (ptr <= self._ptr + self._len) {\n\n            cnt++;\n\n            ptr = findPtr(self._len - (ptr - self._ptr), ptr, needle._len, needle._ptr) + needle._len;\n\n        }\n\n    }\n\n\n\n    /*\n\n     * @dev Returns True if `self` contains `needle`.\n\n     * @param self The slice to search.\n\n     * @param needle The text to search for in `self`.\n\n     * @return True if `needle` is found in `self`, false otherwise.\n\n     */\n\n    function contains(slice memory self, slice memory needle) internal pure returns (bool) {\n\n        return rfindPtr(self._len, self._ptr, needle._len, needle._ptr) != self._ptr;\n\n    }\n\n\n\n    /*\n\n     * @dev Returns a newly allocated string containing the concatenation of\n\n     *      `self` and `other`.\n\n     * @param self The first slice to concatenate.\n\n     * @param other The second slice to concatenate.\n\n     * @return The concatenation of the two strings.\n\n     */\n\n    function concat(slice memory self, slice memory other) internal pure returns (string memory) {\n\n        string memory ret = new string(self._len + other._len);\n\n        uint retptr;\n\n        assembly { retptr := add(ret, 32) }\n\n        memcpy(retptr, self._ptr, self._len);\n\n        memcpy(retptr + self._len, other._ptr, other._len);\n\n        return ret;\n\n    }\n\n\n\n    /*\n\n     * @dev Joins an array of slices, using `self` as a delimiter, returning a\n\n     *      newly allocated string.\n\n     * @param self The delimiter to use.\n\n     * @param parts A list of slices to join.\n\n     * @return A newly allocated string containing all the slices in `parts`,\n\n     *         joined with `self`.\n\n     */\n\n    function join(slice memory self, slice[] memory parts) internal pure returns (string memory) {\n\n        if (parts.length == 0)\n\n            return \"\";\n\n\n\n        uint length = self._len * (parts.length - 1);\n\n        for(uint i = 0; i < parts.length; i++)\n\n            length += parts[i]._len;\n\n\n\n        string memory ret = new string(length);\n\n        uint retptr;\n\n        assembly { retptr := add(ret, 32) }\n\n\n\n        for(i = 0; i < parts.length; i++) {\n\n            memcpy(retptr, parts[i]._ptr, parts[i]._len);\n\n            retptr += parts[i]._len;\n\n            if (i < parts.length - 1) {\n\n                memcpy(retptr, self._ptr, self._len);\n\n                retptr += self._len;\n\n            }\n\n        }\n\n\n\n        return ret;\n\n    }\n",
          "message": "Contract 'strings' (tokenWhitelistable.sol#798-1475) is not in CapWords\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 799,
          "vulnerability_to_line": 802,
          "vulnerability_code": "    struct slice {\n\n        uint _len;\n\n        uint _ptr;\n",
          "message": "Struct 'strings.slice' (tokenWhitelistable.sol#799-802) is not in CapWords\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1598,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getTokenInfo(address) external view returns (string, uint256, uint256, bool, bool, bool, uint256);\n",
          "message": "Parameter '' of ITokenWhitelist.getTokenInfo (tokenWhitelistable.sol#1598) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1601,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function updateTokenRate(address, uint, uint) external;\n",
          "message": "Parameter '' of ITokenWhitelist.updateTokenRate (tokenWhitelistable.sol#1601) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1601,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function updateTokenRate(address, uint, uint) external;\n",
          "message": "Parameter '_scope_0' of ITokenWhitelist.updateTokenRate (tokenWhitelistable.sol#1601) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1601,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function updateTokenRate(address, uint, uint) external;\n",
          "message": "Parameter '_scope_1' of ITokenWhitelist.updateTokenRate (tokenWhitelistable.sol#1601) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1644,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor(address _ens_, bytes32 _oracleNameHash_, bytes32 _controllerNameHash_, address _owner_, bool _transferable_, address _stabelcoinAddress_) ENSResolvable(_ens_) Controllable(_controllerNameHash_) Ownable(_owner_, _transferable_) public {\n",
          "message": "Parameter '_oracleNameHash_' of TokenWhitelist. (tokenWhitelistable.sol#1644) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1644,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor(address _ens_, bytes32 _oracleNameHash_, bytes32 _controllerNameHash_, address _owner_, bool _transferable_, address _stabelcoinAddress_) ENSResolvable(_ens_) Controllable(_controllerNameHash_) Ownable(_owner_, _transferable_) public {\n",
          "message": "Parameter '_stabelcoinAddress_' of TokenWhitelist. (tokenWhitelistable.sol#1644) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1656,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function addTokens(address[] _tokens, bytes32[] _symbols, uint[] _magnitude, bool[] _loadable, bool[] _burnable, uint _lastUpdate) external onlyController {\n",
          "message": "Parameter '_tokens' of TokenWhitelist.addTokens (tokenWhitelistable.sol#1656) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1656,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function addTokens(address[] _tokens, bytes32[] _symbols, uint[] _magnitude, bool[] _loadable, bool[] _burnable, uint _lastUpdate) external onlyController {\n",
          "message": "Parameter '_symbols' of TokenWhitelist.addTokens (tokenWhitelistable.sol#1656) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1656,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function addTokens(address[] _tokens, bytes32[] _symbols, uint[] _magnitude, bool[] _loadable, bool[] _burnable, uint _lastUpdate) external onlyController {\n",
          "message": "Parameter '_magnitude' of TokenWhitelist.addTokens (tokenWhitelistable.sol#1656) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1656,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function addTokens(address[] _tokens, bytes32[] _symbols, uint[] _magnitude, bool[] _loadable, bool[] _burnable, uint _lastUpdate) external onlyController {\n",
          "message": "Parameter '_loadable' of TokenWhitelist.addTokens (tokenWhitelistable.sol#1656) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1656,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function addTokens(address[] _tokens, bytes32[] _symbols, uint[] _magnitude, bool[] _loadable, bool[] _burnable, uint _lastUpdate) external onlyController {\n",
          "message": "Parameter '_burnable' of TokenWhitelist.addTokens (tokenWhitelistable.sol#1656) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1656,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function addTokens(address[] _tokens, bytes32[] _symbols, uint[] _magnitude, bool[] _loadable, bool[] _burnable, uint _lastUpdate) external onlyController {\n",
          "message": "Parameter '_lastUpdate' of TokenWhitelist.addTokens (tokenWhitelistable.sol#1656) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1684,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function removeTokens(address[] _tokens) external onlyController {\n",
          "message": "Parameter '_tokens' of TokenWhitelist.removeTokens (tokenWhitelistable.sol#1684) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1710,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function updateTokenRate(address _token, uint _rate, uint _updateDate) external onlyControllerOrOracle {\n",
          "message": "Parameter '_token' of TokenWhitelist.updateTokenRate (tokenWhitelistable.sol#1710) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1710,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function updateTokenRate(address _token, uint _rate, uint _updateDate) external onlyControllerOrOracle {\n",
          "message": "Parameter '_rate' of TokenWhitelist.updateTokenRate (tokenWhitelistable.sol#1710) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1710,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function updateTokenRate(address _token, uint _rate, uint _updateDate) external onlyControllerOrOracle {\n",
          "message": "Parameter '_updateDate' of TokenWhitelist.updateTokenRate (tokenWhitelistable.sol#1710) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1722,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function claim(address _to, address _asset, uint _amount) external onlyOwner {\n",
          "message": "Parameter '_to' of TokenWhitelist.claim (tokenWhitelistable.sol#1722) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1722,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function claim(address _to, address _asset, uint _amount) external onlyOwner {\n",
          "message": "Parameter '_asset' of TokenWhitelist.claim (tokenWhitelistable.sol#1722) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1722,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function claim(address _to, address _asset, uint _amount) external onlyOwner {\n",
          "message": "Parameter '_amount' of TokenWhitelist.claim (tokenWhitelistable.sol#1722) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1735,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getTokenInfo(address _a) external view returns (string, uint256, uint256, bool, bool, bool, uint256) {\n",
          "message": "Parameter '_a' of TokenWhitelist.getTokenInfo (tokenWhitelistable.sol#1735) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1803,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor(bytes32 _tokenWhitelistNameHash_) internal {\n",
          "message": "Parameter '_tokenWhitelistNameHash_' of TokenWhitelistable. (tokenWhitelistable.sol#1803) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1822,
          "vulnerability_to_line": 1824,
          "vulnerability_code": "    function _getTokenInfo(address _a) internal view returns (string, uint256, uint256, bool, bool, bool, uint256) {\n\n        return ITokenWhitelist(_ensResolve(_tokenWhitelistNode)).getTokenInfo(_a);\n",
          "message": "Function 'TokenWhitelistable._getTokenInfo' (tokenWhitelistable.sol#1822-1824) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1822,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _getTokenInfo(address _a) internal view returns (string, uint256, uint256, bool, bool, bool, uint256) {\n",
          "message": "Parameter '_a' of TokenWhitelistable._getTokenInfo (tokenWhitelistable.sol#1822) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1834,
          "vulnerability_to_line": 1836,
          "vulnerability_code": "    function _getStablecoinInfo() internal view returns (string, uint256, uint256, bool, bool, bool, uint256) {\n\n        return ITokenWhitelist(_ensResolve(_tokenWhitelistNode)).getStablecoinInfo();\n",
          "message": "Function 'TokenWhitelistable._getStablecoinInfo' (tokenWhitelistable.sol#1834-1836) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1840,
          "vulnerability_to_line": 1842,
          "vulnerability_code": "    function _tokenAddressArray() internal view returns (address[]) {\n\n        return ITokenWhitelist(_ensResolve(_tokenWhitelistNode)).tokenAddressArray();\n",
          "message": "Function 'TokenWhitelistable._tokenAddressArray' (tokenWhitelistable.sol#1840-1842) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1848,
          "vulnerability_to_line": 1850,
          "vulnerability_code": "    function _updateTokenRate(address _token, uint _rate, uint _updateDate) internal {\n\n        ITokenWhitelist(_ensResolve(_tokenWhitelistNode)).updateTokenRate(_token, _rate, _updateDate);\n",
          "message": "Function 'TokenWhitelistable._updateTokenRate' (tokenWhitelistable.sol#1848-1850) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1848,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _updateTokenRate(address _token, uint _rate, uint _updateDate) internal {\n",
          "message": "Parameter '_token' of TokenWhitelistable._updateTokenRate (tokenWhitelistable.sol#1848) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1848,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _updateTokenRate(address _token, uint _rate, uint _updateDate) internal {\n",
          "message": "Parameter '_rate' of TokenWhitelistable._updateTokenRate (tokenWhitelistable.sol#1848) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1848,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _updateTokenRate(address _token, uint _rate, uint _updateDate) internal {\n",
          "message": "Parameter '_updateDate' of TokenWhitelistable._updateTokenRate (tokenWhitelistable.sol#1848) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1854,
          "vulnerability_to_line": 1857,
          "vulnerability_code": "    function _isTokenAvailable(address _a) internal view returns (bool) {\n\n        ( , , , bool available, , , ) = _getTokenInfo(_a);\n\n        return available;\n",
          "message": "Function 'TokenWhitelistable._isTokenAvailable' (tokenWhitelistable.sol#1854-1857) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1854,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _isTokenAvailable(address _a) internal view returns (bool) {\n",
          "message": "Parameter '_a' of TokenWhitelistable._isTokenAvailable (tokenWhitelistable.sol#1854) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1861,
          "vulnerability_to_line": 1864,
          "vulnerability_code": "    function _isTokenBurnable(address _a) internal view returns (bool) {\n\n        ( , , , , , bool burnable, ) = _getTokenInfo(_a);\n\n        return burnable;\n",
          "message": "Function 'TokenWhitelistable._isTokenBurnable' (tokenWhitelistable.sol#1861-1864) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1861,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _isTokenBurnable(address _a) internal view returns (bool) {\n",
          "message": "Parameter '_a' of TokenWhitelistable._isTokenBurnable (tokenWhitelistable.sol#1861) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1868,
          "vulnerability_to_line": 1871,
          "vulnerability_code": "    function _isTokenLoadable(address _a) internal view returns (bool) {\n\n        ( , , , , bool loadable, , ) = _getTokenInfo(_a);\n\n        return loadable;\n",
          "message": "Function 'TokenWhitelistable._isTokenLoadable' (tokenWhitelistable.sol#1868-1871) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1868,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _isTokenLoadable(address _a) internal view returns (bool) {\n",
          "message": "Parameter '_a' of TokenWhitelistable._isTokenLoadable (tokenWhitelistable.sol#1868) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1875,
          "vulnerability_to_line": 1877,
          "vulnerability_code": "    function _stablecoin() internal view returns (address) {\n\n        return ITokenWhitelist(_ensResolve(_tokenWhitelistNode)).stablecoin();\n",
          "message": "Function 'TokenWhitelistable._stablecoin' (tokenWhitelistable.sol#1875-1877) is not in mixedCase\n"
        }
      ]
    },
    "smartcheck": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 409,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bytes4 constant INTERFACE_META_ID = 0x01ffc9a7;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 410,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bytes4 constant ADDR_INTERFACE_ID = 0x3b3b57de;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 411,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bytes4 constant CONTENT_INTERFACE_ID = 0xd8389dc5;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 412,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bytes4 constant NAME_INTERFACE_ID = 0x691f3431;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 413,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bytes4 constant ABI_INTERFACE_ID = 0x2203ab56;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 414,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bytes4 constant PUBKEY_INTERFACE_ID = 0xc8690233;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 415,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bytes4 constant TEXT_INTERFACE_ID = 0x59d1d43c;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 416,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bytes4 constant MULTIHASH_INTERFACE_ID = 0xe89401a1;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 845,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (self & 0xffffffffffffffffffffffffffffffff == 0) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 847,
          "vulnerability_to_line": null,
          "vulnerability_code": "            self = bytes32(uint(self) / 0x100000000000000000000000000000000);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 849,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (self & 0xffffffffffffffff == 0) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 851,
          "vulnerability_to_line": null,
          "vulnerability_code": "            self = bytes32(uint(self) / 0x10000000000000000);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 853,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (self & 0xffffffff == 0) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 855,
          "vulnerability_to_line": null,
          "vulnerability_code": "            self = bytes32(uint(self) / 0x100000000);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 857,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (self & 0xffff == 0) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 859,
          "vulnerability_to_line": null,
          "vulnerability_code": "            self = bytes32(uint(self) / 0x10000);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 861,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (self & 0xff == 0) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 923,
          "vulnerability_to_line": null,
          "vulnerability_code": "            if (b < 0x80) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 925,
          "vulnerability_to_line": null,
          "vulnerability_code": "            } else if(b < 0xE0) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 927,
          "vulnerability_to_line": null,
          "vulnerability_code": "            } else if(b < 0xF0) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 929,
          "vulnerability_to_line": null,
          "vulnerability_code": "            } else if(b < 0xF8) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 931,
          "vulnerability_to_line": null,
          "vulnerability_code": "            } else if(b < 0xFC) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 1016,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (b < 0x80) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 1018,
          "vulnerability_to_line": null,
          "vulnerability_code": "        } else if(b < 0xE0) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 1020,
          "vulnerability_to_line": null,
          "vulnerability_code": "        } else if(b < 0xF0) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 1067,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (b < 0x80) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 1070,
          "vulnerability_to_line": null,
          "vulnerability_code": "        } else if(b < 0xE0) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 1071,
          "vulnerability_to_line": null,
          "vulnerability_code": "            ret = b & 0x1F;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 1073,
          "vulnerability_to_line": null,
          "vulnerability_code": "        } else if(b < 0xF0) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 1074,
          "vulnerability_to_line": null,
          "vulnerability_code": "            ret = b & 0x0F;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 1077,
          "vulnerability_to_line": null,
          "vulnerability_code": "            ret = b & 0x07;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 1088,
          "vulnerability_to_line": null,
          "vulnerability_code": "            b = (word / divisor) & 0xFF;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 1089,
          "vulnerability_to_line": null,
          "vulnerability_code": "            if (b & 0xC0 != 0x80) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 1089,
          "vulnerability_to_line": null,
          "vulnerability_code": "            if (b & 0xC0 != 0x80) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 1093,
          "vulnerability_to_line": null,
          "vulnerability_code": "            ret = (ret * 64) | (b & 0x3F);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 85,
          "vulnerability_to_line": null,
          "vulnerability_code": "        _owner = address(0);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ARRAY_LENGTH_MANIPULATION",
          "vulnerability_from_line": 1700,
          "vulnerability_to_line": null,
          "vulnerability_code": "            _tokenAddressArray.length--;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 1457,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(uint i = 0; i < parts.length; i++)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 1464,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(i = 0; i < parts.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 1660,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < _tokens.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 1686,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < _tokens.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 1694,
          "vulnerability_to_line": null,
          "vulnerability_code": "            for (uint j = 0; j < _tokenAddressArray.length.sub(1); j++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
          "vulnerability_from_line": 1046,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function nextRune(slice memory self) internal pure returns (slice memory ret) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
          "vulnerability_from_line": 1104,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function keccak(slice memory self) internal pure returns (bytes32 ret) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
          "vulnerability_from_line": 1364,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function split(slice memory self, slice memory needle) internal pure returns (slice memory token) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
          "vulnerability_from_line": 1400,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function rsplit(slice memory self, slice memory needle) internal pure returns (slice memory token) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
          "vulnerability_from_line": 1410,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function count(slice memory self, slice memory needle) internal pure returns (uint cnt) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 1457,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(uint i = 0; i < parts.length; i++)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 1464,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(i = 0; i < parts.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 1660,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < _tokens.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 1686,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < _tokens.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 1238,
          "vulnerability_to_line": null,
          "vulnerability_code": "                while (ptrdata != needledata) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 1278,
          "vulnerability_to_line": null,
          "vulnerability_code": "                while (ptrdata != needledata) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 1290,
          "vulnerability_to_line": null,
          "vulnerability_code": "                while (ptr >= selfptr) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 1412,
          "vulnerability_to_line": null,
          "vulnerability_code": "        while (ptr <= self._ptr + self._len) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 21,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.25;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 105,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.25;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 135,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.25;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 179,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.25;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 344,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity >=0.4.24;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 401,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.24;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 658,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.25;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 710,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.25;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 796,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.14;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 1504,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.24;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 1590,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.25;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 1792,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.25;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 32,
          "vulnerability_to_line": null,
          "vulnerability_code": "    address private _owner;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 33,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bool private _isTransferable;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 201,
          "vulnerability_to_line": null,
          "vulnerability_code": "    mapping (address => bool) private _isAdmin;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 202,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint private _adminCount;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 204,
          "vulnerability_to_line": null,
          "vulnerability_code": "    mapping (address => bool) private _isController;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 205,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint private _controllerCount;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 665,
          "vulnerability_to_line": null,
          "vulnerability_code": "    ENS private _ens;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 668,
          "vulnerability_to_line": null,
          "vulnerability_code": "    address private _ensRegistry;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 716,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bytes32 private _controllerNode;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 1626,
          "vulnerability_to_line": null,
          "vulnerability_code": "    mapping(address => Token) private _tokenInfoMap;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 1627,
          "vulnerability_to_line": null,
          "vulnerability_code": "    address[] private _tokenAddressArray;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 1636,
          "vulnerability_to_line": null,
          "vulnerability_code": "    address private _stablecoin;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 1639,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bytes32 private _oracleNode;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 1799,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bytes32 private _tokenWhitelistNode;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SAFEMATH",
          "vulnerability_from_line": 1609,
          "vulnerability_to_line": null,
          "vulnerability_code": "    using SafeMath for uint256;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 804,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function memcpy(uint dest, uint src, uint len) private pure {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 828,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function toSlice(string memory self) internal pure returns (slice memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 874,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function toSliceB32(bytes32 self) internal pure returns (slice memory ret) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 899,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function toString(slice memory self) internal pure returns (string memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 916,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function len(slice memory self) internal pure returns (uint l) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 957,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function compare(slice memory self, slice memory other) internal pure returns (int) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 1004,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function nextRune(slice memory self, slice memory rune) internal pure returns (slice memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 1055,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function ord(slice memory self) internal pure returns (uint ret) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 1104,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function keccak(slice memory self) internal pure returns (bytes32 ret) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 1116,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function startsWith(slice memory self, slice memory needle) internal pure returns (bool) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 1142,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function beyond(slice memory self, slice memory needle) internal pure returns (slice memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 1171,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function endsWith(slice memory self, slice memory needle) internal pure returns (bool) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 1199,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function until(slice memory self, slice memory needle) internal pure returns (slice memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 1223,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function findPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 1264,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function rfindPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 1435,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function concat(slice memory self, slice memory other) internal pure returns (string memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 1452,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function join(slice memory self, slice[] memory parts) internal pure returns (string memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 1822,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _getTokenInfo(address _a) internal view returns (string, uint256, uint256, bool, bool, bool, uint256) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 1834,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _getStablecoinInfo() internal view returns (string, uint256, uint256, bool, bool, bool, uint256) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 488,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setMultihash(bytes32 node, bytes hash) public only_owner(node) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 499,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setName(bytes32 node, string name) public only_owner(node) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 512,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setABI(bytes32 node, uint256 contentType, bytes data) public only_owner(node) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 538,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setText(bytes32 node, string key, string value) public only_owner(node) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 538,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setText(bytes32 node, string key, string value) public only_owner(node) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 549,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function text(bytes32 node, string key) public view returns (string) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 549,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function text(bytes32 node, string key) public view returns (string) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 571,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function ABI(bytes32 node, uint256 contentTypes) public view returns (uint256 contentType, bytes data) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 588,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function name(bytes32 node) public view returns (string) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 608,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function multihash(bytes32 node) public view returns (bytes) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 1822,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _getTokenInfo(address _a) internal view returns (string, uint256, uint256, bool, bool, bool, uint256) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 1834,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _getStablecoinInfo() internal view returns (string, uint256, uint256, bool, bool, bool, uint256) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 1840,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _tokenAddressArray() internal view returns (address[]) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 807,
          "vulnerability_to_line": null,
          "vulnerability_code": "            assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 816,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 830,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 876,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 902,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly { retptr := add(ret, 32) }\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 922,
          "vulnerability_to_line": null,
          "vulnerability_code": "            assembly { b := and(mload(ptr), 0xFF) }\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 967,
          "vulnerability_to_line": null,
          "vulnerability_code": "            assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 1015,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly { b := and(mload(sub(mload(add(self, 32)), 31)), 0xFF) }\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 1065,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly { word:= mload(mload(add(self, 32))) }\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 1105,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 1126,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 1149,
          "vulnerability_to_line": null,
          "vulnerability_code": "            assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 1183,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 1207,
          "vulnerability_to_line": null,
          "vulnerability_code": "            assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 1232,
          "vulnerability_to_line": null,
          "vulnerability_code": "                assembly { needledata := and(mload(needleptr), mask) }\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 1236,
          "vulnerability_to_line": null,
          "vulnerability_code": "                assembly { ptrdata := and(mload(ptr), mask) }\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 1242,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    assembly { ptrdata := and(mload(ptr), mask) }\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 1248,
          "vulnerability_to_line": null,
          "vulnerability_code": "                assembly { hash := keccak256(needleptr, needlelen) }\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 1252,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    assembly { testHash := keccak256(ptr, needlelen) }\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 1272,
          "vulnerability_to_line": null,
          "vulnerability_code": "                assembly { needledata := and(mload(needleptr), mask) }\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 1276,
          "vulnerability_to_line": null,
          "vulnerability_code": "                assembly { ptrdata := and(mload(ptr), mask) }\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 1282,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    assembly { ptrdata := and(mload(ptr), mask) }\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 1288,
          "vulnerability_to_line": null,
          "vulnerability_code": "                assembly { hash := keccak256(needleptr, needlelen) }\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 1292,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    assembly { testHash := keccak256(ptr, needlelen) }\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 1438,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly { retptr := add(ret, 32) }\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 1462,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly { retptr := add(ret, 32) }\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 409,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bytes4 constant INTERFACE_META_ID = 0x01ffc9a7;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 410,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bytes4 constant ADDR_INTERFACE_ID = 0x3b3b57de;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 411,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bytes4 constant CONTENT_INTERFACE_ID = 0xd8389dc5;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 412,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bytes4 constant NAME_INTERFACE_ID = 0x691f3431;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 413,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bytes4 constant ABI_INTERFACE_ID = 0x2203ab56;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 414,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bytes4 constant PUBKEY_INTERFACE_ID = 0xc8690233;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 415,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bytes4 constant TEXT_INTERFACE_ID = 0x59d1d43c;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 416,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bytes4 constant MULTIHASH_INTERFACE_ID = 0xe89401a1;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 441,
          "vulnerability_to_line": null,
          "vulnerability_code": "    ENS ens;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 443,
          "vulnerability_to_line": null,
          "vulnerability_code": "    mapping (bytes32 => Record) records;\n",
          "message": null
        }
      ]
    },
    "oyente": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "Integer Overflow",
          "vulnerability_from_line": 278,
          "vulnerability_to_line": null,
          "vulnerability_code": "        _adminCount++;\n",
          "message": null
        },
        {
          "name": "Integer Underflow",
          "vulnerability_from_line": 286,
          "vulnerability_to_line": null,
          "vulnerability_code": "        _adminCount--;\n",
          "message": null
        },
        {
          "name": "Integer Overflow",
          "vulnerability_from_line": 538,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setText(bytes32 node, string key, string value) public only_owner(node) {\n",
          "message": null
        },
        {
          "name": "Integer Underflow",
          "vulnerability_from_line": 571,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function ABI(bytes32 node, uint256 contentTypes) public view returns (uint256 contentType, bytes data) {\n",
          "message": null
        },
        {
          "name": "Integer Overflow",
          "vulnerability_from_line": 1737,
          "vulnerability_to_line": null,
          "vulnerability_code": "        return (tokenInfo.symbol, tokenInfo.magnitude, tokenInfo.rate, tokenInfo.available, tokenInfo.loadable, tokenInfo.burnable, tokenInfo.lastUpdate);\n",
          "message": null
        },
        {
          "name": "Integer Underflow",
          "vulnerability_from_line": 1737,
          "vulnerability_to_line": null,
          "vulnerability_code": "        return (tokenInfo.symbol, tokenInfo.magnitude, tokenInfo.rate, tokenInfo.available, tokenInfo.loadable, tokenInfo.burnable, tokenInfo.lastUpdate);\n",
          "message": null
        }
      ]
    },
    "mythril": {
      "successfull_analysis": false,
      "errors": [
        "DOCKER_TIMEOUT"
      ],
      "vulnerability_findings": []
    },
    "osiris": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "Overflow bugs",
          "vulnerability_from_line": 278,
          "vulnerability_to_line": null,
          "vulnerability_code": "        _adminCount++;\n",
          "message": null
        },
        {
          "name": "Overflow bugs",
          "vulnerability_from_line": 297,
          "vulnerability_to_line": null,
          "vulnerability_code": "        _controllerCount++;\n",
          "message": null
        },
        {
          "name": "Underflow bugs",
          "vulnerability_from_line": 286,
          "vulnerability_to_line": null,
          "vulnerability_code": "        _adminCount--;\n",
          "message": null
        },
        {
          "name": "Underflow bugs",
          "vulnerability_from_line": 305,
          "vulnerability_to_line": null,
          "vulnerability_code": "        _controllerCount--;\n",
          "message": null
        },
        {
          "name": "Truncation bugs",
          "vulnerability_from_line": 589,
          "vulnerability_to_line": null,
          "vulnerability_code": "        return records[node].name;\n",
          "message": null
        },
        {
          "name": "Truncation bugs",
          "vulnerability_from_line": 609,
          "vulnerability_to_line": null,
          "vulnerability_code": "        return records[node].multihash;\n",
          "message": null
        },
        {
          "name": "Underflow bugs",
          "vulnerability_from_line": 514,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(((contentType - 1) & contentType) == 0);\n",
          "message": null
        },
        {
          "name": "Overflow bugs",
          "vulnerability_from_line": 1755,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function tokenAddressArray() external view returns (address[]) {\n",
          "message": null
        },
        {
          "name": "Overflow bugs",
          "vulnerability_from_line": 1756,
          "vulnerability_to_line": null,
          "vulnerability_code": "        return _tokenAddressArray;\n",
          "message": null
        },
        {
          "name": "Truncation bugs",
          "vulnerability_from_line": 845,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (self & 0xffffffffffffffffffffffffffffffff == 0) {\n",
          "message": null
        }
      ]
    }
  }
}