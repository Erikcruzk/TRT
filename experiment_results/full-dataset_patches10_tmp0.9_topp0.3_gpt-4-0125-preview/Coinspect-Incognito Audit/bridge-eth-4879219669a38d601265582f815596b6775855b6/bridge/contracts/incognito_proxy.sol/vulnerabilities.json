{
  "smartbugs_completed": true,
  "analyzer_results": {
    "semgrep": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 310,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < sigIdx.length; i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 311,
          "vulnerability_to_line": null,
          "vulnerability_code": "            if ((i > 0 && sigIdx[i] <= sigIdx[i-1]) || sigIdx[i] >= signers.length) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 398,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < path.length; i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 470,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < v.length; i++){\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 11,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor(address _admin) public {\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 12,
          "vulnerability_to_line": null,
          "vulnerability_code": "        admin = _admin;\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 13,
          "vulnerability_to_line": null,
          "vulnerability_code": "        paused = false;\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 14,
          "vulnerability_to_line": null,
          "vulnerability_code": "        expire = block.timestamp + 365 * 1 days;\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 15,
          "vulnerability_to_line": null,
          "vulnerability_code": "    }\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 106,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor(\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 107,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address admin,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 108,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address[] memory beaconCommittee,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 109,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address[] memory bridgeCommittee\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 110,
          "vulnerability_to_line": null,
          "vulnerability_code": "    ) public AdminPausable(admin) {\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 111,
          "vulnerability_to_line": null,
          "vulnerability_code": "        beaconCommittees.push(Committee({\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 112,
          "vulnerability_to_line": null,
          "vulnerability_code": "            pubkeys: beaconCommittee,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 113,
          "vulnerability_to_line": null,
          "vulnerability_code": "            startBlock: 0\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 114,
          "vulnerability_to_line": null,
          "vulnerability_code": "        }));\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 115,
          "vulnerability_to_line": null,
          "vulnerability_code": "\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 353,
          "vulnerability_to_line": null,
          "vulnerability_code": "            if (beaconCommittees[m].startBlock <= blkHeight) {\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 373,
          "vulnerability_to_line": null,
          "vulnerability_code": "            if (bridgeCommittees[m].startBlock <= blkHeight) {\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 310,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < sigIdx.length; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 398,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < path.length; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 442,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < numVals; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 470,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < v.length; i++){\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 23,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == admin, \"not admin\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 28,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(paused, \"not paused right now\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 33,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(!paused, \"paused right now\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 38,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(block.timestamp < expire, \"expired\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 47,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == successor, \"unauthorized\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 53,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(n < 366, \"cannot extend for too long\"); // To prevent overflow\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 203,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(startHeight > bridgeCommittees[bridgeCommittees.length-1].startBlock, \"cannot change old committee\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 255,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(startHeight > beaconCommittees[beaconCommittees.length-1].startBlock, \"cannot change old committee\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 200,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(meta == 71 && shard == 1);\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 252,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(meta == 70 && shard == 1);\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 311,
          "vulnerability_to_line": null,
          "vulnerability_code": "            if ((i > 0 && sigIdx[i] <= sigIdx[i-1]) || sigIdx[i] >= signers.length) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 312,
          "vulnerability_to_line": null,
          "vulnerability_code": "                return false;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 313,
          "vulnerability_to_line": null,
          "vulnerability_code": "            }\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 310,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < sigIdx.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 398,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < path.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 442,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < numVals; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 470,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < v.length; i++){\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        }
      ]
    },
    "slither": {
      "successfull_analysis": true,
      "errors": [
        "EXIT_CODE_18"
      ],
      "vulnerability_findings": [
        {
          "name": "constant-function",
          "vulnerability_from_line": 418,
          "vulnerability_to_line": 430,
          "vulnerability_code": "    function extractMetaFromInstruction(bytes memory inst) public pure returns(uint8, uint8, uint, uint) {\n\n        require(inst.length >= 0x42); // 0x02 bytes for meta and shard, 0x20 each for height and numVals\n\n        uint8 meta = uint8(inst[0]);\n\n        uint8 shard = uint8(inst[1]);\n\n        uint height;\n\n        uint numVals;\n\n        assembly {\n\n            // skip first 0x20 bytes (stored length of inst)\n\n            height := mload(add(inst, 0x22)) // [2:34]\n\n            numVals := mload(add(inst, 0x42)) // [34:66]\n\n        }\n\n        return (meta, shard, height, numVals);\n",
          "message": "IncognitoProxy.extractMetaFromInstruction (incognito_proxy.sol#418-430) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 438,
          "vulnerability_to_line": 451,
          "vulnerability_code": "    function extractCommitteeFromInstruction(bytes memory inst, uint numVals) public pure returns (address[] memory) {\n\n        require(inst.length == 0x42 + numVals * 0x20);\n\n        address[] memory addr = new address[](numVals);\n\n        address tmp;\n\n        for (uint i = 0; i < numVals; i++) {\n\n            assembly {\n\n                // skip first 0x20 bytes (stored length of inst)\n\n                // also, skip the next 0x42 bytes (stored metadata)\n\n                tmp := mload(add(add(inst, 0x62), mul(i, 0x20))) // 67+i*32\n\n            }\n\n            addr[i] = tmp;\n\n        }\n\n        return addr;\n",
          "message": "IncognitoProxy.extractCommitteeFromInstruction (incognito_proxy.sol#438-451) is declared view but contains assembly code\n"
        },
        {
          "name": "shadowing-local",
          "vulnerability_from_line": 107,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address admin,\n",
          "message": "IncognitoProxy.constructor.admin (local variable @ incognito_proxy.sol#107) shadows:\n\t- AdminPausable.admin (state variable @ incognito_proxy.sol#6)\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 418,
          "vulnerability_to_line": 430,
          "vulnerability_code": "    function extractMetaFromInstruction(bytes memory inst) public pure returns(uint8, uint8, uint, uint) {\n\n        require(inst.length >= 0x42); // 0x02 bytes for meta and shard, 0x20 each for height and numVals\n\n        uint8 meta = uint8(inst[0]);\n\n        uint8 shard = uint8(inst[1]);\n\n        uint height;\n\n        uint numVals;\n\n        assembly {\n\n            // skip first 0x20 bytes (stored length of inst)\n\n            height := mload(add(inst, 0x22)) // [2:34]\n\n            numVals := mload(add(inst, 0x42)) // [34:66]\n\n        }\n\n        return (meta, shard, height, numVals);\n",
          "message": "IncognitoProxy.extractMetaFromInstruction uses assembly (incognito_proxy.sol#418-430)\n\t- incognito_proxy.sol#424-428\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 438,
          "vulnerability_to_line": 451,
          "vulnerability_code": "    function extractCommitteeFromInstruction(bytes memory inst, uint numVals) public pure returns (address[] memory) {\n\n        require(inst.length == 0x42 + numVals * 0x20);\n\n        address[] memory addr = new address[](numVals);\n\n        address tmp;\n\n        for (uint i = 0; i < numVals; i++) {\n\n            assembly {\n\n                // skip first 0x20 bytes (stored length of inst)\n\n                // also, skip the next 0x42 bytes (stored metadata)\n\n                tmp := mload(add(add(inst, 0x62), mul(i, 0x20))) // 67+i*32\n\n            }\n\n            addr[i] = tmp;\n\n        }\n\n        return addr;\n",
          "message": "IncognitoProxy.extractCommitteeFromInstruction uses assembly (incognito_proxy.sol#438-451)\n\t- incognito_proxy.sol#443-447\n"
        },
        {
          "name": "pragma",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.12;\n",
          "message": "Different versions of Solidity is used in incognito_proxy.sol:\n\t- Version used: ['ABIEncoderV2', '^0.5.12']\n\t- incognito_proxy.sol#3 declares pragma solidity^0.5.12\n\t- incognito_proxy.sol#72 declares pragma solidity^0.5.12\n\t- incognito_proxy.sol#73 declares pragma experimentalABIEncoderV2\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 42,
          "vulnerability_to_line": 44,
          "vulnerability_code": "    function retire(address _successor) public onlyAdmin isNotExpired {\n\n        successor = _successor;\n",
          "message": "AdminPausable.retire (incognito_proxy.sol#42-44) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 46,
          "vulnerability_to_line": 50,
          "vulnerability_code": "    function claim() public isNotExpired {\n\n        require(msg.sender == successor, \"unauthorized\");\n\n        admin = successor;\n\n        emit Claim(admin);\n",
          "message": "AdminPausable.claim (incognito_proxy.sol#46-50) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 52,
          "vulnerability_to_line": 56,
          "vulnerability_code": "    function extend(uint n) public onlyAdmin isNotExpired {\n\n        require(n < 366, \"cannot extend for too long\"); // To prevent overflow\n\n        expire = expire + n * 1 days;\n\n        emit Extend(n);\n",
          "message": "AdminPausable.extend (incognito_proxy.sol#52-56) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 58,
          "vulnerability_to_line": 61,
          "vulnerability_code": "    function pause() public onlyAdmin isNotPaused isNotExpired {\n\n        paused = true;\n\n        emit Paused(msg.sender);\n",
          "message": "AdminPausable.pause (incognito_proxy.sol#58-61) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 63,
          "vulnerability_to_line": 66,
          "vulnerability_code": "    function unpause() public onlyAdmin isPaused {\n\n        paused = false;\n\n        emit Unpaused(msg.sender);\n",
          "message": "AdminPausable.unpause (incognito_proxy.sol#63-66) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 128,
          "vulnerability_to_line": 130,
          "vulnerability_code": "    function getBeaconCommittee(uint i) public view returns(Committee memory) {\n\n        return beaconCommittees[i];\n",
          "message": "IncognitoProxy.getBeaconCommittee (incognito_proxy.sol#128-130) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 136,
          "vulnerability_to_line": 138,
          "vulnerability_code": "    function getBridgeCommittee(uint i) public view returns(Committee memory) {\n\n        return bridgeCommittees[i];\n",
          "message": "IncognitoProxy.getBridgeCommittee (incognito_proxy.sol#136-138) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 155,
          "vulnerability_to_line": 213,
          "vulnerability_code": "    function swapBridgeCommittee(\n\n        bytes memory inst,\n\n        bytes32[][2] memory instPaths,\n\n        bool[][2] memory instPathIsLefts,\n\n        bytes32[2] memory instRoots,\n\n        bytes32[2] memory blkData,\n\n        uint[][2] memory sigIdxs,\n\n        uint8[][2] memory sigVs,\n\n        bytes32[][2] memory sigRs,\n\n        bytes32[][2] memory sigSs\n\n    ) public isNotPaused {\n\n        bytes32 instHash = keccak256(inst);\n\n\n\n        // Verify instruction on beacon\n\n        require(instructionApproved(\n\n            true,\n\n            instHash,\n\n            beaconCommittees[beaconCommittees.length-1].startBlock,\n\n            instPaths[0],\n\n            instPathIsLefts[0],\n\n            instRoots[0],\n\n            blkData[0],\n\n            sigIdxs[0],\n\n            sigVs[0],\n\n            sigRs[0],\n\n            sigSs[0]\n\n        ));\n\n\n\n        // Verify instruction on bridge\n\n        require(instructionApproved(\n\n            false,\n\n            instHash,\n\n            bridgeCommittees[bridgeCommittees.length-1].startBlock,\n\n            instPaths[1],\n\n            instPathIsLefts[1],\n\n            instRoots[1],\n\n            blkData[1],\n\n            sigIdxs[1],\n\n            sigVs[1],\n\n            sigRs[1],\n\n            sigSs[1]\n\n        ));\n\n\n\n        // Parse instruction and check metadata\n\n        (uint8 meta, uint8 shard, uint startHeight, uint numVals) = extractMetaFromInstruction(inst);\n\n        require(meta == 71 && shard == 1);\n\n\n\n        // Make sure 1 instruction can't be used twice (using startHeight)\n\n        require(startHeight > bridgeCommittees[bridgeCommittees.length-1].startBlock, \"cannot change old committee\");\n\n\n\n        // Swap committee\n\n        address[] memory pubkeys = extractCommitteeFromInstruction(inst, numVals);\n\n        bridgeCommittees.push(Committee({\n\n            pubkeys: pubkeys,\n\n            startBlock: startHeight\n\n        }));\n\n\n\n        emit BridgeCommitteeSwapped(bridgeCommittees.length, startHeight);\n",
          "message": "IncognitoProxy.swapBridgeCommittee (incognito_proxy.sol#155-213) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 222,
          "vulnerability_to_line": 265,
          "vulnerability_code": "    function swapBeaconCommittee(\n\n        bytes memory inst,\n\n        bytes32[] memory instPath,\n\n        bool[] memory instPathIsLeft,\n\n        bytes32 instRoot,\n\n        bytes32 blkData,\n\n        uint[] memory sigIdx,\n\n        uint8[] memory sigV,\n\n        bytes32[] memory sigR,\n\n        bytes32[] memory sigS\n\n    ) public isNotPaused {\n\n        bytes32 instHash = keccak256(inst);\n\n\n\n        // Verify instruction on beacon\n\n        require(instructionApproved(\n\n            true,\n\n            instHash,\n\n            beaconCommittees[beaconCommittees.length-1].startBlock,\n\n            instPath,\n\n            instPathIsLeft,\n\n            instRoot,\n\n            blkData,\n\n            sigIdx,\n\n            sigV,\n\n            sigR,\n\n            sigS\n\n        ));\n\n\n\n        // Parse instruction and check metadata and shardID\n\n        (uint8 meta, uint8 shard, uint startHeight, uint numVals) = extractMetaFromInstruction(inst);\n\n        require(meta == 70 && shard == 1);\n\n\n\n        // Make sure 1 instruction can't be used twice (using startHeight)\n\n        require(startHeight > beaconCommittees[beaconCommittees.length-1].startBlock, \"cannot change old committee\");\n\n\n\n        // Swap committee\n\n        address[] memory pubkeys = extractCommitteeFromInstruction(inst, numVals);\n\n        beaconCommittees.push(Committee({\n\n            pubkeys: pubkeys,\n\n            startBlock: startHeight\n\n        }));\n\n\n\n        emit BeaconCommitteeSwapped(beaconCommittees.length, startHeight);\n",
          "message": "IncognitoProxy.swapBeaconCommittee (incognito_proxy.sol#222-265) should be declared external\n"
        },
        {
          "name": "solc-version",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.12;\n",
          "message": "Detected issues with version pragma in incognito_proxy.sol:\n\t- pragma solidity^0.5.12 (incognito_proxy.sol#3): it allows old versions\n\t- pragma solidity^0.5.12 (incognito_proxy.sol#72): it allows old versions\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 11,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor(address _admin) public {\n",
          "message": "Parameter '_admin' of AdminPausable. (incognito_proxy.sol#11) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 42,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function retire(address _successor) public onlyAdmin isNotExpired {\n",
          "message": "Parameter '_successor' of AdminPausable.retire (incognito_proxy.sol#42) is not in mixedCase\n"
        }
      ]
    },
    "smartcheck": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 419,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(inst.length >= 0x42); // 0x02 bytes for meta and shard, 0x20 each for height and numVals\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 439,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(inst.length == 0x42 + numVals * 0x20);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 439,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(inst.length == 0x42 + numVals * 0x20);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 310,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < sigIdx.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 398,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < path.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 470,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < v.length; i++){\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 310,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < sigIdx.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 398,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < path.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 470,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < v.length; i++){\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 351,
          "vulnerability_to_line": null,
          "vulnerability_code": "        while (l != r) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 371,
          "vulnerability_to_line": null,
          "vulnerability_code": "        while (l != r) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.12;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 72,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.12;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 418,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function extractMetaFromInstruction(bytes memory inst) public pure returns(uint8, uint8, uint, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 438,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function extractCommitteeFromInstruction(bytes memory inst, uint numVals) public pure returns (address[] memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 346,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function findBeaconCommitteeFromHeight(uint blkHeight) public view returns (address[] memory, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 366,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function findBridgeCommitteeFromHeight(uint blkHeight) public view returns (address[] memory, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 418,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function extractMetaFromInstruction(bytes memory inst) public pure returns(uint8, uint8, uint, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 424,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 443,
          "vulnerability_to_line": null,
          "vulnerability_code": "            assembly {\n",
          "message": null
        }
      ]
    },
    "oyente": {
      "successfull_analysis": false,
      "errors": [
        "exception (RuntimeError: Source map error, unknown name(SHR) or instr_name(INVALID))"
      ],
      "vulnerability_findings": []
    },
    "mythril": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "Integer Arithmetic Bugs (SWC 101)",
          "vulnerability_from_line": 14,
          "vulnerability_to_line": null,
          "vulnerability_code": "        expire = block.timestamp + 365 * 1 days;\n",
          "message": "The arithmetic operator can overflow.\nIt is possible to cause an integer overflow or underflow in the arithmetic operation. \nClassification: SWC-101"
        },
        {
          "name": "Dependence on predictable environment variable (SWC 116)",
          "vulnerability_from_line": 38,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(block.timestamp < expire, \"expired\");\n",
          "message": "A control flow decision is made based on The block.timestamp environment variable.\nThe block.timestamp environment variable is used to determine a control flow decision. Note that the values of variables like coinbase, gaslimit, block number and timestamp are predictable and can be manipulated by a malicious miner. Also keep in mind that attackers know hashes of earlier blocks. Don't use any of those environment variables as sources of randomness and be aware that use of these variables introduces a certain level of trust into miners.\nClassification: SWC-116"
        },
        {
          "name": "Dependence on predictable environment variable (SWC 116)",
          "vulnerability_from_line": 38,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(block.timestamp < expire, \"expired\");\n",
          "message": "A control flow decision is made based on The block.timestamp environment variable.\nThe block.timestamp environment variable is used to determine a control flow decision. Note that the values of variables like coinbase, gaslimit, block number and timestamp are predictable and can be manipulated by a malicious miner. Also keep in mind that attackers know hashes of earlier blocks. Don't use any of those environment variables as sources of randomness and be aware that use of these variables introduces a certain level of trust into miners.\nClassification: SWC-116"
        },
        {
          "name": "Dependence on predictable environment variable (SWC 116)",
          "vulnerability_from_line": 38,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(block.timestamp < expire, \"expired\");\n",
          "message": "A control flow decision is made based on The block.timestamp environment variable.\nThe block.timestamp environment variable is used to determine a control flow decision. Note that the values of variables like coinbase, gaslimit, block number and timestamp are predictable and can be manipulated by a malicious miner. Also keep in mind that attackers know hashes of earlier blocks. Don't use any of those environment variables as sources of randomness and be aware that use of these variables introduces a certain level of trust into miners.\nClassification: SWC-116"
        },
        {
          "name": "Integer Arithmetic Bugs (SWC 101)",
          "vulnerability_from_line": 54,
          "vulnerability_to_line": null,
          "vulnerability_code": "        expire = expire + n * 1 days;\n",
          "message": "The arithmetic operator can overflow.\nIt is possible to cause an integer overflow or underflow in the arithmetic operation. \nClassification: SWC-101"
        },
        {
          "name": "Dependence on predictable environment variable (SWC 116)",
          "vulnerability_from_line": 38,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(block.timestamp < expire, \"expired\");\n",
          "message": "A control flow decision is made based on The block.timestamp environment variable.\nThe block.timestamp environment variable is used to determine a control flow decision. Note that the values of variables like coinbase, gaslimit, block number and timestamp are predictable and can be manipulated by a malicious miner. Also keep in mind that attackers know hashes of earlier blocks. Don't use any of those environment variables as sources of randomness and be aware that use of these variables introduces a certain level of trust into miners.\nClassification: SWC-116"
        }
      ]
    },
    "osiris": {
      "successfull_analysis": false,
      "errors": [
        "Solidity compilation failed"
      ],
      "vulnerability_findings": []
    }
  }
}