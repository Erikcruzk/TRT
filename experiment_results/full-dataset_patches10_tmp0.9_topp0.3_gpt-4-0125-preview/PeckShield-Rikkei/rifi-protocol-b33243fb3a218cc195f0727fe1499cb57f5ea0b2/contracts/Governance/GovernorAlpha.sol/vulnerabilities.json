{
  "smartbugs_completed": true,
  "analyzer_results": {
    "semgrep": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 182,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < proposal.targets.length; i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 198,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < proposal.targets.length; i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 212,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < proposal.targets.length; i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 132,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor(address timelock_, address rifi_, address guardian_) public {\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 133,
          "vulnerability_to_line": null,
          "vulnerability_code": "        timelock = TimelockInterface(timelock_);\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 134,
          "vulnerability_to_line": null,
          "vulnerability_code": "        rifi = RifiInterface(rifi_);\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 135,
          "vulnerability_to_line": null,
          "vulnerability_code": "        guardian = guardian_;\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 136,
          "vulnerability_to_line": null,
          "vulnerability_code": "    }\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 199,
          "vulnerability_to_line": null,
          "vulnerability_code": "            timelock.executeTransaction.value(proposal.values[i])(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], proposal.eta);\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 213,
          "vulnerability_to_line": null,
          "vulnerability_code": "            timelock.cancelTransaction(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], proposal.eta);\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 182,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < proposal.targets.length; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 198,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < proposal.targets.length; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 212,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < proposal.targets.length; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 139,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(rifi.getPriorVotes(msg.sender, sub256(block.number, 1)) > proposalThreshold(), \"GovernorAlpha::propose: proposer votes below proposal threshold\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 140,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(targets.length == values.length && targets.length == signatures.length && targets.length == calldatas.length, \"GovernorAlpha::propose: proposal function information arity mismatch\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 141,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(targets.length != 0, \"GovernorAlpha::propose: must provide actions\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 142,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(targets.length <= proposalMaxOperations(), \"GovernorAlpha::propose: too many actions\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 147,
          "vulnerability_to_line": null,
          "vulnerability_code": "          require(proposersLatestProposalState != ProposalState.Active, \"GovernorAlpha::propose: one live proposal per proposer, found an already active proposal\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 148,
          "vulnerability_to_line": null,
          "vulnerability_code": "          require(proposersLatestProposalState != ProposalState.Pending, \"GovernorAlpha::propose: one live proposal per proposer, found an already pending proposal\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 179,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(state(proposalId) == ProposalState.Succeeded, \"GovernorAlpha::queue: proposal can only be queued if it is succeeded\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 190,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(!timelock.queuedTransactions(keccak256(abi.encode(target, value, signature, data, eta))), \"GovernorAlpha::_queueOrRevert: proposal action already queued at eta\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 195,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(state(proposalId) == ProposalState.Queued, \"GovernorAlpha::execute: proposal can only be executed if it is queued\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 206,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(state != ProposalState.Executed, \"GovernorAlpha::cancel: cannot cancel executed proposal\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 209,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == guardian || rifi.getPriorVotes(proposal.proposer, sub256(block.number, 1)) < proposalThreshold(), \"GovernorAlpha::cancel: proposer above threshold\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 229,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(proposalCount >= proposalId && proposalId > 0, \"GovernorAlpha::state: invalid proposal id\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 259,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(signatory != address(0), \"GovernorAlpha::castVoteBySig: invalid signature\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 264,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(state(proposalId) == ProposalState.Active, \"GovernorAlpha::_castVote: voting is closed\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 267,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(receipt.hasVoted == false, \"GovernorAlpha::_castVote: voter already voted\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 284,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == guardian, \"GovernorAlpha::__acceptAdmin: sender must be gov guardian\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 289,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == guardian, \"GovernorAlpha::__abdicate: sender must be gov guardian\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 294,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == guardian, \"GovernorAlpha::__queueSetTimelockPendingAdmin: sender must be gov guardian\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 299,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == guardian, \"GovernorAlpha::__executeSetTimelockPendingAdmin: sender must be gov guardian\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 305,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(c >= a, \"addition overflow\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 310,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(b <= a, \"subtraction underflow\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 140,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(targets.length == values.length && targets.length == signatures.length && targets.length == calldatas.length, \"GovernorAlpha::propose: proposal function information arity mismatch\");\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 229,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(proposalCount >= proposalId && proposalId > 0, \"GovernorAlpha::state: invalid proposal id\");\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 154,
          "vulnerability_to_line": null,
          "vulnerability_code": "        proposalCount++;\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 182,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < proposal.targets.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 198,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < proposal.targets.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 212,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < proposal.targets.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 139,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(rifi.getPriorVotes(msg.sender, sub256(block.number, 1)) > proposalThreshold(), \"GovernorAlpha::propose: proposer votes below proposal threshold\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 140,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(targets.length == values.length && targets.length == signatures.length && targets.length == calldatas.length, \"GovernorAlpha::propose: proposal function information arity mismatch\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 141,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(targets.length != 0, \"GovernorAlpha::propose: must provide actions\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 142,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(targets.length <= proposalMaxOperations(), \"GovernorAlpha::propose: too many actions\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 147,
          "vulnerability_to_line": null,
          "vulnerability_code": "          require(proposersLatestProposalState != ProposalState.Active, \"GovernorAlpha::propose: one live proposal per proposer, found an already active proposal\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 148,
          "vulnerability_to_line": null,
          "vulnerability_code": "          require(proposersLatestProposalState != ProposalState.Pending, \"GovernorAlpha::propose: one live proposal per proposer, found an already pending proposal\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 179,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(state(proposalId) == ProposalState.Succeeded, \"GovernorAlpha::queue: proposal can only be queued if it is succeeded\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 190,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(!timelock.queuedTransactions(keccak256(abi.encode(target, value, signature, data, eta))), \"GovernorAlpha::_queueOrRevert: proposal action already queued at eta\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 195,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(state(proposalId) == ProposalState.Queued, \"GovernorAlpha::execute: proposal can only be executed if it is queued\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 206,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(state != ProposalState.Executed, \"GovernorAlpha::cancel: cannot cancel executed proposal\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 209,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == guardian || rifi.getPriorVotes(proposal.proposer, sub256(block.number, 1)) < proposalThreshold(), \"GovernorAlpha::cancel: proposer above threshold\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 229,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(proposalCount >= proposalId && proposalId > 0, \"GovernorAlpha::state: invalid proposal id\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 259,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(signatory != address(0), \"GovernorAlpha::castVoteBySig: invalid signature\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 264,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(state(proposalId) == ProposalState.Active, \"GovernorAlpha::_castVote: voting is closed\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 267,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(receipt.hasVoted == false, \"GovernorAlpha::_castVote: voter already voted\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 284,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == guardian, \"GovernorAlpha::__acceptAdmin: sender must be gov guardian\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 289,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == guardian, \"GovernorAlpha::__abdicate: sender must be gov guardian\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 294,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == guardian, \"GovernorAlpha::__queueSetTimelockPendingAdmin: sender must be gov guardian\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 299,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == guardian, \"GovernorAlpha::__executeSetTimelockPendingAdmin: sender must be gov guardian\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        }
      ]
    },
    "slither": {
      "successfull_analysis": true,
      "errors": [
        "EXIT_CODE_39"
      ],
      "vulnerability_findings": [
        {
          "name": "arbitrary-send",
          "vulnerability_from_line": 194,
          "vulnerability_to_line": 202,
          "vulnerability_code": "    function execute(uint proposalId) public payable {\n\n        require(state(proposalId) == ProposalState.Queued, \"GovernorAlpha::execute: proposal can only be executed if it is queued\");\n\n        Proposal storage proposal = proposals[proposalId];\n\n        proposal.executed = true;\n\n        for (uint i = 0; i < proposal.targets.length; i++) {\n\n            timelock.executeTransaction.value(proposal.values[i])(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], proposal.eta);\n\n        }\n\n        emit ProposalExecuted(proposalId);\n",
          "message": "GovernorAlpha.execute (GovernorAlpha.sol#194-202) sends eth to arbitrary user\n\tDangerous calls:\n\t- timelock.executeTransaction.value(proposal.values[i])(proposal.targets[i],proposal.values[i],proposal.signatures[i],proposal.calldatas[i],proposal.eta) (GovernorAlpha.sol#199)\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 314,
          "vulnerability_to_line": 318,
          "vulnerability_code": "    function getChainId() internal pure returns (uint) {\n\n        uint chainId;\n\n        assembly { chainId := chainid() }\n\n        return chainId;\n",
          "message": "GovernorAlpha.getChainId (GovernorAlpha.sol#314-318) is declared view but contains assembly code\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 263,
          "vulnerability_to_line": 281,
          "vulnerability_code": "    function _castVote(address voter, uint proposalId, bool support) internal {\n\n        require(state(proposalId) == ProposalState.Active, \"GovernorAlpha::_castVote: voting is closed\");\n\n        Proposal storage proposal = proposals[proposalId];\n\n        Receipt storage receipt = proposal.receipts[voter];\n\n        require(receipt.hasVoted == false, \"GovernorAlpha::_castVote: voter already voted\");\n\n        uint96 votes = rifi.getPriorVotes(voter, proposal.startBlock);\n\n\n\n        if (support) {\n\n            proposal.forVotes = add256(proposal.forVotes, votes);\n\n        } else {\n\n            proposal.againstVotes = add256(proposal.againstVotes, votes);\n\n        }\n\n\n\n        receipt.hasVoted = true;\n\n        receipt.support = support;\n\n        receipt.votes = votes;\n\n\n\n        emit VoteCast(voter, proposalId, support, votes);\n",
          "message": "Reentrancy in GovernorAlpha._castVote (GovernorAlpha.sol#263-281):\n\tExternal calls:\n\t- require(bool,string)(state(proposalId) == ProposalState.Active,GovernorAlpha::_castVote: voting is closed) (GovernorAlpha.sol#264)\n\t- votes = rifi.getPriorVotes(voter,proposal.startBlock) (GovernorAlpha.sol#268)\n\tState variables written after the call(s):\n\t- proposals (GovernorAlpha.sol#271)\n\t- proposals (GovernorAlpha.sol#273)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 204,
          "vulnerability_to_line": 217,
          "vulnerability_code": "    function cancel(uint proposalId) public {\n\n        ProposalState state = state(proposalId);\n\n        require(state != ProposalState.Executed, \"GovernorAlpha::cancel: cannot cancel executed proposal\");\n\n\n\n        Proposal storage proposal = proposals[proposalId];\n\n        require(msg.sender == guardian || rifi.getPriorVotes(proposal.proposer, sub256(block.number, 1)) < proposalThreshold(), \"GovernorAlpha::cancel: proposer above threshold\");\n\n\n\n        proposal.canceled = true;\n\n        for (uint i = 0; i < proposal.targets.length; i++) {\n\n            timelock.cancelTransaction(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], proposal.eta);\n\n        }\n\n\n\n        emit ProposalCanceled(proposalId);\n",
          "message": "Reentrancy in GovernorAlpha.cancel (GovernorAlpha.sol#204-217):\n\tExternal calls:\n\t- state = state(proposalId) (GovernorAlpha.sol#205)\n\t- require(bool,string)(msg.sender == guardian || rifi.getPriorVotes(proposal.proposer,sub256(block.number,1)) < proposalThreshold(),GovernorAlpha::cancel: proposer above threshold) (GovernorAlpha.sol#209)\n\tState variables written after the call(s):\n\t- proposals (GovernorAlpha.sol#211)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 194,
          "vulnerability_to_line": 202,
          "vulnerability_code": "    function execute(uint proposalId) public payable {\n\n        require(state(proposalId) == ProposalState.Queued, \"GovernorAlpha::execute: proposal can only be executed if it is queued\");\n\n        Proposal storage proposal = proposals[proposalId];\n\n        proposal.executed = true;\n\n        for (uint i = 0; i < proposal.targets.length; i++) {\n\n            timelock.executeTransaction.value(proposal.values[i])(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], proposal.eta);\n\n        }\n\n        emit ProposalExecuted(proposalId);\n",
          "message": "Reentrancy in GovernorAlpha.execute (GovernorAlpha.sol#194-202):\n\tExternal calls:\n\t- require(bool,string)(state(proposalId) == ProposalState.Queued,GovernorAlpha::execute: proposal can only be executed if it is queued) (GovernorAlpha.sol#195)\n\tState variables written after the call(s):\n\t- proposals (GovernorAlpha.sol#197)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 138,
          "vulnerability_to_line": 176,
          "vulnerability_code": "    function propose(address[] memory targets, uint[] memory values, string[] memory signatures, bytes[] memory calldatas, string memory description) public returns (uint) {\n\n        require(rifi.getPriorVotes(msg.sender, sub256(block.number, 1)) > proposalThreshold(), \"GovernorAlpha::propose: proposer votes below proposal threshold\");\n\n        require(targets.length == values.length && targets.length == signatures.length && targets.length == calldatas.length, \"GovernorAlpha::propose: proposal function information arity mismatch\");\n\n        require(targets.length != 0, \"GovernorAlpha::propose: must provide actions\");\n\n        require(targets.length <= proposalMaxOperations(), \"GovernorAlpha::propose: too many actions\");\n\n\n\n        uint latestProposalId = latestProposalIds[msg.sender];\n\n        if (latestProposalId != 0) {\n\n          ProposalState proposersLatestProposalState = state(latestProposalId);\n\n          require(proposersLatestProposalState != ProposalState.Active, \"GovernorAlpha::propose: one live proposal per proposer, found an already active proposal\");\n\n          require(proposersLatestProposalState != ProposalState.Pending, \"GovernorAlpha::propose: one live proposal per proposer, found an already pending proposal\");\n\n        }\n\n\n\n        uint startBlock = add256(block.number, votingDelay());\n\n        uint endBlock = add256(startBlock, votingPeriod());\n\n\n\n        proposalCount++;\n\n        Proposal memory newProposal = Proposal({\n\n            id: proposalCount,\n\n            proposer: msg.sender,\n\n            eta: 0,\n\n            targets: targets,\n\n            values: values,\n\n            signatures: signatures,\n\n            calldatas: calldatas,\n\n            startBlock: startBlock,\n\n            endBlock: endBlock,\n\n            forVotes: 0,\n\n            againstVotes: 0,\n\n            canceled: false,\n\n            executed: false\n\n        });\n\n\n\n        proposals[newProposal.id] = newProposal;\n\n        latestProposalIds[newProposal.proposer] = newProposal.id;\n\n\n\n        emit ProposalCreated(newProposal.id, msg.sender, targets, values, signatures, calldatas, startBlock, endBlock, description);\n\n        return newProposal.id;\n",
          "message": "Reentrancy in GovernorAlpha.propose (GovernorAlpha.sol#138-176):\n\tExternal calls:\n\t- require(bool,string)(rifi.getPriorVotes(msg.sender,sub256(block.number,1)) > proposalThreshold(),GovernorAlpha::propose: proposer votes below proposal threshold) (GovernorAlpha.sol#139)\n\t- proposersLatestProposalState = state(latestProposalId) (GovernorAlpha.sol#146)\n\tState variables written after the call(s):\n\t- latestProposalIds (GovernorAlpha.sol#172)\n\t- proposalCount (GovernorAlpha.sol#154)\n\t- proposals (GovernorAlpha.sol#171)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 178,
          "vulnerability_to_line": 187,
          "vulnerability_code": "    function queue(uint proposalId) public {\n\n        require(state(proposalId) == ProposalState.Succeeded, \"GovernorAlpha::queue: proposal can only be queued if it is succeeded\");\n\n        Proposal storage proposal = proposals[proposalId];\n\n        uint eta = add256(block.timestamp, timelock.delay());\n\n        for (uint i = 0; i < proposal.targets.length; i++) {\n\n            _queueOrRevert(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], eta);\n\n        }\n\n        proposal.eta = eta;\n\n        emit ProposalQueued(proposalId, eta);\n",
          "message": "Reentrancy in GovernorAlpha.queue (GovernorAlpha.sol#178-187):\n\tExternal calls:\n\t- require(bool,string)(state(proposalId) == ProposalState.Succeeded,GovernorAlpha::queue: proposal can only be queued if it is succeeded) (GovernorAlpha.sol#179)\n\t- eta = add256(block.timestamp,timelock.delay()) (GovernorAlpha.sol#181)\n\tState variables written after the call(s):\n\t- proposals (GovernorAlpha.sol#185)\n"
        },
        {
          "name": "unused-return",
          "vulnerability_from_line": 189,
          "vulnerability_to_line": 192,
          "vulnerability_code": "    function _queueOrRevert(address target, uint value, string memory signature, bytes memory data, uint eta) internal {\n\n        require(!timelock.queuedTransactions(keccak256(abi.encode(target, value, signature, data, eta))), \"GovernorAlpha::_queueOrRevert: proposal action already queued at eta\");\n\n        timelock.queueTransaction(target, value, signature, data, eta);\n",
          "message": "GovernorAlpha._queueOrRevert (GovernorAlpha.sol#189-192) does not use the value returned by external calls:\n\t-timelock.queueTransaction(target,value,signature,data,eta) (GovernorAlpha.sol#191)\n"
        },
        {
          "name": "unused-return",
          "vulnerability_from_line": 194,
          "vulnerability_to_line": 202,
          "vulnerability_code": "    function execute(uint proposalId) public payable {\n\n        require(state(proposalId) == ProposalState.Queued, \"GovernorAlpha::execute: proposal can only be executed if it is queued\");\n\n        Proposal storage proposal = proposals[proposalId];\n\n        proposal.executed = true;\n\n        for (uint i = 0; i < proposal.targets.length; i++) {\n\n            timelock.executeTransaction.value(proposal.values[i])(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], proposal.eta);\n\n        }\n\n        emit ProposalExecuted(proposalId);\n",
          "message": "GovernorAlpha.execute (GovernorAlpha.sol#194-202) does not use the value returned by external calls:\n\t-timelock.executeTransaction.value(proposal.values[i])(proposal.targets[i],proposal.values[i],proposal.signatures[i],proposal.calldatas[i],proposal.eta) (GovernorAlpha.sol#199)\n"
        },
        {
          "name": "unused-return",
          "vulnerability_from_line": 293,
          "vulnerability_to_line": 296,
          "vulnerability_code": "    function __queueSetTimelockPendingAdmin(address newPendingAdmin, uint eta) public {\n\n        require(msg.sender == guardian, \"GovernorAlpha::__queueSetTimelockPendingAdmin: sender must be gov guardian\");\n\n        timelock.queueTransaction(address(timelock), 0, \"setPendingAdmin(address)\", abi.encode(newPendingAdmin), eta);\n",
          "message": "GovernorAlpha.__queueSetTimelockPendingAdmin (GovernorAlpha.sol#293-296) does not use the value returned by external calls:\n\t-timelock.queueTransaction(address(timelock),0,setPendingAdmin(address),abi.encode(newPendingAdmin),eta) (GovernorAlpha.sol#295)\n"
        },
        {
          "name": "unused-return",
          "vulnerability_from_line": 298,
          "vulnerability_to_line": 301,
          "vulnerability_code": "    function __executeSetTimelockPendingAdmin(address newPendingAdmin, uint eta) public {\n\n        require(msg.sender == guardian, \"GovernorAlpha::__executeSetTimelockPendingAdmin: sender must be gov guardian\");\n\n        timelock.executeTransaction(address(timelock), 0, \"setPendingAdmin(address)\", abi.encode(newPendingAdmin), eta);\n",
          "message": "GovernorAlpha.__executeSetTimelockPendingAdmin (GovernorAlpha.sol#298-301) does not use the value returned by external calls:\n\t-timelock.executeTransaction(address(timelock),0,setPendingAdmin(address),abi.encode(newPendingAdmin),eta) (GovernorAlpha.sol#300)\n"
        },
        {
          "name": "shadowing-local",
          "vulnerability_from_line": 205,
          "vulnerability_to_line": null,
          "vulnerability_code": "        ProposalState state = state(proposalId);\n",
          "message": "GovernorAlpha.cancel.state (local variable @ GovernorAlpha.sol#205) shadows:\n\t- GovernorAlpha.state (function @ GovernorAlpha.sol#228-248)\n"
        },
        {
          "name": "calls-loop",
          "vulnerability_from_line": 199,
          "vulnerability_to_line": null,
          "vulnerability_code": "            timelock.executeTransaction.value(proposal.values[i])(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], proposal.eta);\n",
          "message": "GovernorAlpha.execute has external calls inside a loop:\n\t- timelock.executeTransaction.value(proposal.values[i])(proposal.targets[i],proposal.values[i],proposal.signatures[i],proposal.calldatas[i],proposal.eta) (GovernorAlpha.sol#199)\n"
        },
        {
          "name": "calls-loop",
          "vulnerability_from_line": 213,
          "vulnerability_to_line": null,
          "vulnerability_code": "            timelock.cancelTransaction(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], proposal.eta);\n",
          "message": "GovernorAlpha.cancel has external calls inside a loop:\n\t- timelock.cancelTransaction(proposal.targets[i],proposal.values[i],proposal.signatures[i],proposal.calldatas[i],proposal.eta) (GovernorAlpha.sol#213)\n"
        },
        {
          "name": "timestamp",
          "vulnerability_from_line": 189,
          "vulnerability_to_line": 192,
          "vulnerability_code": "    function _queueOrRevert(address target, uint value, string memory signature, bytes memory data, uint eta) internal {\n\n        require(!timelock.queuedTransactions(keccak256(abi.encode(target, value, signature, data, eta))), \"GovernorAlpha::_queueOrRevert: proposal action already queued at eta\");\n\n        timelock.queueTransaction(target, value, signature, data, eta);\n",
          "message": "GovernorAlpha._queueOrRevert (GovernorAlpha.sol#189-192) uses timestamp for comparisons\n\tDangerous comparisons:\n\t- require(bool,string)(! timelock.queuedTransactions(keccak256(bytes)(abi.encode(target,value,signature,data,eta))),GovernorAlpha::_queueOrRevert: proposal action already queued at eta) (GovernorAlpha.sol#190)\n"
        },
        {
          "name": "timestamp",
          "vulnerability_from_line": 228,
          "vulnerability_to_line": 248,
          "vulnerability_code": "    function state(uint proposalId) public view returns (ProposalState) {\n\n        require(proposalCount >= proposalId && proposalId > 0, \"GovernorAlpha::state: invalid proposal id\");\n\n        Proposal storage proposal = proposals[proposalId];\n\n        if (proposal.canceled) {\n\n            return ProposalState.Canceled;\n\n        } else if (block.number <= proposal.startBlock) {\n\n            return ProposalState.Pending;\n\n        } else if (block.number <= proposal.endBlock) {\n\n            return ProposalState.Active;\n\n        } else if (proposal.forVotes <= proposal.againstVotes || proposal.forVotes < quorumVotes()) {\n\n            return ProposalState.Defeated;\n\n        } else if (proposal.eta == 0) {\n\n            return ProposalState.Succeeded;\n\n        } else if (proposal.executed) {\n\n            return ProposalState.Executed;\n\n        } else if (block.timestamp >= add256(proposal.eta, timelock.GRACE_PERIOD())) {\n\n            return ProposalState.Expired;\n\n        } else {\n\n            return ProposalState.Queued;\n\n        }\n",
          "message": "GovernorAlpha.state (GovernorAlpha.sol#228-248) uses timestamp for comparisons\n\tDangerous comparisons:\n\t- block.timestamp >= add256(proposal.eta,timelock.GRACE_PERIOD()) (GovernorAlpha.sol#243-247)\n"
        },
        {
          "name": "timestamp",
          "vulnerability_from_line": 303,
          "vulnerability_to_line": 307,
          "vulnerability_code": "    function add256(uint256 a, uint256 b) internal pure returns (uint) {\n\n        uint c = a + b;\n\n        require(c >= a, \"addition overflow\");\n\n        return c;\n",
          "message": "GovernorAlpha.add256 (GovernorAlpha.sol#303-307) uses timestamp for comparisons\n\tDangerous comparisons:\n\t- require(bool,string)(c >= a,addition overflow) (GovernorAlpha.sol#305)\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 314,
          "vulnerability_to_line": 318,
          "vulnerability_code": "    function getChainId() internal pure returns (uint) {\n\n        uint chainId;\n\n        assembly { chainId := chainid() }\n\n        return chainId;\n",
          "message": "GovernorAlpha.getChainId uses assembly (GovernorAlpha.sol#314-318)\n\t- GovernorAlpha.sol#316\n"
        },
        {
          "name": "pragma",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": "Different versions of Solidity is used in GovernorAlpha.sol:\n\t- Version used: ['ABIEncoderV2', '^0.5.16']\n\t- GovernorAlpha.sol#3 declares pragma solidity^0.5.16\n\t- GovernorAlpha.sol#4 declares pragma experimentalABIEncoderV2\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 138,
          "vulnerability_to_line": 176,
          "vulnerability_code": "    function propose(address[] memory targets, uint[] memory values, string[] memory signatures, bytes[] memory calldatas, string memory description) public returns (uint) {\n\n        require(rifi.getPriorVotes(msg.sender, sub256(block.number, 1)) > proposalThreshold(), \"GovernorAlpha::propose: proposer votes below proposal threshold\");\n\n        require(targets.length == values.length && targets.length == signatures.length && targets.length == calldatas.length, \"GovernorAlpha::propose: proposal function information arity mismatch\");\n\n        require(targets.length != 0, \"GovernorAlpha::propose: must provide actions\");\n\n        require(targets.length <= proposalMaxOperations(), \"GovernorAlpha::propose: too many actions\");\n\n\n\n        uint latestProposalId = latestProposalIds[msg.sender];\n\n        if (latestProposalId != 0) {\n\n          ProposalState proposersLatestProposalState = state(latestProposalId);\n\n          require(proposersLatestProposalState != ProposalState.Active, \"GovernorAlpha::propose: one live proposal per proposer, found an already active proposal\");\n\n          require(proposersLatestProposalState != ProposalState.Pending, \"GovernorAlpha::propose: one live proposal per proposer, found an already pending proposal\");\n\n        }\n\n\n\n        uint startBlock = add256(block.number, votingDelay());\n\n        uint endBlock = add256(startBlock, votingPeriod());\n\n\n\n        proposalCount++;\n\n        Proposal memory newProposal = Proposal({\n\n            id: proposalCount,\n\n            proposer: msg.sender,\n\n            eta: 0,\n\n            targets: targets,\n\n            values: values,\n\n            signatures: signatures,\n\n            calldatas: calldatas,\n\n            startBlock: startBlock,\n\n            endBlock: endBlock,\n\n            forVotes: 0,\n\n            againstVotes: 0,\n\n            canceled: false,\n\n            executed: false\n\n        });\n\n\n\n        proposals[newProposal.id] = newProposal;\n\n        latestProposalIds[newProposal.proposer] = newProposal.id;\n\n\n\n        emit ProposalCreated(newProposal.id, msg.sender, targets, values, signatures, calldatas, startBlock, endBlock, description);\n\n        return newProposal.id;\n",
          "message": "GovernorAlpha.propose (GovernorAlpha.sol#138-176) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 178,
          "vulnerability_to_line": 187,
          "vulnerability_code": "    function queue(uint proposalId) public {\n\n        require(state(proposalId) == ProposalState.Succeeded, \"GovernorAlpha::queue: proposal can only be queued if it is succeeded\");\n\n        Proposal storage proposal = proposals[proposalId];\n\n        uint eta = add256(block.timestamp, timelock.delay());\n\n        for (uint i = 0; i < proposal.targets.length; i++) {\n\n            _queueOrRevert(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], eta);\n\n        }\n\n        proposal.eta = eta;\n\n        emit ProposalQueued(proposalId, eta);\n",
          "message": "GovernorAlpha.queue (GovernorAlpha.sol#178-187) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 194,
          "vulnerability_to_line": 202,
          "vulnerability_code": "    function execute(uint proposalId) public payable {\n\n        require(state(proposalId) == ProposalState.Queued, \"GovernorAlpha::execute: proposal can only be executed if it is queued\");\n\n        Proposal storage proposal = proposals[proposalId];\n\n        proposal.executed = true;\n\n        for (uint i = 0; i < proposal.targets.length; i++) {\n\n            timelock.executeTransaction.value(proposal.values[i])(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], proposal.eta);\n\n        }\n\n        emit ProposalExecuted(proposalId);\n",
          "message": "GovernorAlpha.execute (GovernorAlpha.sol#194-202) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 204,
          "vulnerability_to_line": 217,
          "vulnerability_code": "    function cancel(uint proposalId) public {\n\n        ProposalState state = state(proposalId);\n\n        require(state != ProposalState.Executed, \"GovernorAlpha::cancel: cannot cancel executed proposal\");\n\n\n\n        Proposal storage proposal = proposals[proposalId];\n\n        require(msg.sender == guardian || rifi.getPriorVotes(proposal.proposer, sub256(block.number, 1)) < proposalThreshold(), \"GovernorAlpha::cancel: proposer above threshold\");\n\n\n\n        proposal.canceled = true;\n\n        for (uint i = 0; i < proposal.targets.length; i++) {\n\n            timelock.cancelTransaction(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], proposal.eta);\n\n        }\n\n\n\n        emit ProposalCanceled(proposalId);\n",
          "message": "GovernorAlpha.cancel (GovernorAlpha.sol#204-217) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 219,
          "vulnerability_to_line": 222,
          "vulnerability_code": "    function getActions(uint proposalId) public view returns (address[] memory targets, uint[] memory values, string[] memory signatures, bytes[] memory calldatas) {\n\n        Proposal storage p = proposals[proposalId];\n\n        return (p.targets, p.values, p.signatures, p.calldatas);\n",
          "message": "GovernorAlpha.getActions (GovernorAlpha.sol#219-222) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 224,
          "vulnerability_to_line": 226,
          "vulnerability_code": "    function getReceipt(uint proposalId, address voter) public view returns (Receipt memory) {\n\n        return proposals[proposalId].receipts[voter];\n",
          "message": "GovernorAlpha.getReceipt (GovernorAlpha.sol#224-226) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 250,
          "vulnerability_to_line": 252,
          "vulnerability_code": "    function castVote(uint proposalId, bool support) public {\n\n        return _castVote(msg.sender, proposalId, support);\n",
          "message": "GovernorAlpha.castVote (GovernorAlpha.sol#250-252) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 254,
          "vulnerability_to_line": 261,
          "vulnerability_code": "    function castVoteBySig(uint proposalId, bool support, uint8 v, bytes32 r, bytes32 s) public {\n\n        bytes32 domainSeparator = keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), getChainId(), address(this)));\n\n        bytes32 structHash = keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support));\n\n        bytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n\n        address signatory = ecrecover(digest, v, r, s);\n\n        require(signatory != address(0), \"GovernorAlpha::castVoteBySig: invalid signature\");\n\n        return _castVote(signatory, proposalId, support);\n",
          "message": "GovernorAlpha.castVoteBySig (GovernorAlpha.sol#254-261) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 283,
          "vulnerability_to_line": 286,
          "vulnerability_code": "    function __acceptAdmin() public {\n\n        require(msg.sender == guardian, \"GovernorAlpha::__acceptAdmin: sender must be gov guardian\");\n\n        timelock.acceptAdmin();\n",
          "message": "GovernorAlpha.__acceptAdmin (GovernorAlpha.sol#283-286) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 288,
          "vulnerability_to_line": 291,
          "vulnerability_code": "    function __abdicate() public {\n\n        require(msg.sender == guardian, \"GovernorAlpha::__abdicate: sender must be gov guardian\");\n\n        guardian = address(0);\n",
          "message": "GovernorAlpha.__abdicate (GovernorAlpha.sol#288-291) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 293,
          "vulnerability_to_line": 296,
          "vulnerability_code": "    function __queueSetTimelockPendingAdmin(address newPendingAdmin, uint eta) public {\n\n        require(msg.sender == guardian, \"GovernorAlpha::__queueSetTimelockPendingAdmin: sender must be gov guardian\");\n\n        timelock.queueTransaction(address(timelock), 0, \"setPendingAdmin(address)\", abi.encode(newPendingAdmin), eta);\n",
          "message": "GovernorAlpha.__queueSetTimelockPendingAdmin (GovernorAlpha.sol#293-296) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 298,
          "vulnerability_to_line": 301,
          "vulnerability_code": "    function __executeSetTimelockPendingAdmin(address newPendingAdmin, uint eta) public {\n\n        require(msg.sender == guardian, \"GovernorAlpha::__executeSetTimelockPendingAdmin: sender must be gov guardian\");\n\n        timelock.executeTransaction(address(timelock), 0, \"setPendingAdmin(address)\", abi.encode(newPendingAdmin), eta);\n",
          "message": "GovernorAlpha.__executeSetTimelockPendingAdmin (GovernorAlpha.sol#298-301) should be declared external\n"
        },
        {
          "name": "solc-version",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": "Detected issues with version pragma in GovernorAlpha.sol:\n\t- pragma solidity^0.5.16 (GovernorAlpha.sol#3): it allows old versions\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 189,
          "vulnerability_to_line": 192,
          "vulnerability_code": "    function _queueOrRevert(address target, uint value, string memory signature, bytes memory data, uint eta) internal {\n\n        require(!timelock.queuedTransactions(keccak256(abi.encode(target, value, signature, data, eta))), \"GovernorAlpha::_queueOrRevert: proposal action already queued at eta\");\n\n        timelock.queueTransaction(target, value, signature, data, eta);\n",
          "message": "Function 'GovernorAlpha._queueOrRevert' (GovernorAlpha.sol#189-192) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 263,
          "vulnerability_to_line": 281,
          "vulnerability_code": "    function _castVote(address voter, uint proposalId, bool support) internal {\n\n        require(state(proposalId) == ProposalState.Active, \"GovernorAlpha::_castVote: voting is closed\");\n\n        Proposal storage proposal = proposals[proposalId];\n\n        Receipt storage receipt = proposal.receipts[voter];\n\n        require(receipt.hasVoted == false, \"GovernorAlpha::_castVote: voter already voted\");\n\n        uint96 votes = rifi.getPriorVotes(voter, proposal.startBlock);\n\n\n\n        if (support) {\n\n            proposal.forVotes = add256(proposal.forVotes, votes);\n\n        } else {\n\n            proposal.againstVotes = add256(proposal.againstVotes, votes);\n\n        }\n\n\n\n        receipt.hasVoted = true;\n\n        receipt.support = support;\n\n        receipt.votes = votes;\n\n\n\n        emit VoteCast(voter, proposalId, support, votes);\n",
          "message": "Function 'GovernorAlpha._castVote' (GovernorAlpha.sol#263-281) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 283,
          "vulnerability_to_line": 286,
          "vulnerability_code": "    function __acceptAdmin() public {\n\n        require(msg.sender == guardian, \"GovernorAlpha::__acceptAdmin: sender must be gov guardian\");\n\n        timelock.acceptAdmin();\n",
          "message": "Function 'GovernorAlpha.__acceptAdmin' (GovernorAlpha.sol#283-286) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 288,
          "vulnerability_to_line": 291,
          "vulnerability_code": "    function __abdicate() public {\n\n        require(msg.sender == guardian, \"GovernorAlpha::__abdicate: sender must be gov guardian\");\n\n        guardian = address(0);\n",
          "message": "Function 'GovernorAlpha.__abdicate' (GovernorAlpha.sol#288-291) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 293,
          "vulnerability_to_line": 296,
          "vulnerability_code": "    function __queueSetTimelockPendingAdmin(address newPendingAdmin, uint eta) public {\n\n        require(msg.sender == guardian, \"GovernorAlpha::__queueSetTimelockPendingAdmin: sender must be gov guardian\");\n\n        timelock.queueTransaction(address(timelock), 0, \"setPendingAdmin(address)\", abi.encode(newPendingAdmin), eta);\n",
          "message": "Function 'GovernorAlpha.__queueSetTimelockPendingAdmin' (GovernorAlpha.sol#293-296) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 298,
          "vulnerability_to_line": 301,
          "vulnerability_code": "    function __executeSetTimelockPendingAdmin(address newPendingAdmin, uint eta) public {\n\n        require(msg.sender == guardian, \"GovernorAlpha::__executeSetTimelockPendingAdmin: sender must be gov guardian\");\n\n        timelock.executeTransaction(address(timelock), 0, \"setPendingAdmin(address)\", abi.encode(newPendingAdmin), eta);\n",
          "message": "Function 'GovernorAlpha.__executeSetTimelockPendingAdmin' (GovernorAlpha.sol#298-301) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 323,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function GRACE_PERIOD() external view returns (uint);\n",
          "message": "Function 'TimelockInterface.GRACE_PERIOD' (GovernorAlpha.sol#323) is not in mixedCase\n"
        }
      ]
    },
    "smartcheck": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 290,
          "vulnerability_to_line": null,
          "vulnerability_code": "        guardian = address(0);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 182,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < proposal.targets.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 198,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < proposal.targets.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 212,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < proposal.targets.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 182,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < proposal.targets.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 198,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < proposal.targets.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 212,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < proposal.targets.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 314,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getChainId() internal pure returns (uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 219,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getActions(uint proposalId) public view returns (address[] memory targets, uint[] memory values, string[] memory signatures, bytes[] memory calldatas) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 316,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly { chainId := chainid() }\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 326,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function queueTransaction(address target, uint value, string calldata signature, bytes calldata data, uint eta) external returns (bytes32);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 327,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function cancelTransaction(address target, uint value, string calldata signature, bytes calldata data, uint eta) external;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 328,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function executeTransaction(address target, uint value, string calldata signature, bytes calldata data, uint eta) external payable returns (bytes memory);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 326,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function queueTransaction(address target, uint value, string calldata signature, bytes calldata data, uint eta) external returns (bytes32);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 326,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function queueTransaction(address target, uint value, string calldata signature, bytes calldata data, uint eta) external returns (bytes32);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 326,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function queueTransaction(address target, uint value, string calldata signature, bytes calldata data, uint eta) external returns (bytes32);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 326,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function queueTransaction(address target, uint value, string calldata signature, bytes calldata data, uint eta) external returns (bytes32);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 326,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function queueTransaction(address target, uint value, string calldata signature, bytes calldata data, uint eta) external returns (bytes32);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 327,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function cancelTransaction(address target, uint value, string calldata signature, bytes calldata data, uint eta) external;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 327,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function cancelTransaction(address target, uint value, string calldata signature, bytes calldata data, uint eta) external;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 327,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function cancelTransaction(address target, uint value, string calldata signature, bytes calldata data, uint eta) external;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 327,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function cancelTransaction(address target, uint value, string calldata signature, bytes calldata data, uint eta) external;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 328,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function executeTransaction(address target, uint value, string calldata signature, bytes calldata data, uint eta) external payable returns (bytes memory);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 328,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function executeTransaction(address target, uint value, string calldata signature, bytes calldata data, uint eta) external payable returns (bytes memory);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 328,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function executeTransaction(address target, uint value, string calldata signature, bytes calldata data, uint eta) external payable returns (bytes memory);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 328,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function executeTransaction(address target, uint value, string calldata signature, bytes calldata data, uint eta) external payable returns (bytes memory);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 328,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function executeTransaction(address target, uint value, string calldata signature, bytes calldata data, uint eta) external payable returns (bytes memory);\n",
          "message": null
        }
      ]
    },
    "oyente": {
      "successfull_analysis": false,
      "errors": [
        "exception (RuntimeError: Source map error, unknown name(SHR) or instr_name(INVALID))"
      ],
      "vulnerability_findings": []
    },
    "mythril": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": []
    },
    "osiris": {
      "successfull_analysis": false,
      "errors": [
        "Solidity compilation failed"
      ],
      "vulnerability_findings": []
    }
  }
}