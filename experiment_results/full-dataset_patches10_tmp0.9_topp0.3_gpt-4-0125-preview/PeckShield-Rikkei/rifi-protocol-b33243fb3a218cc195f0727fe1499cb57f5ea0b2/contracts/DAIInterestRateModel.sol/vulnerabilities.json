{
  "smartbugs_completed": true,
  "analyzer_results": {
    "semgrep": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 260,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor(\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 261,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint256 baseRatePerYear,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 262,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint256 lowerBaseRatePerYear,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 263,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint256 multiplierPerYear,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 264,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint256 jumpMultiplierPerYear,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 265,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint256 kink_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 266,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint256 lowerKink_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 267,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address owner_\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 268,
          "vulnerability_to_line": null,
          "vulnerability_code": "    ) internal {\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 269,
          "vulnerability_to_line": null,
          "vulnerability_code": "        owner = owner_;\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 485,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor(\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 486,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint256 baseRatePerYear,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 487,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint256 lowerBaseRatePerYear,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 488,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint256 multiplierPerYear,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 489,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint256 jumpMultiplierPerYear,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 490,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint256 kink_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 491,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint256 lowerKink_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 492,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address owner_\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 493,
          "vulnerability_to_line": null,
          "vulnerability_code": "    )\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 494,
          "vulnerability_to_line": null,
          "vulnerability_code": "        public\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 3361,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor() public {}\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 3640,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor(uint jumpMultiplierPerYear, uint kink_, address pot_, address jug_, address owner_) JumpRateModel(0, 0, 0, jumpMultiplierPerYear, kink_, 0, owner_) public {\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 3641,
          "vulnerability_to_line": null,
          "vulnerability_code": "        gapPerBlock = 4e16 / blocksPerYear;\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 3642,
          "vulnerability_to_line": null,
          "vulnerability_code": "        pot = PotLike(pot_);\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 3643,
          "vulnerability_to_line": null,
          "vulnerability_code": "        jug = JugLike(jug_);\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 3644,
          "vulnerability_to_line": null,
          "vulnerability_code": "        poke();\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 3645,
          "vulnerability_to_line": null,
          "vulnerability_code": "    }\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 32,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(c >= a, \"SafeMath: addition overflow\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 96,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(c / a == b, \"SafeMath: multiplication overflow\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 296,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == owner, \"only the owner may call this function.\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1734,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == admin, \"only admin may initialize the market\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1735,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(accrualBlockNumber == 0 && borrowIndex == 0, \"market may only be initialized once\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1739,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(initialExchangeRateMantissa > 0, \"initial exchange rate must be greater than zero.\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1743,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(err == uint(Error.NO_ERROR), \"setting cointroller failed\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1751,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(err == uint(Error.NO_ERROR), \"setting interest rate model failed\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1896,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(mErr == MathError.NO_ERROR, \"balance could not be calculated\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1955,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1965,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1976,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(err == MathError.NO_ERROR, \"borrowBalanceStored: borrowBalanceStoredInternal failed\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 2022,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 2033,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(err == MathError.NO_ERROR, \"exchangeRateStored: exchangeRateStoredInternal failed\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 2105,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 2109,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(mathErr == MathError.NO_ERROR, \"could not calculate block delta\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 2239,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(vars.mathErr == MathError.NO_ERROR, \"MINT_EXCHANGE_CALCULATION_FAILED\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 2247,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(vars.mathErr == MathError.NO_ERROR, \"MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 2250,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(vars.mathErr == MathError.NO_ERROR, \"MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 2318,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 2605,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(vars.mathErr == MathError.NO_ERROR, \"REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 2608,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(vars.mathErr == MathError.NO_ERROR, \"REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 2704,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(amountSeizeError == uint(Error.NO_ERROR), \"LIQUIDATE_COINTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 2707,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(rTokenCollateral.balanceOf(borrower) >= seizeTokens, \"LIQUIDATE_SEIZE_TOO_MUCH\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 2718,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(seizeError == uint(Error.NO_ERROR), \"token seizure failed\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 2869,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(newCointroller.isCointroller(), \"marker method returned false\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 2974,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(totalReservesNew >= totalReserves, \"add reserves unexpected overflow\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 3038,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(totalReservesNew <= totalReserves, \"reduce reserves unexpected underflow\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 3092,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 3132,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_notEntered, \"re-entered\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 3255,
          "vulnerability_to_line": null,
          "vulnerability_code": "    \trequire(address(token) != underlying, \"RBep20::sweepToken: can not sweep underlying token\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 3309,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(success, \"TOKEN_TRANSFER_IN_FAILED\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 3313,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(balanceAfter >= balanceBefore, \"TOKEN_TRANSFER_IN_OVERFLOW\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 3344,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(success, \"TOKEN_TRANSFER_OUT_FAILED\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 3376,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == admin, \"only the admin may call _becomeImplementation\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 3388,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == admin, \"only the admin may call _resignImplementation\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 3422,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == admin, \"only the admin may initialize the implementation\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 3439,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(address(dai) == underlying, \"DAI must be the same as underlying\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 3464,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == admin, \"only the admin may abandon the implementation\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 3522,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(token.transferFrom(from, address(this), amount), \"unexpected EIP-20 transfer in return\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 3565,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require((z = x + y) >= x, \"add-overflow\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 3569,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(y == 0 || (z = x * y) / y == x, \"mul-overflow\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 3655,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == owner, \"only the owner may call this function.\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 1735,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(accrualBlockNumber == 0 && borrowIndex == 0, \"market may only be initialized once\");\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 96,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(c / a == b, \"SafeMath: multiplication overflow\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 296,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == owner, \"only the owner may call this function.\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 1734,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == admin, \"only admin may initialize the market\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 1735,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(accrualBlockNumber == 0 && borrowIndex == 0, \"market may only be initialized once\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 1739,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(initialExchangeRateMantissa > 0, \"initial exchange rate must be greater than zero.\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 1751,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(err == uint(Error.NO_ERROR), \"setting interest rate model failed\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 1976,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(err == MathError.NO_ERROR, \"borrowBalanceStored: borrowBalanceStoredInternal failed\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 2033,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(err == MathError.NO_ERROR, \"exchangeRateStored: exchangeRateStoredInternal failed\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 2247,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(vars.mathErr == MathError.NO_ERROR, \"MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 2250,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(vars.mathErr == MathError.NO_ERROR, \"MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 2318,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 2605,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(vars.mathErr == MathError.NO_ERROR, \"REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 2608,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(vars.mathErr == MathError.NO_ERROR, \"REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 2704,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(amountSeizeError == uint(Error.NO_ERROR), \"LIQUIDATE_COINTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 3038,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(totalReservesNew <= totalReserves, \"reduce reserves unexpected underflow\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 3255,
          "vulnerability_to_line": null,
          "vulnerability_code": "    \trequire(address(token) != underlying, \"RBep20::sweepToken: can not sweep underlying token\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 3376,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == admin, \"only the admin may call _becomeImplementation\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 3388,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == admin, \"only the admin may call _resignImplementation\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 3422,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == admin, \"only the admin may initialize the implementation\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 3439,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(address(dai) == underlying, \"DAI must be the same as underlying\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 3464,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == admin, \"only the admin may abandon the implementation\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 3522,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(token.transferFrom(from, address(this), amount), \"unexpected EIP-20 transfer in return\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 3655,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == owner, \"only the owner may call this function.\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "compound-borrowfresh-reentrancy",
          "vulnerability_from_line": 2490,
          "vulnerability_to_line": null,
          "vulnerability_code": "        doTransferOut(borrower, borrowAmount);\n",
          "message": "Function borrowFresh() in Compound performs state update after doTransferOut()"
        },
        {
          "name": "compound-sweeptoken-not-restricted",
          "vulnerability_from_line": 3257,
          "vulnerability_to_line": null,
          "vulnerability_code": "    \ttoken.transfer(admin, balance);\n",
          "message": "Function sweepToken is allowed to be called by anyone"
        }
      ]
    },
    "slither": {
      "successfull_analysis": true,
      "errors": [
        "EXIT_CODE_105"
      ],
      "vulnerability_findings": [
        {
          "name": "erc20-interface",
          "vulnerability_from_line": 590,
          "vulnerability_to_line": 652,
          "vulnerability_code": "interface EIP20NonStandardInterface {\n\n\n\n    /**\n\n     * @notice Get the total number of tokens in circulation\n\n     * @return The supply of tokens\n\n     */\n\n    function totalSupply() external view returns (uint256);\n\n\n\n    /**\n\n     * @notice Gets the balance of the specified address\n\n     * @param owner The address from which the balance will be retrieved\n\n     * @return The balance\n\n     */\n\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n\n\n    ///\n\n    /// !!!!!!!!!!!!!!\n\n    /// !!! NOTICE !!! `transfer` does not return a value, in violation of the BEP-20 specification\n\n    /// !!!!!!!!!!!!!!\n\n    ///\n\n\n\n    /**\n\n      * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n\n      * @param dst The address of the destination account\n\n      * @param amount The number of tokens to transfer\n\n      */\n\n    function transfer(address dst, uint256 amount) external;\n\n\n\n    ///\n\n    /// !!!!!!!!!!!!!!\n\n    /// !!! NOTICE !!! `transferFrom` does not return a value, in violation of the BEP-20 specification\n\n    /// !!!!!!!!!!!!!!\n\n    ///\n\n\n\n    /**\n\n      * @notice Transfer `amount` tokens from `src` to `dst`\n\n      * @param src The address of the source account\n\n      * @param dst The address of the destination account\n\n      * @param amount The number of tokens to transfer\n\n      */\n\n    function transferFrom(address src, address dst, uint256 amount) external;\n\n\n\n    /**\n\n      * @notice Approve `spender` to transfer up to `amount` from `src`\n\n      * @dev This will overwrite the approval amount for `spender`\n\n      *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n\n      * @param spender The address of the account which may transfer tokens\n\n      * @param amount The number of tokens that are approved\n\n      * @return Whether or not the approval succeeded\n\n      */\n\n    function approve(address spender, uint256 amount) external returns (bool success);\n\n\n\n    /**\n\n      * @notice Get the current allowance from `owner` for `spender`\n\n      * @param owner The address of the account which owns the tokens to be spent\n\n      * @param spender The address of the account which may transfer tokens\n\n      * @return The number of tokens allowed to be spent\n\n      */\n\n    function allowance(address owner, address spender) external view returns (uint256 remaining);\n\n\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n",
          "message": "EIP20NonStandardInterface (DAIInterestRateModel.sol#590-652) has incorrect ERC20 function interface(s):\n\t-transfer (DAIInterestRateModel.sol#616)\n\t-transferFrom (DAIInterestRateModel.sol#630)\n"
        },
        {
          "name": "erc20-interface",
          "vulnerability_from_line": 3585,
          "vulnerability_to_line": 3591,
          "vulnerability_code": "interface GemLike {\n\n    function approve(address, uint) external;\n\n    function balanceOf(address) external view returns (uint);\n\n    function transferFrom(address, address, uint) external returns (bool);\n\n}\n\n\n",
          "message": "GemLike (DAIInterestRateModel.sol#3585-3591) has incorrect ERC20 function interface(s):\n\t-approve (DAIInterestRateModel.sol#3586-3587)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 2929,
          "vulnerability_to_line": 2941,
          "vulnerability_code": "    function _addReservesInternal(uint addAmount) internal nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n\n            return fail(Error(error), FailureInfo.ADD_RESERVES_ACCRUE_INTEREST_FAILED);\n\n        }\n\n\n\n        // _addReservesFresh emits reserve-addition-specific logs on errors, so we don't need to.\n\n        (error, ) = _addReservesFresh(addAmount);\n\n        return error;\n\n    }\n\n\n",
          "message": "Reentrancy in RToken._addReservesInternal (DAIInterestRateModel.sol#2929-2941):\n\tExternal calls:\n\t- error = accrueInterest() (DAIInterestRateModel.sol#2930-2931)\n\tState variables written after the call(s):\n\t- totalReserves (DAIInterestRateModel.sol#2937-2938)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 2992,
          "vulnerability_to_line": 3002,
          "vulnerability_code": "    function _reduceReserves(uint reduceAmount) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n\n            return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.\n\n        return _reduceReservesFresh(reduceAmount);\n\n    }\n\n\n",
          "message": "Reentrancy in RToken._reduceReserves (DAIInterestRateModel.sol#2992-3002):\n\tExternal calls:\n\t- error = accrueInterest() (DAIInterestRateModel.sol#2993-2994)\n\tState variables written after the call(s):\n\t- totalReserves (DAIInterestRateModel.sol#2999-3000)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 2861,
          "vulnerability_to_line": 2880,
          "vulnerability_code": "    function _setCointroller(CointrollerInterface newCointroller) public returns (uint) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COINTROLLER_OWNER_CHECK);\n\n        }\n\n\n\n        CointrollerInterface oldCointroller = cointroller;\n\n        // Ensure invoke cointroller.isCointroller() returns true\n\n        require(newCointroller.isCointroller(), \"marker method returned false\");\n\n\n\n        // Set market's cointroller to newCointroller\n\n        cointroller = newCointroller;\n\n\n\n        // Emit NewCointroller(oldCointroller, newCointroller)\n\n        emit NewCointroller(oldCointroller, newCointroller);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Reentrancy in RToken._setCointroller (DAIInterestRateModel.sol#2861-2880):\n\tExternal calls:\n\t- require(bool,string)(newCointroller.isCointroller(),marker method returned false) (DAIInterestRateModel.sol#2869-2870)\n\tState variables written after the call(s):\n\t- cointroller (DAIInterestRateModel.sol#2872-2873)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 3057,
          "vulnerability_to_line": 3067,
          "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n\n        return _setInterestRateModelFresh(newInterestRateModel);\n\n    }\n\n\n",
          "message": "Reentrancy in RToken._setInterestRateModel (DAIInterestRateModel.sol#3057-3067):\n\tExternal calls:\n\t- error = accrueInterest() (DAIInterestRateModel.sol#3058-3059)\n\t- _setInterestRateModelFresh(newInterestRateModel) (DAIInterestRateModel.sol#3064-3065)\n\tState variables written after the call(s):\n\t- interestRateModel (DAIInterestRateModel.sol#3064-3065)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 3073,
          "vulnerability_to_line": 3103,
          "vulnerability_code": "    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {\n\n\n\n        // Used to store old model for use in the event that is emitted on success\n\n        InterestRateModel oldInterestRateModel;\n\n\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);\n\n        }\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);\n\n        }\n\n\n\n        // Track the market's current interest rate model\n\n        oldInterestRateModel = interestRateModel;\n\n\n\n        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true\n\n        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n\n\n\n        // Set the interest rate model to newInterestRateModel\n\n        interestRateModel = newInterestRateModel;\n\n\n\n        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)\n\n        emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Reentrancy in RToken._setInterestRateModelFresh (DAIInterestRateModel.sol#3073-3103):\n\tExternal calls:\n\t- require(bool,string)(newInterestRateModel.isInterestRateModel(),marker method returned false) (DAIInterestRateModel.sol#3092-3094)\n\tState variables written after the call(s):\n\t- interestRateModel (DAIInterestRateModel.sol#3095-3097)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 2885,
          "vulnerability_to_line": 2895,
          "vulnerability_code": "    function _setReserveFactor(uint newReserveFactorMantissa) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.\n\n            return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.\n\n        return _setReserveFactorFresh(newReserveFactorMantissa);\n\n    }\n\n\n",
          "message": "Reentrancy in RToken._setReserveFactor (DAIInterestRateModel.sol#2885-2895):\n\tExternal calls:\n\t- error = accrueInterest() (DAIInterestRateModel.sol#2886-2887)\n\tState variables written after the call(s):\n\t- reserveFactorMantissa (DAIInterestRateModel.sol#2892-2893)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 2087,
          "vulnerability_to_line": 2165,
          "vulnerability_code": "    function accrueInterest() public returns (uint) {\n\n        /* Remember the initial block number */\n\n        uint currentBlockNumber = getBlockNumber();\n\n        uint accrualBlockNumberPrior = accrualBlockNumber;\n\n\n\n        /* Short-circuit accumulating 0 interest */\n\n        if (accrualBlockNumberPrior == currentBlockNumber) {\n\n            return uint(Error.NO_ERROR);\n\n        }\n\n\n\n        /* Read the previous values out of storage */\n\n        uint cashPrior = getCashPrior();\n\n        uint borrowsPrior = totalBorrows;\n\n        uint reservesPrior = totalReserves;\n\n        uint borrowIndexPrior = borrowIndex;\n\n\n\n        /* Calculate the current borrow interest rate */\n\n        uint borrowRateMantissa = interestRateModel.getBorrowRate(cashPrior, borrowsPrior, reservesPrior);\n\n        require(borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n\n\n\n        /* Calculate the number of blocks elapsed since the last accrual */\n\n        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);\n\n        require(mathErr == MathError.NO_ERROR, \"could not calculate block delta\");\n\n\n\n        /*\n\n         * Calculate the interest accumulated into borrows and reserves and the new index:\n\n         *  simpleInterestFactor = borrowRate * blockDelta\n\n         *  interestAccumulated = simpleInterestFactor * totalBorrows\n\n         *  totalBorrowsNew = interestAccumulated + totalBorrows\n\n         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves\n\n         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\n\n         */\n\n\n\n        Exp memory simpleInterestFactor;\n\n        uint interestAccumulated;\n\n        uint totalBorrowsNew;\n\n        uint totalReservesNew;\n\n        uint borrowIndexNew;\n\n\n\n        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa: borrowRateMantissa}), blockDelta);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED, uint(mathErr));\n\n        }\n\n\n\n        (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED, uint(mathErr));\n\n        }\n\n\n\n        (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED, uint(mathErr));\n\n        }\n\n\n\n        (mathErr, totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa: reserveFactorMantissa}), interestAccumulated, reservesPrior);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED, uint(mathErr));\n\n        }\n\n\n\n        (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndexPrior, borrowIndexPrior);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED, uint(mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accrualBlockNumber = currentBlockNumber;\n\n        borrowIndex = borrowIndexNew;\n\n        totalBorrows = totalBorrowsNew;\n\n        totalReserves = totalReservesNew;\n\n\n\n        /* We emit an AccrueInterest event */\n\n        emit AccrueInterest(cashPrior, interestAccumulated, borrowIndexNew, totalBorrowsNew);\n\n\n\n        return uint(Error.NO_ERROR);\n",
          "message": "Reentrancy in RToken.accrueInterest (DAIInterestRateModel.sol#2087-2165):\n\tExternal calls:\n\t- borrowRateMantissa = interestRateModel.getBorrowRate(cashPrior,borrowsPrior,reservesPrior) (DAIInterestRateModel.sol#2104)\n\tState variables written after the call(s):\n\t- accrualBlockNumber (DAIInterestRateModel.sol#2156)\n\t- borrowIndex (DAIInterestRateModel.sol#2157)\n\t- totalBorrows (DAIInterestRateModel.sol#2158)\n\t- totalReserves (DAIInterestRateModel.sol#2159)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 2418,
          "vulnerability_to_line": 2426,
          "vulnerability_code": "    function borrowInternal(uint borrowAmount) internal nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n\n            return fail(Error(error), FailureInfo.BORROW_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // borrowFresh emits borrow-specific logs on errors, so we don't need to\n\n        return borrowFresh(msg.sender, borrowAmount);\n",
          "message": "Reentrancy in RToken.borrowInternal (DAIInterestRateModel.sol#2418-2426):\n\tExternal calls:\n\t- error = accrueInterest() (DAIInterestRateModel.sol#2419)\n\t- borrowFresh(msg.sender,borrowAmount) (DAIInterestRateModel.sol#2425)\n\tState variables written after the call(s):\n\t- totalBorrows (DAIInterestRateModel.sol#2425)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 1728,
          "vulnerability_to_line": 1759,
          "vulnerability_code": "    function initialize(CointrollerInterface cointroller_,\n\n                        InterestRateModel interestRateModel_,\n\n                        uint initialExchangeRateMantissa_,\n\n                        string memory name_,\n\n                        string memory symbol_,\n\n                        uint8 decimals_) public {\n\n        require(msg.sender == admin, \"only admin may initialize the market\");\n\n        require(accrualBlockNumber == 0 && borrowIndex == 0, \"market may only be initialized once\");\n\n\n\n        // Set initial exchange rate\n\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n\n        require(initialExchangeRateMantissa > 0, \"initial exchange rate must be greater than zero.\");\n\n\n\n        // Set the cointroller\n\n        uint err = _setCointroller(cointroller_);\n\n        require(err == uint(Error.NO_ERROR), \"setting cointroller failed\");\n\n\n\n        // Initialize block number and borrow index (block number mocks depend on cointroller being set)\n\n        accrualBlockNumber = getBlockNumber();\n\n        borrowIndex = mantissaOne;\n\n\n\n        // Set the interest rate model (depends on block number / borrow index)\n\n        err = _setInterestRateModelFresh(interestRateModel_);\n\n        require(err == uint(Error.NO_ERROR), \"setting interest rate model failed\");\n\n\n\n        name = name_;\n\n        symbol = symbol_;\n\n        decimals = decimals_;\n\n\n\n        // The counter starts true to prevent changing it from zero to non-zero (i.e. smaller cost/refund)\n\n        _notEntered = true;\n",
          "message": "Reentrancy in RToken.initialize (DAIInterestRateModel.sol#1728-1759):\n\tExternal calls:\n\t- err = _setCointroller(cointroller_) (DAIInterestRateModel.sol#1742)\n\tState variables written after the call(s):\n\t- accrualBlockNumber (DAIInterestRateModel.sol#1746)\n\t- borrowIndex (DAIInterestRateModel.sol#1747)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 2633,
          "vulnerability_to_line": 2648,
          "vulnerability_code": "    function liquidateBorrowInternal(address borrower, uint repayAmount, RTokenInterface rTokenCollateral) internal nonReentrant returns (uint, uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\n\n            return (fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED), 0);\n\n        }\n\n\n\n        error = rTokenCollateral.accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\n\n            return (fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED), 0);\n\n        }\n\n\n\n        // liquidateBorrowFresh emits borrow-specific logs on errors, so we don't need to\n\n        return liquidateBorrowFresh(msg.sender, borrower, repayAmount, rTokenCollateral);\n",
          "message": "Reentrancy in RToken.liquidateBorrowInternal (DAIInterestRateModel.sol#2633-2648):\n\tExternal calls:\n\t- error = accrueInterest() (DAIInterestRateModel.sol#2634)\n\t- error = rTokenCollateral.accrueInterest() (DAIInterestRateModel.sol#2640)\n\t- liquidateBorrowFresh(msg.sender,borrower,repayAmount,rTokenCollateral) (DAIInterestRateModel.sol#2647)\n\tState variables written after the call(s):\n\t- totalBorrows (DAIInterestRateModel.sol#2647)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 2317,
          "vulnerability_to_line": 2411,
          "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n\n\n\n        RedeemLocalVars memory vars;\n\n\n\n        /* exchangeRate = invoke Exchange Rate Stored() */\n\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* If redeemTokensIn > 0: */\n\n        if (redeemTokensIn > 0) {\n\n            /*\n\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\n\n             *  redeemTokens = redeemTokensIn\n\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n\n             */\n\n            vars.redeemTokens = redeemTokensIn;\n\n\n\n            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED, uint(vars.mathErr));\n\n            }\n\n        } else {\n\n            /*\n\n             * We get the current exchange rate and calculate the amount to be redeemed:\n\n             *  redeemTokens = redeemAmountIn / exchangeRate\n\n             *  redeemAmount = redeemAmountIn\n\n             */\n\n\n\n            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED, uint(vars.mathErr));\n\n            }\n\n\n\n            vars.redeemAmount = redeemAmountIn;\n\n        }\n\n\n\n        /* Fail if redeem not allowed */\n\n        uint allowed = cointroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COINTROLLER_REJECTION, FailureInfo.REDEEM_COINTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);\n\n        }\n\n\n\n        /*\n\n         * We calculate the new total supply and redeemer balance, checking for underflow:\n\n         *  totalSupplyNew = totalSupply - redeemTokens\n\n         *  accountTokensNew = accountTokens[redeemer] - redeemTokens\n\n         */\n\n        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* Fail gracefully if protocol has insufficient cash */\n\n        if (getCashPrior() < vars.redeemAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We invoke doTransferOut for the redeemer and the redeemAmount.\n\n         *  Note: The rToken must handle variations between BEP-20 and ETH underlying.\n\n         *  On success, the rToken has redeemAmount less of cash.\n\n         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n\n         */\n\n        doTransferOut(redeemer, vars.redeemAmount);\n\n\n\n        /* We write previously calculated values into storage */\n\n        totalSupply = vars.totalSupplyNew;\n\n        accountTokens[redeemer] = vars.accountTokensNew;\n\n\n\n        /* We emit a Transfer event, and a Redeem event */\n\n        emit Transfer(redeemer, address(this), vars.redeemTokens);\n\n        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        /* We call the defense hook */\n\n        cointroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        return uint(Error.NO_ERROR);\n",
          "message": "Reentrancy in RToken.redeemFresh (DAIInterestRateModel.sol#2317-2411):\n\tExternal calls:\n\t- allowed = cointroller.redeemAllowed(address(this),redeemer,vars.redeemTokens) (DAIInterestRateModel.sol#2357)\n\tState variables written after the call(s):\n\t- totalSupply (DAIInterestRateModel.sol#2400)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 2528,
          "vulnerability_to_line": 2536,
          "vulnerability_code": "    function repayBorrowBehalfInternal(address borrower, uint repayAmount) internal nonReentrant returns (uint, uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n\n            return (fail(Error(error), FailureInfo.REPAY_BEHALF_ACCRUE_INTEREST_FAILED), 0);\n\n        }\n\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n\n        return repayBorrowFresh(msg.sender, borrower, repayAmount);\n",
          "message": "Reentrancy in RToken.repayBorrowBehalfInternal (DAIInterestRateModel.sol#2528-2536):\n\tExternal calls:\n\t- error = accrueInterest() (DAIInterestRateModel.sol#2529)\n\t- repayBorrowFresh(msg.sender,borrower,repayAmount) (DAIInterestRateModel.sol#2535)\n\tState variables written after the call(s):\n\t- totalBorrows (DAIInterestRateModel.sol#2535)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 2512,
          "vulnerability_to_line": 2520,
          "vulnerability_code": "    function repayBorrowInternal(uint repayAmount) internal nonReentrant returns (uint, uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n\n            return (fail(Error(error), FailureInfo.REPAY_BORROW_ACCRUE_INTEREST_FAILED), 0);\n\n        }\n\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n\n        return repayBorrowFresh(msg.sender, msg.sender, repayAmount);\n",
          "message": "Reentrancy in RToken.repayBorrowInternal (DAIInterestRateModel.sol#2512-2520):\n\tExternal calls:\n\t- error = accrueInterest() (DAIInterestRateModel.sol#2513)\n\t- repayBorrowFresh(msg.sender,msg.sender,repayAmount) (DAIInterestRateModel.sol#2519)\n\tState variables written after the call(s):\n\t- totalBorrows (DAIInterestRateModel.sol#2519)\n"
        },
        {
          "name": "uninitialized-local",
          "vulnerability_from_line": 2458,
          "vulnerability_to_line": null,
          "vulnerability_code": "        BorrowLocalVars memory vars;\n",
          "message": "vars in RToken.borrowFresh (DAIInterestRateModel.sol#2458) is a local variable never initialiazed\n"
        },
        {
          "name": "uninitialized-local",
          "vulnerability_from_line": 2320,
          "vulnerability_to_line": null,
          "vulnerability_code": "        RedeemLocalVars memory vars;\n",
          "message": "vars in RToken.redeemFresh (DAIInterestRateModel.sol#2320) is a local variable never initialiazed\n"
        },
        {
          "name": "uninitialized-local",
          "vulnerability_from_line": 2568,
          "vulnerability_to_line": null,
          "vulnerability_code": "        RepayBorrowLocalVars memory vars;\n",
          "message": "vars in RToken.repayBorrowFresh (DAIInterestRateModel.sol#2568) is a local variable never initialiazed\n"
        },
        {
          "name": "uninitialized-local",
          "vulnerability_from_line": 2950,
          "vulnerability_to_line": 2952,
          "vulnerability_code": "        uint actualAddAmount;\n\n\n",
          "message": "actualAddAmount in RToken._addReservesFresh (DAIInterestRateModel.sol#2950-2952) is a local variable never initialiazed\n"
        },
        {
          "name": "uninitialized-local",
          "vulnerability_from_line": 2212,
          "vulnerability_to_line": null,
          "vulnerability_code": "        MintLocalVars memory vars;\n",
          "message": "vars in RToken.mintFresh (DAIInterestRateModel.sol#2212) is a local variable never initialiazed\n"
        },
        {
          "name": "unused-return",
          "vulnerability_from_line": 3159,
          "vulnerability_to_line": 3174,
          "vulnerability_code": "    function initialize(address underlying_,\n\n                        CointrollerInterface cointroller_,\n\n                        InterestRateModel interestRateModel_,\n\n                        uint initialExchangeRateMantissa_,\n\n                        string memory name_,\n\n                        string memory symbol_,\n\n                        uint8 decimals_) public {\n\n        // RToken initialize does the bulk of the work\n\n        super.initialize(cointroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_);\n\n\n\n        // Set underlying and sanity check it\n\n        underlying = underlying_;\n\n        EIP20Interface(underlying).totalSupply();\n\n    }\n\n\n",
          "message": "RBep20.initialize (DAIInterestRateModel.sol#3159-3174) does not use the value returned by external calls:\n\t-EIP20Interface(underlying).totalSupply() (DAIInterestRateModel.sol#3171-3172)\n"
        },
        {
          "name": "unused-return",
          "vulnerability_from_line": 3492,
          "vulnerability_to_line": 3500,
          "vulnerability_code": "    function accrueInterest() public returns (uint) {\n\n        // Accumulate DSR interest\n\n        PotLike(potAddress).drip();\n\n\n\n        // Accumulate RToken interest\n\n        return super.accrueInterest();\n\n    }\n\n\n",
          "message": "RDaiDelegate.accrueInterest (DAIInterestRateModel.sol#3492-3500) does not use the value returned by external calls:\n\t-PotLike(potAddress).drip() (DAIInterestRateModel.sol#3494-3496)\n"
        },
        {
          "name": "unused-return",
          "vulnerability_from_line": 3463,
          "vulnerability_to_line": 3485,
          "vulnerability_code": "    function _resignImplementation() public {\n\n        require(msg.sender == admin, \"only the admin may abandon the implementation\");\n\n\n\n        // Transfer all cash out of the DSR - note that this relies on self-transfer\n\n        DaiJoinLike daiJoin = DaiJoinLike(daiJoinAddress);\n\n        PotLike pot = PotLike(potAddress);\n\n        VatLike vat = VatLike(vatAddress);\n\n\n\n        // Accumulate interest\n\n        pot.drip();\n\n\n\n        // Calculate the total amount in the pot, and move it out\n\n        uint pie = pot.pie(address(this));\n\n        pot.exit(pie);\n\n\n\n        // Checks the actual balance of DAI in the vat after the pot exit\n\n        uint bal = vat.dai(address(this));\n\n\n\n        // Remove our whole balance\n\n        daiJoin.exit(address(this), bal / RAY);\n\n    }\n\n\n",
          "message": "RDaiDelegate._resignImplementation (DAIInterestRateModel.sol#3463-3485) does not use the value returned by external calls:\n\t-pot.drip() (DAIInterestRateModel.sol#3472-3474)\n"
        },
        {
          "name": "unused-return",
          "vulnerability_from_line": 3433,
          "vulnerability_to_line": 3460,
          "vulnerability_code": "    function _becomeImplementation(address daiJoinAddress_, address potAddress_) internal {\n\n        // Get dai and vat and sanity check the underlying\n\n        DaiJoinLike daiJoin = DaiJoinLike(daiJoinAddress_);\n\n        PotLike pot = PotLike(potAddress_);\n\n        GemLike dai = daiJoin.dai();\n\n        VatLike vat = daiJoin.vat();\n\n        require(address(dai) == underlying, \"DAI must be the same as underlying\");\n\n\n\n        // Remember the relevant addresses\n\n        daiJoinAddress = daiJoinAddress_;\n\n        potAddress = potAddress_;\n\n        vatAddress = address(vat);\n\n\n\n        // Approve moving our DAI into the vat through daiJoin\n\n        dai.approve(daiJoinAddress, uint(-1));\n\n\n\n        // Approve the pot to transfer our funds within the vat\n\n        vat.hope(potAddress);\n\n        vat.hope(daiJoinAddress);\n\n\n\n        // Accumulate DSR interest -- must do this in order to doTransferIn\n\n        pot.drip();\n\n\n\n        // Transfer all cash in (doTransferIn does this regardless of amount)\n\n        doTransferIn(address(this), 0);\n\n    }\n\n\n",
          "message": "RDaiDelegate._becomeImplementation (DAIInterestRateModel.sol#3433-3460) does not use the value returned by external calls:\n\t-pot.drip() (DAIInterestRateModel.sol#3454-3456)\n"
        },
        {
          "name": "shadowing-local",
          "vulnerability_from_line": 1578,
          "vulnerability_to_line": null,
          "vulnerability_code": "        (MathError err, Exp memory fraction) = divScalarByExp(scalar, divisor);\n",
          "message": "Exponential.divScalarByExpTruncate.fraction (local variable @ DAIInterestRateModel.sol#1578) shadows:\n\t- ExponentialNoError.fraction (function @ DAIInterestRateModel.sol#1450-1452)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 3433,
          "vulnerability_to_line": 3460,
          "vulnerability_code": "    function _becomeImplementation(address daiJoinAddress_, address potAddress_) internal {\n\n        // Get dai and vat and sanity check the underlying\n\n        DaiJoinLike daiJoin = DaiJoinLike(daiJoinAddress_);\n\n        PotLike pot = PotLike(potAddress_);\n\n        GemLike dai = daiJoin.dai();\n\n        VatLike vat = daiJoin.vat();\n\n        require(address(dai) == underlying, \"DAI must be the same as underlying\");\n\n\n\n        // Remember the relevant addresses\n\n        daiJoinAddress = daiJoinAddress_;\n\n        potAddress = potAddress_;\n\n        vatAddress = address(vat);\n\n\n\n        // Approve moving our DAI into the vat through daiJoin\n\n        dai.approve(daiJoinAddress, uint(-1));\n\n\n\n        // Approve the pot to transfer our funds within the vat\n\n        vat.hope(potAddress);\n\n        vat.hope(daiJoinAddress);\n\n\n\n        // Accumulate DSR interest -- must do this in order to doTransferIn\n\n        pot.drip();\n\n\n\n        // Transfer all cash in (doTransferIn does this regardless of amount)\n\n        doTransferIn(address(this), 0);\n\n    }\n\n\n",
          "message": "Reentrancy in RDaiDelegate._becomeImplementation (DAIInterestRateModel.sol#3433-3460):\n\tExternal calls:\n\t- dai = daiJoin.dai() (DAIInterestRateModel.sol#3437-3438)\n\t- vat = daiJoin.vat() (DAIInterestRateModel.sol#3438-3439)\n\tState variables written after the call(s):\n\t- daiJoinAddress (DAIInterestRateModel.sol#3442-3443)\n\t- potAddress (DAIInterestRateModel.sol#3443-3444)\n\t- vatAddress (DAIInterestRateModel.sol#3444-3446)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 2441,
          "vulnerability_to_line": 2505,
          "vulnerability_code": "    function borrowFresh(address payable borrower, uint borrowAmount) internal returns (uint) {\n\n        /* Fail if borrow not allowed */\n\n        uint allowed = cointroller.borrowAllowed(address(this), borrower, borrowAmount);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COINTROLLER_REJECTION, FailureInfo.BORROW_COINTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.BORROW_FRESHNESS_CHECK);\n\n        }\n\n\n\n        /* Fail gracefully if protocol has insufficient underlying cash */\n\n        if (getCashPrior() < borrowAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.BORROW_CASH_NOT_AVAILABLE);\n\n        }\n\n\n\n        BorrowLocalVars memory vars;\n\n\n\n        /*\n\n         * We calculate the new borrower and total borrow balances, failing on overflow:\n\n         *  accountBorrowsNew = accountBorrows + borrowAmount\n\n         *  totalBorrowsNew = totalBorrows + borrowAmount\n\n         */\n\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We invoke doTransferOut for the borrower and the borrowAmount.\n\n         *  Note: The rToken must handle variations between BEP-20 and ETH underlying.\n\n         *  On success, the rToken borrowAmount less of cash.\n\n         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n\n         */\n\n        doTransferOut(borrower, borrowAmount);\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n\n        accountBorrows[borrower].interestIndex = borrowIndex;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n\n\n        /* We emit a Borrow event */\n\n        emit Borrow(borrower, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n\n\n        /* We call the defense hook */\n\n        // unused function\n\n        // cointroller.borrowVerify(address(this), borrower, borrowAmount);\n\n\n\n        return uint(Error.NO_ERROR);\n",
          "message": "Reentrancy in RToken.borrowFresh (DAIInterestRateModel.sol#2441-2505):\n\tExternal calls:\n\t- allowed = cointroller.borrowAllowed(address(this),borrower,borrowAmount) (DAIInterestRateModel.sol#2443)\n\tState variables written after the call(s):\n\t- accountBorrows (DAIInterestRateModel.sol#2493)\n\t- accountBorrows (DAIInterestRateModel.sol#2494)\n\t- totalBorrows (DAIInterestRateModel.sol#2495)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 1728,
          "vulnerability_to_line": 1759,
          "vulnerability_code": "    function initialize(CointrollerInterface cointroller_,\n\n                        InterestRateModel interestRateModel_,\n\n                        uint initialExchangeRateMantissa_,\n\n                        string memory name_,\n\n                        string memory symbol_,\n\n                        uint8 decimals_) public {\n\n        require(msg.sender == admin, \"only admin may initialize the market\");\n\n        require(accrualBlockNumber == 0 && borrowIndex == 0, \"market may only be initialized once\");\n\n\n\n        // Set initial exchange rate\n\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n\n        require(initialExchangeRateMantissa > 0, \"initial exchange rate must be greater than zero.\");\n\n\n\n        // Set the cointroller\n\n        uint err = _setCointroller(cointroller_);\n\n        require(err == uint(Error.NO_ERROR), \"setting cointroller failed\");\n\n\n\n        // Initialize block number and borrow index (block number mocks depend on cointroller being set)\n\n        accrualBlockNumber = getBlockNumber();\n\n        borrowIndex = mantissaOne;\n\n\n\n        // Set the interest rate model (depends on block number / borrow index)\n\n        err = _setInterestRateModelFresh(interestRateModel_);\n\n        require(err == uint(Error.NO_ERROR), \"setting interest rate model failed\");\n\n\n\n        name = name_;\n\n        symbol = symbol_;\n\n        decimals = decimals_;\n\n\n\n        // The counter starts true to prevent changing it from zero to non-zero (i.e. smaller cost/refund)\n\n        _notEntered = true;\n",
          "message": "Reentrancy in RToken.initialize (DAIInterestRateModel.sol#1728-1759):\n\tExternal calls:\n\t- err = _setCointroller(cointroller_) (DAIInterestRateModel.sol#1742)\n\t- err = _setInterestRateModelFresh(interestRateModel_) (DAIInterestRateModel.sol#1750)\n\tState variables written after the call(s):\n\t- _notEntered (DAIInterestRateModel.sol#1758)\n\t- decimals (DAIInterestRateModel.sol#1755)\n\t- name (DAIInterestRateModel.sol#1753)\n\t- symbol (DAIInterestRateModel.sol#1754)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 3159,
          "vulnerability_to_line": 3174,
          "vulnerability_code": "    function initialize(address underlying_,\n\n                        CointrollerInterface cointroller_,\n\n                        InterestRateModel interestRateModel_,\n\n                        uint initialExchangeRateMantissa_,\n\n                        string memory name_,\n\n                        string memory symbol_,\n\n                        uint8 decimals_) public {\n\n        // RToken initialize does the bulk of the work\n\n        super.initialize(cointroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_);\n\n\n\n        // Set underlying and sanity check it\n\n        underlying = underlying_;\n\n        EIP20Interface(underlying).totalSupply();\n\n    }\n\n\n",
          "message": "Reentrancy in RBep20.initialize (DAIInterestRateModel.sol#3159-3174):\n\tExternal calls:\n\t- super.initialize(cointroller_,interestRateModel_,initialExchangeRateMantissa_,name_,symbol_,decimals_) (DAIInterestRateModel.sol#3167-3169)\n\tState variables written after the call(s):\n\t- underlying (DAIInterestRateModel.sol#3170-3171)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 2200,
          "vulnerability_to_line": 2265,
          "vulnerability_code": "    function mintFresh(address minter, uint mintAmount) internal returns (uint, uint) {\n\n        /* Fail if mint not allowed */\n\n        uint allowed = cointroller.mintAllowed(address(this), minter, mintAmount);\n\n        if (allowed != 0) {\n\n            return (failOpaque(Error.COINTROLLER_REJECTION, FailureInfo.MINT_COINTROLLER_REJECTION, allowed), 0);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return (fail(Error.MARKET_NOT_FRESH, FailureInfo.MINT_FRESHNESS_CHECK), 0);\n\n        }\n\n\n\n        MintLocalVars memory vars;\n\n\n\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return (failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr)), 0);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         *  We call `doTransferIn` for the minter and the mintAmount.\n\n         *  Note: The rToken must handle variations between BEP-20 and ETH underlying.\n\n         *  `doTransferIn` reverts if anything goes wrong, since we can't be sure if\n\n         *  side-effects occurred. The function returns the amount actually transferred,\n\n         *  in case of a fee. On success, the rToken holds an additional `actualMintAmount`\n\n         *  of cash.\n\n         */\n\n        vars.actualMintAmount = doTransferIn(minter, mintAmount);\n\n\n\n        /*\n\n         * We get the current exchange rate and calculate the number of rTokens to be minted:\n\n         *  mintTokens = actualMintAmount / exchangeRate\n\n         */\n\n\n\n        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(vars.actualMintAmount, Exp({mantissa: vars.exchangeRateMantissa}));\n\n        require(vars.mathErr == MathError.NO_ERROR, \"MINT_EXCHANGE_CALCULATION_FAILED\");\n\n\n\n        /*\n\n         * We calculate the new total supply of rTokens and minter token balance, checking for overflow:\n\n         *  totalSupplyNew = totalSupply + mintTokens\n\n         *  accountTokensNew = accountTokens[minter] + mintTokens\n\n         */\n\n        (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);\n\n        require(vars.mathErr == MathError.NO_ERROR, \"MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED\");\n\n\n\n        (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);\n\n        require(vars.mathErr == MathError.NO_ERROR, \"MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED\");\n\n\n\n        /* We write previously calculated values into storage */\n\n        totalSupply = vars.totalSupplyNew;\n\n        accountTokens[minter] = vars.accountTokensNew;\n\n\n\n        /* We emit a Mint event, and a Transfer event */\n\n        emit Mint(minter, vars.actualMintAmount, vars.mintTokens);\n\n        emit Transfer(address(this), minter, vars.mintTokens);\n\n\n\n        /* We call the defense hook */\n\n        // unused function\n\n        // cointroller.mintVerify(address(this), minter, vars.actualMintAmount, vars.mintTokens);\n\n\n\n        return (uint(Error.NO_ERROR), vars.actualMintAmount);\n",
          "message": "Reentrancy in RToken.mintFresh (DAIInterestRateModel.sol#2200-2265):\n\tExternal calls:\n\t- allowed = cointroller.mintAllowed(address(this),minter,mintAmount) (DAIInterestRateModel.sol#2202)\n\tState variables written after the call(s):\n\t- accountTokens (DAIInterestRateModel.sol#2254)\n\t- totalSupply (DAIInterestRateModel.sol#2253)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 3695,
          "vulnerability_to_line": 3714,
          "vulnerability_code": "    function poke() public {\n\n        (uint duty, ) = jug.ilks(\"ETH-A\");\n\n        uint stabilityFeePerBlock = duty.add(jug.base()).sub(1e27).mul(1e18).div(1e27).mul(15);\n\n\n\n        // We ensure the minimum borrow rate >= DSR / (1 - reserve factor)\n\n        baseRatePerBlock = dsrPerBlock().mul(1e18).div(assumedOneMinusReserveFactorMantissa);\n\n\n\n        // The roof borrow rate is max(base rate, stability fee) + gap, from which we derive the slope\n\n        if (baseRatePerBlock < stabilityFeePerBlock) {\n\n            multiplierPerBlock = stabilityFeePerBlock.sub(baseRatePerBlock).add(gapPerBlock).mul(1e18).div(kink);\n\n        } else {\n\n            multiplierPerBlock = gapPerBlock.mul(1e18).div(kink);\n\n        }\n\n\n\n        emit NewInterestParams(baseRatePerBlock, baseRatePerBlock.div(2), multiplierPerBlock, jumpMultiplierPerBlock, kink, 0);\n\n    }\n\n}\n\n\n\n\n",
          "message": "Reentrancy in DAIInterestRateModel.poke (DAIInterestRateModel.sol#3695-3714):\n\tExternal calls:\n\t- (duty) = jug.ilks(ETH-A) (DAIInterestRateModel.sol#3696-3697)\n\t- stabilityFeePerBlock = duty.add(jug.base()).sub(1e27).mul(1e18).div(1e27).mul(15) (DAIInterestRateModel.sol#3697-3699)\n\t- baseRatePerBlock = dsrPerBlock().mul(1e18).div(assumedOneMinusReserveFactorMantissa) (DAIInterestRateModel.sol#3700-3702)\n\tState variables written after the call(s):\n\t- baseRatePerBlock (DAIInterestRateModel.sol#3700-3702)\n\t- multiplierPerBlock (DAIInterestRateModel.sol#3704-3705)\n\t- multiplierPerBlock (DAIInterestRateModel.sol#3706-3707)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 2317,
          "vulnerability_to_line": 2411,
          "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n\n\n\n        RedeemLocalVars memory vars;\n\n\n\n        /* exchangeRate = invoke Exchange Rate Stored() */\n\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* If redeemTokensIn > 0: */\n\n        if (redeemTokensIn > 0) {\n\n            /*\n\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\n\n             *  redeemTokens = redeemTokensIn\n\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n\n             */\n\n            vars.redeemTokens = redeemTokensIn;\n\n\n\n            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED, uint(vars.mathErr));\n\n            }\n\n        } else {\n\n            /*\n\n             * We get the current exchange rate and calculate the amount to be redeemed:\n\n             *  redeemTokens = redeemAmountIn / exchangeRate\n\n             *  redeemAmount = redeemAmountIn\n\n             */\n\n\n\n            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED, uint(vars.mathErr));\n\n            }\n\n\n\n            vars.redeemAmount = redeemAmountIn;\n\n        }\n\n\n\n        /* Fail if redeem not allowed */\n\n        uint allowed = cointroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COINTROLLER_REJECTION, FailureInfo.REDEEM_COINTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);\n\n        }\n\n\n\n        /*\n\n         * We calculate the new total supply and redeemer balance, checking for underflow:\n\n         *  totalSupplyNew = totalSupply - redeemTokens\n\n         *  accountTokensNew = accountTokens[redeemer] - redeemTokens\n\n         */\n\n        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* Fail gracefully if protocol has insufficient cash */\n\n        if (getCashPrior() < vars.redeemAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We invoke doTransferOut for the redeemer and the redeemAmount.\n\n         *  Note: The rToken must handle variations between BEP-20 and ETH underlying.\n\n         *  On success, the rToken has redeemAmount less of cash.\n\n         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n\n         */\n\n        doTransferOut(redeemer, vars.redeemAmount);\n\n\n\n        /* We write previously calculated values into storage */\n\n        totalSupply = vars.totalSupplyNew;\n\n        accountTokens[redeemer] = vars.accountTokensNew;\n\n\n\n        /* We emit a Transfer event, and a Redeem event */\n\n        emit Transfer(redeemer, address(this), vars.redeemTokens);\n\n        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        /* We call the defense hook */\n\n        cointroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        return uint(Error.NO_ERROR);\n",
          "message": "Reentrancy in RToken.redeemFresh (DAIInterestRateModel.sol#2317-2411):\n\tExternal calls:\n\t- allowed = cointroller.redeemAllowed(address(this),redeemer,vars.redeemTokens) (DAIInterestRateModel.sol#2357)\n\tState variables written after the call(s):\n\t- accountTokens (DAIInterestRateModel.sol#2401)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 2556,
          "vulnerability_to_line": 2623,
          "vulnerability_code": "    function repayBorrowFresh(address payer, address borrower, uint repayAmount) internal returns (uint, uint) {\n\n        /* Fail if repayBorrow not allowed */\n\n        uint allowed = cointroller.repayBorrowAllowed(address(this), payer, borrower, repayAmount);\n\n        if (allowed != 0) {\n\n            return (failOpaque(Error.COINTROLLER_REJECTION, FailureInfo.REPAY_BORROW_COINTROLLER_REJECTION, allowed), 0);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return (fail(Error.MARKET_NOT_FRESH, FailureInfo.REPAY_BORROW_FRESHNESS_CHECK), 0);\n\n        }\n\n\n\n        RepayBorrowLocalVars memory vars;\n\n\n\n        /* We remember the original borrowerIndex for verification purposes */\n\n        vars.borrowerIndex = accountBorrows[borrower].interestIndex;\n\n\n\n        /* We fetch the amount the borrower owes, with accumulated interest */\n\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return (failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr)), 0);\n\n        }\n\n\n\n        /* If repayAmount == -1, repayAmount = accountBorrows */\n\n        if (repayAmount == uint(-1)) {\n\n            vars.repayAmount = vars.accountBorrows;\n\n        } else {\n\n            vars.repayAmount = repayAmount;\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We call doTransferIn for the payer and the repayAmount\n\n         *  Note: The rToken must handle variations between BEP-20 and ETH underlying.\n\n         *  On success, the rToken holds an additional repayAmount of cash.\n\n         *  doTransferIn reverts if anything goes wrong, since we can't be sure if side effects occurred.\n\n         *   it returns the amount actually transferred, in case of a fee.\n\n         */\n\n        vars.actualRepayAmount = doTransferIn(payer, vars.repayAmount);\n\n\n\n        /*\n\n         * We calculate the new borrower and total borrow balances, failing on underflow:\n\n         *  accountBorrowsNew = accountBorrows - actualRepayAmount\n\n         *  totalBorrowsNew = totalBorrows - actualRepayAmount\n\n         */\n\n        (vars.mathErr, vars.accountBorrowsNew) = subUInt(vars.accountBorrows, vars.actualRepayAmount);\n\n        require(vars.mathErr == MathError.NO_ERROR, \"REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED\");\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = subUInt(totalBorrows, vars.actualRepayAmount);\n\n        require(vars.mathErr == MathError.NO_ERROR, \"REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED\");\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n\n        accountBorrows[borrower].interestIndex = borrowIndex;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n\n\n        /* We emit a RepayBorrow event */\n\n        emit RepayBorrow(payer, borrower, vars.actualRepayAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n\n\n        /* We call the defense hook */\n\n        // unused function\n\n        // cointroller.repayBorrowVerify(address(this), payer, borrower, vars.actualRepayAmount, vars.borrowerIndex);\n\n\n\n        return (uint(Error.NO_ERROR), vars.actualRepayAmount);\n",
          "message": "Reentrancy in RToken.repayBorrowFresh (DAIInterestRateModel.sol#2556-2623):\n\tExternal calls:\n\t- allowed = cointroller.repayBorrowAllowed(address(this),payer,borrower,repayAmount) (DAIInterestRateModel.sol#2558)\n\tState variables written after the call(s):\n\t- accountBorrows (DAIInterestRateModel.sol#2611)\n\t- accountBorrows (DAIInterestRateModel.sol#2612)\n\t- totalBorrows (DAIInterestRateModel.sol#2613)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 2753,
          "vulnerability_to_line": 2800,
          "vulnerability_code": "    function seizeInternal(address seizerToken, address liquidator, address borrower, uint seizeTokens) internal returns (uint) {\n\n        /* Fail if seize not allowed */\n\n        uint allowed = cointroller.seizeAllowed(address(this), seizerToken, liquidator, borrower, seizeTokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COINTROLLER_REJECTION, FailureInfo.LIQUIDATE_SEIZE_COINTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Fail if borrower = liquidator */\n\n        if (borrower == liquidator) {\n\n            return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER);\n\n        }\n\n\n\n        MathError mathErr;\n\n        uint borrowerTokensNew;\n\n        uint liquidatorTokensNew;\n\n\n\n        /*\n\n         * We calculate the new borrower and liquidator token balances, failing on underflow/overflow:\n\n         *  borrowerTokensNew = accountTokens[borrower] - seizeTokens\n\n         *  liquidatorTokensNew = accountTokens[liquidator] + seizeTokens\n\n         */\n\n        (mathErr, borrowerTokensNew) = subUInt(accountTokens[borrower], seizeTokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED, uint(mathErr));\n\n        }\n\n\n\n        (mathErr, liquidatorTokensNew) = addUInt(accountTokens[liquidator], seizeTokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED, uint(mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accountTokens[borrower] = borrowerTokensNew;\n\n        accountTokens[liquidator] = liquidatorTokensNew;\n\n\n\n        /* Emit a Transfer event */\n\n        emit Transfer(borrower, liquidator, seizeTokens);\n\n\n\n        /* We call the defense hook */\n\n        // unused function\n\n        // cointroller.seizeVerify(address(this), seizerToken, liquidator, borrower, seizeTokens);\n\n\n\n        return uint(Error.NO_ERROR);\n",
          "message": "Reentrancy in RToken.seizeInternal (DAIInterestRateModel.sol#2753-2800):\n\tExternal calls:\n\t- allowed = cointroller.seizeAllowed(address(this),seizerToken,liquidator,borrower,seizeTokens) (DAIInterestRateModel.sol#2755)\n\tState variables written after the call(s):\n\t- accountTokens (DAIInterestRateModel.sol#2789)\n\t- accountTokens (DAIInterestRateModel.sol#2790)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 1770,
          "vulnerability_to_line": 1830,
          "vulnerability_code": "    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (uint) {\n\n        /* Fail if transfer not allowed */\n\n        uint allowed = cointroller.transferAllowed(address(this), src, dst, tokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COINTROLLER_REJECTION, FailureInfo.TRANSFER_COINTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Do not allow self-transfers */\n\n        if (src == dst) {\n\n            return fail(Error.BAD_INPUT, FailureInfo.TRANSFER_NOT_ALLOWED);\n\n        }\n\n\n\n        /* Get the allowance, infinite for the account owner */\n\n        uint startingAllowance = 0;\n\n        if (spender == src) {\n\n            startingAllowance = uint(-1);\n\n        } else {\n\n            startingAllowance = transferAllowances[src][spender];\n\n        }\n\n\n\n        /* Do the calculations, checking for {under,over}flow */\n\n        MathError mathErr;\n\n        uint allowanceNew;\n\n        uint srrTokensNew;\n\n        uint dstTokensNew;\n\n\n\n        (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ALLOWED);\n\n        }\n\n\n\n        (mathErr, srrTokensNew) = subUInt(accountTokens[src], tokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ENOUGH);\n\n        }\n\n\n\n        (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_TOO_MUCH);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        accountTokens[src] = srrTokensNew;\n\n        accountTokens[dst] = dstTokensNew;\n\n\n\n        /* Eat some of the allowance (if necessary) */\n\n        if (startingAllowance != uint(-1)) {\n\n            transferAllowances[src][spender] = allowanceNew;\n\n        }\n\n\n\n        /* We emit a Transfer event */\n\n        emit Transfer(src, dst, tokens);\n\n\n\n        // unused function\n\n        // cointroller.transferVerify(address(this), src, dst, tokens);\n\n\n\n        return uint(Error.NO_ERROR);\n",
          "message": "Reentrancy in RToken.transferTokens (DAIInterestRateModel.sol#1770-1830):\n\tExternal calls:\n\t- allowed = cointroller.transferAllowed(address(this),src,dst,tokens) (DAIInterestRateModel.sol#1772)\n\tState variables written after the call(s):\n\t- accountTokens (DAIInterestRateModel.sol#1815)\n\t- accountTokens (DAIInterestRateModel.sol#1816)\n\t- transferAllowances (DAIInterestRateModel.sol#1820)\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 3290,
          "vulnerability_to_line": 3317,
          "vulnerability_code": "    function doTransferIn(address from, uint amount) internal returns (uint) {\n\n        EIP20NonStandardInterface token = EIP20NonStandardInterface(underlying);\n\n        uint balanceBefore = EIP20Interface(underlying).balanceOf(address(this));\n\n        token.transferFrom(from, address(this), amount);\n\n\n\n        bool success;\n\n        assembly {\n\n            switch returndatasize()\n\n                case 0 {                       // This is a non-standard BEP-20\n\n                    success := not(0)          // set success to true\n\n                }\n\n                case 32 {                      // This is a compliant BEP-20\n\n                    returndatacopy(0, 0, 32)\n\n                    success := mload(0)        // Set `success = returndata` of external call\n\n                }\n\n                default {                      // This is an excessively non-compliant BEP-20, revert.\n\n                    revert(0, 0)\n\n                }\n\n        }\n\n        require(success, \"TOKEN_TRANSFER_IN_FAILED\");\n\n\n\n        // Calculate the amount that was *actually* transferred\n\n        uint balanceAfter = EIP20Interface(underlying).balanceOf(address(this));\n\n        require(balanceAfter >= balanceBefore, \"TOKEN_TRANSFER_IN_OVERFLOW\");\n\n        return balanceAfter - balanceBefore;   // underflow already checked above, just subtract\n\n    }\n\n\n",
          "message": "RBep20.doTransferIn uses assembly (DAIInterestRateModel.sol#3290-3317)\n\t- DAIInterestRateModel.sol#3296-3309\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 3326,
          "vulnerability_to_line": 3348,
          "vulnerability_code": "    function doTransferOut(address payable to, uint amount) internal {\n\n        EIP20NonStandardInterface token = EIP20NonStandardInterface(underlying);\n\n        token.transfer(to, amount);\n\n\n\n        bool success;\n\n        assembly {\n\n            switch returndatasize()\n\n                case 0 {                      // This is a non-standard BEP-20\n\n                    success := not(0)          // set success to true\n\n                }\n\n                case 32 {                     // This is a complaint BEP-20\n\n                    returndatacopy(0, 0, 32)\n\n                    success := mload(0)        // Set `success = returndata` of external call\n\n                }\n\n                default {                     // This is an excessively non-compliant BEP-20, revert.\n\n                    revert(0, 0)\n\n                }\n\n        }\n\n        require(success, \"TOKEN_TRANSFER_OUT_FAILED\");\n\n    }\n\n}\n\n\n",
          "message": "RBep20.doTransferOut uses assembly (DAIInterestRateModel.sol#3326-3348)\n\t- DAIInterestRateModel.sol#3331-3344\n"
        },
        {
          "name": "constable-states",
          "vulnerability_from_line": 3724,
          "vulnerability_to_line": 3725,
          "vulnerability_code": "   uint256 public base;\n",
          "message": "JugLike.base should be constant (DAIInterestRateModel.sol#3724-3725)\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 894,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint);\n",
          "message": "RTokenInterface._setInterestRateModel (DAIInterestRateModel.sol#894) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 3057,
          "vulnerability_to_line": 3067,
          "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n\n        return _setInterestRateModelFresh(newInterestRateModel);\n\n    }\n\n\n",
          "message": "RToken._setInterestRateModel (DAIInterestRateModel.sol#3057-3067) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 942,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setImplementation(address implementation_, bool allowResign, bytes memory becomeImplementationData) public;\n",
          "message": "RDelegatorInterface._setImplementation (DAIInterestRateModel.sol#942) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 3421,
          "vulnerability_to_line": 3428,
          "vulnerability_code": "    function _becomeImplementation(bytes memory data) public {\n\n        require(msg.sender == admin, \"only the admin may initialize the implementation\");\n\n\n\n        (address daiJoinAddress_, address potAddress_) = abi.decode(data, (address, address));\n\n        return _becomeImplementation(daiJoinAddress_, potAddress_);\n\n    }\n\n\n",
          "message": "RDaiDelegate._becomeImplementation (DAIInterestRateModel.sol#3421-3428) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 951,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _becomeImplementation(bytes memory data) public;\n",
          "message": "RDelegateInterface._becomeImplementation (DAIInterestRateModel.sol#951) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 3367,
          "vulnerability_to_line": 3379,
          "vulnerability_code": "    function _becomeImplementation(bytes memory data) public {\n\n        // Shh -- currently unused\n\n        data;\n\n\n\n        // Shh -- we don't ever want this hook to be marked pure\n\n        if (false) {\n\n            implementation = address(0);\n\n        }\n\n\n\n        require(msg.sender == admin, \"only the admin may call _becomeImplementation\");\n\n    }\n\n\n",
          "message": "RBep20Delegate._becomeImplementation (DAIInterestRateModel.sol#3367-3379) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 956,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _resignImplementation() public;\n",
          "message": "RDelegateInterface._resignImplementation (DAIInterestRateModel.sol#956) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 3382,
          "vulnerability_to_line": 3392,
          "vulnerability_code": "    function _resignImplementation() public {\n\n        // Shh -- we don't ever want this hook to be marked pure\n\n        if (false) {\n\n            implementation = address(0);\n\n        }\n\n\n\n        require(msg.sender == admin, \"only the admin may call _resignImplementation\");\n\n    }\n\n}\n\n\n",
          "message": "RBep20Delegate._resignImplementation (DAIInterestRateModel.sol#3382-3392) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 3463,
          "vulnerability_to_line": 3485,
          "vulnerability_code": "    function _resignImplementation() public {\n\n        require(msg.sender == admin, \"only the admin may abandon the implementation\");\n\n\n\n        // Transfer all cash out of the DSR - note that this relies on self-transfer\n\n        DaiJoinLike daiJoin = DaiJoinLike(daiJoinAddress);\n\n        PotLike pot = PotLike(potAddress);\n\n        VatLike vat = VatLike(vatAddress);\n\n\n\n        // Accumulate interest\n\n        pot.drip();\n\n\n\n        // Calculate the total amount in the pot, and move it out\n\n        uint pie = pot.pie(address(this));\n\n        pot.exit(pie);\n\n\n\n        // Checks the actual balance of DAI in the vat after the pot exit\n\n        uint bal = vat.dai(address(this));\n\n\n\n        // Remove our whole balance\n\n        daiJoin.exit(address(this), bal / RAY);\n\n    }\n\n\n",
          "message": "RDaiDelegate._resignImplementation (DAIInterestRateModel.sol#3463-3485) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 3159,
          "vulnerability_to_line": 3174,
          "vulnerability_code": "    function initialize(address underlying_,\n\n                        CointrollerInterface cointroller_,\n\n                        InterestRateModel interestRateModel_,\n\n                        uint initialExchangeRateMantissa_,\n\n                        string memory name_,\n\n                        string memory symbol_,\n\n                        uint8 decimals_) public {\n\n        // RToken initialize does the bulk of the work\n\n        super.initialize(cointroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_);\n\n\n\n        // Set underlying and sanity check it\n\n        underlying = underlying_;\n\n        EIP20Interface(underlying).totalSupply();\n\n    }\n\n\n",
          "message": "RBep20.initialize (DAIInterestRateModel.sol#3159-3174) should be declared external\n"
        },
        {
          "name": "solc-version",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": "Detected issues with version pragma in DAIInterestRateModel.sol:\n\t- pragma solidity^0.5.16 (DAIInterestRateModel.sol#3): it allows old versions\n\t- pragma solidity^0.5.16 (DAIInterestRateModel.sol#192): it allows old versions\n\t- pragma solidity^0.5.16 (DAIInterestRateModel.sol#428): it allows old versions\n\t- pragma solidity^0.5.16 (DAIInterestRateModel.sol#461): it allows old versions\n\t- pragma solidity^0.5.16 (DAIInterestRateModel.sol#509): it allows old versions\n\t- pragma solidity^0.5.16 (DAIInterestRateModel.sol#583): it allows old versions\n\t- pragma solidity^0.5.16 (DAIInterestRateModel.sol#656): it allows old versions\n\t- pragma solidity^0.5.16 (DAIInterestRateModel.sol#961): it allows old versions\n\t- pragma solidity^0.5.16 (DAIInterestRateModel.sol#1171): it allows old versions\n\t- pragma solidity^0.5.16 (DAIInterestRateModel.sol#1259): it allows old versions\n\t- pragma solidity^0.5.16 (DAIInterestRateModel.sol#1457): it allows old versions\n\t- pragma solidity^0.5.16 (DAIInterestRateModel.sol#1641): it allows old versions\n\t- pragma solidity^0.5.16 (DAIInterestRateModel.sol#1706): it allows old versions\n\t- pragma solidity^0.5.16 (DAIInterestRateModel.sol#3141-3144): it allows old versions\n\t- pragma solidity^0.5.16 (DAIInterestRateModel.sol#3350-3353): it allows old versions\n\t- pragma solidity^0.5.16 (DAIInterestRateModel.sol#3394-3397): it allows old versions\n\t- pragma solidity^0.5.16 (DAIInterestRateModel.sol#3605-3609): it allows old versions\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 219,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint256 public constant blocksPerYear = 2102400;\n",
          "message": "Constant 'BaseJumpRateModel.blocksPerYear' (DAIInterestRateModel.sol#219) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 436,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bool public constant isInterestRateModel = true;\n",
          "message": "Constant 'InterestRateModel.isInterestRateModel' (DAIInterestRateModel.sol#436) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 513,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bool public constant isCointroller = true;\n",
          "message": "Constant 'CointrollerInterface.isCointroller' (DAIInterestRateModel.sol#513) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 664,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bool internal _notEntered;\n",
          "message": "Variable 'RTokenStorage._notEntered' (DAIInterestRateModel.sol#664) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 685,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint internal constant borrowRateMaxMantissa = 0.0005e16;\n",
          "message": "Constant 'RTokenStorage.borrowRateMaxMantissa' (DAIInterestRateModel.sol#685) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 690,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint internal constant reserveFactorMaxMantissa = 1e18;\n",
          "message": "Constant 'RTokenStorage.reserveFactorMaxMantissa' (DAIInterestRateModel.sol#690) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 889,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint);\n",
          "message": "Function 'RTokenInterface._setPendingAdmin' (DAIInterestRateModel.sol#889) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 890,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _acceptAdmin() external returns (uint);\n",
          "message": "Function 'RTokenInterface._acceptAdmin' (DAIInterestRateModel.sol#890) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 891,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setCointroller(CointrollerInterface newCointroller) public returns (uint);\n",
          "message": "Function 'RTokenInterface._setCointroller' (DAIInterestRateModel.sol#891) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 892,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setReserveFactor(uint newReserveFactorMantissa) external returns (uint);\n",
          "message": "Function 'RTokenInterface._setReserveFactor' (DAIInterestRateModel.sol#892) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 893,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _reduceReserves(uint reduceAmount) external returns (uint);\n",
          "message": "Function 'RTokenInterface._reduceReserves' (DAIInterestRateModel.sol#893) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 894,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint);\n",
          "message": "Function 'RTokenInterface._setInterestRateModel' (DAIInterestRateModel.sol#894) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 777,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bool public constant isRToken = true;\n",
          "message": "Constant 'RTokenInterface.isRToken' (DAIInterestRateModel.sol#777) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 920,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _addReserves(uint addAmount) external returns (uint);\n",
          "message": "Function 'RBep20Interface._addReserves' (DAIInterestRateModel.sol#920) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 942,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setImplementation(address implementation_, bool allowResign, bytes memory becomeImplementationData) public;\n",
          "message": "Function 'RDelegatorInterface._setImplementation' (DAIInterestRateModel.sol#942) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 951,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _becomeImplementation(bytes memory data) public;\n",
          "message": "Function 'RDelegateInterface._becomeImplementation' (DAIInterestRateModel.sol#951) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 956,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _resignImplementation() public;\n",
          "message": "Function 'RDelegateInterface._resignImplementation' (DAIInterestRateModel.sol#956) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1294,
          "vulnerability_to_line": 1297,
          "vulnerability_code": "    function mul_ScalarTruncate(Exp memory a, uint scalar) pure internal returns (uint) {\n\n        Exp memory product = mul_(a, scalar);\n\n        return truncate(product);\n",
          "message": "Function 'ExponentialNoError.mul_ScalarTruncate' (DAIInterestRateModel.sol#1294-1297) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1302,
          "vulnerability_to_line": 1305,
          "vulnerability_code": "    function mul_ScalarTruncateAddUInt(Exp memory a, uint scalar, uint addend) pure internal returns (uint) {\n\n        Exp memory product = mul_(a, scalar);\n\n        return add_(truncate(product), addend);\n",
          "message": "Function 'ExponentialNoError.mul_ScalarTruncateAddUInt' (DAIInterestRateModel.sol#1302-1305) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1269,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint constant expScale = 1e18;\n",
          "message": "Constant 'ExponentialNoError.expScale' (DAIInterestRateModel.sol#1269) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1270,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint constant doubleScale = 1e36;\n",
          "message": "Constant 'ExponentialNoError.doubleScale' (DAIInterestRateModel.sol#1270) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1271,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint constant halfExpScale = expScale/2;\n",
          "message": "Constant 'ExponentialNoError.halfExpScale' (DAIInterestRateModel.sol#1271) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1272,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint constant mantissaOne = expScale;\n",
          "message": "Constant 'ExponentialNoError.mantissaOne' (DAIInterestRateModel.sol#1272) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 2811,
          "vulnerability_to_line": 2827,
          "vulnerability_code": "    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint) {\n\n        // Check caller = admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);\n\n        }\n\n\n\n        // Save current value, if any, for inclusion in log\n\n        address oldPendingAdmin = pendingAdmin;\n\n\n\n        // Store pendingAdmin with value newPendingAdmin\n\n        pendingAdmin = newPendingAdmin;\n\n\n\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\n\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n\n\n\n        return uint(Error.NO_ERROR);\n",
          "message": "Function 'RToken._setPendingAdmin' (DAIInterestRateModel.sol#2811-2827) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 2834,
          "vulnerability_to_line": 2856,
          "vulnerability_code": "    function _acceptAdmin() external returns (uint) {\n\n        // Check caller is pendingAdmin and pendingAdmin \u2260 address(0)\n\n        if (msg.sender != pendingAdmin || msg.sender == address(0)) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);\n\n        }\n\n\n\n        // Save current values for inclusion in log\n\n        address oldAdmin = admin;\n\n        address oldPendingAdmin = pendingAdmin;\n\n\n\n        // Store admin with value pendingAdmin\n\n        admin = pendingAdmin;\n\n\n\n        // Clear the pending value\n\n        pendingAdmin = address(0);\n\n\n\n        emit NewAdmin(oldAdmin, admin);\n\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Function 'RToken._acceptAdmin' (DAIInterestRateModel.sol#2834-2856) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 2861,
          "vulnerability_to_line": 2880,
          "vulnerability_code": "    function _setCointroller(CointrollerInterface newCointroller) public returns (uint) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COINTROLLER_OWNER_CHECK);\n\n        }\n\n\n\n        CointrollerInterface oldCointroller = cointroller;\n\n        // Ensure invoke cointroller.isCointroller() returns true\n\n        require(newCointroller.isCointroller(), \"marker method returned false\");\n\n\n\n        // Set market's cointroller to newCointroller\n\n        cointroller = newCointroller;\n\n\n\n        // Emit NewCointroller(oldCointroller, newCointroller)\n\n        emit NewCointroller(oldCointroller, newCointroller);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Function 'RToken._setCointroller' (DAIInterestRateModel.sol#2861-2880) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 2885,
          "vulnerability_to_line": 2895,
          "vulnerability_code": "    function _setReserveFactor(uint newReserveFactorMantissa) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.\n\n            return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.\n\n        return _setReserveFactorFresh(newReserveFactorMantissa);\n\n    }\n\n\n",
          "message": "Function 'RToken._setReserveFactor' (DAIInterestRateModel.sol#2885-2895) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 2992,
          "vulnerability_to_line": 3002,
          "vulnerability_code": "    function _reduceReserves(uint reduceAmount) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n\n            return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.\n\n        return _reduceReservesFresh(reduceAmount);\n\n    }\n\n\n",
          "message": "Function 'RToken._reduceReserves' (DAIInterestRateModel.sol#2992-3002) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 3057,
          "vulnerability_to_line": 3067,
          "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n\n        return _setInterestRateModelFresh(newInterestRateModel);\n\n    }\n\n\n",
          "message": "Function 'RToken._setInterestRateModel' (DAIInterestRateModel.sol#3057-3067) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 2900,
          "vulnerability_to_line": 2924,
          "vulnerability_code": "    function _setReserveFactorFresh(uint newReserveFactorMantissa) internal returns (uint) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_RESERVE_FACTOR_ADMIN_CHECK);\n\n        }\n\n\n\n        // Verify market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_RESERVE_FACTOR_FRESH_CHECK);\n\n        }\n\n\n\n        // Check newReserveFactor \u2264 maxReserveFactor\n\n        if (newReserveFactorMantissa > reserveFactorMaxMantissa) {\n\n            return fail(Error.BAD_INPUT, FailureInfo.SET_RESERVE_FACTOR_BOUNDS_CHECK);\n\n        }\n\n\n\n        uint oldReserveFactorMantissa = reserveFactorMantissa;\n\n        reserveFactorMantissa = newReserveFactorMantissa;\n\n\n\n        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Function 'RToken._setReserveFactorFresh' (DAIInterestRateModel.sol#2900-2924) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 2929,
          "vulnerability_to_line": 2941,
          "vulnerability_code": "    function _addReservesInternal(uint addAmount) internal nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n\n            return fail(Error(error), FailureInfo.ADD_RESERVES_ACCRUE_INTEREST_FAILED);\n\n        }\n\n\n\n        // _addReservesFresh emits reserve-addition-specific logs on errors, so we don't need to.\n\n        (error, ) = _addReservesFresh(addAmount);\n\n        return error;\n\n    }\n\n\n",
          "message": "Function 'RToken._addReservesInternal' (DAIInterestRateModel.sol#2929-2941) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 2947,
          "vulnerability_to_line": 2987,
          "vulnerability_code": "    function _addReservesFresh(uint addAmount) internal returns (uint, uint) {\n\n        // totalReserves + actualAddAmount\n\n        uint totalReservesNew;\n\n        uint actualAddAmount;\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return (fail(Error.MARKET_NOT_FRESH, FailureInfo.ADD_RESERVES_FRESH_CHECK), actualAddAmount);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We call doTransferIn for the caller and the addAmount\n\n         *  Note: The rToken must handle variations between BEP-20 and ETH underlying.\n\n         *  On success, the rToken holds an additional addAmount of cash.\n\n         *  doTransferIn reverts if anything goes wrong, since we can't be sure if side effects occurred.\n\n         *  it returns the amount actually transferred, in case of a fee.\n\n         */\n\n\n\n        actualAddAmount = doTransferIn(msg.sender, addAmount);\n\n\n\n        totalReservesNew = totalReserves + actualAddAmount;\n\n\n\n        /* Revert on overflow */\n\n        require(totalReservesNew >= totalReserves, \"add reserves unexpected overflow\");\n\n\n\n        // Store reserves[n+1] = reserves[n] + actualAddAmount\n\n        totalReserves = totalReservesNew;\n\n\n\n        /* Emit NewReserves(admin, actualAddAmount, reserves[n+1]) */\n\n        emit ReservesAdded(msg.sender, actualAddAmount, totalReservesNew);\n\n\n\n        /* Return (NO_ERROR, actualAddAmount) */\n\n        return (uint(Error.NO_ERROR), actualAddAmount);\n\n    }\n\n\n\n\n",
          "message": "Function 'RToken._addReservesFresh' (DAIInterestRateModel.sol#2947-2987) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 3008,
          "vulnerability_to_line": 3051,
          "vulnerability_code": "    function _reduceReservesFresh(uint reduceAmount) internal returns (uint) {\n\n        // totalReserves - reduceAmount\n\n        uint totalReservesNew;\n\n\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.REDUCE_RESERVES_ADMIN_CHECK);\n\n        }\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDUCE_RESERVES_FRESH_CHECK);\n\n        }\n\n\n\n        // Fail gracefully if protocol has insufficient underlying cash\n\n        if (getCashPrior() < reduceAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDUCE_RESERVES_CASH_NOT_AVAILABLE);\n\n        }\n\n\n\n        // Check reduceAmount \u2264 reserves[n] (totalReserves)\n\n        if (reduceAmount > totalReserves) {\n\n            return fail(Error.BAD_INPUT, FailureInfo.REDUCE_RESERVES_VALIDATION);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        totalReservesNew = totalReserves - reduceAmount;\n\n        // We checked reduceAmount <= totalReserves above, so this should never revert.\n\n        require(totalReservesNew <= totalReserves, \"reduce reserves unexpected underflow\");\n\n\n\n        // Store reserves[n+1] = reserves[n] - reduceAmount\n\n        totalReserves = totalReservesNew;\n\n\n\n        // doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n\n        doTransferOut(admin, reduceAmount);\n\n\n\n        emit ReservesReduced(admin, reduceAmount, totalReservesNew);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Function 'RToken._reduceReservesFresh' (DAIInterestRateModel.sol#3008-3051) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 3073,
          "vulnerability_to_line": 3103,
          "vulnerability_code": "    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {\n\n\n\n        // Used to store old model for use in the event that is emitted on success\n\n        InterestRateModel oldInterestRateModel;\n\n\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);\n\n        }\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);\n\n        }\n\n\n\n        // Track the market's current interest rate model\n\n        oldInterestRateModel = interestRateModel;\n\n\n\n        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true\n\n        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n\n\n\n        // Set the interest rate model to newInterestRateModel\n\n        interestRateModel = newInterestRateModel;\n\n\n\n        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)\n\n        emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Function 'RToken._setInterestRateModelFresh' (DAIInterestRateModel.sol#3073-3103) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 3265,
          "vulnerability_to_line": 3269,
          "vulnerability_code": "    function _addReserves(uint addAmount) external returns (uint) {\n\n        return _addReservesInternal(addAmount);\n\n    }\n\n\n",
          "message": "Function 'RBep20._addReserves' (DAIInterestRateModel.sol#3265-3269) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 3367,
          "vulnerability_to_line": 3379,
          "vulnerability_code": "    function _becomeImplementation(bytes memory data) public {\n\n        // Shh -- currently unused\n\n        data;\n\n\n\n        // Shh -- we don't ever want this hook to be marked pure\n\n        if (false) {\n\n            implementation = address(0);\n\n        }\n\n\n\n        require(msg.sender == admin, \"only the admin may call _becomeImplementation\");\n\n    }\n\n\n",
          "message": "Function 'RBep20Delegate._becomeImplementation' (DAIInterestRateModel.sol#3367-3379) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 3382,
          "vulnerability_to_line": 3392,
          "vulnerability_code": "    function _resignImplementation() public {\n\n        // Shh -- we don't ever want this hook to be marked pure\n\n        if (false) {\n\n            implementation = address(0);\n\n        }\n\n\n\n        require(msg.sender == admin, \"only the admin may call _resignImplementation\");\n\n    }\n\n}\n\n\n",
          "message": "Function 'RBep20Delegate._resignImplementation' (DAIInterestRateModel.sol#3382-3392) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 3421,
          "vulnerability_to_line": 3428,
          "vulnerability_code": "    function _becomeImplementation(bytes memory data) public {\n\n        require(msg.sender == admin, \"only the admin may initialize the implementation\");\n\n\n\n        (address daiJoinAddress_, address potAddress_) = abi.decode(data, (address, address));\n\n        return _becomeImplementation(daiJoinAddress_, potAddress_);\n\n    }\n\n\n",
          "message": "Function 'RDaiDelegate._becomeImplementation' (DAIInterestRateModel.sol#3421-3428) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 3463,
          "vulnerability_to_line": 3485,
          "vulnerability_code": "    function _resignImplementation() public {\n\n        require(msg.sender == admin, \"only the admin may abandon the implementation\");\n\n\n\n        // Transfer all cash out of the DSR - note that this relies on self-transfer\n\n        DaiJoinLike daiJoin = DaiJoinLike(daiJoinAddress);\n\n        PotLike pot = PotLike(potAddress);\n\n        VatLike vat = VatLike(vatAddress);\n\n\n\n        // Accumulate interest\n\n        pot.drip();\n\n\n\n        // Calculate the total amount in the pot, and move it out\n\n        uint pie = pot.pie(address(this));\n\n        pot.exit(pie);\n\n\n\n        // Checks the actual balance of DAI in the vat after the pot exit\n\n        uint bal = vat.dai(address(this));\n\n\n\n        // Remove our whole balance\n\n        daiJoin.exit(address(this), bal / RAY);\n\n    }\n\n\n",
          "message": "Function 'RDaiDelegate._resignImplementation' (DAIInterestRateModel.sol#3463-3485) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 3433,
          "vulnerability_to_line": 3460,
          "vulnerability_code": "    function _becomeImplementation(address daiJoinAddress_, address potAddress_) internal {\n\n        // Get dai and vat and sanity check the underlying\n\n        DaiJoinLike daiJoin = DaiJoinLike(daiJoinAddress_);\n\n        PotLike pot = PotLike(potAddress_);\n\n        GemLike dai = daiJoin.dai();\n\n        VatLike vat = daiJoin.vat();\n\n        require(address(dai) == underlying, \"DAI must be the same as underlying\");\n\n\n\n        // Remember the relevant addresses\n\n        daiJoinAddress = daiJoinAddress_;\n\n        potAddress = potAddress_;\n\n        vatAddress = address(vat);\n\n\n\n        // Approve moving our DAI into the vat through daiJoin\n\n        dai.approve(daiJoinAddress, uint(-1));\n\n\n\n        // Approve the pot to transfer our funds within the vat\n\n        vat.hope(potAddress);\n\n        vat.hope(daiJoinAddress);\n\n\n\n        // Accumulate DSR interest -- must do this in order to doTransferIn\n\n        pot.drip();\n\n\n\n        // Transfer all cash in (doTransferIn does this regardless of amount)\n\n        doTransferIn(address(this), 0);\n\n    }\n\n\n",
          "message": "Function 'RDaiDelegate._becomeImplementation' (DAIInterestRateModel.sol#3433-3460) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 3579,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function pie(address) external view returns (uint);\n",
          "message": "Parameter '' of PotLike.pie (DAIInterestRateModel.sol#3579) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 3581,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function join(uint) external;\n",
          "message": "Parameter '' of PotLike.join (DAIInterestRateModel.sol#3581) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 3582,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function exit(uint) external;\n",
          "message": "Parameter '' of PotLike.exit (DAIInterestRateModel.sol#3582) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 3586,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function approve(address, uint) external;\n",
          "message": "Parameter '' of GemLike.approve (DAIInterestRateModel.sol#3586) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 3586,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function approve(address, uint) external;\n",
          "message": "Parameter '_scope_0' of GemLike.approve (DAIInterestRateModel.sol#3586) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 3587,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function balanceOf(address) external view returns (uint);\n",
          "message": "Parameter '' of GemLike.balanceOf (DAIInterestRateModel.sol#3587) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 3588,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function transferFrom(address, address, uint) external returns (bool);\n",
          "message": "Parameter '' of GemLike.transferFrom (DAIInterestRateModel.sol#3588) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 3588,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function transferFrom(address, address, uint) external returns (bool);\n",
          "message": "Parameter '_scope_0' of GemLike.transferFrom (DAIInterestRateModel.sol#3588) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 3588,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function transferFrom(address, address, uint) external returns (bool);\n",
          "message": "Parameter '_scope_1' of GemLike.transferFrom (DAIInterestRateModel.sol#3588) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 3592,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function dai(address) external view returns (uint);\n",
          "message": "Parameter '' of VatLike.dai (DAIInterestRateModel.sol#3592) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 3593,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function hope(address) external;\n",
          "message": "Parameter '' of VatLike.hope (DAIInterestRateModel.sol#3593) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 3599,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function join(address, uint) external payable;\n",
          "message": "Parameter '' of DaiJoinLike.join (DAIInterestRateModel.sol#3599) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 3599,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function join(address, uint) external payable;\n",
          "message": "Parameter '_scope_0' of DaiJoinLike.join (DAIInterestRateModel.sol#3599) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 3600,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function exit(address, uint) external;\n",
          "message": "Parameter '' of DaiJoinLike.exit (DAIInterestRateModel.sol#3600) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 3600,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function exit(address, uint) external;\n",
          "message": "Parameter '_scope_0' of DaiJoinLike.exit (DAIInterestRateModel.sol#3600) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 3627,
          "vulnerability_to_line": 3629,
          "vulnerability_code": "    uint public constant assumedOneMinusReserveFactorMantissa = 0.95e18;\n\n\n",
          "message": "Constant 'DAIInterestRateModel.assumedOneMinusReserveFactorMantissa' (DAIInterestRateModel.sol#3627-3629) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        }
      ]
    },
    "smartcheck": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 3373,
          "vulnerability_to_line": null,
          "vulnerability_code": "            implementation = address(0);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 3385,
          "vulnerability_to_line": null,
          "vulnerability_code": "            implementation = address(0);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_DIV_MUL",
          "vulnerability_from_line": 3686,
          "vulnerability_to_line": null,
          "vulnerability_code": "        return pot\n",
          "message": null
        },
        {
          "name": "SOLIDITY_DIV_MUL",
          "vulnerability_from_line": 3697,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint stabilityFeePerBlock = duty.add(jug.base()).sub(1e27).mul(1e18).div(1e27).mul(15);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ERC20_APPROVE",
          "vulnerability_from_line": 1861,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function approve(address spender, uint256 amount) external returns (bool) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_LOCKED_MONEY",
          "vulnerability_from_line": 773,
          "vulnerability_to_line": null,
          "vulnerability_code": "contract RTokenInterface is RTokenStorage {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 192,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 428,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 461,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 509,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 583,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 656,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 961,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 1171,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 1259,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 1457,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 1641,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 1706,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 3141,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 3350,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 3394,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 3605,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SAFEMATH",
          "vulnerability_from_line": 200,
          "vulnerability_to_line": null,
          "vulnerability_code": "    using SafeMath for uint256;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SAFEMATH",
          "vulnerability_from_line": 3617,
          "vulnerability_to_line": null,
          "vulnerability_code": "    using SafeMath for uint;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 578,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint repayAmount) external view returns (uint, uint);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 874,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 1194,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function mulUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 1211,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function divUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 1222,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function subUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 1233,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function addUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 1246,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function addThenSubUInt(uint a, uint b, uint c) internal pure returns (MathError, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 1474,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getExp(uint num, uint denom) pure internal returns (MathError, Exp memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 1491,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function addExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 1500,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function subExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 1509,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function mulScalar(Exp memory a, uint scalar) pure internal returns (MathError, Exp memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 1521,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function mulScalarTruncate(Exp memory a, uint scalar) pure internal returns (MathError, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 1533,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function mulScalarTruncateAddUInt(Exp memory a, uint scalar, uint addend) pure internal returns (MathError, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 1545,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function divScalar(Exp memory a, uint scalar) pure internal returns (MathError, Exp memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 1557,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function divScalarByExp(uint scalar, Exp memory divisor) pure internal returns (MathError, Exp memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 1577,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function divScalarByExpTruncate(uint scalar, Exp memory divisor) pure internal returns (MathError, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 1589,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function mulExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 1614,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function mulExp(uint a, uint b) pure internal returns (MathError, Exp memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 1621,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function mulExp3(Exp memory a, Exp memory b, Exp memory c) pure internal returns (MathError, Exp memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 1634,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function divExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 1906,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 1985,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 2042,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function exchangeRateStoredInternal() internal view returns (MathError, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 2173,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function mintInternal(uint mintAmount) internal nonReentrant returns (uint, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 2200,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function mintFresh(address minter, uint mintAmount) internal returns (uint, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 3296,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 889,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 2317,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 3326,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function doTransferOut(address payable to, uint amount) internal {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 3548,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function doTransferOut(address payable to, uint amount) internal {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 889,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1269,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint constant expScale = 1e18;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1270,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint constant doubleScale = 1e36;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1271,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint constant halfExpScale = expScale/2;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1272,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint constant mantissaOne = expScale;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 2317,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 2317,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 2317,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 2317,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 2318,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 2320,
          "vulnerability_to_line": null,
          "vulnerability_code": "        RedeemLocalVars memory vars;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 2323,
          "vulnerability_to_line": null,
          "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 2323,
          "vulnerability_to_line": null,
          "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 2323,
          "vulnerability_to_line": null,
          "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 2323,
          "vulnerability_to_line": null,
          "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 2324,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (vars.mathErr != MathError.NO_ERROR) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 2324,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (vars.mathErr != MathError.NO_ERROR) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 2325,
          "vulnerability_to_line": null,
          "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 2325,
          "vulnerability_to_line": null,
          "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 2325,
          "vulnerability_to_line": null,
          "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 2325,
          "vulnerability_to_line": null,
          "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 2325,
          "vulnerability_to_line": null,
          "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 3326,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function doTransferOut(address payable to, uint amount) internal {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 3326,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function doTransferOut(address payable to, uint amount) internal {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 3327,
          "vulnerability_to_line": null,
          "vulnerability_code": "        EIP20NonStandardInterface token = EIP20NonStandardInterface(underlying);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 3328,
          "vulnerability_to_line": null,
          "vulnerability_code": "        token.transfer(to, amount);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 3328,
          "vulnerability_to_line": null,
          "vulnerability_code": "        token.transfer(to, amount);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 3330,
          "vulnerability_to_line": null,
          "vulnerability_code": "        bool success;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 3332,
          "vulnerability_to_line": null,
          "vulnerability_code": "            switch returndatasize()\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 3332,
          "vulnerability_to_line": null,
          "vulnerability_code": "            switch returndatasize()\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 3334,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    success := not(0)          // set success to true\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 3334,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    success := not(0)          // set success to true\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 3548,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function doTransferOut(address payable to, uint amount) internal {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 3548,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function doTransferOut(address payable to, uint amount) internal {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 3549,
          "vulnerability_to_line": null,
          "vulnerability_code": "        DaiJoinLike daiJoin = DaiJoinLike(daiJoinAddress);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 3550,
          "vulnerability_to_line": null,
          "vulnerability_code": "        PotLike pot = PotLike(potAddress);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 3554,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint pie = add(mul(amount, RAY) / pot.chi(), 1);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 3555,
          "vulnerability_to_line": null,
          "vulnerability_code": "        pot.exit(pie);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 3557,
          "vulnerability_to_line": null,
          "vulnerability_code": "        daiJoin.exit(to, amount);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 3557,
          "vulnerability_to_line": null,
          "vulnerability_code": "        daiJoin.exit(to, amount);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 3629,
          "vulnerability_to_line": null,
          "vulnerability_code": "    PotLike pot;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 3630,
          "vulnerability_to_line": null,
          "vulnerability_code": "    JugLike jug;\n",
          "message": null
        }
      ]
    },
    "oyente": {
      "successfull_analysis": false,
      "errors": [
        "exception (RuntimeError: Source map error, unknown name(SHR) or instr_name(INVALID))"
      ],
      "vulnerability_findings": []
    },
    "mythril": {
      "successfull_analysis": false,
      "errors": [
        "DOCKER_TIMEOUT"
      ],
      "vulnerability_findings": []
    },
    "osiris": {
      "successfull_analysis": false,
      "errors": [
        "Solidity compilation failed"
      ],
      "vulnerability_findings": []
    }
  }
}