{
  "smartbugs_completed": true,
  "analyzer_results": {
    "semgrep": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 2821,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (i = 0; i < bytes(message).length; i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 4162,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < assets.length; i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 4382,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < allMarkets.length; i ++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 4673,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < rTokens.length; i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 4679,
          "vulnerability_to_line": null,
          "vulnerability_code": "                for (uint j = 0; j < holders.length; j++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 4686,
          "vulnerability_to_line": null,
          "vulnerability_code": "                for (uint j = 0; j < holders.length; j++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 4824,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < allMarkets_.length; i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 4833,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < allMarkets_.length; i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 4843,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < allMarkets_.length; i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "inefficient-state-variable-increment",
          "vulnerability_from_line": 4790,
          "vulnerability_to_line": null,
          "vulnerability_code": "        blockNumber += blocks;\n",
          "message": "<x> += <y> costs more gas than <x> = <x> + <y> for state variables."
        },
        {
          "name": "inefficient-state-variable-increment",
          "vulnerability_from_line": 4899,
          "vulnerability_to_line": null,
          "vulnerability_code": "        blockNumber += blocks;\n",
          "message": "<x> += <y> costs more gas than <x> = <x> + <y> for state variables."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 2686,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor(CointrollerInterface cointroller_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 2687,
          "vulnerability_to_line": null,
          "vulnerability_code": "                InterestRateModel interestRateModel_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 2688,
          "vulnerability_to_line": null,
          "vulnerability_code": "                uint initialExchangeRateMantissa_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 2689,
          "vulnerability_to_line": null,
          "vulnerability_code": "                string memory name_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 2690,
          "vulnerability_to_line": null,
          "vulnerability_code": "                string memory symbol_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 2691,
          "vulnerability_to_line": null,
          "vulnerability_code": "                uint8 decimals_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 2692,
          "vulnerability_to_line": null,
          "vulnerability_code": "                address payable admin_) public {\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 2693,
          "vulnerability_to_line": null,
          "vulnerability_code": "        // Creator of the contract is admin during initialization\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 2694,
          "vulnerability_to_line": null,
          "vulnerability_code": "        admin = msg.sender;\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 2695,
          "vulnerability_to_line": null,
          "vulnerability_code": "\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 3015,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor() public {\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 3016,
          "vulnerability_to_line": null,
          "vulnerability_code": "        // Set admin to caller\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 3017,
          "vulnerability_to_line": null,
          "vulnerability_code": "        admin = msg.sender;\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 3018,
          "vulnerability_to_line": null,
          "vulnerability_code": "    }\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 3197,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor(address account) public {\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 3198,
          "vulnerability_to_line": null,
          "vulnerability_code": "        balances[account] = uint96(totalSupply);\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 3199,
          "vulnerability_to_line": null,
          "vulnerability_code": "        emit Transfer(address(0), account, totalSupply);\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 3200,
          "vulnerability_to_line": null,
          "vulnerability_code": "    }\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 3518,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor() public {\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 3519,
          "vulnerability_to_line": null,
          "vulnerability_code": "        admin = msg.sender;\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 3520,
          "vulnerability_to_line": null,
          "vulnerability_code": "    }\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 4787,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor() Cointroller() public {}\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 4862,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor(CointrollerInterface cointroller_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 4863,
          "vulnerability_to_line": null,
          "vulnerability_code": "                InterestRateModel interestRateModel_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 4864,
          "vulnerability_to_line": null,
          "vulnerability_code": "                uint initialExchangeRateMantissa,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 4865,
          "vulnerability_to_line": null,
          "vulnerability_code": "                string memory name_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 4866,
          "vulnerability_to_line": null,
          "vulnerability_code": "                string memory symbol_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 4867,
          "vulnerability_to_line": null,
          "vulnerability_code": "                uint8 decimals_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 4868,
          "vulnerability_to_line": null,
          "vulnerability_code": "                address payable admin_)\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 4869,
          "vulnerability_to_line": null,
          "vulnerability_code": "    RBinance(\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 4870,
          "vulnerability_to_line": null,
          "vulnerability_code": "    cointroller_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 4871,
          "vulnerability_to_line": null,
          "vulnerability_code": "    interestRateModel_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 5012,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor(string memory name_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 5013,
          "vulnerability_to_line": null,
          "vulnerability_code": "                string memory symbol_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 5014,
          "vulnerability_to_line": null,
          "vulnerability_code": "                uint8 decimals_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 5015,
          "vulnerability_to_line": null,
          "vulnerability_code": "                address payable admin_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 5016,
          "vulnerability_to_line": null,
          "vulnerability_code": "                CointrollerInterface cointroller_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 5017,
          "vulnerability_to_line": null,
          "vulnerability_code": "                InterestRateModel interestRateModel_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 5018,
          "vulnerability_to_line": null,
          "vulnerability_code": "                uint initialExchangeRateMantissa)\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 5019,
          "vulnerability_to_line": null,
          "vulnerability_code": "        RBinance(cointroller_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 5020,
          "vulnerability_to_line": null,
          "vulnerability_code": "               interestRateModel_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 5021,
          "vulnerability_to_line": null,
          "vulnerability_code": "               initialExchangeRateMantissa,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 3345,
          "vulnerability_to_line": null,
          "vulnerability_code": "            Checkpoint memory cp = checkpoints[account][center];\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 3559,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < len; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 3639,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < len; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 4162,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < assets.length; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 4382,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < allMarkets.length; i ++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 4403,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(uint i = 0; i < numMarkets; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 4673,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < rTokens.length; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 4679,
          "vulnerability_to_line": null,
          "vulnerability_code": "                for (uint j = 0; j < holders.length; j++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 4686,
          "vulnerability_to_line": null,
          "vulnerability_code": "                for (uint j = 0; j < holders.length; j++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 4824,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < allMarkets_.length; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 4833,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < allMarkets_.length; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 4843,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < allMarkets_.length; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1261,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == admin, \"only admin may initialize the market\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1262,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(accrualBlockNumber == 0 && borrowIndex == 0, \"market may only be initialized once\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1266,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(initialExchangeRateMantissa > 0, \"initial exchange rate must be greater than zero.\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1270,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(err == uint(Error.NO_ERROR), \"setting cointroller failed\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1278,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(err == uint(Error.NO_ERROR), \"setting interest rate model failed\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1423,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(mErr == MathError.NO_ERROR, \"balance could not be calculated\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1482,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1492,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1503,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(err == MathError.NO_ERROR, \"borrowBalanceStored: borrowBalanceStoredInternal failed\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1549,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1560,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(err == MathError.NO_ERROR, \"exchangeRateStored: exchangeRateStoredInternal failed\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1632,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1636,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(mathErr == MathError.NO_ERROR, \"could not calculate block delta\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1766,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(vars.mathErr == MathError.NO_ERROR, \"MINT_EXCHANGE_CALCULATION_FAILED\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1774,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(vars.mathErr == MathError.NO_ERROR, \"MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1777,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(vars.mathErr == MathError.NO_ERROR, \"MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1845,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 2132,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(vars.mathErr == MathError.NO_ERROR, \"REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 2135,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(vars.mathErr == MathError.NO_ERROR, \"REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 2231,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(amountSeizeError == uint(Error.NO_ERROR), \"LIQUIDATE_COINTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 2234,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(rTokenCollateral.balanceOf(borrower) >= seizeTokens, \"LIQUIDATE_SEIZE_TOO_MUCH\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 2245,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(seizeError == uint(Error.NO_ERROR), \"token seizure failed\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 2396,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(newCointroller.isCointroller(), \"marker method returned false\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 2501,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(totalReservesNew >= totalReserves, \"add reserves unexpected overflow\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 2565,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(totalReservesNew <= totalReserves, \"reduce reserves unexpected underflow\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 2619,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 2659,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_notEntered, \"re-entered\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 2803,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == from, \"sender mismatch\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 2804,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.value == amount, \"value mismatch\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 3300,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(signatory != address(0), \"Rifi::delegateBySig: invalid signature\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 3301,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(nonce == nonces[signatory]++, \"Rifi::delegateBySig: invalid nonce\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 3302,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(now <= expiry, \"Rifi::delegateBySig: signature expired\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 3324,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(blockNumber < block.number, \"Rifi::getPriorVotes: not yet determined\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 3368,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(src != address(0), \"Rifi::_transferTokens: cannot transfer from the zero address\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 3369,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(dst != address(0), \"Rifi::_transferTokens: cannot transfer to the zero address\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 3523,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(rifiAddress == address(0), \"RIFI address can only be set once\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 3611,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(oErr == 0, \"exitMarket: getAccountSnapshot failed\"); // semi-opaque error code\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 3670,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(!mintGuardianPaused[rToken], \"mint is paused\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 3763,
          "vulnerability_to_line": null,
          "vulnerability_code": "            revert(\"redeemTokens zero\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 3776,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(!borrowGuardianPaused[rToken], \"borrow is paused\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 3784,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(msg.sender == rToken, \"sender must be rToken\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 3806,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(nextTotalBorrows < borrowCap, \"market borrow cap reached\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 3983,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(!seizeGuardianPaused, \"seize is paused\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 4041,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(!transferGuardianPaused, \"transfer is paused\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 4279,
          "vulnerability_to_line": null,
          "vulnerability_code": "    \trequire(msg.sender == admin, \"only admin can set close factor\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 4383,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(allMarkets[i] != RToken(rToken), \"market already added\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 4396,
          "vulnerability_to_line": null,
          "vulnerability_code": "    \trequire(msg.sender == admin || msg.sender == borrowCapGuardian, \"only admin or borrow cap guardian can set borrow caps\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 4401,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(numMarkets != 0 && numMarkets == numBorrowCaps, \"invalid input\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 4414,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == admin, \"only admin can set borrow cap guardian\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 4449,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(markets[address(rToken)].isListed, \"cannot pause a market that is not listed\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 4450,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == pauseGuardian || msg.sender == admin, \"only pause guardian and admin can pause\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 4451,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == admin || state == true, \"only admin can unpause\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 4459,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(markets[address(rToken)].isListed, \"cannot pause a market that is not listed\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 4460,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == pauseGuardian || msg.sender == admin, \"only pause guardian and admin can pause\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 4461,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == admin || state == true, \"only admin can unpause\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 4469,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == pauseGuardian || msg.sender == admin, \"only pause guardian and admin can pause\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 4470,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == admin || state == true, \"only admin can unpause\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 4478,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == pauseGuardian || msg.sender == admin, \"only pause guardian and admin can pause\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 4479,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == admin || state == true, \"only admin can unpause\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 4487,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == unitroller.admin(), \"only unitroller admin can change brains\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 4488,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(unitroller._acceptImplementation() == 0, \"change not authorized\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 4515,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(market.isListed == true, \"rifi market is not listed\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 4675,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(markets[address(rToken)].isListed, \"market must be listed\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 4720,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(adminOrInitializing(), \"only admin can grant rifi\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 4722,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(amountLeft == 0, \"insufficient rifi for grant\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 4732,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(adminOrInitializing(), \"only admin can set rifi speed\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 4742,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(adminOrInitializing(), \"only admin can set rifi speed\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 4879,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(failTransferToAddresses[to] == false, \"TOKEN_TRANSFER_OUT_FAILED\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 1262,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(accrualBlockNumber == 0 && borrowIndex == 0, \"market may only be initialized once\");\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 4401,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(numMarkets != 0 && numMarkets == numBorrowCaps, \"invalid input\");\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 3267,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (spender != src && spenderAllowance != uint96(-1)) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 3268,
          "vulnerability_to_line": null,
          "vulnerability_code": "            uint96 newAllowance = sub96(spenderAllowance, amount, \"Rifi::transferFrom: transfer amount exceeds spender allowance\");\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 3269,
          "vulnerability_to_line": null,
          "vulnerability_code": "            allowances[src][spender] = newAllowance;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 3270,
          "vulnerability_to_line": null,
          "vulnerability_code": "\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 3271,
          "vulnerability_to_line": null,
          "vulnerability_code": "            emit Approval(src, spender, newAllowance);\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 3272,
          "vulnerability_to_line": null,
          "vulnerability_code": "        }\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 3379,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (srcRep != dstRep && amount > 0) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 3380,
          "vulnerability_to_line": null,
          "vulnerability_code": "            if (srcRep != address(0)) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 3381,
          "vulnerability_to_line": null,
          "vulnerability_code": "                uint32 srcRepNum = numCheckpoints[srcRep];\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 3382,
          "vulnerability_to_line": null,
          "vulnerability_code": "                uint96 srcRepOld = srcRepNum > 0 ? checkpoints[srcRep][srcRepNum - 1].votes : 0;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 3383,
          "vulnerability_to_line": null,
          "vulnerability_code": "                uint96 srcRepNew = sub96(srcRepOld, amount, \"Rifi::_moveVotes: vote amount underflows\");\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 3384,
          "vulnerability_to_line": null,
          "vulnerability_code": "                _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 3385,
          "vulnerability_to_line": null,
          "vulnerability_code": "            }\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 3386,
          "vulnerability_to_line": null,
          "vulnerability_code": "\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 3387,
          "vulnerability_to_line": null,
          "vulnerability_code": "            if (dstRep != address(0)) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 3388,
          "vulnerability_to_line": null,
          "vulnerability_code": "                uint32 dstRepNum = numCheckpoints[dstRep];\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 3399,
          "vulnerability_to_line": null,
          "vulnerability_code": "      if (nCheckpoints > 0 && checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 3400,
          "vulnerability_to_line": null,
          "vulnerability_code": "          checkpoints[delegatee][nCheckpoints - 1].votes = newVotes;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 3401,
          "vulnerability_to_line": null,
          "vulnerability_code": "      } else {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 3402,
          "vulnerability_to_line": null,
          "vulnerability_code": "          checkpoints[delegatee][nCheckpoints] = Checkpoint(blockNumber, newVotes);\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 3403,
          "vulnerability_to_line": null,
          "vulnerability_code": "          numCheckpoints[delegatee] = nCheckpoints + 1;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 3404,
          "vulnerability_to_line": null,
          "vulnerability_code": "      }\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 3762,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (redeemTokens == 0 && redeemAmount > 0) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 3763,
          "vulnerability_to_line": null,
          "vulnerability_code": "            revert(\"redeemTokens zero\");\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 3764,
          "vulnerability_to_line": null,
          "vulnerability_code": "        }\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4316,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (newCollateralFactorMantissa != 0 && oracle.getUnderlyingPrice(rToken) == 0) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4317,
          "vulnerability_to_line": null,
          "vulnerability_code": "            return fail(Error.PRICE_ERROR, FailureInfo.SET_COLLATERAL_FACTOR_WITHOUT_PRICE);\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4318,
          "vulnerability_to_line": null,
          "vulnerability_code": "        }\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4517,
          "vulnerability_to_line": null,
          "vulnerability_code": "            if (rifiSupplyState[address(rToken)].index == 0 && rifiSupplyState[address(rToken)].block == 0) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4518,
          "vulnerability_to_line": null,
          "vulnerability_code": "                rifiSupplyState[address(rToken)] = RifiMarketState({\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4519,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    index: rifiInitialIndex,\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4520,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    block: safe32(getBlockNumber(), \"block number exceeds 32 bits\")\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4521,
          "vulnerability_to_line": null,
          "vulnerability_code": "                });\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4522,
          "vulnerability_to_line": null,
          "vulnerability_code": "            }\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4524,
          "vulnerability_to_line": null,
          "vulnerability_code": "            if (rifiBorrowState[address(rToken)].index == 0 && rifiBorrowState[address(rToken)].block == 0) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4525,
          "vulnerability_to_line": null,
          "vulnerability_code": "                rifiBorrowState[address(rToken)] = RifiMarketState({\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4526,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    index: rifiInitialIndex,\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4527,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    block: safe32(getBlockNumber(), \"block number exceeds 32 bits\")\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4528,
          "vulnerability_to_line": null,
          "vulnerability_code": "                });\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4529,
          "vulnerability_to_line": null,
          "vulnerability_code": "            }\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4547,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (deltaBlocks > 0 && supplySpeed > 0) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4548,
          "vulnerability_to_line": null,
          "vulnerability_code": "            uint supplyTokens = RToken(rToken).totalSupply();\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4549,
          "vulnerability_to_line": null,
          "vulnerability_code": "            uint rifiAccrued = mul_(deltaBlocks, supplySpeed);\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4550,
          "vulnerability_to_line": null,
          "vulnerability_code": "            Double memory ratio = supplyTokens > 0 ? fraction(rifiAccrued, supplyTokens) : Double({mantissa: 0});\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4551,
          "vulnerability_to_line": null,
          "vulnerability_code": "            Double memory index = add_(Double({mantissa: supplyState.index}), ratio);\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4552,
          "vulnerability_to_line": null,
          "vulnerability_code": "            rifiSupplyState[rToken] = RifiMarketState({\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4553,
          "vulnerability_to_line": null,
          "vulnerability_code": "                index: safe224(index.mantissa, \"new index exceeds 224 bits\"),\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4554,
          "vulnerability_to_line": null,
          "vulnerability_code": "                block: safe32(blockNumber, \"block number exceeds 32 bits\")\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4555,
          "vulnerability_to_line": null,
          "vulnerability_code": "            });\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4556,
          "vulnerability_to_line": null,
          "vulnerability_code": "        } else if (deltaBlocks > 0) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4570,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (deltaBlocks > 0 && borrowSpeed > 0) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4571,
          "vulnerability_to_line": null,
          "vulnerability_code": "            uint borrowAmount = div_(RToken(rToken).totalBorrows(), marketBorrowIndex);\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4572,
          "vulnerability_to_line": null,
          "vulnerability_code": "            uint rifiAccrued = mul_(deltaBlocks, borrowSpeed);\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4573,
          "vulnerability_to_line": null,
          "vulnerability_code": "            Double memory ratio = borrowAmount > 0 ? fraction(rifiAccrued, borrowAmount) : Double({mantissa: 0});\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4574,
          "vulnerability_to_line": null,
          "vulnerability_code": "            Double memory index = add_(Double({mantissa: borrowState.index}), ratio);\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4575,
          "vulnerability_to_line": null,
          "vulnerability_code": "            rifiBorrowState[rToken] = RifiMarketState({\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4576,
          "vulnerability_to_line": null,
          "vulnerability_code": "                index: safe224(index.mantissa, \"new index exceeds 224 bits\"),\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4577,
          "vulnerability_to_line": null,
          "vulnerability_code": "                block: safe32(blockNumber, \"block number exceeds 32 bits\")\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4578,
          "vulnerability_to_line": null,
          "vulnerability_code": "            });\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4579,
          "vulnerability_to_line": null,
          "vulnerability_code": "        } else if (deltaBlocks > 0) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4595,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (supplierIndex.mantissa == 0 && supplyIndex.mantissa > 0) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4596,
          "vulnerability_to_line": null,
          "vulnerability_code": "            supplierIndex.mantissa = rifiInitialIndex;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4597,
          "vulnerability_to_line": null,
          "vulnerability_code": "        }\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4637,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (deltaBlocks > 0 && rifiSpeed > 0) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4638,
          "vulnerability_to_line": null,
          "vulnerability_code": "            uint newAccrued = mul_(deltaBlocks, rifiSpeed);\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4639,
          "vulnerability_to_line": null,
          "vulnerability_code": "            uint contributorAccrued = add_(rifiAccrued[contributor], newAccrued);\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4640,
          "vulnerability_to_line": null,
          "vulnerability_code": "\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4641,
          "vulnerability_to_line": null,
          "vulnerability_code": "            rifiAccrued[contributor] = contributorAccrued;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4642,
          "vulnerability_to_line": null,
          "vulnerability_code": "            lastContributorBlock[contributor] = blockNumber;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4643,
          "vulnerability_to_line": null,
          "vulnerability_code": "        }\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4704,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (amount > 0 && amount <= rifiRemaining) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4705,
          "vulnerability_to_line": null,
          "vulnerability_code": "            rifi.transfer(user, amount);\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4706,
          "vulnerability_to_line": null,
          "vulnerability_code": "            return 0;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4707,
          "vulnerability_to_line": null,
          "vulnerability_code": "        }\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-prefix-decrement-not-postfix",
          "vulnerability_from_line": 3652,
          "vulnerability_to_line": null,
          "vulnerability_code": "        storedList.length--;\n",
          "message": "Consider using the prefix decrement expression whenever the return value is not needed. The prefix decrement expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 2821,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (i = 0; i < bytes(message).length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 3301,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(nonce == nonces[signatory]++, \"Rifi::delegateBySig: invalid nonce\");\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 3559,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < len; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 3639,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < len; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 4162,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < assets.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 4382,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < allMarkets.length; i ++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 4403,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(uint i = 0; i < numMarkets; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 4673,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < rTokens.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 4679,
          "vulnerability_to_line": null,
          "vulnerability_code": "                for (uint j = 0; j < holders.length; j++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 4686,
          "vulnerability_to_line": null,
          "vulnerability_code": "                for (uint j = 0; j < holders.length; j++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 4824,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < allMarkets_.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 4833,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < allMarkets_.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 4843,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < allMarkets_.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 1261,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == admin, \"only admin may initialize the market\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 1262,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(accrualBlockNumber == 0 && borrowIndex == 0, \"market may only be initialized once\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 1266,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(initialExchangeRateMantissa > 0, \"initial exchange rate must be greater than zero.\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 1278,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(err == uint(Error.NO_ERROR), \"setting interest rate model failed\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 1503,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(err == MathError.NO_ERROR, \"borrowBalanceStored: borrowBalanceStoredInternal failed\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 1560,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(err == MathError.NO_ERROR, \"exchangeRateStored: exchangeRateStoredInternal failed\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 1774,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(vars.mathErr == MathError.NO_ERROR, \"MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 1777,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(vars.mathErr == MathError.NO_ERROR, \"MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 1845,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 2132,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(vars.mathErr == MathError.NO_ERROR, \"REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 2135,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(vars.mathErr == MathError.NO_ERROR, \"REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 2231,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(amountSeizeError == uint(Error.NO_ERROR), \"LIQUIDATE_COINTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 2565,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(totalReservesNew <= totalReserves, \"reduce reserves unexpected underflow\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 3300,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(signatory != address(0), \"Rifi::delegateBySig: invalid signature\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 3301,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(nonce == nonces[signatory]++, \"Rifi::delegateBySig: invalid nonce\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 3302,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(now <= expiry, \"Rifi::delegateBySig: signature expired\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 3324,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(blockNumber < block.number, \"Rifi::getPriorVotes: not yet determined\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 3368,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(src != address(0), \"Rifi::_transferTokens: cannot transfer from the zero address\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 3369,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(dst != address(0), \"Rifi::_transferTokens: cannot transfer to the zero address\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 3523,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(rifiAddress == address(0), \"RIFI address can only be set once\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 3611,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(oErr == 0, \"exitMarket: getAccountSnapshot failed\"); // semi-opaque error code\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 4396,
          "vulnerability_to_line": null,
          "vulnerability_code": "    \trequire(msg.sender == admin || msg.sender == borrowCapGuardian, \"only admin or borrow cap guardian can set borrow caps\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 4414,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == admin, \"only admin can set borrow cap guardian\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 4449,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(markets[address(rToken)].isListed, \"cannot pause a market that is not listed\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 4450,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == pauseGuardian || msg.sender == admin, \"only pause guardian and admin can pause\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 4459,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(markets[address(rToken)].isListed, \"cannot pause a market that is not listed\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 4460,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == pauseGuardian || msg.sender == admin, \"only pause guardian and admin can pause\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 4469,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == pauseGuardian || msg.sender == admin, \"only pause guardian and admin can pause\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 4478,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == pauseGuardian || msg.sender == admin, \"only pause guardian and admin can pause\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 4487,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == unitroller.admin(), \"only unitroller admin can change brains\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "compound-borrowfresh-reentrancy",
          "vulnerability_from_line": 2017,
          "vulnerability_to_line": null,
          "vulnerability_code": "        doTransferOut(borrower, borrowAmount);\n",
          "message": "Function borrowFresh() in Compound performs state update after doTransferOut()"
        }
      ]
    },
    "slither": {
      "successfull_analysis": true,
      "errors": [
        "EXIT_CODE_200"
      ],
      "vulnerability_findings": [
        {
          "name": "controlled-delegatecall",
          "vulnerability_from_line": 3118,
          "vulnerability_to_line": 3133,
          "vulnerability_code": "    function () payable external {\n\n        // delegate all other functions to current implementation\n\n        (bool success, ) = cointrollerImplementation.delegatecall(msg.data);\n\n\n\n        assembly {\n\n              let free_mem_ptr := mload(0x40)\n\n              returndatacopy(free_mem_ptr, 0, returndatasize)\n\n\n\n              switch success\n\n              case 0 { revert(free_mem_ptr, returndatasize) }\n\n              default { return(free_mem_ptr, returndatasize) }\n\n        }\n\n    }\n\n}\n\n\n",
          "message": "Unitroller.fallback (RBinanceHarness.sol#3118-3133) uses delegatecall to a input-controlled function id\n\t(success) = cointrollerImplementation.delegatecall(msg.data) (RBinanceHarness.sol#3120-3122)\n"
        },
        {
          "name": "shadowing-state",
          "vulnerability_from_line": 4785,
          "vulnerability_to_line": 4787,
          "vulnerability_code": "    address public rifiAddress;\n\n\n",
          "message": "CointrollerScenario.rifiAddress (RBinanceHarness.sol#4785-4787) shadows:\n\t- Cointroller.rifiAddress (RBinanceHarness.sol#3504-3506)\n"
        },
        {
          "name": "uninitialized-state",
          "vulnerability_from_line": 2871,
          "vulnerability_to_line": 2873,
          "vulnerability_code": "    address public cointrollerImplementation;\n\n\n",
          "message": "UnitrollerAdminStorage.cointrollerImplementation (RBinanceHarness.sol#2871-2873) is never initialized. It is used in:\n\t- adminOrInitializing (RBinanceHarness.sol#4494-4498)\n"
        },
        {
          "name": "uninitialized-state",
          "vulnerability_from_line": 2950,
          "vulnerability_to_line": 2952,
          "vulnerability_code": "    uint256 public rifiRate;\n\n\n",
          "message": "CointrollerStorage.rifiRate (RBinanceHarness.sol#2950-2952) is never initialized. It is used in:\n\t- refreshRifiSpeeds (RBinanceHarness.sol#4821-4851)\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 3430,
          "vulnerability_to_line": 3437,
          "vulnerability_code": "    function getChainId() internal pure returns (uint) {\n\n        uint256 chainId;\n\n        assembly { chainId := chainid() }\n\n        return chainId;\n\n    }\n\n}\n\n\n",
          "message": "Rifi.getChainId (RBinanceHarness.sol#3430-3437) is declared view but contains assembly code\n"
        },
        {
          "name": "erc20-interface",
          "vulnerability_from_line": 117,
          "vulnerability_to_line": 179,
          "vulnerability_code": "interface EIP20NonStandardInterface {\n\n\n\n    /**\n\n     * @notice Get the total number of tokens in circulation\n\n     * @return The supply of tokens\n\n     */\n\n    function totalSupply() external view returns (uint256);\n\n\n\n    /**\n\n     * @notice Gets the balance of the specified address\n\n     * @param owner The address from which the balance will be retrieved\n\n     * @return The balance\n\n     */\n\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n\n\n    ///\n\n    /// !!!!!!!!!!!!!!\n\n    /// !!! NOTICE !!! `transfer` does not return a value, in violation of the BEP-20 specification\n\n    /// !!!!!!!!!!!!!!\n\n    ///\n\n\n\n    /**\n\n      * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n\n      * @param dst The address of the destination account\n\n      * @param amount The number of tokens to transfer\n\n      */\n\n    function transfer(address dst, uint256 amount) external;\n\n\n\n    ///\n\n    /// !!!!!!!!!!!!!!\n\n    /// !!! NOTICE !!! `transferFrom` does not return a value, in violation of the BEP-20 specification\n\n    /// !!!!!!!!!!!!!!\n\n    ///\n\n\n\n    /**\n\n      * @notice Transfer `amount` tokens from `src` to `dst`\n\n      * @param src The address of the source account\n\n      * @param dst The address of the destination account\n\n      * @param amount The number of tokens to transfer\n\n      */\n\n    function transferFrom(address src, address dst, uint256 amount) external;\n\n\n\n    /**\n\n      * @notice Approve `spender` to transfer up to `amount` from `src`\n\n      * @dev This will overwrite the approval amount for `spender`\n\n      *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n\n      * @param spender The address of the account which may transfer tokens\n\n      * @param amount The number of tokens that are approved\n\n      * @return Whether or not the approval succeeded\n\n      */\n\n    function approve(address spender, uint256 amount) external returns (bool success);\n\n\n\n    /**\n\n      * @notice Get the current allowance from `owner` for `spender`\n\n      * @param owner The address of the account which owns the tokens to be spent\n\n      * @param spender The address of the account which may transfer tokens\n\n      * @return The number of tokens allowed to be spent\n\n      */\n\n    function allowance(address owner, address spender) external view returns (uint256 remaining);\n\n\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n",
          "message": "EIP20NonStandardInterface (RBinanceHarness.sol#117-179) has incorrect ERC20 function interface(s):\n\t-transfer (RBinanceHarness.sol#143)\n\t-transferFrom (RBinanceHarness.sol#157)\n"
        },
        {
          "name": "incorrect-equality",
          "vulnerability_from_line": 3396,
          "vulnerability_to_line": 3409,
          "vulnerability_code": "    function _writeCheckpoint(address delegatee, uint32 nCheckpoints, uint96 oldVotes, uint96 newVotes) internal {\n\n      uint32 blockNumber = safe32(block.number, \"Rifi::_writeCheckpoint: block number exceeds 32 bits\");\n\n\n\n      if (nCheckpoints > 0 && checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber) {\n\n          checkpoints[delegatee][nCheckpoints - 1].votes = newVotes;\n\n      } else {\n\n          checkpoints[delegatee][nCheckpoints] = Checkpoint(blockNumber, newVotes);\n\n          numCheckpoints[delegatee] = nCheckpoints + 1;\n\n      }\n\n\n\n      emit DelegateVotesChanged(delegatee, oldVotes, newVotes);\n\n    }\n\n\n",
          "message": "Rifi._writeCheckpoint (RBinanceHarness.sol#3396-3409) uses a dangerous strict equality:\n\t- nCheckpoints > 0 && checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber\n"
        },
        {
          "name": "incorrect-equality",
          "vulnerability_from_line": 2789,
          "vulnerability_to_line": 2795,
          "vulnerability_code": "    function getCashPrior() internal view returns (uint) {\n\n        (MathError err, uint startingBalance) = subUInt(address(this).balance, msg.value);\n\n        require(err == MathError.NO_ERROR);\n\n        return startingBalance;\n\n    }\n\n\n",
          "message": "RBinance.getCashPrior (RBinanceHarness.sol#2789-2795) uses a dangerous strict equality:\n\t- require(bool)(err == MathError.NO_ERROR)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 2456,
          "vulnerability_to_line": 2468,
          "vulnerability_code": "    function _addReservesInternal(uint addAmount) internal nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n\n            return fail(Error(error), FailureInfo.ADD_RESERVES_ACCRUE_INTEREST_FAILED);\n\n        }\n\n\n\n        // _addReservesFresh emits reserve-addition-specific logs on errors, so we don't need to.\n\n        (error, ) = _addReservesFresh(addAmount);\n\n        return error;\n\n    }\n\n\n",
          "message": "Reentrancy in RToken._addReservesInternal (RBinanceHarness.sol#2456-2468):\n\tExternal calls:\n\t- error = accrueInterest() (RBinanceHarness.sol#2457-2458)\n\tState variables written after the call(s):\n\t- totalReserves (RBinanceHarness.sol#2464-2465)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 2519,
          "vulnerability_to_line": 2529,
          "vulnerability_code": "    function _reduceReserves(uint reduceAmount) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n\n            return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.\n\n        return _reduceReservesFresh(reduceAmount);\n\n    }\n\n\n",
          "message": "Reentrancy in RToken._reduceReserves (RBinanceHarness.sol#2519-2529):\n\tExternal calls:\n\t- error = accrueInterest() (RBinanceHarness.sol#2520-2521)\n\tState variables written after the call(s):\n\t- totalReserves (RBinanceHarness.sol#2526-2527)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 2388,
          "vulnerability_to_line": 2407,
          "vulnerability_code": "    function _setCointroller(CointrollerInterface newCointroller) public returns (uint) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COINTROLLER_OWNER_CHECK);\n\n        }\n\n\n\n        CointrollerInterface oldCointroller = cointroller;\n\n        // Ensure invoke cointroller.isCointroller() returns true\n\n        require(newCointroller.isCointroller(), \"marker method returned false\");\n\n\n\n        // Set market's cointroller to newCointroller\n\n        cointroller = newCointroller;\n\n\n\n        // Emit NewCointroller(oldCointroller, newCointroller)\n\n        emit NewCointroller(oldCointroller, newCointroller);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Reentrancy in RToken._setCointroller (RBinanceHarness.sol#2388-2407):\n\tExternal calls:\n\t- require(bool,string)(newCointroller.isCointroller(),marker method returned false) (RBinanceHarness.sol#2396-2397)\n\tState variables written after the call(s):\n\t- cointroller (RBinanceHarness.sol#2399-2400)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 2584,
          "vulnerability_to_line": 2594,
          "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n\n        return _setInterestRateModelFresh(newInterestRateModel);\n\n    }\n\n\n",
          "message": "Reentrancy in RToken._setInterestRateModel (RBinanceHarness.sol#2584-2594):\n\tExternal calls:\n\t- error = accrueInterest() (RBinanceHarness.sol#2585-2586)\n\t- _setInterestRateModelFresh(newInterestRateModel) (RBinanceHarness.sol#2591-2592)\n\tState variables written after the call(s):\n\t- interestRateModel (RBinanceHarness.sol#2591-2592)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 2600,
          "vulnerability_to_line": 2630,
          "vulnerability_code": "    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {\n\n\n\n        // Used to store old model for use in the event that is emitted on success\n\n        InterestRateModel oldInterestRateModel;\n\n\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);\n\n        }\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);\n\n        }\n\n\n\n        // Track the market's current interest rate model\n\n        oldInterestRateModel = interestRateModel;\n\n\n\n        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true\n\n        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n\n\n\n        // Set the interest rate model to newInterestRateModel\n\n        interestRateModel = newInterestRateModel;\n\n\n\n        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)\n\n        emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Reentrancy in RToken._setInterestRateModelFresh (RBinanceHarness.sol#2600-2630):\n\tExternal calls:\n\t- require(bool,string)(newInterestRateModel.isInterestRateModel(),marker method returned false) (RBinanceHarness.sol#2619-2621)\n\tState variables written after the call(s):\n\t- interestRateModel (RBinanceHarness.sol#2622-2624)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 2412,
          "vulnerability_to_line": 2422,
          "vulnerability_code": "    function _setReserveFactor(uint newReserveFactorMantissa) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.\n\n            return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.\n\n        return _setReserveFactorFresh(newReserveFactorMantissa);\n\n    }\n\n\n",
          "message": "Reentrancy in RToken._setReserveFactor (RBinanceHarness.sol#2412-2422):\n\tExternal calls:\n\t- error = accrueInterest() (RBinanceHarness.sol#2413-2414)\n\tState variables written after the call(s):\n\t- reserveFactorMantissa (RBinanceHarness.sol#2419-2420)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 4360,
          "vulnerability_to_line": 4381,
          "vulnerability_code": "    function _supportMarket(RToken rToken) external returns (uint) {\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SUPPORT_MARKET_OWNER_CHECK);\n\n        }\n\n\n\n        if (markets[address(rToken)].isListed) {\n\n            return fail(Error.MARKET_ALREADY_LISTED, FailureInfo.SUPPORT_MARKET_EXISTS);\n\n        }\n\n\n\n        rToken.isRToken(); // Sanity check to make sure its really a RToken\n\n\n\n        // Note that isRified is not in active use anymore\n\n        markets[address(rToken)] = Market({isListed: true, isRified: false, collateralFactorMantissa: 0});\n\n\n\n        _addMarketInternal(address(rToken));\n\n\n\n        emit MarketListed(rToken);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Reentrancy in Cointroller._supportMarket (RBinanceHarness.sol#4360-4381):\n\tExternal calls:\n\t- rToken.isRToken() (RBinanceHarness.sol#4369)\n\tState variables written after the call(s):\n\t- markets (RBinanceHarness.sol#4372-4374)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 1614,
          "vulnerability_to_line": 1692,
          "vulnerability_code": "    function accrueInterest() public returns (uint) {\n\n        /* Remember the initial block number */\n\n        uint currentBlockNumber = getBlockNumber();\n\n        uint accrualBlockNumberPrior = accrualBlockNumber;\n\n\n\n        /* Short-circuit accumulating 0 interest */\n\n        if (accrualBlockNumberPrior == currentBlockNumber) {\n\n            return uint(Error.NO_ERROR);\n\n        }\n\n\n\n        /* Read the previous values out of storage */\n\n        uint cashPrior = getCashPrior();\n\n        uint borrowsPrior = totalBorrows;\n\n        uint reservesPrior = totalReserves;\n\n        uint borrowIndexPrior = borrowIndex;\n\n\n\n        /* Calculate the current borrow interest rate */\n\n        uint borrowRateMantissa = interestRateModel.getBorrowRate(cashPrior, borrowsPrior, reservesPrior);\n\n        require(borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n\n\n\n        /* Calculate the number of blocks elapsed since the last accrual */\n\n        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);\n\n        require(mathErr == MathError.NO_ERROR, \"could not calculate block delta\");\n\n\n\n        /*\n\n         * Calculate the interest accumulated into borrows and reserves and the new index:\n\n         *  simpleInterestFactor = borrowRate * blockDelta\n\n         *  interestAccumulated = simpleInterestFactor * totalBorrows\n\n         *  totalBorrowsNew = interestAccumulated + totalBorrows\n\n         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves\n\n         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\n\n         */\n\n\n\n        Exp memory simpleInterestFactor;\n\n        uint interestAccumulated;\n\n        uint totalBorrowsNew;\n\n        uint totalReservesNew;\n\n        uint borrowIndexNew;\n\n\n\n        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa: borrowRateMantissa}), blockDelta);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED, uint(mathErr));\n\n        }\n\n\n\n        (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED, uint(mathErr));\n\n        }\n\n\n\n        (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED, uint(mathErr));\n\n        }\n\n\n\n        (mathErr, totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa: reserveFactorMantissa}), interestAccumulated, reservesPrior);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED, uint(mathErr));\n\n        }\n\n\n\n        (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndexPrior, borrowIndexPrior);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED, uint(mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accrualBlockNumber = currentBlockNumber;\n\n        borrowIndex = borrowIndexNew;\n\n        totalBorrows = totalBorrowsNew;\n\n        totalReserves = totalReservesNew;\n\n\n\n        /* We emit an AccrueInterest event */\n\n        emit AccrueInterest(cashPrior, interestAccumulated, borrowIndexNew, totalBorrowsNew);\n\n\n\n        return uint(Error.NO_ERROR);\n",
          "message": "Reentrancy in RToken.accrueInterest (RBinanceHarness.sol#1614-1692):\n\tExternal calls:\n\t- borrowRateMantissa = interestRateModel.getBorrowRate(cashPrior,borrowsPrior,reservesPrior) (RBinanceHarness.sol#1631)\n\tState variables written after the call(s):\n\t- accrualBlockNumber (RBinanceHarness.sol#1683)\n\t- borrowIndex (RBinanceHarness.sol#1684)\n\t- totalBorrows (RBinanceHarness.sol#1685)\n\t- totalReserves (RBinanceHarness.sol#1686)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 1945,
          "vulnerability_to_line": 1953,
          "vulnerability_code": "    function borrowInternal(uint borrowAmount) internal nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n\n            return fail(Error(error), FailureInfo.BORROW_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // borrowFresh emits borrow-specific logs on errors, so we don't need to\n\n        return borrowFresh(msg.sender, borrowAmount);\n",
          "message": "Reentrancy in RToken.borrowInternal (RBinanceHarness.sol#1945-1953):\n\tExternal calls:\n\t- error = accrueInterest() (RBinanceHarness.sol#1946)\n\t- borrowFresh(msg.sender,borrowAmount) (RBinanceHarness.sol#1952)\n\tState variables written after the call(s):\n\t- totalBorrows (RBinanceHarness.sol#1952)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 4672,
          "vulnerability_to_line": 4695,
          "vulnerability_code": "    function claimRifi(address[] memory holders, RToken[] memory rTokens, bool borrowers, bool suppliers) public {\n\n        for (uint i = 0; i < rTokens.length; i++) {\n\n            RToken rToken = rTokens[i];\n\n            require(markets[address(rToken)].isListed, \"market must be listed\");\n\n            if (borrowers == true) {\n\n                Exp memory borrowIndex = Exp({mantissa: rToken.borrowIndex()});\n\n                updateRifiBorrowIndex(address(rToken), borrowIndex);\n\n                for (uint j = 0; j < holders.length; j++) {\n\n                    distributeBorrowerRifi(address(rToken), holders[j], borrowIndex);\n\n                    rifiAccrued[holders[j]] = grantRifiInternal(holders[j], rifiAccrued[holders[j]]);\n\n                }\n\n            }\n\n            if (suppliers == true) {\n\n                updateRifiSupplyIndex(address(rToken));\n\n                for (uint j = 0; j < holders.length; j++) {\n\n                    distributeSupplierRifi(address(rToken), holders[j]);\n\n                    rifiAccrued[holders[j]] = grantRifiInternal(holders[j], rifiAccrued[holders[j]]);\n\n                }\n\n            }\n\n        }\n\n    }\n\n\n\n    /**\n",
          "message": "Reentrancy in Cointroller.claimRifi (RBinanceHarness.sol#4672-4695):\n\tExternal calls:\n\t- borrowIndex = Exp(rToken.borrowIndex()) (RBinanceHarness.sol#4677-4678)\n\t- updateRifiBorrowIndex(address(rToken),borrowIndex) (RBinanceHarness.sol#4678-4679)\n\t- distributeBorrowerRifi(address(rToken),holders[j],borrowIndex) (RBinanceHarness.sol#4680-4681)\n\t- rifiAccrued[holders[j]] = grantRifiInternal(holders[j],rifiAccrued[holders[j]]) (RBinanceHarness.sol#4681-4682)\n\tState variables written after the call(s):\n\t- rifiAccrued (RBinanceHarness.sol#4681-4682)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 4672,
          "vulnerability_to_line": 4695,
          "vulnerability_code": "    function claimRifi(address[] memory holders, RToken[] memory rTokens, bool borrowers, bool suppliers) public {\n\n        for (uint i = 0; i < rTokens.length; i++) {\n\n            RToken rToken = rTokens[i];\n\n            require(markets[address(rToken)].isListed, \"market must be listed\");\n\n            if (borrowers == true) {\n\n                Exp memory borrowIndex = Exp({mantissa: rToken.borrowIndex()});\n\n                updateRifiBorrowIndex(address(rToken), borrowIndex);\n\n                for (uint j = 0; j < holders.length; j++) {\n\n                    distributeBorrowerRifi(address(rToken), holders[j], borrowIndex);\n\n                    rifiAccrued[holders[j]] = grantRifiInternal(holders[j], rifiAccrued[holders[j]]);\n\n                }\n\n            }\n\n            if (suppliers == true) {\n\n                updateRifiSupplyIndex(address(rToken));\n\n                for (uint j = 0; j < holders.length; j++) {\n\n                    distributeSupplierRifi(address(rToken), holders[j]);\n\n                    rifiAccrued[holders[j]] = grantRifiInternal(holders[j], rifiAccrued[holders[j]]);\n\n                }\n\n            }\n\n        }\n\n    }\n\n\n\n    /**\n",
          "message": "Reentrancy in Cointroller.claimRifi (RBinanceHarness.sol#4672-4695):\n\tExternal calls:\n\t- borrowIndex = Exp(rToken.borrowIndex()) (RBinanceHarness.sol#4677-4678)\n\t- updateRifiBorrowIndex(address(rToken),borrowIndex) (RBinanceHarness.sol#4678-4679)\n\t- updateRifiSupplyIndex(address(rToken)) (RBinanceHarness.sol#4685-4686)\n\t- distributeSupplierRifi(address(rToken),holders[j_scope_0]) (RBinanceHarness.sol#4687-4688)\n\t- rifiAccrued[holders[j_scope_0]] = grantRifiInternal(holders[j_scope_0],rifiAccrued[holders[j_scope_0]]) (RBinanceHarness.sol#4688-4689)\n\tState variables written after the call(s):\n\t- rifiAccrued (RBinanceHarness.sol#4688-4689)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 2686,
          "vulnerability_to_line": 2703,
          "vulnerability_code": "    constructor(CointrollerInterface cointroller_,\n\n                InterestRateModel interestRateModel_,\n\n                uint initialExchangeRateMantissa_,\n\n                string memory name_,\n\n                string memory symbol_,\n\n                uint8 decimals_,\n\n                address payable admin_) public {\n\n        // Creator of the contract is admin during initialization\n\n        admin = msg.sender;\n\n\n\n        initialize(cointroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_);\n\n\n\n        // Set the proper admin now that initialization is done\n\n        admin = admin_;\n\n    }\n\n\n\n\n",
          "message": "Reentrancy in RBinance.constructor (RBinanceHarness.sol#2686-2703):\n\tExternal calls:\n\t- initialize(cointroller_,interestRateModel_,initialExchangeRateMantissa_,name_,symbol_,decimals_) (RBinanceHarness.sol#2696-2698)\n\tState variables written after the call(s):\n\t- admin (RBinanceHarness.sol#2699-2700)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 3607,
          "vulnerability_to_line": 3659,
          "vulnerability_code": "    function exitMarket(address rTokenAddress) external returns (uint) {\n\n        RToken rToken = RToken(rTokenAddress);\n\n        /* Get sender tokensHeld and amountOwed underlying from the rToken */\n\n        (uint oErr, uint tokensHeld, uint amountOwed, ) = rToken.getAccountSnapshot(msg.sender);\n\n        require(oErr == 0, \"exitMarket: getAccountSnapshot failed\"); // semi-opaque error code\n\n\n\n        /* Fail if the sender has a borrow balance */\n\n        if (amountOwed != 0) {\n\n            return fail(Error.NONZERO_BORROW_BALANCE, FailureInfo.EXIT_MARKET_BALANCE_OWED);\n\n        }\n\n\n\n        /* Fail if the sender is not permitted to redeem all of their tokens */\n\n        uint allowed = redeemAllowedInternal(rTokenAddress, msg.sender, tokensHeld);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.REJECTION, FailureInfo.EXIT_MARKET_REJECTION, allowed);\n\n        }\n\n\n\n        Market storage marketToExit = markets[address(rToken)];\n\n\n\n        /* Return true if the sender is not already \u2018in\u2019 the market */\n\n        if (!marketToExit.accountMembership[msg.sender]) {\n\n            return uint(Error.NO_ERROR);\n\n        }\n\n\n\n        /* Set rToken account membership to false */\n\n        delete marketToExit.accountMembership[msg.sender];\n\n\n\n        /* Delete rToken from the account\u2019s list of assets */\n\n        // load into memory for faster iteration\n\n        RToken[] memory userAssetList = accountAssets[msg.sender];\n\n        uint len = userAssetList.length;\n\n        uint assetIndex = len;\n\n        for (uint i = 0; i < len; i++) {\n\n            if (userAssetList[i] == rToken) {\n\n                assetIndex = i;\n\n                break;\n\n            }\n\n        }\n\n\n\n        // We *must* have found the asset in the list or our redundant data structure is broken\n\n        assert(assetIndex < len);\n\n\n\n        // copy last item in list to location of item to be removed, reduce length by 1\n\n        RToken[] storage storedList = accountAssets[msg.sender];\n\n        storedList[assetIndex] = storedList[storedList.length - 1];\n\n        storedList.length--;\n\n\n\n        emit MarketExited(rToken, msg.sender);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Reentrancy in Cointroller.exitMarket (RBinanceHarness.sol#3607-3659):\n\tExternal calls:\n\t- (oErr,tokensHeld,amountOwed) = rToken.getAccountSnapshot(msg.sender) (RBinanceHarness.sol#3610-3611)\n\t- allowed = redeemAllowedInternal(rTokenAddress,msg.sender,tokensHeld) (RBinanceHarness.sol#3619-3620)\n\tState variables written after the call(s):\n\t- accountAssets (RBinanceHarness.sol#3651-3652)\n\t- accountAssets (RBinanceHarness.sol#3652-3654)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 1255,
          "vulnerability_to_line": 1286,
          "vulnerability_code": "    function initialize(CointrollerInterface cointroller_,\n\n                        InterestRateModel interestRateModel_,\n\n                        uint initialExchangeRateMantissa_,\n\n                        string memory name_,\n\n                        string memory symbol_,\n\n                        uint8 decimals_) public {\n\n        require(msg.sender == admin, \"only admin may initialize the market\");\n\n        require(accrualBlockNumber == 0 && borrowIndex == 0, \"market may only be initialized once\");\n\n\n\n        // Set initial exchange rate\n\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n\n        require(initialExchangeRateMantissa > 0, \"initial exchange rate must be greater than zero.\");\n\n\n\n        // Set the cointroller\n\n        uint err = _setCointroller(cointroller_);\n\n        require(err == uint(Error.NO_ERROR), \"setting cointroller failed\");\n\n\n\n        // Initialize block number and borrow index (block number mocks depend on cointroller being set)\n\n        accrualBlockNumber = getBlockNumber();\n\n        borrowIndex = mantissaOne;\n\n\n\n        // Set the interest rate model (depends on block number / borrow index)\n\n        err = _setInterestRateModelFresh(interestRateModel_);\n\n        require(err == uint(Error.NO_ERROR), \"setting interest rate model failed\");\n\n\n\n        name = name_;\n\n        symbol = symbol_;\n\n        decimals = decimals_;\n\n\n\n        // The counter starts true to prevent changing it from zero to non-zero (i.e. smaller cost/refund)\n\n        _notEntered = true;\n",
          "message": "Reentrancy in RToken.initialize (RBinanceHarness.sol#1255-1286):\n\tExternal calls:\n\t- err = _setCointroller(cointroller_) (RBinanceHarness.sol#1269)\n\tState variables written after the call(s):\n\t- accrualBlockNumber (RBinanceHarness.sol#1273)\n\t- borrowIndex (RBinanceHarness.sol#1274)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 2160,
          "vulnerability_to_line": 2175,
          "vulnerability_code": "    function liquidateBorrowInternal(address borrower, uint repayAmount, RTokenInterface rTokenCollateral) internal nonReentrant returns (uint, uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\n\n            return (fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED), 0);\n\n        }\n\n\n\n        error = rTokenCollateral.accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\n\n            return (fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED), 0);\n\n        }\n\n\n\n        // liquidateBorrowFresh emits borrow-specific logs on errors, so we don't need to\n\n        return liquidateBorrowFresh(msg.sender, borrower, repayAmount, rTokenCollateral);\n",
          "message": "Reentrancy in RToken.liquidateBorrowInternal (RBinanceHarness.sol#2160-2175):\n\tExternal calls:\n\t- error = accrueInterest() (RBinanceHarness.sol#2161)\n\t- error = rTokenCollateral.accrueInterest() (RBinanceHarness.sol#2167)\n\t- liquidateBorrowFresh(msg.sender,borrower,repayAmount,rTokenCollateral) (RBinanceHarness.sol#2174)\n\tState variables written after the call(s):\n\t- totalBorrows (RBinanceHarness.sol#2174)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 1844,
          "vulnerability_to_line": 1938,
          "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n\n\n\n        RedeemLocalVars memory vars;\n\n\n\n        /* exchangeRate = invoke Exchange Rate Stored() */\n\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* If redeemTokensIn > 0: */\n\n        if (redeemTokensIn > 0) {\n\n            /*\n\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\n\n             *  redeemTokens = redeemTokensIn\n\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n\n             */\n\n            vars.redeemTokens = redeemTokensIn;\n\n\n\n            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED, uint(vars.mathErr));\n\n            }\n\n        } else {\n\n            /*\n\n             * We get the current exchange rate and calculate the amount to be redeemed:\n\n             *  redeemTokens = redeemAmountIn / exchangeRate\n\n             *  redeemAmount = redeemAmountIn\n\n             */\n\n\n\n            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED, uint(vars.mathErr));\n\n            }\n\n\n\n            vars.redeemAmount = redeemAmountIn;\n\n        }\n\n\n\n        /* Fail if redeem not allowed */\n\n        uint allowed = cointroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COINTROLLER_REJECTION, FailureInfo.REDEEM_COINTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);\n\n        }\n\n\n\n        /*\n\n         * We calculate the new total supply and redeemer balance, checking for underflow:\n\n         *  totalSupplyNew = totalSupply - redeemTokens\n\n         *  accountTokensNew = accountTokens[redeemer] - redeemTokens\n\n         */\n\n        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* Fail gracefully if protocol has insufficient cash */\n\n        if (getCashPrior() < vars.redeemAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We invoke doTransferOut for the redeemer and the redeemAmount.\n\n         *  Note: The rToken must handle variations between BEP-20 and ETH underlying.\n\n         *  On success, the rToken has redeemAmount less of cash.\n\n         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n\n         */\n\n        doTransferOut(redeemer, vars.redeemAmount);\n\n\n\n        /* We write previously calculated values into storage */\n\n        totalSupply = vars.totalSupplyNew;\n\n        accountTokens[redeemer] = vars.accountTokensNew;\n\n\n\n        /* We emit a Transfer event, and a Redeem event */\n\n        emit Transfer(redeemer, address(this), vars.redeemTokens);\n\n        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        /* We call the defense hook */\n\n        cointroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        return uint(Error.NO_ERROR);\n",
          "message": "Reentrancy in RToken.redeemFresh (RBinanceHarness.sol#1844-1938):\n\tExternal calls:\n\t- allowed = cointroller.redeemAllowed(address(this),redeemer,vars.redeemTokens) (RBinanceHarness.sol#1884)\n\tState variables written after the call(s):\n\t- totalSupply (RBinanceHarness.sol#1927)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 2055,
          "vulnerability_to_line": 2063,
          "vulnerability_code": "    function repayBorrowBehalfInternal(address borrower, uint repayAmount) internal nonReentrant returns (uint, uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n\n            return (fail(Error(error), FailureInfo.REPAY_BEHALF_ACCRUE_INTEREST_FAILED), 0);\n\n        }\n\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n\n        return repayBorrowFresh(msg.sender, borrower, repayAmount);\n",
          "message": "Reentrancy in RToken.repayBorrowBehalfInternal (RBinanceHarness.sol#2055-2063):\n\tExternal calls:\n\t- error = accrueInterest() (RBinanceHarness.sol#2056)\n\t- repayBorrowFresh(msg.sender,borrower,repayAmount) (RBinanceHarness.sol#2062)\n\tState variables written after the call(s):\n\t- totalBorrows (RBinanceHarness.sol#2062)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 2039,
          "vulnerability_to_line": 2047,
          "vulnerability_code": "    function repayBorrowInternal(uint repayAmount) internal nonReentrant returns (uint, uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n\n            return (fail(Error(error), FailureInfo.REPAY_BORROW_ACCRUE_INTEREST_FAILED), 0);\n\n        }\n\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n\n        return repayBorrowFresh(msg.sender, msg.sender, repayAmount);\n",
          "message": "Reentrancy in RToken.repayBorrowInternal (RBinanceHarness.sol#2039-2047):\n\tExternal calls:\n\t- error = accrueInterest() (RBinanceHarness.sol#2040)\n\t- repayBorrowFresh(msg.sender,msg.sender,repayAmount) (RBinanceHarness.sol#2046)\n\tState variables written after the call(s):\n\t- totalBorrows (RBinanceHarness.sol#2046)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 3976,
          "vulnerability_to_line": 4005,
          "vulnerability_code": "    function seizeAllowed(\n\n        address rTokenCollateral,\n\n        address rTokenBorrowed,\n\n        address liquidator,\n\n        address borrower,\n\n        uint seizeTokens) external returns (uint) {\n\n        // Pausing is a very serious situation - we revert to sound the alarms\n\n        require(!seizeGuardianPaused, \"seize is paused\");\n\n\n\n        // Shh - currently unused\n\n        seizeTokens;\n\n\n\n        if (!markets[rTokenCollateral].isListed || !markets[rTokenBorrowed].isListed) {\n\n            return uint(Error.MARKET_NOT_LISTED);\n\n        }\n\n\n\n        if (RToken(rTokenCollateral).cointroller() != RToken(rTokenBorrowed).cointroller()) {\n\n            return uint(Error.COINTROLLER_MISMATCH);\n\n        }\n\n\n\n        // Keep the flywheel moving\n\n        updateRifiSupplyIndex(rTokenCollateral);\n\n        distributeSupplierRifi(rTokenCollateral, borrower);\n\n        distributeSupplierRifi(rTokenCollateral, liquidator);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
          "message": "Reentrancy in Cointroller.seizeAllowed (RBinanceHarness.sol#3976-4005):\n\tExternal calls:\n\t- updateRifiSupplyIndex(rTokenCollateral) (RBinanceHarness.sol#3997-3998)\n\t- distributeSupplierRifi(rTokenCollateral,borrower) (RBinanceHarness.sol#3998-3999)\n\t- distributeSupplierRifi(rTokenCollateral,liquidator) (RBinanceHarness.sol#3999-4001)\n\tState variables written after the call(s):\n\t- rifiAccrued (RBinanceHarness.sol#3999-4001)\n\t- rifiSupplierIndex (RBinanceHarness.sol#3999-4001)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 4505,
          "vulnerability_to_line": 4539,
          "vulnerability_code": "    function setRifiSpeedInternal(RToken rToken, uint rifiSpeed) internal {\n\n        uint currentRifiSpeed = rifiSpeeds[address(rToken)];\n\n        if (currentRifiSpeed != 0) {\n\n            // note that RIFI speed could be set to 0 to halt liquidity rewards for a market\n\n            Exp memory borrowIndex = Exp({mantissa: rToken.borrowIndex()});\n\n            updateRifiSupplyIndex(address(rToken));\n\n            updateRifiBorrowIndex(address(rToken), borrowIndex);\n\n        } else if (rifiSpeed != 0) {\n\n            // Add the RIFI market\n\n            Market storage market = markets[address(rToken)];\n\n            require(market.isListed == true, \"rifi market is not listed\");\n\n\n\n            if (rifiSupplyState[address(rToken)].index == 0 && rifiSupplyState[address(rToken)].block == 0) {\n\n                rifiSupplyState[address(rToken)] = RifiMarketState({\n\n                    index: rifiInitialIndex,\n\n                    block: safe32(getBlockNumber(), \"block number exceeds 32 bits\")\n\n                });\n\n            }\n\n\n\n            if (rifiBorrowState[address(rToken)].index == 0 && rifiBorrowState[address(rToken)].block == 0) {\n\n                rifiBorrowState[address(rToken)] = RifiMarketState({\n\n                    index: rifiInitialIndex,\n\n                    block: safe32(getBlockNumber(), \"block number exceeds 32 bits\")\n\n                });\n\n            }\n\n        }\n\n\n\n        if (currentRifiSpeed != rifiSpeed) {\n\n            rifiSpeeds[address(rToken)] = rifiSpeed;\n\n            emit RifiSpeedUpdated(rToken, rifiSpeed);\n\n        }\n\n    }\n\n\n\n    /**\n",
          "message": "Reentrancy in Cointroller.setRifiSpeedInternal (RBinanceHarness.sol#4505-4539):\n\tExternal calls:\n\t- borrowIndex = Exp(rToken.borrowIndex()) (RBinanceHarness.sol#4509-4510)\n\t- updateRifiSupplyIndex(address(rToken)) (RBinanceHarness.sol#4510-4511)\n\t- updateRifiBorrowIndex(address(rToken),borrowIndex) (RBinanceHarness.sol#4511-4512)\n\tState variables written after the call(s):\n\t- rifiSpeeds (RBinanceHarness.sol#4533-4534)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 4039,
          "vulnerability_to_line": 4059,
          "vulnerability_code": "    function transferAllowed(address rToken, address src, address dst, uint transferTokens) external returns (uint) {\n\n        // Pausing is a very serious situation - we revert to sound the alarms\n\n        require(!transferGuardianPaused, \"transfer is paused\");\n\n\n\n        // Currently the only consideration is whether or not\n\n        //  the src is allowed to redeem this many tokens\n\n        uint allowed = redeemAllowedInternal(rToken, src, transferTokens);\n\n        if (allowed != uint(Error.NO_ERROR)) {\n\n            return allowed;\n\n        }\n\n\n\n        // Keep the flywheel moving\n\n        updateRifiSupplyIndex(rToken);\n\n        distributeSupplierRifi(rToken, src);\n\n        distributeSupplierRifi(rToken, dst);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
          "message": "Reentrancy in Cointroller.transferAllowed (RBinanceHarness.sol#4039-4059):\n\tExternal calls:\n\t- allowed = redeemAllowedInternal(rToken,src,transferTokens) (RBinanceHarness.sol#4045-4046)\n\t- updateRifiSupplyIndex(rToken) (RBinanceHarness.sol#4051-4052)\n\t- distributeSupplierRifi(rToken,src) (RBinanceHarness.sol#4052-4053)\n\t- distributeSupplierRifi(rToken,dst) (RBinanceHarness.sol#4053-4055)\n\tState variables written after the call(s):\n\t- rifiAccrued (RBinanceHarness.sol#4053-4055)\n\t- rifiSupplierIndex (RBinanceHarness.sol#4053-4055)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 4565,
          "vulnerability_to_line": 4585,
          "vulnerability_code": "    function updateRifiBorrowIndex(address rToken, Exp memory marketBorrowIndex) internal {\n\n        RifiMarketState storage borrowState = rifiBorrowState[rToken];\n\n        uint borrowSpeed = rifiSpeeds[rToken];\n\n        uint blockNumber = getBlockNumber();\n\n        uint deltaBlocks = sub_(blockNumber, uint(borrowState.block));\n\n        if (deltaBlocks > 0 && borrowSpeed > 0) {\n\n            uint borrowAmount = div_(RToken(rToken).totalBorrows(), marketBorrowIndex);\n\n            uint rifiAccrued = mul_(deltaBlocks, borrowSpeed);\n\n            Double memory ratio = borrowAmount > 0 ? fraction(rifiAccrued, borrowAmount) : Double({mantissa: 0});\n\n            Double memory index = add_(Double({mantissa: borrowState.index}), ratio);\n\n            rifiBorrowState[rToken] = RifiMarketState({\n\n                index: safe224(index.mantissa, \"new index exceeds 224 bits\"),\n\n                block: safe32(blockNumber, \"block number exceeds 32 bits\")\n\n            });\n\n        } else if (deltaBlocks > 0) {\n\n            borrowState.block = safe32(blockNumber, \"block number exceeds 32 bits\");\n\n        }\n\n    }\n\n\n\n    /**\n",
          "message": "Reentrancy in Cointroller.updateRifiBorrowIndex (RBinanceHarness.sol#4565-4585):\n\tExternal calls:\n\t- borrowAmount = div_(RToken(rToken).totalBorrows(),marketBorrowIndex) (RBinanceHarness.sol#4571-4572)\n\tState variables written after the call(s):\n\t- rifiBorrowState (RBinanceHarness.sol#4575-4579)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 4542,
          "vulnerability_to_line": 4562,
          "vulnerability_code": "    function updateRifiSupplyIndex(address rToken) internal {\n\n        RifiMarketState storage supplyState = rifiSupplyState[rToken];\n\n        uint supplySpeed = rifiSpeeds[rToken];\n\n        uint blockNumber = getBlockNumber();\n\n        uint deltaBlocks = sub_(blockNumber, uint(supplyState.block));\n\n        if (deltaBlocks > 0 && supplySpeed > 0) {\n\n            uint supplyTokens = RToken(rToken).totalSupply();\n\n            uint rifiAccrued = mul_(deltaBlocks, supplySpeed);\n\n            Double memory ratio = supplyTokens > 0 ? fraction(rifiAccrued, supplyTokens) : Double({mantissa: 0});\n\n            Double memory index = add_(Double({mantissa: supplyState.index}), ratio);\n\n            rifiSupplyState[rToken] = RifiMarketState({\n\n                index: safe224(index.mantissa, \"new index exceeds 224 bits\"),\n\n                block: safe32(blockNumber, \"block number exceeds 32 bits\")\n\n            });\n\n        } else if (deltaBlocks > 0) {\n\n            supplyState.block = safe32(blockNumber, \"block number exceeds 32 bits\");\n\n        }\n\n    }\n\n\n\n    /**\n",
          "message": "Reentrancy in Cointroller.updateRifiSupplyIndex (RBinanceHarness.sol#4542-4562):\n\tExternal calls:\n\t- supplyTokens = RToken(rToken).totalSupply() (RBinanceHarness.sol#4548-4549)\n\tState variables written after the call(s):\n\t- rifiSupplyState (RBinanceHarness.sol#4552-4556)\n"
        },
        {
          "name": "uninitialized-local",
          "vulnerability_from_line": 1985,
          "vulnerability_to_line": null,
          "vulnerability_code": "        BorrowLocalVars memory vars;\n",
          "message": "vars in RToken.borrowFresh (RBinanceHarness.sol#1985) is a local variable never initialiazed\n"
        },
        {
          "name": "uninitialized-local",
          "vulnerability_from_line": 2477,
          "vulnerability_to_line": 2479,
          "vulnerability_code": "        uint actualAddAmount;\n\n\n",
          "message": "actualAddAmount in RToken._addReservesFresh (RBinanceHarness.sol#2477-2479) is a local variable never initialiazed\n"
        },
        {
          "name": "uninitialized-local",
          "vulnerability_from_line": 3809,
          "vulnerability_to_line": null,
          "vulnerability_code": "        (Error err, , uint shortfall) = getHypotheticalAccountLiquidityInternal(borrower, RToken(rToken), 0, borrowAmount);\n",
          "message": "err_scope_0 in Cointroller.borrowAllowed (RBinanceHarness.sol#3809) is a local variable never initialiazed\n"
        },
        {
          "name": "uninitialized-local",
          "vulnerability_from_line": 1847,
          "vulnerability_to_line": null,
          "vulnerability_code": "        RedeemLocalVars memory vars;\n",
          "message": "vars in RToken.redeemFresh (RBinanceHarness.sol#1847) is a local variable never initialiazed\n"
        },
        {
          "name": "uninitialized-local",
          "vulnerability_from_line": 2095,
          "vulnerability_to_line": null,
          "vulnerability_code": "        RepayBorrowLocalVars memory vars;\n",
          "message": "vars in RToken.repayBorrowFresh (RBinanceHarness.sol#2095) is a local variable never initialiazed\n"
        },
        {
          "name": "uninitialized-local",
          "vulnerability_from_line": 1739,
          "vulnerability_to_line": null,
          "vulnerability_code": "        MintLocalVars memory vars;\n",
          "message": "vars in RToken.mintFresh (RBinanceHarness.sol#1739) is a local variable never initialiazed\n"
        },
        {
          "name": "unused-return",
          "vulnerability_from_line": 4360,
          "vulnerability_to_line": 4381,
          "vulnerability_code": "    function _supportMarket(RToken rToken) external returns (uint) {\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SUPPORT_MARKET_OWNER_CHECK);\n\n        }\n\n\n\n        if (markets[address(rToken)].isListed) {\n\n            return fail(Error.MARKET_ALREADY_LISTED, FailureInfo.SUPPORT_MARKET_EXISTS);\n\n        }\n\n\n\n        rToken.isRToken(); // Sanity check to make sure its really a RToken\n\n\n\n        // Note that isRified is not in active use anymore\n\n        markets[address(rToken)] = Market({isListed: true, isRified: false, collateralFactorMantissa: 0});\n\n\n\n        _addMarketInternal(address(rToken));\n\n\n\n        emit MarketListed(rToken);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Cointroller._supportMarket (RBinanceHarness.sol#4360-4381) does not use the value returned by external calls:\n\t-rToken.isRToken() (RBinanceHarness.sol#4369)\n"
        },
        {
          "name": "unused-return",
          "vulnerability_from_line": 4701,
          "vulnerability_to_line": 4711,
          "vulnerability_code": "    function grantRifiInternal(address user, uint amount) internal returns (uint) {\n\n        Rifi rifi = Rifi(getRifiAddress());\n\n        uint rifiRemaining = rifi.balanceOf(address(this));\n\n        if (amount > 0 && amount <= rifiRemaining) {\n\n            rifi.transfer(user, amount);\n\n            return 0;\n\n        }\n\n        return amount;\n\n    }\n\n\n",
          "message": "Cointroller.grantRifiInternal (RBinanceHarness.sol#4701-4711) does not use the value returned by external calls:\n\t-rifi.transfer(user,amount) (RBinanceHarness.sol#4705-4706)\n"
        },
        {
          "name": "shadowing-local",
          "vulnerability_from_line": 1105,
          "vulnerability_to_line": null,
          "vulnerability_code": "        (MathError err, Exp memory fraction) = divScalarByExp(scalar, divisor);\n",
          "message": "Exponential.divScalarByExpTruncate.fraction (local variable @ RBinanceHarness.sol#1105) shadows:\n\t- ExponentialNoError.fraction (function @ RBinanceHarness.sol#977-979)\n"
        },
        {
          "name": "shadowing-local",
          "vulnerability_from_line": 4549,
          "vulnerability_to_line": 4550,
          "vulnerability_code": "            uint rifiAccrued = mul_(deltaBlocks, supplySpeed);\n",
          "message": "Cointroller.updateRifiSupplyIndex.rifiAccrued (local variable @ RBinanceHarness.sol#4549-4550) shadows:\n\t- CointrollerStorage.rifiAccrued (state variable @ RBinanceHarness.sol#2968-2970)\n"
        },
        {
          "name": "shadowing-local",
          "vulnerability_from_line": 4572,
          "vulnerability_to_line": 4573,
          "vulnerability_code": "            uint rifiAccrued = mul_(deltaBlocks, borrowSpeed);\n",
          "message": "Cointroller.updateRifiBorrowIndex.rifiAccrued (local variable @ RBinanceHarness.sol#4572-4573) shadows:\n\t- CointrollerStorage.rifiAccrued (state variable @ RBinanceHarness.sol#2968-2970)\n"
        },
        {
          "name": "shadowing-local",
          "vulnerability_from_line": 4864,
          "vulnerability_to_line": 4865,
          "vulnerability_code": "                uint initialExchangeRateMantissa,\n",
          "message": "RBinanceHarness.constructor.initialExchangeRateMantissa (local variable @ RBinanceHarness.sol#4864-4865) shadows:\n\t- RTokenStorage.initialExchangeRateMantissa (state variable @ RBinanceHarness.sol#242)\n"
        },
        {
          "name": "shadowing-local",
          "vulnerability_from_line": 5018,
          "vulnerability_to_line": 5019,
          "vulnerability_code": "                uint initialExchangeRateMantissa)\n",
          "message": "RBinanceScenario.constructor.initialExchangeRateMantissa (local variable @ RBinanceHarness.sol#5018-5019) shadows:\n\t- RTokenStorage.initialExchangeRateMantissa (state variable @ RBinanceHarness.sol#242)\n"
        },
        {
          "name": "calls-loop",
          "vulnerability_from_line": 4836,
          "vulnerability_to_line": 4837,
          "vulnerability_code": "                Exp memory assetPrice = Exp({mantissa: oracle.getUnderlyingPrice(rToken)});\n",
          "message": "CointrollerScenario.refreshRifiSpeeds has external calls inside a loop:\n\t- assetPrice = Exp(oracle.getUnderlyingPrice(rToken_scope_1)) (RBinanceHarness.sol#4836-4837)\n"
        },
        {
          "name": "calls-loop",
          "vulnerability_from_line": 4837,
          "vulnerability_to_line": 4838,
          "vulnerability_code": "                Exp memory utility = mul_(assetPrice, rToken.totalBorrows());\n",
          "message": "CointrollerScenario.refreshRifiSpeeds has external calls inside a loop:\n\t- utility = mul_(assetPrice,rToken_scope_1.totalBorrows()) (RBinanceHarness.sol#4837-4838)\n"
        },
        {
          "name": "calls-loop",
          "vulnerability_from_line": 4826,
          "vulnerability_to_line": 4827,
          "vulnerability_code": "            Exp memory borrowIndex = Exp({mantissa: rToken.borrowIndex()});\n",
          "message": "CointrollerScenario.refreshRifiSpeeds has external calls inside a loop:\n\t- borrowIndex = Exp(rToken.borrowIndex()) (RBinanceHarness.sol#4826-4827)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 4360,
          "vulnerability_to_line": 4381,
          "vulnerability_code": "    function _supportMarket(RToken rToken) external returns (uint) {\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SUPPORT_MARKET_OWNER_CHECK);\n\n        }\n\n\n\n        if (markets[address(rToken)].isListed) {\n\n            return fail(Error.MARKET_ALREADY_LISTED, FailureInfo.SUPPORT_MARKET_EXISTS);\n\n        }\n\n\n\n        rToken.isRToken(); // Sanity check to make sure its really a RToken\n\n\n\n        // Note that isRified is not in active use anymore\n\n        markets[address(rToken)] = Market({isListed: true, isRified: false, collateralFactorMantissa: 0});\n\n\n\n        _addMarketInternal(address(rToken));\n\n\n\n        emit MarketListed(rToken);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Reentrancy in Cointroller._supportMarket (RBinanceHarness.sol#4360-4381):\n\tExternal calls:\n\t- rToken.isRToken() (RBinanceHarness.sol#4369)\n\tState variables written after the call(s):\n\t- allMarkets (RBinanceHarness.sol#4374-4376)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 1968,
          "vulnerability_to_line": 2032,
          "vulnerability_code": "    function borrowFresh(address payable borrower, uint borrowAmount) internal returns (uint) {\n\n        /* Fail if borrow not allowed */\n\n        uint allowed = cointroller.borrowAllowed(address(this), borrower, borrowAmount);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COINTROLLER_REJECTION, FailureInfo.BORROW_COINTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.BORROW_FRESHNESS_CHECK);\n\n        }\n\n\n\n        /* Fail gracefully if protocol has insufficient underlying cash */\n\n        if (getCashPrior() < borrowAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.BORROW_CASH_NOT_AVAILABLE);\n\n        }\n\n\n\n        BorrowLocalVars memory vars;\n\n\n\n        /*\n\n         * We calculate the new borrower and total borrow balances, failing on overflow:\n\n         *  accountBorrowsNew = accountBorrows + borrowAmount\n\n         *  totalBorrowsNew = totalBorrows + borrowAmount\n\n         */\n\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We invoke doTransferOut for the borrower and the borrowAmount.\n\n         *  Note: The rToken must handle variations between BEP-20 and ETH underlying.\n\n         *  On success, the rToken borrowAmount less of cash.\n\n         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n\n         */\n\n        doTransferOut(borrower, borrowAmount);\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n\n        accountBorrows[borrower].interestIndex = borrowIndex;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n\n\n        /* We emit a Borrow event */\n\n        emit Borrow(borrower, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n\n\n        /* We call the defense hook */\n\n        // unused function\n\n        // cointroller.borrowVerify(address(this), borrower, borrowAmount);\n\n\n\n        return uint(Error.NO_ERROR);\n",
          "message": "Reentrancy in RToken.borrowFresh (RBinanceHarness.sol#1968-2032):\n\tExternal calls:\n\t- allowed = cointroller.borrowAllowed(address(this),borrower,borrowAmount) (RBinanceHarness.sol#1970)\n\tState variables written after the call(s):\n\t- accountBorrows (RBinanceHarness.sol#2020)\n\t- accountBorrows (RBinanceHarness.sol#2021)\n\t- totalBorrows (RBinanceHarness.sol#2022)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 4613,
          "vulnerability_to_line": 4630,
          "vulnerability_code": "    function distributeBorrowerRifi(address rToken, address borrower, Exp memory marketBorrowIndex) internal {\n\n        RifiMarketState storage borrowState = rifiBorrowState[rToken];\n\n        Double memory borrowIndex = Double({mantissa: borrowState.index});\n\n        Double memory borrowerIndex = Double({mantissa: rifiBorrowerIndex[rToken][borrower]});\n\n        rifiBorrowerIndex[rToken][borrower] = borrowIndex.mantissa;\n\n\n\n        if (borrowerIndex.mantissa > 0) {\n\n            Double memory deltaIndex = sub_(borrowIndex, borrowerIndex);\n\n            uint borrowerAmount = div_(RToken(rToken).borrowBalanceStored(borrower), marketBorrowIndex);\n\n            uint borrowerDelta = mul_(borrowerAmount, deltaIndex);\n\n            uint borrowerAccrued = add_(rifiAccrued[borrower], borrowerDelta);\n\n            rifiAccrued[borrower] = borrowerAccrued;\n\n            emit DistributedBorrowerRifi(RToken(rToken), borrower, borrowerDelta, borrowIndex.mantissa);\n\n        }\n\n    }\n\n\n\n    /**\n",
          "message": "Reentrancy in Cointroller.distributeBorrowerRifi (RBinanceHarness.sol#4613-4630):\n\tExternal calls:\n\t- borrowerAmount = div_(RToken(rToken).borrowBalanceStored(borrower),marketBorrowIndex) (RBinanceHarness.sol#4621-4622)\n\tState variables written after the call(s):\n\t- rifiAccrued (RBinanceHarness.sol#4624-4625)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 4589,
          "vulnerability_to_line": 4608,
          "vulnerability_code": "    function distributeSupplierRifi(address rToken, address supplier) internal {\n\n        RifiMarketState storage supplyState = rifiSupplyState[rToken];\n\n        Double memory supplyIndex = Double({mantissa: supplyState.index});\n\n        Double memory supplierIndex = Double({mantissa: rifiSupplierIndex[rToken][supplier]});\n\n        rifiSupplierIndex[rToken][supplier] = supplyIndex.mantissa;\n\n\n\n        if (supplierIndex.mantissa == 0 && supplyIndex.mantissa > 0) {\n\n            supplierIndex.mantissa = rifiInitialIndex;\n\n        }\n\n\n\n        Double memory deltaIndex = sub_(supplyIndex, supplierIndex);\n\n        uint supplierTokens = RToken(rToken).balanceOf(supplier);\n\n        uint supplierDelta = mul_(supplierTokens, deltaIndex);\n\n        uint supplierAccrued = add_(rifiAccrued[supplier], supplierDelta);\n\n        rifiAccrued[supplier] = supplierAccrued;\n\n        emit DistributedSupplierRifi(RToken(rToken), supplier, supplierDelta, supplyIndex.mantissa);\n\n    }\n\n\n\n    /**\n",
          "message": "Reentrancy in Cointroller.distributeSupplierRifi (RBinanceHarness.sol#4589-4608):\n\tExternal calls:\n\t- supplierTokens = RToken(rToken).balanceOf(supplier) (RBinanceHarness.sol#4600-4601)\n\tState variables written after the call(s):\n\t- rifiAccrued (RBinanceHarness.sol#4603-4604)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 1255,
          "vulnerability_to_line": 1286,
          "vulnerability_code": "    function initialize(CointrollerInterface cointroller_,\n\n                        InterestRateModel interestRateModel_,\n\n                        uint initialExchangeRateMantissa_,\n\n                        string memory name_,\n\n                        string memory symbol_,\n\n                        uint8 decimals_) public {\n\n        require(msg.sender == admin, \"only admin may initialize the market\");\n\n        require(accrualBlockNumber == 0 && borrowIndex == 0, \"market may only be initialized once\");\n\n\n\n        // Set initial exchange rate\n\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n\n        require(initialExchangeRateMantissa > 0, \"initial exchange rate must be greater than zero.\");\n\n\n\n        // Set the cointroller\n\n        uint err = _setCointroller(cointroller_);\n\n        require(err == uint(Error.NO_ERROR), \"setting cointroller failed\");\n\n\n\n        // Initialize block number and borrow index (block number mocks depend on cointroller being set)\n\n        accrualBlockNumber = getBlockNumber();\n\n        borrowIndex = mantissaOne;\n\n\n\n        // Set the interest rate model (depends on block number / borrow index)\n\n        err = _setInterestRateModelFresh(interestRateModel_);\n\n        require(err == uint(Error.NO_ERROR), \"setting interest rate model failed\");\n\n\n\n        name = name_;\n\n        symbol = symbol_;\n\n        decimals = decimals_;\n\n\n\n        // The counter starts true to prevent changing it from zero to non-zero (i.e. smaller cost/refund)\n\n        _notEntered = true;\n",
          "message": "Reentrancy in RToken.initialize (RBinanceHarness.sol#1255-1286):\n\tExternal calls:\n\t- err = _setCointroller(cointroller_) (RBinanceHarness.sol#1269)\n\t- err = _setInterestRateModelFresh(interestRateModel_) (RBinanceHarness.sol#1277)\n\tState variables written after the call(s):\n\t- _notEntered (RBinanceHarness.sol#1285)\n\t- decimals (RBinanceHarness.sol#1282)\n\t- name (RBinanceHarness.sol#1280)\n\t- symbol (RBinanceHarness.sol#1281)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 1727,
          "vulnerability_to_line": 1792,
          "vulnerability_code": "    function mintFresh(address minter, uint mintAmount) internal returns (uint, uint) {\n\n        /* Fail if mint not allowed */\n\n        uint allowed = cointroller.mintAllowed(address(this), minter, mintAmount);\n\n        if (allowed != 0) {\n\n            return (failOpaque(Error.COINTROLLER_REJECTION, FailureInfo.MINT_COINTROLLER_REJECTION, allowed), 0);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return (fail(Error.MARKET_NOT_FRESH, FailureInfo.MINT_FRESHNESS_CHECK), 0);\n\n        }\n\n\n\n        MintLocalVars memory vars;\n\n\n\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return (failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr)), 0);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         *  We call `doTransferIn` for the minter and the mintAmount.\n\n         *  Note: The rToken must handle variations between BEP-20 and ETH underlying.\n\n         *  `doTransferIn` reverts if anything goes wrong, since we can't be sure if\n\n         *  side-effects occurred. The function returns the amount actually transferred,\n\n         *  in case of a fee. On success, the rToken holds an additional `actualMintAmount`\n\n         *  of cash.\n\n         */\n\n        vars.actualMintAmount = doTransferIn(minter, mintAmount);\n\n\n\n        /*\n\n         * We get the current exchange rate and calculate the number of rTokens to be minted:\n\n         *  mintTokens = actualMintAmount / exchangeRate\n\n         */\n\n\n\n        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(vars.actualMintAmount, Exp({mantissa: vars.exchangeRateMantissa}));\n\n        require(vars.mathErr == MathError.NO_ERROR, \"MINT_EXCHANGE_CALCULATION_FAILED\");\n\n\n\n        /*\n\n         * We calculate the new total supply of rTokens and minter token balance, checking for overflow:\n\n         *  totalSupplyNew = totalSupply + mintTokens\n\n         *  accountTokensNew = accountTokens[minter] + mintTokens\n\n         */\n\n        (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);\n\n        require(vars.mathErr == MathError.NO_ERROR, \"MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED\");\n\n\n\n        (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);\n\n        require(vars.mathErr == MathError.NO_ERROR, \"MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED\");\n\n\n\n        /* We write previously calculated values into storage */\n\n        totalSupply = vars.totalSupplyNew;\n\n        accountTokens[minter] = vars.accountTokensNew;\n\n\n\n        /* We emit a Mint event, and a Transfer event */\n\n        emit Mint(minter, vars.actualMintAmount, vars.mintTokens);\n\n        emit Transfer(address(this), minter, vars.mintTokens);\n\n\n\n        /* We call the defense hook */\n\n        // unused function\n\n        // cointroller.mintVerify(address(this), minter, vars.actualMintAmount, vars.mintTokens);\n\n\n\n        return (uint(Error.NO_ERROR), vars.actualMintAmount);\n",
          "message": "Reentrancy in RToken.mintFresh (RBinanceHarness.sol#1727-1792):\n\tExternal calls:\n\t- allowed = cointroller.mintAllowed(address(this),minter,mintAmount) (RBinanceHarness.sol#1729)\n\tState variables written after the call(s):\n\t- accountTokens (RBinanceHarness.sol#1781)\n\t- totalSupply (RBinanceHarness.sol#1780)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 1844,
          "vulnerability_to_line": 1938,
          "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n\n\n\n        RedeemLocalVars memory vars;\n\n\n\n        /* exchangeRate = invoke Exchange Rate Stored() */\n\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* If redeemTokensIn > 0: */\n\n        if (redeemTokensIn > 0) {\n\n            /*\n\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\n\n             *  redeemTokens = redeemTokensIn\n\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n\n             */\n\n            vars.redeemTokens = redeemTokensIn;\n\n\n\n            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED, uint(vars.mathErr));\n\n            }\n\n        } else {\n\n            /*\n\n             * We get the current exchange rate and calculate the amount to be redeemed:\n\n             *  redeemTokens = redeemAmountIn / exchangeRate\n\n             *  redeemAmount = redeemAmountIn\n\n             */\n\n\n\n            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED, uint(vars.mathErr));\n\n            }\n\n\n\n            vars.redeemAmount = redeemAmountIn;\n\n        }\n\n\n\n        /* Fail if redeem not allowed */\n\n        uint allowed = cointroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COINTROLLER_REJECTION, FailureInfo.REDEEM_COINTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);\n\n        }\n\n\n\n        /*\n\n         * We calculate the new total supply and redeemer balance, checking for underflow:\n\n         *  totalSupplyNew = totalSupply - redeemTokens\n\n         *  accountTokensNew = accountTokens[redeemer] - redeemTokens\n\n         */\n\n        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* Fail gracefully if protocol has insufficient cash */\n\n        if (getCashPrior() < vars.redeemAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We invoke doTransferOut for the redeemer and the redeemAmount.\n\n         *  Note: The rToken must handle variations between BEP-20 and ETH underlying.\n\n         *  On success, the rToken has redeemAmount less of cash.\n\n         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n\n         */\n\n        doTransferOut(redeemer, vars.redeemAmount);\n\n\n\n        /* We write previously calculated values into storage */\n\n        totalSupply = vars.totalSupplyNew;\n\n        accountTokens[redeemer] = vars.accountTokensNew;\n\n\n\n        /* We emit a Transfer event, and a Redeem event */\n\n        emit Transfer(redeemer, address(this), vars.redeemTokens);\n\n        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        /* We call the defense hook */\n\n        cointroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        return uint(Error.NO_ERROR);\n",
          "message": "Reentrancy in RToken.redeemFresh (RBinanceHarness.sol#1844-1938):\n\tExternal calls:\n\t- allowed = cointroller.redeemAllowed(address(this),redeemer,vars.redeemTokens) (RBinanceHarness.sol#1884)\n\tState variables written after the call(s):\n\t- accountTokens (RBinanceHarness.sol#1928)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 2083,
          "vulnerability_to_line": 2150,
          "vulnerability_code": "    function repayBorrowFresh(address payer, address borrower, uint repayAmount) internal returns (uint, uint) {\n\n        /* Fail if repayBorrow not allowed */\n\n        uint allowed = cointroller.repayBorrowAllowed(address(this), payer, borrower, repayAmount);\n\n        if (allowed != 0) {\n\n            return (failOpaque(Error.COINTROLLER_REJECTION, FailureInfo.REPAY_BORROW_COINTROLLER_REJECTION, allowed), 0);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return (fail(Error.MARKET_NOT_FRESH, FailureInfo.REPAY_BORROW_FRESHNESS_CHECK), 0);\n\n        }\n\n\n\n        RepayBorrowLocalVars memory vars;\n\n\n\n        /* We remember the original borrowerIndex for verification purposes */\n\n        vars.borrowerIndex = accountBorrows[borrower].interestIndex;\n\n\n\n        /* We fetch the amount the borrower owes, with accumulated interest */\n\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return (failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr)), 0);\n\n        }\n\n\n\n        /* If repayAmount == -1, repayAmount = accountBorrows */\n\n        if (repayAmount == uint(-1)) {\n\n            vars.repayAmount = vars.accountBorrows;\n\n        } else {\n\n            vars.repayAmount = repayAmount;\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We call doTransferIn for the payer and the repayAmount\n\n         *  Note: The rToken must handle variations between BEP-20 and ETH underlying.\n\n         *  On success, the rToken holds an additional repayAmount of cash.\n\n         *  doTransferIn reverts if anything goes wrong, since we can't be sure if side effects occurred.\n\n         *   it returns the amount actually transferred, in case of a fee.\n\n         */\n\n        vars.actualRepayAmount = doTransferIn(payer, vars.repayAmount);\n\n\n\n        /*\n\n         * We calculate the new borrower and total borrow balances, failing on underflow:\n\n         *  accountBorrowsNew = accountBorrows - actualRepayAmount\n\n         *  totalBorrowsNew = totalBorrows - actualRepayAmount\n\n         */\n\n        (vars.mathErr, vars.accountBorrowsNew) = subUInt(vars.accountBorrows, vars.actualRepayAmount);\n\n        require(vars.mathErr == MathError.NO_ERROR, \"REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED\");\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = subUInt(totalBorrows, vars.actualRepayAmount);\n\n        require(vars.mathErr == MathError.NO_ERROR, \"REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED\");\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n\n        accountBorrows[borrower].interestIndex = borrowIndex;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n\n\n        /* We emit a RepayBorrow event */\n\n        emit RepayBorrow(payer, borrower, vars.actualRepayAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n\n\n        /* We call the defense hook */\n\n        // unused function\n\n        // cointroller.repayBorrowVerify(address(this), payer, borrower, vars.actualRepayAmount, vars.borrowerIndex);\n\n\n\n        return (uint(Error.NO_ERROR), vars.actualRepayAmount);\n",
          "message": "Reentrancy in RToken.repayBorrowFresh (RBinanceHarness.sol#2083-2150):\n\tExternal calls:\n\t- allowed = cointroller.repayBorrowAllowed(address(this),payer,borrower,repayAmount) (RBinanceHarness.sol#2085)\n\tState variables written after the call(s):\n\t- accountBorrows (RBinanceHarness.sol#2138)\n\t- accountBorrows (RBinanceHarness.sol#2139)\n\t- totalBorrows (RBinanceHarness.sol#2140)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 2280,
          "vulnerability_to_line": 2327,
          "vulnerability_code": "    function seizeInternal(address seizerToken, address liquidator, address borrower, uint seizeTokens) internal returns (uint) {\n\n        /* Fail if seize not allowed */\n\n        uint allowed = cointroller.seizeAllowed(address(this), seizerToken, liquidator, borrower, seizeTokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COINTROLLER_REJECTION, FailureInfo.LIQUIDATE_SEIZE_COINTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Fail if borrower = liquidator */\n\n        if (borrower == liquidator) {\n\n            return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER);\n\n        }\n\n\n\n        MathError mathErr;\n\n        uint borrowerTokensNew;\n\n        uint liquidatorTokensNew;\n\n\n\n        /*\n\n         * We calculate the new borrower and liquidator token balances, failing on underflow/overflow:\n\n         *  borrowerTokensNew = accountTokens[borrower] - seizeTokens\n\n         *  liquidatorTokensNew = accountTokens[liquidator] + seizeTokens\n\n         */\n\n        (mathErr, borrowerTokensNew) = subUInt(accountTokens[borrower], seizeTokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED, uint(mathErr));\n\n        }\n\n\n\n        (mathErr, liquidatorTokensNew) = addUInt(accountTokens[liquidator], seizeTokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED, uint(mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accountTokens[borrower] = borrowerTokensNew;\n\n        accountTokens[liquidator] = liquidatorTokensNew;\n\n\n\n        /* Emit a Transfer event */\n\n        emit Transfer(borrower, liquidator, seizeTokens);\n\n\n\n        /* We call the defense hook */\n\n        // unused function\n\n        // cointroller.seizeVerify(address(this), seizerToken, liquidator, borrower, seizeTokens);\n\n\n\n        return uint(Error.NO_ERROR);\n",
          "message": "Reentrancy in RToken.seizeInternal (RBinanceHarness.sol#2280-2327):\n\tExternal calls:\n\t- allowed = cointroller.seizeAllowed(address(this),seizerToken,liquidator,borrower,seizeTokens) (RBinanceHarness.sol#2282)\n\tState variables written after the call(s):\n\t- accountTokens (RBinanceHarness.sol#2316)\n\t- accountTokens (RBinanceHarness.sol#2317)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 1297,
          "vulnerability_to_line": 1357,
          "vulnerability_code": "    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (uint) {\n\n        /* Fail if transfer not allowed */\n\n        uint allowed = cointroller.transferAllowed(address(this), src, dst, tokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COINTROLLER_REJECTION, FailureInfo.TRANSFER_COINTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Do not allow self-transfers */\n\n        if (src == dst) {\n\n            return fail(Error.BAD_INPUT, FailureInfo.TRANSFER_NOT_ALLOWED);\n\n        }\n\n\n\n        /* Get the allowance, infinite for the account owner */\n\n        uint startingAllowance = 0;\n\n        if (spender == src) {\n\n            startingAllowance = uint(-1);\n\n        } else {\n\n            startingAllowance = transferAllowances[src][spender];\n\n        }\n\n\n\n        /* Do the calculations, checking for {under,over}flow */\n\n        MathError mathErr;\n\n        uint allowanceNew;\n\n        uint srrTokensNew;\n\n        uint dstTokensNew;\n\n\n\n        (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ALLOWED);\n\n        }\n\n\n\n        (mathErr, srrTokensNew) = subUInt(accountTokens[src], tokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ENOUGH);\n\n        }\n\n\n\n        (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_TOO_MUCH);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        accountTokens[src] = srrTokensNew;\n\n        accountTokens[dst] = dstTokensNew;\n\n\n\n        /* Eat some of the allowance (if necessary) */\n\n        if (startingAllowance != uint(-1)) {\n\n            transferAllowances[src][spender] = allowanceNew;\n\n        }\n\n\n\n        /* We emit a Transfer event */\n\n        emit Transfer(src, dst, tokens);\n\n\n\n        // unused function\n\n        // cointroller.transferVerify(address(this), src, dst, tokens);\n\n\n\n        return uint(Error.NO_ERROR);\n",
          "message": "Reentrancy in RToken.transferTokens (RBinanceHarness.sol#1297-1357):\n\tExternal calls:\n\t- allowed = cointroller.transferAllowed(address(this),src,dst,tokens) (RBinanceHarness.sol#1299)\n\tState variables written after the call(s):\n\t- accountTokens (RBinanceHarness.sol#1342)\n\t- accountTokens (RBinanceHarness.sol#1343)\n\t- transferAllowances (RBinanceHarness.sol#1347)\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 3118,
          "vulnerability_to_line": 3133,
          "vulnerability_code": "    function () payable external {\n\n        // delegate all other functions to current implementation\n\n        (bool success, ) = cointrollerImplementation.delegatecall(msg.data);\n\n\n\n        assembly {\n\n              let free_mem_ptr := mload(0x40)\n\n              returndatacopy(free_mem_ptr, 0, returndatasize)\n\n\n\n              switch success\n\n              case 0 { revert(free_mem_ptr, returndatasize) }\n\n              default { return(free_mem_ptr, returndatasize) }\n\n        }\n\n    }\n\n}\n\n\n",
          "message": "Unitroller.fallback uses assembly (RBinanceHarness.sol#3118-3133)\n\t- RBinanceHarness.sol#3122-3133\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 3430,
          "vulnerability_to_line": 3437,
          "vulnerability_code": "    function getChainId() internal pure returns (uint) {\n\n        uint256 chainId;\n\n        assembly { chainId := chainid() }\n\n        return chainId;\n\n    }\n\n}\n\n\n",
          "message": "Rifi.getChainId uses assembly (RBinanceHarness.sol#3430-3437)\n\t- RBinanceHarness.sol#3432-3433\n"
        },
        {
          "name": "constable-states",
          "vulnerability_from_line": 2933,
          "vulnerability_to_line": 2934,
          "vulnerability_code": "    bool public _borrowGuardianPaused;\n",
          "message": "CointrollerStorage._borrowGuardianPaused should be constant (RBinanceHarness.sol#2933-2934)\nCointrollerStorage._mintGuardianPaused should be constant (RBinanceHarness.sol#2932-2933)\nCointrollerStorage.rifiRate should be constant (RBinanceHarness.sol#2950-2952)\nRBep20Storage.underlying should be constant (RBinanceHarness.sol#428)\nRBinanceScenario.reserveFactor should be constant (RBinanceHarness.sol#5010-5012)\nRDelegationStorage.implementation should be constant (RBinanceHarness.sol#454)\n"
        },
        {
          "name": "pragma",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": "Different versions of Solidity is used in RBinanceHarness.sol:\n\t- Version used: ['ABIEncoderV2', '^0.5.16']\n\t- RBinanceHarness.sol#3 declares pragma solidity^0.5.16\n\t- RBinanceHarness.sol#77 declares pragma solidity^0.5.16\n\t- RBinanceHarness.sol#110 declares pragma solidity^0.5.16\n\t- RBinanceHarness.sol#183 declares pragma solidity^0.5.16\n\t- RBinanceHarness.sol#488 declares pragma solidity^0.5.16\n\t- RBinanceHarness.sol#698 declares pragma solidity^0.5.16\n\t- RBinanceHarness.sol#786 declares pragma solidity^0.5.16\n\t- RBinanceHarness.sol#984 declares pragma solidity^0.5.16\n\t- RBinanceHarness.sol#1168 declares pragma solidity^0.5.16\n\t- RBinanceHarness.sol#1233 declares pragma solidity^0.5.16\n\t- RBinanceHarness.sol#2668-2671 declares pragma solidity^0.5.16\n\t- RBinanceHarness.sol#2837-2839 declares pragma solidity^0.5.16\n\t- RBinanceHarness.sol#2854-2857 declares pragma solidity^0.5.16\n\t- RBinanceHarness.sol#2985-2988 declares pragma solidity^0.5.16\n\t- RBinanceHarness.sol#3135-3136 declares pragma solidity^0.5.16\n\t- RBinanceHarness.sol#3136-3138 declares pragma experimentalABIEncoderV2\n\t- RBinanceHarness.sol#3439-3447 declares pragma solidity^0.5.16\n\t- RBinanceHarness.sol#4781-4783 declares pragma solidity^0.5.16\n\t- RBinanceHarness.sol#4853-4856 declares pragma solidity^0.5.16\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 421,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint);\n",
          "message": "RTokenInterface._setInterestRateModel (RBinanceHarness.sol#421) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 2584,
          "vulnerability_to_line": 2594,
          "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n\n        return _setInterestRateModelFresh(newInterestRateModel);\n\n    }\n\n\n",
          "message": "RToken._setInterestRateModel (RBinanceHarness.sol#2584-2594) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 469,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setImplementation(address implementation_, bool allowResign, bytes memory becomeImplementationData) public;\n",
          "message": "RDelegatorInterface._setImplementation (RBinanceHarness.sol#469) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 478,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _becomeImplementation(bytes memory data) public;\n",
          "message": "RDelegateInterface._becomeImplementation (RBinanceHarness.sol#478) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 483,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _resignImplementation() public;\n",
          "message": "RDelegateInterface._resignImplementation (RBinanceHarness.sol#483) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 3021,
          "vulnerability_to_line": 3036,
          "vulnerability_code": "    function _setPendingImplementation(address newPendingImplementation) public returns (uint) {\n\n\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_IMPLEMENTATION_OWNER_CHECK);\n\n        }\n\n\n\n        address oldPendingImplementation = pendingCointrollerImplementation;\n\n\n\n        pendingCointrollerImplementation = newPendingImplementation;\n\n\n\n        emit NewPendingImplementation(oldPendingImplementation, pendingCointrollerImplementation);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Unitroller._setPendingImplementation (RBinanceHarness.sol#3021-3036) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 3041,
          "vulnerability_to_line": 3062,
          "vulnerability_code": "    function _acceptImplementation() public returns (uint) {\n\n        // Check caller is pendingImplementation and pendingImplementation \u2260 address(0)\n\n        if (msg.sender != pendingCointrollerImplementation || pendingCointrollerImplementation == address(0)) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_PENDING_IMPLEMENTATION_ADDRESS_CHECK);\n\n        }\n\n\n\n        // Save current values for inclusion in log\n\n        address oldImplementation = cointrollerImplementation;\n\n        address oldPendingImplementation = pendingCointrollerImplementation;\n\n\n\n        cointrollerImplementation = pendingCointrollerImplementation;\n\n\n\n        pendingCointrollerImplementation = address(0);\n\n\n\n        emit NewImplementation(oldImplementation, cointrollerImplementation);\n\n        emit NewPendingImplementation(oldPendingImplementation, pendingCointrollerImplementation);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n\n",
          "message": "Unitroller._acceptImplementation (RBinanceHarness.sol#3041-3062) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 3068,
          "vulnerability_to_line": 3086,
          "vulnerability_code": "    function _setPendingAdmin(address newPendingAdmin) public returns (uint) {\n\n        // Check caller = admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);\n\n        }\n\n\n\n        // Save current value, if any, for inclusion in log\n\n        address oldPendingAdmin = pendingAdmin;\n\n\n\n        // Store pendingAdmin with value newPendingAdmin\n\n        pendingAdmin = newPendingAdmin;\n\n\n\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\n\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Unitroller._setPendingAdmin (RBinanceHarness.sol#3068-3086) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 3091,
          "vulnerability_to_line": 3114,
          "vulnerability_code": "    function _acceptAdmin() public returns (uint) {\n\n        // Check caller is pendingAdmin and pendingAdmin \u2260 address(0)\n\n        if (msg.sender != pendingAdmin || msg.sender == address(0)) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);\n\n        }\n\n\n\n        // Save current values for inclusion in log\n\n        address oldAdmin = admin;\n\n        address oldPendingAdmin = pendingAdmin;\n\n\n\n        // Store admin with value pendingAdmin\n\n        admin = pendingAdmin;\n\n\n\n        // Clear the pending value\n\n        pendingAdmin = address(0);\n\n\n\n        emit NewAdmin(oldAdmin, admin);\n\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
          "message": "Unitroller._acceptAdmin (RBinanceHarness.sol#3091-3114) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 3282,
          "vulnerability_to_line": 3287,
          "vulnerability_code": "    function delegate(address delegatee) public {\n\n        return _delegate(msg.sender, delegatee);\n\n    }\n\n\n\n    /**\n",
          "message": "Rifi.delegate (RBinanceHarness.sol#3282-3287) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 3295,
          "vulnerability_to_line": 3307,
          "vulnerability_code": "    function delegateBySig(address delegatee, uint nonce, uint expiry, uint8 v, bytes32 r, bytes32 s) public {\n\n        bytes32 domainSeparator = keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), getChainId(), address(this)));\n\n        bytes32 structHash = keccak256(abi.encode(DELEGATION_TYPEHASH, delegatee, nonce, expiry));\n\n        bytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n\n        address signatory = ecrecover(digest, v, r, s);\n\n        require(signatory != address(0), \"Rifi::delegateBySig: invalid signature\");\n\n        require(nonce == nonces[signatory]++, \"Rifi::delegateBySig: invalid nonce\");\n\n        require(now <= expiry, \"Rifi::delegateBySig: signature expired\");\n\n        return _delegate(signatory, delegatee);\n\n    }\n\n\n\n    /**\n",
          "message": "Rifi.delegateBySig (RBinanceHarness.sol#3295-3307) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 3323,
          "vulnerability_to_line": 3357,
          "vulnerability_code": "    function getPriorVotes(address account, uint blockNumber) public view returns (uint96) {\n\n        require(blockNumber < block.number, \"Rifi::getPriorVotes: not yet determined\");\n\n\n\n        uint32 nCheckpoints = numCheckpoints[account];\n\n        if (nCheckpoints == 0) {\n\n            return 0;\n\n        }\n\n\n\n        // First check most recent balance\n\n        if (checkpoints[account][nCheckpoints - 1].fromBlock <= blockNumber) {\n\n            return checkpoints[account][nCheckpoints - 1].votes;\n\n        }\n\n\n\n        // Next check implicit zero balance\n\n        if (checkpoints[account][0].fromBlock > blockNumber) {\n\n            return 0;\n\n        }\n\n\n\n        uint32 lower = 0;\n\n        uint32 upper = nCheckpoints - 1;\n\n        while (upper > lower) {\n\n            uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\n\n            Checkpoint memory cp = checkpoints[account][center];\n\n            if (cp.fromBlock == blockNumber) {\n\n                return cp.votes;\n\n            } else if (cp.fromBlock < blockNumber) {\n\n                lower = center;\n\n            } else {\n\n                upper = center - 1;\n\n            }\n\n        }\n\n        return checkpoints[account][lower].votes;\n\n    }\n\n\n",
          "message": "Rifi.getPriorVotes (RBinanceHarness.sol#3323-3357) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 3555,
          "vulnerability_to_line": 3569,
          "vulnerability_code": "    function enterMarkets(address[] memory rTokens) public returns (uint[] memory) {\n\n        uint len = rTokens.length;\n\n\n\n        uint[] memory results = new uint[](len);\n\n        for (uint i = 0; i < len; i++) {\n\n            RToken rToken = RToken(rTokens[i]);\n\n\n\n            results[i] = uint(addToMarketInternal(rToken, msg.sender));\n\n        }\n\n\n\n        return results;\n\n    }\n\n\n\n    /**\n",
          "message": "Cointroller.enterMarkets (RBinanceHarness.sol#3555-3569) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 11,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function enterMarkets(address[] calldata rTokens) external returns (uint[] memory);\n",
          "message": "CointrollerInterface.enterMarkets (RBinanceHarness.sol#11) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 3522,
          "vulnerability_to_line": 3527,
          "vulnerability_code": "    function initialize(address rifi) public {\n\n        require(rifiAddress == address(0), \"RIFI address can only be set once\");\n\n        rifiAddress = rifi;\n\n    }\n\n\n",
          "message": "Cointroller.initialize (RBinanceHarness.sol#3522-3527) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 4104,
          "vulnerability_to_line": 4111,
          "vulnerability_code": "    function getAccountLiquidity(address account) public view returns (uint, uint, uint) {\n\n        (Error err, uint liquidity, uint shortfall) = getHypotheticalAccountLiquidityInternal(account, RToken(0), 0, 0);\n\n\n\n        return (uint(err), liquidity, shortfall);\n\n    }\n\n\n\n    /**\n",
          "message": "Cointroller.getAccountLiquidity (RBinanceHarness.sol#4104-4111) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 4130,
          "vulnerability_to_line": 4140,
          "vulnerability_code": "    function getHypotheticalAccountLiquidity(\n\n        address account,\n\n        address rTokenModify,\n\n        uint redeemTokens,\n\n        uint borrowAmount) public view returns (uint, uint, uint) {\n\n        (Error err, uint liquidity, uint shortfall) = getHypotheticalAccountLiquidityInternal(account, RToken(rTokenModify), redeemTokens, borrowAmount);\n\n        return (uint(err), liquidity, shortfall);\n\n    }\n\n\n\n    /**\n",
          "message": "Cointroller.getHypotheticalAccountLiquidity (RBinanceHarness.sol#4130-4140) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 4253,
          "vulnerability_to_line": 4272,
          "vulnerability_code": "    function _setPriceOracle(PriceOracle newOracle) public returns (uint) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PRICE_ORACLE_OWNER_CHECK);\n\n        }\n\n\n\n        // Track the old oracle for the cointroller\n\n        PriceOracle oldOracle = oracle;\n\n\n\n        // Set cointroller's oracle to newOracle\n\n        oracle = newOracle;\n\n\n\n        // Emit NewPriceOracle(oldOracle, newOracle)\n\n        emit NewPriceOracle(oldOracle, newOracle);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
          "message": "Cointroller._setPriceOracle (RBinanceHarness.sol#4253-4272) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 4431,
          "vulnerability_to_line": 4448,
          "vulnerability_code": "    function _setPauseGuardian(address newPauseGuardian) public returns (uint) {\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PAUSE_GUARDIAN_OWNER_CHECK);\n\n        }\n\n\n\n        // Save current value for inclusion in log\n\n        address oldPauseGuardian = pauseGuardian;\n\n\n\n        // Store pauseGuardian with value newPauseGuardian\n\n        pauseGuardian = newPauseGuardian;\n\n\n\n        // Emit NewPauseGuardian(OldPauseGuardian, NewPauseGuardian)\n\n        emit NewPauseGuardian(oldPauseGuardian, pauseGuardian);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Cointroller._setPauseGuardian (RBinanceHarness.sol#4431-4448) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 4448,
          "vulnerability_to_line": 4458,
          "vulnerability_code": "    function _setMintPaused(RToken rToken, bool state) public returns (bool) {\n\n        require(markets[address(rToken)].isListed, \"cannot pause a market that is not listed\");\n\n        require(msg.sender == pauseGuardian || msg.sender == admin, \"only pause guardian and admin can pause\");\n\n        require(msg.sender == admin || state == true, \"only admin can unpause\");\n\n\n\n        mintGuardianPaused[address(rToken)] = state;\n\n        emit ActionPaused(rToken, \"Mint\", state);\n\n        return state;\n\n    }\n\n\n",
          "message": "Cointroller._setMintPaused (RBinanceHarness.sol#4448-4458) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 4458,
          "vulnerability_to_line": 4468,
          "vulnerability_code": "    function _setBorrowPaused(RToken rToken, bool state) public returns (bool) {\n\n        require(markets[address(rToken)].isListed, \"cannot pause a market that is not listed\");\n\n        require(msg.sender == pauseGuardian || msg.sender == admin, \"only pause guardian and admin can pause\");\n\n        require(msg.sender == admin || state == true, \"only admin can unpause\");\n\n\n\n        borrowGuardianPaused[address(rToken)] = state;\n\n        emit ActionPaused(rToken, \"Borrow\", state);\n\n        return state;\n\n    }\n\n\n",
          "message": "Cointroller._setBorrowPaused (RBinanceHarness.sol#4458-4468) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 4468,
          "vulnerability_to_line": 4477,
          "vulnerability_code": "    function _setTransferPaused(bool state) public returns (bool) {\n\n        require(msg.sender == pauseGuardian || msg.sender == admin, \"only pause guardian and admin can pause\");\n\n        require(msg.sender == admin || state == true, \"only admin can unpause\");\n\n\n\n        transferGuardianPaused = state;\n\n        emit ActionPaused(\"Transfer\", state);\n\n        return state;\n\n    }\n\n\n",
          "message": "Cointroller._setTransferPaused (RBinanceHarness.sol#4468-4477) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 4477,
          "vulnerability_to_line": 4486,
          "vulnerability_code": "    function _setSeizePaused(bool state) public returns (bool) {\n\n        require(msg.sender == pauseGuardian || msg.sender == admin, \"only pause guardian and admin can pause\");\n\n        require(msg.sender == admin || state == true, \"only admin can unpause\");\n\n\n\n        seizeGuardianPaused = state;\n\n        emit ActionPaused(\"Seize\", state);\n\n        return state;\n\n    }\n\n\n",
          "message": "Cointroller._setSeizePaused (RBinanceHarness.sol#4477-4486) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 4486,
          "vulnerability_to_line": 4492,
          "vulnerability_code": "    function _become(Unitroller unitroller) public {\n\n        require(msg.sender == unitroller.admin(), \"only unitroller admin can change brains\");\n\n        require(unitroller._acceptImplementation() == 0, \"change not authorized\");\n\n    }\n\n\n\n    /**\n",
          "message": "Cointroller._become (RBinanceHarness.sol#4486-4492) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 4650,
          "vulnerability_to_line": 4655,
          "vulnerability_code": "    function claimRifi(address holder) public {\n\n        return claimRifi(holder, allMarkets);\n\n    }\n\n\n\n    /**\n",
          "message": "Cointroller.claimRifi (RBinanceHarness.sol#4650-4655) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 4719,
          "vulnerability_to_line": 4727,
          "vulnerability_code": "    function _grantRifi(address recipient, uint amount) public {\n\n        require(adminOrInitializing(), \"only admin can grant rifi\");\n\n        uint amountLeft = grantRifiInternal(recipient, amount);\n\n        require(amountLeft == 0, \"insufficient rifi for grant\");\n\n        emit RifiGranted(recipient, amount);\n\n    }\n\n\n\n    /**\n",
          "message": "Cointroller._grantRifi (RBinanceHarness.sol#4719-4727) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 4731,
          "vulnerability_to_line": 4737,
          "vulnerability_code": "    function _setRifiSpeed(RToken rToken, uint rifiSpeed) public {\n\n        require(adminOrInitializing(), \"only admin can set rifi speed\");\n\n        setRifiSpeedInternal(rToken, rifiSpeed);\n\n    }\n\n\n\n    /**\n",
          "message": "Cointroller._setRifiSpeed (RBinanceHarness.sol#4731-4737) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 4741,
          "vulnerability_to_line": 4758,
          "vulnerability_code": "    function _setContributorRifiSpeed(address contributor, uint rifiSpeed) public {\n\n        require(adminOrInitializing(), \"only admin can set rifi speed\");\n\n\n\n        // note that RIFI speed could be set to 0 to halt liquidity rewards for a contributor\n\n        updateContributorRewards(contributor);\n\n        if (rifiSpeed == 0) {\n\n            // release storage\n\n            delete lastContributorBlock[contributor];\n\n        } else {\n\n            lastContributorBlock[contributor] = getBlockNumber();\n\n        }\n\n        rifiContributorSpeeds[contributor] = rifiSpeed;\n\n\n\n        emit ContributorRifiSpeedUpdated(contributor, rifiSpeed);\n\n    }\n\n\n\n    /**\n",
          "message": "Cointroller._setContributorRifiSpeed (RBinanceHarness.sol#4741-4758) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 4762,
          "vulnerability_to_line": 4766,
          "vulnerability_code": "    function getAllMarkets() public view returns (RToken[] memory) {\n\n        return allMarkets;\n\n    }\n\n\n",
          "message": "Cointroller.getAllMarkets (RBinanceHarness.sol#4762-4766) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 4789,
          "vulnerability_to_line": 4794,
          "vulnerability_code": "    function fastForward(uint blocks) public returns (uint) {\n\n        blockNumber += blocks;\n\n        return blockNumber;\n\n    }\n\n\n",
          "message": "CointrollerScenario.fastForward (RBinanceHarness.sol#4789-4794) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 4794,
          "vulnerability_to_line": 4798,
          "vulnerability_code": "    function setRifiAddress(address rifiAddress_) public {\n\n        rifiAddress = rifiAddress_;\n\n    }\n\n\n",
          "message": "CointrollerScenario.setRifiAddress (RBinanceHarness.sol#4794-4798) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 4802,
          "vulnerability_to_line": 4806,
          "vulnerability_code": "    function setBlockNumber(uint number) public {\n\n        blockNumber = number;\n\n    }\n\n\n",
          "message": "CointrollerScenario.setBlockNumber (RBinanceHarness.sol#4802-4806) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 4810,
          "vulnerability_to_line": 4814,
          "vulnerability_code": "    function membershipLength(RToken rToken) public view returns (uint) {\n\n        return accountAssets[address(rToken)].length;\n\n    }\n\n\n",
          "message": "CointrollerScenario.membershipLength (RBinanceHarness.sol#4810-4814) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 4814,
          "vulnerability_to_line": 4819,
          "vulnerability_code": "    function unlist(RToken rToken) public {\n\n        markets[address(rToken)].isListed = false;\n\n    }\n\n\n\n    /**\n",
          "message": "CointrollerScenario.unlist (RBinanceHarness.sol#4814-4819) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 4821,
          "vulnerability_to_line": 4851,
          "vulnerability_code": "    function refreshRifiSpeeds() public {\n\n        RToken[] memory allMarkets_ = allMarkets;\n\n\n\n        for (uint i = 0; i < allMarkets_.length; i++) {\n\n            RToken rToken = allMarkets_[i];\n\n            Exp memory borrowIndex = Exp({mantissa: rToken.borrowIndex()});\n\n            updateRifiSupplyIndex(address(rToken));\n\n            updateRifiBorrowIndex(address(rToken), borrowIndex);\n\n        }\n\n\n\n        Exp memory totalUtility = Exp({mantissa: 0});\n\n        Exp[] memory utilities = new Exp[](allMarkets_.length);\n\n        for (uint i = 0; i < allMarkets_.length; i++) {\n\n            RToken rToken = allMarkets_[i];\n\n            if (rifiSpeeds[address(rToken)] > 0) {\n\n                Exp memory assetPrice = Exp({mantissa: oracle.getUnderlyingPrice(rToken)});\n\n                Exp memory utility = mul_(assetPrice, rToken.totalBorrows());\n\n                utilities[i] = utility;\n\n                totalUtility = add_(totalUtility, utility);\n\n            }\n\n        }\n\n\n\n        for (uint i = 0; i < allMarkets_.length; i++) {\n\n            RToken rToken = allMarkets[i];\n\n            uint newSpeed = totalUtility.mantissa > 0 ? mul_(rifiRate, div_(utilities[i], totalUtility)) : 0;\n\n            setRifiSpeedInternal(rToken, newSpeed);\n\n        }\n\n    }\n\n}\n\n\n",
          "message": "CointrollerScenario.refreshRifiSpeeds (RBinanceHarness.sol#4821-4851) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 4894,
          "vulnerability_to_line": 4898,
          "vulnerability_code": "    function harnessSetBlockNumber(uint newBlockNumber) public {\n\n        blockNumber = newBlockNumber;\n\n    }\n\n\n",
          "message": "RBinanceHarness.harnessSetBlockNumber (RBinanceHarness.sol#4894-4898) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 4898,
          "vulnerability_to_line": 4902,
          "vulnerability_code": "    function harnessFastForward(uint blocks) public {\n\n        blockNumber += blocks;\n\n    }\n\n\n",
          "message": "RBinanceHarness.harnessFastForward (RBinanceHarness.sol#4898-4902) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 4906,
          "vulnerability_to_line": 4910,
          "vulnerability_code": "    function harnessSetAccrualBlockNumber(uint _accrualblockNumber) public {\n\n        accrualBlockNumber = _accrualblockNumber;\n\n    }\n\n\n",
          "message": "RBinanceHarness.harnessSetAccrualBlockNumber (RBinanceHarness.sol#4906-4910) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 4910,
          "vulnerability_to_line": 4914,
          "vulnerability_code": "    function harnessSetTotalSupply(uint totalSupply_) public {\n\n        totalSupply = totalSupply_;\n\n    }\n\n\n",
          "message": "RBinanceHarness.harnessSetTotalSupply (RBinanceHarness.sol#4910-4914) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 4914,
          "vulnerability_to_line": 4918,
          "vulnerability_code": "    function harnessSetTotalBorrows(uint totalBorrows_) public {\n\n        totalBorrows = totalBorrows_;\n\n    }\n\n\n",
          "message": "RBinanceHarness.harnessSetTotalBorrows (RBinanceHarness.sol#4914-4918) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 4918,
          "vulnerability_to_line": 4922,
          "vulnerability_code": "    function harnessSetTotalReserves(uint totalReserves_) public {\n\n        totalReserves = totalReserves_;\n\n    }\n\n\n",
          "message": "RBinanceHarness.harnessSetTotalReserves (RBinanceHarness.sol#4918-4922) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 4922,
          "vulnerability_to_line": 4928,
          "vulnerability_code": "    function harnessExchangeRateDetails(uint _totalSupply, uint _totalBorrows, uint _totalReserves) public {\n\n        totalSupply = _totalSupply;\n\n        totalBorrows = _totalBorrows;\n\n        totalReserves = _totalReserves;\n\n    }\n\n\n",
          "message": "RBinanceHarness.harnessExchangeRateDetails (RBinanceHarness.sol#4922-4928) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 4928,
          "vulnerability_to_line": 4932,
          "vulnerability_code": "    function harnessSetExchangeRate(uint exchangeRate) public {\n\n        harnessExchangeRate = exchangeRate;\n\n    }\n\n\n",
          "message": "RBinanceHarness.harnessSetExchangeRate (RBinanceHarness.sol#4928-4932) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 4932,
          "vulnerability_to_line": 4936,
          "vulnerability_code": "    function harnessSetFailTransferToAddress(address _to, bool _fail) public {\n\n        failTransferToAddresses[_to] = _fail;\n\n    }\n\n\n",
          "message": "RBinanceHarness.harnessSetFailTransferToAddress (RBinanceHarness.sol#4932-4936) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 4936,
          "vulnerability_to_line": 4941,
          "vulnerability_code": "    function harnessMintFresh(address account, uint mintAmount) public returns (uint) {\n\n        (uint err,) = super.mintFresh(account, mintAmount);\n\n        return err;\n\n    }\n\n\n",
          "message": "RBinanceHarness.harnessMintFresh (RBinanceHarness.sol#4936-4941) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 4941,
          "vulnerability_to_line": 4945,
          "vulnerability_code": "    function harnessRedeemFresh(address payable account, uint rTokenAmount, uint underlyingAmount) public returns (uint) {\n\n        return super.redeemFresh(account, rTokenAmount, underlyingAmount);\n\n    }\n\n\n",
          "message": "RBinanceHarness.harnessRedeemFresh (RBinanceHarness.sol#4941-4945) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 4945,
          "vulnerability_to_line": 4950,
          "vulnerability_code": "    function harnessAccountBorrows(address account) public view returns (uint principal, uint interestIndex) {\n\n        BorrowSnapshot memory snapshot = accountBorrows[account];\n\n        return (snapshot.principal, snapshot.interestIndex);\n\n    }\n\n\n",
          "message": "RBinanceHarness.harnessAccountBorrows (RBinanceHarness.sol#4945-4950) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 4950,
          "vulnerability_to_line": 4954,
          "vulnerability_code": "    function harnessSetAccountBorrows(address account, uint principal, uint interestIndex) public {\n\n        accountBorrows[account] = BorrowSnapshot({principal: principal, interestIndex: interestIndex});\n\n    }\n\n\n",
          "message": "RBinanceHarness.harnessSetAccountBorrows (RBinanceHarness.sol#4950-4954) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 4954,
          "vulnerability_to_line": 4958,
          "vulnerability_code": "    function harnessSetBorrowIndex(uint borrowIndex_) public {\n\n        borrowIndex = borrowIndex_;\n\n    }\n\n\n",
          "message": "RBinanceHarness.harnessSetBorrowIndex (RBinanceHarness.sol#4954-4958) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 4958,
          "vulnerability_to_line": 4962,
          "vulnerability_code": "    function harnessBorrowFresh(address payable account, uint borrowAmount) public returns (uint) {\n\n        return borrowFresh(account, borrowAmount);\n\n    }\n\n\n",
          "message": "RBinanceHarness.harnessBorrowFresh (RBinanceHarness.sol#4958-4962) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 4962,
          "vulnerability_to_line": 4967,
          "vulnerability_code": "    function harnessRepayBorrowFresh(address payer, address account, uint repayBorrowAmount) public payable returns (uint) {\n\n        (uint err,) = repayBorrowFresh(payer, account, repayBorrowAmount);\n\n        return err;\n\n    }\n\n\n",
          "message": "RBinanceHarness.harnessRepayBorrowFresh (RBinanceHarness.sol#4962-4967) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 4967,
          "vulnerability_to_line": 4972,
          "vulnerability_code": "    function harnessLiquidateBorrowFresh(address liquidator, address borrower, uint repayAmount, RToken rTokenCollateral) public returns (uint) {\n\n        (uint err,) = liquidateBorrowFresh(liquidator, borrower, repayAmount, rTokenCollateral);\n\n        return err;\n\n    }\n\n\n",
          "message": "RBinanceHarness.harnessLiquidateBorrowFresh (RBinanceHarness.sol#4967-4972) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 4972,
          "vulnerability_to_line": 4976,
          "vulnerability_code": "    function harnessReduceReservesFresh(uint amount) public returns (uint) {\n\n        return _reduceReservesFresh(amount);\n\n    }\n\n\n",
          "message": "RBinanceHarness.harnessReduceReservesFresh (RBinanceHarness.sol#4972-4976) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 4976,
          "vulnerability_to_line": 4980,
          "vulnerability_code": "    function harnessSetReserves(uint amount) public {\n\n        totalReserves = amount;\n\n    }\n\n\n",
          "message": "RBinanceHarness.harnessSetReserves (RBinanceHarness.sol#4976-4980) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 4980,
          "vulnerability_to_line": 4984,
          "vulnerability_code": "    function harnessSetReserveFactorFresh(uint newReserveFactorMantissa) public returns (uint) {\n\n        return _setReserveFactorFresh(newReserveFactorMantissa);\n\n    }\n\n\n",
          "message": "RBinanceHarness.harnessSetReserveFactorFresh (RBinanceHarness.sol#4980-4984) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 4984,
          "vulnerability_to_line": 4988,
          "vulnerability_code": "    function harnessSetInterestRateModelFresh(InterestRateModel newInterestRateModel) public returns (uint) {\n\n        return _setInterestRateModelFresh(newInterestRateModel);\n\n    }\n\n\n",
          "message": "RBinanceHarness.harnessSetInterestRateModelFresh (RBinanceHarness.sol#4984-4988) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 4988,
          "vulnerability_to_line": 4992,
          "vulnerability_code": "    function harnessSetInterestRateModel(address newInterestRateModelAddress) public {\n\n        interestRateModel = InterestRateModel(newInterestRateModelAddress);\n\n    }\n\n\n",
          "message": "RBinanceHarness.harnessSetInterestRateModel (RBinanceHarness.sol#4988-4992) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 4992,
          "vulnerability_to_line": 4996,
          "vulnerability_code": "    function harnessGetCashPrior() public payable returns (uint) {\n\n        return getCashPrior();\n\n    }\n\n\n",
          "message": "RBinanceHarness.harnessGetCashPrior (RBinanceHarness.sol#4992-4996) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 4996,
          "vulnerability_to_line": 5000,
          "vulnerability_code": "    function harnessDoTransferIn(address from, uint amount) public payable returns (uint) {\n\n        return doTransferIn(from, amount);\n\n    }\n\n\n",
          "message": "RBinanceHarness.harnessDoTransferIn (RBinanceHarness.sol#4996-5000) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 5000,
          "vulnerability_to_line": 5004,
          "vulnerability_code": "    function harnessDoTransferOut(address payable to, uint amount) public payable {\n\n        return doTransferOut(to, amount);\n\n    }\n\n\n",
          "message": "RBinanceHarness.harnessDoTransferOut (RBinanceHarness.sol#5000-5004) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 5028,
          "vulnerability_to_line": 5032,
          "vulnerability_code": "    function setTotalBorrows(uint totalBorrows_) public {\n\n        totalBorrows = totalBorrows_;\n\n    }\n\n\n",
          "message": "RBinanceScenario.setTotalBorrows (RBinanceHarness.sol#5028-5032) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 5032,
          "vulnerability_to_line": 5036,
          "vulnerability_code": "    function setTotalReserves(uint totalReserves_) public {\n\n        totalReserves = totalReserves_;\n\n    }\n\n\n",
          "message": "RBinanceScenario.setTotalReserves (RBinanceHarness.sol#5032-5036) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 5036,
          "vulnerability_to_line": 5040,
          "vulnerability_code": "    function donate() public payable {\n\n        // no-op\n\n    }\n\n\n",
          "message": "RBinanceScenario.donate (RBinanceHarness.sol#5036-5040) should be declared external\n"
        },
        {
          "name": "solc-version",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": "Detected issues with version pragma in RBinanceHarness.sol:\n\t- pragma solidity^0.5.16 (RBinanceHarness.sol#3): it allows old versions\n\t- pragma solidity^0.5.16 (RBinanceHarness.sol#77): it allows old versions\n\t- pragma solidity^0.5.16 (RBinanceHarness.sol#110): it allows old versions\n\t- pragma solidity^0.5.16 (RBinanceHarness.sol#183): it allows old versions\n\t- pragma solidity^0.5.16 (RBinanceHarness.sol#488): it allows old versions\n\t- pragma solidity^0.5.16 (RBinanceHarness.sol#698): it allows old versions\n\t- pragma solidity^0.5.16 (RBinanceHarness.sol#786): it allows old versions\n\t- pragma solidity^0.5.16 (RBinanceHarness.sol#984): it allows old versions\n\t- pragma solidity^0.5.16 (RBinanceHarness.sol#1168): it allows old versions\n\t- pragma solidity^0.5.16 (RBinanceHarness.sol#1233): it allows old versions\n\t- pragma solidity^0.5.16 (RBinanceHarness.sol#2668-2671): it allows old versions\n\t- pragma solidity^0.5.16 (RBinanceHarness.sol#2837-2839): it allows old versions\n\t- pragma solidity^0.5.16 (RBinanceHarness.sol#2854-2857): it allows old versions\n\t- pragma solidity^0.5.16 (RBinanceHarness.sol#2985-2988): it allows old versions\n\t- pragma solidity^0.5.16 (RBinanceHarness.sol#3135-3136): it allows old versions\n\t- pragma solidity^0.5.16 (RBinanceHarness.sol#3439-3447): it allows old versions\n\t- pragma solidity^0.5.16 (RBinanceHarness.sol#4781-4783): it allows old versions\n\t- pragma solidity^0.5.16 (RBinanceHarness.sol#4853-4856): it allows old versions\n"
        },
        {
          "name": "low-level-calls",
          "vulnerability_from_line": 3118,
          "vulnerability_to_line": 3133,
          "vulnerability_code": "    function () payable external {\n\n        // delegate all other functions to current implementation\n\n        (bool success, ) = cointrollerImplementation.delegatecall(msg.data);\n\n\n\n        assembly {\n\n              let free_mem_ptr := mload(0x40)\n\n              returndatacopy(free_mem_ptr, 0, returndatasize)\n\n\n\n              switch success\n\n              case 0 { revert(free_mem_ptr, returndatasize) }\n\n              default { return(free_mem_ptr, returndatasize) }\n\n        }\n\n    }\n\n}\n\n\n",
          "message": "Low level call in Unitroller.fallback (RBinanceHarness.sol#3118-3133):\n\t-(success) = cointrollerImplementation.delegatecall(msg.data) RBinanceHarness.sol#3120-3122\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 7,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bool public constant isCointroller = true;\n",
          "message": "Constant 'CointrollerInterface.isCointroller' (RBinanceHarness.sol#7) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 85,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bool public constant isInterestRateModel = true;\n",
          "message": "Constant 'InterestRateModel.isInterestRateModel' (RBinanceHarness.sol#85) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 191,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bool internal _notEntered;\n",
          "message": "Variable 'RTokenStorage._notEntered' (RBinanceHarness.sol#191) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 212,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint internal constant borrowRateMaxMantissa = 0.0005e16;\n",
          "message": "Constant 'RTokenStorage.borrowRateMaxMantissa' (RBinanceHarness.sol#212) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 217,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint internal constant reserveFactorMaxMantissa = 1e18;\n",
          "message": "Constant 'RTokenStorage.reserveFactorMaxMantissa' (RBinanceHarness.sol#217) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 416,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint);\n",
          "message": "Function 'RTokenInterface._setPendingAdmin' (RBinanceHarness.sol#416) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 417,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _acceptAdmin() external returns (uint);\n",
          "message": "Function 'RTokenInterface._acceptAdmin' (RBinanceHarness.sol#417) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 418,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setCointroller(CointrollerInterface newCointroller) public returns (uint);\n",
          "message": "Function 'RTokenInterface._setCointroller' (RBinanceHarness.sol#418) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 419,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setReserveFactor(uint newReserveFactorMantissa) external returns (uint);\n",
          "message": "Function 'RTokenInterface._setReserveFactor' (RBinanceHarness.sol#419) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 420,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _reduceReserves(uint reduceAmount) external returns (uint);\n",
          "message": "Function 'RTokenInterface._reduceReserves' (RBinanceHarness.sol#420) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 421,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint);\n",
          "message": "Function 'RTokenInterface._setInterestRateModel' (RBinanceHarness.sol#421) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 304,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bool public constant isRToken = true;\n",
          "message": "Constant 'RTokenInterface.isRToken' (RBinanceHarness.sol#304) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 447,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _addReserves(uint addAmount) external returns (uint);\n",
          "message": "Function 'RBep20Interface._addReserves' (RBinanceHarness.sol#447) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 469,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setImplementation(address implementation_, bool allowResign, bytes memory becomeImplementationData) public;\n",
          "message": "Function 'RDelegatorInterface._setImplementation' (RBinanceHarness.sol#469) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 478,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _becomeImplementation(bytes memory data) public;\n",
          "message": "Function 'RDelegateInterface._becomeImplementation' (RBinanceHarness.sol#478) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 483,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _resignImplementation() public;\n",
          "message": "Function 'RDelegateInterface._resignImplementation' (RBinanceHarness.sol#483) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 821,
          "vulnerability_to_line": 824,
          "vulnerability_code": "    function mul_ScalarTruncate(Exp memory a, uint scalar) pure internal returns (uint) {\n\n        Exp memory product = mul_(a, scalar);\n\n        return truncate(product);\n",
          "message": "Function 'ExponentialNoError.mul_ScalarTruncate' (RBinanceHarness.sol#821-824) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 829,
          "vulnerability_to_line": 832,
          "vulnerability_code": "    function mul_ScalarTruncateAddUInt(Exp memory a, uint scalar, uint addend) pure internal returns (uint) {\n\n        Exp memory product = mul_(a, scalar);\n\n        return add_(truncate(product), addend);\n",
          "message": "Function 'ExponentialNoError.mul_ScalarTruncateAddUInt' (RBinanceHarness.sol#829-832) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 796,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint constant expScale = 1e18;\n",
          "message": "Constant 'ExponentialNoError.expScale' (RBinanceHarness.sol#796) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 797,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint constant doubleScale = 1e36;\n",
          "message": "Constant 'ExponentialNoError.doubleScale' (RBinanceHarness.sol#797) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 798,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint constant halfExpScale = expScale/2;\n",
          "message": "Constant 'ExponentialNoError.halfExpScale' (RBinanceHarness.sol#798) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 799,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint constant mantissaOne = expScale;\n",
          "message": "Constant 'ExponentialNoError.mantissaOne' (RBinanceHarness.sol#799) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 2338,
          "vulnerability_to_line": 2354,
          "vulnerability_code": "    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint) {\n\n        // Check caller = admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);\n\n        }\n\n\n\n        // Save current value, if any, for inclusion in log\n\n        address oldPendingAdmin = pendingAdmin;\n\n\n\n        // Store pendingAdmin with value newPendingAdmin\n\n        pendingAdmin = newPendingAdmin;\n\n\n\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\n\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n\n\n\n        return uint(Error.NO_ERROR);\n",
          "message": "Function 'RToken._setPendingAdmin' (RBinanceHarness.sol#2338-2354) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 2361,
          "vulnerability_to_line": 2383,
          "vulnerability_code": "    function _acceptAdmin() external returns (uint) {\n\n        // Check caller is pendingAdmin and pendingAdmin \u2260 address(0)\n\n        if (msg.sender != pendingAdmin || msg.sender == address(0)) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);\n\n        }\n\n\n\n        // Save current values for inclusion in log\n\n        address oldAdmin = admin;\n\n        address oldPendingAdmin = pendingAdmin;\n\n\n\n        // Store admin with value pendingAdmin\n\n        admin = pendingAdmin;\n\n\n\n        // Clear the pending value\n\n        pendingAdmin = address(0);\n\n\n\n        emit NewAdmin(oldAdmin, admin);\n\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Function 'RToken._acceptAdmin' (RBinanceHarness.sol#2361-2383) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 2388,
          "vulnerability_to_line": 2407,
          "vulnerability_code": "    function _setCointroller(CointrollerInterface newCointroller) public returns (uint) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COINTROLLER_OWNER_CHECK);\n\n        }\n\n\n\n        CointrollerInterface oldCointroller = cointroller;\n\n        // Ensure invoke cointroller.isCointroller() returns true\n\n        require(newCointroller.isCointroller(), \"marker method returned false\");\n\n\n\n        // Set market's cointroller to newCointroller\n\n        cointroller = newCointroller;\n\n\n\n        // Emit NewCointroller(oldCointroller, newCointroller)\n\n        emit NewCointroller(oldCointroller, newCointroller);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Function 'RToken._setCointroller' (RBinanceHarness.sol#2388-2407) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 2412,
          "vulnerability_to_line": 2422,
          "vulnerability_code": "    function _setReserveFactor(uint newReserveFactorMantissa) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.\n\n            return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.\n\n        return _setReserveFactorFresh(newReserveFactorMantissa);\n\n    }\n\n\n",
          "message": "Function 'RToken._setReserveFactor' (RBinanceHarness.sol#2412-2422) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 2519,
          "vulnerability_to_line": 2529,
          "vulnerability_code": "    function _reduceReserves(uint reduceAmount) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n\n            return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.\n\n        return _reduceReservesFresh(reduceAmount);\n\n    }\n\n\n",
          "message": "Function 'RToken._reduceReserves' (RBinanceHarness.sol#2519-2529) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 2584,
          "vulnerability_to_line": 2594,
          "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n\n        return _setInterestRateModelFresh(newInterestRateModel);\n\n    }\n\n\n",
          "message": "Function 'RToken._setInterestRateModel' (RBinanceHarness.sol#2584-2594) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 2427,
          "vulnerability_to_line": 2451,
          "vulnerability_code": "    function _setReserveFactorFresh(uint newReserveFactorMantissa) internal returns (uint) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_RESERVE_FACTOR_ADMIN_CHECK);\n\n        }\n\n\n\n        // Verify market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_RESERVE_FACTOR_FRESH_CHECK);\n\n        }\n\n\n\n        // Check newReserveFactor \u2264 maxReserveFactor\n\n        if (newReserveFactorMantissa > reserveFactorMaxMantissa) {\n\n            return fail(Error.BAD_INPUT, FailureInfo.SET_RESERVE_FACTOR_BOUNDS_CHECK);\n\n        }\n\n\n\n        uint oldReserveFactorMantissa = reserveFactorMantissa;\n\n        reserveFactorMantissa = newReserveFactorMantissa;\n\n\n\n        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Function 'RToken._setReserveFactorFresh' (RBinanceHarness.sol#2427-2451) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 2456,
          "vulnerability_to_line": 2468,
          "vulnerability_code": "    function _addReservesInternal(uint addAmount) internal nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n\n            return fail(Error(error), FailureInfo.ADD_RESERVES_ACCRUE_INTEREST_FAILED);\n\n        }\n\n\n\n        // _addReservesFresh emits reserve-addition-specific logs on errors, so we don't need to.\n\n        (error, ) = _addReservesFresh(addAmount);\n\n        return error;\n\n    }\n\n\n",
          "message": "Function 'RToken._addReservesInternal' (RBinanceHarness.sol#2456-2468) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 2474,
          "vulnerability_to_line": 2514,
          "vulnerability_code": "    function _addReservesFresh(uint addAmount) internal returns (uint, uint) {\n\n        // totalReserves + actualAddAmount\n\n        uint totalReservesNew;\n\n        uint actualAddAmount;\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return (fail(Error.MARKET_NOT_FRESH, FailureInfo.ADD_RESERVES_FRESH_CHECK), actualAddAmount);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We call doTransferIn for the caller and the addAmount\n\n         *  Note: The rToken must handle variations between BEP-20 and ETH underlying.\n\n         *  On success, the rToken holds an additional addAmount of cash.\n\n         *  doTransferIn reverts if anything goes wrong, since we can't be sure if side effects occurred.\n\n         *  it returns the amount actually transferred, in case of a fee.\n\n         */\n\n\n\n        actualAddAmount = doTransferIn(msg.sender, addAmount);\n\n\n\n        totalReservesNew = totalReserves + actualAddAmount;\n\n\n\n        /* Revert on overflow */\n\n        require(totalReservesNew >= totalReserves, \"add reserves unexpected overflow\");\n\n\n\n        // Store reserves[n+1] = reserves[n] + actualAddAmount\n\n        totalReserves = totalReservesNew;\n\n\n\n        /* Emit NewReserves(admin, actualAddAmount, reserves[n+1]) */\n\n        emit ReservesAdded(msg.sender, actualAddAmount, totalReservesNew);\n\n\n\n        /* Return (NO_ERROR, actualAddAmount) */\n\n        return (uint(Error.NO_ERROR), actualAddAmount);\n\n    }\n\n\n\n\n",
          "message": "Function 'RToken._addReservesFresh' (RBinanceHarness.sol#2474-2514) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 2535,
          "vulnerability_to_line": 2578,
          "vulnerability_code": "    function _reduceReservesFresh(uint reduceAmount) internal returns (uint) {\n\n        // totalReserves - reduceAmount\n\n        uint totalReservesNew;\n\n\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.REDUCE_RESERVES_ADMIN_CHECK);\n\n        }\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDUCE_RESERVES_FRESH_CHECK);\n\n        }\n\n\n\n        // Fail gracefully if protocol has insufficient underlying cash\n\n        if (getCashPrior() < reduceAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDUCE_RESERVES_CASH_NOT_AVAILABLE);\n\n        }\n\n\n\n        // Check reduceAmount \u2264 reserves[n] (totalReserves)\n\n        if (reduceAmount > totalReserves) {\n\n            return fail(Error.BAD_INPUT, FailureInfo.REDUCE_RESERVES_VALIDATION);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        totalReservesNew = totalReserves - reduceAmount;\n\n        // We checked reduceAmount <= totalReserves above, so this should never revert.\n\n        require(totalReservesNew <= totalReserves, \"reduce reserves unexpected underflow\");\n\n\n\n        // Store reserves[n+1] = reserves[n] - reduceAmount\n\n        totalReserves = totalReservesNew;\n\n\n\n        // doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n\n        doTransferOut(admin, reduceAmount);\n\n\n\n        emit ReservesReduced(admin, reduceAmount, totalReservesNew);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Function 'RToken._reduceReservesFresh' (RBinanceHarness.sol#2535-2578) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 2600,
          "vulnerability_to_line": 2630,
          "vulnerability_code": "    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {\n\n\n\n        // Used to store old model for use in the event that is emitted on success\n\n        InterestRateModel oldInterestRateModel;\n\n\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);\n\n        }\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);\n\n        }\n\n\n\n        // Track the market's current interest rate model\n\n        oldInterestRateModel = interestRateModel;\n\n\n\n        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true\n\n        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n\n\n\n        // Set the interest rate model to newInterestRateModel\n\n        interestRateModel = newInterestRateModel;\n\n\n\n        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)\n\n        emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Function 'RToken._setInterestRateModelFresh' (RBinanceHarness.sol#2600-2630) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 2841,
          "vulnerability_to_line": 2843,
          "vulnerability_code": "    bool public constant isPriceOracle = true;\n\n\n",
          "message": "Constant 'PriceOracle.isPriceOracle' (RBinanceHarness.sol#2841-2843) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 2932,
          "vulnerability_to_line": 2933,
          "vulnerability_code": "    bool public _mintGuardianPaused;\n",
          "message": "Variable 'CointrollerStorage._mintGuardianPaused' (RBinanceHarness.sol#2932-2933) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 2933,
          "vulnerability_to_line": 2934,
          "vulnerability_code": "    bool public _borrowGuardianPaused;\n",
          "message": "Variable 'CointrollerStorage._borrowGuardianPaused' (RBinanceHarness.sol#2933-2934) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 3021,
          "vulnerability_to_line": 3036,
          "vulnerability_code": "    function _setPendingImplementation(address newPendingImplementation) public returns (uint) {\n\n\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_IMPLEMENTATION_OWNER_CHECK);\n\n        }\n\n\n\n        address oldPendingImplementation = pendingCointrollerImplementation;\n\n\n\n        pendingCointrollerImplementation = newPendingImplementation;\n\n\n\n        emit NewPendingImplementation(oldPendingImplementation, pendingCointrollerImplementation);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Function 'Unitroller._setPendingImplementation' (RBinanceHarness.sol#3021-3036) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 3041,
          "vulnerability_to_line": 3062,
          "vulnerability_code": "    function _acceptImplementation() public returns (uint) {\n\n        // Check caller is pendingImplementation and pendingImplementation \u2260 address(0)\n\n        if (msg.sender != pendingCointrollerImplementation || pendingCointrollerImplementation == address(0)) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_PENDING_IMPLEMENTATION_ADDRESS_CHECK);\n\n        }\n\n\n\n        // Save current values for inclusion in log\n\n        address oldImplementation = cointrollerImplementation;\n\n        address oldPendingImplementation = pendingCointrollerImplementation;\n\n\n\n        cointrollerImplementation = pendingCointrollerImplementation;\n\n\n\n        pendingCointrollerImplementation = address(0);\n\n\n\n        emit NewImplementation(oldImplementation, cointrollerImplementation);\n\n        emit NewPendingImplementation(oldPendingImplementation, pendingCointrollerImplementation);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n\n",
          "message": "Function 'Unitroller._acceptImplementation' (RBinanceHarness.sol#3041-3062) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 3068,
          "vulnerability_to_line": 3086,
          "vulnerability_code": "    function _setPendingAdmin(address newPendingAdmin) public returns (uint) {\n\n        // Check caller = admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);\n\n        }\n\n\n\n        // Save current value, if any, for inclusion in log\n\n        address oldPendingAdmin = pendingAdmin;\n\n\n\n        // Store pendingAdmin with value newPendingAdmin\n\n        pendingAdmin = newPendingAdmin;\n\n\n\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\n\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Function 'Unitroller._setPendingAdmin' (RBinanceHarness.sol#3068-3086) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 3091,
          "vulnerability_to_line": 3114,
          "vulnerability_code": "    function _acceptAdmin() public returns (uint) {\n\n        // Check caller is pendingAdmin and pendingAdmin \u2260 address(0)\n\n        if (msg.sender != pendingAdmin || msg.sender == address(0)) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);\n\n        }\n\n\n\n        // Save current values for inclusion in log\n\n        address oldAdmin = admin;\n\n        address oldPendingAdmin = pendingAdmin;\n\n\n\n        // Store admin with value pendingAdmin\n\n        admin = pendingAdmin;\n\n\n\n        // Clear the pending value\n\n        pendingAdmin = address(0);\n\n\n\n        emit NewAdmin(oldAdmin, admin);\n\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
          "message": "Function 'Unitroller._acceptAdmin' (RBinanceHarness.sol#3091-3114) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 3357,
          "vulnerability_to_line": 3367,
          "vulnerability_code": "    function _delegate(address delegator, address delegatee) internal {\n\n        address currentDelegate = delegates[delegator];\n\n        uint96 delegatorBalance = balances[delegator];\n\n        delegates[delegator] = delegatee;\n\n\n\n        emit DelegateChanged(delegator, currentDelegate, delegatee);\n\n\n\n        _moveDelegates(currentDelegate, delegatee, delegatorBalance);\n\n    }\n\n\n",
          "message": "Function 'Rifi._delegate' (RBinanceHarness.sol#3357-3367) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 3367,
          "vulnerability_to_line": 3378,
          "vulnerability_code": "    function _transferTokens(address src, address dst, uint96 amount) internal {\n\n        require(src != address(0), \"Rifi::_transferTokens: cannot transfer from the zero address\");\n\n        require(dst != address(0), \"Rifi::_transferTokens: cannot transfer to the zero address\");\n\n\n\n        balances[src] = sub96(balances[src], amount, \"Rifi::_transferTokens: transfer amount exceeds balance\");\n\n        balances[dst] = add96(balances[dst], amount, \"Rifi::_transferTokens: transfer amount overflows\");\n\n        emit Transfer(src, dst, amount);\n\n\n\n        _moveDelegates(delegates[src], delegates[dst], amount);\n\n    }\n\n\n",
          "message": "Function 'Rifi._transferTokens' (RBinanceHarness.sol#3367-3378) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 3378,
          "vulnerability_to_line": 3396,
          "vulnerability_code": "    function _moveDelegates(address srcRep, address dstRep, uint96 amount) internal {\n\n        if (srcRep != dstRep && amount > 0) {\n\n            if (srcRep != address(0)) {\n\n                uint32 srcRepNum = numCheckpoints[srcRep];\n\n                uint96 srcRepOld = srcRepNum > 0 ? checkpoints[srcRep][srcRepNum - 1].votes : 0;\n\n                uint96 srcRepNew = sub96(srcRepOld, amount, \"Rifi::_moveVotes: vote amount underflows\");\n\n                _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);\n\n            }\n\n\n\n            if (dstRep != address(0)) {\n\n                uint32 dstRepNum = numCheckpoints[dstRep];\n\n                uint96 dstRepOld = dstRepNum > 0 ? checkpoints[dstRep][dstRepNum - 1].votes : 0;\n\n                uint96 dstRepNew = add96(dstRepOld, amount, \"Rifi::_moveVotes: vote amount overflows\");\n\n                _writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);\n\n            }\n\n        }\n\n    }\n\n\n",
          "message": "Function 'Rifi._moveDelegates' (RBinanceHarness.sol#3378-3396) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 3396,
          "vulnerability_to_line": 3409,
          "vulnerability_code": "    function _writeCheckpoint(address delegatee, uint32 nCheckpoints, uint96 oldVotes, uint96 newVotes) internal {\n\n      uint32 blockNumber = safe32(block.number, \"Rifi::_writeCheckpoint: block number exceeds 32 bits\");\n\n\n\n      if (nCheckpoints > 0 && checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber) {\n\n          checkpoints[delegatee][nCheckpoints - 1].votes = newVotes;\n\n      } else {\n\n          checkpoints[delegatee][nCheckpoints] = Checkpoint(blockNumber, newVotes);\n\n          numCheckpoints[delegatee] = nCheckpoints + 1;\n\n      }\n\n\n\n      emit DelegateVotesChanged(delegatee, oldVotes, newVotes);\n\n    }\n\n\n",
          "message": "Function 'Rifi._writeCheckpoint' (RBinanceHarness.sol#3396-3409) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 3149,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint public constant totalSupply = 500000000e18; // 500 million Rifi\n",
          "message": "Constant 'Rifi.totalSupply' (RBinanceHarness.sol#3149) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 4253,
          "vulnerability_to_line": 4272,
          "vulnerability_code": "    function _setPriceOracle(PriceOracle newOracle) public returns (uint) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PRICE_ORACLE_OWNER_CHECK);\n\n        }\n\n\n\n        // Track the old oracle for the cointroller\n\n        PriceOracle oldOracle = oracle;\n\n\n\n        // Set cointroller's oracle to newOracle\n\n        oracle = newOracle;\n\n\n\n        // Emit NewPriceOracle(oldOracle, newOracle)\n\n        emit NewPriceOracle(oldOracle, newOracle);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
          "message": "Function 'Cointroller._setPriceOracle' (RBinanceHarness.sol#4253-4272) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 4277,
          "vulnerability_to_line": 4289,
          "vulnerability_code": "    function _setCloseFactor(uint newCloseFactorMantissa) external returns (uint) {\n\n        // Check caller is admin\n\n    \trequire(msg.sender == admin, \"only admin can set close factor\");\n\n\n\n        uint oldCloseFactorMantissa = closeFactorMantissa;\n\n        closeFactorMantissa = newCloseFactorMantissa;\n\n        emit NewCloseFactor(oldCloseFactorMantissa, closeFactorMantissa);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
          "message": "Function 'Cointroller._setCloseFactor' (RBinanceHarness.sol#4277-4289) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 4295,
          "vulnerability_to_line": 4331,
          "vulnerability_code": "    function _setCollateralFactor(RToken rToken, uint newCollateralFactorMantissa) external returns (uint) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COLLATERAL_FACTOR_OWNER_CHECK);\n\n        }\n\n\n\n        // Verify market is listed\n\n        Market storage market = markets[address(rToken)];\n\n        if (!market.isListed) {\n\n            return fail(Error.MARKET_NOT_LISTED, FailureInfo.SET_COLLATERAL_FACTOR_NO_EXISTS);\n\n        }\n\n\n\n        Exp memory newCollateralFactorExp = Exp({mantissa: newCollateralFactorMantissa});\n\n\n\n        // Check collateral factor <= 0.9\n\n        Exp memory highLimit = Exp({mantissa: collateralFactorMaxMantissa});\n\n        if (lessThanExp(highLimit, newCollateralFactorExp)) {\n\n            return fail(Error.INVALID_COLLATERAL_FACTOR, FailureInfo.SET_COLLATERAL_FACTOR_VALIDATION);\n\n        }\n\n\n\n        // If collateral factor != 0, fail if price == 0\n\n        if (newCollateralFactorMantissa != 0 && oracle.getUnderlyingPrice(rToken) == 0) {\n\n            return fail(Error.PRICE_ERROR, FailureInfo.SET_COLLATERAL_FACTOR_WITHOUT_PRICE);\n\n        }\n\n\n\n        // Set market's collateral factor to new collateral factor, remember old value\n\n        uint oldCollateralFactorMantissa = market.collateralFactorMantissa;\n\n        market.collateralFactorMantissa = newCollateralFactorMantissa;\n\n\n\n        // Emit event with asset, old collateral factor, and new collateral factor\n\n        emit NewCollateralFactor(rToken, oldCollateralFactorMantissa, newCollateralFactorMantissa);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
          "message": "Function 'Cointroller._setCollateralFactor' (RBinanceHarness.sol#4295-4331) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 4336,
          "vulnerability_to_line": 4355,
          "vulnerability_code": "    function _setLiquidationIncentive(uint newLiquidationIncentiveMantissa) external returns (uint) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_LIQUIDATION_INCENTIVE_OWNER_CHECK);\n\n        }\n\n\n\n        // Save current value for use in log\n\n        uint oldLiquidationIncentiveMantissa = liquidationIncentiveMantissa;\n\n\n\n        // Set liquidation incentive to new incentive\n\n        liquidationIncentiveMantissa = newLiquidationIncentiveMantissa;\n\n\n\n        // Emit event with old incentive, new incentive\n\n        emit NewLiquidationIncentive(oldLiquidationIncentiveMantissa, newLiquidationIncentiveMantissa);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
          "message": "Function 'Cointroller._setLiquidationIncentive' (RBinanceHarness.sol#4336-4355) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 4360,
          "vulnerability_to_line": 4381,
          "vulnerability_code": "    function _supportMarket(RToken rToken) external returns (uint) {\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SUPPORT_MARKET_OWNER_CHECK);\n\n        }\n\n\n\n        if (markets[address(rToken)].isListed) {\n\n            return fail(Error.MARKET_ALREADY_LISTED, FailureInfo.SUPPORT_MARKET_EXISTS);\n\n        }\n\n\n\n        rToken.isRToken(); // Sanity check to make sure its really a RToken\n\n\n\n        // Note that isRified is not in active use anymore\n\n        markets[address(rToken)] = Market({isListed: true, isRified: false, collateralFactorMantissa: 0});\n\n\n\n        _addMarketInternal(address(rToken));\n\n\n\n        emit MarketListed(rToken);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Function 'Cointroller._supportMarket' (RBinanceHarness.sol#4360-4381) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 4381,
          "vulnerability_to_line": 4390,
          "vulnerability_code": "    function _addMarketInternal(address rToken) internal {\n\n        for (uint i = 0; i < allMarkets.length; i ++) {\n\n            require(allMarkets[i] != RToken(rToken), \"market already added\");\n\n        }\n\n        allMarkets.push(RToken(rToken));\n\n    }\n\n\n\n\n\n    /**\n",
          "message": "Function 'Cointroller._addMarketInternal' (RBinanceHarness.sol#4381-4390) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 4395,
          "vulnerability_to_line": 4410,
          "vulnerability_code": "    function _setMarketBorrowCaps(RToken[] calldata rTokens, uint[] calldata newBorrowCaps) external {\n\n    \trequire(msg.sender == admin || msg.sender == borrowCapGuardian, \"only admin or borrow cap guardian can set borrow caps\");\n\n\n\n        uint numMarkets = rTokens.length;\n\n        uint numBorrowCaps = newBorrowCaps.length;\n\n\n\n        require(numMarkets != 0 && numMarkets == numBorrowCaps, \"invalid input\");\n\n\n\n        for(uint i = 0; i < numMarkets; i++) {\n\n            borrowCaps[address(rTokens[i])] = newBorrowCaps[i];\n\n            emit NewBorrowCap(rTokens[i], newBorrowCaps[i]);\n\n        }\n\n    }\n\n\n\n    /**\n",
          "message": "Function 'Cointroller._setMarketBorrowCaps' (RBinanceHarness.sol#4395-4410) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 4413,
          "vulnerability_to_line": 4427,
          "vulnerability_code": "    function _setBorrowCapGuardian(address newBorrowCapGuardian) external {\n\n        require(msg.sender == admin, \"only admin can set borrow cap guardian\");\n\n\n\n        // Save current value for inclusion in log\n\n        address oldBorrowCapGuardian = borrowCapGuardian;\n\n\n\n        // Store borrowCapGuardian with value newBorrowCapGuardian\n\n        borrowCapGuardian = newBorrowCapGuardian;\n\n\n\n        // Emit NewBorrowCapGuardian(OldBorrowCapGuardian, NewBorrowCapGuardian)\n\n        emit NewBorrowCapGuardian(oldBorrowCapGuardian, newBorrowCapGuardian);\n\n    }\n\n\n\n    /**\n",
          "message": "Function 'Cointroller._setBorrowCapGuardian' (RBinanceHarness.sol#4413-4427) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 4431,
          "vulnerability_to_line": 4448,
          "vulnerability_code": "    function _setPauseGuardian(address newPauseGuardian) public returns (uint) {\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PAUSE_GUARDIAN_OWNER_CHECK);\n\n        }\n\n\n\n        // Save current value for inclusion in log\n\n        address oldPauseGuardian = pauseGuardian;\n\n\n\n        // Store pauseGuardian with value newPauseGuardian\n\n        pauseGuardian = newPauseGuardian;\n\n\n\n        // Emit NewPauseGuardian(OldPauseGuardian, NewPauseGuardian)\n\n        emit NewPauseGuardian(oldPauseGuardian, pauseGuardian);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Function 'Cointroller._setPauseGuardian' (RBinanceHarness.sol#4431-4448) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 4448,
          "vulnerability_to_line": 4458,
          "vulnerability_code": "    function _setMintPaused(RToken rToken, bool state) public returns (bool) {\n\n        require(markets[address(rToken)].isListed, \"cannot pause a market that is not listed\");\n\n        require(msg.sender == pauseGuardian || msg.sender == admin, \"only pause guardian and admin can pause\");\n\n        require(msg.sender == admin || state == true, \"only admin can unpause\");\n\n\n\n        mintGuardianPaused[address(rToken)] = state;\n\n        emit ActionPaused(rToken, \"Mint\", state);\n\n        return state;\n\n    }\n\n\n",
          "message": "Function 'Cointroller._setMintPaused' (RBinanceHarness.sol#4448-4458) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 4458,
          "vulnerability_to_line": 4468,
          "vulnerability_code": "    function _setBorrowPaused(RToken rToken, bool state) public returns (bool) {\n\n        require(markets[address(rToken)].isListed, \"cannot pause a market that is not listed\");\n\n        require(msg.sender == pauseGuardian || msg.sender == admin, \"only pause guardian and admin can pause\");\n\n        require(msg.sender == admin || state == true, \"only admin can unpause\");\n\n\n\n        borrowGuardianPaused[address(rToken)] = state;\n\n        emit ActionPaused(rToken, \"Borrow\", state);\n\n        return state;\n\n    }\n\n\n",
          "message": "Function 'Cointroller._setBorrowPaused' (RBinanceHarness.sol#4458-4468) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 4468,
          "vulnerability_to_line": 4477,
          "vulnerability_code": "    function _setTransferPaused(bool state) public returns (bool) {\n\n        require(msg.sender == pauseGuardian || msg.sender == admin, \"only pause guardian and admin can pause\");\n\n        require(msg.sender == admin || state == true, \"only admin can unpause\");\n\n\n\n        transferGuardianPaused = state;\n\n        emit ActionPaused(\"Transfer\", state);\n\n        return state;\n\n    }\n\n\n",
          "message": "Function 'Cointroller._setTransferPaused' (RBinanceHarness.sol#4468-4477) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 4477,
          "vulnerability_to_line": 4486,
          "vulnerability_code": "    function _setSeizePaused(bool state) public returns (bool) {\n\n        require(msg.sender == pauseGuardian || msg.sender == admin, \"only pause guardian and admin can pause\");\n\n        require(msg.sender == admin || state == true, \"only admin can unpause\");\n\n\n\n        seizeGuardianPaused = state;\n\n        emit ActionPaused(\"Seize\", state);\n\n        return state;\n\n    }\n\n\n",
          "message": "Function 'Cointroller._setSeizePaused' (RBinanceHarness.sol#4477-4486) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 4486,
          "vulnerability_to_line": 4492,
          "vulnerability_code": "    function _become(Unitroller unitroller) public {\n\n        require(msg.sender == unitroller.admin(), \"only unitroller admin can change brains\");\n\n        require(unitroller._acceptImplementation() == 0, \"change not authorized\");\n\n    }\n\n\n\n    /**\n",
          "message": "Function 'Cointroller._become' (RBinanceHarness.sol#4486-4492) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 4719,
          "vulnerability_to_line": 4727,
          "vulnerability_code": "    function _grantRifi(address recipient, uint amount) public {\n\n        require(adminOrInitializing(), \"only admin can grant rifi\");\n\n        uint amountLeft = grantRifiInternal(recipient, amount);\n\n        require(amountLeft == 0, \"insufficient rifi for grant\");\n\n        emit RifiGranted(recipient, amount);\n\n    }\n\n\n\n    /**\n",
          "message": "Function 'Cointroller._grantRifi' (RBinanceHarness.sol#4719-4727) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 4731,
          "vulnerability_to_line": 4737,
          "vulnerability_code": "    function _setRifiSpeed(RToken rToken, uint rifiSpeed) public {\n\n        require(adminOrInitializing(), \"only admin can set rifi speed\");\n\n        setRifiSpeedInternal(rToken, rifiSpeed);\n\n    }\n\n\n\n    /**\n",
          "message": "Function 'Cointroller._setRifiSpeed' (RBinanceHarness.sol#4731-4737) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 4741,
          "vulnerability_to_line": 4758,
          "vulnerability_code": "    function _setContributorRifiSpeed(address contributor, uint rifiSpeed) public {\n\n        require(adminOrInitializing(), \"only admin can set rifi speed\");\n\n\n\n        // note that RIFI speed could be set to 0 to halt liquidity rewards for a contributor\n\n        updateContributorRewards(contributor);\n\n        if (rifiSpeed == 0) {\n\n            // release storage\n\n            delete lastContributorBlock[contributor];\n\n        } else {\n\n            lastContributorBlock[contributor] = getBlockNumber();\n\n        }\n\n        rifiContributorSpeeds[contributor] = rifiSpeed;\n\n\n\n        emit ContributorRifiSpeedUpdated(contributor, rifiSpeed);\n\n    }\n\n\n\n    /**\n",
          "message": "Function 'Cointroller._setContributorRifiSpeed' (RBinanceHarness.sol#4741-4758) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 3507,
          "vulnerability_to_line": 3509,
          "vulnerability_code": "    uint224 public constant rifiInitialIndex = 1e36;\n\n\n",
          "message": "Constant 'Cointroller.rifiInitialIndex' (RBinanceHarness.sol#3507-3509) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 3510,
          "vulnerability_to_line": 3511,
          "vulnerability_code": "    uint internal constant closeFactorMinMantissa = 0.05e18; // 0.05\n",
          "message": "Constant 'Cointroller.closeFactorMinMantissa' (RBinanceHarness.sol#3510-3511) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 3513,
          "vulnerability_to_line": 3515,
          "vulnerability_code": "    uint internal constant closeFactorMaxMantissa = 0.9e18; // 0.9\n\n\n",
          "message": "Constant 'Cointroller.closeFactorMaxMantissa' (RBinanceHarness.sol#3513-3515) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 3516,
          "vulnerability_to_line": 3518,
          "vulnerability_code": "    uint internal constant collateralFactorMaxMantissa = 0.9e18; // 0.9\n\n\n",
          "message": "Constant 'Cointroller.collateralFactorMaxMantissa' (RBinanceHarness.sol#3516-3518) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 4906,
          "vulnerability_to_line": 4907,
          "vulnerability_code": "    function harnessSetAccrualBlockNumber(uint _accrualblockNumber) public {\n",
          "message": "Parameter '_accrualblockNumber' of RBinanceHarness.harnessSetAccrualBlockNumber (RBinanceHarness.sol#4906-4907) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 4922,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function harnessExchangeRateDetails(uint _totalSupply, uint _totalBorrows, uint _totalReserves) public {\n",
          "message": "Parameter '_totalSupply' of RBinanceHarness.harnessExchangeRateDetails (RBinanceHarness.sol#4922) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 4922,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function harnessExchangeRateDetails(uint _totalSupply, uint _totalBorrows, uint _totalReserves) public {\n",
          "message": "Parameter '_totalBorrows' of RBinanceHarness.harnessExchangeRateDetails (RBinanceHarness.sol#4922) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 4922,
          "vulnerability_to_line": 4923,
          "vulnerability_code": "    function harnessExchangeRateDetails(uint _totalSupply, uint _totalBorrows, uint _totalReserves) public {\n",
          "message": "Parameter '_totalReserves' of RBinanceHarness.harnessExchangeRateDetails (RBinanceHarness.sol#4922-4923) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 4932,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function harnessSetFailTransferToAddress(address _to, bool _fail) public {\n",
          "message": "Parameter '_to' of RBinanceHarness.harnessSetFailTransferToAddress (RBinanceHarness.sol#4932) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 4932,
          "vulnerability_to_line": 4933,
          "vulnerability_code": "    function harnessSetFailTransferToAddress(address _to, bool _fail) public {\n",
          "message": "Parameter '_fail' of RBinanceHarness.harnessSetFailTransferToAddress (RBinanceHarness.sol#4932-4933) is not in mixedCase\n"
        },
        {
          "name": "unused-state",
          "vulnerability_from_line": 798,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint constant halfExpScale = expScale/2;\n",
          "message": "ExponentialNoError.halfExpScale (RBinanceHarness.sol#798) is never used in CointrollerScenario\nExponentialNoError.mantissaOne (RBinanceHarness.sol#799) is never used in CointrollerScenario\nCointroller.closeFactorMinMantissa (RBinanceHarness.sol#3510-3511) is never used in CointrollerScenario\nCointroller.closeFactorMaxMantissa (RBinanceHarness.sol#3513-3515) is never used in CointrollerScenario\n"
        },
        {
          "name": "unused-state",
          "vulnerability_from_line": 5010,
          "vulnerability_to_line": 5012,
          "vulnerability_code": "    uint reserveFactor;\n\n\n",
          "message": "RBinanceScenario.reserveFactor (RBinanceHarness.sol#5010-5012) is never used in RBinanceScenario\n"
        }
      ]
    },
    "smartcheck": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 3053,
          "vulnerability_to_line": null,
          "vulnerability_code": "        pendingCointrollerImplementation = address(0);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 3105,
          "vulnerability_to_line": null,
          "vulnerability_code": "        pendingAdmin = address(0);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ARRAY_LENGTH_MANIPULATION",
          "vulnerability_from_line": 3652,
          "vulnerability_to_line": null,
          "vulnerability_code": "        storedList.length--;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ERC20_APPROVE",
          "vulnerability_from_line": 1388,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function approve(address spender, uint256 amount) external returns (bool) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 4162,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < assets.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 4382,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < allMarkets.length; i ++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 4673,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < rTokens.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 4679,
          "vulnerability_to_line": null,
          "vulnerability_code": "                for (uint j = 0; j < holders.length; j++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 4686,
          "vulnerability_to_line": null,
          "vulnerability_code": "                for (uint j = 0; j < holders.length; j++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 4824,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < allMarkets_.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 4833,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < allMarkets_.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 4843,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < allMarkets_.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 3559,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < len; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 3639,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < len; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 4162,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < assets.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 4382,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < allMarkets.length; i ++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 4403,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(uint i = 0; i < numMarkets; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 4673,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < rTokens.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 4679,
          "vulnerability_to_line": null,
          "vulnerability_code": "                for (uint j = 0; j < holders.length; j++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 4686,
          "vulnerability_to_line": null,
          "vulnerability_code": "                for (uint j = 0; j < holders.length; j++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 4824,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < allMarkets_.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 4833,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < allMarkets_.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 4843,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < allMarkets_.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 3343,
          "vulnerability_to_line": null,
          "vulnerability_code": "        while (upper > lower) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_LOCKED_MONEY",
          "vulnerability_from_line": 300,
          "vulnerability_to_line": null,
          "vulnerability_code": "contract RTokenInterface is RTokenStorage {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_LOCKED_MONEY",
          "vulnerability_from_line": 2675,
          "vulnerability_to_line": null,
          "vulnerability_code": "contract RBinance is RToken {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_LOCKED_MONEY",
          "vulnerability_from_line": 2993,
          "vulnerability_to_line": null,
          "vulnerability_code": "contract Unitroller is UnitrollerAdminStorage, CointrollerErrorReporter {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_LOCKED_MONEY",
          "vulnerability_from_line": 4856,
          "vulnerability_to_line": null,
          "vulnerability_code": "contract RBinanceHarness is RBinance {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_LOCKED_MONEY",
          "vulnerability_from_line": 5009,
          "vulnerability_to_line": null,
          "vulnerability_code": "contract RBinanceScenario is RBinance {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 77,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 110,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 183,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 488,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 698,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 786,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 984,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 1168,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 1233,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 2668,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 2837,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 2854,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 2985,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 3135,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 3439,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 4781,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 4853,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_REVERT_REQUIRE",
          "vulnerability_from_line": 3762,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (redeemTokens == 0 && redeemAmount > 0) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 3430,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getChainId() internal pure returns (uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 72,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint repayAmount) external view returns (uint, uint);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 401,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 721,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function mulUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 738,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function divUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 749,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function subUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 760,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function addUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 773,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function addThenSubUInt(uint a, uint b, uint c) internal pure returns (MathError, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 1001,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getExp(uint num, uint denom) pure internal returns (MathError, Exp memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 1018,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function addExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 1027,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function subExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 1036,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function mulScalar(Exp memory a, uint scalar) pure internal returns (MathError, Exp memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 1048,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function mulScalarTruncate(Exp memory a, uint scalar) pure internal returns (MathError, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 1060,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function mulScalarTruncateAddUInt(Exp memory a, uint scalar, uint addend) pure internal returns (MathError, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 1072,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function divScalar(Exp memory a, uint scalar) pure internal returns (MathError, Exp memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 1084,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function divScalarByExp(uint scalar, Exp memory divisor) pure internal returns (MathError, Exp memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 1104,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function divScalarByExpTruncate(uint scalar, Exp memory divisor) pure internal returns (MathError, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 1116,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function mulExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 1141,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function mulExp(uint a, uint b) pure internal returns (MathError, Exp memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 1148,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function mulExp3(Exp memory a, Exp memory b, Exp memory c) pure internal returns (MathError, Exp memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 1161,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function divExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 1433,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 1512,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 1569,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function exchangeRateStoredInternal() internal view returns (MathError, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 1700,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function mintInternal(uint mintAmount) internal nonReentrant returns (uint, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 1727,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function mintFresh(address minter, uint mintAmount) internal returns (uint, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 4104,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getAccountLiquidity(address account) public view returns (uint, uint, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 4116,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getAccountLiquidityInternal(address account) internal view returns (Error, uint, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 4134,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint borrowAmount) public view returns (uint, uint, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 4155,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint borrowAmount) internal view returns (Error, uint, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 4217,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function liquidateCalculateSeizeTokens(address rTokenBorrowed, address rTokenCollateral, uint actualRepayAmount) external view returns (uint, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UNCHECKED_CALL",
          "vulnerability_from_line": 3120,
          "vulnerability_to_line": null,
          "vulnerability_code": "        (bool success, ) = cointrollerImplementation.delegatecall(msg.data);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 3122,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 3432,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly { chainId := chainid() }\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 416,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1844,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 2686,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor(CointrollerInterface cointroller_,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 4862,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor(CointrollerInterface cointroller_,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 5012,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor(string memory name_,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 416,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 796,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint constant expScale = 1e18;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 797,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint constant doubleScale = 1e36;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 798,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint constant halfExpScale = expScale/2;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 799,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint constant mantissaOne = expScale;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1844,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1844,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1844,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1844,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1845,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1847,
          "vulnerability_to_line": null,
          "vulnerability_code": "        RedeemLocalVars memory vars;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1850,
          "vulnerability_to_line": null,
          "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1850,
          "vulnerability_to_line": null,
          "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1850,
          "vulnerability_to_line": null,
          "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1850,
          "vulnerability_to_line": null,
          "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1851,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (vars.mathErr != MathError.NO_ERROR) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1851,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (vars.mathErr != MathError.NO_ERROR) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1852,
          "vulnerability_to_line": null,
          "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1852,
          "vulnerability_to_line": null,
          "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1852,
          "vulnerability_to_line": null,
          "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1852,
          "vulnerability_to_line": null,
          "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1852,
          "vulnerability_to_line": null,
          "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 2696,
          "vulnerability_to_line": null,
          "vulnerability_code": "        initialize(cointroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 2696,
          "vulnerability_to_line": null,
          "vulnerability_code": "        initialize(cointroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 2696,
          "vulnerability_to_line": null,
          "vulnerability_code": "        initialize(cointroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 2696,
          "vulnerability_to_line": null,
          "vulnerability_code": "        initialize(cointroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 2699,
          "vulnerability_to_line": null,
          "vulnerability_code": "        admin = admin_;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 4857,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint harnessExchangeRate;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 4868,
          "vulnerability_to_line": null,
          "vulnerability_code": "                address payable admin_)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 4869,
          "vulnerability_to_line": null,
          "vulnerability_code": "    RBinance(\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 4872,
          "vulnerability_to_line": null,
          "vulnerability_code": "    initialExchangeRateMantissa,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 4874,
          "vulnerability_to_line": null,
          "vulnerability_code": "    symbol_,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 5010,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint reserveFactor;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 5015,
          "vulnerability_to_line": null,
          "vulnerability_code": "                address payable admin_,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 5016,
          "vulnerability_to_line": null,
          "vulnerability_code": "                CointrollerInterface cointroller_,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 5017,
          "vulnerability_to_line": null,
          "vulnerability_code": "                InterestRateModel interestRateModel_,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 5018,
          "vulnerability_to_line": null,
          "vulnerability_code": "                uint initialExchangeRateMantissa)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 5019,
          "vulnerability_to_line": null,
          "vulnerability_code": "        RBinance(cointroller_,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 5020,
          "vulnerability_to_line": null,
          "vulnerability_code": "               interestRateModel_,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 5022,
          "vulnerability_to_line": null,
          "vulnerability_code": "               name_,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 5024,
          "vulnerability_to_line": null,
          "vulnerability_code": "               decimals_,\n",
          "message": null
        }
      ]
    },
    "oyente": {
      "successfull_analysis": false,
      "errors": [
        "exception (RuntimeError: Source map error, unknown name(SHR) or instr_name(INVALID))"
      ],
      "vulnerability_findings": []
    },
    "mythril": {
      "successfull_analysis": false,
      "errors": [
        "DOCKER_TIMEOUT"
      ],
      "vulnerability_findings": []
    },
    "osiris": {
      "successfull_analysis": false,
      "errors": [
        "Solidity compilation failed"
      ],
      "vulnerability_findings": []
    }
  }
}