{
  "smartbugs_completed": true,
  "analyzer_results": {
    "semgrep": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 589,
          "vulnerability_to_line": null,
          "vulnerability_code": "    for(uint256 i = 0; i < _saleData.length; i += 3){\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 743,
          "vulnerability_to_line": null,
          "vulnerability_code": "    while((index < self.milestoneTimes.length) && (self.milestoneTimes[index] < timestamp)) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 313,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require((self.owner == msg.sender) && (_newOwner > 0));\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 325,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require((self.owner == msg.sender) && self.stillMinting);\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 1209,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require((self.personalCaps[msg.sender] == 0) && (self.base.hasContributed[msg.sender] == 0));\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 620,
          "vulnerability_to_line": null,
          "vulnerability_code": "    if (crowdsaleActive(self) && nonZeroPurchase) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 621,
          "vulnerability_to_line": null,
          "vulnerability_code": "      return true;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 622,
          "vulnerability_to_line": null,
          "vulnerability_code": "    } else {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 623,
          "vulnerability_to_line": null,
          "vulnerability_code": "      LogErrorMsg(msg.value, \"Invalid Purchase! Check start time and amount of ether.\");\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 624,
          "vulnerability_to_line": null,
          "vulnerability_code": "      return false;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 625,
          "vulnerability_to_line": null,
          "vulnerability_code": "    }\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 681,
          "vulnerability_to_line": null,
          "vulnerability_code": "    if ((!crowdsaleEnded(self)) && (self.token.balanceOf(this)>0)) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 682,
          "vulnerability_to_line": null,
          "vulnerability_code": "      LogErrorMsg(0, \"Cannot withdraw owner ether until after the sale!\");\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 683,
          "vulnerability_to_line": null,
          "vulnerability_code": "      return false;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 684,
          "vulnerability_to_line": null,
          "vulnerability_code": "    }\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 829,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (self.list[_node][PREV] == HEAD && self.list[_node][NEXT] == HEAD) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 830,
          "vulnerability_to_line": null,
          "vulnerability_code": "            if (self.list[HEAD][NEXT] == _node) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 831,
          "vulnerability_to_line": null,
          "vulnerability_code": "                return true;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 832,
          "vulnerability_to_line": null,
          "vulnerability_code": "            } else {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 833,
          "vulnerability_to_line": null,
          "vulnerability_code": "                return false;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 834,
          "vulnerability_to_line": null,
          "vulnerability_code": "            }\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 835,
          "vulnerability_to_line": null,
          "vulnerability_code": "        } else {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 836,
          "vulnerability_to_line": null,
          "vulnerability_code": "            return true;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 837,
          "vulnerability_to_line": null,
          "vulnerability_code": "        }\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 913,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if(!nodeExists(self,_new) && nodeExists(self,_node)) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 914,
          "vulnerability_to_line": null,
          "vulnerability_code": "            uint256 c = self.list[_node][_direction];\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 915,
          "vulnerability_to_line": null,
          "vulnerability_code": "            createLink(self, _node, _new, _direction);\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 916,
          "vulnerability_to_line": null,
          "vulnerability_code": "            createLink(self, _new, c, _direction);\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 917,
          "vulnerability_to_line": null,
          "vulnerability_code": "            return true;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 918,
          "vulnerability_to_line": null,
          "vulnerability_code": "        } else {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 919,
          "vulnerability_to_line": null,
          "vulnerability_code": "            return false;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 920,
          "vulnerability_to_line": null,
          "vulnerability_code": "        }\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 744,
          "vulnerability_to_line": null,
          "vulnerability_code": "      index++;\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 747,
          "vulnerability_to_line": null,
          "vulnerability_code": "      index++;\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 848,
          "vulnerability_to_line": null,
          "vulnerability_code": "            numElements++;\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 1143,
          "vulnerability_to_line": null,
          "vulnerability_code": "      _digits++;\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        }
      ]
    },
    "slither": {
      "successfull_analysis": true,
      "errors": [
        "DOCKER_RECEIVED_SIGNAL_36"
      ],
      "vulnerability_findings": [
        {
          "name": "constant-function",
          "vulnerability_from_line": 40,
          "vulnerability_to_line": 49,
          "vulnerability_code": "  function times(uint256 a, uint256 b) public pure returns (bool err,uint256 res) {\n\n    assembly{\n\n      res := mul(a,b)\n\n      switch or(iszero(b), eq(div(res,b), a))\n\n      case 0 {\n\n        err := 1\n\n        res := 0\n\n      }\n\n    }\n",
          "message": "BasicMathLib.times (InteractiveCrowdsaleTestContract.sol#40-49) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 57,
          "vulnerability_to_line": 72,
          "vulnerability_code": "  function dividedBy(uint256 a, uint256 b) public pure returns (bool err,uint256 i) {\n\n    uint256 res;\n\n    assembly{\n\n      switch iszero(b)\n\n      case 0 {\n\n        res := div(a,b)\n\n        let loc := mload(0x40)\n\n        mstore(add(loc,0x20),res)\n\n        i := mload(add(loc,0x20))\n\n      }\n\n      default {\n\n        err := 1\n\n        i := 0\n\n      }\n\n    }\n",
          "message": "BasicMathLib.dividedBy (InteractiveCrowdsaleTestContract.sol#57-72) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 80,
          "vulnerability_to_line": 89,
          "vulnerability_code": "  function plus(uint256 a, uint256 b) public pure returns (bool err, uint256 res) {\n\n    assembly{\n\n      res := add(a,b)\n\n      switch and(eq(sub(res,b), a), or(gt(res,b),eq(res,b)))\n\n      case 0 {\n\n        err := 1\n\n        res := 0\n\n      }\n\n    }\n",
          "message": "BasicMathLib.plus (InteractiveCrowdsaleTestContract.sol#80-89) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 97,
          "vulnerability_to_line": 106,
          "vulnerability_code": "  function minus(uint256 a, uint256 b) public pure returns (bool err,uint256 res) {\n\n    assembly{\n\n      res := sub(a,b)\n\n      switch eq(and(eq(add(res,b), a), or(lt(res,a), eq(res,a))), 1)\n\n      case 0 {\n\n        err := 1\n\n        res := 0\n\n      }\n\n    }\n",
          "message": "BasicMathLib.minus (InteractiveCrowdsaleTestContract.sol#97-106) is declared view but contains assembly code\n"
        },
        {
          "name": "uninitialized-local",
          "vulnerability_from_line": 287,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint256 _newAllowed;\n",
          "message": "_newAllowed in TokenLib.approveChange (InteractiveCrowdsaleTestContract.sol#287) is a local variable never initialiazed\n"
        },
        {
          "name": "uninitialized-local",
          "vulnerability_from_line": 1211,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint256 _bonusPercent;\n",
          "message": "_bonusPercent in InteractiveCrowdsaleLib.submitBid (InteractiveCrowdsaleTestContract.sol#1211) is a local variable never initialiazed\n"
        },
        {
          "name": "uninitialized-local",
          "vulnerability_from_line": 1366,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bool loop;\n",
          "message": "loop in InteractiveCrowdsaleLib.withdrawBid (InteractiveCrowdsaleTestContract.sol#1366) is a local variable never initialiazed\n"
        },
        {
          "name": "uninitialized-local",
          "vulnerability_from_line": 1251,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bool loop;\n",
          "message": "loop in InteractiveCrowdsaleLib.submitBid (InteractiveCrowdsaleTestContract.sol#1251) is a local variable never initialiazed\n"
        },
        {
          "name": "uninitialized-local",
          "vulnerability_from_line": 1364,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint256 _proposedValue;\n",
          "message": "_proposedValue in InteractiveCrowdsaleLib.withdrawBid (InteractiveCrowdsaleTestContract.sol#1364) is a local variable never initialiazed\n"
        },
        {
          "name": "uninitialized-local",
          "vulnerability_from_line": 741,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint256 index;\n",
          "message": "index in CrowdsaleLib.getSaleData (InteractiveCrowdsaleTestContract.sol#741) is a local variable never initialiazed\n"
        },
        {
          "name": "unused-return",
          "vulnerability_from_line": 1201,
          "vulnerability_to_line": 1308,
          "vulnerability_code": "  function submitBid(InteractiveCrowdsaleStorage storage self,\n\n                      uint256 _amount,\n\n                      uint256 _personalCap,\n\n                      uint256 _valuePredict) public returns (bool)\n\n  {\n\n    require(msg.sender != self.base.owner);\n\n    require(self.base.validPurchase());\n\n    // bidder can't have already bid\n\n    require((self.personalCaps[msg.sender] == 0) && (self.base.hasContributed[msg.sender] == 0));\n\n\n\n    uint256 _bonusPercent;\n\n    // token purchase bonus only applies before the withdrawal lock\n\n    if (now < self.endWithdrawalTime) {\n\n      require(_personalCap > _amount);\n\n      _bonusPercent = getCurrentBonus(self);\n\n    } else {\n\n      // The personal valuation submitted must be greater than the current\n\n      // valuation plus the bid if after the withdrawal lock.\n\n      require(_personalCap >= self.totalValuation + _amount);\n\n    }\n\n\n\n    // personal valuation and minimum should be set to the proper granularity,\n\n    // only three most significant values can be non-zero. reduces the number of possible\n\n    // valuation buckets in the linked list\n\n    uint256 digits = numDigits(_personalCap);\n\n    if(digits > 3) {\n\n      require((_personalCap % (10**(digits - 3))) == 0);\n\n    }\n\n\n\n    // add the bid to the sorted valuations list\n\n    // duplicate personal valuation caps share a spot in the linked list\n\n    uint256 _listSpot;\n\n    if(!self.valuationsList.nodeExists(_personalCap)){\n\n        _listSpot = self.valuationsList.getSortedSpot(_valuePredict,_personalCap,NEXT);\n\n        self.valuationsList.insert(_listSpot,_personalCap,PREV);\n\n    }\n\n\n\n    // add the bid to the address => cap mapping\n\n    self.personalCaps[msg.sender] = _personalCap;\n\n\n\n    // add the bid to the sum of bids at this valuation. Needed for calculating correct valuation pointer\n\n    self.valuationSums[_personalCap] += _amount;\n\n    self.numBidsAtValuation[_personalCap] += 1;\n\n\n\n    // add the bid to bidder's contribution amount\n\n    self.base.hasContributed[msg.sender] += _amount;\n\n\n\n    // temp variables for calculation\n\n    uint256 _proposedCommit;\n\n    uint256 _currentBucket;\n\n    bool loop;\n\n    bool exists;\n\n\n\n    // we only affect the pointer if we are coming in above it\n\n    if(_personalCap > self.currentBucket){\n\n\n\n      // if our valuation is sitting at the current bucket then we are using\n\n      // commitments right at their cap\n\n      if (self.totalValuation == self.currentBucket) {\n\n        // we are going to drop those commitments to see if we are going to be\n\n        // greater than the current bucket without them\n\n        _proposedCommit = (self.valueCommitted - self.valuationSums[self.currentBucket]) + _amount;\n\n        if(_proposedCommit > self.currentBucket){ loop = true; }\n\n      } else {\n\n        // else we're sitting in between buckets and have already dropped the\n\n        // previous commitments\n\n        _proposedCommit = self.totalValuation + _amount;\n\n        loop = true;\n\n      }\n\n\n\n      if(loop){\n\n        // if we're going to loop we move to the next bucket\n\n        (exists,_currentBucket) = self.valuationsList.getAdjacent(self.currentBucket, NEXT);\n\n\n\n        while(_proposedCommit >= _currentBucket){\n\n          // while we are proposed higher than the next bucket we drop commitments\n\n          // and iterate to the next\n\n          _proposedCommit = _proposedCommit - self.valuationSums[_currentBucket];\n\n          (exists,_currentBucket) = self.valuationsList.getAdjacent(_currentBucket, NEXT);\n\n        }\n\n        // once we've reached a bucket too high we move back to the last bucket and set it\n\n        (exists, _currentBucket) = self.valuationsList.getAdjacent(_currentBucket, PREV);\n\n        self.currentBucket = _currentBucket;\n\n      } else {\n\n        // else we're staying at the current bucket\n\n        _currentBucket = self.currentBucket;\n\n      }\n\n      // if our proposed commitment is less than or equal to the bucket\n\n      if(_proposedCommit <= _currentBucket){\n\n        // we add the commitments in that bucket\n\n        _proposedCommit += self.valuationSums[_currentBucket];\n\n        // and our value is capped at that bucket\n\n        self.totalValuation = _currentBucket;\n\n      } else {\n\n        // else our total value is in between buckets and it equals the total commitements\n\n        self.totalValuation = _proposedCommit;\n\n      }\n\n\n\n      self.valueCommitted = _proposedCommit;\n\n    } else if(_personalCap == self.totalValuation){\n\n      self.valueCommitted += _amount;\n\n    }\n\n\n\n    self.pricePurchasedAt[msg.sender] = (self.base.tokensPerEth * (100 + _bonusPercent))/100;\n\n    LogBidAccepted(msg.sender, _amount, _personalCap);\n\n    BucketAndValuationAndCommitted(self.currentBucket, self.totalValuation, self.valueCommitted);\n\n    return true;\n",
          "message": "InteractiveCrowdsaleLib.submitBid (InteractiveCrowdsaleTestContract.sol#1201-1308) does not use the value returned by external calls:\n\t-self.valuationsList.insert(_listSpot,_personalCap,PREV) (InteractiveCrowdsaleTestContract.sol#1235)\n"
        },
        {
          "name": "unused-return",
          "vulnerability_from_line": 1456,
          "vulnerability_to_line": 1490,
          "vulnerability_code": "  function launchToken(InteractiveCrowdsaleStorage storage self) internal returns (bool) {\n\n    // total valuation of all the tokens not including the bonus\n\n    uint256 _fullValue = (self.totalValuation*100)/uint256(self.percentBeingSold);\n\n    // total valuation of bonus tokens\n\n    uint256 _bonusValue = ((self.totalValuation * (100 + self.priceBonusPercent))/100) - self.totalValuation;\n\n    // total supply of all tokens not including the bonus\n\n    uint256 _supply = (_fullValue * self.base.tokensPerEth)/1000000000000000000;\n\n    // total number of bonus tokens\n\n    uint256 _bonusTokens = (_bonusValue * self.base.tokensPerEth)/1000000000000000000;\n\n    // tokens allocated to the owner of the sale\n\n    uint256 _ownerTokens = _supply - ((_supply * uint256(self.percentBeingSold))/100);\n\n    // total supply of tokens not including the bonus tokens\n\n    uint256 _totalSupply = _supply + _bonusTokens;\n\n\n\n    // deploy new token contract with total number of tokens\n\n    self.base.token = new CrowdsaleToken(address(this),\n\n                                         self.tokenInfo.name,\n\n                                         self.tokenInfo.symbol,\n\n                                         self.tokenInfo.decimals,\n\n                                         _totalSupply,\n\n                                         self.tokenInfo.stillMinting);\n\n\n\n    // if the sale got canceled, then all the tokens go to the owner and bonus tokens are burned\n\n    if(!self.isCanceled){\n\n      self.base.token.transfer(self.base.owner, _ownerTokens);\n\n    } else {\n\n      self.base.token.transfer(self.base.owner, _supply);\n\n      self.base.token.burnToken(_bonusTokens);\n\n    }\n\n    // the owner of the crowdsale becomes the new owner of the token contract\n\n    self.base.token.changeOwner(self.base.owner);\n\n    self.base.startingTokenBalance = _supply - _ownerTokens;\n\n\n\n    return true;\n",
          "message": "InteractiveCrowdsaleLib.launchToken (InteractiveCrowdsaleTestContract.sol#1456-1490) does not use the value returned by external calls:\n\t-self.base.token.transfer(self.base.owner,_ownerTokens) (InteractiveCrowdsaleTestContract.sol#1480)\n\t-self.base.token.transfer(self.base.owner,_supply) (InteractiveCrowdsaleTestContract.sol#1482)\n\t-self.base.token.burnToken(_bonusTokens) (InteractiveCrowdsaleTestContract.sol#1483)\n\t-self.base.token.changeOwner(self.base.owner) (InteractiveCrowdsaleTestContract.sol#1486)\n"
        },
        {
          "name": "unused-return",
          "vulnerability_from_line": 1510,
          "vulnerability_to_line": 1578,
          "vulnerability_code": "  function retreiveFinalResult(InteractiveCrowdsaleStorage storage self) public returns (bool) {\n\n    require(now > self.base.endTime);\n\n    require(self.personalCaps[msg.sender] > 0);\n\n\n\n    uint256 numTokens;\n\n    uint256 remainder;\n\n\n\n    if(!self.isFinalized){\n\n      require(setCanceled(self));\n\n      require(self.isCanceled);\n\n    }\n\n\n\n    if (self.isCanceled) {\n\n      // if the sale was canceled, everyone gets a full refund\n\n      self.base.leftoverWei[msg.sender] += self.base.hasContributed[msg.sender];\n\n      self.base.hasContributed[msg.sender] = 0;\n\n      LogErrorMsg(self.totalValuation, \"Sale is canceled, all bids have been refunded!\");\n\n      return true;\n\n    }\n\n\n\n    if (self.personalCaps[msg.sender] < self.totalValuation) {\n\n\n\n      // full refund if personal cap is less than total valuation\n\n      self.base.leftoverWei[msg.sender] += self.base.hasContributed[msg.sender];\n\n\n\n      // set hasContributed to 0 to prevent participant from calling this over and over\n\n      self.base.hasContributed[msg.sender] = 0;\n\n\n\n      return self.base.withdrawLeftoverWei();\n\n\n\n    } else if (self.personalCaps[msg.sender] == self.totalValuation) {\n\n\n\n      // calculate the portion that this address has to take out of their bid\n\n      uint256 refundAmount = (self.q*self.base.hasContributed[msg.sender])/100;\n\n\n\n      // refund that amount of wei to the address\n\n      self.base.leftoverWei[msg.sender] += refundAmount;\n\n\n\n      // subtract that amount the address' contribution\n\n      self.base.hasContributed[msg.sender] -= refundAmount;\n\n    }\n\n\n\n    LogErrorMsg(self.base.hasContributed[msg.sender],\"contribution\");\n\n    LogErrorMsg(self.pricePurchasedAt[msg.sender],\"price\");\n\n    LogErrorMsg(self.q,\"percentage\");\n\n    // calculate the number of tokens that the bidder purchased\n\n    (numTokens, remainder) = calculateTokenPurchase(self.base.hasContributed[msg.sender],\n\n                                                    self.pricePurchasedAt[msg.sender]);\n\n\n\n    // add tokens to the bidders purchase.  can't overflow because it will be under the cap\n\n    self.base.withdrawTokensMap[msg.sender] += numTokens;\n\n    self.valueCommitted = self.valueCommitted - remainder;\n\n    self.base.leftoverWei[msg.sender] += remainder;\n\n\n\n    // burn any extra bonus tokens\n\n    uint256 _fullBonus;\n\n    uint256 _fullBonusPrice = (self.base.tokensPerEth*(100 + self.priceBonusPercent))/100;\n\n    (_fullBonus, remainder) = calculateTokenPurchase(self.base.hasContributed[msg.sender], _fullBonusPrice);\n\n    uint256 _leftoverBonus = _fullBonus - numTokens;\n\n    self.base.token.burnToken(_leftoverBonus);\n\n\n\n    self.base.hasContributed[msg.sender] = 0;\n\n\n\n    // send tokens and leftoverWei to the address calling the function\n\n    self.base.withdrawTokens();\n\n\n\n    self.base.withdrawLeftoverWei();\n\n\n",
          "message": "InteractiveCrowdsaleLib.retreiveFinalResult (InteractiveCrowdsaleTestContract.sol#1510-1578) does not use the value returned by external calls:\n\t-self.base.token.burnToken(_leftoverBonus) (InteractiveCrowdsaleTestContract.sol#1569)\n\t-self.base.withdrawTokens() (InteractiveCrowdsaleTestContract.sol#1574)\n\t-self.base.withdrawLeftoverWei() (InteractiveCrowdsaleTestContract.sol#1576)\n"
        },
        {
          "name": "shadowing-local",
          "vulnerability_from_line": 406,
          "vulnerability_to_line": null,
          "vulnerability_code": "                          string name,\n",
          "message": "CrowdsaleToken.CrowdsaleToken.name (local variable @ InteractiveCrowdsaleTestContract.sol#406) shadows:\n\t- CrowdsaleToken.name (function @ InteractiveCrowdsaleTestContract.sol#415-417)\n"
        },
        {
          "name": "shadowing-local",
          "vulnerability_from_line": 407,
          "vulnerability_to_line": null,
          "vulnerability_code": "                          string symbol,\n",
          "message": "CrowdsaleToken.CrowdsaleToken.symbol (local variable @ InteractiveCrowdsaleTestContract.sol#407) shadows:\n\t- CrowdsaleToken.symbol (function @ InteractiveCrowdsaleTestContract.sol#419-421)\n"
        },
        {
          "name": "shadowing-local",
          "vulnerability_from_line": 408,
          "vulnerability_to_line": null,
          "vulnerability_code": "                          uint8 decimals,\n",
          "message": "CrowdsaleToken.CrowdsaleToken.decimals (local variable @ InteractiveCrowdsaleTestContract.sol#408) shadows:\n\t- CrowdsaleToken.decimals (function @ InteractiveCrowdsaleTestContract.sol#423-425)\n"
        },
        {
          "name": "shadowing-local",
          "vulnerability_from_line": 409,
          "vulnerability_to_line": null,
          "vulnerability_code": "                          uint256 initialSupply,\n",
          "message": "CrowdsaleToken.CrowdsaleToken.initialSupply (local variable @ InteractiveCrowdsaleTestContract.sol#409) shadows:\n\t- CrowdsaleToken.initialSupply (function @ InteractiveCrowdsaleTestContract.sol#431-433)\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 40,
          "vulnerability_to_line": 49,
          "vulnerability_code": "  function times(uint256 a, uint256 b) public pure returns (bool err,uint256 res) {\n\n    assembly{\n\n      res := mul(a,b)\n\n      switch or(iszero(b), eq(div(res,b), a))\n\n      case 0 {\n\n        err := 1\n\n        res := 0\n\n      }\n\n    }\n",
          "message": "BasicMathLib.times uses assembly (InteractiveCrowdsaleTestContract.sol#40-49)\n\t- InteractiveCrowdsaleTestContract.sol#41-49\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 57,
          "vulnerability_to_line": 72,
          "vulnerability_code": "  function dividedBy(uint256 a, uint256 b) public pure returns (bool err,uint256 i) {\n\n    uint256 res;\n\n    assembly{\n\n      switch iszero(b)\n\n      case 0 {\n\n        res := div(a,b)\n\n        let loc := mload(0x40)\n\n        mstore(add(loc,0x20),res)\n\n        i := mload(add(loc,0x20))\n\n      }\n\n      default {\n\n        err := 1\n\n        i := 0\n\n      }\n\n    }\n",
          "message": "BasicMathLib.dividedBy uses assembly (InteractiveCrowdsaleTestContract.sol#57-72)\n\t- InteractiveCrowdsaleTestContract.sol#59-72\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 80,
          "vulnerability_to_line": 89,
          "vulnerability_code": "  function plus(uint256 a, uint256 b) public pure returns (bool err, uint256 res) {\n\n    assembly{\n\n      res := add(a,b)\n\n      switch and(eq(sub(res,b), a), or(gt(res,b),eq(res,b)))\n\n      case 0 {\n\n        err := 1\n\n        res := 0\n\n      }\n\n    }\n",
          "message": "BasicMathLib.plus uses assembly (InteractiveCrowdsaleTestContract.sol#80-89)\n\t- InteractiveCrowdsaleTestContract.sol#81-89\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 97,
          "vulnerability_to_line": 106,
          "vulnerability_code": "  function minus(uint256 a, uint256 b) public pure returns (bool err,uint256 res) {\n\n    assembly{\n\n      res := sub(a,b)\n\n      switch eq(and(eq(add(res,b), a), or(lt(res,a), eq(res,a))), 1)\n\n      case 0 {\n\n        err := 1\n\n        res := 0\n\n      }\n\n    }\n",
          "message": "BasicMathLib.minus uses assembly (InteractiveCrowdsaleTestContract.sol#97-106)\n\t- InteractiveCrowdsaleTestContract.sol#98-106\n"
        },
        {
          "name": "pragma",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.18;\n",
          "message": "Different versions of Solidity is used in InteractiveCrowdsaleTestContract.sol:\n\t- Version used: ['^0.4.15', '^0.4.18']\n\t- InteractiveCrowdsaleTestContract.sol#3 declares pragma solidity^0.4.18\n\t- InteractiveCrowdsaleTestContract.sol#111 declares pragma solidity^0.4.18\n\t- InteractiveCrowdsaleTestContract.sol#370 declares pragma solidity^0.4.15\n\t- InteractiveCrowdsaleTestContract.sol#480 declares pragma solidity^0.4.18\n\t- InteractiveCrowdsaleTestContract.sol#765 declares pragma solidity^0.4.18\n\t- InteractiveCrowdsaleTestContract.sol#958 declares pragma solidity^0.4.18\n\t- InteractiveCrowdsaleTestContract.sol#1614 declares pragma solidity^0.4.18\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 40,
          "vulnerability_to_line": 49,
          "vulnerability_code": "  function times(uint256 a, uint256 b) public pure returns (bool err,uint256 res) {\n\n    assembly{\n\n      res := mul(a,b)\n\n      switch or(iszero(b), eq(div(res,b), a))\n\n      case 0 {\n\n        err := 1\n\n        res := 0\n\n      }\n\n    }\n",
          "message": "BasicMathLib.times (InteractiveCrowdsaleTestContract.sol#40-49) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 57,
          "vulnerability_to_line": 72,
          "vulnerability_code": "  function dividedBy(uint256 a, uint256 b) public pure returns (bool err,uint256 i) {\n\n    uint256 res;\n\n    assembly{\n\n      switch iszero(b)\n\n      case 0 {\n\n        res := div(a,b)\n\n        let loc := mload(0x40)\n\n        mstore(add(loc,0x20),res)\n\n        i := mload(add(loc,0x20))\n\n      }\n\n      default {\n\n        err := 1\n\n        i := 0\n\n      }\n\n    }\n",
          "message": "BasicMathLib.dividedBy (InteractiveCrowdsaleTestContract.sol#57-72) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 80,
          "vulnerability_to_line": 89,
          "vulnerability_code": "  function plus(uint256 a, uint256 b) public pure returns (bool err, uint256 res) {\n\n    assembly{\n\n      res := add(a,b)\n\n      switch and(eq(sub(res,b), a), or(gt(res,b),eq(res,b)))\n\n      case 0 {\n\n        err := 1\n\n        res := 0\n\n      }\n\n    }\n",
          "message": "BasicMathLib.plus (InteractiveCrowdsaleTestContract.sol#80-89) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 97,
          "vulnerability_to_line": 106,
          "vulnerability_code": "  function minus(uint256 a, uint256 b) public pure returns (bool err,uint256 res) {\n\n    assembly{\n\n      res := sub(a,b)\n\n      switch eq(and(eq(add(res,b), a), or(lt(res,a), eq(res,a))), 1)\n\n      case 0 {\n\n        err := 1\n\n        res := 0\n\n      }\n\n    }\n",
          "message": "BasicMathLib.minus (InteractiveCrowdsaleTestContract.sol#97-106) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 172,
          "vulnerability_to_line": 191,
          "vulnerability_code": "  function init(TokenStorage storage self,\n\n                address _owner,\n\n                string _name,\n\n                string _symbol,\n\n                uint8 _decimals,\n\n                uint256 _initial_supply,\n\n                bool _allowMinting)\n\n                public\n\n  {\n\n    require(!self.initialized);\n\n    self.initialized = true;\n\n    self.name = _name;\n\n    self.symbol = _symbol;\n\n    self.totalSupply = _initial_supply;\n\n    self.initialSupply = _initial_supply;\n\n    self.decimals = _decimals;\n\n    self.owner = _owner;\n\n    self.stillMinting = _allowMinting;\n\n    self.balances[_owner] = _initial_supply;\n",
          "message": "TokenLib.init (InteractiveCrowdsaleTestContract.sol#172-191) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 198,
          "vulnerability_to_line": 210,
          "vulnerability_code": "  function transfer(TokenStorage storage self, address _to, uint256 _value) public returns (bool) {\n\n    require(_to != address(0));\n\n    bool err;\n\n    uint256 balance;\n\n\n\n    (err,balance) = self.balances[msg.sender].minus(_value);\n\n    require(!err);\n\n    self.balances[msg.sender] = balance;\n\n    //It's not possible to overflow token supply\n\n    self.balances[_to] = self.balances[_to] + _value;\n\n    Transfer(msg.sender, _to, _value);\n\n    return true;\n",
          "message": "TokenLib.transfer (InteractiveCrowdsaleTestContract.sol#198-210) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 218,
          "vulnerability_to_line": 242,
          "vulnerability_code": "  function transferFrom(TokenStorage storage self,\n\n                        address _from,\n\n                        address _to,\n\n                        uint256 _value)\n\n                        public\n\n                        returns (bool)\n\n  {\n\n    var _allowance = self.allowed[_from][msg.sender];\n\n    bool err;\n\n    uint256 balanceOwner;\n\n    uint256 balanceSpender;\n\n\n\n    (err,balanceOwner) = self.balances[_from].minus(_value);\n\n    require(!err);\n\n\n\n    (err,balanceSpender) = _allowance.minus(_value);\n\n    require(!err);\n\n\n\n    self.balances[_from] = balanceOwner;\n\n    self.allowed[_from][msg.sender] = balanceSpender;\n\n    self.balances[_to] = self.balances[_to] + _value;\n\n\n\n    Transfer(_from, _to, _value);\n\n    return true;\n",
          "message": "TokenLib.transferFrom (InteractiveCrowdsaleTestContract.sol#218-242) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 248,
          "vulnerability_to_line": 250,
          "vulnerability_code": "  function balanceOf(TokenStorage storage self, address _owner) public view returns (uint256 balance) {\n\n    return self.balances[_owner];\n",
          "message": "TokenLib.balanceOf (InteractiveCrowdsaleTestContract.sol#248-250) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 257,
          "vulnerability_to_line": 264,
          "vulnerability_code": "  function approve(TokenStorage storage self, address _spender, uint256 _value) public returns (bool) {\n\n    // must set to zero before changing approval amount in accordance with spec\n\n    require((_value == 0) || (self.allowed[msg.sender][_spender] == 0));\n\n\n\n    self.allowed[msg.sender][_spender] = _value;\n\n    Approval(msg.sender, _spender, _value);\n\n    return true;\n",
          "message": "TokenLib.approve (InteractiveCrowdsaleTestContract.sol#257-264) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 271,
          "vulnerability_to_line": 276,
          "vulnerability_code": "  function allowance(TokenStorage storage self, address _owner, address _spender)\n\n                     public\n\n                     view\n\n                     returns (uint256 remaining) {\n\n    return self.allowed[_owner][_spender];\n",
          "message": "TokenLib.allowance (InteractiveCrowdsaleTestContract.sol#271-276) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 284,
          "vulnerability_to_line": 306,
          "vulnerability_code": "  function approveChange (TokenStorage storage self, address _spender, uint256 _valueChange, bool _increase)\n\n                          public returns (bool)\n\n  {\n\n    uint256 _newAllowed;\n\n    bool err;\n\n\n\n    if(_increase) {\n\n      (err, _newAllowed) = self.allowed[msg.sender][_spender].plus(_valueChange);\n\n      require(!err);\n\n\n\n      self.allowed[msg.sender][_spender] = _newAllowed;\n\n    } else {\n\n      if (_valueChange > self.allowed[msg.sender][_spender]) {\n\n        self.allowed[msg.sender][_spender] = 0;\n\n      } else {\n\n        _newAllowed = self.allowed[msg.sender][_spender] - _valueChange;\n\n        self.allowed[msg.sender][_spender] = _newAllowed;\n\n      }\n\n    }\n\n\n\n    Approval(msg.sender, _spender, _newAllowed);\n\n    return true;\n",
          "message": "TokenLib.approveChange (InteractiveCrowdsaleTestContract.sol#284-306) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 312,
          "vulnerability_to_line": 318,
          "vulnerability_code": "  function changeOwner(TokenStorage storage self, address _newOwner) public returns (bool) {\n\n    require((self.owner == msg.sender) && (_newOwner > 0));\n\n\n\n    self.owner = _newOwner;\n\n    OwnerChange(msg.sender, _newOwner);\n\n    return true;\n",
          "message": "TokenLib.changeOwner (InteractiveCrowdsaleTestContract.sol#312-318) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 324,
          "vulnerability_to_line": 336,
          "vulnerability_code": "  function mintToken(TokenStorage storage self, uint256 _amount) public returns (bool) {\n\n    require((self.owner == msg.sender) && self.stillMinting);\n\n    uint256 _newAmount;\n\n    bool err;\n\n\n\n    (err, _newAmount) = self.totalSupply.plus(_amount);\n\n    require(!err);\n\n\n\n    self.totalSupply =  _newAmount;\n\n    self.balances[self.owner] = self.balances[self.owner] + _amount;\n\n    Transfer(0x0, self.owner, _amount);\n\n    return true;\n",
          "message": "TokenLib.mintToken (InteractiveCrowdsaleTestContract.sol#324-336) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 341,
          "vulnerability_to_line": 347,
          "vulnerability_code": "  function closeMint(TokenStorage storage self) public returns (bool) {\n\n    require(self.owner == msg.sender);\n\n\n\n    self.stillMinting = false;\n\n    MintingClosed(true);\n\n    return true;\n",
          "message": "TokenLib.closeMint (InteractiveCrowdsaleTestContract.sol#341-347) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 353,
          "vulnerability_to_line": 365,
          "vulnerability_code": "  function burnToken(TokenStorage storage self, uint256 _amount) public returns (bool) {\n\n      uint256 _newBalance;\n\n      bool err;\n\n\n\n      (err, _newBalance) = self.balances[msg.sender].minus(_amount);\n\n      require(!err);\n\n\n\n      self.balances[msg.sender] = _newBalance;\n\n      self.totalSupply = self.totalSupply - _amount;\n\n      Burn(msg.sender, _amount);\n\n      Transfer(msg.sender, 0x0, _amount);\n\n      return true;\n",
          "message": "TokenLib.burnToken (InteractiveCrowdsaleTestContract.sol#353-365) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 415,
          "vulnerability_to_line": 417,
          "vulnerability_code": "  function name() public view returns (string) {\n\n    return token.name;\n",
          "message": "CrowdsaleToken.name (InteractiveCrowdsaleTestContract.sol#415-417) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 419,
          "vulnerability_to_line": 421,
          "vulnerability_code": "  function symbol() public view returns (string) {\n\n    return token.symbol;\n",
          "message": "CrowdsaleToken.symbol (InteractiveCrowdsaleTestContract.sol#419-421) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 423,
          "vulnerability_to_line": 425,
          "vulnerability_code": "  function decimals() public view returns (uint8) {\n\n    return token.decimals;\n",
          "message": "CrowdsaleToken.decimals (InteractiveCrowdsaleTestContract.sol#423-425) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 427,
          "vulnerability_to_line": 429,
          "vulnerability_code": "  function totalSupply() public view returns (uint256) {\n\n    return token.totalSupply;\n",
          "message": "CrowdsaleToken.totalSupply (InteractiveCrowdsaleTestContract.sol#427-429) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 431,
          "vulnerability_to_line": 433,
          "vulnerability_code": "  function initialSupply() public view returns (uint256) {\n\n    return token.initialSupply;\n",
          "message": "CrowdsaleToken.initialSupply (InteractiveCrowdsaleTestContract.sol#431-433) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 435,
          "vulnerability_to_line": 437,
          "vulnerability_code": "  function balanceOf(address who) public view returns (uint256) {\n\n    return token.balanceOf(who);\n",
          "message": "CrowdsaleToken.balanceOf (InteractiveCrowdsaleTestContract.sol#435-437) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 439,
          "vulnerability_to_line": 441,
          "vulnerability_code": "  function allowance(address owner, address spender) public view returns (uint256) {\n\n    return token.allowance(owner, spender);\n",
          "message": "CrowdsaleToken.allowance (InteractiveCrowdsaleTestContract.sol#439-441) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 443,
          "vulnerability_to_line": 445,
          "vulnerability_code": "  function transfer(address to, uint value) public returns (bool ok) {\n\n    return token.transfer(to, value);\n",
          "message": "CrowdsaleToken.transfer (InteractiveCrowdsaleTestContract.sol#443-445) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 447,
          "vulnerability_to_line": 449,
          "vulnerability_code": "  function transferFrom(address from, address to, uint value) public returns (bool ok) {\n\n    return token.transferFrom(from, to, value);\n",
          "message": "CrowdsaleToken.transferFrom (InteractiveCrowdsaleTestContract.sol#447-449) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 451,
          "vulnerability_to_line": 453,
          "vulnerability_code": "  function approve(address spender, uint value) public returns (bool ok) {\n\n    return token.approve(spender, value);\n",
          "message": "CrowdsaleToken.approve (InteractiveCrowdsaleTestContract.sol#451-453) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 455,
          "vulnerability_to_line": 459,
          "vulnerability_code": "  function approveChange(address spender, uint256 valueChange, bool increase)\n\n                         public returns (bool ok)\n\n  {\n\n    return token.approveChange(spender, valueChange, increase);\n",
          "message": "CrowdsaleToken.approveChange (InteractiveCrowdsaleTestContract.sol#455-459) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 461,
          "vulnerability_to_line": 463,
          "vulnerability_code": "  function changeOwner(address newOwner) public returns (bool ok) {\n\n    return token.changeOwner(newOwner);\n",
          "message": "CrowdsaleToken.changeOwner (InteractiveCrowdsaleTestContract.sol#461-463) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 465,
          "vulnerability_to_line": 467,
          "vulnerability_code": "  function mintToken(uint256 amount) public returns (bool ok) {\n\n    return token.mintToken(amount);\n",
          "message": "CrowdsaleToken.mintToken (InteractiveCrowdsaleTestContract.sol#465-467) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 469,
          "vulnerability_to_line": 471,
          "vulnerability_code": "  function closeMint() public returns (bool ok) {\n\n    return token.closeMint();\n",
          "message": "CrowdsaleToken.closeMint (InteractiveCrowdsaleTestContract.sol#469-471) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 473,
          "vulnerability_to_line": 475,
          "vulnerability_code": "  function burnToken(uint256 amount) public returns (bool ok) {\n\n    return token.burnToken(amount);\n",
          "message": "CrowdsaleToken.burnToken (InteractiveCrowdsaleTestContract.sol#473-475) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 567,
          "vulnerability_to_line": 599,
          "vulnerability_code": "  function init(CrowdsaleStorage storage self,\n\n                address _owner,\n\n                uint256[] _saleData,\n\n                uint256 _endTime,\n\n                uint8 _percentBurn,\n\n                CrowdsaleToken _token)\n\n                public\n\n  {\n\n  \trequire(self.owner == 0);\n\n    require(_saleData.length > 0);\n\n    require((_saleData.length%3) == 0); // ensure saleData is 3-item sets\n\n    require(_saleData[0] > (now + 2 hours));\n\n    require(_endTime > _saleData[0]);\n\n    require(_owner > 0);\n\n    require(_percentBurn <= 100);\n\n    self.owner = _owner;\n\n    self.startTime = _saleData[0];\n\n    self.endTime = _endTime;\n\n    self.token = _token;\n\n    self.percentBurn = _percentBurn;\n\n\n\n    uint256 _tempTime;\n\n    for(uint256 i = 0; i < _saleData.length; i += 3){\n\n      require(_saleData[i] > _tempTime);\n\n      require(_saleData[i + 1] > 0);\n\n      require((_saleData[i + 2] == 0) || (_saleData[i + 2] >= 100));\n\n      self.milestoneTimes.push(_saleData[i]);\n\n      self.saleData[_saleData[i]][0] = _saleData[i + 1];\n\n      self.saleData[_saleData[i]][1] = _saleData[i + 2];\n\n      _tempTime = _saleData[i];\n\n    }\n\n    changeTokenPrice(self, _saleData[1]);\n",
          "message": "CrowdsaleLib.init (InteractiveCrowdsaleTestContract.sol#567-599) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 631,
          "vulnerability_to_line": 659,
          "vulnerability_code": "  function withdrawTokens(CrowdsaleStorage storage self) public returns (bool) {\n\n    bool ok;\n\n\n\n    if (self.withdrawTokensMap[msg.sender] == 0) {\n\n      LogErrorMsg(0, \"Sender has no tokens to withdraw!\");\n\n      return false;\n\n    }\n\n\n\n    if (msg.sender == self.owner) {\n\n      if(!crowdsaleEnded(self)){\n\n        LogErrorMsg(0, \"Owner cannot withdraw extra tokens until after the sale!\");\n\n        return false;\n\n      } else {\n\n        if(self.percentBurn > 0){\n\n          uint256 _burnAmount = (self.withdrawTokensMap[msg.sender] * self.percentBurn)/100;\n\n          self.withdrawTokensMap[msg.sender] = self.withdrawTokensMap[msg.sender] - _burnAmount;\n\n          ok = self.token.burnToken(_burnAmount);\n\n          require(ok);\n\n        }\n\n      }\n\n    }\n\n\n\n    var total = self.withdrawTokensMap[msg.sender];\n\n    self.withdrawTokensMap[msg.sender] = 0;\n\n    ok = self.token.transfer(msg.sender, total);\n\n    require(ok);\n\n    LogTokensWithdrawn(msg.sender, total);\n\n    return true;\n",
          "message": "CrowdsaleLib.withdrawTokens (InteractiveCrowdsaleTestContract.sol#631-659) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 664,
          "vulnerability_to_line": 675,
          "vulnerability_code": "  function withdrawLeftoverWei(CrowdsaleStorage storage self) public returns (bool) {\n\n    if (self.leftoverWei[msg.sender] == 0) {\n\n      LogErrorMsg(0, \"Sender has no extra wei to withdraw!\");\n\n      return false;\n\n    }\n\n\n\n    var total = self.leftoverWei[msg.sender];\n\n    self.leftoverWei[msg.sender] = 0;\n\n    msg.sender.transfer(total);\n\n    LogWeiWithdrawn(msg.sender, total);\n\n    return true;\n",
          "message": "CrowdsaleLib.withdrawLeftoverWei (InteractiveCrowdsaleTestContract.sol#664-675) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 680,
          "vulnerability_to_line": 695,
          "vulnerability_code": "  function withdrawOwnerEth(CrowdsaleStorage storage self) public returns (bool) {\n\n    if ((!crowdsaleEnded(self)) && (self.token.balanceOf(this)>0)) {\n\n      LogErrorMsg(0, \"Cannot withdraw owner ether until after the sale!\");\n\n      return false;\n\n    }\n\n\n\n    require(msg.sender == self.owner);\n\n    require(self.ownerBalance > 0);\n\n\n\n    uint256 amount = self.ownerBalance;\n\n    self.ownerBalance = 0;\n\n    self.owner.transfer(amount);\n\n    LogOwnerEthWithdrawn(msg.sender,amount,\"Crowdsale owner has withdrawn all funds!\");\n\n\n\n    return true;\n",
          "message": "CrowdsaleLib.withdrawOwnerEth (InteractiveCrowdsaleTestContract.sol#680-695) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 716,
          "vulnerability_to_line": 729,
          "vulnerability_code": "  function setTokens(CrowdsaleStorage storage self) public returns (bool) {\n\n    require(msg.sender == self.owner);\n\n    require(!self.tokensSet);\n\n    require(now < self.endTime);\n\n\n\n    uint256 _tokenBalance;\n\n\n\n    _tokenBalance = self.token.balanceOf(this);\n\n    self.withdrawTokensMap[msg.sender] = _tokenBalance;\n\n    self.startingTokenBalance = _tokenBalance;\n\n    self.tokensSet = true;\n\n\n\n    return true;\n",
          "message": "CrowdsaleLib.setTokens (InteractiveCrowdsaleTestContract.sol#716-729) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 735,
          "vulnerability_to_line": 753,
          "vulnerability_code": "  function getSaleData(CrowdsaleStorage storage self, uint256 timestamp)\n\n                       public\n\n                       view\n\n                       returns (uint256[3])\n\n  {\n\n    uint256[3] memory _thisData;\n\n    uint256 index;\n\n\n\n    while((index < self.milestoneTimes.length) && (self.milestoneTimes[index] < timestamp)) {\n\n      index++;\n\n    }\n\n    if(index == 0)\n\n      index++;\n\n\n\n    _thisData[0] = self.milestoneTimes[index - 1];\n\n    _thisData[1] = self.saleData[_thisData[0]][0];\n\n    _thisData[2] = self.saleData[_thisData[0]][1];\n\n    return _thisData;\n",
          "message": "CrowdsaleLib.getSaleData (InteractiveCrowdsaleTestContract.sol#735-753) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 758,
          "vulnerability_to_line": 760,
          "vulnerability_code": "  function getTokensSold(CrowdsaleStorage storage self) public view returns (uint256) {\n\n    return self.startingTokenBalance - self.withdrawTokensMap[self.owner];\n",
          "message": "CrowdsaleLib.getTokensSold (InteractiveCrowdsaleTestContract.sol#758-760) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 1099,
          "vulnerability_to_line": 1134,
          "vulnerability_code": "  function init(InteractiveCrowdsaleStorage storage self,\n\n                address _owner,\n\n                uint256[] _saleData,\n\n                uint256 _priceBonusPercent,\n\n                uint256 _minimumRaise,\n\n                uint256 _endWithdrawalTime,\n\n                uint256 _endTime,\n\n                uint8 _percentBeingSold,\n\n                string _tokenName,\n\n                string _tokenSymbol,\n\n                uint8 _tokenDecimals,\n\n                bool _allowMinting) public\n\n  {\n\n    self.base.init(_owner,\n\n                _saleData,\n\n                _endTime,\n\n                0, // no token burning for iico\n\n                CrowdsaleToken(0)); // no tokens created prior to iico\n\n\n\n    require(_endWithdrawalTime < _endTime);\n\n    require(_endWithdrawalTime > _saleData[0]);\n\n    require(_minimumRaise > 0);\n\n    require(_percentBeingSold > 0);\n\n    require(_percentBeingSold <= 100);\n\n    require(_priceBonusPercent > 0);\n\n\n\n    self.minimumRaise = _minimumRaise;\n\n    self.endWithdrawalTime = _endWithdrawalTime;\n\n    self.percentBeingSold = _percentBeingSold;\n\n    self.priceBonusPercent = _priceBonusPercent;\n\n\n\n    self.tokenInfo.name = _tokenName;\n\n    self.tokenInfo.symbol = _tokenSymbol;\n\n    self.tokenInfo.decimals = _tokenDecimals;\n\n    self.tokenInfo.stillMinting = _allowMinting;\n",
          "message": "InteractiveCrowdsaleLib.init (InteractiveCrowdsaleTestContract.sol#1099-1134) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 1201,
          "vulnerability_to_line": 1308,
          "vulnerability_code": "  function submitBid(InteractiveCrowdsaleStorage storage self,\n\n                      uint256 _amount,\n\n                      uint256 _personalCap,\n\n                      uint256 _valuePredict) public returns (bool)\n\n  {\n\n    require(msg.sender != self.base.owner);\n\n    require(self.base.validPurchase());\n\n    // bidder can't have already bid\n\n    require((self.personalCaps[msg.sender] == 0) && (self.base.hasContributed[msg.sender] == 0));\n\n\n\n    uint256 _bonusPercent;\n\n    // token purchase bonus only applies before the withdrawal lock\n\n    if (now < self.endWithdrawalTime) {\n\n      require(_personalCap > _amount);\n\n      _bonusPercent = getCurrentBonus(self);\n\n    } else {\n\n      // The personal valuation submitted must be greater than the current\n\n      // valuation plus the bid if after the withdrawal lock.\n\n      require(_personalCap >= self.totalValuation + _amount);\n\n    }\n\n\n\n    // personal valuation and minimum should be set to the proper granularity,\n\n    // only three most significant values can be non-zero. reduces the number of possible\n\n    // valuation buckets in the linked list\n\n    uint256 digits = numDigits(_personalCap);\n\n    if(digits > 3) {\n\n      require((_personalCap % (10**(digits - 3))) == 0);\n\n    }\n\n\n\n    // add the bid to the sorted valuations list\n\n    // duplicate personal valuation caps share a spot in the linked list\n\n    uint256 _listSpot;\n\n    if(!self.valuationsList.nodeExists(_personalCap)){\n\n        _listSpot = self.valuationsList.getSortedSpot(_valuePredict,_personalCap,NEXT);\n\n        self.valuationsList.insert(_listSpot,_personalCap,PREV);\n\n    }\n\n\n\n    // add the bid to the address => cap mapping\n\n    self.personalCaps[msg.sender] = _personalCap;\n\n\n\n    // add the bid to the sum of bids at this valuation. Needed for calculating correct valuation pointer\n\n    self.valuationSums[_personalCap] += _amount;\n\n    self.numBidsAtValuation[_personalCap] += 1;\n\n\n\n    // add the bid to bidder's contribution amount\n\n    self.base.hasContributed[msg.sender] += _amount;\n\n\n\n    // temp variables for calculation\n\n    uint256 _proposedCommit;\n\n    uint256 _currentBucket;\n\n    bool loop;\n\n    bool exists;\n\n\n\n    // we only affect the pointer if we are coming in above it\n\n    if(_personalCap > self.currentBucket){\n\n\n\n      // if our valuation is sitting at the current bucket then we are using\n\n      // commitments right at their cap\n\n      if (self.totalValuation == self.currentBucket) {\n\n        // we are going to drop those commitments to see if we are going to be\n\n        // greater than the current bucket without them\n\n        _proposedCommit = (self.valueCommitted - self.valuationSums[self.currentBucket]) + _amount;\n\n        if(_proposedCommit > self.currentBucket){ loop = true; }\n\n      } else {\n\n        // else we're sitting in between buckets and have already dropped the\n\n        // previous commitments\n\n        _proposedCommit = self.totalValuation + _amount;\n\n        loop = true;\n\n      }\n\n\n\n      if(loop){\n\n        // if we're going to loop we move to the next bucket\n\n        (exists,_currentBucket) = self.valuationsList.getAdjacent(self.currentBucket, NEXT);\n\n\n\n        while(_proposedCommit >= _currentBucket){\n\n          // while we are proposed higher than the next bucket we drop commitments\n\n          // and iterate to the next\n\n          _proposedCommit = _proposedCommit - self.valuationSums[_currentBucket];\n\n          (exists,_currentBucket) = self.valuationsList.getAdjacent(_currentBucket, NEXT);\n\n        }\n\n        // once we've reached a bucket too high we move back to the last bucket and set it\n\n        (exists, _currentBucket) = self.valuationsList.getAdjacent(_currentBucket, PREV);\n\n        self.currentBucket = _currentBucket;\n\n      } else {\n\n        // else we're staying at the current bucket\n\n        _currentBucket = self.currentBucket;\n\n      }\n\n      // if our proposed commitment is less than or equal to the bucket\n\n      if(_proposedCommit <= _currentBucket){\n\n        // we add the commitments in that bucket\n\n        _proposedCommit += self.valuationSums[_currentBucket];\n\n        // and our value is capped at that bucket\n\n        self.totalValuation = _currentBucket;\n\n      } else {\n\n        // else our total value is in between buckets and it equals the total commitements\n\n        self.totalValuation = _proposedCommit;\n\n      }\n\n\n\n      self.valueCommitted = _proposedCommit;\n\n    } else if(_personalCap == self.totalValuation){\n\n      self.valueCommitted += _amount;\n\n    }\n\n\n\n    self.pricePurchasedAt[msg.sender] = (self.base.tokensPerEth * (100 + _bonusPercent))/100;\n\n    LogBidAccepted(msg.sender, _amount, _personalCap);\n\n    BucketAndValuationAndCommitted(self.currentBucket, self.totalValuation, self.valueCommitted);\n\n    return true;\n",
          "message": "InteractiveCrowdsaleLib.submitBid (InteractiveCrowdsaleTestContract.sol#1201-1308) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 1315,
          "vulnerability_to_line": 1423,
          "vulnerability_code": "  function withdrawBid(InteractiveCrowdsaleStorage storage self) public returns (bool) {\n\n    // The sender has to have already bid on the sale\n\n    require(self.personalCaps[msg.sender] > 0);\n\n\n\n    uint256 refundWei;\n\n    // cannot withdraw after compulsory withdraw period is over unless the bid's\n\n    // valuation is below the cutoff\n\n    if (now >= self.endWithdrawalTime) {\n\n      require(self.personalCaps[msg.sender] < self.totalValuation);\n\n\n\n      // full refund because their bid no longer affects the total sale valuation\n\n      refundWei = self.base.hasContributed[msg.sender];\n\n\n\n    } else {\n\n      require(!self.hasManuallyWithdrawn[msg.sender]);  // manual withdrawals are only allowed once\n\n      /***********************************************************************\n\n      The following lines were commented out due to stack depth, but they represent\n\n      the variables and calculations from the paper. The actual code is the same\n\n      thing spelled out using current variables.  See section 4 of the white paper for formula used\n\n      ************************************************************************/\n\n      //uint256 t = self.endWithdrawalTime - self.base.startTime;\n\n      //uint256 s = now - self.base.startTime;\n\n      //uint256 pa = self.pricePurchasedAt[msg.sender];\n\n      //uint256 pu = self.base.tokensPerEth;\n\n      //uint256 multiplierPercent =  (100*(t - s))/t;\n\n      //self.pricePurchasedAt = pa-((pa-pu)/3)\n\n\n\n      uint256 multiplierPercent = (100 * (self.endWithdrawalTime - now)) /\n\n                                  (self.endWithdrawalTime - self.base.startTime);\n\n      refundWei = (multiplierPercent * self.base.hasContributed[msg.sender]) / 100;\n\n      // SWC-Integer Overflow and Underflow: L392-L395\n\n      self.valuationSums[self.personalCaps[msg.sender]] -= refundWei;\n\n      self.numBidsAtValuation[self.personalCaps[msg.sender]] -= 1;\n\n\n\n      self.pricePurchasedAt[msg.sender] = self.pricePurchasedAt[msg.sender] -\n\n                                          ((self.pricePurchasedAt[msg.sender] - self.base.tokensPerEth) / 3);\n\n\n\n      self.hasManuallyWithdrawn[msg.sender] = true;\n\n\n\n    }\n\n\n\n    // Put the sender's contributed wei into the leftoverWei mapping for later withdrawal\n\n    self.base.leftoverWei[msg.sender] += refundWei;\n\n\n\n    // subtract the bidder's refund from its total contribution\n\n    self.base.hasContributed[msg.sender] -= refundWei;\n\n\n\n\n\n    uint256 _proposedCommit;\n\n    uint256 _proposedValue;\n\n    uint256 _currentBucket;\n\n    bool loop;\n\n    bool exists;\n\n\n\n    // bidder's withdrawal only affects the pointer if the personal cap is at or\n\n    // above the current valuation\n\n    if(self.personalCaps[msg.sender] >= self.totalValuation){\n\n\n\n      // first we remove the refundWei from the committed value\n\n      _proposedCommit = self.valueCommitted - refundWei;\n\n\n\n      // if we've dropped below the current bucket\n\n      if(_proposedCommit <= self.currentBucket){\n\n        // and current valuation is above the bucket\n\n        if(self.totalValuation > self.currentBucket){\n\n          _proposedCommit += self.valuationSums[self.currentBucket];\n\n        }\n\n\n\n        if(_proposedCommit >= self.currentBucket){\n\n          _proposedValue = self.currentBucket;\n\n        } else {\n\n          // if we are still below the current bucket then we need to iterate\n\n          loop = true;\n\n        }\n\n      } else {\n\n        if(self.totalValuation == self.currentBucket){\n\n          _proposedValue = self.totalValuation;\n\n        } else {\n\n          _proposedValue = _proposedCommit;\n\n        }\n\n      }\n\n\n\n      if(loop){\n\n        // if we're going to loop we move to the previous bucket\n\n        (exists,_currentBucket) = self.valuationsList.getAdjacent(self.currentBucket, PREV);\n\n        while(_proposedCommit <= _currentBucket){\n\n          // while we are proposed lower than the previous bucket we add commitments\n\n          _proposedCommit += self.valuationSums[_currentBucket];\n\n          // and iterate to the previous\n\n          if(_proposedCommit >= _currentBucket){\n\n            _proposedValue = _currentBucket;\n\n          } else {\n\n            (exists,_currentBucket) = self.valuationsList.getAdjacent(_currentBucket, PREV);\n\n          }\n\n        }\n\n\n\n        if(_proposedValue == 0) { _proposedValue = _proposedCommit; }\n\n\n\n        self.currentBucket = _currentBucket;\n\n      }\n\n\n\n      self.totalValuation = _proposedValue;\n\n      self.valueCommitted = _proposedCommit;\n\n    }\n\n\n\n    LogBidWithdrawn(msg.sender, refundWei, self.personalCaps[msg.sender]);\n\n    BucketAndValuationAndCommitted(self.currentBucket, self.totalValuation, self.valueCommitted);\n\n    return true;\n",
          "message": "InteractiveCrowdsaleLib.withdrawBid (InteractiveCrowdsaleTestContract.sol#1315-1423) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 1428,
          "vulnerability_to_line": 1450,
          "vulnerability_code": "  function finalizeSale(InteractiveCrowdsaleStorage storage self) public returns (bool) {\n\n    require(now >= self.base.endTime);\n\n    require(!self.isFinalized); // can only be called once\n\n    require(setCanceled(self));\n\n\n\n    self.isFinalized = true;\n\n    require(launchToken(self));\n\n    // may need to be computed due to EVM rounding errors\n\n    uint256 computedValue;\n\n\n\n    if(!self.isCanceled){\n\n      if(self.totalValuation == self.currentBucket){\n\n        // calculate the fraction of each minimal valuation bidders ether and tokens to refund\n\n        self.q = (100*(self.valueCommitted - self.totalValuation)/(self.valuationSums[self.totalValuation])) + 1;\n\n        computedValue = self.valueCommitted - self.valuationSums[self.totalValuation];\n\n        computedValue += (self.q * self.valuationSums[self.totalValuation])/100;\n\n      } else {\n\n        // no computation necessary\n\n        computedValue = self.totalValuation;\n\n      }\n\n      self.base.ownerBalance = computedValue;  // sets ETH raised in the sale to be ready for withdrawal\n\n    }\n",
          "message": "InteractiveCrowdsaleLib.finalizeSale (InteractiveCrowdsaleTestContract.sol#1428-1450) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 1510,
          "vulnerability_to_line": 1578,
          "vulnerability_code": "  function retreiveFinalResult(InteractiveCrowdsaleStorage storage self) public returns (bool) {\n\n    require(now > self.base.endTime);\n\n    require(self.personalCaps[msg.sender] > 0);\n\n\n\n    uint256 numTokens;\n\n    uint256 remainder;\n\n\n\n    if(!self.isFinalized){\n\n      require(setCanceled(self));\n\n      require(self.isCanceled);\n\n    }\n\n\n\n    if (self.isCanceled) {\n\n      // if the sale was canceled, everyone gets a full refund\n\n      self.base.leftoverWei[msg.sender] += self.base.hasContributed[msg.sender];\n\n      self.base.hasContributed[msg.sender] = 0;\n\n      LogErrorMsg(self.totalValuation, \"Sale is canceled, all bids have been refunded!\");\n\n      return true;\n\n    }\n\n\n\n    if (self.personalCaps[msg.sender] < self.totalValuation) {\n\n\n\n      // full refund if personal cap is less than total valuation\n\n      self.base.leftoverWei[msg.sender] += self.base.hasContributed[msg.sender];\n\n\n\n      // set hasContributed to 0 to prevent participant from calling this over and over\n\n      self.base.hasContributed[msg.sender] = 0;\n\n\n\n      return self.base.withdrawLeftoverWei();\n\n\n\n    } else if (self.personalCaps[msg.sender] == self.totalValuation) {\n\n\n\n      // calculate the portion that this address has to take out of their bid\n\n      uint256 refundAmount = (self.q*self.base.hasContributed[msg.sender])/100;\n\n\n\n      // refund that amount of wei to the address\n\n      self.base.leftoverWei[msg.sender] += refundAmount;\n\n\n\n      // subtract that amount the address' contribution\n\n      self.base.hasContributed[msg.sender] -= refundAmount;\n\n    }\n\n\n\n    LogErrorMsg(self.base.hasContributed[msg.sender],\"contribution\");\n\n    LogErrorMsg(self.pricePurchasedAt[msg.sender],\"price\");\n\n    LogErrorMsg(self.q,\"percentage\");\n\n    // calculate the number of tokens that the bidder purchased\n\n    (numTokens, remainder) = calculateTokenPurchase(self.base.hasContributed[msg.sender],\n\n                                                    self.pricePurchasedAt[msg.sender]);\n\n\n\n    // add tokens to the bidders purchase.  can't overflow because it will be under the cap\n\n    self.base.withdrawTokensMap[msg.sender] += numTokens;\n\n    self.valueCommitted = self.valueCommitted - remainder;\n\n    self.base.leftoverWei[msg.sender] += remainder;\n\n\n\n    // burn any extra bonus tokens\n\n    uint256 _fullBonus;\n\n    uint256 _fullBonusPrice = (self.base.tokensPerEth*(100 + self.priceBonusPercent))/100;\n\n    (_fullBonus, remainder) = calculateTokenPurchase(self.base.hasContributed[msg.sender], _fullBonusPrice);\n\n    uint256 _leftoverBonus = _fullBonus - numTokens;\n\n    self.base.token.burnToken(_leftoverBonus);\n\n\n\n    self.base.hasContributed[msg.sender] = 0;\n\n\n\n    // send tokens and leftoverWei to the address calling the function\n\n    self.base.withdrawTokens();\n\n\n\n    self.base.withdrawLeftoverWei();\n\n\n",
          "message": "InteractiveCrowdsaleLib.retreiveFinalResult (InteractiveCrowdsaleTestContract.sol#1510-1578) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 1657,
          "vulnerability_to_line": 1659,
          "vulnerability_code": "  function () public {\n\n    LogErrorMsg(0, 'Did not send correct data!');\n",
          "message": "InteractiveCrowdsaleTestContract.fallback (InteractiveCrowdsaleTestContract.sol#1657-1659) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 1661,
          "vulnerability_to_line": 1663,
          "vulnerability_code": "  function submitBid(uint256 _personalValuation, uint256 _listPredict) payable public returns (bool) {\n\n    return sale.submitBid(msg.value, _personalValuation, _listPredict);\n",
          "message": "InteractiveCrowdsaleTestContract.submitBid (InteractiveCrowdsaleTestContract.sol#1661-1663) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 1665,
          "vulnerability_to_line": 1667,
          "vulnerability_code": "  function withdrawBid() public returns (bool) {\n\n    return sale.withdrawBid();\n",
          "message": "InteractiveCrowdsaleTestContract.withdrawBid (InteractiveCrowdsaleTestContract.sol#1665-1667) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 1669,
          "vulnerability_to_line": 1671,
          "vulnerability_code": "  function withdrawLeftoverWei() public returns (bool) {\n\n    return sale.withdrawLeftoverWei();\n",
          "message": "InteractiveCrowdsaleTestContract.withdrawLeftoverWei (InteractiveCrowdsaleTestContract.sol#1669-1671) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 1673,
          "vulnerability_to_line": 1675,
          "vulnerability_code": "  function retreiveFinalResult() public returns (bool) {\n\n    return sale.retreiveFinalResult();\n",
          "message": "InteractiveCrowdsaleTestContract.retreiveFinalResult (InteractiveCrowdsaleTestContract.sol#1673-1675) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 1677,
          "vulnerability_to_line": 1679,
          "vulnerability_code": "  function finalizeSale() public returns (bool) {\n\n    return sale.finalizeSale();\n",
          "message": "InteractiveCrowdsaleTestContract.finalizeSale (InteractiveCrowdsaleTestContract.sol#1677-1679) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 1681,
          "vulnerability_to_line": 1683,
          "vulnerability_code": "  function withdrawOwnerEth() public returns (bool) {\n\n  \treturn sale.withdrawOwnerEth();\n",
          "message": "InteractiveCrowdsaleTestContract.withdrawOwnerEth (InteractiveCrowdsaleTestContract.sol#1681-1683) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 1685,
          "vulnerability_to_line": 1687,
          "vulnerability_code": "  function crowdsaleActive() public view returns (bool) {\n\n  \treturn sale.crowdsaleActive();\n",
          "message": "InteractiveCrowdsaleTestContract.crowdsaleActive (InteractiveCrowdsaleTestContract.sol#1685-1687) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 1689,
          "vulnerability_to_line": 1691,
          "vulnerability_code": "  function crowdsaleEnded() public view returns (bool) {\n\n  \treturn sale.crowdsaleEnded();\n",
          "message": "InteractiveCrowdsaleTestContract.crowdsaleEnded (InteractiveCrowdsaleTestContract.sol#1689-1691) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 1693,
          "vulnerability_to_line": 1695,
          "vulnerability_code": "  function getOwner() public view returns (address) {\n\n    return sale.base.owner;\n",
          "message": "InteractiveCrowdsaleTestContract.getOwner (InteractiveCrowdsaleTestContract.sol#1693-1695) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 1697,
          "vulnerability_to_line": 1699,
          "vulnerability_code": "  function getTokensPerEth() public view returns (uint256) {\n\n    return sale.base.tokensPerEth;\n",
          "message": "InteractiveCrowdsaleTestContract.getTokensPerEth (InteractiveCrowdsaleTestContract.sol#1697-1699) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 1701,
          "vulnerability_to_line": 1703,
          "vulnerability_code": "  function getStartTime() public view returns (uint256) {\n\n    return sale.base.startTime;\n",
          "message": "InteractiveCrowdsaleTestContract.getStartTime (InteractiveCrowdsaleTestContract.sol#1701-1703) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 1705,
          "vulnerability_to_line": 1707,
          "vulnerability_code": "  function getEndTime() public view returns (uint256) {\n\n    return sale.base.endTime;\n",
          "message": "InteractiveCrowdsaleTestContract.getEndTime (InteractiveCrowdsaleTestContract.sol#1705-1707) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 1709,
          "vulnerability_to_line": 1711,
          "vulnerability_code": "  function getMinimumRaise() public view returns (uint256) {\n\n    return sale.minimumRaise;\n",
          "message": "InteractiveCrowdsaleTestContract.getMinimumRaise (InteractiveCrowdsaleTestContract.sol#1709-1711) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 1713,
          "vulnerability_to_line": 1715,
          "vulnerability_code": "  function getEndWithdrawlTime() public view returns (uint256) {\n\n    return sale.endWithdrawalTime;\n",
          "message": "InteractiveCrowdsaleTestContract.getEndWithdrawlTime (InteractiveCrowdsaleTestContract.sol#1713-1715) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 1717,
          "vulnerability_to_line": 1719,
          "vulnerability_code": "  function getCommittedCapital() public view returns (uint256) {\n\n    return sale.valueCommitted;\n",
          "message": "InteractiveCrowdsaleTestContract.getCommittedCapital (InteractiveCrowdsaleTestContract.sol#1717-1719) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 1721,
          "vulnerability_to_line": 1723,
          "vulnerability_code": "  function getContribution(address _buyer) public view returns (uint256) {\n\n    return sale.base.hasContributed[_buyer];\n",
          "message": "InteractiveCrowdsaleTestContract.getContribution (InteractiveCrowdsaleTestContract.sol#1721-1723) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 1725,
          "vulnerability_to_line": 1727,
          "vulnerability_code": "  function getLeftoverWei(address _buyer) public view returns (uint256) {\n\n    return sale.base.leftoverWei[_buyer];\n",
          "message": "InteractiveCrowdsaleTestContract.getLeftoverWei (InteractiveCrowdsaleTestContract.sol#1725-1727) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 1729,
          "vulnerability_to_line": 1731,
          "vulnerability_code": "  function getPersonalCap(address _bidder) public view returns (uint256) {\n\n    return sale.getPersonalCap(_bidder);\n",
          "message": "InteractiveCrowdsaleTestContract.getPersonalCap (InteractiveCrowdsaleTestContract.sol#1729-1731) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 1733,
          "vulnerability_to_line": 1735,
          "vulnerability_code": "  function getPrice(address _bidder) public view returns (uint256) {\n\n    return sale.pricePurchasedAt[_bidder];\n",
          "message": "InteractiveCrowdsaleTestContract.getPrice (InteractiveCrowdsaleTestContract.sol#1733-1735) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 1737,
          "vulnerability_to_line": 1739,
          "vulnerability_code": "  function getTokensSold() public view returns (uint256) {\n\n    return sale.getTokensSold();\n",
          "message": "InteractiveCrowdsaleTestContract.getTokensSold (InteractiveCrowdsaleTestContract.sol#1737-1739) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 1741,
          "vulnerability_to_line": 1743,
          "vulnerability_code": "  function getPercentBeingSold() public view returns (uint256) {\n\n    return sale.percentBeingSold;\n",
          "message": "InteractiveCrowdsaleTestContract.getPercentBeingSold (InteractiveCrowdsaleTestContract.sol#1741-1743) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 1745,
          "vulnerability_to_line": 1747,
          "vulnerability_code": "  function getCurrentBucket() public view returns (uint256) {\n\n    return sale.currentBucket;\n",
          "message": "InteractiveCrowdsaleTestContract.getCurrentBucket (InteractiveCrowdsaleTestContract.sol#1745-1747) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 1749,
          "vulnerability_to_line": 1751,
          "vulnerability_code": "  function getTotalValuation() public view returns (uint256) {\n\n    return sale.totalValuation;\n",
          "message": "InteractiveCrowdsaleTestContract.getTotalValuation (InteractiveCrowdsaleTestContract.sol#1749-1751) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 1753,
          "vulnerability_to_line": 1755,
          "vulnerability_code": "  function getTokenAddress() public view returns (address) {\n\n    return address(sale.base.token);\n",
          "message": "InteractiveCrowdsaleTestContract.getTokenAddress (InteractiveCrowdsaleTestContract.sol#1753-1755) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 1757,
          "vulnerability_to_line": 1759,
          "vulnerability_code": "  function getValueCommitement(uint256 bucket) public view returns (uint256) {\n\n    return sale.valuationSums[bucket];\n",
          "message": "InteractiveCrowdsaleTestContract.getValueCommitement (InteractiveCrowdsaleTestContract.sol#1757-1759) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 1761,
          "vulnerability_to_line": 1763,
          "vulnerability_code": "  function getOwnerBalance() public view returns (uint256) {\n\n    return sale.base.ownerBalance;\n",
          "message": "InteractiveCrowdsaleTestContract.getOwnerBalance (InteractiveCrowdsaleTestContract.sol#1761-1763) should be declared external\n"
        },
        {
          "name": "solc-version",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.18;\n",
          "message": "Detected issues with version pragma in InteractiveCrowdsaleTestContract.sol:\n\t- pragma solidity^0.4.18 (InteractiveCrowdsaleTestContract.sol#3): it allows old versions\n\t- pragma solidity^0.4.18 (InteractiveCrowdsaleTestContract.sol#111): it allows old versions\n\t- pragma solidity^0.4.15 (InteractiveCrowdsaleTestContract.sol#370): it allows old versions\n\t- pragma solidity^0.4.18 (InteractiveCrowdsaleTestContract.sol#480): it allows old versions\n\t- pragma solidity^0.4.18 (InteractiveCrowdsaleTestContract.sol#765): it allows old versions\n\t- pragma solidity^0.4.18 (InteractiveCrowdsaleTestContract.sol#958): it allows old versions\n\t- pragma solidity^0.4.18 (InteractiveCrowdsaleTestContract.sol#1614): it allows old versions\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 173,
          "vulnerability_to_line": null,
          "vulnerability_code": "                address _owner,\n",
          "message": "Parameter '_owner' of TokenLib.init (InteractiveCrowdsaleTestContract.sol#173) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 174,
          "vulnerability_to_line": null,
          "vulnerability_code": "                string _name,\n",
          "message": "Parameter '_name' of TokenLib.init (InteractiveCrowdsaleTestContract.sol#174) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 175,
          "vulnerability_to_line": null,
          "vulnerability_code": "                string _symbol,\n",
          "message": "Parameter '_symbol' of TokenLib.init (InteractiveCrowdsaleTestContract.sol#175) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 176,
          "vulnerability_to_line": null,
          "vulnerability_code": "                uint8 _decimals,\n",
          "message": "Parameter '_decimals' of TokenLib.init (InteractiveCrowdsaleTestContract.sol#176) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 177,
          "vulnerability_to_line": null,
          "vulnerability_code": "                uint256 _initial_supply,\n",
          "message": "Parameter '_initial_supply' of TokenLib.init (InteractiveCrowdsaleTestContract.sol#177) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 178,
          "vulnerability_to_line": null,
          "vulnerability_code": "                bool _allowMinting)\n",
          "message": "Parameter '_allowMinting' of TokenLib.init (InteractiveCrowdsaleTestContract.sol#178) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 198,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function transfer(TokenStorage storage self, address _to, uint256 _value) public returns (bool) {\n",
          "message": "Parameter '_to' of TokenLib.transfer (InteractiveCrowdsaleTestContract.sol#198) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 198,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function transfer(TokenStorage storage self, address _to, uint256 _value) public returns (bool) {\n",
          "message": "Parameter '_value' of TokenLib.transfer (InteractiveCrowdsaleTestContract.sol#198) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 219,
          "vulnerability_to_line": null,
          "vulnerability_code": "                        address _from,\n",
          "message": "Parameter '_from' of TokenLib.transferFrom (InteractiveCrowdsaleTestContract.sol#219) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 220,
          "vulnerability_to_line": null,
          "vulnerability_code": "                        address _to,\n",
          "message": "Parameter '_to' of TokenLib.transferFrom (InteractiveCrowdsaleTestContract.sol#220) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 221,
          "vulnerability_to_line": null,
          "vulnerability_code": "                        uint256 _value)\n",
          "message": "Parameter '_value' of TokenLib.transferFrom (InteractiveCrowdsaleTestContract.sol#221) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 248,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function balanceOf(TokenStorage storage self, address _owner) public view returns (uint256 balance) {\n",
          "message": "Parameter '_owner' of TokenLib.balanceOf (InteractiveCrowdsaleTestContract.sol#248) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 257,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function approve(TokenStorage storage self, address _spender, uint256 _value) public returns (bool) {\n",
          "message": "Parameter '_spender' of TokenLib.approve (InteractiveCrowdsaleTestContract.sol#257) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 257,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function approve(TokenStorage storage self, address _spender, uint256 _value) public returns (bool) {\n",
          "message": "Parameter '_value' of TokenLib.approve (InteractiveCrowdsaleTestContract.sol#257) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 271,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function allowance(TokenStorage storage self, address _owner, address _spender)\n",
          "message": "Parameter '_owner' of TokenLib.allowance (InteractiveCrowdsaleTestContract.sol#271) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 271,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function allowance(TokenStorage storage self, address _owner, address _spender)\n",
          "message": "Parameter '_spender' of TokenLib.allowance (InteractiveCrowdsaleTestContract.sol#271) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 284,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function approveChange (TokenStorage storage self, address _spender, uint256 _valueChange, bool _increase)\n",
          "message": "Parameter '_spender' of TokenLib.approveChange (InteractiveCrowdsaleTestContract.sol#284) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 284,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function approveChange (TokenStorage storage self, address _spender, uint256 _valueChange, bool _increase)\n",
          "message": "Parameter '_valueChange' of TokenLib.approveChange (InteractiveCrowdsaleTestContract.sol#284) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 284,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function approveChange (TokenStorage storage self, address _spender, uint256 _valueChange, bool _increase)\n",
          "message": "Parameter '_increase' of TokenLib.approveChange (InteractiveCrowdsaleTestContract.sol#284) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 312,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function changeOwner(TokenStorage storage self, address _newOwner) public returns (bool) {\n",
          "message": "Parameter '_newOwner' of TokenLib.changeOwner (InteractiveCrowdsaleTestContract.sol#312) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 324,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function mintToken(TokenStorage storage self, uint256 _amount) public returns (bool) {\n",
          "message": "Parameter '_amount' of TokenLib.mintToken (InteractiveCrowdsaleTestContract.sol#324) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 353,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function burnToken(TokenStorage storage self, uint256 _amount) public returns (bool) {\n",
          "message": "Parameter '_amount' of TokenLib.burnToken (InteractiveCrowdsaleTestContract.sol#353) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 405,
          "vulnerability_to_line": 413,
          "vulnerability_code": "  function CrowdsaleToken(address owner,\n\n                          string name,\n\n                          string symbol,\n\n                          uint8 decimals,\n\n                          uint256 initialSupply,\n\n                          bool allowMinting) public\n\n  {\n\n    token.init(owner, name, symbol, decimals, initialSupply, allowMinting);\n",
          "message": "Function 'CrowdsaleToken.CrowdsaleToken' (InteractiveCrowdsaleTestContract.sol#405-413) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 568,
          "vulnerability_to_line": null,
          "vulnerability_code": "                address _owner,\n",
          "message": "Parameter '_owner' of CrowdsaleLib.init (InteractiveCrowdsaleTestContract.sol#568) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 569,
          "vulnerability_to_line": null,
          "vulnerability_code": "                uint256[] _saleData,\n",
          "message": "Parameter '_saleData' of CrowdsaleLib.init (InteractiveCrowdsaleTestContract.sol#569) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 570,
          "vulnerability_to_line": null,
          "vulnerability_code": "                uint256 _endTime,\n",
          "message": "Parameter '_endTime' of CrowdsaleLib.init (InteractiveCrowdsaleTestContract.sol#570) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 571,
          "vulnerability_to_line": null,
          "vulnerability_code": "                uint8 _percentBurn,\n",
          "message": "Parameter '_percentBurn' of CrowdsaleLib.init (InteractiveCrowdsaleTestContract.sol#571) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 572,
          "vulnerability_to_line": null,
          "vulnerability_code": "                CrowdsaleToken _token)\n",
          "message": "Parameter '_token' of CrowdsaleLib.init (InteractiveCrowdsaleTestContract.sol#572) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 702,
          "vulnerability_to_line": null,
          "vulnerability_code": "                            uint256 _tokensPerEth)\n",
          "message": "Parameter '_tokensPerEth' of CrowdsaleLib.changeTokenPrice (InteractiveCrowdsaleTestContract.sol#702) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 825,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function nodeExists(LinkedList storage self, uint256 _node) \n",
          "message": "Parameter '_node' of LinkedListLib.nodeExists (InteractiveCrowdsaleTestContract.sol#825) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 856,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getNode(LinkedList storage self, uint256 _node)\n",
          "message": "Parameter '_node' of LinkedListLib.getNode (InteractiveCrowdsaleTestContract.sol#856) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 870,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getAdjacent(LinkedList storage self, uint256 _node, bool _direction)\n",
          "message": "Parameter '_node' of LinkedListLib.getAdjacent (InteractiveCrowdsaleTestContract.sol#870) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 870,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getAdjacent(LinkedList storage self, uint256 _node, bool _direction)\n",
          "message": "Parameter '_direction' of LinkedListLib.getAdjacent (InteractiveCrowdsaleTestContract.sol#870) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 886,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getSortedSpot(LinkedList storage self, uint256 _node, uint256 _value, bool _direction)\n",
          "message": "Parameter '_node' of LinkedListLib.getSortedSpot (InteractiveCrowdsaleTestContract.sol#886) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 886,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getSortedSpot(LinkedList storage self, uint256 _node, uint256 _value, bool _direction)\n",
          "message": "Parameter '_value' of LinkedListLib.getSortedSpot (InteractiveCrowdsaleTestContract.sol#886) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 886,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getSortedSpot(LinkedList storage self, uint256 _node, uint256 _value, bool _direction)\n",
          "message": "Parameter '_direction' of LinkedListLib.getSortedSpot (InteractiveCrowdsaleTestContract.sol#886) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 902,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function createLink(LinkedList storage self, uint256 _node, uint256 _link, bool _direction) internal  {\n",
          "message": "Parameter '_node' of LinkedListLib.createLink (InteractiveCrowdsaleTestContract.sol#902) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 902,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function createLink(LinkedList storage self, uint256 _node, uint256 _link, bool _direction) internal  {\n",
          "message": "Parameter '_link' of LinkedListLib.createLink (InteractiveCrowdsaleTestContract.sol#902) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 902,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function createLink(LinkedList storage self, uint256 _node, uint256 _link, bool _direction) internal  {\n",
          "message": "Parameter '_direction' of LinkedListLib.createLink (InteractiveCrowdsaleTestContract.sol#902) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 912,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function insert(LinkedList storage self, uint256 _node, uint256 _new, bool _direction) internal returns (bool) {\n",
          "message": "Parameter '_node' of LinkedListLib.insert (InteractiveCrowdsaleTestContract.sol#912) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 912,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function insert(LinkedList storage self, uint256 _node, uint256 _new, bool _direction) internal returns (bool) {\n",
          "message": "Parameter '_new' of LinkedListLib.insert (InteractiveCrowdsaleTestContract.sol#912) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 912,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function insert(LinkedList storage self, uint256 _node, uint256 _new, bool _direction) internal returns (bool) {\n",
          "message": "Parameter '_direction' of LinkedListLib.insert (InteractiveCrowdsaleTestContract.sol#912) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 926,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function remove(LinkedList storage self, uint256 _node) internal returns (uint256) {\n",
          "message": "Parameter '_node' of LinkedListLib.remove (InteractiveCrowdsaleTestContract.sol#926) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 938,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function push(LinkedList storage self, uint256 _node, bool _direction) internal  {\n",
          "message": "Parameter '_node' of LinkedListLib.push (InteractiveCrowdsaleTestContract.sol#938) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 938,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function push(LinkedList storage self, uint256 _node, bool _direction) internal  {\n",
          "message": "Parameter '_direction' of LinkedListLib.push (InteractiveCrowdsaleTestContract.sol#938) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 945,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function pop(LinkedList storage self, bool _direction) internal returns (uint256) {\n",
          "message": "Parameter '_direction' of LinkedListLib.pop (InteractiveCrowdsaleTestContract.sol#945) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1100,
          "vulnerability_to_line": null,
          "vulnerability_code": "                address _owner,\n",
          "message": "Parameter '_owner' of InteractiveCrowdsaleLib.init (InteractiveCrowdsaleTestContract.sol#1100) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1101,
          "vulnerability_to_line": null,
          "vulnerability_code": "                uint256[] _saleData,\n",
          "message": "Parameter '_saleData' of InteractiveCrowdsaleLib.init (InteractiveCrowdsaleTestContract.sol#1101) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1102,
          "vulnerability_to_line": null,
          "vulnerability_code": "                uint256 _priceBonusPercent,\n",
          "message": "Parameter '_priceBonusPercent' of InteractiveCrowdsaleLib.init (InteractiveCrowdsaleTestContract.sol#1102) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1103,
          "vulnerability_to_line": null,
          "vulnerability_code": "                uint256 _minimumRaise,\n",
          "message": "Parameter '_minimumRaise' of InteractiveCrowdsaleLib.init (InteractiveCrowdsaleTestContract.sol#1103) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1104,
          "vulnerability_to_line": null,
          "vulnerability_code": "                uint256 _endWithdrawalTime,\n",
          "message": "Parameter '_endWithdrawalTime' of InteractiveCrowdsaleLib.init (InteractiveCrowdsaleTestContract.sol#1104) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1105,
          "vulnerability_to_line": null,
          "vulnerability_code": "                uint256 _endTime,\n",
          "message": "Parameter '_endTime' of InteractiveCrowdsaleLib.init (InteractiveCrowdsaleTestContract.sol#1105) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1106,
          "vulnerability_to_line": null,
          "vulnerability_code": "                uint8 _percentBeingSold,\n",
          "message": "Parameter '_percentBeingSold' of InteractiveCrowdsaleLib.init (InteractiveCrowdsaleTestContract.sol#1106) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1107,
          "vulnerability_to_line": null,
          "vulnerability_code": "                string _tokenName,\n",
          "message": "Parameter '_tokenName' of InteractiveCrowdsaleLib.init (InteractiveCrowdsaleTestContract.sol#1107) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1108,
          "vulnerability_to_line": null,
          "vulnerability_code": "                string _tokenSymbol,\n",
          "message": "Parameter '_tokenSymbol' of InteractiveCrowdsaleLib.init (InteractiveCrowdsaleTestContract.sol#1108) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1109,
          "vulnerability_to_line": null,
          "vulnerability_code": "                uint8 _tokenDecimals,\n",
          "message": "Parameter '_tokenDecimals' of InteractiveCrowdsaleLib.init (InteractiveCrowdsaleTestContract.sol#1109) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1110,
          "vulnerability_to_line": null,
          "vulnerability_code": "                bool _allowMinting) public\n",
          "message": "Parameter '_allowMinting' of InteractiveCrowdsaleLib.init (InteractiveCrowdsaleTestContract.sol#1110) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1139,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function numDigits(uint256 _number) public pure returns (uint256) {\n",
          "message": "Parameter '_number' of InteractiveCrowdsaleLib.numDigits (InteractiveCrowdsaleTestContract.sol#1139) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1154,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function calculateTokenPurchase(uint256 _amount,\n",
          "message": "Parameter '_amount' of InteractiveCrowdsaleLib.calculateTokenPurchase (InteractiveCrowdsaleTestContract.sol#1154) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1155,
          "vulnerability_to_line": null,
          "vulnerability_code": "                                  uint256 _price)\n",
          "message": "Parameter '_price' of InteractiveCrowdsaleLib.calculateTokenPurchase (InteractiveCrowdsaleTestContract.sol#1155) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1202,
          "vulnerability_to_line": null,
          "vulnerability_code": "                      uint256 _amount,\n",
          "message": "Parameter '_amount' of InteractiveCrowdsaleLib.submitBid (InteractiveCrowdsaleTestContract.sol#1202) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1203,
          "vulnerability_to_line": null,
          "vulnerability_code": "                      uint256 _personalCap,\n",
          "message": "Parameter '_personalCap' of InteractiveCrowdsaleLib.submitBid (InteractiveCrowdsaleTestContract.sol#1203) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1204,
          "vulnerability_to_line": null,
          "vulnerability_code": "                      uint256 _valuePredict) public returns (bool)\n",
          "message": "Parameter '_valuePredict' of InteractiveCrowdsaleLib.submitBid (InteractiveCrowdsaleTestContract.sol#1204) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1602,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function getPersonalCap(InteractiveCrowdsaleStorage storage self, address _bidder) internal view returns (uint256) {\n",
          "message": "Parameter '_bidder' of InteractiveCrowdsaleLib.getPersonalCap (InteractiveCrowdsaleTestContract.sol#1602) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1630,
          "vulnerability_to_line": 1655,
          "vulnerability_code": "  function InteractiveCrowdsaleTestContract(\n\n    address owner,\n\n    // SWC-Code With No Effects: L22\n\n    uint256[] saleData,\n\n    uint256 priceBonusPercent,\n\n    uint256 minimumRaise,\n\n    uint256 endWithdrawalTime,\n\n    uint256 endTime,\n\n    uint8 percentBeingSold,\n\n    string tokenName,\n\n    string tokenSymbol,\n\n    uint8 tokenDecimals,\n\n    bool allowMinting) public\n\n  {\n\n  \tsale.init(owner,\n\n              saleData,\n\n              priceBonusPercent,\n\n              minimumRaise,\n\n              endWithdrawalTime,\n\n              endTime,\n\n              percentBeingSold,\n\n              tokenName,\n\n              tokenSymbol,\n\n              tokenDecimals,\n\n              allowMinting);\n",
          "message": "Function 'InteractiveCrowdsaleTestContract.InteractiveCrowdsaleTestContract' (InteractiveCrowdsaleTestContract.sol#1630-1655) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1661,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function submitBid(uint256 _personalValuation, uint256 _listPredict) payable public returns (bool) {\n",
          "message": "Parameter '_personalValuation' of InteractiveCrowdsaleTestContract.submitBid (InteractiveCrowdsaleTestContract.sol#1661) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1661,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function submitBid(uint256 _personalValuation, uint256 _listPredict) payable public returns (bool) {\n",
          "message": "Parameter '_listPredict' of InteractiveCrowdsaleTestContract.submitBid (InteractiveCrowdsaleTestContract.sol#1661) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1721,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function getContribution(address _buyer) public view returns (uint256) {\n",
          "message": "Parameter '_buyer' of InteractiveCrowdsaleTestContract.getContribution (InteractiveCrowdsaleTestContract.sol#1721) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1725,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function getLeftoverWei(address _buyer) public view returns (uint256) {\n",
          "message": "Parameter '_buyer' of InteractiveCrowdsaleTestContract.getLeftoverWei (InteractiveCrowdsaleTestContract.sol#1725) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1729,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function getPersonalCap(address _bidder) public view returns (uint256) {\n",
          "message": "Parameter '_bidder' of InteractiveCrowdsaleTestContract.getPersonalCap (InteractiveCrowdsaleTestContract.sol#1729) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1733,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function getPrice(address _bidder) public view returns (uint256) {\n",
          "message": "Parameter '_bidder' of InteractiveCrowdsaleTestContract.getPrice (InteractiveCrowdsaleTestContract.sol#1733) is not in mixedCase\n"
        },
        {
          "name": "unused-state",
          "vulnerability_from_line": 998,
          "vulnerability_to_line": null,
          "vulnerability_code": "  uint256 constant NULL = 0;\n",
          "message": "InteractiveCrowdsaleLib.NULL (InteractiveCrowdsaleTestContract.sol#998) is never used in InteractiveCrowdsaleLib\nInteractiveCrowdsaleLib.HEAD (InteractiveCrowdsaleTestContract.sol#999) is never used in InteractiveCrowdsaleLib\n"
        }
      ]
    },
    "smartcheck": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "SOLIDITY_ERC20_APPROVE",
          "vulnerability_from_line": 451,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function approve(address spender, uint value) public returns (bool ok) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 589,
          "vulnerability_to_line": null,
          "vulnerability_code": "    for(uint256 i = 0; i < _saleData.length; i += 3){\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 743,
          "vulnerability_to_line": null,
          "vulnerability_code": "    while((index < self.milestoneTimes.length) && (self.milestoneTimes[index] < timestamp)) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
          "vulnerability_from_line": 1428,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function finalizeSale(InteractiveCrowdsaleStorage storage self) public returns (bool) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
          "vulnerability_from_line": 40,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function times(uint256 a, uint256 b) public pure returns (bool err,uint256 res) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
          "vulnerability_from_line": 57,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function dividedBy(uint256 a, uint256 b) public pure returns (bool err,uint256 i) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
          "vulnerability_from_line": 80,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function plus(uint256 a, uint256 b) public pure returns (bool err, uint256 res) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
          "vulnerability_from_line": 97,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function minus(uint256 a, uint256 b) public pure returns (bool err,uint256 res) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 589,
          "vulnerability_to_line": null,
          "vulnerability_code": "    for(uint256 i = 0; i < _saleData.length; i += 3){\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 743,
          "vulnerability_to_line": null,
          "vulnerability_code": "    while((index < self.milestoneTimes.length) && (self.milestoneTimes[index] < timestamp)) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 846,
          "vulnerability_to_line": null,
          "vulnerability_code": "        while (i != HEAD) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 894,
          "vulnerability_to_line": null,
          "vulnerability_code": "        while  ((next != 0) && (_value != next) && ((_value < next) != _direction)) next = self.list[next][_direction];\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 1275,
          "vulnerability_to_line": null,
          "vulnerability_code": "        while(_proposedCommit >= _currentBucket){\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 1400,
          "vulnerability_to_line": null,
          "vulnerability_code": "        while(_proposedCommit <= _currentBucket){\n",
          "message": null
        },
        {
          "name": "SOLIDITY_LOCKED_MONEY",
          "vulnerability_from_line": 1623,
          "vulnerability_to_line": null,
          "vulnerability_code": "contract InteractiveCrowdsaleTestContract {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.18;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 111,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.18;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 370,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.15;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 480,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.18;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 765,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.18;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 958,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.18;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 1614,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.18;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 40,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function times(uint256 a, uint256 b) public pure returns (bool err,uint256 res) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 57,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function dividedBy(uint256 a, uint256 b) public pure returns (bool err,uint256 i) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 80,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function plus(uint256 a, uint256 b) public pure returns (bool err, uint256 res) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 97,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function minus(uint256 a, uint256 b) public pure returns (bool err,uint256 res) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 857,
          "vulnerability_to_line": null,
          "vulnerability_code": "        internal view returns (bool,uint256,uint256)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 871,
          "vulnerability_to_line": null,
          "vulnerability_code": "        internal view returns (bool,uint256)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 1158,
          "vulnerability_to_line": null,
          "vulnerability_code": "                                  returns (uint256,uint256)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 1657,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function () public {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 174,
          "vulnerability_to_line": null,
          "vulnerability_code": "                string _name,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 175,
          "vulnerability_to_line": null,
          "vulnerability_code": "                string _symbol,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 406,
          "vulnerability_to_line": null,
          "vulnerability_code": "                          string name,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 407,
          "vulnerability_to_line": null,
          "vulnerability_code": "                          string symbol,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 415,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function name() public view returns (string) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 419,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function symbol() public view returns (string) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 569,
          "vulnerability_to_line": null,
          "vulnerability_code": "                uint256[] _saleData,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 1101,
          "vulnerability_to_line": null,
          "vulnerability_code": "                uint256[] _saleData,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 1107,
          "vulnerability_to_line": null,
          "vulnerability_code": "                string _tokenName,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 1108,
          "vulnerability_to_line": null,
          "vulnerability_code": "                string _tokenSymbol,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 1633,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint256[] saleData,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 1639,
          "vulnerability_to_line": null,
          "vulnerability_code": "    string tokenName,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 1640,
          "vulnerability_to_line": null,
          "vulnerability_code": "    string tokenSymbol,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 41,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly{\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 59,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly{\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 81,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly{\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 98,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly{\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 799,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint256 constant NULL = 0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 800,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint256 constant HEAD = 0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 801,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bool constant PREV = false;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 802,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bool constant NEXT = true;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 998,
          "vulnerability_to_line": null,
          "vulnerability_code": "  uint256 constant NULL = 0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 999,
          "vulnerability_to_line": null,
          "vulnerability_code": "  uint256 constant HEAD = 0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1000,
          "vulnerability_to_line": null,
          "vulnerability_code": "  bool constant PREV = false;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1001,
          "vulnerability_to_line": null,
          "vulnerability_code": "  bool constant NEXT = true;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1626,
          "vulnerability_to_line": null,
          "vulnerability_code": "  InteractiveCrowdsaleLib.InteractiveCrowdsaleStorage sale;\n",
          "message": null
        }
      ]
    },
    "oyente": {
      "successfull_analysis": true,
      "errors": [
        "DOCKER_SEGV"
      ],
      "vulnerability_findings": [
        {
          "name": "Integer Overflow",
          "vulnerability_from_line": 82,
          "vulnerability_to_line": null,
          "vulnerability_code": "      res := add(a,b)\n",
          "message": null
        },
        {
          "name": "Integer Underflow",
          "vulnerability_from_line": 83,
          "vulnerability_to_line": null,
          "vulnerability_code": "      switch and(eq(sub(res,b), a), or(gt(res,b),eq(res,b)))\n",
          "message": null
        }
      ]
    },
    "mythril": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "Integer Arithmetic Bugs (SWC 101)",
          "vulnerability_from_line": 82,
          "vulnerability_to_line": null,
          "vulnerability_code": "      res := add(a,b)\n",
          "message": "The arithmetic operator can overflow.\nIt is possible to cause an integer overflow or underflow in the arithmetic operation. \nClassification: SWC-101"
        },
        {
          "name": "Integer Arithmetic Bugs (SWC 101)",
          "vulnerability_from_line": 83,
          "vulnerability_to_line": null,
          "vulnerability_code": "      switch and(eq(sub(res,b), a), or(gt(res,b),eq(res,b)))\n",
          "message": "The arithmetic operator can underflow.\nIt is possible to cause an integer overflow or underflow in the arithmetic operation. \nClassification: SWC-101"
        },
        {
          "name": "Integer Arithmetic Bugs (SWC 101)",
          "vulnerability_from_line": 99,
          "vulnerability_to_line": null,
          "vulnerability_code": "      res := sub(a,b)\n",
          "message": "The arithmetic operator can underflow.\nIt is possible to cause an integer overflow or underflow in the arithmetic operation. \nClassification: SWC-101"
        },
        {
          "name": "Integer Arithmetic Bugs (SWC 101)",
          "vulnerability_from_line": 100,
          "vulnerability_to_line": null,
          "vulnerability_code": "      switch eq(and(eq(add(res,b), a), or(lt(res,a), eq(res,a))), 1)\n",
          "message": "The arithmetic operator can overflow.\nIt is possible to cause an integer overflow or underflow in the arithmetic operation. \nClassification: SWC-101"
        },
        {
          "name": "Dependence on predictable environment variable (SWC 116)",
          "vulnerability_from_line": 605,
          "vulnerability_to_line": null,
          "vulnerability_code": "  \treturn (now >= self.startTime && now <= self.endTime);\n",
          "message": "A control flow decision is made based on The block.timestamp environment variable.\nThe block.timestamp environment variable is used to determine a control flow decision. Note that the values of variables like coinbase, gaslimit, block number and timestamp are predictable and can be manipulated by a malicious miner. Also keep in mind that attackers know hashes of earlier blocks. Don't use any of those environment variables as sources of randomness and be aware that use of these variables introduces a certain level of trust into miners.\nClassification: SWC-116"
        },
        {
          "name": "Exception State (SWC 110)",
          "vulnerability_from_line": null,
          "vulnerability_to_line": null,
          "vulnerability_code": null,
          "message": "An assertion violation was triggered.\nIt is possible to trigger an assertion violation. Note that Solidity assert() statements should only be used to check invariants. Review the transaction trace generated for this issue and either make sure your program logic is correct, or use require() instead of assert() if your goal is to constrain user inputs or enforce preconditions. Remember to validate inputs from both callers (for instance, via passed arguments) and callees (for instance, via return values). This issue is reported for internal compiler generated code.\nClassification: SWC-110"
        }
      ]
    },
    "osiris": {
      "successfull_analysis": true,
      "errors": [
        "DOCKER_TIMEOUT"
      ],
      "vulnerability_findings": [
        {
          "name": "Division bugs",
          "vulnerability_from_line": 43,
          "vulnerability_to_line": null,
          "vulnerability_code": "      switch or(iszero(b), eq(div(res,b), a))\n",
          "message": null
        },
        {
          "name": "Overflow bugs",
          "vulnerability_from_line": 42,
          "vulnerability_to_line": null,
          "vulnerability_code": "      res := mul(a,b)\n",
          "message": null
        },
        {
          "name": "Concurrency bug",
          "vulnerability_from_line": 672,
          "vulnerability_to_line": null,
          "vulnerability_code": "    msg.sender.transfer(total);\n",
          "message": null
        },
        {
          "name": "Concurrency bug",
          "vulnerability_from_line": 691,
          "vulnerability_to_line": null,
          "vulnerability_code": "    self.owner.transfer(amount);\n",
          "message": null
        },
        {
          "name": "Overflow bugs",
          "vulnerability_from_line": 645,
          "vulnerability_to_line": null,
          "vulnerability_code": "          uint256 _burnAmount = (self.withdrawTokensMap[msg.sender] * self.percentBurn)/100;\n",
          "message": null
        },
        {
          "name": "Time dependency bug",
          "vulnerability_from_line": 681,
          "vulnerability_to_line": null,
          "vulnerability_code": "    if ((!crowdsaleEnded(self)) && (self.token.balanceOf(this)>0)) {\n",
          "message": null
        },
        {
          "name": "Time dependency bug",
          "vulnerability_from_line": 681,
          "vulnerability_to_line": null,
          "vulnerability_code": "    if ((!crowdsaleEnded(self)) && (self.token.balanceOf(this)>0)) {\n",
          "message": null
        },
        {
          "name": "Underflow bugs",
          "vulnerability_from_line": 646,
          "vulnerability_to_line": null,
          "vulnerability_code": "          self.withdrawTokensMap[msg.sender] = self.withdrawTokensMap[msg.sender] - _burnAmount;\n",
          "message": null
        },
        {
          "name": "Underflow bugs",
          "vulnerability_from_line": 759,
          "vulnerability_to_line": null,
          "vulnerability_code": "    return self.startingTokenBalance - self.withdrawTokensMap[self.owner];\n",
          "message": null
        }
      ]
    }
  }
}