{
  "smartbugs_completed": true,
  "analyzer_results": {
    "semgrep": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 149,
          "vulnerability_to_line": null,
          "vulnerability_code": "      for (uint256 i = 0; i<self.length; i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 153,
          "vulnerability_to_line": null,
          "vulnerability_code": "          i = self.length;\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 243,
          "vulnerability_to_line": null,
          "vulnerability_code": "    for (uint256 i = 0; i < self.length; i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 247,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 j = i; j < self.length - 1; j++){\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 251,
          "vulnerability_to_line": null,
          "vulnerability_code": "        delete self[self.length - 1];\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 252,
          "vulnerability_to_line": null,
          "vulnerability_code": "        self.length--;\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "non-optimal-variables-swap",
          "vulnerability_from_line": 198,
          "vulnerability_to_line": null,
          "vulnerability_code": "          temp = self[swap];\n",
          "message": "Consider swapping variables using `(self[swap], self[root]) = (self[root], self[swap])` to save gas"
        },
        {
          "name": "non-optimal-variables-swap",
          "vulnerability_from_line": 199,
          "vulnerability_to_line": null,
          "vulnerability_code": "          self[swap] = self[root];\n",
          "message": "Consider swapping variables using `(self[swap], self[root]) = (self[root], self[swap])` to save gas"
        },
        {
          "name": "non-optimal-variables-swap",
          "vulnerability_from_line": 200,
          "vulnerability_to_line": null,
          "vulnerability_code": "          self[root] = temp;\n",
          "message": "Consider swapping variables using `(self[swap], self[root]) = (self[root], self[swap])` to save gas"
        },
        {
          "name": "non-optimal-variables-swap",
          "vulnerability_from_line": 211,
          "vulnerability_to_line": null,
          "vulnerability_code": "      temp = self[end];\n",
          "message": "Consider swapping variables using `(self[end], self[0]) = (self[0], self[end])` to save gas"
        },
        {
          "name": "non-optimal-variables-swap",
          "vulnerability_from_line": 212,
          "vulnerability_to_line": null,
          "vulnerability_code": "      self[end] = self[0];\n",
          "message": "Consider swapping variables using `(self[end], self[0]) = (self[0], self[end])` to save gas"
        },
        {
          "name": "non-optimal-variables-swap",
          "vulnerability_from_line": 213,
          "vulnerability_to_line": null,
          "vulnerability_code": "      self[0] = temp;\n",
          "message": "Consider swapping variables using `(self[end], self[0]) = (self[0], self[end])` to save gas"
        },
        {
          "name": "non-optimal-variables-swap",
          "vulnerability_from_line": 227,
          "vulnerability_to_line": null,
          "vulnerability_code": "          temp = self[swap];\n",
          "message": "Consider swapping variables using `(self[swap], self[root]) = (self[root], self[swap])` to save gas"
        },
        {
          "name": "non-optimal-variables-swap",
          "vulnerability_from_line": 228,
          "vulnerability_to_line": null,
          "vulnerability_code": "          self[swap] = self[root];\n",
          "message": "Consider swapping variables using `(self[swap], self[root]) = (self[root], self[swap])` to save gas"
        },
        {
          "name": "non-optimal-variables-swap",
          "vulnerability_from_line": 229,
          "vulnerability_to_line": null,
          "vulnerability_code": "          self[root] = temp;\n",
          "message": "Consider swapping variables using `(self[swap], self[root]) = (self[root], self[swap])` to save gas"
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 149,
          "vulnerability_to_line": null,
          "vulnerability_code": "      for (uint256 i = 0; i<self.length; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 243,
          "vulnerability_to_line": null,
          "vulnerability_code": "    for (uint256 i = 0; i < self.length; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 247,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 j = i; j < self.length - 1; j++){\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 193,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if((rChild <= end) && (self[swap]<self[rChild]))\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 194,
          "vulnerability_to_line": null,
          "vulnerability_code": "          swap = rChild;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 222,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if((rChild <= end) && (self[swap]<self[rChild]))\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 223,
          "vulnerability_to_line": null,
          "vulnerability_code": "          swap = rChild;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-prefix-decrement-not-postfix",
          "vulnerability_from_line": 252,
          "vulnerability_to_line": null,
          "vulnerability_code": "        self.length--;\n",
          "message": "Consider using the prefix decrement expression whenever the return value is not needed. The prefix decrement expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-decrement-not-postfix",
          "vulnerability_from_line": 253,
          "vulnerability_to_line": null,
          "vulnerability_code": "        i--;\n",
          "message": "Consider using the prefix decrement expression whenever the return value is not needed. The prefix decrement expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 149,
          "vulnerability_to_line": null,
          "vulnerability_code": "      for (uint256 i = 0; i<self.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 243,
          "vulnerability_to_line": null,
          "vulnerability_code": "    for (uint256 i = 0; i < self.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 247,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 j = i; j < self.length - 1; j++){\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        }
      ]
    },
    "slither": {
      "successfull_analysis": true,
      "errors": [
        "EXIT_CODE_12"
      ],
      "vulnerability_findings": [
        {
          "name": "constant-function",
          "vulnerability_from_line": 37,
          "vulnerability_to_line": 58,
          "vulnerability_code": "  function sumElements(uint32[] storage self) public view returns(uint256 sum) {\n\n    uint256 term;\n\n    uint8 remainder;\n\n\n\n    assembly {\n\n      mstore(0x60,self_slot)\n\n\n\n      for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } {\n\n        term := sload(add(sha3(0x60,0x20),div(i,8)))\n\n\n\n        remainder := mod(i,8)\n\n\n\n        for { let j := 0 } lt(j, remainder) { j := add(j, 1) } {\n\n          term := div(term,4294967296)\n\n        }\n\n\n\n        term := and(0x00000000000000000000000000000000000000000000000000000000ffffffff,term)\n\n        sum := add(term,sum)\n\n\n\n      }\n\n    }\n",
          "message": "Array32Lib.sumElements (Array32Lib.sol#37-58) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 63,
          "vulnerability_to_line": 87,
          "vulnerability_code": "  function getMax(uint32[] storage self) public view returns(uint32 maxValue) {\n\n    uint256 term;\n\n    uint8 remainder;\n\n\n\n    assembly {\n\n      mstore(0x60,self_slot)\n\n      maxValue := 0\n\n\n\n      for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } {\n\n        term := sload(add(sha3(0x60,0x20),div(i,8)))\n\n\n\n        remainder := mod(i,8)\n\n\n\n        for { let j := 0 } lt(j, remainder) { j := add(j, 1) } {\n\n          term := div(term,4294967296)\n\n        }\n\n\n\n        term := and(0x00000000000000000000000000000000000000000000000000000000ffffffff,term)\n\n        switch lt(maxValue, term)\n\n        case 1 {\n\n          maxValue := term\n\n        }\n\n      }\n\n    }\n",
          "message": "Array32Lib.getMax (Array32Lib.sol#63-87) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 92,
          "vulnerability_to_line": 120,
          "vulnerability_code": "  function getMin(uint32[] storage self) public view returns(uint32 minValue) {\n\n    uint256 term;\n\n    uint8 remainder;\n\n\n\n    assembly {\n\n      mstore(0x60,self_slot)\n\n\n\n      for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } {\n\n        term := sload(add(sha3(0x60,0x20),div(i,8)))\n\n\n\n        remainder := mod(i,8)\n\n\n\n        for { let j := 0 } lt(j, remainder) { j := add(j, 1) } {\n\n          term := div(term,4294967296)\n\n        }\n\n\n\n        term := and(0x00000000000000000000000000000000000000000000000000000000ffffffff,term)\n\n\n\n        switch eq(i,0)\n\n        case 1 {\n\n          minValue := term\n\n        }\n\n        switch gt(minValue, term)\n\n        case 1 {\n\n          minValue := term\n\n        }\n\n      }\n\n    }\n",
          "message": "Array32Lib.getMin (Array32Lib.sol#92-120) is declared view but contains assembly code\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 37,
          "vulnerability_to_line": 58,
          "vulnerability_code": "  function sumElements(uint32[] storage self) public view returns(uint256 sum) {\n\n    uint256 term;\n\n    uint8 remainder;\n\n\n\n    assembly {\n\n      mstore(0x60,self_slot)\n\n\n\n      for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } {\n\n        term := sload(add(sha3(0x60,0x20),div(i,8)))\n\n\n\n        remainder := mod(i,8)\n\n\n\n        for { let j := 0 } lt(j, remainder) { j := add(j, 1) } {\n\n          term := div(term,4294967296)\n\n        }\n\n\n\n        term := and(0x00000000000000000000000000000000000000000000000000000000ffffffff,term)\n\n        sum := add(term,sum)\n\n\n\n      }\n\n    }\n",
          "message": "Array32Lib.sumElements uses assembly (Array32Lib.sol#37-58)\n\t- Array32Lib.sol#41-58\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 63,
          "vulnerability_to_line": 87,
          "vulnerability_code": "  function getMax(uint32[] storage self) public view returns(uint32 maxValue) {\n\n    uint256 term;\n\n    uint8 remainder;\n\n\n\n    assembly {\n\n      mstore(0x60,self_slot)\n\n      maxValue := 0\n\n\n\n      for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } {\n\n        term := sload(add(sha3(0x60,0x20),div(i,8)))\n\n\n\n        remainder := mod(i,8)\n\n\n\n        for { let j := 0 } lt(j, remainder) { j := add(j, 1) } {\n\n          term := div(term,4294967296)\n\n        }\n\n\n\n        term := and(0x00000000000000000000000000000000000000000000000000000000ffffffff,term)\n\n        switch lt(maxValue, term)\n\n        case 1 {\n\n          maxValue := term\n\n        }\n\n      }\n\n    }\n",
          "message": "Array32Lib.getMax uses assembly (Array32Lib.sol#63-87)\n\t- Array32Lib.sol#67-87\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 92,
          "vulnerability_to_line": 120,
          "vulnerability_code": "  function getMin(uint32[] storage self) public view returns(uint32 minValue) {\n\n    uint256 term;\n\n    uint8 remainder;\n\n\n\n    assembly {\n\n      mstore(0x60,self_slot)\n\n\n\n      for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } {\n\n        term := sload(add(sha3(0x60,0x20),div(i,8)))\n\n\n\n        remainder := mod(i,8)\n\n\n\n        for { let j := 0 } lt(j, remainder) { j := add(j, 1) } {\n\n          term := div(term,4294967296)\n\n        }\n\n\n\n        term := and(0x00000000000000000000000000000000000000000000000000000000ffffffff,term)\n\n\n\n        switch eq(i,0)\n\n        case 1 {\n\n          minValue := term\n\n        }\n\n        switch gt(minValue, term)\n\n        case 1 {\n\n          minValue := term\n\n        }\n\n      }\n\n    }\n",
          "message": "Array32Lib.getMin uses assembly (Array32Lib.sol#92-120)\n\t- Array32Lib.sol#96-120\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 37,
          "vulnerability_to_line": 58,
          "vulnerability_code": "  function sumElements(uint32[] storage self) public view returns(uint256 sum) {\n\n    uint256 term;\n\n    uint8 remainder;\n\n\n\n    assembly {\n\n      mstore(0x60,self_slot)\n\n\n\n      for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } {\n\n        term := sload(add(sha3(0x60,0x20),div(i,8)))\n\n\n\n        remainder := mod(i,8)\n\n\n\n        for { let j := 0 } lt(j, remainder) { j := add(j, 1) } {\n\n          term := div(term,4294967296)\n\n        }\n\n\n\n        term := and(0x00000000000000000000000000000000000000000000000000000000ffffffff,term)\n\n        sum := add(term,sum)\n\n\n\n      }\n\n    }\n",
          "message": "Array32Lib.sumElements (Array32Lib.sol#37-58) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 63,
          "vulnerability_to_line": 87,
          "vulnerability_code": "  function getMax(uint32[] storage self) public view returns(uint32 maxValue) {\n\n    uint256 term;\n\n    uint8 remainder;\n\n\n\n    assembly {\n\n      mstore(0x60,self_slot)\n\n      maxValue := 0\n\n\n\n      for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } {\n\n        term := sload(add(sha3(0x60,0x20),div(i,8)))\n\n\n\n        remainder := mod(i,8)\n\n\n\n        for { let j := 0 } lt(j, remainder) { j := add(j, 1) } {\n\n          term := div(term,4294967296)\n\n        }\n\n\n\n        term := and(0x00000000000000000000000000000000000000000000000000000000ffffffff,term)\n\n        switch lt(maxValue, term)\n\n        case 1 {\n\n          maxValue := term\n\n        }\n\n      }\n\n    }\n",
          "message": "Array32Lib.getMax (Array32Lib.sol#63-87) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 92,
          "vulnerability_to_line": 120,
          "vulnerability_code": "  function getMin(uint32[] storage self) public view returns(uint32 minValue) {\n\n    uint256 term;\n\n    uint8 remainder;\n\n\n\n    assembly {\n\n      mstore(0x60,self_slot)\n\n\n\n      for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } {\n\n        term := sload(add(sha3(0x60,0x20),div(i,8)))\n\n\n\n        remainder := mod(i,8)\n\n\n\n        for { let j := 0 } lt(j, remainder) { j := add(j, 1) } {\n\n          term := div(term,4294967296)\n\n        }\n\n\n\n        term := and(0x00000000000000000000000000000000000000000000000000000000ffffffff,term)\n\n\n\n        switch eq(i,0)\n\n        case 1 {\n\n          minValue := term\n\n        }\n\n        switch gt(minValue, term)\n\n        case 1 {\n\n          minValue := term\n\n        }\n\n      }\n\n    }\n",
          "message": "Array32Lib.getMin (Array32Lib.sol#92-120) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 177,
          "vulnerability_to_line": 235,
          "vulnerability_code": "  function heapSort(uint32[] storage self) public {\n\n    uint256 end = self.length - 1;\n\n    uint256 start = getParentI(end);\n\n    uint256 root = start;\n\n    uint256 lChild;\n\n    uint256 rChild;\n\n    uint256 swap;\n\n    uint32 temp;\n\n    while(start >= 0){\n\n      root = start;\n\n      lChild = getLeftChildI(start);\n\n      while(lChild <= end){\n\n        rChild = lChild + 1;\n\n        swap = root;\n\n        if(self[swap] < self[lChild])\n\n          swap = lChild;\n\n        if((rChild <= end) && (self[swap]<self[rChild]))\n\n          swap = rChild;\n\n        if(swap == root)\n\n          lChild = end+1;\n\n        else {\n\n          temp = self[swap];\n\n          self[swap] = self[root];\n\n          self[root] = temp;\n\n          root = swap;\n\n          lChild = getLeftChildI(root);\n\n        }\n\n      }\n\n      if(start == 0)\n\n        break;\n\n      else\n\n        start = start - 1;\n\n    }\n\n    while(end > 0){\n\n      temp = self[end];\n\n      self[end] = self[0];\n\n      self[0] = temp;\n\n      end = end - 1;\n\n      root = 0;\n\n      lChild = getLeftChildI(0);\n\n      while(lChild <= end){\n\n        rChild = lChild + 1;\n\n        swap = root;\n\n        if(self[swap] < self[lChild])\n\n          swap = lChild;\n\n        if((rChild <= end) && (self[swap]<self[rChild]))\n\n          swap = rChild;\n\n        if(swap == root)\n\n          lChild = end + 1;\n\n        else {\n\n          temp = self[swap];\n\n          self[swap] = self[root];\n\n          self[root] = temp;\n\n          root = swap;\n\n          lChild = getLeftChildI(root);\n\n        }\n\n      }\n\n    }\n",
          "message": "Array32Lib.heapSort (Array32Lib.sol#177-235) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 239,
          "vulnerability_to_line": 258,
          "vulnerability_code": "  function uniq(uint32[] storage self) public returns (uint256 length) {\n\n    bool contains;\n\n    uint256 index;\n\n\n\n    for (uint256 i = 0; i < self.length; i++) {\n\n      (contains, index) = indexOf(self, self[i], false);\n\n\n\n      if (i > index) {\n\n        for (uint256 j = i; j < self.length - 1; j++){\n\n          self[j] = self[j + 1];\n\n        }\n\n\n\n        delete self[self.length - 1];\n\n        self.length--;\n\n        i--;\n\n      }\n\n    }\n\n\n\n    length = self.length;\n",
          "message": "Array32Lib.uniq (Array32Lib.sol#239-258) should be declared external\n"
        },
        {
          "name": "solc-version",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.18;\n",
          "message": "Detected issues with version pragma in Array32Lib.sol:\n\t- pragma solidity^0.4.18 (Array32Lib.sol#3): it allows old versions\n"
        }
      ]
    },
    "smartcheck": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "SOLIDITY_ARRAY_LENGTH_MANIPULATION",
          "vulnerability_from_line": 252,
          "vulnerability_to_line": null,
          "vulnerability_code": "        self.length--;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
          "vulnerability_from_line": 45,
          "vulnerability_to_line": null,
          "vulnerability_code": "        term := sload(add(sha3(0x60,0x20),div(i,8)))\n",
          "message": null
        },
        {
          "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
          "vulnerability_from_line": 72,
          "vulnerability_to_line": null,
          "vulnerability_code": "        term := sload(add(sha3(0x60,0x20),div(i,8)))\n",
          "message": null
        },
        {
          "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
          "vulnerability_from_line": 100,
          "vulnerability_to_line": null,
          "vulnerability_code": "        term := sload(add(sha3(0x60,0x20),div(i,8)))\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 149,
          "vulnerability_to_line": null,
          "vulnerability_code": "      for (uint256 i = 0; i<self.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 243,
          "vulnerability_to_line": null,
          "vulnerability_code": "    for (uint256 i = 0; i < self.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 247,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 j = i; j < self.length - 1; j++){\n",
          "message": null
        },
        {
          "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
          "vulnerability_from_line": 37,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function sumElements(uint32[] storage self) public view returns(uint256 sum) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
          "vulnerability_from_line": 63,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function getMax(uint32[] storage self) public view returns(uint32 maxValue) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
          "vulnerability_from_line": 92,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function getMin(uint32[] storage self) public view returns(uint32 minValue) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 149,
          "vulnerability_to_line": null,
          "vulnerability_code": "      for (uint256 i = 0; i<self.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 243,
          "vulnerability_to_line": null,
          "vulnerability_code": "    for (uint256 i = 0; i < self.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 136,
          "vulnerability_to_line": null,
          "vulnerability_code": "        while (low <= high) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 188,
          "vulnerability_to_line": null,
          "vulnerability_code": "      while(lChild <= end){\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 217,
          "vulnerability_to_line": null,
          "vulnerability_code": "      while(lChild <= end){\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.18;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
          "vulnerability_from_line": 37,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function sumElements(uint32[] storage self) public view returns(uint256 sum) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
          "vulnerability_from_line": 63,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function getMax(uint32[] storage self) public view returns(uint32 maxValue) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
          "vulnerability_from_line": 92,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function getMin(uint32[] storage self) public view returns(uint32 minValue) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UINT_CANT_BE_NEGATIVE",
          "vulnerability_from_line": 185,
          "vulnerability_to_line": null,
          "vulnerability_code": "    while(start >= 0){\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UINT_CANT_BE_NEGATIVE",
          "vulnerability_from_line": 185,
          "vulnerability_to_line": null,
          "vulnerability_code": "    while(start >= 0){\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 41,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 67,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 96,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly {\n",
          "message": null
        }
      ]
    },
    "oyente": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "Integer Overflow",
          "vulnerability_from_line": 150,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (self[i] == value) {\n",
          "message": null
        },
        {
          "name": "Integer Underflow",
          "vulnerability_from_line": 178,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint256 end = self.length - 1;\n",
          "message": null
        }
      ]
    },
    "mythril": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "Exception State (SWC 110)",
          "vulnerability_from_line": 128,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function indexOf(uint32[] storage self, uint32 value, bool isSorted)\n",
          "message": "An assertion violation was triggered.\nIt is possible to trigger an assertion violation. Note that Solidity assert() statements should only be used to check invariants. Review the transaction trace generated for this issue and either make sure your program logic is correct, or use require() instead of assert() if your goal is to constrain user inputs or enforce preconditions. Remember to validate inputs from both callers (for instance, via passed arguments) and callees (for instance, via return values).\nClassification: SWC-110"
        }
      ]
    },
    "osiris": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "Division bugs",
          "vulnerability_from_line": 138,
          "vulnerability_to_line": null,
          "vulnerability_code": "          if (self[mid] == value) {\n",
          "message": null
        },
        {
          "name": "Division bugs",
          "vulnerability_from_line": 191,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if(self[swap] < self[lChild])\n",
          "message": null
        },
        {
          "name": "Division bugs",
          "vulnerability_from_line": 191,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if(self[swap] < self[lChild])\n",
          "message": null
        },
        {
          "name": "Overflow bugs",
          "vulnerability_from_line": 54,
          "vulnerability_to_line": null,
          "vulnerability_code": "        sum := add(term,sum)\n",
          "message": null
        },
        {
          "name": "Truncation bugs",
          "vulnerability_from_line": 53,
          "vulnerability_to_line": null,
          "vulnerability_code": "        term := and(0x00000000000000000000000000000000000000000000000000000000ffffffff,term)\n",
          "message": null
        },
        {
          "name": "Truncation bugs",
          "vulnerability_from_line": 80,
          "vulnerability_to_line": null,
          "vulnerability_code": "        term := and(0x00000000000000000000000000000000000000000000000000000000ffffffff,term)\n",
          "message": null
        },
        {
          "name": "Truncation bugs",
          "vulnerability_from_line": 108,
          "vulnerability_to_line": null,
          "vulnerability_code": "        term := and(0x00000000000000000000000000000000000000000000000000000000ffffffff,term)\n",
          "message": null
        },
        {
          "name": "Truncation bugs",
          "vulnerability_from_line": 138,
          "vulnerability_to_line": null,
          "vulnerability_code": "          if (self[mid] == value) {\n",
          "message": null
        },
        {
          "name": "Truncation bugs",
          "vulnerability_from_line": 150,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (self[i] == value) {\n",
          "message": null
        },
        {
          "name": "Truncation bugs",
          "vulnerability_from_line": 191,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if(self[swap] < self[lChild])\n",
          "message": null
        },
        {
          "name": "Truncation bugs",
          "vulnerability_from_line": 191,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if(self[swap] < self[lChild])\n",
          "message": null
        },
        {
          "name": "Truncation bugs",
          "vulnerability_from_line": 244,
          "vulnerability_to_line": null,
          "vulnerability_code": "      (contains, index) = indexOf(self, self[i], false);\n",
          "message": null
        },
        {
          "name": "Truncation bugs",
          "vulnerability_from_line": 251,
          "vulnerability_to_line": null,
          "vulnerability_code": "        delete self[self.length - 1];\n",
          "message": null
        }
      ]
    }
  }
}