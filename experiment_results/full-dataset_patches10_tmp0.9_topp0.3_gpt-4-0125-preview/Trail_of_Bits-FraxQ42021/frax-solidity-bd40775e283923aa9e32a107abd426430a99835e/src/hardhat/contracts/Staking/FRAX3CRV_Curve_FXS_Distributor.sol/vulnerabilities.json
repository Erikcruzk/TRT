{
  "smartbugs_completed": true,
  "analyzer_results": {
    "semgrep": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "use-abi-encodecall-instead-of-encodewithselector",
          "vulnerability_from_line": 304,
          "vulnerability_to_line": null,
          "vulnerability_code": "        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n",
          "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
        },
        {
          "name": "use-abi-encodecall-instead-of-encodewithselector",
          "vulnerability_from_line": 308,
          "vulnerability_to_line": null,
          "vulnerability_code": "        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n",
          "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
        },
        {
          "name": "use-abi-encodecall-instead-of-encodewithselector",
          "vulnerability_from_line": 319,
          "vulnerability_to_line": null,
          "vulnerability_code": "        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n",
          "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
        },
        {
          "name": "use-abi-encodecall-instead-of-encodewithselector",
          "vulnerability_from_line": 324,
          "vulnerability_to_line": null,
          "vulnerability_code": "        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n",
          "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
        },
        {
          "name": "use-abi-encodecall-instead-of-encodewithselector",
          "vulnerability_from_line": 329,
          "vulnerability_to_line": null,
          "vulnerability_code": "        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n",
          "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
        },
        {
          "name": "inefficient-state-variable-increment",
          "vulnerability_from_line": 277,
          "vulnerability_to_line": null,
          "vulnerability_code": "        _guardCounter += 1;\n",
          "message": "<x> += <y> costs more gas than <x> = <x> + <y> for state variables."
        },
        {
          "name": "init-variables-with-default-value",
          "vulnerability_from_line": 461,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint256 public periodFinish = 0;\n",
          "message": "Uninitialized variables are assigned with the types default value. Explicitly initializing a variable with its default value costs unnecessary gas."
        },
        {
          "name": "init-variables-with-default-value",
          "vulnerability_from_line": 462,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint256 public rewardRate = 0;\n",
          "message": "Uninitialized variables are assigned with the types default value. Explicitly initializing a variable with its default value costs unnecessary gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 188,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor (address _owner) public {\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 189,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_owner != address(0), \"Owner address cannot be 0\");\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 190,
          "vulnerability_to_line": null,
          "vulnerability_code": "        owner = _owner;\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 191,
          "vulnerability_to_line": null,
          "vulnerability_code": "        emit OwnerChanged(address(0), _owner);\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 192,
          "vulnerability_to_line": null,
          "vulnerability_code": "    }\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 223,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor () internal {\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 224,
          "vulnerability_to_line": null,
          "vulnerability_code": "        // This contract is abstract, and thus cannot be instantiated directly\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 225,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(owner != address(0), \"Owner must be set\");\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 226,
          "vulnerability_to_line": null,
          "vulnerability_code": "        // Paused will be false, and lastPauseTime will be 0 upon initialisation\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 227,
          "vulnerability_to_line": null,
          "vulnerability_code": "    }\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 263,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor () internal {\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 264,
          "vulnerability_to_line": null,
          "vulnerability_code": "        // The counter starts at one to prevent changing it from zero to a non-zero\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 265,
          "vulnerability_to_line": null,
          "vulnerability_code": "        // value, which is a more expensive operation.\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 266,
          "vulnerability_to_line": null,
          "vulnerability_code": "        _guardCounter = 1;\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 267,
          "vulnerability_to_line": null,
          "vulnerability_code": "    }\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 475,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor (\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 476,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address _owner,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 477,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address _rewardsDistribution,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 478,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address _rewardsToken,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 479,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address _stakingToken,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 480,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint256 _rewardsDuration\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 481,
          "vulnerability_to_line": null,
          "vulnerability_code": "    ) public Owned(_owner) {\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 482,
          "vulnerability_to_line": null,
          "vulnerability_code": "        rewardsToken = IERC20(_rewardsToken);\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 483,
          "vulnerability_to_line": null,
          "vulnerability_code": "        stakingToken = IERC20(_stakingToken);\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 484,
          "vulnerability_to_line": null,
          "vulnerability_code": "        rewardsDistribution = _rewardsDistribution;\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 189,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_owner != address(0), \"Owner address cannot be 0\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 200,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == nominatedOwner, \"You must be nominated before you can accept ownership\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 212,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == owner, \"Only the contract owner may perform this action\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 225,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(owner != address(0), \"Owner must be set\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 254,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(!paused, \"This action cannot be performed while the contract is paused\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 280,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(localCounter == _guardCounter, \"ReentrancyGuard: reentrant call\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 290,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == rewardsDistribution, \"Caller is not RewardsDistribution contract\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 316,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require((value == 0) || (token.allowance(address(this), spender) == 0),\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 317,
          "vulnerability_to_line": null,
          "vulnerability_code": "            \"SafeERC20: approve from non-zero to non-zero allowance\"\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 318,
          "vulnerability_to_line": null,
          "vulnerability_code": "        );\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 347,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 351,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(success, \"SafeERC20: low-level call failed\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 355,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 372,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(c >= a, \"SafeMath: addition overflow\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 387,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(b <= a, \"SafeMath: subtraction overflow\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 411,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(c / a == b, \"SafeMath: multiplication overflow\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 429,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(b > 0, \"SafeMath: division by zero\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 448,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(b != 0, \"SafeMath: modulo by zero\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 523,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(amount > 0, \"Cannot stake 0\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 531,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(amount > 0, \"Cannot withdraw 0\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 574,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(tokenAddress != address(stakingToken), \"Cannot withdraw the staking token\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 580,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 581,
          "vulnerability_to_line": null,
          "vulnerability_code": "            block.timestamp > periodFinish,\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 582,
          "vulnerability_to_line": null,
          "vulnerability_code": "            \"Reward period incomplete\"\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 583,
          "vulnerability_to_line": null,
          "vulnerability_code": "        );\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 200,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == nominatedOwner, \"You must be nominated before you can accept ownership\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 212,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == owner, \"Only the contract owner may perform this action\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 254,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(!paused, \"This action cannot be performed while the contract is paused\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 290,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == rewardsDistribution, \"Caller is not RewardsDistribution contract\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 316,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require((value == 0) || (token.allowance(address(this), spender) == 0),\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 317,
          "vulnerability_to_line": null,
          "vulnerability_code": "            \"SafeERC20: approve from non-zero to non-zero allowance\"\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 318,
          "vulnerability_to_line": null,
          "vulnerability_code": "        );\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 355,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 411,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(c / a == b, \"SafeMath: multiplication overflow\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 574,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(tokenAddress != address(stakingToken), \"Cannot withdraw the staking token\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        }
      ]
    },
    "slither": {
      "successfull_analysis": true,
      "errors": [
        "EXIT_CODE_19"
      ],
      "vulnerability_findings": [
        {
          "name": "constant-function",
          "vulnerability_from_line": 54,
          "vulnerability_to_line": 63,
          "vulnerability_code": "    function isContract(address account) internal view returns (bool) {\n\n        // This method relies in extcodesize, which returns 0 for contracts in\n\n        // construction, since the code is only stored at the end of the\n\n        // constructor execution.\n\n\n\n        uint256 size;\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly { size := extcodesize(account) }\n\n        return size > 0;\n",
          "message": "Address.isContract (FRAX3CRV_Curve_FXS_Distributor.sol#54-63) is declared view but contains assembly code\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 547,
          "vulnerability_to_line": 550,
          "vulnerability_code": "    function exit() external {\n\n        withdraw(_balances[msg.sender]);\n\n        getReward();\n",
          "message": "Reentrancy in FRAX3CRV_Curve_FXS_Distributor.exit (FRAX3CRV_Curve_FXS_Distributor.sol#547-550):\n\tExternal calls:\n\t- withdraw(_balances[msg.sender]) (FRAX3CRV_Curve_FXS_Distributor.sol#548)\n\t- getReward() (FRAX3CRV_Curve_FXS_Distributor.sol#549)\n\tState variables written after the call(s):\n\t- _guardCounter (FRAX3CRV_Curve_FXS_Distributor.sol#549)\n\t- lastUpdateTime (FRAX3CRV_Curve_FXS_Distributor.sol#549)\n\t- rewardPerTokenStored (FRAX3CRV_Curve_FXS_Distributor.sol#549)\n\t- rewards (FRAX3CRV_Curve_FXS_Distributor.sol#549)\n\t- userRewardPerTokenPaid (FRAX3CRV_Curve_FXS_Distributor.sol#549)\n"
        },
        {
          "name": "timestamp",
          "vulnerability_from_line": 554,
          "vulnerability_to_line": 570,
          "vulnerability_code": "    function notifyRewardAmount(uint256 reward) external onlyRewardsDistribution updateReward(address(0)) {\n\n        // handle the transfer of reward tokens via `transferFrom` to reduce the number\n\n        // of transactions required and ensure correctness of the reward amount\n\n        rewardsToken.safeTransferFrom(msg.sender, address(this), reward);\n\n\n\n        if (block.timestamp >= periodFinish) {\n\n            rewardRate = reward.div(rewardsDuration);\n\n        } else {\n\n            uint256 remaining = periodFinish.sub(block.timestamp);\n\n            uint256 leftover = remaining.mul(rewardRate);\n\n            rewardRate = reward.add(leftover).div(rewardsDuration);\n\n        }\n\n\n\n        lastUpdateTime = block.timestamp;\n\n        periodFinish = block.timestamp.add(rewardsDuration);\n\n        emit RewardAdded(reward);\n",
          "message": "FRAX3CRV_Curve_FXS_Distributor.notifyRewardAmount (FRAX3CRV_Curve_FXS_Distributor.sol#554-570) uses timestamp for comparisons\n\tDangerous comparisons:\n\t- block.timestamp >= periodFinish (FRAX3CRV_Curve_FXS_Distributor.sol#559-565)\n"
        },
        {
          "name": "timestamp",
          "vulnerability_from_line": 579,
          "vulnerability_to_line": 586,
          "vulnerability_code": "    function setRewardsDuration(uint256 _rewardsDuration) external onlyOwner {\n\n        require(\n\n            block.timestamp > periodFinish,\n\n            \"Reward period incomplete\"\n\n        );\n\n        rewardsDuration = _rewardsDuration;\n\n        emit RewardsDurationUpdated(rewardsDuration);\n",
          "message": "FRAX3CRV_Curve_FXS_Distributor.setRewardsDuration (FRAX3CRV_Curve_FXS_Distributor.sol#579-586) uses timestamp for comparisons\n\tDangerous comparisons:\n\t- require(bool,string)(block.timestamp > periodFinish,Reward period incomplete) (FRAX3CRV_Curve_FXS_Distributor.sol#580-583)\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 54,
          "vulnerability_to_line": 63,
          "vulnerability_code": "    function isContract(address account) internal view returns (bool) {\n\n        // This method relies in extcodesize, which returns 0 for contracts in\n\n        // construction, since the code is only stored at the end of the\n\n        // constructor execution.\n\n\n\n        uint256 size;\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly { size := extcodesize(account) }\n\n        return size > 0;\n",
          "message": "Address.isContract uses assembly (FRAX3CRV_Curve_FXS_Distributor.sol#54-63)\n\t- FRAX3CRV_Curve_FXS_Distributor.sol#61\n"
        },
        {
          "name": "pragma",
          "vulnerability_from_line": 4,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity 0.5.17;\n",
          "message": "Different versions of Solidity is used in FRAX3CRV_Curve_FXS_Distributor.sol:\n\t- Version used: ['0.5.17', 'ABIEncoderV2']\n\t- FRAX3CRV_Curve_FXS_Distributor.sol#4 declares pragma solidity0.5.17\n\t- FRAX3CRV_Curve_FXS_Distributor.sol#5 declares pragma experimentalABIEncoderV2\n"
        },
        {
          "name": "solc-version",
          "vulnerability_from_line": 4,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity 0.5.17;\n",
          "message": "Detected issues with version pragma in FRAX3CRV_Curve_FXS_Distributor.sol:\n\t- pragma solidity0.5.17 (FRAX3CRV_Curve_FXS_Distributor.sol#4): it allows old versions\n"
        },
        {
          "name": "low-level-calls",
          "vulnerability_from_line": 338,
          "vulnerability_to_line": 357,
          "vulnerability_code": "    function callOptionalReturn(IERC20 token, bytes memory data) private {\n\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n\n        // we're implementing it ourselves.\n\n\n\n        // A Solidity high level call has three parts:\n\n        //  1. The target address is checked to verify it contains contract code\n\n        //  2. The call itself is made, and success asserted\n\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\n\n        // solhint-disable-next-line max-line-length\n\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\n\n\n\n        // solhint-disable-next-line avoid-low-level-calls\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n\n        require(success, \"SafeERC20: low-level call failed\");\n\n\n\n        if (returndata.length > 0) { // Return data is optional\n\n            // solhint-disable-next-line max-line-length\n\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n\n        }\n",
          "message": "Low level call in SafeERC20.callOptionalReturn (FRAX3CRV_Curve_FXS_Distributor.sol#338-357):\n\t-(success,returndata) = address(token).call(data) FRAX3CRV_Curve_FXS_Distributor.sol#350\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 188,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor (address _owner) public {\n",
          "message": "Parameter '_owner' of Owned. (FRAX3CRV_Curve_FXS_Distributor.sol#188) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 194,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function nominateNewOwner(address _owner) external onlyOwner {\n",
          "message": "Parameter '_owner' of Owned.nominateNewOwner (FRAX3CRV_Curve_FXS_Distributor.sol#194) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 211,
          "vulnerability_to_line": 213,
          "vulnerability_code": "    function _onlyOwner() private view {\n\n        require(msg.sender == owner, \"Only the contract owner may perform this action\");\n",
          "message": "Function 'Owned._onlyOwner' (FRAX3CRV_Curve_FXS_Distributor.sol#211-213) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 233,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setPaused(bool _paused) external onlyOwner {\n",
          "message": "Parameter '_paused' of Pausable.setPaused (FRAX3CRV_Curve_FXS_Distributor.sol#233) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 294,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setRewardsDistribution(address _rewardsDistribution) external onlyOwner {\n",
          "message": "Parameter '_rewardsDistribution' of RewardsDistributionRecipient.setRewardsDistribution (FRAX3CRV_Curve_FXS_Distributor.sol#294) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 453,
          "vulnerability_to_line": 608,
          "vulnerability_code": "contract FRAX3CRV_Curve_FXS_Distributor is IStakingRewards, RewardsDistributionRecipient, ReentrancyGuard, Pausable {\n\n    using SafeMath for uint256;\n\n    using SafeERC20 for IERC20;\n\n\n\n    /* ========== STATE VARIABLES ========== */\n\n\n\n    IERC20 public rewardsToken;\n\n    IERC20 public stakingToken;\n\n    uint256 public periodFinish = 0;\n\n    uint256 public rewardRate = 0;\n\n    uint256 public rewardsDuration;\n\n    uint256 public lastUpdateTime;\n\n    uint256 public rewardPerTokenStored;\n\n\n\n    mapping(address => uint256) public userRewardPerTokenPaid;\n\n    mapping(address => uint256) public rewards;\n\n\n\n    uint256 private _totalSupply;\n\n    mapping(address => uint256) private _balances;\n\n\n\n    /* ========== CONSTRUCTOR ========== */\n\n\n\n    constructor (\n\n        address _owner,\n\n        address _rewardsDistribution,\n\n        address _rewardsToken,\n\n        address _stakingToken,\n\n        uint256 _rewardsDuration\n\n    ) public Owned(_owner) {\n\n        rewardsToken = IERC20(_rewardsToken);\n\n        stakingToken = IERC20(_stakingToken);\n\n        rewardsDistribution = _rewardsDistribution;\n\n        rewardsDuration = _rewardsDuration;\n\n    }\n\n\n\n    /* ========== VIEWS ========== */\n\n\n\n    function totalSupply() external view returns (uint256) {\n\n        return _totalSupply;\n\n    }\n\n\n\n    function balanceOf(address account) external view returns (uint256) {\n\n        return _balances[account];\n\n    }\n\n\n\n    function lastTimeRewardApplicable() internal view returns (uint256) {\n\n        return Math.min(block.timestamp, periodFinish);\n\n    }\n\n\n\n    function rewardPerToken() internal view returns (uint256) {\n\n        if (_totalSupply == 0) {\n\n            return rewardPerTokenStored;\n\n        }\n\n        return\n\n            rewardPerTokenStored.add(\n\n                lastTimeRewardApplicable().sub(lastUpdateTime).mul(rewardRate).mul(1e18).div(_totalSupply)\n\n            );\n\n    }\n\n\n\n    function earned(address account) public view returns (uint256) {\n\n        return _balances[account].mul(rewardPerToken().sub(userRewardPerTokenPaid[account])).div(1e18).add(rewards[account]);\n\n    }\n\n\n\n    function getRewardForDuration() external view returns (uint256) {\n\n        return rewardRate.mul(rewardsDuration);\n\n    }\n\n\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n\n\n    function stake(uint256 amount) external nonReentrant notPaused updateReward(msg.sender) {\n\n        require(amount > 0, \"Cannot stake 0\");\n\n        _totalSupply = _totalSupply.add(amount);\n\n        _balances[msg.sender] = _balances[msg.sender].add(amount);\n\n        stakingToken.safeTransferFrom(msg.sender, address(this), amount);\n\n        emit Staked(msg.sender, amount);\n\n    }\n\n\n\n    function withdraw(uint256 amount) public nonReentrant updateReward(msg.sender) {\n\n        require(amount > 0, \"Cannot withdraw 0\");\n\n        _totalSupply = _totalSupply.sub(amount);\n\n        _balances[msg.sender] = _balances[msg.sender].sub(amount);\n\n        stakingToken.safeTransfer(msg.sender, amount);\n\n        emit Withdrawn(msg.sender, amount);\n\n    }\n\n\n\n    function getReward() public nonReentrant updateReward(msg.sender) {\n\n        uint256 reward = rewards[msg.sender];\n\n        if (reward > 0) {\n\n            rewards[msg.sender] = 0;\n\n            rewardsToken.safeTransfer(msg.sender, reward);\n\n            emit RewardPaid(msg.sender, reward);\n\n        }\n\n    }\n\n\n\n    function exit() external {\n\n        withdraw(_balances[msg.sender]);\n\n        getReward();\n\n    }\n\n\n\n    /* ========== RESTRICTED FUNCTIONS ========== */\n\n\n\n    function notifyRewardAmount(uint256 reward) external onlyRewardsDistribution updateReward(address(0)) {\n\n        // handle the transfer of reward tokens via `transferFrom` to reduce the number\n\n        // of transactions required and ensure correctness of the reward amount\n\n        rewardsToken.safeTransferFrom(msg.sender, address(this), reward);\n\n\n\n        if (block.timestamp >= periodFinish) {\n\n            rewardRate = reward.div(rewardsDuration);\n\n        } else {\n\n            uint256 remaining = periodFinish.sub(block.timestamp);\n\n            uint256 leftover = remaining.mul(rewardRate);\n\n            rewardRate = reward.add(leftover).div(rewardsDuration);\n\n        }\n\n\n\n        lastUpdateTime = block.timestamp;\n\n        periodFinish = block.timestamp.add(rewardsDuration);\n\n        emit RewardAdded(reward);\n\n    }\n\n\n\n    // Added to support recovering LP Rewards from other systems such as BAL to be distributed to holders\n\n    function recoverERC20(address tokenAddress, uint256 tokenAmount) external onlyOwner {\n\n        require(tokenAddress != address(stakingToken), \"Cannot withdraw the staking token\");\n\n        IERC20(tokenAddress).safeTransfer(owner, tokenAmount);\n\n        emit Recovered(tokenAddress, tokenAmount);\n\n    }\n\n\n\n    function setRewardsDuration(uint256 _rewardsDuration) external onlyOwner {\n\n        require(\n\n            block.timestamp > periodFinish,\n\n            \"Reward period incomplete\"\n\n        );\n\n        rewardsDuration = _rewardsDuration;\n\n        emit RewardsDurationUpdated(rewardsDuration);\n\n    }\n\n\n\n    /* ========== MODIFIERS ========== */\n\n\n\n    modifier updateReward(address account) {\n\n        rewardPerTokenStored = rewardPerToken();\n\n        lastUpdateTime = lastTimeRewardApplicable();\n\n        if (account != address(0)) {\n\n            rewards[account] = earned(account);\n\n            userRewardPerTokenPaid[account] = rewardPerTokenStored;\n\n        }\n\n        _;\n\n    }\n\n\n\n    /* ========== EVENTS ========== */\n\n\n\n    event RewardAdded(uint256 reward);\n\n    event Staked(address indexed user, uint256 amount);\n\n    event Withdrawn(address indexed user, uint256 amount);\n\n    event RewardPaid(address indexed user, uint256 reward);\n\n    event RewardsDurationUpdated(uint256 newDuration);\n\n    event Recovered(address token, uint256 amount);\n",
          "message": "Contract 'FRAX3CRV_Curve_FXS_Distributor' (FRAX3CRV_Curve_FXS_Distributor.sol#453-608) is not in CapWords\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 477,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address _rewardsDistribution,\n",
          "message": "Parameter '_rewardsDistribution' of FRAX3CRV_Curve_FXS_Distributor. (FRAX3CRV_Curve_FXS_Distributor.sol#477) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 478,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address _rewardsToken,\n",
          "message": "Parameter '_rewardsToken' of FRAX3CRV_Curve_FXS_Distributor. (FRAX3CRV_Curve_FXS_Distributor.sol#478) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 479,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address _stakingToken,\n",
          "message": "Parameter '_stakingToken' of FRAX3CRV_Curve_FXS_Distributor. (FRAX3CRV_Curve_FXS_Distributor.sol#479) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 480,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint256 _rewardsDuration\n",
          "message": "Parameter '_rewardsDuration' of FRAX3CRV_Curve_FXS_Distributor. (FRAX3CRV_Curve_FXS_Distributor.sol#480) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 579,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setRewardsDuration(uint256 _rewardsDuration) external onlyOwner {\n",
          "message": "Parameter '_rewardsDuration' of FRAX3CRV_Curve_FXS_Distributor.setRewardsDuration (FRAX3CRV_Curve_FXS_Distributor.sol#579) is not in mixedCase\n"
        }
      ]
    },
    "smartcheck": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 203,
          "vulnerability_to_line": null,
          "vulnerability_code": "        nominatedOwner = address(0);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 554,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function notifyRewardAmount(uint256 reward) external onlyRewardsDistribution updateReward(address(0)) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_OVERPOWERED_ROLE",
          "vulnerability_from_line": 233,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setPaused(bool _paused) external onlyOwner {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_OVERPOWERED_ROLE",
          "vulnerability_from_line": 294,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setRewardsDistribution(address _rewardsDistribution) external onlyOwner {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_OVERPOWERED_ROLE",
          "vulnerability_from_line": 579,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setRewardsDuration(uint256 _rewardsDuration) external onlyOwner {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 261,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint256 private _guardCounter;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 470,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint256 private _totalSupply;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 471,
          "vulnerability_to_line": null,
          "vulnerability_code": "    mapping(address => uint256) private _balances;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SAFEMATH",
          "vulnerability_from_line": 300,
          "vulnerability_to_line": null,
          "vulnerability_code": "    using SafeMath for uint256;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SAFEMATH",
          "vulnerability_from_line": 454,
          "vulnerability_to_line": null,
          "vulnerability_code": "    using SafeMath for uint256;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
          "vulnerability_from_line": 54,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function isContract(address account) internal view returns (bool) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UNCHECKED_CALL",
          "vulnerability_from_line": 304,
          "vulnerability_to_line": null,
          "vulnerability_code": "        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UNCHECKED_CALL",
          "vulnerability_from_line": 308,
          "vulnerability_to_line": null,
          "vulnerability_code": "        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UNCHECKED_CALL",
          "vulnerability_from_line": 319,
          "vulnerability_to_line": null,
          "vulnerability_code": "        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UNCHECKED_CALL",
          "vulnerability_from_line": 324,
          "vulnerability_to_line": null,
          "vulnerability_code": "        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UNCHECKED_CALL",
          "vulnerability_from_line": 329,
          "vulnerability_to_line": null,
          "vulnerability_code": "        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UNCHECKED_CALL",
          "vulnerability_from_line": 350,
          "vulnerability_to_line": null,
          "vulnerability_code": "        (bool success, bytes memory returndata) = address(token).call(data);\n",
          "message": null
        }
      ]
    },
    "oyente": {
      "successfull_analysis": false,
      "errors": [
        "exception (IndexError: pop from empty list)"
      ],
      "vulnerability_findings": []
    },
    "mythril": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": []
    },
    "osiris": {
      "successfull_analysis": false,
      "errors": [
        "Solidity compilation failed"
      ],
      "vulnerability_findings": []
    }
  }
}