{
  "smartbugs_completed": true,
  "analyzer_results": {
    "semgrep": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 133,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(set._values.length > index, \"EnumerableSet: index out of bounds\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 133,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(set._values.length > index, \"EnumerableSet: index out of bounds\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        }
      ]
    },
    "slither": {
      "successfull_analysis": true,
      "errors": [
        "EXIT_CODE_7"
      ],
      "vulnerability_findings": [
        {
          "name": "unused-return",
          "vulnerability_from_line": 74,
          "vulnerability_to_line": 106,
          "vulnerability_code": "    function _remove(Set storage set, bytes32 value) private returns (bool) {\n\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n\n        uint256 valueIndex = set._indexes[value];\n\n\n\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\n\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n\n            // This modifies the order of the array, as noted in {at}.\n\n\n\n            uint256 toDeleteIndex = valueIndex - 1;\n\n            uint256 lastIndex = set._values.length - 1;\n\n\n\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\n\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\n\n\n\n            bytes32 lastvalue = set._values[lastIndex];\n\n\n\n            // Move the last value to the index where the value to delete is\n\n            set._values[toDeleteIndex] = lastvalue;\n\n            // Update the index for the moved value\n\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\n\n\n\n            // Delete the slot where the moved value was stored\n\n            set._values.pop();\n\n\n\n            // Delete the index for the deleted slot\n\n            delete set._indexes[value];\n\n\n\n            return true;\n\n        } else {\n\n            return false;\n\n        }\n",
          "message": "EnumerableSet._remove (EnumerableSet.sol#74-106) does not use the value returned by external calls:\n\t-set._values.pop() (EnumerableSet.sol#97)\n"
        },
        {
          "name": "solc-version",
          "vulnerability_from_line": 5,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity >=0.6.11;\n",
          "message": "Detected issues with version pragma in EnumerableSet.sol:\n\t- pragma solidity>=0.6.11 (EnumerableSet.sol#5): it allows old versions\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 56,
          "vulnerability_to_line": 66,
          "vulnerability_code": "    function _add(Set storage set, bytes32 value) private returns (bool) {\n\n        if (!_contains(set, value)) {\n\n            set._values.push(value);\n\n            // The value is stored at length-1, but we add 1 to all indexes\n\n            // and use 0 as a sentinel value\n\n            set._indexes[value] = set._values.length;\n\n            return true;\n\n        } else {\n\n            return false;\n\n        }\n",
          "message": "Function 'EnumerableSet._add' (EnumerableSet.sol#56-66) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 74,
          "vulnerability_to_line": 106,
          "vulnerability_code": "    function _remove(Set storage set, bytes32 value) private returns (bool) {\n\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n\n        uint256 valueIndex = set._indexes[value];\n\n\n\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\n\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n\n            // This modifies the order of the array, as noted in {at}.\n\n\n\n            uint256 toDeleteIndex = valueIndex - 1;\n\n            uint256 lastIndex = set._values.length - 1;\n\n\n\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\n\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\n\n\n\n            bytes32 lastvalue = set._values[lastIndex];\n\n\n\n            // Move the last value to the index where the value to delete is\n\n            set._values[toDeleteIndex] = lastvalue;\n\n            // Update the index for the moved value\n\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\n\n\n\n            // Delete the slot where the moved value was stored\n\n            set._values.pop();\n\n\n\n            // Delete the index for the deleted slot\n\n            delete set._indexes[value];\n\n\n\n            return true;\n\n        } else {\n\n            return false;\n\n        }\n",
          "message": "Function 'EnumerableSet._remove' (EnumerableSet.sol#74-106) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 111,
          "vulnerability_to_line": 113,
          "vulnerability_code": "    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n\n        return set._indexes[value] != 0;\n",
          "message": "Function 'EnumerableSet._contains' (EnumerableSet.sol#111-113) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 118,
          "vulnerability_to_line": 120,
          "vulnerability_code": "    function _length(Set storage set) private view returns (uint256) {\n\n        return set._values.length;\n",
          "message": "Function 'EnumerableSet._length' (EnumerableSet.sol#118-120) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 132,
          "vulnerability_to_line": 135,
          "vulnerability_code": "    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n\n        require(set._values.length > index, \"EnumerableSet: index out of bounds\");\n\n        return set._values[index];\n",
          "message": "Function 'EnumerableSet._at' (EnumerableSet.sol#132-135) is not in mixedCase\n"
        }
      ]
    },
    "smartcheck": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 5,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity >=0.6.11;\n",
          "message": null
        }
      ]
    },
    "oyente": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": []
    },
    "mythril": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "Exception State (SWC 110)",
          "vulnerability_from_line": null,
          "vulnerability_to_line": null,
          "vulnerability_code": null,
          "message": "An assertion violation was triggered.\nIt is possible to trigger an assertion violation. Note that Solidity assert() statements should only be used to check invariants. Review the transaction trace generated for this issue and either make sure your program logic is correct, or use require() instead of assert() if your goal is to constrain user inputs or enforce preconditions. Remember to validate inputs from both callers (for instance, via passed arguments) and callees (for instance, via return values). This issue is reported for internal compiler generated code.\nClassification: SWC-110"
        }
      ]
    },
    "osiris": {
      "successfull_analysis": false,
      "errors": [
        "Solidity compilation failed"
      ],
      "vulnerability_findings": []
    }
  }
}