{
  "smartbugs_completed": true,
  "analyzer_results": {
    "semgrep": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 12,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor(address[N_TABLES] memory tables) public {\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 13,
          "vulnerability_to_line": null,
          "vulnerability_code": "        lookupTables = tables;\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 14,
          "vulnerability_to_line": null,
          "vulnerability_code": "\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 15,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 16,
          "vulnerability_to_line": null,
          "vulnerability_code": "            if gt(lookupTables_slot, 0) {\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 17,
          "vulnerability_to_line": null,
          "vulnerability_code": "                // The address of the lookupTables must be 0.\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 18,
          "vulnerability_to_line": null,
          "vulnerability_code": "                // This is guaranteed by the ABI, as long as it is the first storage variable.\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 19,
          "vulnerability_to_line": null,
          "vulnerability_code": "                // This is an assumption in the implementation, and can be removed if\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 20,
          "vulnerability_to_line": null,
          "vulnerability_code": "                // the lookup table address is taken into account.\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 21,
          "vulnerability_to_line": null,
          "vulnerability_code": "                revert(0, 0)\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 106,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(proofLength >= 4, \"Proof too short.\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 110,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(proofLength <= 402, \"Proof too long.\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 113,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require((proofLength & 1) == 0, \"Proof length must be even.\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 122,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(nodeIdx < 2**height, \"nodeIdx not in tree.\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 123,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require((nodeIdx & 1) == 0, \"nodeIdx must be even.\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        }
      ]
    },
    "slither": {
      "successfull_analysis": true,
      "errors": [
        "EXIT_CODE_4"
      ],
      "vulnerability_findings": [
        {
          "name": "constant-function",
          "vulnerability_from_line": 100,
          "vulnerability_to_line": 308,
          "vulnerability_code": "    function verifyMerkle(uint256[] memory merkleProof) internal view {\n\n        uint256 proofLength = merkleProof.length;\n\n\n\n        // The minimal supported proof length is for a tree height of 1 in a 4 word representation as follows:\n\n        // 1 word pairs representing the authentication path.\n\n        // 1 word pair representing the root and the nodeIdx.\n\n        require(proofLength >= 4, \"Proof too short.\");\n\n\n\n        // The contract supports verification paths of lengths up to 200 in a 402 word representation as described above.\n\n        // This limitation is imposed in order to avoid potential attacks.\n\n        require(proofLength <= 402, \"Proof too long.\");\n\n\n\n        // Ensure proofs are always a series of word pairs.\n\n        require((proofLength & 1) == 0, \"Proof length must be even.\");\n\n\n\n        // Each hash takes 2 256bit words and the last two words are the root and nodeIdx.\n\n        uint256 height = (proofLength - 2) / 2; // NOLINT: divide-before-multiply.\n\n\n\n        // Note that it is important to limit the range of vault id, to make sure\n\n        // we use the left node (== merkle_root) in the last iteration of the loop below.\n\n\n\n        uint256 nodeIdx = merkleProof[proofLength - 1] >> 8;\n\n        require(nodeIdx < 2**height, \"nodeIdx not in tree.\");\n\n        require((nodeIdx & 1) == 0, \"nodeIdx must be even.\");\n\n\n\n        uint256 rowSize = (2 * height) * 0x20;\n\n        uint256[] memory proof = merkleProof;\n\n        assembly {\n\n            // Skip the length of the proof array.\n\n            proof := add(proof, 0x20)\n\n\n\n            function raise_error(message, msg_len) {\n\n                // Solidity generates reverts with reason that look as follows:\n\n                // 1. 4 bytes with the constant 0x08c379a0 (== Keccak256(b'Error(string)')[:4]).\n\n                // 2. 32 bytes offset bytes (typically 0x20).\n\n                // 3. 32 bytes with the length of the revert reason.\n\n                // 4. Revert reason string.\n\n\n\n                mstore(0, 0x08c379a000000000000000000000000000000000000000000000000000000000)\n\n                mstore(0x4, 0x20)\n\n                mstore(0x24, msg_len)\n\n                mstore(0x44, message)\n\n                revert(0, add(0x44, msg_len))\n\n            }\n\n\n\n            let left_node := shr(4, mload(proof))\n\n            let right_node := and(\n\n                mload(add(proof, 0x1f)),\n\n                0x0fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n\n            )\n\n\n\n            let primeMinusOne := 0x800000000000011000000000000000000000000000000000000000000000000\n\n            if or(gt(left_node, primeMinusOne), gt(right_node, primeMinusOne)) {\n\n                raise_error(\"Bad starkKey or assetId.\", 24)\n\n            }\n\n\n\n            let nodeSelectors := nodeIdx\n\n\n\n            // Allocate EC points table with dimensions N_TABLES by N_HASHES.\n\n            let table := mload(0x40)\n\n            let tableEnd := add(\n\n                table,\n\n                mul(\n\n                    rowSize,\n\n                    // N_TABLES=\n\n                    63\n\n                )\n\n            )\n\n\n\n            // for i = 0..N_TABLES-1, fill the i'th row in the table.\n\n            for {\n\n                let i := 0\n\n            } lt(i, 63) {\n\n                i := add(i, 1)\n\n            } {\n\n                if iszero(\n\n                    staticcall(\n\n                        gas(),\n\n                        sload(i),\n\n                        add(proof, i),\n\n                        rowSize,\n\n                        add(table, mul(i, rowSize)),\n\n                        rowSize\n\n                    )\n\n                ) {\n\n                    returndatacopy(0, 0, returndatasize())\n\n                    revert(0, returndatasize())\n\n                }\n\n            }\n\n\n\n            // The following variables are allocated above PRIME to avoid the stack too deep error.\n\n            // Byte offset used to access the table and proof.\n\n            let offset := 0\n\n            let ptr\n\n            let aZ\n\n\n\n            let PRIME := 0x800000000000011000000000000000000000000000000000000000000000001\n\n\n\n            // For k = 0..HASHES-1, Compute the k'th hash by summing the k'th column in table.\n\n            // Instead of k we use offset := k * sizeof(EC point).\n\n            // Additonally we use ptr := offset + j * rowSize to ge over the EC points we want\n\n            // to sum.\n\n            for {\n\n\n\n            } lt(offset, rowSize) {\n\n\n\n            } {\n\n                // Init (aX, aY, aZ) to the first value in the current column and sum over the\n\n                // column.\n\n                ptr := add(table, offset)\n\n                aZ := 1\n\n                let aX := mload(ptr)\n\n                let aY := mload(add(ptr, 0x20))\n\n\n\n                for {\n\n                    ptr := add(ptr, rowSize)\n\n                } lt(ptr, tableEnd) {\n\n                    ptr := add(ptr, rowSize)\n\n                } {\n\n                    let bX := mload(ptr)\n\n                    let bY := mload(add(ptr, 0x20))\n\n\n\n                    // Set (aX, aY, aZ) to be the sum of the EC points (aX, aY, aZ) and (bX, bY, 1).\n\n                    let minusAZ := sub(PRIME, aZ)\n\n                    // Slope = sN/sD =  {(aY/aZ) - (bY/1)} / {(aX/aZ) - (bX/1)}.\n\n                    // sN = aY - bY * aZ.\n\n                    let sN := addmod(aY, mulmod(minusAZ, bY, PRIME), PRIME)\n\n\n\n                    let minusAZBX := mulmod(minusAZ, bX, PRIME)\n\n                    // sD = aX - bX * aZ.\n\n                    let sD := addmod(aX, minusAZBX, PRIME)\n\n\n\n                    let sSqrD := mulmod(sD, sD, PRIME)\n\n\n\n                    // Compute the (affine) x coordinate of the result as xN/xD.\n\n\n\n                    // (xN/xD) = ((sN)^2/(sD)^2) - (aX/aZ) - (bX/1).\n\n                    // xN = (sN)^2 * aZ - aX * (sD)^2 - bX * (sD)^2 * aZ.\n\n                    // = (sN)^2 * aZ + (sD^2) (bX * (-aZ) - aX).\n\n                    let xN := addmod(\n\n                        mulmod(mulmod(sN, sN, PRIME), aZ, PRIME),\n\n                        mulmod(sSqrD, add(minusAZBX, sub(PRIME, aX)), PRIME),\n\n                        PRIME\n\n                    )\n\n\n\n                    // xD = (sD)^2 * aZ.\n\n                    let xD := mulmod(sSqrD, aZ, PRIME)\n\n\n\n                    // Compute (aX', aY', aZ') for the next iteration and assigning them to (aX, aY, aZ).\n\n                    // (y/z) = (sN/sD) * {(bX/1) - (xN/xD)} - (bY/1).\n\n                    // aZ' = sD*xD.\n\n                    aZ := mulmod(sD, xD, PRIME)\n\n                    // aY' = sN*(bX * xD - xN) - bY*z = -bY * z + sN * (-xN + xD*bX).\n\n                    aY := addmod(\n\n                        sub(PRIME, mulmod(bY, aZ, PRIME)),\n\n                        mulmod(sN, add(sub(PRIME, xN), mulmod(xD, bX, PRIME)), PRIME),\n\n                        PRIME\n\n                    )\n\n\n\n                    // As the value of the affine x coordinate is xN/xD and z=sD*xD,\n\n                    // the projective x coordinate is xN*sD.\n\n                    aX := mulmod(xN, sD, PRIME)\n\n                }\n\n\n\n                // At this point proof[offset + 0x40] holds the next input to be hashed.\n\n                // This input is typically in the form left_node||right_node||0 and\n\n                // we need to extract the relevant node for the consistent check below.\n\n                // Note that the same logic is reused for the leaf computation and\n\n                // for the consistent check with the final root.\n\n                offset := add(offset, 0x40)\n\n\n\n                // Init expected_hash to left_node.\n\n                // It will be replaced by right_node if necessary.\n\n                let expected_hash := shr(4, mload(add(proof, offset)))\n\n\n\n                let other_node := and(\n\n                    // right_node\n\n                    mload(add(proof, add(offset, 0x1f))),\n\n                    0x0fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n\n                )\n\n\n\n                // Make sure both nodes are in the range [0, PRIME - 1].\n\n                if or(gt(expected_hash, primeMinusOne), gt(other_node, primeMinusOne)) {\n\n                    raise_error(\"Value out of range.\", 19)\n\n                }\n\n\n\n                nodeSelectors := shr(1, nodeSelectors)\n\n                if and(nodeSelectors, 1) {\n\n                    expected_hash := other_node\n\n                }\n\n\n\n                // Make sure the result is consistent with the Merkle path.\n\n                // I.e (aX/aZ) == expected_hash,\n\n                // where expected_hash = (nodeSelectors & 1) == 0 ? left_node : right_node.\n\n                // We also make sure aZ is not 0. I.e. during the summation we never tried\n\n                // to add two points with the same x coordinate.\n\n                // This is not strictly necessary because knowing how to trigger this condition\n\n                // implies knowing a non-trivial linear equation on the random points defining the\n\n                // hash function.\n\n                if iszero(aZ) {\n\n                    raise_error(\"aZ is zero.\", 11)\n\n                }\n\n\n\n                if sub(aX, mulmod(expected_hash, aZ, PRIME)) {\n\n                    raise_error(\"Bad Merkle path.\", 16)\n\n                }\n\n            }\n\n        }\n",
          "message": "PedersenMerkleVerifier.verifyMerkle (PedersenMerkleVerifier.sol#100-308) is declared view but contains assembly code\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 12,
          "vulnerability_to_line": 24,
          "vulnerability_code": "    constructor(address[N_TABLES] memory tables) public {\n\n        lookupTables = tables;\n\n\n\n        assembly {\n\n            if gt(lookupTables_slot, 0) {\n\n                // The address of the lookupTables must be 0.\n\n                // This is guaranteed by the ABI, as long as it is the first storage variable.\n\n                // This is an assumption in the implementation, and can be removed if\n\n                // the lookup table address is taken into account.\n\n                revert(0, 0)\n\n            }\n\n        }\n",
          "message": "PedersenMerkleVerifier.constructor uses assembly (PedersenMerkleVerifier.sol#12-24)\n\t- PedersenMerkleVerifier.sol#15-23\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 100,
          "vulnerability_to_line": 308,
          "vulnerability_code": "    function verifyMerkle(uint256[] memory merkleProof) internal view {\n\n        uint256 proofLength = merkleProof.length;\n\n\n\n        // The minimal supported proof length is for a tree height of 1 in a 4 word representation as follows:\n\n        // 1 word pairs representing the authentication path.\n\n        // 1 word pair representing the root and the nodeIdx.\n\n        require(proofLength >= 4, \"Proof too short.\");\n\n\n\n        // The contract supports verification paths of lengths up to 200 in a 402 word representation as described above.\n\n        // This limitation is imposed in order to avoid potential attacks.\n\n        require(proofLength <= 402, \"Proof too long.\");\n\n\n\n        // Ensure proofs are always a series of word pairs.\n\n        require((proofLength & 1) == 0, \"Proof length must be even.\");\n\n\n\n        // Each hash takes 2 256bit words and the last two words are the root and nodeIdx.\n\n        uint256 height = (proofLength - 2) / 2; // NOLINT: divide-before-multiply.\n\n\n\n        // Note that it is important to limit the range of vault id, to make sure\n\n        // we use the left node (== merkle_root) in the last iteration of the loop below.\n\n\n\n        uint256 nodeIdx = merkleProof[proofLength - 1] >> 8;\n\n        require(nodeIdx < 2**height, \"nodeIdx not in tree.\");\n\n        require((nodeIdx & 1) == 0, \"nodeIdx must be even.\");\n\n\n\n        uint256 rowSize = (2 * height) * 0x20;\n\n        uint256[] memory proof = merkleProof;\n\n        assembly {\n\n            // Skip the length of the proof array.\n\n            proof := add(proof, 0x20)\n\n\n\n            function raise_error(message, msg_len) {\n\n                // Solidity generates reverts with reason that look as follows:\n\n                // 1. 4 bytes with the constant 0x08c379a0 (== Keccak256(b'Error(string)')[:4]).\n\n                // 2. 32 bytes offset bytes (typically 0x20).\n\n                // 3. 32 bytes with the length of the revert reason.\n\n                // 4. Revert reason string.\n\n\n\n                mstore(0, 0x08c379a000000000000000000000000000000000000000000000000000000000)\n\n                mstore(0x4, 0x20)\n\n                mstore(0x24, msg_len)\n\n                mstore(0x44, message)\n\n                revert(0, add(0x44, msg_len))\n\n            }\n\n\n\n            let left_node := shr(4, mload(proof))\n\n            let right_node := and(\n\n                mload(add(proof, 0x1f)),\n\n                0x0fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n\n            )\n\n\n\n            let primeMinusOne := 0x800000000000011000000000000000000000000000000000000000000000000\n\n            if or(gt(left_node, primeMinusOne), gt(right_node, primeMinusOne)) {\n\n                raise_error(\"Bad starkKey or assetId.\", 24)\n\n            }\n\n\n\n            let nodeSelectors := nodeIdx\n\n\n\n            // Allocate EC points table with dimensions N_TABLES by N_HASHES.\n\n            let table := mload(0x40)\n\n            let tableEnd := add(\n\n                table,\n\n                mul(\n\n                    rowSize,\n\n                    // N_TABLES=\n\n                    63\n\n                )\n\n            )\n\n\n\n            // for i = 0..N_TABLES-1, fill the i'th row in the table.\n\n            for {\n\n                let i := 0\n\n            } lt(i, 63) {\n\n                i := add(i, 1)\n\n            } {\n\n                if iszero(\n\n                    staticcall(\n\n                        gas(),\n\n                        sload(i),\n\n                        add(proof, i),\n\n                        rowSize,\n\n                        add(table, mul(i, rowSize)),\n\n                        rowSize\n\n                    )\n\n                ) {\n\n                    returndatacopy(0, 0, returndatasize())\n\n                    revert(0, returndatasize())\n\n                }\n\n            }\n\n\n\n            // The following variables are allocated above PRIME to avoid the stack too deep error.\n\n            // Byte offset used to access the table and proof.\n\n            let offset := 0\n\n            let ptr\n\n            let aZ\n\n\n\n            let PRIME := 0x800000000000011000000000000000000000000000000000000000000000001\n\n\n\n            // For k = 0..HASHES-1, Compute the k'th hash by summing the k'th column in table.\n\n            // Instead of k we use offset := k * sizeof(EC point).\n\n            // Additonally we use ptr := offset + j * rowSize to ge over the EC points we want\n\n            // to sum.\n\n            for {\n\n\n\n            } lt(offset, rowSize) {\n\n\n\n            } {\n\n                // Init (aX, aY, aZ) to the first value in the current column and sum over the\n\n                // column.\n\n                ptr := add(table, offset)\n\n                aZ := 1\n\n                let aX := mload(ptr)\n\n                let aY := mload(add(ptr, 0x20))\n\n\n\n                for {\n\n                    ptr := add(ptr, rowSize)\n\n                } lt(ptr, tableEnd) {\n\n                    ptr := add(ptr, rowSize)\n\n                } {\n\n                    let bX := mload(ptr)\n\n                    let bY := mload(add(ptr, 0x20))\n\n\n\n                    // Set (aX, aY, aZ) to be the sum of the EC points (aX, aY, aZ) and (bX, bY, 1).\n\n                    let minusAZ := sub(PRIME, aZ)\n\n                    // Slope = sN/sD =  {(aY/aZ) - (bY/1)} / {(aX/aZ) - (bX/1)}.\n\n                    // sN = aY - bY * aZ.\n\n                    let sN := addmod(aY, mulmod(minusAZ, bY, PRIME), PRIME)\n\n\n\n                    let minusAZBX := mulmod(minusAZ, bX, PRIME)\n\n                    // sD = aX - bX * aZ.\n\n                    let sD := addmod(aX, minusAZBX, PRIME)\n\n\n\n                    let sSqrD := mulmod(sD, sD, PRIME)\n\n\n\n                    // Compute the (affine) x coordinate of the result as xN/xD.\n\n\n\n                    // (xN/xD) = ((sN)^2/(sD)^2) - (aX/aZ) - (bX/1).\n\n                    // xN = (sN)^2 * aZ - aX * (sD)^2 - bX * (sD)^2 * aZ.\n\n                    // = (sN)^2 * aZ + (sD^2) (bX * (-aZ) - aX).\n\n                    let xN := addmod(\n\n                        mulmod(mulmod(sN, sN, PRIME), aZ, PRIME),\n\n                        mulmod(sSqrD, add(minusAZBX, sub(PRIME, aX)), PRIME),\n\n                        PRIME\n\n                    )\n\n\n\n                    // xD = (sD)^2 * aZ.\n\n                    let xD := mulmod(sSqrD, aZ, PRIME)\n\n\n\n                    // Compute (aX', aY', aZ') for the next iteration and assigning them to (aX, aY, aZ).\n\n                    // (y/z) = (sN/sD) * {(bX/1) - (xN/xD)} - (bY/1).\n\n                    // aZ' = sD*xD.\n\n                    aZ := mulmod(sD, xD, PRIME)\n\n                    // aY' = sN*(bX * xD - xN) - bY*z = -bY * z + sN * (-xN + xD*bX).\n\n                    aY := addmod(\n\n                        sub(PRIME, mulmod(bY, aZ, PRIME)),\n\n                        mulmod(sN, add(sub(PRIME, xN), mulmod(xD, bX, PRIME)), PRIME),\n\n                        PRIME\n\n                    )\n\n\n\n                    // As the value of the affine x coordinate is xN/xD and z=sD*xD,\n\n                    // the projective x coordinate is xN*sD.\n\n                    aX := mulmod(xN, sD, PRIME)\n\n                }\n\n\n\n                // At this point proof[offset + 0x40] holds the next input to be hashed.\n\n                // This input is typically in the form left_node||right_node||0 and\n\n                // we need to extract the relevant node for the consistent check below.\n\n                // Note that the same logic is reused for the leaf computation and\n\n                // for the consistent check with the final root.\n\n                offset := add(offset, 0x40)\n\n\n\n                // Init expected_hash to left_node.\n\n                // It will be replaced by right_node if necessary.\n\n                let expected_hash := shr(4, mload(add(proof, offset)))\n\n\n\n                let other_node := and(\n\n                    // right_node\n\n                    mload(add(proof, add(offset, 0x1f))),\n\n                    0x0fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n\n                )\n\n\n\n                // Make sure both nodes are in the range [0, PRIME - 1].\n\n                if or(gt(expected_hash, primeMinusOne), gt(other_node, primeMinusOne)) {\n\n                    raise_error(\"Value out of range.\", 19)\n\n                }\n\n\n\n                nodeSelectors := shr(1, nodeSelectors)\n\n                if and(nodeSelectors, 1) {\n\n                    expected_hash := other_node\n\n                }\n\n\n\n                // Make sure the result is consistent with the Merkle path.\n\n                // I.e (aX/aZ) == expected_hash,\n\n                // where expected_hash = (nodeSelectors & 1) == 0 ? left_node : right_node.\n\n                // We also make sure aZ is not 0. I.e. during the summation we never tried\n\n                // to add two points with the same x coordinate.\n\n                // This is not strictly necessary because knowing how to trigger this condition\n\n                // implies knowing a non-trivial linear equation on the random points defining the\n\n                // hash function.\n\n                if iszero(aZ) {\n\n                    raise_error(\"aZ is zero.\", 11)\n\n                }\n\n\n\n                if sub(aX, mulmod(expected_hash, aZ, PRIME)) {\n\n                    raise_error(\"Bad Merkle path.\", 16)\n\n                }\n\n            }\n\n        }\n",
          "message": "PedersenMerkleVerifier.verifyMerkle uses assembly (PedersenMerkleVerifier.sol#100-308)\n\t- PedersenMerkleVerifier.sol#127-307\n"
        },
        {
          "name": "solc-version",
          "vulnerability_from_line": 4,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.6.12;\n",
          "message": "Detected issues with version pragma in PedersenMerkleVerifier.sol:\n\t- pragma solidity^0.6.12 (PedersenMerkleVerifier.sol#4): it allows old versions\n"
        }
      ]
    },
    "smartcheck": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 125,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint256 rowSize = (2 * height) * 0x20;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 4,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.6.12;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
          "vulnerability_from_line": 100,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function verifyMerkle(uint256[] memory merkleProof) internal view {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 15,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 127,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 10,
          "vulnerability_to_line": null,
          "vulnerability_code": "    address[N_TABLES] lookupTables;\n",
          "message": null
        }
      ]
    },
    "oyente": {
      "successfull_analysis": false,
      "errors": [
        "exception (IndexError: pop from empty list)"
      ],
      "vulnerability_findings": []
    },
    "mythril": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": []
    },
    "osiris": {
      "successfull_analysis": false,
      "errors": [
        "Solidity compilation failed"
      ],
      "vulnerability_findings": []
    }
  }
}