{
  "smartbugs_completed": true,
  "analyzer_results": {
    "semgrep": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": []
    },
    "slither": {
      "successfull_analysis": true,
      "errors": [
        "EXIT_CODE_2"
      ],
      "vulnerability_findings": [
        {
          "name": "erc20-interface",
          "vulnerability_from_line": 9,
          "vulnerability_to_line": 69,
          "vulnerability_code": "interface IERC721 {\n\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n\n\n    /**\n\n      Returns the number of NFTs in ``owner``'s account.\n\n    */\n\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n\n\n    /**\n\n      Returns the owner of the NFT specified by `tokenId`.\n\n    */\n\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n\n\n    /**\n\n      Transfers a specific NFT (`tokenId`) from one account (`from`) to\n\n      another (`to`).\n\n\n\n\n\n\n\n      Requirements:\n\n      - `from`, `to` cannot be zero.\n\n      - `tokenId` must be owned by `from`.\n\n      - If the caller is not `from`, it must be have been allowed to move this\n\n      NFT by either {approve} or {setApprovalForAll}.\n\n    */\n\n    function safeTransferFrom(\n\n        address from,\n\n        address to,\n\n        uint256 tokenId\n\n    ) external;\n\n\n\n    /**\n\n      Transfers a specific NFT (`tokenId`) from one account (`from`) to\n\n      another (`to`).\n\n           Requirements:\n\n      - If the caller is not `from`, it must be approved to move this NFT by\n\n      either {approve} or {setApprovalForAll}.\n\n    */\n\n    function transferFrom(\n\n        address from,\n\n        address to,\n\n        uint256 tokenId\n\n    ) external;\n\n\n\n    function approve(address to, uint256 tokenId) external;\n\n\n\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n\n\n    function setApprovalForAll(address operator, bool _approved) external;\n\n\n\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n\n\n    function safeTransferFrom(\n\n        address from,\n\n        address to,\n\n        uint256 tokenId,\n\n        bytes calldata data\n\n    ) external;\n",
          "message": "IERC721 (IERC721.sol#9-69) has incorrect ERC20 function interface(s):\n\t-transferFrom (IERC721.sol#49-53)\n\t-approve (IERC721.sol#55)\n"
        },
        {
          "name": "solc-version",
          "vulnerability_from_line": 4,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.6.12;\n",
          "message": "Detected issues with version pragma in IERC721.sol:\n\t- pragma solidity^0.6.12 (IERC721.sol#4): it allows old versions\n"
        }
      ]
    },
    "smartcheck": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 4,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.6.12;\n",
          "message": null
        }
      ]
    },
    "oyente": {
      "successfull_analysis": false,
      "errors": [
        "execution failed"
      ],
      "vulnerability_findings": []
    },
    "mythril": {
      "successfull_analysis": false,
      "errors": [
        "input files do not contain any valid contracts"
      ],
      "vulnerability_findings": []
    },
    "osiris": {
      "successfull_analysis": false,
      "errors": [
        "Solidity compilation failed"
      ],
      "vulnerability_findings": []
    }
  }
}