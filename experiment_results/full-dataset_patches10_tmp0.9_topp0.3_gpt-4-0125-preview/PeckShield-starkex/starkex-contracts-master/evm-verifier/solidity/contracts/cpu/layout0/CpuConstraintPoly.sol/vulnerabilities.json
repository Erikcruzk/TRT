{
  "smartbugs_completed": true,
  "analyzer_results": {
    "semgrep": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": []
    },
    "slither": {
      "successfull_analysis": true,
      "errors": [
        "EXIT_CODE_2"
      ],
      "vulnerability_findings": [
        {
          "name": "assembly",
          "vulnerability_from_line": 91,
          "vulnerability_to_line": 5239,
          "vulnerability_code": "    fallback() external {\n\n        uint256 res;\n\n        assembly {\n\n            let PRIME := 0x800000000000011000000000000000000000000000000000000000000000001\n\n            // Copy input from calldata to memory.\n\n            calldatacopy(0x0, 0x0, /*Input data size*/ 0x3380)\n\n            let point := /*oods_point*/ mload(0x380)\n\n            function expmod(base, exponent, modulus) -> result {\n\n              let p := /*expmod_context*/ 0x43a0\n\n              mstore(p, 0x20)                 // Length of Base.\n\n              mstore(add(p, 0x20), 0x20)      // Length of Exponent.\n\n              mstore(add(p, 0x40), 0x20)      // Length of Modulus.\n\n              mstore(add(p, 0x60), base)      // Base.\n\n              mstore(add(p, 0x80), exponent)  // Exponent.\n\n              mstore(add(p, 0xa0), modulus)   // Modulus.\n\n              // Call modexp precompile.\n\n              if iszero(staticcall(not(0), 0x05, p, 0xc0, p, 0x20)) {\n\n                revert(0, 0)\n\n              }\n\n              result := mload(p)\n\n            }\n\n            {\n\n              // Prepare expmods for denominators and numerators.\n\n\n\n              // expmods[0] = point^trace_length.\n\n              mstore(0x38e0, expmod(point, /*trace_length*/ mload(0x80), PRIME))\n\n\n\n              // expmods[1] = point^(trace_length / 16).\n\n              mstore(0x3900, expmod(point, div(/*trace_length*/ mload(0x80), 16), PRIME))\n\n\n\n              // expmods[2] = point^(trace_length / 2).\n\n              mstore(0x3920, expmod(point, div(/*trace_length*/ mload(0x80), 2), PRIME))\n\n\n\n              // expmods[3] = point^(trace_length / 8).\n\n              mstore(0x3940, expmod(point, div(/*trace_length*/ mload(0x80), 8), PRIME))\n\n\n\n              // expmods[4] = point^(trace_length / 256).\n\n              mstore(0x3960, expmod(point, div(/*trace_length*/ mload(0x80), 256), PRIME))\n\n\n\n              // expmods[5] = point^(trace_length / 512).\n\n              mstore(0x3980, expmod(point, div(/*trace_length*/ mload(0x80), 512), PRIME))\n\n\n\n              // expmods[6] = point^(trace_length / 128).\n\n              mstore(0x39a0, expmod(point, div(/*trace_length*/ mload(0x80), 128), PRIME))\n\n\n\n              // expmods[7] = point^(trace_length / 4096).\n\n              mstore(0x39c0, expmod(point, div(/*trace_length*/ mload(0x80), 4096), PRIME))\n\n\n\n              // expmods[8] = point^(trace_length / 32).\n\n              mstore(0x39e0, expmod(point, div(/*trace_length*/ mload(0x80), 32), PRIME))\n\n\n\n              // expmods[9] = point^(trace_length / 8192).\n\n              mstore(0x3a00, expmod(point, div(/*trace_length*/ mload(0x80), 8192), PRIME))\n\n\n\n              // expmods[10] = trace_generator^(15 * trace_length / 16).\n\n              mstore(0x3a20, expmod(/*trace_generator*/ mload(0x360), div(mul(15, /*trace_length*/ mload(0x80)), 16), PRIME))\n\n\n\n              // expmods[11] = trace_generator^(16 * (trace_length / 16 - 1)).\n\n              mstore(0x3a40, expmod(/*trace_generator*/ mload(0x360), mul(16, sub(div(/*trace_length*/ mload(0x80), 16), 1)), PRIME))\n\n\n\n              // expmods[12] = trace_generator^(2 * (trace_length / 2 - 1)).\n\n              mstore(0x3a60, expmod(/*trace_generator*/ mload(0x360), mul(2, sub(div(/*trace_length*/ mload(0x80), 2), 1)), PRIME))\n\n\n\n              // expmods[13] = trace_generator^(trace_length - 1).\n\n              mstore(0x3a80, expmod(/*trace_generator*/ mload(0x360), sub(/*trace_length*/ mload(0x80), 1), PRIME))\n\n\n\n              // expmods[14] = trace_generator^(255 * trace_length / 256).\n\n              mstore(0x3aa0, expmod(/*trace_generator*/ mload(0x360), div(mul(255, /*trace_length*/ mload(0x80)), 256), PRIME))\n\n\n\n              // expmods[15] = trace_generator^(63 * trace_length / 64).\n\n              mstore(0x3ac0, expmod(/*trace_generator*/ mload(0x360), div(mul(63, /*trace_length*/ mload(0x80)), 64), PRIME))\n\n\n\n              // expmods[16] = trace_generator^(trace_length / 2).\n\n              mstore(0x3ae0, expmod(/*trace_generator*/ mload(0x360), div(/*trace_length*/ mload(0x80), 2), PRIME))\n\n\n\n              // expmods[17] = trace_generator^(128 * (trace_length / 128 - 1)).\n\n              mstore(0x3b00, expmod(/*trace_generator*/ mload(0x360), mul(128, sub(div(/*trace_length*/ mload(0x80), 128), 1)), PRIME))\n\n\n\n              // expmods[18] = trace_generator^(251 * trace_length / 256).\n\n              mstore(0x3b20, expmod(/*trace_generator*/ mload(0x360), div(mul(251, /*trace_length*/ mload(0x80)), 256), PRIME))\n\n\n\n              // expmods[19] = trace_generator^(8192 * (trace_length / 8192 - 1)).\n\n              mstore(0x3b40, expmod(/*trace_generator*/ mload(0x360), mul(8192, sub(div(/*trace_length*/ mload(0x80), 8192), 1)), PRIME))\n\n\n\n            }\n\n\n\n            {\n\n              // Compute domains.\n\n\n\n              // Denominator for constraints: 'cpu/decode/opcode_rc/bit', 'rc16/perm/step0', 'rc16/diff_is_bit', 'pedersen/hash0/ec_subset_sum/booleanity_test', 'pedersen/hash0/ec_subset_sum/add_points/slope', 'pedersen/hash0/ec_subset_sum/add_points/x', 'pedersen/hash0/ec_subset_sum/add_points/y', 'pedersen/hash0/ec_subset_sum/copy_point/x', 'pedersen/hash0/ec_subset_sum/copy_point/y', 'pedersen/hash1/ec_subset_sum/booleanity_test', 'pedersen/hash1/ec_subset_sum/add_points/slope', 'pedersen/hash1/ec_subset_sum/add_points/x', 'pedersen/hash1/ec_subset_sum/add_points/y', 'pedersen/hash1/ec_subset_sum/copy_point/x', 'pedersen/hash1/ec_subset_sum/copy_point/y', 'pedersen/hash2/ec_subset_sum/booleanity_test', 'pedersen/hash2/ec_subset_sum/add_points/slope', 'pedersen/hash2/ec_subset_sum/add_points/x', 'pedersen/hash2/ec_subset_sum/add_points/y', 'pedersen/hash2/ec_subset_sum/copy_point/x', 'pedersen/hash2/ec_subset_sum/copy_point/y', 'pedersen/hash3/ec_subset_sum/booleanity_test', 'pedersen/hash3/ec_subset_sum/add_points/slope', 'pedersen/hash3/ec_subset_sum/add_points/x', 'pedersen/hash3/ec_subset_sum/add_points/y', 'pedersen/hash3/ec_subset_sum/copy_point/x', 'pedersen/hash3/ec_subset_sum/copy_point/y'.\n\n              // domains[0] = point^trace_length - 1.\n\n              mstore(0x3b60,\n\n                     addmod(/*point^trace_length*/ mload(0x38e0), sub(PRIME, 1), PRIME))\n\n\n\n              // Denominator for constraints: 'cpu/decode/opcode_rc/zero'.\n\n              // Numerator for constraints: 'cpu/decode/opcode_rc/bit'.\n\n              // domains[1] = point^(trace_length / 16) - trace_generator^(15 * trace_length / 16).\n\n              mstore(0x3b80,\n\n                     addmod(\n\n                       /*point^(trace_length / 16)*/ mload(0x3900),\n\n                       sub(PRIME, /*trace_generator^(15 * trace_length / 16)*/ mload(0x3a20)),\n\n                       PRIME))\n\n\n\n              // Denominator for constraints: 'cpu/decode/opcode_rc_input', 'cpu/decode/flag_op1_base_op0_bit', 'cpu/decode/flag_res_op1_bit', 'cpu/decode/flag_pc_update_regular_bit', 'cpu/decode/fp_update_regular_bit', 'cpu/operands/mem_dst_addr', 'cpu/operands/mem0_addr', 'cpu/operands/mem1_addr', 'cpu/operands/ops_mul', 'cpu/operands/res', 'cpu/update_registers/update_pc/tmp0', 'cpu/update_registers/update_pc/tmp1', 'cpu/update_registers/update_pc/pc_cond_negative', 'cpu/update_registers/update_pc/pc_cond_positive', 'cpu/update_registers/update_ap/ap_update', 'cpu/update_registers/update_fp/fp_update', 'cpu/opcodes/call/push_fp', 'cpu/opcodes/call/push_pc', 'cpu/opcodes/call/off0', 'cpu/opcodes/call/off1', 'cpu/opcodes/call/flags', 'cpu/opcodes/ret/off0', 'cpu/opcodes/ret/off2', 'cpu/opcodes/ret/flags', 'cpu/opcodes/assert_eq/assert_eq', 'ecdsa/signature0/doubling_key/slope', 'ecdsa/signature0/doubling_key/x', 'ecdsa/signature0/doubling_key/y', 'ecdsa/signature0/exponentiate_key/booleanity_test', 'ecdsa/signature0/exponentiate_key/add_points/slope', 'ecdsa/signature0/exponentiate_key/add_points/x', 'ecdsa/signature0/exponentiate_key/add_points/y', 'ecdsa/signature0/exponentiate_key/add_points/x_diff_inv', 'ecdsa/signature0/exponentiate_key/copy_point/x', 'ecdsa/signature0/exponentiate_key/copy_point/y'.\n\n              // domains[2] = point^(trace_length / 16) - 1.\n\n              mstore(0x3ba0,\n\n                     addmod(/*point^(trace_length / 16)*/ mload(0x3900), sub(PRIME, 1), PRIME))\n\n\n\n              // Denominator for constraints: 'final_ap', 'final_fp', 'final_pc'.\n\n              // Numerator for constraints: 'cpu/update_registers/update_pc/tmp0', 'cpu/update_registers/update_pc/tmp1', 'cpu/update_registers/update_pc/pc_cond_negative', 'cpu/update_registers/update_pc/pc_cond_positive', 'cpu/update_registers/update_ap/ap_update', 'cpu/update_registers/update_fp/fp_update'.\n\n              // domains[3] = point - trace_generator^(16 * (trace_length / 16 - 1)).\n\n              mstore(0x3bc0,\n\n                     addmod(\n\n                       point,\n\n                       sub(PRIME, /*trace_generator^(16 * (trace_length / 16 - 1))*/ mload(0x3a40)),\n\n                       PRIME))\n\n\n\n              // Denominator for constraints: 'initial_ap', 'initial_fp', 'initial_pc', 'memory/multi_column_perm/perm/init0', 'memory/initial_addr', 'rc16/perm/init0', 'rc16/minimum', 'pedersen/init_addr', 'rc_builtin/init_addr', 'ecdsa/init_addr'.\n\n              // domains[4] = point - 1.\n\n              mstore(0x3be0,\n\n                     addmod(point, sub(PRIME, 1), PRIME))\n\n\n\n              // Denominator for constraints: 'memory/multi_column_perm/perm/step0', 'memory/diff_is_bit', 'memory/is_func'.\n\n              // domains[5] = point^(trace_length / 2) - 1.\n\n              mstore(0x3c00,\n\n                     addmod(/*point^(trace_length / 2)*/ mload(0x3920), sub(PRIME, 1), PRIME))\n\n\n\n              // Denominator for constraints: 'memory/multi_column_perm/perm/last'.\n\n              // Numerator for constraints: 'memory/multi_column_perm/perm/step0', 'memory/diff_is_bit', 'memory/is_func'.\n\n              // domains[6] = point - trace_generator^(2 * (trace_length / 2 - 1)).\n\n              mstore(0x3c20,\n\n                     addmod(\n\n                       point,\n\n                       sub(PRIME, /*trace_generator^(2 * (trace_length / 2 - 1))*/ mload(0x3a60)),\n\n                       PRIME))\n\n\n\n              // Denominator for constraints: 'public_memory_addr_zero', 'public_memory_value_zero'.\n\n              // domains[7] = point^(trace_length / 8) - 1.\n\n              mstore(0x3c40,\n\n                     addmod(/*point^(trace_length / 8)*/ mload(0x3940), sub(PRIME, 1), PRIME))\n\n\n\n              // Denominator for constraints: 'rc16/perm/last', 'rc16/maximum'.\n\n              // Numerator for constraints: 'rc16/perm/step0', 'rc16/diff_is_bit'.\n\n              // domains[8] = point - trace_generator^(trace_length - 1).\n\n              mstore(0x3c60,\n\n                     addmod(point, sub(PRIME, /*trace_generator^(trace_length - 1)*/ mload(0x3a80)), PRIME))\n\n\n\n              // Denominator for constraints: 'pedersen/hash0/ec_subset_sum/bit_unpacking/last_one_is_zero', 'pedersen/hash0/ec_subset_sum/bit_unpacking/zeroes_between_ones0', 'pedersen/hash0/ec_subset_sum/bit_unpacking/cumulative_bit192', 'pedersen/hash0/ec_subset_sum/bit_unpacking/zeroes_between_ones192', 'pedersen/hash0/ec_subset_sum/bit_unpacking/cumulative_bit196', 'pedersen/hash0/ec_subset_sum/bit_unpacking/zeroes_between_ones196', 'pedersen/hash0/copy_point/x', 'pedersen/hash0/copy_point/y', 'pedersen/hash1/ec_subset_sum/bit_unpacking/last_one_is_zero', 'pedersen/hash1/ec_subset_sum/bit_unpacking/zeroes_between_ones0', 'pedersen/hash1/ec_subset_sum/bit_unpacking/cumulative_bit192', 'pedersen/hash1/ec_subset_sum/bit_unpacking/zeroes_between_ones192', 'pedersen/hash1/ec_subset_sum/bit_unpacking/cumulative_bit196', 'pedersen/hash1/ec_subset_sum/bit_unpacking/zeroes_between_ones196', 'pedersen/hash1/copy_point/x', 'pedersen/hash1/copy_point/y', 'pedersen/hash2/ec_subset_sum/bit_unpacking/last_one_is_zero', 'pedersen/hash2/ec_subset_sum/bit_unpacking/zeroes_between_ones0', 'pedersen/hash2/ec_subset_sum/bit_unpacking/cumulative_bit192', 'pedersen/hash2/ec_subset_sum/bit_unpacking/zeroes_between_ones192', 'pedersen/hash2/ec_subset_sum/bit_unpacking/cumulative_bit196', 'pedersen/hash2/ec_subset_sum/bit_unpacking/zeroes_between_ones196', 'pedersen/hash2/copy_point/x', 'pedersen/hash2/copy_point/y', 'pedersen/hash3/ec_subset_sum/bit_unpacking/last_one_is_zero', 'pedersen/hash3/ec_subset_sum/bit_unpacking/zeroes_between_ones0', 'pedersen/hash3/ec_subset_sum/bit_unpacking/cumulative_bit192', 'pedersen/hash3/ec_subset_sum/bit_unpacking/zeroes_between_ones192', 'pedersen/hash3/ec_subset_sum/bit_unpacking/cumulative_bit196', 'pedersen/hash3/ec_subset_sum/bit_unpacking/zeroes_between_ones196', 'pedersen/hash3/copy_point/x', 'pedersen/hash3/copy_point/y'.\n\n              // domains[9] = point^(trace_length / 256) - 1.\n\n              mstore(0x3c80,\n\n                     addmod(/*point^(trace_length / 256)*/ mload(0x3960), sub(PRIME, 1), PRIME))\n\n\n\n              // Denominator for constraints: 'pedersen/hash0/ec_subset_sum/zeros_tail', 'pedersen/hash1/ec_subset_sum/zeros_tail', 'pedersen/hash2/ec_subset_sum/zeros_tail', 'pedersen/hash3/ec_subset_sum/zeros_tail'.\n\n              // Numerator for constraints: 'pedersen/hash0/ec_subset_sum/booleanity_test', 'pedersen/hash0/ec_subset_sum/add_points/slope', 'pedersen/hash0/ec_subset_sum/add_points/x', 'pedersen/hash0/ec_subset_sum/add_points/y', 'pedersen/hash0/ec_subset_sum/copy_point/x', 'pedersen/hash0/ec_subset_sum/copy_point/y', 'pedersen/hash1/ec_subset_sum/booleanity_test', 'pedersen/hash1/ec_subset_sum/add_points/slope', 'pedersen/hash1/ec_subset_sum/add_points/x', 'pedersen/hash1/ec_subset_sum/add_points/y', 'pedersen/hash1/ec_subset_sum/copy_point/x', 'pedersen/hash1/ec_subset_sum/copy_point/y', 'pedersen/hash2/ec_subset_sum/booleanity_test', 'pedersen/hash2/ec_subset_sum/add_points/slope', 'pedersen/hash2/ec_subset_sum/add_points/x', 'pedersen/hash2/ec_subset_sum/add_points/y', 'pedersen/hash2/ec_subset_sum/copy_point/x', 'pedersen/hash2/ec_subset_sum/copy_point/y', 'pedersen/hash3/ec_subset_sum/booleanity_test', 'pedersen/hash3/ec_subset_sum/add_points/slope', 'pedersen/hash3/ec_subset_sum/add_points/x', 'pedersen/hash3/ec_subset_sum/add_points/y', 'pedersen/hash3/ec_subset_sum/copy_point/x', 'pedersen/hash3/ec_subset_sum/copy_point/y'.\n\n              // domains[10] = point^(trace_length / 256) - trace_generator^(255 * trace_length / 256).\n\n              mstore(0x3ca0,\n\n                     addmod(\n\n                       /*point^(trace_length / 256)*/ mload(0x3960),\n\n                       sub(PRIME, /*trace_generator^(255 * trace_length / 256)*/ mload(0x3aa0)),\n\n                       PRIME))\n\n\n\n              // Denominator for constraints: 'pedersen/hash0/ec_subset_sum/bit_extraction_end', 'pedersen/hash1/ec_subset_sum/bit_extraction_end', 'pedersen/hash2/ec_subset_sum/bit_extraction_end', 'pedersen/hash3/ec_subset_sum/bit_extraction_end'.\n\n              // domains[11] = point^(trace_length / 256) - trace_generator^(63 * trace_length / 64).\n\n              mstore(0x3cc0,\n\n                     addmod(\n\n                       /*point^(trace_length / 256)*/ mload(0x3960),\n\n                       sub(PRIME, /*trace_generator^(63 * trace_length / 64)*/ mload(0x3ac0)),\n\n                       PRIME))\n\n\n\n              // Numerator for constraints: 'pedersen/hash0/copy_point/x', 'pedersen/hash0/copy_point/y', 'pedersen/hash1/copy_point/x', 'pedersen/hash1/copy_point/y', 'pedersen/hash2/copy_point/x', 'pedersen/hash2/copy_point/y', 'pedersen/hash3/copy_point/x', 'pedersen/hash3/copy_point/y'.\n\n              // domains[12] = point^(trace_length / 512) - trace_generator^(trace_length / 2).\n\n              mstore(0x3ce0,\n\n                     addmod(\n\n                       /*point^(trace_length / 512)*/ mload(0x3980),\n\n                       sub(PRIME, /*trace_generator^(trace_length / 2)*/ mload(0x3ae0)),\n\n                       PRIME))\n\n\n\n              // Denominator for constraints: 'pedersen/hash0/init/x', 'pedersen/hash0/init/y', 'pedersen/hash1/init/x', 'pedersen/hash1/init/y', 'pedersen/hash2/init/x', 'pedersen/hash2/init/y', 'pedersen/hash3/init/x', 'pedersen/hash3/init/y', 'pedersen/input0_value0', 'pedersen/input0_value1', 'pedersen/input0_value2', 'pedersen/input0_value3', 'pedersen/input1_value0', 'pedersen/input1_value1', 'pedersen/input1_value2', 'pedersen/input1_value3', 'pedersen/output_value0', 'pedersen/output_value1', 'pedersen/output_value2', 'pedersen/output_value3'.\n\n              // domains[13] = point^(trace_length / 512) - 1.\n\n              mstore(0x3d00,\n\n                     addmod(/*point^(trace_length / 512)*/ mload(0x3980), sub(PRIME, 1), PRIME))\n\n\n\n              // Denominator for constraints: 'pedersen/input0_addr', 'pedersen/input1_addr', 'pedersen/output_addr', 'rc_builtin/value', 'rc_builtin/addr_step'.\n\n              // domains[14] = point^(trace_length / 128) - 1.\n\n              mstore(0x3d20,\n\n                     addmod(/*point^(trace_length / 128)*/ mload(0x39a0), sub(PRIME, 1), PRIME))\n\n\n\n              // Numerator for constraints: 'pedersen/input0_addr', 'rc_builtin/addr_step'.\n\n              // domains[15] = point - trace_generator^(128 * (trace_length / 128 - 1)).\n\n              mstore(0x3d40,\n\n                     addmod(\n\n                       point,\n\n                       sub(PRIME, /*trace_generator^(128 * (trace_length / 128 - 1))*/ mload(0x3b00)),\n\n                       PRIME))\n\n\n\n              // Denominator for constraints: 'ecdsa/signature0/exponentiate_key/zeros_tail'.\n\n              // Numerator for constraints: 'ecdsa/signature0/doubling_key/slope', 'ecdsa/signature0/doubling_key/x', 'ecdsa/signature0/doubling_key/y', 'ecdsa/signature0/exponentiate_key/booleanity_test', 'ecdsa/signature0/exponentiate_key/add_points/slope', 'ecdsa/signature0/exponentiate_key/add_points/x', 'ecdsa/signature0/exponentiate_key/add_points/y', 'ecdsa/signature0/exponentiate_key/add_points/x_diff_inv', 'ecdsa/signature0/exponentiate_key/copy_point/x', 'ecdsa/signature0/exponentiate_key/copy_point/y'.\n\n              // domains[16] = point^(trace_length / 4096) - trace_generator^(255 * trace_length / 256).\n\n              mstore(0x3d60,\n\n                     addmod(\n\n                       /*point^(trace_length / 4096)*/ mload(0x39c0),\n\n                       sub(PRIME, /*trace_generator^(255 * trace_length / 256)*/ mload(0x3aa0)),\n\n                       PRIME))\n\n\n\n              // Denominator for constraints: 'ecdsa/signature0/exponentiate_generator/booleanity_test', 'ecdsa/signature0/exponentiate_generator/add_points/slope', 'ecdsa/signature0/exponentiate_generator/add_points/x', 'ecdsa/signature0/exponentiate_generator/add_points/y', 'ecdsa/signature0/exponentiate_generator/add_points/x_diff_inv', 'ecdsa/signature0/exponentiate_generator/copy_point/x', 'ecdsa/signature0/exponentiate_generator/copy_point/y'.\n\n              // domains[17] = point^(trace_length / 32) - 1.\n\n              mstore(0x3d80,\n\n                     addmod(/*point^(trace_length / 32)*/ mload(0x39e0), sub(PRIME, 1), PRIME))\n\n\n\n              // Denominator for constraints: 'ecdsa/signature0/exponentiate_generator/zeros_tail'.\n\n              // Numerator for constraints: 'ecdsa/signature0/exponentiate_generator/booleanity_test', 'ecdsa/signature0/exponentiate_generator/add_points/slope', 'ecdsa/signature0/exponentiate_generator/add_points/x', 'ecdsa/signature0/exponentiate_generator/add_points/y', 'ecdsa/signature0/exponentiate_generator/add_points/x_diff_inv', 'ecdsa/signature0/exponentiate_generator/copy_point/x', 'ecdsa/signature0/exponentiate_generator/copy_point/y'.\n\n              // domains[18] = point^(trace_length / 8192) - trace_generator^(255 * trace_length / 256).\n\n              mstore(0x3da0,\n\n                     addmod(\n\n                       /*point^(trace_length / 8192)*/ mload(0x3a00),\n\n                       sub(PRIME, /*trace_generator^(255 * trace_length / 256)*/ mload(0x3aa0)),\n\n                       PRIME))\n\n\n\n              // Denominator for constraints: 'ecdsa/signature0/exponentiate_generator/bit_extraction_end'.\n\n              // domains[19] = point^(trace_length / 8192) - trace_generator^(251 * trace_length / 256).\n\n              mstore(0x3dc0,\n\n                     addmod(\n\n                       /*point^(trace_length / 8192)*/ mload(0x3a00),\n\n                       sub(PRIME, /*trace_generator^(251 * trace_length / 256)*/ mload(0x3b20)),\n\n                       PRIME))\n\n\n\n              // Denominator for constraints: 'ecdsa/signature0/exponentiate_key/bit_extraction_end'.\n\n              // domains[20] = point^(trace_length / 4096) - trace_generator^(251 * trace_length / 256).\n\n              mstore(0x3de0,\n\n                     addmod(\n\n                       /*point^(trace_length / 4096)*/ mload(0x39c0),\n\n                       sub(PRIME, /*trace_generator^(251 * trace_length / 256)*/ mload(0x3b20)),\n\n                       PRIME))\n\n\n\n              // Denominator for constraints: 'ecdsa/signature0/init_gen/x', 'ecdsa/signature0/init_gen/y', 'ecdsa/signature0/add_results/slope', 'ecdsa/signature0/add_results/x', 'ecdsa/signature0/add_results/y', 'ecdsa/signature0/add_results/x_diff_inv', 'ecdsa/signature0/extract_r/slope', 'ecdsa/signature0/extract_r/x', 'ecdsa/signature0/extract_r/x_diff_inv', 'ecdsa/signature0/z_nonzero', 'ecdsa/signature0/q_on_curve/x_squared', 'ecdsa/signature0/q_on_curve/on_curve', 'ecdsa/message_addr', 'ecdsa/pubkey_addr', 'ecdsa/message_value0', 'ecdsa/pubkey_value0'.\n\n              // domains[21] = point^(trace_length / 8192) - 1.\n\n              mstore(0x3e00,\n\n                     addmod(/*point^(trace_length / 8192)*/ mload(0x3a00), sub(PRIME, 1), PRIME))\n\n\n\n              // Denominator for constraints: 'ecdsa/signature0/init_key/x', 'ecdsa/signature0/init_key/y', 'ecdsa/signature0/r_and_w_nonzero'.\n\n              // domains[22] = point^(trace_length / 4096) - 1.\n\n              mstore(0x3e20,\n\n                     addmod(/*point^(trace_length / 4096)*/ mload(0x39c0), sub(PRIME, 1), PRIME))\n\n\n\n              // Numerator for constraints: 'ecdsa/pubkey_addr'.\n\n              // domains[23] = point - trace_generator^(8192 * (trace_length / 8192 - 1)).\n\n              mstore(0x3e40,\n\n                     addmod(\n\n                       point,\n\n                       sub(PRIME, /*trace_generator^(8192 * (trace_length / 8192 - 1))*/ mload(0x3b40)),\n\n                       PRIME))\n\n\n\n            }\n\n\n\n            {\n\n              // Prepare denominators for batch inverse.\n\n\n\n              // denominators[0] = domains[0].\n\n              mstore(0x4100, /*domains[0]*/ mload(0x3b60))\n\n\n\n              // denominators[1] = domains[1].\n\n              mstore(0x4120, /*domains[1]*/ mload(0x3b80))\n\n\n\n              // denominators[2] = domains[2].\n\n              mstore(0x4140, /*domains[2]*/ mload(0x3ba0))\n\n\n\n              // denominators[3] = domains[3].\n\n              mstore(0x4160, /*domains[3]*/ mload(0x3bc0))\n\n\n\n              // denominators[4] = domains[4].\n\n              mstore(0x4180, /*domains[4]*/ mload(0x3be0))\n\n\n\n              // denominators[5] = domains[5].\n\n              mstore(0x41a0, /*domains[5]*/ mload(0x3c00))\n\n\n\n              // denominators[6] = domains[6].\n\n              mstore(0x41c0, /*domains[6]*/ mload(0x3c20))\n\n\n\n              // denominators[7] = domains[7].\n\n              mstore(0x41e0, /*domains[7]*/ mload(0x3c40))\n\n\n\n              // denominators[8] = domains[8].\n\n              mstore(0x4200, /*domains[8]*/ mload(0x3c60))\n\n\n\n              // denominators[9] = domains[9].\n\n              mstore(0x4220, /*domains[9]*/ mload(0x3c80))\n\n\n\n              // denominators[10] = domains[10].\n\n              mstore(0x4240, /*domains[10]*/ mload(0x3ca0))\n\n\n\n              // denominators[11] = domains[11].\n\n              mstore(0x4260, /*domains[11]*/ mload(0x3cc0))\n\n\n\n              // denominators[12] = domains[13].\n\n              mstore(0x4280, /*domains[13]*/ mload(0x3d00))\n\n\n\n              // denominators[13] = domains[14].\n\n              mstore(0x42a0, /*domains[14]*/ mload(0x3d20))\n\n\n\n              // denominators[14] = domains[16].\n\n              mstore(0x42c0, /*domains[16]*/ mload(0x3d60))\n\n\n\n              // denominators[15] = domains[17].\n\n              mstore(0x42e0, /*domains[17]*/ mload(0x3d80))\n\n\n\n              // denominators[16] = domains[18].\n\n              mstore(0x4300, /*domains[18]*/ mload(0x3da0))\n\n\n\n              // denominators[17] = domains[19].\n\n              mstore(0x4320, /*domains[19]*/ mload(0x3dc0))\n\n\n\n              // denominators[18] = domains[20].\n\n              mstore(0x4340, /*domains[20]*/ mload(0x3de0))\n\n\n\n              // denominators[19] = domains[21].\n\n              mstore(0x4360, /*domains[21]*/ mload(0x3e00))\n\n\n\n              // denominators[20] = domains[22].\n\n              mstore(0x4380, /*domains[22]*/ mload(0x3e20))\n\n\n\n            }\n\n\n\n            {\n\n              // Compute the inverses of the denominators into denominatorInvs using batch inverse.\n\n\n\n              // Start by computing the cumulative product.\n\n              // Let (d_0, d_1, d_2, ..., d_{n-1}) be the values in denominators. After this loop\n\n              // denominatorInvs will be (1, d_0, d_0 * d_1, ...) and prod will contain the value of\n\n              // d_0 * ... * d_{n-1}.\n\n              // Compute the offset between the partialProducts array and the input values array.\n\n              let productsToValuesOffset := 0x2a0\n\n              let prod := 1\n\n              let partialProductEndPtr := 0x4100\n\n              for { let partialProductPtr := 0x3e60 }\n\n                  lt(partialProductPtr, partialProductEndPtr)\n\n                  { partialProductPtr := add(partialProductPtr, 0x20) } {\n\n                  mstore(partialProductPtr, prod)\n\n                  // prod *= d_{i}.\n\n                  prod := mulmod(prod,\n\n                                 mload(add(partialProductPtr, productsToValuesOffset)),\n\n                                 PRIME)\n\n              }\n\n\n\n              let firstPartialProductPtr := 0x3e60\n\n              // Compute the inverse of the product.\n\n              let prodInv := expmod(prod, sub(PRIME, 2), PRIME)\n\n\n\n              if eq(prodInv, 0) {\n\n                  // Solidity generates reverts with reason that look as follows:\n\n                  // 1. 4 bytes with the constant 0x08c379a0 (== Keccak256(b'Error(string)')[:4]).\n\n                  // 2. 32 bytes offset bytes (always 0x20 as far as i can tell).\n\n                  // 3. 32 bytes with the length of the revert reason.\n\n                  // 4. Revert reason string.\n\n\n\n                  mstore(0, 0x08c379a000000000000000000000000000000000000000000000000000000000)\n\n                  mstore(0x4, 0x20)\n\n                  mstore(0x24, 0x1e)\n\n                  mstore(0x44, \"Batch inverse product is zero.\")\n\n                  revert(0, 0x62)\n\n              }\n\n\n\n              // Compute the inverses.\n\n              // Loop over denominator_invs in reverse order.\n\n              // currentPartialProductPtr is initialized to one past the end.\n\n              let currentPartialProductPtr := 0x4100\n\n              for { } gt(currentPartialProductPtr, firstPartialProductPtr) { } {\n\n                  currentPartialProductPtr := sub(currentPartialProductPtr, 0x20)\n\n                  // Store 1/d_{i} = (d_0 * ... * d_{i-1}) * 1/(d_0 * ... * d_{i}).\n\n                  mstore(currentPartialProductPtr,\n\n                         mulmod(mload(currentPartialProductPtr), prodInv, PRIME))\n\n                  // Update prodInv to be 1/(d_0 * ... * d_{i-1}) by multiplying by d_i.\n\n                  prodInv := mulmod(prodInv,\n\n                                     mload(add(currentPartialProductPtr, productsToValuesOffset)),\n\n                                     PRIME)\n\n              }\n\n            }\n\n\n\n            {\n\n              // Compute the result of the composition polynomial.\n\n\n\n              {\n\n              // cpu/decode/opcode_rc/bit_0 = column1_row0 - (column1_row1 + column1_row1).\n\n              let val := addmod(\n\n                /*column1_row0*/ mload(0x1be0),\n\n                sub(\n\n                  PRIME,\n\n                  addmod(/*column1_row1*/ mload(0x1c00), /*column1_row1*/ mload(0x1c00), PRIME)),\n\n                PRIME)\n\n              mstore(0x3380, val)\n\n              }\n\n\n\n\n\n              {\n\n              // cpu/decode/opcode_rc/bit_2 = column1_row2 - (column1_row3 + column1_row3).\n\n              let val := addmod(\n\n                /*column1_row2*/ mload(0x1c20),\n\n                sub(\n\n                  PRIME,\n\n                  addmod(/*column1_row3*/ mload(0x1c40), /*column1_row3*/ mload(0x1c40), PRIME)),\n\n                PRIME)\n\n              mstore(0x33a0, val)\n\n              }\n\n\n\n\n\n              {\n\n              // cpu/decode/opcode_rc/bit_4 = column1_row4 - (column1_row5 + column1_row5).\n\n              let val := addmod(\n\n                /*column1_row4*/ mload(0x1c60),\n\n                sub(\n\n                  PRIME,\n\n                  addmod(/*column1_row5*/ mload(0x1c80), /*column1_row5*/ mload(0x1c80), PRIME)),\n\n                PRIME)\n\n              mstore(0x33c0, val)\n\n              }\n\n\n\n\n\n              {\n\n              // cpu/decode/opcode_rc/bit_3 = column1_row3 - (column1_row4 + column1_row4).\n\n              let val := addmod(\n\n                /*column1_row3*/ mload(0x1c40),\n\n                sub(\n\n                  PRIME,\n\n                  addmod(/*column1_row4*/ mload(0x1c60), /*column1_row4*/ mload(0x1c60), PRIME)),\n\n                PRIME)\n\n              mstore(0x33e0, val)\n\n              }\n\n\n\n\n\n              {\n\n              // cpu/decode/flag_op1_base_op0_0 = 1 - (cpu__decode__opcode_rc__bit_2 + cpu__decode__opcode_rc__bit_4 + cpu__decode__opcode_rc__bit_3).\n\n              let val := addmod(\n\n                1,\n\n                sub(\n\n                  PRIME,\n\n                  addmod(\n\n                    addmod(\n\n                      /*intermediate_value/cpu/decode/opcode_rc/bit_2*/ mload(0x33a0),\n\n                      /*intermediate_value/cpu/decode/opcode_rc/bit_4*/ mload(0x33c0),\n\n                      PRIME),\n\n                    /*intermediate_value/cpu/decode/opcode_rc/bit_3*/ mload(0x33e0),\n\n                    PRIME)),\n\n                PRIME)\n\n              mstore(0x3400, val)\n\n              }\n\n\n\n\n\n              {\n\n              // cpu/decode/opcode_rc/bit_5 = column1_row5 - (column1_row6 + column1_row6).\n\n              let val := addmod(\n\n                /*column1_row5*/ mload(0x1c80),\n\n                sub(\n\n                  PRIME,\n\n                  addmod(/*column1_row6*/ mload(0x1ca0), /*column1_row6*/ mload(0x1ca0), PRIME)),\n\n                PRIME)\n\n              mstore(0x3420, val)\n\n              }\n\n\n\n\n\n              {\n\n              // cpu/decode/opcode_rc/bit_6 = column1_row6 - (column1_row7 + column1_row7).\n\n              let val := addmod(\n\n                /*column1_row6*/ mload(0x1ca0),\n\n                sub(\n\n                  PRIME,\n\n                  addmod(/*column1_row7*/ mload(0x1cc0), /*column1_row7*/ mload(0x1cc0), PRIME)),\n\n                PRIME)\n\n              mstore(0x3440, val)\n\n              }\n\n\n\n\n\n              {\n\n              // cpu/decode/opcode_rc/bit_9 = column1_row9 - (column1_row10 + column1_row10).\n\n              let val := addmod(\n\n                /*column1_row9*/ mload(0x1d00),\n\n                sub(\n\n                  PRIME,\n\n                  addmod(/*column1_row10*/ mload(0x1d20), /*column1_row10*/ mload(0x1d20), PRIME)),\n\n                PRIME)\n\n              mstore(0x3460, val)\n\n              }\n\n\n\n\n\n              {\n\n              // cpu/decode/flag_res_op1_0 = 1 - (cpu__decode__opcode_rc__bit_5 + cpu__decode__opcode_rc__bit_6 + cpu__decode__opcode_rc__bit_9).\n\n              let val := addmod(\n\n                1,\n\n                sub(\n\n                  PRIME,\n\n                  addmod(\n\n                    addmod(\n\n                      /*intermediate_value/cpu/decode/opcode_rc/bit_5*/ mload(0x3420),\n\n                      /*intermediate_value/cpu/decode/opcode_rc/bit_6*/ mload(0x3440),\n\n                      PRIME),\n\n                    /*intermediate_value/cpu/decode/opcode_rc/bit_9*/ mload(0x3460),\n\n                    PRIME)),\n\n                PRIME)\n\n              mstore(0x3480, val)\n\n              }\n\n\n\n\n\n              {\n\n              // cpu/decode/opcode_rc/bit_7 = column1_row7 - (column1_row8 + column1_row8).\n\n              let val := addmod(\n\n                /*column1_row7*/ mload(0x1cc0),\n\n                sub(\n\n                  PRIME,\n\n                  addmod(/*column1_row8*/ mload(0x1ce0), /*column1_row8*/ mload(0x1ce0), PRIME)),\n\n                PRIME)\n\n              mstore(0x34a0, val)\n\n              }\n\n\n\n\n\n              {\n\n              // cpu/decode/opcode_rc/bit_8 = column1_row8 - (column1_row9 + column1_row9).\n\n              let val := addmod(\n\n                /*column1_row8*/ mload(0x1ce0),\n\n                sub(\n\n                  PRIME,\n\n                  addmod(/*column1_row9*/ mload(0x1d00), /*column1_row9*/ mload(0x1d00), PRIME)),\n\n                PRIME)\n\n              mstore(0x34c0, val)\n\n              }\n\n\n\n\n\n              {\n\n              // cpu/decode/flag_pc_update_regular_0 = 1 - (cpu__decode__opcode_rc__bit_7 + cpu__decode__opcode_rc__bit_8 + cpu__decode__opcode_rc__bit_9).\n\n              let val := addmod(\n\n                1,\n\n                sub(\n\n                  PRIME,\n\n                  addmod(\n\n                    addmod(\n\n                      /*intermediate_value/cpu/decode/opcode_rc/bit_7*/ mload(0x34a0),\n\n                      /*intermediate_value/cpu/decode/opcode_rc/bit_8*/ mload(0x34c0),\n\n                      PRIME),\n\n                    /*intermediate_value/cpu/decode/opcode_rc/bit_9*/ mload(0x3460),\n\n                    PRIME)),\n\n                PRIME)\n\n              mstore(0x34e0, val)\n\n              }\n\n\n\n\n\n              {\n\n              // cpu/decode/opcode_rc/bit_12 = column1_row12 - (column1_row13 + column1_row13).\n\n              let val := addmod(\n\n                /*column1_row12*/ mload(0x1d60),\n\n                sub(\n\n                  PRIME,\n\n                  addmod(/*column1_row13*/ mload(0x1d80), /*column1_row13*/ mload(0x1d80), PRIME)),\n\n                PRIME)\n\n              mstore(0x3500, val)\n\n              }\n\n\n\n\n\n              {\n\n              // cpu/decode/opcode_rc/bit_13 = column1_row13 - (column1_row14 + column1_row14).\n\n              let val := addmod(\n\n                /*column1_row13*/ mload(0x1d80),\n\n                sub(\n\n                  PRIME,\n\n                  addmod(/*column1_row14*/ mload(0x1da0), /*column1_row14*/ mload(0x1da0), PRIME)),\n\n                PRIME)\n\n              mstore(0x3520, val)\n\n              }\n\n\n\n\n\n              {\n\n              // cpu/decode/fp_update_regular_0 = 1 - (cpu__decode__opcode_rc__bit_12 + cpu__decode__opcode_rc__bit_13).\n\n              let val := addmod(\n\n                1,\n\n                sub(\n\n                  PRIME,\n\n                  addmod(\n\n                    /*intermediate_value/cpu/decode/opcode_rc/bit_12*/ mload(0x3500),\n\n                    /*intermediate_value/cpu/decode/opcode_rc/bit_13*/ mload(0x3520),\n\n                    PRIME)),\n\n                PRIME)\n\n              mstore(0x3540, val)\n\n              }\n\n\n\n\n\n              {\n\n              // cpu/decode/opcode_rc/bit_1 = column1_row1 - (column1_row2 + column1_row2).\n\n              let val := addmod(\n\n                /*column1_row1*/ mload(0x1c00),\n\n                sub(\n\n                  PRIME,\n\n                  addmod(/*column1_row2*/ mload(0x1c20), /*column1_row2*/ mload(0x1c20), PRIME)),\n\n                PRIME)\n\n              mstore(0x3560, val)\n\n              }\n\n\n\n\n\n              {\n\n              // npc_reg_0 = column19_row0 + cpu__decode__opcode_rc__bit_2 + 1.\n\n              let val := addmod(\n\n                addmod(\n\n                  /*column19_row0*/ mload(0x2820),\n\n                  /*intermediate_value/cpu/decode/opcode_rc/bit_2*/ mload(0x33a0),\n\n                  PRIME),\n\n                1,\n\n                PRIME)\n\n              mstore(0x3580, val)\n\n              }\n\n\n\n\n\n              {\n\n              // cpu/decode/opcode_rc/bit_10 = column1_row10 - (column1_row11 + column1_row11).\n\n              let val := addmod(\n\n                /*column1_row10*/ mload(0x1d20),\n\n                sub(\n\n                  PRIME,\n\n                  addmod(/*column1_row11*/ mload(0x1d40), /*column1_row11*/ mload(0x1d40), PRIME)),\n\n                PRIME)\n\n              mstore(0x35a0, val)\n\n              }\n\n\n\n\n\n              {\n\n              // cpu/decode/opcode_rc/bit_11 = column1_row11 - (column1_row12 + column1_row12).\n\n              let val := addmod(\n\n                /*column1_row11*/ mload(0x1d40),\n\n                sub(\n\n                  PRIME,\n\n                  addmod(/*column1_row12*/ mload(0x1d60), /*column1_row12*/ mload(0x1d60), PRIME)),\n\n                PRIME)\n\n              mstore(0x35c0, val)\n\n              }\n\n\n\n\n\n              {\n\n              // cpu/decode/opcode_rc/bit_14 = column1_row14 - (column1_row15 + column1_row15).\n\n              let val := addmod(\n\n                /*column1_row14*/ mload(0x1da0),\n\n                sub(\n\n                  PRIME,\n\n                  addmod(/*column1_row15*/ mload(0x1dc0), /*column1_row15*/ mload(0x1dc0), PRIME)),\n\n                PRIME)\n\n              mstore(0x35e0, val)\n\n              }\n\n\n\n\n\n              {\n\n              // memory/address_diff_0 = column20_row2 - column20_row0.\n\n              let val := addmod(/*column20_row2*/ mload(0x2cc0), sub(PRIME, /*column20_row0*/ mload(0x2c80)), PRIME)\n\n              mstore(0x3600, val)\n\n              }\n\n\n\n\n\n              {\n\n              // rc16/diff_0 = column2_row1 - column2_row0.\n\n              let val := addmod(/*column2_row1*/ mload(0x1e00), sub(PRIME, /*column2_row0*/ mload(0x1de0)), PRIME)\n\n              mstore(0x3620, val)\n\n              }\n\n\n\n\n\n              {\n\n              // pedersen/hash0/ec_subset_sum/bit_0 = column5_row0 - (column5_row1 + column5_row1).\n\n              let val := addmod(\n\n                /*column5_row0*/ mload(0x1f40),\n\n                sub(\n\n                  PRIME,\n\n                  addmod(/*column5_row1*/ mload(0x1f60), /*column5_row1*/ mload(0x1f60), PRIME)),\n\n                PRIME)\n\n              mstore(0x3640, val)\n\n              }\n\n\n\n\n\n              {\n\n              // pedersen/hash0/ec_subset_sum/bit_neg_0 = 1 - pedersen__hash0__ec_subset_sum__bit_0.\n\n              let val := addmod(\n\n                1,\n\n                sub(PRIME, /*intermediate_value/pedersen/hash0/ec_subset_sum/bit_0*/ mload(0x3640)),\n\n                PRIME)\n\n              mstore(0x3660, val)\n\n              }\n\n\n\n\n\n              {\n\n              // pedersen/hash1/ec_subset_sum/bit_0 = column8_row0 - (column8_row1 + column8_row1).\n\n              let val := addmod(\n\n                /*column8_row0*/ mload(0x2180),\n\n                sub(\n\n                  PRIME,\n\n                  addmod(/*column8_row1*/ mload(0x21a0), /*column8_row1*/ mload(0x21a0), PRIME)),\n\n                PRIME)\n\n              mstore(0x3680, val)\n\n              }\n\n\n\n\n\n              {\n\n              // pedersen/hash1/ec_subset_sum/bit_neg_0 = 1 - pedersen__hash1__ec_subset_sum__bit_0.\n\n              let val := addmod(\n\n                1,\n\n                sub(PRIME, /*intermediate_value/pedersen/hash1/ec_subset_sum/bit_0*/ mload(0x3680)),\n\n                PRIME)\n\n              mstore(0x36a0, val)\n\n              }\n\n\n\n\n\n              {\n\n              // pedersen/hash2/ec_subset_sum/bit_0 = column11_row0 - (column11_row1 + column11_row1).\n\n              let val := addmod(\n\n                /*column11_row0*/ mload(0x23c0),\n\n                sub(\n\n                  PRIME,\n\n                  addmod(/*column11_row1*/ mload(0x23e0), /*column11_row1*/ mload(0x23e0), PRIME)),\n\n                PRIME)\n\n              mstore(0x36c0, val)\n\n              }\n\n\n\n\n\n              {\n\n              // pedersen/hash2/ec_subset_sum/bit_neg_0 = 1 - pedersen__hash2__ec_subset_sum__bit_0.\n\n              let val := addmod(\n\n                1,\n\n                sub(PRIME, /*intermediate_value/pedersen/hash2/ec_subset_sum/bit_0*/ mload(0x36c0)),\n\n                PRIME)\n\n              mstore(0x36e0, val)\n\n              }\n\n\n\n\n\n              {\n\n              // pedersen/hash3/ec_subset_sum/bit_0 = column14_row0 - (column14_row1 + column14_row1).\n\n              let val := addmod(\n\n                /*column14_row0*/ mload(0x2600),\n\n                sub(\n\n                  PRIME,\n\n                  addmod(/*column14_row1*/ mload(0x2620), /*column14_row1*/ mload(0x2620), PRIME)),\n\n                PRIME)\n\n              mstore(0x3700, val)\n\n              }\n\n\n\n\n\n              {\n\n              // pedersen/hash3/ec_subset_sum/bit_neg_0 = 1 - pedersen__hash3__ec_subset_sum__bit_0.\n\n              let val := addmod(\n\n                1,\n\n                sub(PRIME, /*intermediate_value/pedersen/hash3/ec_subset_sum/bit_0*/ mload(0x3700)),\n\n                PRIME)\n\n              mstore(0x3720, val)\n\n              }\n\n\n\n\n\n              {\n\n              // rc_builtin/value0_0 = column0_row12.\n\n              let val := /*column0_row12*/ mload(0x1ae0)\n\n              mstore(0x3740, val)\n\n              }\n\n\n\n\n\n              {\n\n              // rc_builtin/value1_0 = rc_builtin__value0_0 * offset_size + column0_row28.\n\n              let val := addmod(\n\n                mulmod(\n\n                  /*intermediate_value/rc_builtin/value0_0*/ mload(0x3740),\n\n                  /*offset_size*/ mload(0xa0),\n\n                  PRIME),\n\n                /*column0_row28*/ mload(0x1b00),\n\n                PRIME)\n\n              mstore(0x3760, val)\n\n              }\n\n\n\n\n\n              {\n\n              // rc_builtin/value2_0 = rc_builtin__value1_0 * offset_size + column0_row44.\n\n              let val := addmod(\n\n                mulmod(\n\n                  /*intermediate_value/rc_builtin/value1_0*/ mload(0x3760),\n\n                  /*offset_size*/ mload(0xa0),\n\n                  PRIME),\n\n                /*column0_row44*/ mload(0x1b20),\n\n                PRIME)\n\n              mstore(0x3780, val)\n\n              }\n\n\n\n\n\n              {\n\n              // rc_builtin/value3_0 = rc_builtin__value2_0 * offset_size + column0_row60.\n\n              let val := addmod(\n\n                mulmod(\n\n                  /*intermediate_value/rc_builtin/value2_0*/ mload(0x3780),\n\n                  /*offset_size*/ mload(0xa0),\n\n                  PRIME),\n\n                /*column0_row60*/ mload(0x1b40),\n\n                PRIME)\n\n              mstore(0x37a0, val)\n\n              }\n\n\n\n\n\n              {\n\n              // rc_builtin/value4_0 = rc_builtin__value3_0 * offset_size + column0_row76.\n\n              let val := addmod(\n\n                mulmod(\n\n                  /*intermediate_value/rc_builtin/value3_0*/ mload(0x37a0),\n\n                  /*offset_size*/ mload(0xa0),\n\n                  PRIME),\n\n                /*column0_row76*/ mload(0x1b60),\n\n                PRIME)\n\n              mstore(0x37c0, val)\n\n              }\n\n\n\n\n\n              {\n\n              // rc_builtin/value5_0 = rc_builtin__value4_0 * offset_size + column0_row92.\n\n              let val := addmod(\n\n                mulmod(\n\n                  /*intermediate_value/rc_builtin/value4_0*/ mload(0x37c0),\n\n                  /*offset_size*/ mload(0xa0),\n\n                  PRIME),\n\n                /*column0_row92*/ mload(0x1b80),\n\n                PRIME)\n\n              mstore(0x37e0, val)\n\n              }\n\n\n\n\n\n              {\n\n              // rc_builtin/value6_0 = rc_builtin__value5_0 * offset_size + column0_row108.\n\n              let val := addmod(\n\n                mulmod(\n\n                  /*intermediate_value/rc_builtin/value5_0*/ mload(0x37e0),\n\n                  /*offset_size*/ mload(0xa0),\n\n                  PRIME),\n\n                /*column0_row108*/ mload(0x1ba0),\n\n                PRIME)\n\n              mstore(0x3800, val)\n\n              }\n\n\n\n\n\n              {\n\n              // rc_builtin/value7_0 = rc_builtin__value6_0 * offset_size + column0_row124.\n\n              let val := addmod(\n\n                mulmod(\n\n                  /*intermediate_value/rc_builtin/value6_0*/ mload(0x3800),\n\n                  /*offset_size*/ mload(0xa0),\n\n                  PRIME),\n\n                /*column0_row124*/ mload(0x1bc0),\n\n                PRIME)\n\n              mstore(0x3820, val)\n\n              }\n\n\n\n\n\n              {\n\n              // ecdsa/signature0/doubling_key/x_squared = column21_row6 * column21_row6.\n\n              let val := mulmod(/*column21_row6*/ mload(0x2dc0), /*column21_row6*/ mload(0x2dc0), PRIME)\n\n              mstore(0x3840, val)\n\n              }\n\n\n\n\n\n              {\n\n              // ecdsa/signature0/exponentiate_generator/bit_0 = column21_row15 - (column21_row47 + column21_row47).\n\n              let val := addmod(\n\n                /*column21_row15*/ mload(0x2ee0),\n\n                sub(\n\n                  PRIME,\n\n                  addmod(/*column21_row47*/ mload(0x3040), /*column21_row47*/ mload(0x3040), PRIME)),\n\n                PRIME)\n\n              mstore(0x3860, val)\n\n              }\n\n\n\n\n\n              {\n\n              // ecdsa/signature0/exponentiate_generator/bit_neg_0 = 1 - ecdsa__signature0__exponentiate_generator__bit_0.\n\n              let val := addmod(\n\n                1,\n\n                sub(\n\n                  PRIME,\n\n                  /*intermediate_value/ecdsa/signature0/exponentiate_generator/bit_0*/ mload(0x3860)),\n\n                PRIME)\n\n              mstore(0x3880, val)\n\n              }\n\n\n\n\n\n              {\n\n              // ecdsa/signature0/exponentiate_key/bit_0 = column21_row5 - (column21_row21 + column21_row21).\n\n              let val := addmod(\n\n                /*column21_row5*/ mload(0x2da0),\n\n                sub(\n\n                  PRIME,\n\n                  addmod(/*column21_row21*/ mload(0x2f40), /*column21_row21*/ mload(0x2f40), PRIME)),\n\n                PRIME)\n\n              mstore(0x38a0, val)\n\n              }\n\n\n\n\n\n              {\n\n              // ecdsa/signature0/exponentiate_key/bit_neg_0 = 1 - ecdsa__signature0__exponentiate_key__bit_0.\n\n              let val := addmod(\n\n                1,\n\n                sub(\n\n                  PRIME,\n\n                  /*intermediate_value/ecdsa/signature0/exponentiate_key/bit_0*/ mload(0x38a0)),\n\n                PRIME)\n\n              mstore(0x38c0, val)\n\n              }\n\n\n\n\n\n              {\n\n              // Constraint expression for cpu/decode/opcode_rc/bit: cpu__decode__opcode_rc__bit_0 * cpu__decode__opcode_rc__bit_0 - cpu__decode__opcode_rc__bit_0.\n\n              let val := addmod(\n\n                mulmod(\n\n                  /*intermediate_value/cpu/decode/opcode_rc/bit_0*/ mload(0x3380),\n\n                  /*intermediate_value/cpu/decode/opcode_rc/bit_0*/ mload(0x3380),\n\n                  PRIME),\n\n                sub(PRIME, /*intermediate_value/cpu/decode/opcode_rc/bit_0*/ mload(0x3380)),\n\n                PRIME)\n\n\n\n              // Numerator: point^(trace_length / 16) - trace_generator^(15 * trace_length / 16).\n\n              // val *= domains[1].\n\n              val := mulmod(val, /*domains[1]*/ mload(0x3b80), PRIME)\n\n              // Denominator: point^trace_length - 1.\n\n              // val *= denominator_invs[0].\n\n              val := mulmod(val, /*denominator_invs[0]*/ mload(0x3e60), PRIME)\n\n\n\n              // res += val * coefficients[0].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[0]*/ mload(0x400), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for cpu/decode/opcode_rc/zero: column1_row0.\n\n              let val := /*column1_row0*/ mload(0x1be0)\n\n\n\n              // Numerator: 1.\n\n              // val *= 1.\n\n              // Denominator: point^(trace_length / 16) - trace_generator^(15 * trace_length / 16).\n\n              // val *= denominator_invs[1].\n\n              val := mulmod(val, /*denominator_invs[1]*/ mload(0x3e80), PRIME)\n\n\n\n              // res += val * coefficients[1].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[1]*/ mload(0x420), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for cpu/decode/opcode_rc_input: column19_row1 - (((column1_row0 * offset_size + column0_row4) * offset_size + column0_row8) * offset_size + column0_row0).\n\n              let val := addmod(\n\n                /*column19_row1*/ mload(0x2840),\n\n                sub(\n\n                  PRIME,\n\n                  addmod(\n\n                    mulmod(\n\n                      addmod(\n\n                        mulmod(\n\n                          addmod(\n\n                            mulmod(/*column1_row0*/ mload(0x1be0), /*offset_size*/ mload(0xa0), PRIME),\n\n                            /*column0_row4*/ mload(0x1aa0),\n\n                            PRIME),\n\n                          /*offset_size*/ mload(0xa0),\n\n                          PRIME),\n\n                        /*column0_row8*/ mload(0x1ac0),\n\n                        PRIME),\n\n                      /*offset_size*/ mload(0xa0),\n\n                      PRIME),\n\n                    /*column0_row0*/ mload(0x1a60),\n\n                    PRIME)),\n\n                PRIME)\n\n\n\n              // Numerator: 1.\n\n              // val *= 1.\n\n              // Denominator: point^(trace_length / 16) - 1.\n\n              // val *= denominator_invs[2].\n\n              val := mulmod(val, /*denominator_invs[2]*/ mload(0x3ea0), PRIME)\n\n\n\n              // res += val * coefficients[2].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[2]*/ mload(0x440), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for cpu/decode/flag_op1_base_op0_bit: cpu__decode__flag_op1_base_op0_0 * cpu__decode__flag_op1_base_op0_0 - cpu__decode__flag_op1_base_op0_0.\n\n              let val := addmod(\n\n                mulmod(\n\n                  /*intermediate_value/cpu/decode/flag_op1_base_op0_0*/ mload(0x3400),\n\n                  /*intermediate_value/cpu/decode/flag_op1_base_op0_0*/ mload(0x3400),\n\n                  PRIME),\n\n                sub(PRIME, /*intermediate_value/cpu/decode/flag_op1_base_op0_0*/ mload(0x3400)),\n\n                PRIME)\n\n\n\n              // Numerator: 1.\n\n              // val *= 1.\n\n              // Denominator: point^(trace_length / 16) - 1.\n\n              // val *= denominator_invs[2].\n\n              val := mulmod(val, /*denominator_invs[2]*/ mload(0x3ea0), PRIME)\n\n\n\n              // res += val * coefficients[3].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[3]*/ mload(0x460), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for cpu/decode/flag_res_op1_bit: cpu__decode__flag_res_op1_0 * cpu__decode__flag_res_op1_0 - cpu__decode__flag_res_op1_0.\n\n              let val := addmod(\n\n                mulmod(\n\n                  /*intermediate_value/cpu/decode/flag_res_op1_0*/ mload(0x3480),\n\n                  /*intermediate_value/cpu/decode/flag_res_op1_0*/ mload(0x3480),\n\n                  PRIME),\n\n                sub(PRIME, /*intermediate_value/cpu/decode/flag_res_op1_0*/ mload(0x3480)),\n\n                PRIME)\n\n\n\n              // Numerator: 1.\n\n              // val *= 1.\n\n              // Denominator: point^(trace_length / 16) - 1.\n\n              // val *= denominator_invs[2].\n\n              val := mulmod(val, /*denominator_invs[2]*/ mload(0x3ea0), PRIME)\n\n\n\n              // res += val * coefficients[4].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[4]*/ mload(0x480), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for cpu/decode/flag_pc_update_regular_bit: cpu__decode__flag_pc_update_regular_0 * cpu__decode__flag_pc_update_regular_0 - cpu__decode__flag_pc_update_regular_0.\n\n              let val := addmod(\n\n                mulmod(\n\n                  /*intermediate_value/cpu/decode/flag_pc_update_regular_0*/ mload(0x34e0),\n\n                  /*intermediate_value/cpu/decode/flag_pc_update_regular_0*/ mload(0x34e0),\n\n                  PRIME),\n\n                sub(PRIME, /*intermediate_value/cpu/decode/flag_pc_update_regular_0*/ mload(0x34e0)),\n\n                PRIME)\n\n\n\n              // Numerator: 1.\n\n              // val *= 1.\n\n              // Denominator: point^(trace_length / 16) - 1.\n\n              // val *= denominator_invs[2].\n\n              val := mulmod(val, /*denominator_invs[2]*/ mload(0x3ea0), PRIME)\n\n\n\n              // res += val * coefficients[5].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[5]*/ mload(0x4a0), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for cpu/decode/fp_update_regular_bit: cpu__decode__fp_update_regular_0 * cpu__decode__fp_update_regular_0 - cpu__decode__fp_update_regular_0.\n\n              let val := addmod(\n\n                mulmod(\n\n                  /*intermediate_value/cpu/decode/fp_update_regular_0*/ mload(0x3540),\n\n                  /*intermediate_value/cpu/decode/fp_update_regular_0*/ mload(0x3540),\n\n                  PRIME),\n\n                sub(PRIME, /*intermediate_value/cpu/decode/fp_update_regular_0*/ mload(0x3540)),\n\n                PRIME)\n\n\n\n              // Numerator: 1.\n\n              // val *= 1.\n\n              // Denominator: point^(trace_length / 16) - 1.\n\n              // val *= denominator_invs[2].\n\n              val := mulmod(val, /*denominator_invs[2]*/ mload(0x3ea0), PRIME)\n\n\n\n              // res += val * coefficients[6].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[6]*/ mload(0x4c0), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for cpu/operands/mem_dst_addr: column19_row8 + half_offset_size - (cpu__decode__opcode_rc__bit_0 * column21_row8 + (1 - cpu__decode__opcode_rc__bit_0) * column21_row0 + column0_row0).\n\n              let val := addmod(\n\n                addmod(/*column19_row8*/ mload(0x2920), /*half_offset_size*/ mload(0xc0), PRIME),\n\n                sub(\n\n                  PRIME,\n\n                  addmod(\n\n                    addmod(\n\n                      mulmod(\n\n                        /*intermediate_value/cpu/decode/opcode_rc/bit_0*/ mload(0x3380),\n\n                        /*column21_row8*/ mload(0x2e00),\n\n                        PRIME),\n\n                      mulmod(\n\n                        addmod(\n\n                          1,\n\n                          sub(PRIME, /*intermediate_value/cpu/decode/opcode_rc/bit_0*/ mload(0x3380)),\n\n                          PRIME),\n\n                        /*column21_row0*/ mload(0x2d00),\n\n                        PRIME),\n\n                      PRIME),\n\n                    /*column0_row0*/ mload(0x1a60),\n\n                    PRIME)),\n\n                PRIME)\n\n\n\n              // Numerator: 1.\n\n              // val *= 1.\n\n              // Denominator: point^(trace_length / 16) - 1.\n\n              // val *= denominator_invs[2].\n\n              val := mulmod(val, /*denominator_invs[2]*/ mload(0x3ea0), PRIME)\n\n\n\n              // res += val * coefficients[7].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[7]*/ mload(0x4e0), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for cpu/operands/mem0_addr: column19_row4 + half_offset_size - (cpu__decode__opcode_rc__bit_1 * column21_row8 + (1 - cpu__decode__opcode_rc__bit_1) * column21_row0 + column0_row8).\n\n              let val := addmod(\n\n                addmod(/*column19_row4*/ mload(0x28a0), /*half_offset_size*/ mload(0xc0), PRIME),\n\n                sub(\n\n                  PRIME,\n\n                  addmod(\n\n                    addmod(\n\n                      mulmod(\n\n                        /*intermediate_value/cpu/decode/opcode_rc/bit_1*/ mload(0x3560),\n\n                        /*column21_row8*/ mload(0x2e00),\n\n                        PRIME),\n\n                      mulmod(\n\n                        addmod(\n\n                          1,\n\n                          sub(PRIME, /*intermediate_value/cpu/decode/opcode_rc/bit_1*/ mload(0x3560)),\n\n                          PRIME),\n\n                        /*column21_row0*/ mload(0x2d00),\n\n                        PRIME),\n\n                      PRIME),\n\n                    /*column0_row8*/ mload(0x1ac0),\n\n                    PRIME)),\n\n                PRIME)\n\n\n\n              // Numerator: 1.\n\n              // val *= 1.\n\n              // Denominator: point^(trace_length / 16) - 1.\n\n              // val *= denominator_invs[2].\n\n              val := mulmod(val, /*denominator_invs[2]*/ mload(0x3ea0), PRIME)\n\n\n\n              // res += val * coefficients[8].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[8]*/ mload(0x500), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for cpu/operands/mem1_addr: column19_row12 + half_offset_size - (cpu__decode__opcode_rc__bit_2 * column19_row0 + cpu__decode__opcode_rc__bit_4 * column21_row0 + cpu__decode__opcode_rc__bit_3 * column21_row8 + cpu__decode__flag_op1_base_op0_0 * column19_row5 + column0_row4).\n\n              let val := addmod(\n\n                addmod(/*column19_row12*/ mload(0x2960), /*half_offset_size*/ mload(0xc0), PRIME),\n\n                sub(\n\n                  PRIME,\n\n                  addmod(\n\n                    addmod(\n\n                      addmod(\n\n                        addmod(\n\n                          mulmod(\n\n                            /*intermediate_value/cpu/decode/opcode_rc/bit_2*/ mload(0x33a0),\n\n                            /*column19_row0*/ mload(0x2820),\n\n                            PRIME),\n\n                          mulmod(\n\n                            /*intermediate_value/cpu/decode/opcode_rc/bit_4*/ mload(0x33c0),\n\n                            /*column21_row0*/ mload(0x2d00),\n\n                            PRIME),\n\n                          PRIME),\n\n                        mulmod(\n\n                          /*intermediate_value/cpu/decode/opcode_rc/bit_3*/ mload(0x33e0),\n\n                          /*column21_row8*/ mload(0x2e00),\n\n                          PRIME),\n\n                        PRIME),\n\n                      mulmod(\n\n                        /*intermediate_value/cpu/decode/flag_op1_base_op0_0*/ mload(0x3400),\n\n                        /*column19_row5*/ mload(0x28c0),\n\n                        PRIME),\n\n                      PRIME),\n\n                    /*column0_row4*/ mload(0x1aa0),\n\n                    PRIME)),\n\n                PRIME)\n\n\n\n              // Numerator: 1.\n\n              // val *= 1.\n\n              // Denominator: point^(trace_length / 16) - 1.\n\n              // val *= denominator_invs[2].\n\n              val := mulmod(val, /*denominator_invs[2]*/ mload(0x3ea0), PRIME)\n\n\n\n              // res += val * coefficients[9].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[9]*/ mload(0x520), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for cpu/operands/ops_mul: column21_row4 - column19_row5 * column19_row13.\n\n              let val := addmod(\n\n                /*column21_row4*/ mload(0x2d80),\n\n                sub(\n\n                  PRIME,\n\n                  mulmod(/*column19_row5*/ mload(0x28c0), /*column19_row13*/ mload(0x2980), PRIME)),\n\n                PRIME)\n\n\n\n              // Numerator: 1.\n\n              // val *= 1.\n\n              // Denominator: point^(trace_length / 16) - 1.\n\n              // val *= denominator_invs[2].\n\n              val := mulmod(val, /*denominator_invs[2]*/ mload(0x3ea0), PRIME)\n\n\n\n              // res += val * coefficients[10].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[10]*/ mload(0x540), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for cpu/operands/res: (1 - cpu__decode__opcode_rc__bit_9) * column21_row12 - (cpu__decode__opcode_rc__bit_5 * (column19_row5 + column19_row13) + cpu__decode__opcode_rc__bit_6 * column21_row4 + cpu__decode__flag_res_op1_0 * column19_row13).\n\n              let val := addmod(\n\n                mulmod(\n\n                  addmod(\n\n                    1,\n\n                    sub(PRIME, /*intermediate_value/cpu/decode/opcode_rc/bit_9*/ mload(0x3460)),\n\n                    PRIME),\n\n                  /*column21_row12*/ mload(0x2e80),\n\n                  PRIME),\n\n                sub(\n\n                  PRIME,\n\n                  addmod(\n\n                    addmod(\n\n                      mulmod(\n\n                        /*intermediate_value/cpu/decode/opcode_rc/bit_5*/ mload(0x3420),\n\n                        addmod(/*column19_row5*/ mload(0x28c0), /*column19_row13*/ mload(0x2980), PRIME),\n\n                        PRIME),\n\n                      mulmod(\n\n                        /*intermediate_value/cpu/decode/opcode_rc/bit_6*/ mload(0x3440),\n\n                        /*column21_row4*/ mload(0x2d80),\n\n                        PRIME),\n\n                      PRIME),\n\n                    mulmod(\n\n                      /*intermediate_value/cpu/decode/flag_res_op1_0*/ mload(0x3480),\n\n                      /*column19_row13*/ mload(0x2980),\n\n                      PRIME),\n\n                    PRIME)),\n\n                PRIME)\n\n\n\n              // Numerator: 1.\n\n              // val *= 1.\n\n              // Denominator: point^(trace_length / 16) - 1.\n\n              // val *= denominator_invs[2].\n\n              val := mulmod(val, /*denominator_invs[2]*/ mload(0x3ea0), PRIME)\n\n\n\n              // res += val * coefficients[11].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[11]*/ mload(0x560), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for cpu/update_registers/update_pc/tmp0: column21_row2 - cpu__decode__opcode_rc__bit_9 * column19_row9.\n\n              let val := addmod(\n\n                /*column21_row2*/ mload(0x2d40),\n\n                sub(\n\n                  PRIME,\n\n                  mulmod(\n\n                    /*intermediate_value/cpu/decode/opcode_rc/bit_9*/ mload(0x3460),\n\n                    /*column19_row9*/ mload(0x2940),\n\n                    PRIME)),\n\n                PRIME)\n\n\n\n              // Numerator: point - trace_generator^(16 * (trace_length / 16 - 1)).\n\n              // val *= domains[3].\n\n              val := mulmod(val, /*domains[3]*/ mload(0x3bc0), PRIME)\n\n              // Denominator: point^(trace_length / 16) - 1.\n\n              // val *= denominator_invs[2].\n\n              val := mulmod(val, /*denominator_invs[2]*/ mload(0x3ea0), PRIME)\n\n\n\n              // res += val * coefficients[12].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[12]*/ mload(0x580), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for cpu/update_registers/update_pc/tmp1: column21_row10 - column21_row2 * column21_row12.\n\n              let val := addmod(\n\n                /*column21_row10*/ mload(0x2e40),\n\n                sub(\n\n                  PRIME,\n\n                  mulmod(/*column21_row2*/ mload(0x2d40), /*column21_row12*/ mload(0x2e80), PRIME)),\n\n                PRIME)\n\n\n\n              // Numerator: point - trace_generator^(16 * (trace_length / 16 - 1)).\n\n              // val *= domains[3].\n\n              val := mulmod(val, /*domains[3]*/ mload(0x3bc0), PRIME)\n\n              // Denominator: point^(trace_length / 16) - 1.\n\n              // val *= denominator_invs[2].\n\n              val := mulmod(val, /*denominator_invs[2]*/ mload(0x3ea0), PRIME)\n\n\n\n              // res += val * coefficients[13].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[13]*/ mload(0x5a0), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for cpu/update_registers/update_pc/pc_cond_negative: (1 - cpu__decode__opcode_rc__bit_9) * column19_row16 + column21_row2 * (column19_row16 - (column19_row0 + column19_row13)) - (cpu__decode__flag_pc_update_regular_0 * npc_reg_0 + cpu__decode__opcode_rc__bit_7 * column21_row12 + cpu__decode__opcode_rc__bit_8 * (column19_row0 + column21_row12)).\n\n              let val := addmod(\n\n                addmod(\n\n                  mulmod(\n\n                    addmod(\n\n                      1,\n\n                      sub(PRIME, /*intermediate_value/cpu/decode/opcode_rc/bit_9*/ mload(0x3460)),\n\n                      PRIME),\n\n                    /*column19_row16*/ mload(0x29a0),\n\n                    PRIME),\n\n                  mulmod(\n\n                    /*column21_row2*/ mload(0x2d40),\n\n                    addmod(\n\n                      /*column19_row16*/ mload(0x29a0),\n\n                      sub(\n\n                        PRIME,\n\n                        addmod(/*column19_row0*/ mload(0x2820), /*column19_row13*/ mload(0x2980), PRIME)),\n\n                      PRIME),\n\n                    PRIME),\n\n                  PRIME),\n\n                sub(\n\n                  PRIME,\n\n                  addmod(\n\n                    addmod(\n\n                      mulmod(\n\n                        /*intermediate_value/cpu/decode/flag_pc_update_regular_0*/ mload(0x34e0),\n\n                        /*intermediate_value/npc_reg_0*/ mload(0x3580),\n\n                        PRIME),\n\n                      mulmod(\n\n                        /*intermediate_value/cpu/decode/opcode_rc/bit_7*/ mload(0x34a0),\n\n                        /*column21_row12*/ mload(0x2e80),\n\n                        PRIME),\n\n                      PRIME),\n\n                    mulmod(\n\n                      /*intermediate_value/cpu/decode/opcode_rc/bit_8*/ mload(0x34c0),\n\n                      addmod(/*column19_row0*/ mload(0x2820), /*column21_row12*/ mload(0x2e80), PRIME),\n\n                      PRIME),\n\n                    PRIME)),\n\n                PRIME)\n\n\n\n              // Numerator: point - trace_generator^(16 * (trace_length / 16 - 1)).\n\n              // val *= domains[3].\n\n              val := mulmod(val, /*domains[3]*/ mload(0x3bc0), PRIME)\n\n              // Denominator: point^(trace_length / 16) - 1.\n\n              // val *= denominator_invs[2].\n\n              val := mulmod(val, /*denominator_invs[2]*/ mload(0x3ea0), PRIME)\n\n\n\n              // res += val * coefficients[14].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[14]*/ mload(0x5c0), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for cpu/update_registers/update_pc/pc_cond_positive: (column21_row10 - cpu__decode__opcode_rc__bit_9) * (column19_row16 - npc_reg_0).\n\n              let val := mulmod(\n\n                addmod(\n\n                  /*column21_row10*/ mload(0x2e40),\n\n                  sub(PRIME, /*intermediate_value/cpu/decode/opcode_rc/bit_9*/ mload(0x3460)),\n\n                  PRIME),\n\n                addmod(\n\n                  /*column19_row16*/ mload(0x29a0),\n\n                  sub(PRIME, /*intermediate_value/npc_reg_0*/ mload(0x3580)),\n\n                  PRIME),\n\n                PRIME)\n\n\n\n              // Numerator: point - trace_generator^(16 * (trace_length / 16 - 1)).\n\n              // val *= domains[3].\n\n              val := mulmod(val, /*domains[3]*/ mload(0x3bc0), PRIME)\n\n              // Denominator: point^(trace_length / 16) - 1.\n\n              // val *= denominator_invs[2].\n\n              val := mulmod(val, /*denominator_invs[2]*/ mload(0x3ea0), PRIME)\n\n\n\n              // res += val * coefficients[15].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[15]*/ mload(0x5e0), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for cpu/update_registers/update_ap/ap_update: column21_row16 - (column21_row0 + cpu__decode__opcode_rc__bit_10 * column21_row12 + cpu__decode__opcode_rc__bit_11 + cpu__decode__opcode_rc__bit_12 * 2).\n\n              let val := addmod(\n\n                /*column21_row16*/ mload(0x2f00),\n\n                sub(\n\n                  PRIME,\n\n                  addmod(\n\n                    addmod(\n\n                      addmod(\n\n                        /*column21_row0*/ mload(0x2d00),\n\n                        mulmod(\n\n                          /*intermediate_value/cpu/decode/opcode_rc/bit_10*/ mload(0x35a0),\n\n                          /*column21_row12*/ mload(0x2e80),\n\n                          PRIME),\n\n                        PRIME),\n\n                      /*intermediate_value/cpu/decode/opcode_rc/bit_11*/ mload(0x35c0),\n\n                      PRIME),\n\n                    mulmod(/*intermediate_value/cpu/decode/opcode_rc/bit_12*/ mload(0x3500), 2, PRIME),\n\n                    PRIME)),\n\n                PRIME)\n\n\n\n              // Numerator: point - trace_generator^(16 * (trace_length / 16 - 1)).\n\n              // val *= domains[3].\n\n              val := mulmod(val, /*domains[3]*/ mload(0x3bc0), PRIME)\n\n              // Denominator: point^(trace_length / 16) - 1.\n\n              // val *= denominator_invs[2].\n\n              val := mulmod(val, /*denominator_invs[2]*/ mload(0x3ea0), PRIME)\n\n\n\n              // res += val * coefficients[16].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[16]*/ mload(0x600), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for cpu/update_registers/update_fp/fp_update: column21_row24 - (cpu__decode__fp_update_regular_0 * column21_row8 + cpu__decode__opcode_rc__bit_13 * column19_row9 + cpu__decode__opcode_rc__bit_12 * (column21_row0 + 2)).\n\n              let val := addmod(\n\n                /*column21_row24*/ mload(0x2fa0),\n\n                sub(\n\n                  PRIME,\n\n                  addmod(\n\n                    addmod(\n\n                      mulmod(\n\n                        /*intermediate_value/cpu/decode/fp_update_regular_0*/ mload(0x3540),\n\n                        /*column21_row8*/ mload(0x2e00),\n\n                        PRIME),\n\n                      mulmod(\n\n                        /*intermediate_value/cpu/decode/opcode_rc/bit_13*/ mload(0x3520),\n\n                        /*column19_row9*/ mload(0x2940),\n\n                        PRIME),\n\n                      PRIME),\n\n                    mulmod(\n\n                      /*intermediate_value/cpu/decode/opcode_rc/bit_12*/ mload(0x3500),\n\n                      addmod(/*column21_row0*/ mload(0x2d00), 2, PRIME),\n\n                      PRIME),\n\n                    PRIME)),\n\n                PRIME)\n\n\n\n              // Numerator: point - trace_generator^(16 * (trace_length / 16 - 1)).\n\n              // val *= domains[3].\n\n              val := mulmod(val, /*domains[3]*/ mload(0x3bc0), PRIME)\n\n              // Denominator: point^(trace_length / 16) - 1.\n\n              // val *= denominator_invs[2].\n\n              val := mulmod(val, /*denominator_invs[2]*/ mload(0x3ea0), PRIME)\n\n\n\n              // res += val * coefficients[17].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[17]*/ mload(0x620), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for cpu/opcodes/call/push_fp: cpu__decode__opcode_rc__bit_12 * (column19_row9 - column21_row8).\n\n              let val := mulmod(\n\n                /*intermediate_value/cpu/decode/opcode_rc/bit_12*/ mload(0x3500),\n\n                addmod(/*column19_row9*/ mload(0x2940), sub(PRIME, /*column21_row8*/ mload(0x2e00)), PRIME),\n\n                PRIME)\n\n\n\n              // Numerator: 1.\n\n              // val *= 1.\n\n              // Denominator: point^(trace_length / 16) - 1.\n\n              // val *= denominator_invs[2].\n\n              val := mulmod(val, /*denominator_invs[2]*/ mload(0x3ea0), PRIME)\n\n\n\n              // res += val * coefficients[18].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[18]*/ mload(0x640), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for cpu/opcodes/call/push_pc: cpu__decode__opcode_rc__bit_12 * (column19_row5 - (column19_row0 + cpu__decode__opcode_rc__bit_2 + 1)).\n\n              let val := mulmod(\n\n                /*intermediate_value/cpu/decode/opcode_rc/bit_12*/ mload(0x3500),\n\n                addmod(\n\n                  /*column19_row5*/ mload(0x28c0),\n\n                  sub(\n\n                    PRIME,\n\n                    addmod(\n\n                      addmod(\n\n                        /*column19_row0*/ mload(0x2820),\n\n                        /*intermediate_value/cpu/decode/opcode_rc/bit_2*/ mload(0x33a0),\n\n                        PRIME),\n\n                      1,\n\n                      PRIME)),\n\n                  PRIME),\n\n                PRIME)\n\n\n\n              // Numerator: 1.\n\n              // val *= 1.\n\n              // Denominator: point^(trace_length / 16) - 1.\n\n              // val *= denominator_invs[2].\n\n              val := mulmod(val, /*denominator_invs[2]*/ mload(0x3ea0), PRIME)\n\n\n\n              // res += val * coefficients[19].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[19]*/ mload(0x660), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for cpu/opcodes/call/off0: cpu__decode__opcode_rc__bit_12 * (column0_row0 - half_offset_size).\n\n              let val := mulmod(\n\n                /*intermediate_value/cpu/decode/opcode_rc/bit_12*/ mload(0x3500),\n\n                addmod(/*column0_row0*/ mload(0x1a60), sub(PRIME, /*half_offset_size*/ mload(0xc0)), PRIME),\n\n                PRIME)\n\n\n\n              // Numerator: 1.\n\n              // val *= 1.\n\n              // Denominator: point^(trace_length / 16) - 1.\n\n              // val *= denominator_invs[2].\n\n              val := mulmod(val, /*denominator_invs[2]*/ mload(0x3ea0), PRIME)\n\n\n\n              // res += val * coefficients[20].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[20]*/ mload(0x680), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for cpu/opcodes/call/off1: cpu__decode__opcode_rc__bit_12 * (column0_row8 - (half_offset_size + 1)).\n\n              let val := mulmod(\n\n                /*intermediate_value/cpu/decode/opcode_rc/bit_12*/ mload(0x3500),\n\n                addmod(\n\n                  /*column0_row8*/ mload(0x1ac0),\n\n                  sub(PRIME, addmod(/*half_offset_size*/ mload(0xc0), 1, PRIME)),\n\n                  PRIME),\n\n                PRIME)\n\n\n\n              // Numerator: 1.\n\n              // val *= 1.\n\n              // Denominator: point^(trace_length / 16) - 1.\n\n              // val *= denominator_invs[2].\n\n              val := mulmod(val, /*denominator_invs[2]*/ mload(0x3ea0), PRIME)\n\n\n\n              // res += val * coefficients[21].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[21]*/ mload(0x6a0), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for cpu/opcodes/call/flags: cpu__decode__opcode_rc__bit_12 * (cpu__decode__opcode_rc__bit_12 + cpu__decode__opcode_rc__bit_12 + 1 + 1 - (cpu__decode__opcode_rc__bit_0 + cpu__decode__opcode_rc__bit_1 + 4)).\n\n              let val := mulmod(\n\n                /*intermediate_value/cpu/decode/opcode_rc/bit_12*/ mload(0x3500),\n\n                addmod(\n\n                  addmod(\n\n                    addmod(\n\n                      addmod(\n\n                        /*intermediate_value/cpu/decode/opcode_rc/bit_12*/ mload(0x3500),\n\n                        /*intermediate_value/cpu/decode/opcode_rc/bit_12*/ mload(0x3500),\n\n                        PRIME),\n\n                      1,\n\n                      PRIME),\n\n                    1,\n\n                    PRIME),\n\n                  sub(\n\n                    PRIME,\n\n                    addmod(\n\n                      addmod(\n\n                        /*intermediate_value/cpu/decode/opcode_rc/bit_0*/ mload(0x3380),\n\n                        /*intermediate_value/cpu/decode/opcode_rc/bit_1*/ mload(0x3560),\n\n                        PRIME),\n\n                      4,\n\n                      PRIME)),\n\n                  PRIME),\n\n                PRIME)\n\n\n\n              // Numerator: 1.\n\n              // val *= 1.\n\n              // Denominator: point^(trace_length / 16) - 1.\n\n              // val *= denominator_invs[2].\n\n              val := mulmod(val, /*denominator_invs[2]*/ mload(0x3ea0), PRIME)\n\n\n\n              // res += val * coefficients[22].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[22]*/ mload(0x6c0), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for cpu/opcodes/ret/off0: cpu__decode__opcode_rc__bit_13 * (column0_row0 + 2 - half_offset_size).\n\n              let val := mulmod(\n\n                /*intermediate_value/cpu/decode/opcode_rc/bit_13*/ mload(0x3520),\n\n                addmod(\n\n                  addmod(/*column0_row0*/ mload(0x1a60), 2, PRIME),\n\n                  sub(PRIME, /*half_offset_size*/ mload(0xc0)),\n\n                  PRIME),\n\n                PRIME)\n\n\n\n              // Numerator: 1.\n\n              // val *= 1.\n\n              // Denominator: point^(trace_length / 16) - 1.\n\n              // val *= denominator_invs[2].\n\n              val := mulmod(val, /*denominator_invs[2]*/ mload(0x3ea0), PRIME)\n\n\n\n              // res += val * coefficients[23].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[23]*/ mload(0x6e0), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for cpu/opcodes/ret/off2: cpu__decode__opcode_rc__bit_13 * (column0_row4 + 1 - half_offset_size).\n\n              let val := mulmod(\n\n                /*intermediate_value/cpu/decode/opcode_rc/bit_13*/ mload(0x3520),\n\n                addmod(\n\n                  addmod(/*column0_row4*/ mload(0x1aa0), 1, PRIME),\n\n                  sub(PRIME, /*half_offset_size*/ mload(0xc0)),\n\n                  PRIME),\n\n                PRIME)\n\n\n\n              // Numerator: 1.\n\n              // val *= 1.\n\n              // Denominator: point^(trace_length / 16) - 1.\n\n              // val *= denominator_invs[2].\n\n              val := mulmod(val, /*denominator_invs[2]*/ mload(0x3ea0), PRIME)\n\n\n\n              // res += val * coefficients[24].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[24]*/ mload(0x700), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for cpu/opcodes/ret/flags: cpu__decode__opcode_rc__bit_13 * (cpu__decode__opcode_rc__bit_7 + cpu__decode__opcode_rc__bit_0 + cpu__decode__opcode_rc__bit_3 + cpu__decode__flag_res_op1_0 - 4).\n\n              let val := mulmod(\n\n                /*intermediate_value/cpu/decode/opcode_rc/bit_13*/ mload(0x3520),\n\n                addmod(\n\n                  addmod(\n\n                    addmod(\n\n                      addmod(\n\n                        /*intermediate_value/cpu/decode/opcode_rc/bit_7*/ mload(0x34a0),\n\n                        /*intermediate_value/cpu/decode/opcode_rc/bit_0*/ mload(0x3380),\n\n                        PRIME),\n\n                      /*intermediate_value/cpu/decode/opcode_rc/bit_3*/ mload(0x33e0),\n\n                      PRIME),\n\n                    /*intermediate_value/cpu/decode/flag_res_op1_0*/ mload(0x3480),\n\n                    PRIME),\n\n                  sub(PRIME, 4),\n\n                  PRIME),\n\n                PRIME)\n\n\n\n              // Numerator: 1.\n\n              // val *= 1.\n\n              // Denominator: point^(trace_length / 16) - 1.\n\n              // val *= denominator_invs[2].\n\n              val := mulmod(val, /*denominator_invs[2]*/ mload(0x3ea0), PRIME)\n\n\n\n              // res += val * coefficients[25].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[25]*/ mload(0x720), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for cpu/opcodes/assert_eq/assert_eq: cpu__decode__opcode_rc__bit_14 * (column19_row9 - column21_row12).\n\n              let val := mulmod(\n\n                /*intermediate_value/cpu/decode/opcode_rc/bit_14*/ mload(0x35e0),\n\n                addmod(\n\n                  /*column19_row9*/ mload(0x2940),\n\n                  sub(PRIME, /*column21_row12*/ mload(0x2e80)),\n\n                  PRIME),\n\n                PRIME)\n\n\n\n              // Numerator: 1.\n\n              // val *= 1.\n\n              // Denominator: point^(trace_length / 16) - 1.\n\n              // val *= denominator_invs[2].\n\n              val := mulmod(val, /*denominator_invs[2]*/ mload(0x3ea0), PRIME)\n\n\n\n              // res += val * coefficients[26].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[26]*/ mload(0x740), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for initial_ap: column21_row0 - initial_ap.\n\n              let val := addmod(/*column21_row0*/ mload(0x2d00), sub(PRIME, /*initial_ap*/ mload(0xe0)), PRIME)\n\n\n\n              // Numerator: 1.\n\n              // val *= 1.\n\n              // Denominator: point - 1.\n\n              // val *= denominator_invs[4].\n\n              val := mulmod(val, /*denominator_invs[4]*/ mload(0x3ee0), PRIME)\n\n\n\n              // res += val * coefficients[27].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[27]*/ mload(0x760), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for initial_fp: column21_row8 - initial_ap.\n\n              let val := addmod(/*column21_row8*/ mload(0x2e00), sub(PRIME, /*initial_ap*/ mload(0xe0)), PRIME)\n\n\n\n              // Numerator: 1.\n\n              // val *= 1.\n\n              // Denominator: point - 1.\n\n              // val *= denominator_invs[4].\n\n              val := mulmod(val, /*denominator_invs[4]*/ mload(0x3ee0), PRIME)\n\n\n\n              // res += val * coefficients[28].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[28]*/ mload(0x780), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for initial_pc: column19_row0 - initial_pc.\n\n              let val := addmod(/*column19_row0*/ mload(0x2820), sub(PRIME, /*initial_pc*/ mload(0x100)), PRIME)\n\n\n\n              // Numerator: 1.\n\n              // val *= 1.\n\n              // Denominator: point - 1.\n\n              // val *= denominator_invs[4].\n\n              val := mulmod(val, /*denominator_invs[4]*/ mload(0x3ee0), PRIME)\n\n\n\n              // res += val * coefficients[29].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[29]*/ mload(0x7a0), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for final_ap: column21_row0 - final_ap.\n\n              let val := addmod(/*column21_row0*/ mload(0x2d00), sub(PRIME, /*final_ap*/ mload(0x120)), PRIME)\n\n\n\n              // Numerator: 1.\n\n              // val *= 1.\n\n              // Denominator: point - trace_generator^(16 * (trace_length / 16 - 1)).\n\n              // val *= denominator_invs[3].\n\n              val := mulmod(val, /*denominator_invs[3]*/ mload(0x3ec0), PRIME)\n\n\n\n              // res += val * coefficients[30].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[30]*/ mload(0x7c0), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for final_fp: column21_row8 - initial_ap.\n\n              let val := addmod(/*column21_row8*/ mload(0x2e00), sub(PRIME, /*initial_ap*/ mload(0xe0)), PRIME)\n\n\n\n              // Numerator: 1.\n\n              // val *= 1.\n\n              // Denominator: point - trace_generator^(16 * (trace_length / 16 - 1)).\n\n              // val *= denominator_invs[3].\n\n              val := mulmod(val, /*denominator_invs[3]*/ mload(0x3ec0), PRIME)\n\n\n\n              // res += val * coefficients[31].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[31]*/ mload(0x7e0), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for final_pc: column19_row0 - final_pc.\n\n              let val := addmod(/*column19_row0*/ mload(0x2820), sub(PRIME, /*final_pc*/ mload(0x140)), PRIME)\n\n\n\n              // Numerator: 1.\n\n              // val *= 1.\n\n              // Denominator: point - trace_generator^(16 * (trace_length / 16 - 1)).\n\n              // val *= denominator_invs[3].\n\n              val := mulmod(val, /*denominator_invs[3]*/ mload(0x3ec0), PRIME)\n\n\n\n              // res += val * coefficients[32].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[32]*/ mload(0x800), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for memory/multi_column_perm/perm/init0: (memory/multi_column_perm/perm/interaction_elm - (column20_row0 + memory/multi_column_perm/hash_interaction_elm0 * column20_row1)) * column24_inter1_row0 + column19_row0 + memory/multi_column_perm/hash_interaction_elm0 * column19_row1 - memory/multi_column_perm/perm/interaction_elm.\n\n              let val := addmod(\n\n                addmod(\n\n                  addmod(\n\n                    mulmod(\n\n                      addmod(\n\n                        /*memory/multi_column_perm/perm/interaction_elm*/ mload(0x160),\n\n                        sub(\n\n                          PRIME,\n\n                          addmod(\n\n                            /*column20_row0*/ mload(0x2c80),\n\n                            mulmod(\n\n                              /*memory/multi_column_perm/hash_interaction_elm0*/ mload(0x180),\n\n                              /*column20_row1*/ mload(0x2ca0),\n\n                              PRIME),\n\n                            PRIME)),\n\n                        PRIME),\n\n                      /*column24_inter1_row0*/ mload(0x3340),\n\n                      PRIME),\n\n                    /*column19_row0*/ mload(0x2820),\n\n                    PRIME),\n\n                  mulmod(\n\n                    /*memory/multi_column_perm/hash_interaction_elm0*/ mload(0x180),\n\n                    /*column19_row1*/ mload(0x2840),\n\n                    PRIME),\n\n                  PRIME),\n\n                sub(PRIME, /*memory/multi_column_perm/perm/interaction_elm*/ mload(0x160)),\n\n                PRIME)\n\n\n\n              // Numerator: 1.\n\n              // val *= 1.\n\n              // Denominator: point - 1.\n\n              // val *= denominator_invs[4].\n\n              val := mulmod(val, /*denominator_invs[4]*/ mload(0x3ee0), PRIME)\n\n\n\n              // res += val * coefficients[33].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[33]*/ mload(0x820), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for memory/multi_column_perm/perm/step0: (memory/multi_column_perm/perm/interaction_elm - (column20_row2 + memory/multi_column_perm/hash_interaction_elm0 * column20_row3)) * column24_inter1_row2 - (memory/multi_column_perm/perm/interaction_elm - (column19_row2 + memory/multi_column_perm/hash_interaction_elm0 * column19_row3)) * column24_inter1_row0.\n\n              let val := addmod(\n\n                mulmod(\n\n                  addmod(\n\n                    /*memory/multi_column_perm/perm/interaction_elm*/ mload(0x160),\n\n                    sub(\n\n                      PRIME,\n\n                      addmod(\n\n                        /*column20_row2*/ mload(0x2cc0),\n\n                        mulmod(\n\n                          /*memory/multi_column_perm/hash_interaction_elm0*/ mload(0x180),\n\n                          /*column20_row3*/ mload(0x2ce0),\n\n                          PRIME),\n\n                        PRIME)),\n\n                    PRIME),\n\n                  /*column24_inter1_row2*/ mload(0x3360),\n\n                  PRIME),\n\n                sub(\n\n                  PRIME,\n\n                  mulmod(\n\n                    addmod(\n\n                      /*memory/multi_column_perm/perm/interaction_elm*/ mload(0x160),\n\n                      sub(\n\n                        PRIME,\n\n                        addmod(\n\n                          /*column19_row2*/ mload(0x2860),\n\n                          mulmod(\n\n                            /*memory/multi_column_perm/hash_interaction_elm0*/ mload(0x180),\n\n                            /*column19_row3*/ mload(0x2880),\n\n                            PRIME),\n\n                          PRIME)),\n\n                      PRIME),\n\n                    /*column24_inter1_row0*/ mload(0x3340),\n\n                    PRIME)),\n\n                PRIME)\n\n\n\n              // Numerator: point - trace_generator^(2 * (trace_length / 2 - 1)).\n\n              // val *= domains[6].\n\n              val := mulmod(val, /*domains[6]*/ mload(0x3c20), PRIME)\n\n              // Denominator: point^(trace_length / 2) - 1.\n\n              // val *= denominator_invs[5].\n\n              val := mulmod(val, /*denominator_invs[5]*/ mload(0x3f00), PRIME)\n\n\n\n              // res += val * coefficients[34].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[34]*/ mload(0x840), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for memory/multi_column_perm/perm/last: column24_inter1_row0 - memory/multi_column_perm/perm/public_memory_prod.\n\n              let val := addmod(\n\n                /*column24_inter1_row0*/ mload(0x3340),\n\n                sub(PRIME, /*memory/multi_column_perm/perm/public_memory_prod*/ mload(0x1a0)),\n\n                PRIME)\n\n\n\n              // Numerator: 1.\n\n              // val *= 1.\n\n              // Denominator: point - trace_generator^(2 * (trace_length / 2 - 1)).\n\n              // val *= denominator_invs[6].\n\n              val := mulmod(val, /*denominator_invs[6]*/ mload(0x3f20), PRIME)\n\n\n\n              // res += val * coefficients[35].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[35]*/ mload(0x860), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for memory/diff_is_bit: memory__address_diff_0 * memory__address_diff_0 - memory__address_diff_0.\n\n              let val := addmod(\n\n                mulmod(\n\n                  /*intermediate_value/memory/address_diff_0*/ mload(0x3600),\n\n                  /*intermediate_value/memory/address_diff_0*/ mload(0x3600),\n\n                  PRIME),\n\n                sub(PRIME, /*intermediate_value/memory/address_diff_0*/ mload(0x3600)),\n\n                PRIME)\n\n\n\n              // Numerator: point - trace_generator^(2 * (trace_length / 2 - 1)).\n\n              // val *= domains[6].\n\n              val := mulmod(val, /*domains[6]*/ mload(0x3c20), PRIME)\n\n              // Denominator: point^(trace_length / 2) - 1.\n\n              // val *= denominator_invs[5].\n\n              val := mulmod(val, /*denominator_invs[5]*/ mload(0x3f00), PRIME)\n\n\n\n              // res += val * coefficients[36].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[36]*/ mload(0x880), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for memory/is_func: (memory__address_diff_0 - 1) * (column20_row1 - column20_row3).\n\n              let val := mulmod(\n\n                addmod(/*intermediate_value/memory/address_diff_0*/ mload(0x3600), sub(PRIME, 1), PRIME),\n\n                addmod(/*column20_row1*/ mload(0x2ca0), sub(PRIME, /*column20_row3*/ mload(0x2ce0)), PRIME),\n\n                PRIME)\n\n\n\n              // Numerator: point - trace_generator^(2 * (trace_length / 2 - 1)).\n\n              // val *= domains[6].\n\n              val := mulmod(val, /*domains[6]*/ mload(0x3c20), PRIME)\n\n              // Denominator: point^(trace_length / 2) - 1.\n\n              // val *= denominator_invs[5].\n\n              val := mulmod(val, /*denominator_invs[5]*/ mload(0x3f00), PRIME)\n\n\n\n              // res += val * coefficients[37].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[37]*/ mload(0x8a0), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for memory/initial_addr: column20_row0 - 1.\n\n              let val := addmod(/*column20_row0*/ mload(0x2c80), sub(PRIME, 1), PRIME)\n\n\n\n              // Numerator: 1.\n\n              // val *= 1.\n\n              // Denominator: point - 1.\n\n              // val *= denominator_invs[4].\n\n              val := mulmod(val, /*denominator_invs[4]*/ mload(0x3ee0), PRIME)\n\n\n\n              // res += val * coefficients[38].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[38]*/ mload(0x8c0), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for public_memory_addr_zero: column19_row2.\n\n              let val := /*column19_row2*/ mload(0x2860)\n\n\n\n              // Numerator: 1.\n\n              // val *= 1.\n\n              // Denominator: point^(trace_length / 8) - 1.\n\n              // val *= denominator_invs[7].\n\n              val := mulmod(val, /*denominator_invs[7]*/ mload(0x3f40), PRIME)\n\n\n\n              // res += val * coefficients[39].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[39]*/ mload(0x8e0), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for public_memory_value_zero: column19_row3.\n\n              let val := /*column19_row3*/ mload(0x2880)\n\n\n\n              // Numerator: 1.\n\n              // val *= 1.\n\n              // Denominator: point^(trace_length / 8) - 1.\n\n              // val *= denominator_invs[7].\n\n              val := mulmod(val, /*denominator_invs[7]*/ mload(0x3f40), PRIME)\n\n\n\n              // res += val * coefficients[40].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[40]*/ mload(0x900), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for rc16/perm/init0: (rc16/perm/interaction_elm - column2_row0) * column23_inter1_row0 + column0_row0 - rc16/perm/interaction_elm.\n\n              let val := addmod(\n\n                addmod(\n\n                  mulmod(\n\n                    addmod(\n\n                      /*rc16/perm/interaction_elm*/ mload(0x1c0),\n\n                      sub(PRIME, /*column2_row0*/ mload(0x1de0)),\n\n                      PRIME),\n\n                    /*column23_inter1_row0*/ mload(0x3300),\n\n                    PRIME),\n\n                  /*column0_row0*/ mload(0x1a60),\n\n                  PRIME),\n\n                sub(PRIME, /*rc16/perm/interaction_elm*/ mload(0x1c0)),\n\n                PRIME)\n\n\n\n              // Numerator: 1.\n\n              // val *= 1.\n\n              // Denominator: point - 1.\n\n              // val *= denominator_invs[4].\n\n              val := mulmod(val, /*denominator_invs[4]*/ mload(0x3ee0), PRIME)\n\n\n\n              // res += val * coefficients[41].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[41]*/ mload(0x920), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for rc16/perm/step0: (rc16/perm/interaction_elm - column2_row1) * column23_inter1_row1 - (rc16/perm/interaction_elm - column0_row1) * column23_inter1_row0.\n\n              let val := addmod(\n\n                mulmod(\n\n                  addmod(\n\n                    /*rc16/perm/interaction_elm*/ mload(0x1c0),\n\n                    sub(PRIME, /*column2_row1*/ mload(0x1e00)),\n\n                    PRIME),\n\n                  /*column23_inter1_row1*/ mload(0x3320),\n\n                  PRIME),\n\n                sub(\n\n                  PRIME,\n\n                  mulmod(\n\n                    addmod(\n\n                      /*rc16/perm/interaction_elm*/ mload(0x1c0),\n\n                      sub(PRIME, /*column0_row1*/ mload(0x1a80)),\n\n                      PRIME),\n\n                    /*column23_inter1_row0*/ mload(0x3300),\n\n                    PRIME)),\n\n                PRIME)\n\n\n\n              // Numerator: point - trace_generator^(trace_length - 1).\n\n              // val *= domains[8].\n\n              val := mulmod(val, /*domains[8]*/ mload(0x3c60), PRIME)\n\n              // Denominator: point^trace_length - 1.\n\n              // val *= denominator_invs[0].\n\n              val := mulmod(val, /*denominator_invs[0]*/ mload(0x3e60), PRIME)\n\n\n\n              // res += val * coefficients[42].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[42]*/ mload(0x940), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for rc16/perm/last: column23_inter1_row0 - rc16/perm/public_memory_prod.\n\n              let val := addmod(\n\n                /*column23_inter1_row0*/ mload(0x3300),\n\n                sub(PRIME, /*rc16/perm/public_memory_prod*/ mload(0x1e0)),\n\n                PRIME)\n\n\n\n              // Numerator: 1.\n\n              // val *= 1.\n\n              // Denominator: point - trace_generator^(trace_length - 1).\n\n              // val *= denominator_invs[8].\n\n              val := mulmod(val, /*denominator_invs[8]*/ mload(0x3f60), PRIME)\n\n\n\n              // res += val * coefficients[43].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[43]*/ mload(0x960), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for rc16/diff_is_bit: rc16__diff_0 * rc16__diff_0 - rc16__diff_0.\n\n              let val := addmod(\n\n                mulmod(\n\n                  /*intermediate_value/rc16/diff_0*/ mload(0x3620),\n\n                  /*intermediate_value/rc16/diff_0*/ mload(0x3620),\n\n                  PRIME),\n\n                sub(PRIME, /*intermediate_value/rc16/diff_0*/ mload(0x3620)),\n\n                PRIME)\n\n\n\n              // Numerator: point - trace_generator^(trace_length - 1).\n\n              // val *= domains[8].\n\n              val := mulmod(val, /*domains[8]*/ mload(0x3c60), PRIME)\n\n              // Denominator: point^trace_length - 1.\n\n              // val *= denominator_invs[0].\n\n              val := mulmod(val, /*denominator_invs[0]*/ mload(0x3e60), PRIME)\n\n\n\n              // res += val * coefficients[44].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[44]*/ mload(0x980), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for rc16/minimum: column2_row0 - rc_min.\n\n              let val := addmod(/*column2_row0*/ mload(0x1de0), sub(PRIME, /*rc_min*/ mload(0x200)), PRIME)\n\n\n\n              // Numerator: 1.\n\n              // val *= 1.\n\n              // Denominator: point - 1.\n\n              // val *= denominator_invs[4].\n\n              val := mulmod(val, /*denominator_invs[4]*/ mload(0x3ee0), PRIME)\n\n\n\n              // res += val * coefficients[45].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[45]*/ mload(0x9a0), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for rc16/maximum: column2_row0 - rc_max.\n\n              let val := addmod(/*column2_row0*/ mload(0x1de0), sub(PRIME, /*rc_max*/ mload(0x220)), PRIME)\n\n\n\n              // Numerator: 1.\n\n              // val *= 1.\n\n              // Denominator: point - trace_generator^(trace_length - 1).\n\n              // val *= denominator_invs[8].\n\n              val := mulmod(val, /*denominator_invs[8]*/ mload(0x3f60), PRIME)\n\n\n\n              // res += val * coefficients[46].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[46]*/ mload(0x9c0), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for pedersen/hash0/ec_subset_sum/bit_unpacking/last_one_is_zero: column16_row255 * (column5_row0 - (column5_row1 + column5_row1)).\n\n              let val := mulmod(\n\n                /*column16_row255*/ mload(0x2780),\n\n                addmod(\n\n                  /*column5_row0*/ mload(0x1f40),\n\n                  sub(\n\n                    PRIME,\n\n                    addmod(/*column5_row1*/ mload(0x1f60), /*column5_row1*/ mload(0x1f60), PRIME)),\n\n                  PRIME),\n\n                PRIME)\n\n\n\n              // Numerator: 1.\n\n              // val *= 1.\n\n              // Denominator: point^(trace_length / 256) - 1.\n\n              // val *= denominator_invs[9].\n\n              val := mulmod(val, /*denominator_invs[9]*/ mload(0x3f80), PRIME)\n\n\n\n              // res += val * coefficients[47].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[47]*/ mload(0x9e0), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for pedersen/hash0/ec_subset_sum/bit_unpacking/zeroes_between_ones0: column16_row255 * (column5_row1 - 3138550867693340381917894711603833208051177722232017256448 * column5_row192).\n\n              let val := mulmod(\n\n                /*column16_row255*/ mload(0x2780),\n\n                addmod(\n\n                  /*column5_row1*/ mload(0x1f60),\n\n                  sub(\n\n                    PRIME,\n\n                    mulmod(\n\n                      3138550867693340381917894711603833208051177722232017256448,\n\n                      /*column5_row192*/ mload(0x1f80),\n\n                      PRIME)),\n\n                  PRIME),\n\n                PRIME)\n\n\n\n              // Numerator: 1.\n\n              // val *= 1.\n\n              // Denominator: point^(trace_length / 256) - 1.\n\n              // val *= denominator_invs[9].\n\n              val := mulmod(val, /*denominator_invs[9]*/ mload(0x3f80), PRIME)\n\n\n\n              // res += val * coefficients[48].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[48]*/ mload(0xa00), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for pedersen/hash0/ec_subset_sum/bit_unpacking/cumulative_bit192: column16_row255 - column15_row255 * (column5_row192 - (column5_row193 + column5_row193)).\n\n              let val := addmod(\n\n                /*column16_row255*/ mload(0x2780),\n\n                sub(\n\n                  PRIME,\n\n                  mulmod(\n\n                    /*column15_row255*/ mload(0x2740),\n\n                    addmod(\n\n                      /*column5_row192*/ mload(0x1f80),\n\n                      sub(\n\n                        PRIME,\n\n                        addmod(/*column5_row193*/ mload(0x1fa0), /*column5_row193*/ mload(0x1fa0), PRIME)),\n\n                      PRIME),\n\n                    PRIME)),\n\n                PRIME)\n\n\n\n              // Numerator: 1.\n\n              // val *= 1.\n\n              // Denominator: point^(trace_length / 256) - 1.\n\n              // val *= denominator_invs[9].\n\n              val := mulmod(val, /*denominator_invs[9]*/ mload(0x3f80), PRIME)\n\n\n\n              // res += val * coefficients[49].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[49]*/ mload(0xa20), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for pedersen/hash0/ec_subset_sum/bit_unpacking/zeroes_between_ones192: column15_row255 * (column5_row193 - 8 * column5_row196).\n\n              let val := mulmod(\n\n                /*column15_row255*/ mload(0x2740),\n\n                addmod(\n\n                  /*column5_row193*/ mload(0x1fa0),\n\n                  sub(PRIME, mulmod(8, /*column5_row196*/ mload(0x1fc0), PRIME)),\n\n                  PRIME),\n\n                PRIME)\n\n\n\n              // Numerator: 1.\n\n              // val *= 1.\n\n              // Denominator: point^(trace_length / 256) - 1.\n\n              // val *= denominator_invs[9].\n\n              val := mulmod(val, /*denominator_invs[9]*/ mload(0x3f80), PRIME)\n\n\n\n              // res += val * coefficients[50].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[50]*/ mload(0xa40), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for pedersen/hash0/ec_subset_sum/bit_unpacking/cumulative_bit196: column15_row255 - (column5_row251 - (column5_row252 + column5_row252)) * (column5_row196 - (column5_row197 + column5_row197)).\n\n              let val := addmod(\n\n                /*column15_row255*/ mload(0x2740),\n\n                sub(\n\n                  PRIME,\n\n                  mulmod(\n\n                    addmod(\n\n                      /*column5_row251*/ mload(0x2000),\n\n                      sub(\n\n                        PRIME,\n\n                        addmod(/*column5_row252*/ mload(0x2020), /*column5_row252*/ mload(0x2020), PRIME)),\n\n                      PRIME),\n\n                    addmod(\n\n                      /*column5_row196*/ mload(0x1fc0),\n\n                      sub(\n\n                        PRIME,\n\n                        addmod(/*column5_row197*/ mload(0x1fe0), /*column5_row197*/ mload(0x1fe0), PRIME)),\n\n                      PRIME),\n\n                    PRIME)),\n\n                PRIME)\n\n\n\n              // Numerator: 1.\n\n              // val *= 1.\n\n              // Denominator: point^(trace_length / 256) - 1.\n\n              // val *= denominator_invs[9].\n\n              val := mulmod(val, /*denominator_invs[9]*/ mload(0x3f80), PRIME)\n\n\n\n              // res += val * coefficients[51].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[51]*/ mload(0xa60), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for pedersen/hash0/ec_subset_sum/bit_unpacking/zeroes_between_ones196: (column5_row251 - (column5_row252 + column5_row252)) * (column5_row197 - 18014398509481984 * column5_row251).\n\n              let val := mulmod(\n\n                addmod(\n\n                  /*column5_row251*/ mload(0x2000),\n\n                  sub(\n\n                    PRIME,\n\n                    addmod(/*column5_row252*/ mload(0x2020), /*column5_row252*/ mload(0x2020), PRIME)),\n\n                  PRIME),\n\n                addmod(\n\n                  /*column5_row197*/ mload(0x1fe0),\n\n                  sub(PRIME, mulmod(18014398509481984, /*column5_row251*/ mload(0x2000), PRIME)),\n\n                  PRIME),\n\n                PRIME)\n\n\n\n              // Numerator: 1.\n\n              // val *= 1.\n\n              // Denominator: point^(trace_length / 256) - 1.\n\n              // val *= denominator_invs[9].\n\n              val := mulmod(val, /*denominator_invs[9]*/ mload(0x3f80), PRIME)\n\n\n\n              // res += val * coefficients[52].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[52]*/ mload(0xa80), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for pedersen/hash0/ec_subset_sum/booleanity_test: pedersen__hash0__ec_subset_sum__bit_0 * (pedersen__hash0__ec_subset_sum__bit_0 - 1).\n\n              let val := mulmod(\n\n                /*intermediate_value/pedersen/hash0/ec_subset_sum/bit_0*/ mload(0x3640),\n\n                addmod(\n\n                  /*intermediate_value/pedersen/hash0/ec_subset_sum/bit_0*/ mload(0x3640),\n\n                  sub(PRIME, 1),\n\n                  PRIME),\n\n                PRIME)\n\n\n\n              // Numerator: point^(trace_length / 256) - trace_generator^(255 * trace_length / 256).\n\n              // val *= domains[10].\n\n              val := mulmod(val, /*domains[10]*/ mload(0x3ca0), PRIME)\n\n              // Denominator: point^trace_length - 1.\n\n              // val *= denominator_invs[0].\n\n              val := mulmod(val, /*denominator_invs[0]*/ mload(0x3e60), PRIME)\n\n\n\n              // res += val * coefficients[53].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[53]*/ mload(0xaa0), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for pedersen/hash0/ec_subset_sum/bit_extraction_end: column5_row0.\n\n              let val := /*column5_row0*/ mload(0x1f40)\n\n\n\n              // Numerator: 1.\n\n              // val *= 1.\n\n              // Denominator: point^(trace_length / 256) - trace_generator^(63 * trace_length / 64).\n\n              // val *= denominator_invs[11].\n\n              val := mulmod(val, /*denominator_invs[11]*/ mload(0x3fc0), PRIME)\n\n\n\n              // res += val * coefficients[54].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[54]*/ mload(0xac0), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for pedersen/hash0/ec_subset_sum/zeros_tail: column5_row0.\n\n              let val := /*column5_row0*/ mload(0x1f40)\n\n\n\n              // Numerator: 1.\n\n              // val *= 1.\n\n              // Denominator: point^(trace_length / 256) - trace_generator^(255 * trace_length / 256).\n\n              // val *= denominator_invs[10].\n\n              val := mulmod(val, /*denominator_invs[10]*/ mload(0x3fa0), PRIME)\n\n\n\n              // res += val * coefficients[55].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[55]*/ mload(0xae0), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for pedersen/hash0/ec_subset_sum/add_points/slope: pedersen__hash0__ec_subset_sum__bit_0 * (column4_row0 - pedersen__points__y) - column15_row0 * (column3_row0 - pedersen__points__x).\n\n              let val := addmod(\n\n                mulmod(\n\n                  /*intermediate_value/pedersen/hash0/ec_subset_sum/bit_0*/ mload(0x3640),\n\n                  addmod(\n\n                    /*column4_row0*/ mload(0x1ec0),\n\n                    sub(PRIME, /*periodic_column/pedersen/points/y*/ mload(0x20)),\n\n                    PRIME),\n\n                  PRIME),\n\n                sub(\n\n                  PRIME,\n\n                  mulmod(\n\n                    /*column15_row0*/ mload(0x2720),\n\n                    addmod(\n\n                      /*column3_row0*/ mload(0x1e20),\n\n                      sub(PRIME, /*periodic_column/pedersen/points/x*/ mload(0x0)),\n\n                      PRIME),\n\n                    PRIME)),\n\n                PRIME)\n\n\n\n              // Numerator: point^(trace_length / 256) - trace_generator^(255 * trace_length / 256).\n\n              // val *= domains[10].\n\n              val := mulmod(val, /*domains[10]*/ mload(0x3ca0), PRIME)\n\n              // Denominator: point^trace_length - 1.\n\n              // val *= denominator_invs[0].\n\n              val := mulmod(val, /*denominator_invs[0]*/ mload(0x3e60), PRIME)\n\n\n\n              // res += val * coefficients[56].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[56]*/ mload(0xb00), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for pedersen/hash0/ec_subset_sum/add_points/x: column15_row0 * column15_row0 - pedersen__hash0__ec_subset_sum__bit_0 * (column3_row0 + pedersen__points__x + column3_row1).\n\n              let val := addmod(\n\n                mulmod(/*column15_row0*/ mload(0x2720), /*column15_row0*/ mload(0x2720), PRIME),\n\n                sub(\n\n                  PRIME,\n\n                  mulmod(\n\n                    /*intermediate_value/pedersen/hash0/ec_subset_sum/bit_0*/ mload(0x3640),\n\n                    addmod(\n\n                      addmod(\n\n                        /*column3_row0*/ mload(0x1e20),\n\n                        /*periodic_column/pedersen/points/x*/ mload(0x0),\n\n                        PRIME),\n\n                      /*column3_row1*/ mload(0x1e40),\n\n                      PRIME),\n\n                    PRIME)),\n\n                PRIME)\n\n\n\n              // Numerator: point^(trace_length / 256) - trace_generator^(255 * trace_length / 256).\n\n              // val *= domains[10].\n\n              val := mulmod(val, /*domains[10]*/ mload(0x3ca0), PRIME)\n\n              // Denominator: point^trace_length - 1.\n\n              // val *= denominator_invs[0].\n\n              val := mulmod(val, /*denominator_invs[0]*/ mload(0x3e60), PRIME)\n\n\n\n              // res += val * coefficients[57].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[57]*/ mload(0xb20), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for pedersen/hash0/ec_subset_sum/add_points/y: pedersen__hash0__ec_subset_sum__bit_0 * (column4_row0 + column4_row1) - column15_row0 * (column3_row0 - column3_row1).\n\n              let val := addmod(\n\n                mulmod(\n\n                  /*intermediate_value/pedersen/hash0/ec_subset_sum/bit_0*/ mload(0x3640),\n\n                  addmod(/*column4_row0*/ mload(0x1ec0), /*column4_row1*/ mload(0x1ee0), PRIME),\n\n                  PRIME),\n\n                sub(\n\n                  PRIME,\n\n                  mulmod(\n\n                    /*column15_row0*/ mload(0x2720),\n\n                    addmod(/*column3_row0*/ mload(0x1e20), sub(PRIME, /*column3_row1*/ mload(0x1e40)), PRIME),\n\n                    PRIME)),\n\n                PRIME)\n\n\n\n              // Numerator: point^(trace_length / 256) - trace_generator^(255 * trace_length / 256).\n\n              // val *= domains[10].\n\n              val := mulmod(val, /*domains[10]*/ mload(0x3ca0), PRIME)\n\n              // Denominator: point^trace_length - 1.\n\n              // val *= denominator_invs[0].\n\n              val := mulmod(val, /*denominator_invs[0]*/ mload(0x3e60), PRIME)\n\n\n\n              // res += val * coefficients[58].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[58]*/ mload(0xb40), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for pedersen/hash0/ec_subset_sum/copy_point/x: pedersen__hash0__ec_subset_sum__bit_neg_0 * (column3_row1 - column3_row0).\n\n              let val := mulmod(\n\n                /*intermediate_value/pedersen/hash0/ec_subset_sum/bit_neg_0*/ mload(0x3660),\n\n                addmod(/*column3_row1*/ mload(0x1e40), sub(PRIME, /*column3_row0*/ mload(0x1e20)), PRIME),\n\n                PRIME)\n\n\n\n              // Numerator: point^(trace_length / 256) - trace_generator^(255 * trace_length / 256).\n\n              // val *= domains[10].\n\n              val := mulmod(val, /*domains[10]*/ mload(0x3ca0), PRIME)\n\n              // Denominator: point^trace_length - 1.\n\n              // val *= denominator_invs[0].\n\n              val := mulmod(val, /*denominator_invs[0]*/ mload(0x3e60), PRIME)\n\n\n\n              // res += val * coefficients[59].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[59]*/ mload(0xb60), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for pedersen/hash0/ec_subset_sum/copy_point/y: pedersen__hash0__ec_subset_sum__bit_neg_0 * (column4_row1 - column4_row0).\n\n              let val := mulmod(\n\n                /*intermediate_value/pedersen/hash0/ec_subset_sum/bit_neg_0*/ mload(0x3660),\n\n                addmod(/*column4_row1*/ mload(0x1ee0), sub(PRIME, /*column4_row0*/ mload(0x1ec0)), PRIME),\n\n                PRIME)\n\n\n\n              // Numerator: point^(trace_length / 256) - trace_generator^(255 * trace_length / 256).\n\n              // val *= domains[10].\n\n              val := mulmod(val, /*domains[10]*/ mload(0x3ca0), PRIME)\n\n              // Denominator: point^trace_length - 1.\n\n              // val *= denominator_invs[0].\n\n              val := mulmod(val, /*denominator_invs[0]*/ mload(0x3e60), PRIME)\n\n\n\n              // res += val * coefficients[60].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[60]*/ mload(0xb80), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for pedersen/hash0/copy_point/x: column3_row256 - column3_row255.\n\n              let val := addmod(\n\n                /*column3_row256*/ mload(0x1e80),\n\n                sub(PRIME, /*column3_row255*/ mload(0x1e60)),\n\n                PRIME)\n\n\n\n              // Numerator: point^(trace_length / 512) - trace_generator^(trace_length / 2).\n\n              // val *= domains[12].\n\n              val := mulmod(val, /*domains[12]*/ mload(0x3ce0), PRIME)\n\n              // Denominator: point^(trace_length / 256) - 1.\n\n              // val *= denominator_invs[9].\n\n              val := mulmod(val, /*denominator_invs[9]*/ mload(0x3f80), PRIME)\n\n\n\n              // res += val * coefficients[61].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[61]*/ mload(0xba0), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for pedersen/hash0/copy_point/y: column4_row256 - column4_row255.\n\n              let val := addmod(\n\n                /*column4_row256*/ mload(0x1f20),\n\n                sub(PRIME, /*column4_row255*/ mload(0x1f00)),\n\n                PRIME)\n\n\n\n              // Numerator: point^(trace_length / 512) - trace_generator^(trace_length / 2).\n\n              // val *= domains[12].\n\n              val := mulmod(val, /*domains[12]*/ mload(0x3ce0), PRIME)\n\n              // Denominator: point^(trace_length / 256) - 1.\n\n              // val *= denominator_invs[9].\n\n              val := mulmod(val, /*denominator_invs[9]*/ mload(0x3f80), PRIME)\n\n\n\n              // res += val * coefficients[62].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[62]*/ mload(0xbc0), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for pedersen/hash0/init/x: column3_row0 - pedersen/shift_point.x.\n\n              let val := addmod(\n\n                /*column3_row0*/ mload(0x1e20),\n\n                sub(PRIME, /*pedersen/shift_point.x*/ mload(0x240)),\n\n                PRIME)\n\n\n\n              // Numerator: 1.\n\n              // val *= 1.\n\n              // Denominator: point^(trace_length / 512) - 1.\n\n              // val *= denominator_invs[12].\n\n              val := mulmod(val, /*denominator_invs[12]*/ mload(0x3fe0), PRIME)\n\n\n\n              // res += val * coefficients[63].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[63]*/ mload(0xbe0), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for pedersen/hash0/init/y: column4_row0 - pedersen/shift_point.y.\n\n              let val := addmod(\n\n                /*column4_row0*/ mload(0x1ec0),\n\n                sub(PRIME, /*pedersen/shift_point.y*/ mload(0x260)),\n\n                PRIME)\n\n\n\n              // Numerator: 1.\n\n              // val *= 1.\n\n              // Denominator: point^(trace_length / 512) - 1.\n\n              // val *= denominator_invs[12].\n\n              val := mulmod(val, /*denominator_invs[12]*/ mload(0x3fe0), PRIME)\n\n\n\n              // res += val * coefficients[64].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[64]*/ mload(0xc00), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for pedersen/hash1/ec_subset_sum/bit_unpacking/last_one_is_zero: column18_row255 * (column8_row0 - (column8_row1 + column8_row1)).\n\n              let val := mulmod(\n\n                /*column18_row255*/ mload(0x2800),\n\n                addmod(\n\n                  /*column8_row0*/ mload(0x2180),\n\n                  sub(\n\n                    PRIME,\n\n                    addmod(/*column8_row1*/ mload(0x21a0), /*column8_row1*/ mload(0x21a0), PRIME)),\n\n                  PRIME),\n\n                PRIME)\n\n\n\n              // Numerator: 1.\n\n              // val *= 1.\n\n              // Denominator: point^(trace_length / 256) - 1.\n\n              // val *= denominator_invs[9].\n\n              val := mulmod(val, /*denominator_invs[9]*/ mload(0x3f80), PRIME)\n\n\n\n              // res += val * coefficients[65].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[65]*/ mload(0xc20), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for pedersen/hash1/ec_subset_sum/bit_unpacking/zeroes_between_ones0: column18_row255 * (column8_row1 - 3138550867693340381917894711603833208051177722232017256448 * column8_row192).\n\n              let val := mulmod(\n\n                /*column18_row255*/ mload(0x2800),\n\n                addmod(\n\n                  /*column8_row1*/ mload(0x21a0),\n\n                  sub(\n\n                    PRIME,\n\n                    mulmod(\n\n                      3138550867693340381917894711603833208051177722232017256448,\n\n                      /*column8_row192*/ mload(0x21c0),\n\n                      PRIME)),\n\n                  PRIME),\n\n                PRIME)\n\n\n\n              // Numerator: 1.\n\n              // val *= 1.\n\n              // Denominator: point^(trace_length / 256) - 1.\n\n              // val *= denominator_invs[9].\n\n              val := mulmod(val, /*denominator_invs[9]*/ mload(0x3f80), PRIME)\n\n\n\n              // res += val * coefficients[66].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[66]*/ mload(0xc40), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for pedersen/hash1/ec_subset_sum/bit_unpacking/cumulative_bit192: column18_row255 - column17_row255 * (column8_row192 - (column8_row193 + column8_row193)).\n\n              let val := addmod(\n\n                /*column18_row255*/ mload(0x2800),\n\n                sub(\n\n                  PRIME,\n\n                  mulmod(\n\n                    /*column17_row255*/ mload(0x27c0),\n\n                    addmod(\n\n                      /*column8_row192*/ mload(0x21c0),\n\n                      sub(\n\n                        PRIME,\n\n                        addmod(/*column8_row193*/ mload(0x21e0), /*column8_row193*/ mload(0x21e0), PRIME)),\n\n                      PRIME),\n\n                    PRIME)),\n\n                PRIME)\n\n\n\n              // Numerator: 1.\n\n              // val *= 1.\n\n              // Denominator: point^(trace_length / 256) - 1.\n\n              // val *= denominator_invs[9].\n\n              val := mulmod(val, /*denominator_invs[9]*/ mload(0x3f80), PRIME)\n\n\n\n              // res += val * coefficients[67].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[67]*/ mload(0xc60), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for pedersen/hash1/ec_subset_sum/bit_unpacking/zeroes_between_ones192: column17_row255 * (column8_row193 - 8 * column8_row196).\n\n              let val := mulmod(\n\n                /*column17_row255*/ mload(0x27c0),\n\n                addmod(\n\n                  /*column8_row193*/ mload(0x21e0),\n\n                  sub(PRIME, mulmod(8, /*column8_row196*/ mload(0x2200), PRIME)),\n\n                  PRIME),\n\n                PRIME)\n\n\n\n              // Numerator: 1.\n\n              // val *= 1.\n\n              // Denominator: point^(trace_length / 256) - 1.\n\n              // val *= denominator_invs[9].\n\n              val := mulmod(val, /*denominator_invs[9]*/ mload(0x3f80), PRIME)\n\n\n\n              // res += val * coefficients[68].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[68]*/ mload(0xc80), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for pedersen/hash1/ec_subset_sum/bit_unpacking/cumulative_bit196: column17_row255 - (column8_row251 - (column8_row252 + column8_row252)) * (column8_row196 - (column8_row197 + column8_row197)).\n\n              let val := addmod(\n\n                /*column17_row255*/ mload(0x27c0),\n\n                sub(\n\n                  PRIME,\n\n                  mulmod(\n\n                    addmod(\n\n                      /*column8_row251*/ mload(0x2240),\n\n                      sub(\n\n                        PRIME,\n\n                        addmod(/*column8_row252*/ mload(0x2260), /*column8_row252*/ mload(0x2260), PRIME)),\n\n                      PRIME),\n\n                    addmod(\n\n                      /*column8_row196*/ mload(0x2200),\n\n                      sub(\n\n                        PRIME,\n\n                        addmod(/*column8_row197*/ mload(0x2220), /*column8_row197*/ mload(0x2220), PRIME)),\n\n                      PRIME),\n\n                    PRIME)),\n\n                PRIME)\n\n\n\n              // Numerator: 1.\n\n              // val *= 1.\n\n              // Denominator: point^(trace_length / 256) - 1.\n\n              // val *= denominator_invs[9].\n\n              val := mulmod(val, /*denominator_invs[9]*/ mload(0x3f80), PRIME)\n\n\n\n              // res += val * coefficients[69].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[69]*/ mload(0xca0), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for pedersen/hash1/ec_subset_sum/bit_unpacking/zeroes_between_ones196: (column8_row251 - (column8_row252 + column8_row252)) * (column8_row197 - 18014398509481984 * column8_row251).\n\n              let val := mulmod(\n\n                addmod(\n\n                  /*column8_row251*/ mload(0x2240),\n\n                  sub(\n\n                    PRIME,\n\n                    addmod(/*column8_row252*/ mload(0x2260), /*column8_row252*/ mload(0x2260), PRIME)),\n\n                  PRIME),\n\n                addmod(\n\n                  /*column8_row197*/ mload(0x2220),\n\n                  sub(PRIME, mulmod(18014398509481984, /*column8_row251*/ mload(0x2240), PRIME)),\n\n                  PRIME),\n\n                PRIME)\n\n\n\n              // Numerator: 1.\n\n              // val *= 1.\n\n              // Denominator: point^(trace_length / 256) - 1.\n\n              // val *= denominator_invs[9].\n\n              val := mulmod(val, /*denominator_invs[9]*/ mload(0x3f80), PRIME)\n\n\n\n              // res += val * coefficients[70].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[70]*/ mload(0xcc0), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for pedersen/hash1/ec_subset_sum/booleanity_test: pedersen__hash1__ec_subset_sum__bit_0 * (pedersen__hash1__ec_subset_sum__bit_0 - 1).\n\n              let val := mulmod(\n\n                /*intermediate_value/pedersen/hash1/ec_subset_sum/bit_0*/ mload(0x3680),\n\n                addmod(\n\n                  /*intermediate_value/pedersen/hash1/ec_subset_sum/bit_0*/ mload(0x3680),\n\n                  sub(PRIME, 1),\n\n                  PRIME),\n\n                PRIME)\n\n\n\n              // Numerator: point^(trace_length / 256) - trace_generator^(255 * trace_length / 256).\n\n              // val *= domains[10].\n\n              val := mulmod(val, /*domains[10]*/ mload(0x3ca0), PRIME)\n\n              // Denominator: point^trace_length - 1.\n\n              // val *= denominator_invs[0].\n\n              val := mulmod(val, /*denominator_invs[0]*/ mload(0x3e60), PRIME)\n\n\n\n              // res += val * coefficients[71].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[71]*/ mload(0xce0), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for pedersen/hash1/ec_subset_sum/bit_extraction_end: column8_row0.\n\n              let val := /*column8_row0*/ mload(0x2180)\n\n\n\n              // Numerator: 1.\n\n              // val *= 1.\n\n              // Denominator: point^(trace_length / 256) - trace_generator^(63 * trace_length / 64).\n\n              // val *= denominator_invs[11].\n\n              val := mulmod(val, /*denominator_invs[11]*/ mload(0x3fc0), PRIME)\n\n\n\n              // res += val * coefficients[72].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[72]*/ mload(0xd00), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for pedersen/hash1/ec_subset_sum/zeros_tail: column8_row0.\n\n              let val := /*column8_row0*/ mload(0x2180)\n\n\n\n              // Numerator: 1.\n\n              // val *= 1.\n\n              // Denominator: point^(trace_length / 256) - trace_generator^(255 * trace_length / 256).\n\n              // val *= denominator_invs[10].\n\n              val := mulmod(val, /*denominator_invs[10]*/ mload(0x3fa0), PRIME)\n\n\n\n              // res += val * coefficients[73].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[73]*/ mload(0xd20), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for pedersen/hash1/ec_subset_sum/add_points/slope: pedersen__hash1__ec_subset_sum__bit_0 * (column7_row0 - pedersen__points__y) - column16_row0 * (column6_row0 - pedersen__points__x).\n\n              let val := addmod(\n\n                mulmod(\n\n                  /*intermediate_value/pedersen/hash1/ec_subset_sum/bit_0*/ mload(0x3680),\n\n                  addmod(\n\n                    /*column7_row0*/ mload(0x2100),\n\n                    sub(PRIME, /*periodic_column/pedersen/points/y*/ mload(0x20)),\n\n                    PRIME),\n\n                  PRIME),\n\n                sub(\n\n                  PRIME,\n\n                  mulmod(\n\n                    /*column16_row0*/ mload(0x2760),\n\n                    addmod(\n\n                      /*column6_row0*/ mload(0x2060),\n\n                      sub(PRIME, /*periodic_column/pedersen/points/x*/ mload(0x0)),\n\n                      PRIME),\n\n                    PRIME)),\n\n                PRIME)\n\n\n\n              // Numerator: point^(trace_length / 256) - trace_generator^(255 * trace_length / 256).\n\n              // val *= domains[10].\n\n              val := mulmod(val, /*domains[10]*/ mload(0x3ca0), PRIME)\n\n              // Denominator: point^trace_length - 1.\n\n              // val *= denominator_invs[0].\n\n              val := mulmod(val, /*denominator_invs[0]*/ mload(0x3e60), PRIME)\n\n\n\n              // res += val * coefficients[74].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[74]*/ mload(0xd40), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for pedersen/hash1/ec_subset_sum/add_points/x: column16_row0 * column16_row0 - pedersen__hash1__ec_subset_sum__bit_0 * (column6_row0 + pedersen__points__x + column6_row1).\n\n              let val := addmod(\n\n                mulmod(/*column16_row0*/ mload(0x2760), /*column16_row0*/ mload(0x2760), PRIME),\n\n                sub(\n\n                  PRIME,\n\n                  mulmod(\n\n                    /*intermediate_value/pedersen/hash1/ec_subset_sum/bit_0*/ mload(0x3680),\n\n                    addmod(\n\n                      addmod(\n\n                        /*column6_row0*/ mload(0x2060),\n\n                        /*periodic_column/pedersen/points/x*/ mload(0x0),\n\n                        PRIME),\n\n                      /*column6_row1*/ mload(0x2080),\n\n                      PRIME),\n\n                    PRIME)),\n\n                PRIME)\n\n\n\n              // Numerator: point^(trace_length / 256) - trace_generator^(255 * trace_length / 256).\n\n              // val *= domains[10].\n\n              val := mulmod(val, /*domains[10]*/ mload(0x3ca0), PRIME)\n\n              // Denominator: point^trace_length - 1.\n\n              // val *= denominator_invs[0].\n\n              val := mulmod(val, /*denominator_invs[0]*/ mload(0x3e60), PRIME)\n\n\n\n              // res += val * coefficients[75].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[75]*/ mload(0xd60), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for pedersen/hash1/ec_subset_sum/add_points/y: pedersen__hash1__ec_subset_sum__bit_0 * (column7_row0 + column7_row1) - column16_row0 * (column6_row0 - column6_row1).\n\n              let val := addmod(\n\n                mulmod(\n\n                  /*intermediate_value/pedersen/hash1/ec_subset_sum/bit_0*/ mload(0x3680),\n\n                  addmod(/*column7_row0*/ mload(0x2100), /*column7_row1*/ mload(0x2120), PRIME),\n\n                  PRIME),\n\n                sub(\n\n                  PRIME,\n\n                  mulmod(\n\n                    /*column16_row0*/ mload(0x2760),\n\n                    addmod(/*column6_row0*/ mload(0x2060), sub(PRIME, /*column6_row1*/ mload(0x2080)), PRIME),\n\n                    PRIME)),\n\n                PRIME)\n\n\n\n              // Numerator: point^(trace_length / 256) - trace_generator^(255 * trace_length / 256).\n\n              // val *= domains[10].\n\n              val := mulmod(val, /*domains[10]*/ mload(0x3ca0), PRIME)\n\n              // Denominator: point^trace_length - 1.\n\n              // val *= denominator_invs[0].\n\n              val := mulmod(val, /*denominator_invs[0]*/ mload(0x3e60), PRIME)\n\n\n\n              // res += val * coefficients[76].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[76]*/ mload(0xd80), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for pedersen/hash1/ec_subset_sum/copy_point/x: pedersen__hash1__ec_subset_sum__bit_neg_0 * (column6_row1 - column6_row0).\n\n              let val := mulmod(\n\n                /*intermediate_value/pedersen/hash1/ec_subset_sum/bit_neg_0*/ mload(0x36a0),\n\n                addmod(/*column6_row1*/ mload(0x2080), sub(PRIME, /*column6_row0*/ mload(0x2060)), PRIME),\n\n                PRIME)\n\n\n\n              // Numerator: point^(trace_length / 256) - trace_generator^(255 * trace_length / 256).\n\n              // val *= domains[10].\n\n              val := mulmod(val, /*domains[10]*/ mload(0x3ca0), PRIME)\n\n              // Denominator: point^trace_length - 1.\n\n              // val *= denominator_invs[0].\n\n              val := mulmod(val, /*denominator_invs[0]*/ mload(0x3e60), PRIME)\n\n\n\n              // res += val * coefficients[77].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[77]*/ mload(0xda0), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for pedersen/hash1/ec_subset_sum/copy_point/y: pedersen__hash1__ec_subset_sum__bit_neg_0 * (column7_row1 - column7_row0).\n\n              let val := mulmod(\n\n                /*intermediate_value/pedersen/hash1/ec_subset_sum/bit_neg_0*/ mload(0x36a0),\n\n                addmod(/*column7_row1*/ mload(0x2120), sub(PRIME, /*column7_row0*/ mload(0x2100)), PRIME),\n\n                PRIME)\n\n\n\n              // Numerator: point^(trace_length / 256) - trace_generator^(255 * trace_length / 256).\n\n              // val *= domains[10].\n\n              val := mulmod(val, /*domains[10]*/ mload(0x3ca0), PRIME)\n\n              // Denominator: point^trace_length - 1.\n\n              // val *= denominator_invs[0].\n\n              val := mulmod(val, /*denominator_invs[0]*/ mload(0x3e60), PRIME)\n\n\n\n              // res += val * coefficients[78].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[78]*/ mload(0xdc0), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for pedersen/hash1/copy_point/x: column6_row256 - column6_row255.\n\n              let val := addmod(\n\n                /*column6_row256*/ mload(0x20c0),\n\n                sub(PRIME, /*column6_row255*/ mload(0x20a0)),\n\n                PRIME)\n\n\n\n              // Numerator: point^(trace_length / 512) - trace_generator^(trace_length / 2).\n\n              // val *= domains[12].\n\n              val := mulmod(val, /*domains[12]*/ mload(0x3ce0), PRIME)\n\n              // Denominator: point^(trace_length / 256) - 1.\n\n              // val *= denominator_invs[9].\n\n              val := mulmod(val, /*denominator_invs[9]*/ mload(0x3f80), PRIME)\n\n\n\n              // res += val * coefficients[79].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[79]*/ mload(0xde0), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for pedersen/hash1/copy_point/y: column7_row256 - column7_row255.\n\n              let val := addmod(\n\n                /*column7_row256*/ mload(0x2160),\n\n                sub(PRIME, /*column7_row255*/ mload(0x2140)),\n\n                PRIME)\n\n\n\n              // Numerator: point^(trace_length / 512) - trace_generator^(trace_length / 2).\n\n              // val *= domains[12].\n\n              val := mulmod(val, /*domains[12]*/ mload(0x3ce0), PRIME)\n\n              // Denominator: point^(trace_length / 256) - 1.\n\n              // val *= denominator_invs[9].\n\n              val := mulmod(val, /*denominator_invs[9]*/ mload(0x3f80), PRIME)\n\n\n\n              // res += val * coefficients[80].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[80]*/ mload(0xe00), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for pedersen/hash1/init/x: column6_row0 - pedersen/shift_point.x.\n\n              let val := addmod(\n\n                /*column6_row0*/ mload(0x2060),\n\n                sub(PRIME, /*pedersen/shift_point.x*/ mload(0x240)),\n\n                PRIME)\n\n\n\n              // Numerator: 1.\n\n              // val *= 1.\n\n              // Denominator: point^(trace_length / 512) - 1.\n\n              // val *= denominator_invs[12].\n\n              val := mulmod(val, /*denominator_invs[12]*/ mload(0x3fe0), PRIME)\n\n\n\n              // res += val * coefficients[81].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[81]*/ mload(0xe20), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for pedersen/hash1/init/y: column7_row0 - pedersen/shift_point.y.\n\n              let val := addmod(\n\n                /*column7_row0*/ mload(0x2100),\n\n                sub(PRIME, /*pedersen/shift_point.y*/ mload(0x260)),\n\n                PRIME)\n\n\n\n              // Numerator: 1.\n\n              // val *= 1.\n\n              // Denominator: point^(trace_length / 512) - 1.\n\n              // val *= denominator_invs[12].\n\n              val := mulmod(val, /*denominator_invs[12]*/ mload(0x3fe0), PRIME)\n\n\n\n              // res += val * coefficients[82].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[82]*/ mload(0xe40), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for pedersen/hash2/ec_subset_sum/bit_unpacking/last_one_is_zero: column22_row144 * (column11_row0 - (column11_row1 + column11_row1)).\n\n              let val := mulmod(\n\n                /*column22_row144*/ mload(0x32a0),\n\n                addmod(\n\n                  /*column11_row0*/ mload(0x23c0),\n\n                  sub(\n\n                    PRIME,\n\n                    addmod(/*column11_row1*/ mload(0x23e0), /*column11_row1*/ mload(0x23e0), PRIME)),\n\n                  PRIME),\n\n                PRIME)\n\n\n\n              // Numerator: 1.\n\n              // val *= 1.\n\n              // Denominator: point^(trace_length / 256) - 1.\n\n              // val *= denominator_invs[9].\n\n              val := mulmod(val, /*denominator_invs[9]*/ mload(0x3f80), PRIME)\n\n\n\n              // res += val * coefficients[83].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[83]*/ mload(0xe60), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for pedersen/hash2/ec_subset_sum/bit_unpacking/zeroes_between_ones0: column22_row144 * (column11_row1 - 3138550867693340381917894711603833208051177722232017256448 * column11_row192).\n\n              let val := mulmod(\n\n                /*column22_row144*/ mload(0x32a0),\n\n                addmod(\n\n                  /*column11_row1*/ mload(0x23e0),\n\n                  sub(\n\n                    PRIME,\n\n                    mulmod(\n\n                      3138550867693340381917894711603833208051177722232017256448,\n\n                      /*column11_row192*/ mload(0x2400),\n\n                      PRIME)),\n\n                  PRIME),\n\n                PRIME)\n\n\n\n              // Numerator: 1.\n\n              // val *= 1.\n\n              // Denominator: point^(trace_length / 256) - 1.\n\n              // val *= denominator_invs[9].\n\n              val := mulmod(val, /*denominator_invs[9]*/ mload(0x3f80), PRIME)\n\n\n\n              // res += val * coefficients[84].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[84]*/ mload(0xe80), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for pedersen/hash2/ec_subset_sum/bit_unpacking/cumulative_bit192: column22_row144 - column22_row16 * (column11_row192 - (column11_row193 + column11_row193)).\n\n              let val := addmod(\n\n                /*column22_row144*/ mload(0x32a0),\n\n                sub(\n\n                  PRIME,\n\n                  mulmod(\n\n                    /*column22_row16*/ mload(0x3260),\n\n                    addmod(\n\n                      /*column11_row192*/ mload(0x2400),\n\n                      sub(\n\n                        PRIME,\n\n                        addmod(/*column11_row193*/ mload(0x2420), /*column11_row193*/ mload(0x2420), PRIME)),\n\n                      PRIME),\n\n                    PRIME)),\n\n                PRIME)\n\n\n\n              // Numerator: 1.\n\n              // val *= 1.\n\n              // Denominator: point^(trace_length / 256) - 1.\n\n              // val *= denominator_invs[9].\n\n              val := mulmod(val, /*denominator_invs[9]*/ mload(0x3f80), PRIME)\n\n\n\n              // res += val * coefficients[85].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[85]*/ mload(0xea0), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for pedersen/hash2/ec_subset_sum/bit_unpacking/zeroes_between_ones192: column22_row16 * (column11_row193 - 8 * column11_row196).\n\n              let val := mulmod(\n\n                /*column22_row16*/ mload(0x3260),\n\n                addmod(\n\n                  /*column11_row193*/ mload(0x2420),\n\n                  sub(PRIME, mulmod(8, /*column11_row196*/ mload(0x2440), PRIME)),\n\n                  PRIME),\n\n                PRIME)\n\n\n\n              // Numerator: 1.\n\n              // val *= 1.\n\n              // Denominator: point^(trace_length / 256) - 1.\n\n              // val *= denominator_invs[9].\n\n              val := mulmod(val, /*denominator_invs[9]*/ mload(0x3f80), PRIME)\n\n\n\n              // res += val * coefficients[86].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[86]*/ mload(0xec0), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for pedersen/hash2/ec_subset_sum/bit_unpacking/cumulative_bit196: column22_row16 - (column11_row251 - (column11_row252 + column11_row252)) * (column11_row196 - (column11_row197 + column11_row197)).\n\n              let val := addmod(\n\n                /*column22_row16*/ mload(0x3260),\n\n                sub(\n\n                  PRIME,\n\n                  mulmod(\n\n                    addmod(\n\n                      /*column11_row251*/ mload(0x2480),\n\n                      sub(\n\n                        PRIME,\n\n                        addmod(/*column11_row252*/ mload(0x24a0), /*column11_row252*/ mload(0x24a0), PRIME)),\n\n                      PRIME),\n\n                    addmod(\n\n                      /*column11_row196*/ mload(0x2440),\n\n                      sub(\n\n                        PRIME,\n\n                        addmod(/*column11_row197*/ mload(0x2460), /*column11_row197*/ mload(0x2460), PRIME)),\n\n                      PRIME),\n\n                    PRIME)),\n\n                PRIME)\n\n\n\n              // Numerator: 1.\n\n              // val *= 1.\n\n              // Denominator: point^(trace_length / 256) - 1.\n\n              // val *= denominator_invs[9].\n\n              val := mulmod(val, /*denominator_invs[9]*/ mload(0x3f80), PRIME)\n\n\n\n              // res += val * coefficients[87].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[87]*/ mload(0xee0), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for pedersen/hash2/ec_subset_sum/bit_unpacking/zeroes_between_ones196: (column11_row251 - (column11_row252 + column11_row252)) * (column11_row197 - 18014398509481984 * column11_row251).\n\n              let val := mulmod(\n\n                addmod(\n\n                  /*column11_row251*/ mload(0x2480),\n\n                  sub(\n\n                    PRIME,\n\n                    addmod(/*column11_row252*/ mload(0x24a0), /*column11_row252*/ mload(0x24a0), PRIME)),\n\n                  PRIME),\n\n                addmod(\n\n                  /*column11_row197*/ mload(0x2460),\n\n                  sub(PRIME, mulmod(18014398509481984, /*column11_row251*/ mload(0x2480), PRIME)),\n\n                  PRIME),\n\n                PRIME)\n\n\n\n              // Numerator: 1.\n\n              // val *= 1.\n\n              // Denominator: point^(trace_length / 256) - 1.\n\n              // val *= denominator_invs[9].\n\n              val := mulmod(val, /*denominator_invs[9]*/ mload(0x3f80), PRIME)\n\n\n\n              // res += val * coefficients[88].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[88]*/ mload(0xf00), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for pedersen/hash2/ec_subset_sum/booleanity_test: pedersen__hash2__ec_subset_sum__bit_0 * (pedersen__hash2__ec_subset_sum__bit_0 - 1).\n\n              let val := mulmod(\n\n                /*intermediate_value/pedersen/hash2/ec_subset_sum/bit_0*/ mload(0x36c0),\n\n                addmod(\n\n                  /*intermediate_value/pedersen/hash2/ec_subset_sum/bit_0*/ mload(0x36c0),\n\n                  sub(PRIME, 1),\n\n                  PRIME),\n\n                PRIME)\n\n\n\n              // Numerator: point^(trace_length / 256) - trace_generator^(255 * trace_length / 256).\n\n              // val *= domains[10].\n\n              val := mulmod(val, /*domains[10]*/ mload(0x3ca0), PRIME)\n\n              // Denominator: point^trace_length - 1.\n\n              // val *= denominator_invs[0].\n\n              val := mulmod(val, /*denominator_invs[0]*/ mload(0x3e60), PRIME)\n\n\n\n              // res += val * coefficients[89].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[89]*/ mload(0xf20), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for pedersen/hash2/ec_subset_sum/bit_extraction_end: column11_row0.\n\n              let val := /*column11_row0*/ mload(0x23c0)\n\n\n\n              // Numerator: 1.\n\n              // val *= 1.\n\n              // Denominator: point^(trace_length / 256) - trace_generator^(63 * trace_length / 64).\n\n              // val *= denominator_invs[11].\n\n              val := mulmod(val, /*denominator_invs[11]*/ mload(0x3fc0), PRIME)\n\n\n\n              // res += val * coefficients[90].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[90]*/ mload(0xf40), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for pedersen/hash2/ec_subset_sum/zeros_tail: column11_row0.\n\n              let val := /*column11_row0*/ mload(0x23c0)\n\n\n\n              // Numerator: 1.\n\n              // val *= 1.\n\n              // Denominator: point^(trace_length / 256) - trace_generator^(255 * trace_length / 256).\n\n              // val *= denominator_invs[10].\n\n              val := mulmod(val, /*denominator_invs[10]*/ mload(0x3fa0), PRIME)\n\n\n\n              // res += val * coefficients[91].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[91]*/ mload(0xf60), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for pedersen/hash2/ec_subset_sum/add_points/slope: pedersen__hash2__ec_subset_sum__bit_0 * (column10_row0 - pedersen__points__y) - column17_row0 * (column9_row0 - pedersen__points__x).\n\n              let val := addmod(\n\n                mulmod(\n\n                  /*intermediate_value/pedersen/hash2/ec_subset_sum/bit_0*/ mload(0x36c0),\n\n                  addmod(\n\n                    /*column10_row0*/ mload(0x2340),\n\n                    sub(PRIME, /*periodic_column/pedersen/points/y*/ mload(0x20)),\n\n                    PRIME),\n\n                  PRIME),\n\n                sub(\n\n                  PRIME,\n\n                  mulmod(\n\n                    /*column17_row0*/ mload(0x27a0),\n\n                    addmod(\n\n                      /*column9_row0*/ mload(0x22a0),\n\n                      sub(PRIME, /*periodic_column/pedersen/points/x*/ mload(0x0)),\n\n                      PRIME),\n\n                    PRIME)),\n\n                PRIME)\n\n\n\n              // Numerator: point^(trace_length / 256) - trace_generator^(255 * trace_length / 256).\n\n              // val *= domains[10].\n\n              val := mulmod(val, /*domains[10]*/ mload(0x3ca0), PRIME)\n\n              // Denominator: point^trace_length - 1.\n\n              // val *= denominator_invs[0].\n\n              val := mulmod(val, /*denominator_invs[0]*/ mload(0x3e60), PRIME)\n\n\n\n              // res += val * coefficients[92].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[92]*/ mload(0xf80), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for pedersen/hash2/ec_subset_sum/add_points/x: column17_row0 * column17_row0 - pedersen__hash2__ec_subset_sum__bit_0 * (column9_row0 + pedersen__points__x + column9_row1).\n\n              let val := addmod(\n\n                mulmod(/*column17_row0*/ mload(0x27a0), /*column17_row0*/ mload(0x27a0), PRIME),\n\n                sub(\n\n                  PRIME,\n\n                  mulmod(\n\n                    /*intermediate_value/pedersen/hash2/ec_subset_sum/bit_0*/ mload(0x36c0),\n\n                    addmod(\n\n                      addmod(\n\n                        /*column9_row0*/ mload(0x22a0),\n\n                        /*periodic_column/pedersen/points/x*/ mload(0x0),\n\n                        PRIME),\n\n                      /*column9_row1*/ mload(0x22c0),\n\n                      PRIME),\n\n                    PRIME)),\n\n                PRIME)\n\n\n\n              // Numerator: point^(trace_length / 256) - trace_generator^(255 * trace_length / 256).\n\n              // val *= domains[10].\n\n              val := mulmod(val, /*domains[10]*/ mload(0x3ca0), PRIME)\n\n              // Denominator: point^trace_length - 1.\n\n              // val *= denominator_invs[0].\n\n              val := mulmod(val, /*denominator_invs[0]*/ mload(0x3e60), PRIME)\n\n\n\n              // res += val * coefficients[93].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[93]*/ mload(0xfa0), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for pedersen/hash2/ec_subset_sum/add_points/y: pedersen__hash2__ec_subset_sum__bit_0 * (column10_row0 + column10_row1) - column17_row0 * (column9_row0 - column9_row1).\n\n              let val := addmod(\n\n                mulmod(\n\n                  /*intermediate_value/pedersen/hash2/ec_subset_sum/bit_0*/ mload(0x36c0),\n\n                  addmod(/*column10_row0*/ mload(0x2340), /*column10_row1*/ mload(0x2360), PRIME),\n\n                  PRIME),\n\n                sub(\n\n                  PRIME,\n\n                  mulmod(\n\n                    /*column17_row0*/ mload(0x27a0),\n\n                    addmod(/*column9_row0*/ mload(0x22a0), sub(PRIME, /*column9_row1*/ mload(0x22c0)), PRIME),\n\n                    PRIME)),\n\n                PRIME)\n\n\n\n              // Numerator: point^(trace_length / 256) - trace_generator^(255 * trace_length / 256).\n\n              // val *= domains[10].\n\n              val := mulmod(val, /*domains[10]*/ mload(0x3ca0), PRIME)\n\n              // Denominator: point^trace_length - 1.\n\n              // val *= denominator_invs[0].\n\n              val := mulmod(val, /*denominator_invs[0]*/ mload(0x3e60), PRIME)\n\n\n\n              // res += val * coefficients[94].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[94]*/ mload(0xfc0), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for pedersen/hash2/ec_subset_sum/copy_point/x: pedersen__hash2__ec_subset_sum__bit_neg_0 * (column9_row1 - column9_row0).\n\n              let val := mulmod(\n\n                /*intermediate_value/pedersen/hash2/ec_subset_sum/bit_neg_0*/ mload(0x36e0),\n\n                addmod(/*column9_row1*/ mload(0x22c0), sub(PRIME, /*column9_row0*/ mload(0x22a0)), PRIME),\n\n                PRIME)\n\n\n\n              // Numerator: point^(trace_length / 256) - trace_generator^(255 * trace_length / 256).\n\n              // val *= domains[10].\n\n              val := mulmod(val, /*domains[10]*/ mload(0x3ca0), PRIME)\n\n              // Denominator: point^trace_length - 1.\n\n              // val *= denominator_invs[0].\n\n              val := mulmod(val, /*denominator_invs[0]*/ mload(0x3e60), PRIME)\n\n\n\n              // res += val * coefficients[95].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[95]*/ mload(0xfe0), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for pedersen/hash2/ec_subset_sum/copy_point/y: pedersen__hash2__ec_subset_sum__bit_neg_0 * (column10_row1 - column10_row0).\n\n              let val := mulmod(\n\n                /*intermediate_value/pedersen/hash2/ec_subset_sum/bit_neg_0*/ mload(0x36e0),\n\n                addmod(/*column10_row1*/ mload(0x2360), sub(PRIME, /*column10_row0*/ mload(0x2340)), PRIME),\n\n                PRIME)\n\n\n\n              // Numerator: point^(trace_length / 256) - trace_generator^(255 * trace_length / 256).\n\n              // val *= domains[10].\n\n              val := mulmod(val, /*domains[10]*/ mload(0x3ca0), PRIME)\n\n              // Denominator: point^trace_length - 1.\n\n              // val *= denominator_invs[0].\n\n              val := mulmod(val, /*denominator_invs[0]*/ mload(0x3e60), PRIME)\n\n\n\n              // res += val * coefficients[96].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[96]*/ mload(0x1000), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for pedersen/hash2/copy_point/x: column9_row256 - column9_row255.\n\n              let val := addmod(\n\n                /*column9_row256*/ mload(0x2300),\n\n                sub(PRIME, /*column9_row255*/ mload(0x22e0)),\n\n                PRIME)\n\n\n\n              // Numerator: point^(trace_length / 512) - trace_generator^(trace_length / 2).\n\n              // val *= domains[12].\n\n              val := mulmod(val, /*domains[12]*/ mload(0x3ce0), PRIME)\n\n              // Denominator: point^(trace_length / 256) - 1.\n\n              // val *= denominator_invs[9].\n\n              val := mulmod(val, /*denominator_invs[9]*/ mload(0x3f80), PRIME)\n\n\n\n              // res += val * coefficients[97].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[97]*/ mload(0x1020), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for pedersen/hash2/copy_point/y: column10_row256 - column10_row255.\n\n              let val := addmod(\n\n                /*column10_row256*/ mload(0x23a0),\n\n                sub(PRIME, /*column10_row255*/ mload(0x2380)),\n\n                PRIME)\n\n\n\n              // Numerator: point^(trace_length / 512) - trace_generator^(trace_length / 2).\n\n              // val *= domains[12].\n\n              val := mulmod(val, /*domains[12]*/ mload(0x3ce0), PRIME)\n\n              // Denominator: point^(trace_length / 256) - 1.\n\n              // val *= denominator_invs[9].\n\n              val := mulmod(val, /*denominator_invs[9]*/ mload(0x3f80), PRIME)\n\n\n\n              // res += val * coefficients[98].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[98]*/ mload(0x1040), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for pedersen/hash2/init/x: column9_row0 - pedersen/shift_point.x.\n\n              let val := addmod(\n\n                /*column9_row0*/ mload(0x22a0),\n\n                sub(PRIME, /*pedersen/shift_point.x*/ mload(0x240)),\n\n                PRIME)\n\n\n\n              // Numerator: 1.\n\n              // val *= 1.\n\n              // Denominator: point^(trace_length / 512) - 1.\n\n              // val *= denominator_invs[12].\n\n              val := mulmod(val, /*denominator_invs[12]*/ mload(0x3fe0), PRIME)\n\n\n\n              // res += val * coefficients[99].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[99]*/ mload(0x1060), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for pedersen/hash2/init/y: column10_row0 - pedersen/shift_point.y.\n\n              let val := addmod(\n\n                /*column10_row0*/ mload(0x2340),\n\n                sub(PRIME, /*pedersen/shift_point.y*/ mload(0x260)),\n\n                PRIME)\n\n\n\n              // Numerator: 1.\n\n              // val *= 1.\n\n              // Denominator: point^(trace_length / 512) - 1.\n\n              // val *= denominator_invs[12].\n\n              val := mulmod(val, /*denominator_invs[12]*/ mload(0x3fe0), PRIME)\n\n\n\n              // res += val * coefficients[100].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[100]*/ mload(0x1080), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for pedersen/hash3/ec_subset_sum/bit_unpacking/last_one_is_zero: column22_row208 * (column14_row0 - (column14_row1 + column14_row1)).\n\n              let val := mulmod(\n\n                /*column22_row208*/ mload(0x32c0),\n\n                addmod(\n\n                  /*column14_row0*/ mload(0x2600),\n\n                  sub(\n\n                    PRIME,\n\n                    addmod(/*column14_row1*/ mload(0x2620), /*column14_row1*/ mload(0x2620), PRIME)),\n\n                  PRIME),\n\n                PRIME)\n\n\n\n              // Numerator: 1.\n\n              // val *= 1.\n\n              // Denominator: point^(trace_length / 256) - 1.\n\n              // val *= denominator_invs[9].\n\n              val := mulmod(val, /*denominator_invs[9]*/ mload(0x3f80), PRIME)\n\n\n\n              // res += val * coefficients[101].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[101]*/ mload(0x10a0), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for pedersen/hash3/ec_subset_sum/bit_unpacking/zeroes_between_ones0: column22_row208 * (column14_row1 - 3138550867693340381917894711603833208051177722232017256448 * column14_row192).\n\n              let val := mulmod(\n\n                /*column22_row208*/ mload(0x32c0),\n\n                addmod(\n\n                  /*column14_row1*/ mload(0x2620),\n\n                  sub(\n\n                    PRIME,\n\n                    mulmod(\n\n                      3138550867693340381917894711603833208051177722232017256448,\n\n                      /*column14_row192*/ mload(0x2640),\n\n                      PRIME)),\n\n                  PRIME),\n\n                PRIME)\n\n\n\n              // Numerator: 1.\n\n              // val *= 1.\n\n              // Denominator: point^(trace_length / 256) - 1.\n\n              // val *= denominator_invs[9].\n\n              val := mulmod(val, /*denominator_invs[9]*/ mload(0x3f80), PRIME)\n\n\n\n              // res += val * coefficients[102].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[102]*/ mload(0x10c0), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for pedersen/hash3/ec_subset_sum/bit_unpacking/cumulative_bit192: column22_row208 - column22_row80 * (column14_row192 - (column14_row193 + column14_row193)).\n\n              let val := addmod(\n\n                /*column22_row208*/ mload(0x32c0),\n\n                sub(\n\n                  PRIME,\n\n                  mulmod(\n\n                    /*column22_row80*/ mload(0x3280),\n\n                    addmod(\n\n                      /*column14_row192*/ mload(0x2640),\n\n                      sub(\n\n                        PRIME,\n\n                        addmod(/*column14_row193*/ mload(0x2660), /*column14_row193*/ mload(0x2660), PRIME)),\n\n                      PRIME),\n\n                    PRIME)),\n\n                PRIME)\n\n\n\n              // Numerator: 1.\n\n              // val *= 1.\n\n              // Denominator: point^(trace_length / 256) - 1.\n\n              // val *= denominator_invs[9].\n\n              val := mulmod(val, /*denominator_invs[9]*/ mload(0x3f80), PRIME)\n\n\n\n              // res += val * coefficients[103].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[103]*/ mload(0x10e0), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for pedersen/hash3/ec_subset_sum/bit_unpacking/zeroes_between_ones192: column22_row80 * (column14_row193 - 8 * column14_row196).\n\n              let val := mulmod(\n\n                /*column22_row80*/ mload(0x3280),\n\n                addmod(\n\n                  /*column14_row193*/ mload(0x2660),\n\n                  sub(PRIME, mulmod(8, /*column14_row196*/ mload(0x2680), PRIME)),\n\n                  PRIME),\n\n                PRIME)\n\n\n\n              // Numerator: 1.\n\n              // val *= 1.\n\n              // Denominator: point^(trace_length / 256) - 1.\n\n              // val *= denominator_invs[9].\n\n              val := mulmod(val, /*denominator_invs[9]*/ mload(0x3f80), PRIME)\n\n\n\n              // res += val * coefficients[104].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[104]*/ mload(0x1100), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for pedersen/hash3/ec_subset_sum/bit_unpacking/cumulative_bit196: column22_row80 - (column14_row251 - (column14_row252 + column14_row252)) * (column14_row196 - (column14_row197 + column14_row197)).\n\n              let val := addmod(\n\n                /*column22_row80*/ mload(0x3280),\n\n                sub(\n\n                  PRIME,\n\n                  mulmod(\n\n                    addmod(\n\n                      /*column14_row251*/ mload(0x26c0),\n\n                      sub(\n\n                        PRIME,\n\n                        addmod(/*column14_row252*/ mload(0x26e0), /*column14_row252*/ mload(0x26e0), PRIME)),\n\n                      PRIME),\n\n                    addmod(\n\n                      /*column14_row196*/ mload(0x2680),\n\n                      sub(\n\n                        PRIME,\n\n                        addmod(/*column14_row197*/ mload(0x26a0), /*column14_row197*/ mload(0x26a0), PRIME)),\n\n                      PRIME),\n\n                    PRIME)),\n\n                PRIME)\n\n\n\n              // Numerator: 1.\n\n              // val *= 1.\n\n              // Denominator: point^(trace_length / 256) - 1.\n\n              // val *= denominator_invs[9].\n\n              val := mulmod(val, /*denominator_invs[9]*/ mload(0x3f80), PRIME)\n\n\n\n              // res += val * coefficients[105].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[105]*/ mload(0x1120), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for pedersen/hash3/ec_subset_sum/bit_unpacking/zeroes_between_ones196: (column14_row251 - (column14_row252 + column14_row252)) * (column14_row197 - 18014398509481984 * column14_row251).\n\n              let val := mulmod(\n\n                addmod(\n\n                  /*column14_row251*/ mload(0x26c0),\n\n                  sub(\n\n                    PRIME,\n\n                    addmod(/*column14_row252*/ mload(0x26e0), /*column14_row252*/ mload(0x26e0), PRIME)),\n\n                  PRIME),\n\n                addmod(\n\n                  /*column14_row197*/ mload(0x26a0),\n\n                  sub(PRIME, mulmod(18014398509481984, /*column14_row251*/ mload(0x26c0), PRIME)),\n\n                  PRIME),\n\n                PRIME)\n\n\n\n              // Numerator: 1.\n\n              // val *= 1.\n\n              // Denominator: point^(trace_length / 256) - 1.\n\n              // val *= denominator_invs[9].\n\n              val := mulmod(val, /*denominator_invs[9]*/ mload(0x3f80), PRIME)\n\n\n\n              // res += val * coefficients[106].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[106]*/ mload(0x1140), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for pedersen/hash3/ec_subset_sum/booleanity_test: pedersen__hash3__ec_subset_sum__bit_0 * (pedersen__hash3__ec_subset_sum__bit_0 - 1).\n\n              let val := mulmod(\n\n                /*intermediate_value/pedersen/hash3/ec_subset_sum/bit_0*/ mload(0x3700),\n\n                addmod(\n\n                  /*intermediate_value/pedersen/hash3/ec_subset_sum/bit_0*/ mload(0x3700),\n\n                  sub(PRIME, 1),\n\n                  PRIME),\n\n                PRIME)\n\n\n\n              // Numerator: point^(trace_length / 256) - trace_generator^(255 * trace_length / 256).\n\n              // val *= domains[10].\n\n              val := mulmod(val, /*domains[10]*/ mload(0x3ca0), PRIME)\n\n              // Denominator: point^trace_length - 1.\n\n              // val *= denominator_invs[0].\n\n              val := mulmod(val, /*denominator_invs[0]*/ mload(0x3e60), PRIME)\n\n\n\n              // res += val * coefficients[107].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[107]*/ mload(0x1160), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for pedersen/hash3/ec_subset_sum/bit_extraction_end: column14_row0.\n\n              let val := /*column14_row0*/ mload(0x2600)\n\n\n\n              // Numerator: 1.\n\n              // val *= 1.\n\n              // Denominator: point^(trace_length / 256) - trace_generator^(63 * trace_length / 64).\n\n              // val *= denominator_invs[11].\n\n              val := mulmod(val, /*denominator_invs[11]*/ mload(0x3fc0), PRIME)\n\n\n\n              // res += val * coefficients[108].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[108]*/ mload(0x1180), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for pedersen/hash3/ec_subset_sum/zeros_tail: column14_row0.\n\n              let val := /*column14_row0*/ mload(0x2600)\n\n\n\n              // Numerator: 1.\n\n              // val *= 1.\n\n              // Denominator: point^(trace_length / 256) - trace_generator^(255 * trace_length / 256).\n\n              // val *= denominator_invs[10].\n\n              val := mulmod(val, /*denominator_invs[10]*/ mload(0x3fa0), PRIME)\n\n\n\n              // res += val * coefficients[109].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[109]*/ mload(0x11a0), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for pedersen/hash3/ec_subset_sum/add_points/slope: pedersen__hash3__ec_subset_sum__bit_0 * (column13_row0 - pedersen__points__y) - column18_row0 * (column12_row0 - pedersen__points__x).\n\n              let val := addmod(\n\n                mulmod(\n\n                  /*intermediate_value/pedersen/hash3/ec_subset_sum/bit_0*/ mload(0x3700),\n\n                  addmod(\n\n                    /*column13_row0*/ mload(0x2580),\n\n                    sub(PRIME, /*periodic_column/pedersen/points/y*/ mload(0x20)),\n\n                    PRIME),\n\n                  PRIME),\n\n                sub(\n\n                  PRIME,\n\n                  mulmod(\n\n                    /*column18_row0*/ mload(0x27e0),\n\n                    addmod(\n\n                      /*column12_row0*/ mload(0x24e0),\n\n                      sub(PRIME, /*periodic_column/pedersen/points/x*/ mload(0x0)),\n\n                      PRIME),\n\n                    PRIME)),\n\n                PRIME)\n\n\n\n              // Numerator: point^(trace_length / 256) - trace_generator^(255 * trace_length / 256).\n\n              // val *= domains[10].\n\n              val := mulmod(val, /*domains[10]*/ mload(0x3ca0), PRIME)\n\n              // Denominator: point^trace_length - 1.\n\n              // val *= denominator_invs[0].\n\n              val := mulmod(val, /*denominator_invs[0]*/ mload(0x3e60), PRIME)\n\n\n\n              // res += val * coefficients[110].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[110]*/ mload(0x11c0), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for pedersen/hash3/ec_subset_sum/add_points/x: column18_row0 * column18_row0 - pedersen__hash3__ec_subset_sum__bit_0 * (column12_row0 + pedersen__points__x + column12_row1).\n\n              let val := addmod(\n\n                mulmod(/*column18_row0*/ mload(0x27e0), /*column18_row0*/ mload(0x27e0), PRIME),\n\n                sub(\n\n                  PRIME,\n\n                  mulmod(\n\n                    /*intermediate_value/pedersen/hash3/ec_subset_sum/bit_0*/ mload(0x3700),\n\n                    addmod(\n\n                      addmod(\n\n                        /*column12_row0*/ mload(0x24e0),\n\n                        /*periodic_column/pedersen/points/x*/ mload(0x0),\n\n                        PRIME),\n\n                      /*column12_row1*/ mload(0x2500),\n\n                      PRIME),\n\n                    PRIME)),\n\n                PRIME)\n\n\n\n              // Numerator: point^(trace_length / 256) - trace_generator^(255 * trace_length / 256).\n\n              // val *= domains[10].\n\n              val := mulmod(val, /*domains[10]*/ mload(0x3ca0), PRIME)\n\n              // Denominator: point^trace_length - 1.\n\n              // val *= denominator_invs[0].\n\n              val := mulmod(val, /*denominator_invs[0]*/ mload(0x3e60), PRIME)\n\n\n\n              // res += val * coefficients[111].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[111]*/ mload(0x11e0), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for pedersen/hash3/ec_subset_sum/add_points/y: pedersen__hash3__ec_subset_sum__bit_0 * (column13_row0 + column13_row1) - column18_row0 * (column12_row0 - column12_row1).\n\n              let val := addmod(\n\n                mulmod(\n\n                  /*intermediate_value/pedersen/hash3/ec_subset_sum/bit_0*/ mload(0x3700),\n\n                  addmod(/*column13_row0*/ mload(0x2580), /*column13_row1*/ mload(0x25a0), PRIME),\n\n                  PRIME),\n\n                sub(\n\n                  PRIME,\n\n                  mulmod(\n\n                    /*column18_row0*/ mload(0x27e0),\n\n                    addmod(/*column12_row0*/ mload(0x24e0), sub(PRIME, /*column12_row1*/ mload(0x2500)), PRIME),\n\n                    PRIME)),\n\n                PRIME)\n\n\n\n              // Numerator: point^(trace_length / 256) - trace_generator^(255 * trace_length / 256).\n\n              // val *= domains[10].\n\n              val := mulmod(val, /*domains[10]*/ mload(0x3ca0), PRIME)\n\n              // Denominator: point^trace_length - 1.\n\n              // val *= denominator_invs[0].\n\n              val := mulmod(val, /*denominator_invs[0]*/ mload(0x3e60), PRIME)\n\n\n\n              // res += val * coefficients[112].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[112]*/ mload(0x1200), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for pedersen/hash3/ec_subset_sum/copy_point/x: pedersen__hash3__ec_subset_sum__bit_neg_0 * (column12_row1 - column12_row0).\n\n              let val := mulmod(\n\n                /*intermediate_value/pedersen/hash3/ec_subset_sum/bit_neg_0*/ mload(0x3720),\n\n                addmod(/*column12_row1*/ mload(0x2500), sub(PRIME, /*column12_row0*/ mload(0x24e0)), PRIME),\n\n                PRIME)\n\n\n\n              // Numerator: point^(trace_length / 256) - trace_generator^(255 * trace_length / 256).\n\n              // val *= domains[10].\n\n              val := mulmod(val, /*domains[10]*/ mload(0x3ca0), PRIME)\n\n              // Denominator: point^trace_length - 1.\n\n              // val *= denominator_invs[0].\n\n              val := mulmod(val, /*denominator_invs[0]*/ mload(0x3e60), PRIME)\n\n\n\n              // res += val * coefficients[113].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[113]*/ mload(0x1220), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for pedersen/hash3/ec_subset_sum/copy_point/y: pedersen__hash3__ec_subset_sum__bit_neg_0 * (column13_row1 - column13_row0).\n\n              let val := mulmod(\n\n                /*intermediate_value/pedersen/hash3/ec_subset_sum/bit_neg_0*/ mload(0x3720),\n\n                addmod(/*column13_row1*/ mload(0x25a0), sub(PRIME, /*column13_row0*/ mload(0x2580)), PRIME),\n\n                PRIME)\n\n\n\n              // Numerator: point^(trace_length / 256) - trace_generator^(255 * trace_length / 256).\n\n              // val *= domains[10].\n\n              val := mulmod(val, /*domains[10]*/ mload(0x3ca0), PRIME)\n\n              // Denominator: point^trace_length - 1.\n\n              // val *= denominator_invs[0].\n\n              val := mulmod(val, /*denominator_invs[0]*/ mload(0x3e60), PRIME)\n\n\n\n              // res += val * coefficients[114].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[114]*/ mload(0x1240), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for pedersen/hash3/copy_point/x: column12_row256 - column12_row255.\n\n              let val := addmod(\n\n                /*column12_row256*/ mload(0x2540),\n\n                sub(PRIME, /*column12_row255*/ mload(0x2520)),\n\n                PRIME)\n\n\n\n              // Numerator: point^(trace_length / 512) - trace_generator^(trace_length / 2).\n\n              // val *= domains[12].\n\n              val := mulmod(val, /*domains[12]*/ mload(0x3ce0), PRIME)\n\n              // Denominator: point^(trace_length / 256) - 1.\n\n              // val *= denominator_invs[9].\n\n              val := mulmod(val, /*denominator_invs[9]*/ mload(0x3f80), PRIME)\n\n\n\n              // res += val * coefficients[115].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[115]*/ mload(0x1260), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for pedersen/hash3/copy_point/y: column13_row256 - column13_row255.\n\n              let val := addmod(\n\n                /*column13_row256*/ mload(0x25e0),\n\n                sub(PRIME, /*column13_row255*/ mload(0x25c0)),\n\n                PRIME)\n\n\n\n              // Numerator: point^(trace_length / 512) - trace_generator^(trace_length / 2).\n\n              // val *= domains[12].\n\n              val := mulmod(val, /*domains[12]*/ mload(0x3ce0), PRIME)\n\n              // Denominator: point^(trace_length / 256) - 1.\n\n              // val *= denominator_invs[9].\n\n              val := mulmod(val, /*denominator_invs[9]*/ mload(0x3f80), PRIME)\n\n\n\n              // res += val * coefficients[116].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[116]*/ mload(0x1280), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for pedersen/hash3/init/x: column12_row0 - pedersen/shift_point.x.\n\n              let val := addmod(\n\n                /*column12_row0*/ mload(0x24e0),\n\n                sub(PRIME, /*pedersen/shift_point.x*/ mload(0x240)),\n\n                PRIME)\n\n\n\n              // Numerator: 1.\n\n              // val *= 1.\n\n              // Denominator: point^(trace_length / 512) - 1.\n\n              // val *= denominator_invs[12].\n\n              val := mulmod(val, /*denominator_invs[12]*/ mload(0x3fe0), PRIME)\n\n\n\n              // res += val * coefficients[117].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[117]*/ mload(0x12a0), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for pedersen/hash3/init/y: column13_row0 - pedersen/shift_point.y.\n\n              let val := addmod(\n\n                /*column13_row0*/ mload(0x2580),\n\n                sub(PRIME, /*pedersen/shift_point.y*/ mload(0x260)),\n\n                PRIME)\n\n\n\n              // Numerator: 1.\n\n              // val *= 1.\n\n              // Denominator: point^(trace_length / 512) - 1.\n\n              // val *= denominator_invs[12].\n\n              val := mulmod(val, /*denominator_invs[12]*/ mload(0x3fe0), PRIME)\n\n\n\n              // res += val * coefficients[118].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[118]*/ mload(0x12c0), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for pedersen/input0_value0: column19_row7 - column5_row0.\n\n              let val := addmod(/*column19_row7*/ mload(0x2900), sub(PRIME, /*column5_row0*/ mload(0x1f40)), PRIME)\n\n\n\n              // Numerator: 1.\n\n              // val *= 1.\n\n              // Denominator: point^(trace_length / 512) - 1.\n\n              // val *= denominator_invs[12].\n\n              val := mulmod(val, /*denominator_invs[12]*/ mload(0x3fe0), PRIME)\n\n\n\n              // res += val * coefficients[119].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[119]*/ mload(0x12e0), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for pedersen/input0_value1: column19_row135 - column8_row0.\n\n              let val := addmod(\n\n                /*column19_row135*/ mload(0x2ae0),\n\n                sub(PRIME, /*column8_row0*/ mload(0x2180)),\n\n                PRIME)\n\n\n\n              // Numerator: 1.\n\n              // val *= 1.\n\n              // Denominator: point^(trace_length / 512) - 1.\n\n              // val *= denominator_invs[12].\n\n              val := mulmod(val, /*denominator_invs[12]*/ mload(0x3fe0), PRIME)\n\n\n\n              // res += val * coefficients[120].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[120]*/ mload(0x1300), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for pedersen/input0_value2: column19_row263 - column11_row0.\n\n              let val := addmod(\n\n                /*column19_row263*/ mload(0x2b60),\n\n                sub(PRIME, /*column11_row0*/ mload(0x23c0)),\n\n                PRIME)\n\n\n\n              // Numerator: 1.\n\n              // val *= 1.\n\n              // Denominator: point^(trace_length / 512) - 1.\n\n              // val *= denominator_invs[12].\n\n              val := mulmod(val, /*denominator_invs[12]*/ mload(0x3fe0), PRIME)\n\n\n\n              // res += val * coefficients[121].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[121]*/ mload(0x1320), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for pedersen/input0_value3: column19_row391 - column14_row0.\n\n              let val := addmod(\n\n                /*column19_row391*/ mload(0x2bc0),\n\n                sub(PRIME, /*column14_row0*/ mload(0x2600)),\n\n                PRIME)\n\n\n\n              // Numerator: 1.\n\n              // val *= 1.\n\n              // Denominator: point^(trace_length / 512) - 1.\n\n              // val *= denominator_invs[12].\n\n              val := mulmod(val, /*denominator_invs[12]*/ mload(0x3fe0), PRIME)\n\n\n\n              // res += val * coefficients[122].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[122]*/ mload(0x1340), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for pedersen/input0_addr: column19_row134 - (column19_row38 + 1).\n\n              let val := addmod(\n\n                /*column19_row134*/ mload(0x2ac0),\n\n                sub(PRIME, addmod(/*column19_row38*/ mload(0x2a00), 1, PRIME)),\n\n                PRIME)\n\n\n\n              // Numerator: point - trace_generator^(128 * (trace_length / 128 - 1)).\n\n              // val *= domains[15].\n\n              val := mulmod(val, /*domains[15]*/ mload(0x3d40), PRIME)\n\n              // Denominator: point^(trace_length / 128) - 1.\n\n              // val *= denominator_invs[13].\n\n              val := mulmod(val, /*denominator_invs[13]*/ mload(0x4000), PRIME)\n\n\n\n              // res += val * coefficients[123].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[123]*/ mload(0x1360), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for pedersen/init_addr: column19_row6 - initial_pedersen_addr.\n\n              let val := addmod(\n\n                /*column19_row6*/ mload(0x28e0),\n\n                sub(PRIME, /*initial_pedersen_addr*/ mload(0x280)),\n\n                PRIME)\n\n\n\n              // Numerator: 1.\n\n              // val *= 1.\n\n              // Denominator: point - 1.\n\n              // val *= denominator_invs[4].\n\n              val := mulmod(val, /*denominator_invs[4]*/ mload(0x3ee0), PRIME)\n\n\n\n              // res += val * coefficients[124].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[124]*/ mload(0x1380), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for pedersen/input1_value0: column19_row71 - column5_row256.\n\n              let val := addmod(\n\n                /*column19_row71*/ mload(0x2a60),\n\n                sub(PRIME, /*column5_row256*/ mload(0x2040)),\n\n                PRIME)\n\n\n\n              // Numerator: 1.\n\n              // val *= 1.\n\n              // Denominator: point^(trace_length / 512) - 1.\n\n              // val *= denominator_invs[12].\n\n              val := mulmod(val, /*denominator_invs[12]*/ mload(0x3fe0), PRIME)\n\n\n\n              // res += val * coefficients[125].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[125]*/ mload(0x13a0), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for pedersen/input1_value1: column19_row199 - column8_row256.\n\n              let val := addmod(\n\n                /*column19_row199*/ mload(0x2b20),\n\n                sub(PRIME, /*column8_row256*/ mload(0x2280)),\n\n                PRIME)\n\n\n\n              // Numerator: 1.\n\n              // val *= 1.\n\n              // Denominator: point^(trace_length / 512) - 1.\n\n              // val *= denominator_invs[12].\n\n              val := mulmod(val, /*denominator_invs[12]*/ mload(0x3fe0), PRIME)\n\n\n\n              // res += val * coefficients[126].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[126]*/ mload(0x13c0), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for pedersen/input1_value2: column19_row327 - column11_row256.\n\n              let val := addmod(\n\n                /*column19_row327*/ mload(0x2ba0),\n\n                sub(PRIME, /*column11_row256*/ mload(0x24c0)),\n\n                PRIME)\n\n\n\n              // Numerator: 1.\n\n              // val *= 1.\n\n              // Denominator: point^(trace_length / 512) - 1.\n\n              // val *= denominator_invs[12].\n\n              val := mulmod(val, /*denominator_invs[12]*/ mload(0x3fe0), PRIME)\n\n\n\n              // res += val * coefficients[127].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[127]*/ mload(0x13e0), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for pedersen/input1_value3: column19_row455 - column14_row256.\n\n              let val := addmod(\n\n                /*column19_row455*/ mload(0x2c00),\n\n                sub(PRIME, /*column14_row256*/ mload(0x2700)),\n\n                PRIME)\n\n\n\n              // Numerator: 1.\n\n              // val *= 1.\n\n              // Denominator: point^(trace_length / 512) - 1.\n\n              // val *= denominator_invs[12].\n\n              val := mulmod(val, /*denominator_invs[12]*/ mload(0x3fe0), PRIME)\n\n\n\n              // res += val * coefficients[128].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[128]*/ mload(0x1400), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for pedersen/input1_addr: column19_row70 - (column19_row6 + 1).\n\n              let val := addmod(\n\n                /*column19_row70*/ mload(0x2a40),\n\n                sub(PRIME, addmod(/*column19_row6*/ mload(0x28e0), 1, PRIME)),\n\n                PRIME)\n\n\n\n              // Numerator: 1.\n\n              // val *= 1.\n\n              // Denominator: point^(trace_length / 128) - 1.\n\n              // val *= denominator_invs[13].\n\n              val := mulmod(val, /*denominator_invs[13]*/ mload(0x4000), PRIME)\n\n\n\n              // res += val * coefficients[129].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[129]*/ mload(0x1420), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for pedersen/output_value0: column19_row39 - column3_row511.\n\n              let val := addmod(\n\n                /*column19_row39*/ mload(0x2a20),\n\n                sub(PRIME, /*column3_row511*/ mload(0x1ea0)),\n\n                PRIME)\n\n\n\n              // Numerator: 1.\n\n              // val *= 1.\n\n              // Denominator: point^(trace_length / 512) - 1.\n\n              // val *= denominator_invs[12].\n\n              val := mulmod(val, /*denominator_invs[12]*/ mload(0x3fe0), PRIME)\n\n\n\n              // res += val * coefficients[130].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[130]*/ mload(0x1440), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for pedersen/output_value1: column19_row167 - column6_row511.\n\n              let val := addmod(\n\n                /*column19_row167*/ mload(0x2b00),\n\n                sub(PRIME, /*column6_row511*/ mload(0x20e0)),\n\n                PRIME)\n\n\n\n              // Numerator: 1.\n\n              // val *= 1.\n\n              // Denominator: point^(trace_length / 512) - 1.\n\n              // val *= denominator_invs[12].\n\n              val := mulmod(val, /*denominator_invs[12]*/ mload(0x3fe0), PRIME)\n\n\n\n              // res += val * coefficients[131].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[131]*/ mload(0x1460), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for pedersen/output_value2: column19_row295 - column9_row511.\n\n              let val := addmod(\n\n                /*column19_row295*/ mload(0x2b80),\n\n                sub(PRIME, /*column9_row511*/ mload(0x2320)),\n\n                PRIME)\n\n\n\n              // Numerator: 1.\n\n              // val *= 1.\n\n              // Denominator: point^(trace_length / 512) - 1.\n\n              // val *= denominator_invs[12].\n\n              val := mulmod(val, /*denominator_invs[12]*/ mload(0x3fe0), PRIME)\n\n\n\n              // res += val * coefficients[132].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[132]*/ mload(0x1480), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for pedersen/output_value3: column19_row423 - column12_row511.\n\n              let val := addmod(\n\n                /*column19_row423*/ mload(0x2be0),\n\n                sub(PRIME, /*column12_row511*/ mload(0x2560)),\n\n                PRIME)\n\n\n\n              // Numerator: 1.\n\n              // val *= 1.\n\n              // Denominator: point^(trace_length / 512) - 1.\n\n              // val *= denominator_invs[12].\n\n              val := mulmod(val, /*denominator_invs[12]*/ mload(0x3fe0), PRIME)\n\n\n\n              // res += val * coefficients[133].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[133]*/ mload(0x14a0), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for pedersen/output_addr: column19_row38 - (column19_row70 + 1).\n\n              let val := addmod(\n\n                /*column19_row38*/ mload(0x2a00),\n\n                sub(PRIME, addmod(/*column19_row70*/ mload(0x2a40), 1, PRIME)),\n\n                PRIME)\n\n\n\n              // Numerator: 1.\n\n              // val *= 1.\n\n              // Denominator: point^(trace_length / 128) - 1.\n\n              // val *= denominator_invs[13].\n\n              val := mulmod(val, /*denominator_invs[13]*/ mload(0x4000), PRIME)\n\n\n\n              // res += val * coefficients[134].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[134]*/ mload(0x14c0), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for rc_builtin/value: rc_builtin__value7_0 - column19_row103.\n\n              let val := addmod(\n\n                /*intermediate_value/rc_builtin/value7_0*/ mload(0x3820),\n\n                sub(PRIME, /*column19_row103*/ mload(0x2aa0)),\n\n                PRIME)\n\n\n\n              // Numerator: 1.\n\n              // val *= 1.\n\n              // Denominator: point^(trace_length / 128) - 1.\n\n              // val *= denominator_invs[13].\n\n              val := mulmod(val, /*denominator_invs[13]*/ mload(0x4000), PRIME)\n\n\n\n              // res += val * coefficients[135].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[135]*/ mload(0x14e0), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for rc_builtin/addr_step: column19_row230 - (column19_row102 + 1).\n\n              let val := addmod(\n\n                /*column19_row230*/ mload(0x2b40),\n\n                sub(PRIME, addmod(/*column19_row102*/ mload(0x2a80), 1, PRIME)),\n\n                PRIME)\n\n\n\n              // Numerator: point - trace_generator^(128 * (trace_length / 128 - 1)).\n\n              // val *= domains[15].\n\n              val := mulmod(val, /*domains[15]*/ mload(0x3d40), PRIME)\n\n              // Denominator: point^(trace_length / 128) - 1.\n\n              // val *= denominator_invs[13].\n\n              val := mulmod(val, /*denominator_invs[13]*/ mload(0x4000), PRIME)\n\n\n\n              // res += val * coefficients[136].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[136]*/ mload(0x1500), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for rc_builtin/init_addr: column19_row102 - initial_rc_addr.\n\n              let val := addmod(\n\n                /*column19_row102*/ mload(0x2a80),\n\n                sub(PRIME, /*initial_rc_addr*/ mload(0x2a0)),\n\n                PRIME)\n\n\n\n              // Numerator: 1.\n\n              // val *= 1.\n\n              // Denominator: point - 1.\n\n              // val *= denominator_invs[4].\n\n              val := mulmod(val, /*denominator_invs[4]*/ mload(0x3ee0), PRIME)\n\n\n\n              // res += val * coefficients[137].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[137]*/ mload(0x1520), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for ecdsa/signature0/doubling_key/slope: ecdsa__signature0__doubling_key__x_squared + ecdsa__signature0__doubling_key__x_squared + ecdsa__signature0__doubling_key__x_squared + ecdsa/sig_config.alpha - (column21_row14 + column21_row14) * column21_row13.\n\n              let val := addmod(\n\n                addmod(\n\n                  addmod(\n\n                    addmod(\n\n                      /*intermediate_value/ecdsa/signature0/doubling_key/x_squared*/ mload(0x3840),\n\n                      /*intermediate_value/ecdsa/signature0/doubling_key/x_squared*/ mload(0x3840),\n\n                      PRIME),\n\n                    /*intermediate_value/ecdsa/signature0/doubling_key/x_squared*/ mload(0x3840),\n\n                    PRIME),\n\n                  /*ecdsa/sig_config.alpha*/ mload(0x2c0),\n\n                  PRIME),\n\n                sub(\n\n                  PRIME,\n\n                  mulmod(\n\n                    addmod(/*column21_row14*/ mload(0x2ec0), /*column21_row14*/ mload(0x2ec0), PRIME),\n\n                    /*column21_row13*/ mload(0x2ea0),\n\n                    PRIME)),\n\n                PRIME)\n\n\n\n              // Numerator: point^(trace_length / 4096) - trace_generator^(255 * trace_length / 256).\n\n              // val *= domains[16].\n\n              val := mulmod(val, /*domains[16]*/ mload(0x3d60), PRIME)\n\n              // Denominator: point^(trace_length / 16) - 1.\n\n              // val *= denominator_invs[2].\n\n              val := mulmod(val, /*denominator_invs[2]*/ mload(0x3ea0), PRIME)\n\n\n\n              // res += val * coefficients[138].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[138]*/ mload(0x1540), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for ecdsa/signature0/doubling_key/x: column21_row13 * column21_row13 - (column21_row6 + column21_row6 + column21_row22).\n\n              let val := addmod(\n\n                mulmod(/*column21_row13*/ mload(0x2ea0), /*column21_row13*/ mload(0x2ea0), PRIME),\n\n                sub(\n\n                  PRIME,\n\n                  addmod(\n\n                    addmod(/*column21_row6*/ mload(0x2dc0), /*column21_row6*/ mload(0x2dc0), PRIME),\n\n                    /*column21_row22*/ mload(0x2f60),\n\n                    PRIME)),\n\n                PRIME)\n\n\n\n              // Numerator: point^(trace_length / 4096) - trace_generator^(255 * trace_length / 256).\n\n              // val *= domains[16].\n\n              val := mulmod(val, /*domains[16]*/ mload(0x3d60), PRIME)\n\n              // Denominator: point^(trace_length / 16) - 1.\n\n              // val *= denominator_invs[2].\n\n              val := mulmod(val, /*denominator_invs[2]*/ mload(0x3ea0), PRIME)\n\n\n\n              // res += val * coefficients[139].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[139]*/ mload(0x1560), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for ecdsa/signature0/doubling_key/y: column21_row14 + column21_row30 - column21_row13 * (column21_row6 - column21_row22).\n\n              let val := addmod(\n\n                addmod(/*column21_row14*/ mload(0x2ec0), /*column21_row30*/ mload(0x2fe0), PRIME),\n\n                sub(\n\n                  PRIME,\n\n                  mulmod(\n\n                    /*column21_row13*/ mload(0x2ea0),\n\n                    addmod(\n\n                      /*column21_row6*/ mload(0x2dc0),\n\n                      sub(PRIME, /*column21_row22*/ mload(0x2f60)),\n\n                      PRIME),\n\n                    PRIME)),\n\n                PRIME)\n\n\n\n              // Numerator: point^(trace_length / 4096) - trace_generator^(255 * trace_length / 256).\n\n              // val *= domains[16].\n\n              val := mulmod(val, /*domains[16]*/ mload(0x3d60), PRIME)\n\n              // Denominator: point^(trace_length / 16) - 1.\n\n              // val *= denominator_invs[2].\n\n              val := mulmod(val, /*denominator_invs[2]*/ mload(0x3ea0), PRIME)\n\n\n\n              // res += val * coefficients[140].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[140]*/ mload(0x1580), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for ecdsa/signature0/exponentiate_generator/booleanity_test: ecdsa__signature0__exponentiate_generator__bit_0 * (ecdsa__signature0__exponentiate_generator__bit_0 - 1).\n\n              let val := mulmod(\n\n                /*intermediate_value/ecdsa/signature0/exponentiate_generator/bit_0*/ mload(0x3860),\n\n                addmod(\n\n                  /*intermediate_value/ecdsa/signature0/exponentiate_generator/bit_0*/ mload(0x3860),\n\n                  sub(PRIME, 1),\n\n                  PRIME),\n\n                PRIME)\n\n\n\n              // Numerator: point^(trace_length / 8192) - trace_generator^(255 * trace_length / 256).\n\n              // val *= domains[18].\n\n              val := mulmod(val, /*domains[18]*/ mload(0x3da0), PRIME)\n\n              // Denominator: point^(trace_length / 32) - 1.\n\n              // val *= denominator_invs[15].\n\n              val := mulmod(val, /*denominator_invs[15]*/ mload(0x4040), PRIME)\n\n\n\n              // res += val * coefficients[141].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[141]*/ mload(0x15a0), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for ecdsa/signature0/exponentiate_generator/bit_extraction_end: column21_row15.\n\n              let val := /*column21_row15*/ mload(0x2ee0)\n\n\n\n              // Numerator: 1.\n\n              // val *= 1.\n\n              // Denominator: point^(trace_length / 8192) - trace_generator^(251 * trace_length / 256).\n\n              // val *= denominator_invs[17].\n\n              val := mulmod(val, /*denominator_invs[17]*/ mload(0x4080), PRIME)\n\n\n\n              // res += val * coefficients[142].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[142]*/ mload(0x15c0), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for ecdsa/signature0/exponentiate_generator/zeros_tail: column21_row15.\n\n              let val := /*column21_row15*/ mload(0x2ee0)\n\n\n\n              // Numerator: 1.\n\n              // val *= 1.\n\n              // Denominator: point^(trace_length / 8192) - trace_generator^(255 * trace_length / 256).\n\n              // val *= denominator_invs[16].\n\n              val := mulmod(val, /*denominator_invs[16]*/ mload(0x4060), PRIME)\n\n\n\n              // res += val * coefficients[143].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[143]*/ mload(0x15e0), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for ecdsa/signature0/exponentiate_generator/add_points/slope: ecdsa__signature0__exponentiate_generator__bit_0 * (column21_row23 - ecdsa__generator_points__y) - column21_row31 * (column21_row7 - ecdsa__generator_points__x).\n\n              let val := addmod(\n\n                mulmod(\n\n                  /*intermediate_value/ecdsa/signature0/exponentiate_generator/bit_0*/ mload(0x3860),\n\n                  addmod(\n\n                    /*column21_row23*/ mload(0x2f80),\n\n                    sub(PRIME, /*periodic_column/ecdsa/generator_points/y*/ mload(0x60)),\n\n                    PRIME),\n\n                  PRIME),\n\n                sub(\n\n                  PRIME,\n\n                  mulmod(\n\n                    /*column21_row31*/ mload(0x3000),\n\n                    addmod(\n\n                      /*column21_row7*/ mload(0x2de0),\n\n                      sub(PRIME, /*periodic_column/ecdsa/generator_points/x*/ mload(0x40)),\n\n                      PRIME),\n\n                    PRIME)),\n\n                PRIME)\n\n\n\n              // Numerator: point^(trace_length / 8192) - trace_generator^(255 * trace_length / 256).\n\n              // val *= domains[18].\n\n              val := mulmod(val, /*domains[18]*/ mload(0x3da0), PRIME)\n\n              // Denominator: point^(trace_length / 32) - 1.\n\n              // val *= denominator_invs[15].\n\n              val := mulmod(val, /*denominator_invs[15]*/ mload(0x4040), PRIME)\n\n\n\n              // res += val * coefficients[144].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[144]*/ mload(0x1600), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for ecdsa/signature0/exponentiate_generator/add_points/x: column21_row31 * column21_row31 - ecdsa__signature0__exponentiate_generator__bit_0 * (column21_row7 + ecdsa__generator_points__x + column21_row39).\n\n              let val := addmod(\n\n                mulmod(/*column21_row31*/ mload(0x3000), /*column21_row31*/ mload(0x3000), PRIME),\n\n                sub(\n\n                  PRIME,\n\n                  mulmod(\n\n                    /*intermediate_value/ecdsa/signature0/exponentiate_generator/bit_0*/ mload(0x3860),\n\n                    addmod(\n\n                      addmod(\n\n                        /*column21_row7*/ mload(0x2de0),\n\n                        /*periodic_column/ecdsa/generator_points/x*/ mload(0x40),\n\n                        PRIME),\n\n                      /*column21_row39*/ mload(0x3020),\n\n                      PRIME),\n\n                    PRIME)),\n\n                PRIME)\n\n\n\n              // Numerator: point^(trace_length / 8192) - trace_generator^(255 * trace_length / 256).\n\n              // val *= domains[18].\n\n              val := mulmod(val, /*domains[18]*/ mload(0x3da0), PRIME)\n\n              // Denominator: point^(trace_length / 32) - 1.\n\n              // val *= denominator_invs[15].\n\n              val := mulmod(val, /*denominator_invs[15]*/ mload(0x4040), PRIME)\n\n\n\n              // res += val * coefficients[145].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[145]*/ mload(0x1620), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for ecdsa/signature0/exponentiate_generator/add_points/y: ecdsa__signature0__exponentiate_generator__bit_0 * (column21_row23 + column21_row55) - column21_row31 * (column21_row7 - column21_row39).\n\n              let val := addmod(\n\n                mulmod(\n\n                  /*intermediate_value/ecdsa/signature0/exponentiate_generator/bit_0*/ mload(0x3860),\n\n                  addmod(/*column21_row23*/ mload(0x2f80), /*column21_row55*/ mload(0x3060), PRIME),\n\n                  PRIME),\n\n                sub(\n\n                  PRIME,\n\n                  mulmod(\n\n                    /*column21_row31*/ mload(0x3000),\n\n                    addmod(\n\n                      /*column21_row7*/ mload(0x2de0),\n\n                      sub(PRIME, /*column21_row39*/ mload(0x3020)),\n\n                      PRIME),\n\n                    PRIME)),\n\n                PRIME)\n\n\n\n              // Numerator: point^(trace_length / 8192) - trace_generator^(255 * trace_length / 256).\n\n              // val *= domains[18].\n\n              val := mulmod(val, /*domains[18]*/ mload(0x3da0), PRIME)\n\n              // Denominator: point^(trace_length / 32) - 1.\n\n              // val *= denominator_invs[15].\n\n              val := mulmod(val, /*denominator_invs[15]*/ mload(0x4040), PRIME)\n\n\n\n              // res += val * coefficients[146].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[146]*/ mload(0x1640), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for ecdsa/signature0/exponentiate_generator/add_points/x_diff_inv: column22_row0 * (column21_row7 - ecdsa__generator_points__x) - 1.\n\n              let val := addmod(\n\n                mulmod(\n\n                  /*column22_row0*/ mload(0x3240),\n\n                  addmod(\n\n                    /*column21_row7*/ mload(0x2de0),\n\n                    sub(PRIME, /*periodic_column/ecdsa/generator_points/x*/ mload(0x40)),\n\n                    PRIME),\n\n                  PRIME),\n\n                sub(PRIME, 1),\n\n                PRIME)\n\n\n\n              // Numerator: point^(trace_length / 8192) - trace_generator^(255 * trace_length / 256).\n\n              // val *= domains[18].\n\n              val := mulmod(val, /*domains[18]*/ mload(0x3da0), PRIME)\n\n              // Denominator: point^(trace_length / 32) - 1.\n\n              // val *= denominator_invs[15].\n\n              val := mulmod(val, /*denominator_invs[15]*/ mload(0x4040), PRIME)\n\n\n\n              // res += val * coefficients[147].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[147]*/ mload(0x1660), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for ecdsa/signature0/exponentiate_generator/copy_point/x: ecdsa__signature0__exponentiate_generator__bit_neg_0 * (column21_row39 - column21_row7).\n\n              let val := mulmod(\n\n                /*intermediate_value/ecdsa/signature0/exponentiate_generator/bit_neg_0*/ mload(0x3880),\n\n                addmod(\n\n                  /*column21_row39*/ mload(0x3020),\n\n                  sub(PRIME, /*column21_row7*/ mload(0x2de0)),\n\n                  PRIME),\n\n                PRIME)\n\n\n\n              // Numerator: point^(trace_length / 8192) - trace_generator^(255 * trace_length / 256).\n\n              // val *= domains[18].\n\n              val := mulmod(val, /*domains[18]*/ mload(0x3da0), PRIME)\n\n              // Denominator: point^(trace_length / 32) - 1.\n\n              // val *= denominator_invs[15].\n\n              val := mulmod(val, /*denominator_invs[15]*/ mload(0x4040), PRIME)\n\n\n\n              // res += val * coefficients[148].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[148]*/ mload(0x1680), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for ecdsa/signature0/exponentiate_generator/copy_point/y: ecdsa__signature0__exponentiate_generator__bit_neg_0 * (column21_row55 - column21_row23).\n\n              let val := mulmod(\n\n                /*intermediate_value/ecdsa/signature0/exponentiate_generator/bit_neg_0*/ mload(0x3880),\n\n                addmod(\n\n                  /*column21_row55*/ mload(0x3060),\n\n                  sub(PRIME, /*column21_row23*/ mload(0x2f80)),\n\n                  PRIME),\n\n                PRIME)\n\n\n\n              // Numerator: point^(trace_length / 8192) - trace_generator^(255 * trace_length / 256).\n\n              // val *= domains[18].\n\n              val := mulmod(val, /*domains[18]*/ mload(0x3da0), PRIME)\n\n              // Denominator: point^(trace_length / 32) - 1.\n\n              // val *= denominator_invs[15].\n\n              val := mulmod(val, /*denominator_invs[15]*/ mload(0x4040), PRIME)\n\n\n\n              // res += val * coefficients[149].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[149]*/ mload(0x16a0), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for ecdsa/signature0/exponentiate_key/booleanity_test: ecdsa__signature0__exponentiate_key__bit_0 * (ecdsa__signature0__exponentiate_key__bit_0 - 1).\n\n              let val := mulmod(\n\n                /*intermediate_value/ecdsa/signature0/exponentiate_key/bit_0*/ mload(0x38a0),\n\n                addmod(\n\n                  /*intermediate_value/ecdsa/signature0/exponentiate_key/bit_0*/ mload(0x38a0),\n\n                  sub(PRIME, 1),\n\n                  PRIME),\n\n                PRIME)\n\n\n\n              // Numerator: point^(trace_length / 4096) - trace_generator^(255 * trace_length / 256).\n\n              // val *= domains[16].\n\n              val := mulmod(val, /*domains[16]*/ mload(0x3d60), PRIME)\n\n              // Denominator: point^(trace_length / 16) - 1.\n\n              // val *= denominator_invs[2].\n\n              val := mulmod(val, /*denominator_invs[2]*/ mload(0x3ea0), PRIME)\n\n\n\n              // res += val * coefficients[150].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[150]*/ mload(0x16c0), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for ecdsa/signature0/exponentiate_key/bit_extraction_end: column21_row5.\n\n              let val := /*column21_row5*/ mload(0x2da0)\n\n\n\n              // Numerator: 1.\n\n              // val *= 1.\n\n              // Denominator: point^(trace_length / 4096) - trace_generator^(251 * trace_length / 256).\n\n              // val *= denominator_invs[18].\n\n              val := mulmod(val, /*denominator_invs[18]*/ mload(0x40a0), PRIME)\n\n\n\n              // res += val * coefficients[151].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[151]*/ mload(0x16e0), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for ecdsa/signature0/exponentiate_key/zeros_tail: column21_row5.\n\n              let val := /*column21_row5*/ mload(0x2da0)\n\n\n\n              // Numerator: 1.\n\n              // val *= 1.\n\n              // Denominator: point^(trace_length / 4096) - trace_generator^(255 * trace_length / 256).\n\n              // val *= denominator_invs[14].\n\n              val := mulmod(val, /*denominator_invs[14]*/ mload(0x4020), PRIME)\n\n\n\n              // res += val * coefficients[152].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[152]*/ mload(0x1700), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for ecdsa/signature0/exponentiate_key/add_points/slope: ecdsa__signature0__exponentiate_key__bit_0 * (column21_row9 - column21_row14) - column21_row3 * (column21_row1 - column21_row6).\n\n              let val := addmod(\n\n                mulmod(\n\n                  /*intermediate_value/ecdsa/signature0/exponentiate_key/bit_0*/ mload(0x38a0),\n\n                  addmod(\n\n                    /*column21_row9*/ mload(0x2e20),\n\n                    sub(PRIME, /*column21_row14*/ mload(0x2ec0)),\n\n                    PRIME),\n\n                  PRIME),\n\n                sub(\n\n                  PRIME,\n\n                  mulmod(\n\n                    /*column21_row3*/ mload(0x2d60),\n\n                    addmod(/*column21_row1*/ mload(0x2d20), sub(PRIME, /*column21_row6*/ mload(0x2dc0)), PRIME),\n\n                    PRIME)),\n\n                PRIME)\n\n\n\n              // Numerator: point^(trace_length / 4096) - trace_generator^(255 * trace_length / 256).\n\n              // val *= domains[16].\n\n              val := mulmod(val, /*domains[16]*/ mload(0x3d60), PRIME)\n\n              // Denominator: point^(trace_length / 16) - 1.\n\n              // val *= denominator_invs[2].\n\n              val := mulmod(val, /*denominator_invs[2]*/ mload(0x3ea0), PRIME)\n\n\n\n              // res += val * coefficients[153].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[153]*/ mload(0x1720), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for ecdsa/signature0/exponentiate_key/add_points/x: column21_row3 * column21_row3 - ecdsa__signature0__exponentiate_key__bit_0 * (column21_row1 + column21_row6 + column21_row17).\n\n              let val := addmod(\n\n                mulmod(/*column21_row3*/ mload(0x2d60), /*column21_row3*/ mload(0x2d60), PRIME),\n\n                sub(\n\n                  PRIME,\n\n                  mulmod(\n\n                    /*intermediate_value/ecdsa/signature0/exponentiate_key/bit_0*/ mload(0x38a0),\n\n                    addmod(\n\n                      addmod(/*column21_row1*/ mload(0x2d20), /*column21_row6*/ mload(0x2dc0), PRIME),\n\n                      /*column21_row17*/ mload(0x2f20),\n\n                      PRIME),\n\n                    PRIME)),\n\n                PRIME)\n\n\n\n              // Numerator: point^(trace_length / 4096) - trace_generator^(255 * trace_length / 256).\n\n              // val *= domains[16].\n\n              val := mulmod(val, /*domains[16]*/ mload(0x3d60), PRIME)\n\n              // Denominator: point^(trace_length / 16) - 1.\n\n              // val *= denominator_invs[2].\n\n              val := mulmod(val, /*denominator_invs[2]*/ mload(0x3ea0), PRIME)\n\n\n\n              // res += val * coefficients[154].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[154]*/ mload(0x1740), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for ecdsa/signature0/exponentiate_key/add_points/y: ecdsa__signature0__exponentiate_key__bit_0 * (column21_row9 + column21_row25) - column21_row3 * (column21_row1 - column21_row17).\n\n              let val := addmod(\n\n                mulmod(\n\n                  /*intermediate_value/ecdsa/signature0/exponentiate_key/bit_0*/ mload(0x38a0),\n\n                  addmod(/*column21_row9*/ mload(0x2e20), /*column21_row25*/ mload(0x2fc0), PRIME),\n\n                  PRIME),\n\n                sub(\n\n                  PRIME,\n\n                  mulmod(\n\n                    /*column21_row3*/ mload(0x2d60),\n\n                    addmod(\n\n                      /*column21_row1*/ mload(0x2d20),\n\n                      sub(PRIME, /*column21_row17*/ mload(0x2f20)),\n\n                      PRIME),\n\n                    PRIME)),\n\n                PRIME)\n\n\n\n              // Numerator: point^(trace_length / 4096) - trace_generator^(255 * trace_length / 256).\n\n              // val *= domains[16].\n\n              val := mulmod(val, /*domains[16]*/ mload(0x3d60), PRIME)\n\n              // Denominator: point^(trace_length / 16) - 1.\n\n              // val *= denominator_invs[2].\n\n              val := mulmod(val, /*denominator_invs[2]*/ mload(0x3ea0), PRIME)\n\n\n\n              // res += val * coefficients[155].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[155]*/ mload(0x1760), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for ecdsa/signature0/exponentiate_key/add_points/x_diff_inv: column21_row11 * (column21_row1 - column21_row6) - 1.\n\n              let val := addmod(\n\n                mulmod(\n\n                  /*column21_row11*/ mload(0x2e60),\n\n                  addmod(/*column21_row1*/ mload(0x2d20), sub(PRIME, /*column21_row6*/ mload(0x2dc0)), PRIME),\n\n                  PRIME),\n\n                sub(PRIME, 1),\n\n                PRIME)\n\n\n\n              // Numerator: point^(trace_length / 4096) - trace_generator^(255 * trace_length / 256).\n\n              // val *= domains[16].\n\n              val := mulmod(val, /*domains[16]*/ mload(0x3d60), PRIME)\n\n              // Denominator: point^(trace_length / 16) - 1.\n\n              // val *= denominator_invs[2].\n\n              val := mulmod(val, /*denominator_invs[2]*/ mload(0x3ea0), PRIME)\n\n\n\n              // res += val * coefficients[156].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[156]*/ mload(0x1780), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for ecdsa/signature0/exponentiate_key/copy_point/x: ecdsa__signature0__exponentiate_key__bit_neg_0 * (column21_row17 - column21_row1).\n\n              let val := mulmod(\n\n                /*intermediate_value/ecdsa/signature0/exponentiate_key/bit_neg_0*/ mload(0x38c0),\n\n                addmod(\n\n                  /*column21_row17*/ mload(0x2f20),\n\n                  sub(PRIME, /*column21_row1*/ mload(0x2d20)),\n\n                  PRIME),\n\n                PRIME)\n\n\n\n              // Numerator: point^(trace_length / 4096) - trace_generator^(255 * trace_length / 256).\n\n              // val *= domains[16].\n\n              val := mulmod(val, /*domains[16]*/ mload(0x3d60), PRIME)\n\n              // Denominator: point^(trace_length / 16) - 1.\n\n              // val *= denominator_invs[2].\n\n              val := mulmod(val, /*denominator_invs[2]*/ mload(0x3ea0), PRIME)\n\n\n\n              // res += val * coefficients[157].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[157]*/ mload(0x17a0), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for ecdsa/signature0/exponentiate_key/copy_point/y: ecdsa__signature0__exponentiate_key__bit_neg_0 * (column21_row25 - column21_row9).\n\n              let val := mulmod(\n\n                /*intermediate_value/ecdsa/signature0/exponentiate_key/bit_neg_0*/ mload(0x38c0),\n\n                addmod(\n\n                  /*column21_row25*/ mload(0x2fc0),\n\n                  sub(PRIME, /*column21_row9*/ mload(0x2e20)),\n\n                  PRIME),\n\n                PRIME)\n\n\n\n              // Numerator: point^(trace_length / 4096) - trace_generator^(255 * trace_length / 256).\n\n              // val *= domains[16].\n\n              val := mulmod(val, /*domains[16]*/ mload(0x3d60), PRIME)\n\n              // Denominator: point^(trace_length / 16) - 1.\n\n              // val *= denominator_invs[2].\n\n              val := mulmod(val, /*denominator_invs[2]*/ mload(0x3ea0), PRIME)\n\n\n\n              // res += val * coefficients[158].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[158]*/ mload(0x17c0), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for ecdsa/signature0/init_gen/x: column21_row7 - ecdsa/sig_config.shift_point.x.\n\n              let val := addmod(\n\n                /*column21_row7*/ mload(0x2de0),\n\n                sub(PRIME, /*ecdsa/sig_config.shift_point.x*/ mload(0x2e0)),\n\n                PRIME)\n\n\n\n              // Numerator: 1.\n\n              // val *= 1.\n\n              // Denominator: point^(trace_length / 8192) - 1.\n\n              // val *= denominator_invs[19].\n\n              val := mulmod(val, /*denominator_invs[19]*/ mload(0x40c0), PRIME)\n\n\n\n              // res += val * coefficients[159].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[159]*/ mload(0x17e0), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for ecdsa/signature0/init_gen/y: column21_row23 + ecdsa/sig_config.shift_point.y.\n\n              let val := addmod(\n\n                /*column21_row23*/ mload(0x2f80),\n\n                /*ecdsa/sig_config.shift_point.y*/ mload(0x300),\n\n                PRIME)\n\n\n\n              // Numerator: 1.\n\n              // val *= 1.\n\n              // Denominator: point^(trace_length / 8192) - 1.\n\n              // val *= denominator_invs[19].\n\n              val := mulmod(val, /*denominator_invs[19]*/ mload(0x40c0), PRIME)\n\n\n\n              // res += val * coefficients[160].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[160]*/ mload(0x1800), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for ecdsa/signature0/init_key/x: column21_row1 - ecdsa/sig_config.shift_point.x.\n\n              let val := addmod(\n\n                /*column21_row1*/ mload(0x2d20),\n\n                sub(PRIME, /*ecdsa/sig_config.shift_point.x*/ mload(0x2e0)),\n\n                PRIME)\n\n\n\n              // Numerator: 1.\n\n              // val *= 1.\n\n              // Denominator: point^(trace_length / 4096) - 1.\n\n              // val *= denominator_invs[20].\n\n              val := mulmod(val, /*denominator_invs[20]*/ mload(0x40e0), PRIME)\n\n\n\n              // res += val * coefficients[161].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[161]*/ mload(0x1820), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for ecdsa/signature0/init_key/y: column21_row9 - ecdsa/sig_config.shift_point.y.\n\n              let val := addmod(\n\n                /*column21_row9*/ mload(0x2e20),\n\n                sub(PRIME, /*ecdsa/sig_config.shift_point.y*/ mload(0x300)),\n\n                PRIME)\n\n\n\n              // Numerator: 1.\n\n              // val *= 1.\n\n              // Denominator: point^(trace_length / 4096) - 1.\n\n              // val *= denominator_invs[20].\n\n              val := mulmod(val, /*denominator_invs[20]*/ mload(0x40e0), PRIME)\n\n\n\n              // res += val * coefficients[162].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[162]*/ mload(0x1840), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for ecdsa/signature0/add_results/slope: column21_row8183 - (column21_row4089 + column21_row8191 * (column21_row8167 - column21_row4081)).\n\n              let val := addmod(\n\n                /*column21_row8183*/ mload(0x31c0),\n\n                sub(\n\n                  PRIME,\n\n                  addmod(\n\n                    /*column21_row4089*/ mload(0x30c0),\n\n                    mulmod(\n\n                      /*column21_row8191*/ mload(0x3220),\n\n                      addmod(\n\n                        /*column21_row8167*/ mload(0x3160),\n\n                        sub(PRIME, /*column21_row4081*/ mload(0x3080)),\n\n                        PRIME),\n\n                      PRIME),\n\n                    PRIME)),\n\n                PRIME)\n\n\n\n              // Numerator: 1.\n\n              // val *= 1.\n\n              // Denominator: point^(trace_length / 8192) - 1.\n\n              // val *= denominator_invs[19].\n\n              val := mulmod(val, /*denominator_invs[19]*/ mload(0x40c0), PRIME)\n\n\n\n              // res += val * coefficients[163].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[163]*/ mload(0x1860), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for ecdsa/signature0/add_results/x: column21_row8191 * column21_row8191 - (column21_row8167 + column21_row4081 + column21_row4102).\n\n              let val := addmod(\n\n                mulmod(/*column21_row8191*/ mload(0x3220), /*column21_row8191*/ mload(0x3220), PRIME),\n\n                sub(\n\n                  PRIME,\n\n                  addmod(\n\n                    addmod(/*column21_row8167*/ mload(0x3160), /*column21_row4081*/ mload(0x3080), PRIME),\n\n                    /*column21_row4102*/ mload(0x3120),\n\n                    PRIME)),\n\n                PRIME)\n\n\n\n              // Numerator: 1.\n\n              // val *= 1.\n\n              // Denominator: point^(trace_length / 8192) - 1.\n\n              // val *= denominator_invs[19].\n\n              val := mulmod(val, /*denominator_invs[19]*/ mload(0x40c0), PRIME)\n\n\n\n              // res += val * coefficients[164].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[164]*/ mload(0x1880), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for ecdsa/signature0/add_results/y: column21_row8183 + column21_row4110 - column21_row8191 * (column21_row8167 - column21_row4102).\n\n              let val := addmod(\n\n                addmod(/*column21_row8183*/ mload(0x31c0), /*column21_row4110*/ mload(0x3140), PRIME),\n\n                sub(\n\n                  PRIME,\n\n                  mulmod(\n\n                    /*column21_row8191*/ mload(0x3220),\n\n                    addmod(\n\n                      /*column21_row8167*/ mload(0x3160),\n\n                      sub(PRIME, /*column21_row4102*/ mload(0x3120)),\n\n                      PRIME),\n\n                    PRIME)),\n\n                PRIME)\n\n\n\n              // Numerator: 1.\n\n              // val *= 1.\n\n              // Denominator: point^(trace_length / 8192) - 1.\n\n              // val *= denominator_invs[19].\n\n              val := mulmod(val, /*denominator_invs[19]*/ mload(0x40c0), PRIME)\n\n\n\n              // res += val * coefficients[165].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[165]*/ mload(0x18a0), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for ecdsa/signature0/add_results/x_diff_inv: column22_row8160 * (column21_row8167 - column21_row4081) - 1.\n\n              let val := addmod(\n\n                mulmod(\n\n                  /*column22_row8160*/ mload(0x32e0),\n\n                  addmod(\n\n                    /*column21_row8167*/ mload(0x3160),\n\n                    sub(PRIME, /*column21_row4081*/ mload(0x3080)),\n\n                    PRIME),\n\n                  PRIME),\n\n                sub(PRIME, 1),\n\n                PRIME)\n\n\n\n              // Numerator: 1.\n\n              // val *= 1.\n\n              // Denominator: point^(trace_length / 8192) - 1.\n\n              // val *= denominator_invs[19].\n\n              val := mulmod(val, /*denominator_invs[19]*/ mload(0x40c0), PRIME)\n\n\n\n              // res += val * coefficients[166].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[166]*/ mload(0x18c0), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for ecdsa/signature0/extract_r/slope: column21_row8185 + ecdsa/sig_config.shift_point.y - column21_row4083 * (column21_row8177 - ecdsa/sig_config.shift_point.x).\n\n              let val := addmod(\n\n                addmod(\n\n                  /*column21_row8185*/ mload(0x31e0),\n\n                  /*ecdsa/sig_config.shift_point.y*/ mload(0x300),\n\n                  PRIME),\n\n                sub(\n\n                  PRIME,\n\n                  mulmod(\n\n                    /*column21_row4083*/ mload(0x30a0),\n\n                    addmod(\n\n                      /*column21_row8177*/ mload(0x3180),\n\n                      sub(PRIME, /*ecdsa/sig_config.shift_point.x*/ mload(0x2e0)),\n\n                      PRIME),\n\n                    PRIME)),\n\n                PRIME)\n\n\n\n              // Numerator: 1.\n\n              // val *= 1.\n\n              // Denominator: point^(trace_length / 8192) - 1.\n\n              // val *= denominator_invs[19].\n\n              val := mulmod(val, /*denominator_invs[19]*/ mload(0x40c0), PRIME)\n\n\n\n              // res += val * coefficients[167].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[167]*/ mload(0x18e0), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for ecdsa/signature0/extract_r/x: column21_row4083 * column21_row4083 - (column21_row8177 + ecdsa/sig_config.shift_point.x + column21_row5).\n\n              let val := addmod(\n\n                mulmod(/*column21_row4083*/ mload(0x30a0), /*column21_row4083*/ mload(0x30a0), PRIME),\n\n                sub(\n\n                  PRIME,\n\n                  addmod(\n\n                    addmod(\n\n                      /*column21_row8177*/ mload(0x3180),\n\n                      /*ecdsa/sig_config.shift_point.x*/ mload(0x2e0),\n\n                      PRIME),\n\n                    /*column21_row5*/ mload(0x2da0),\n\n                    PRIME)),\n\n                PRIME)\n\n\n\n              // Numerator: 1.\n\n              // val *= 1.\n\n              // Denominator: point^(trace_length / 8192) - 1.\n\n              // val *= denominator_invs[19].\n\n              val := mulmod(val, /*denominator_invs[19]*/ mload(0x40c0), PRIME)\n\n\n\n              // res += val * coefficients[168].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[168]*/ mload(0x1900), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for ecdsa/signature0/extract_r/x_diff_inv: column21_row8179 * (column21_row8177 - ecdsa/sig_config.shift_point.x) - 1.\n\n              let val := addmod(\n\n                mulmod(\n\n                  /*column21_row8179*/ mload(0x31a0),\n\n                  addmod(\n\n                    /*column21_row8177*/ mload(0x3180),\n\n                    sub(PRIME, /*ecdsa/sig_config.shift_point.x*/ mload(0x2e0)),\n\n                    PRIME),\n\n                  PRIME),\n\n                sub(PRIME, 1),\n\n                PRIME)\n\n\n\n              // Numerator: 1.\n\n              // val *= 1.\n\n              // Denominator: point^(trace_length / 8192) - 1.\n\n              // val *= denominator_invs[19].\n\n              val := mulmod(val, /*denominator_invs[19]*/ mload(0x40c0), PRIME)\n\n\n\n              // res += val * coefficients[169].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[169]*/ mload(0x1920), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for ecdsa/signature0/z_nonzero: column21_row15 * column21_row4091 - 1.\n\n              let val := addmod(\n\n                mulmod(/*column21_row15*/ mload(0x2ee0), /*column21_row4091*/ mload(0x30e0), PRIME),\n\n                sub(PRIME, 1),\n\n                PRIME)\n\n\n\n              // Numerator: 1.\n\n              // val *= 1.\n\n              // Denominator: point^(trace_length / 8192) - 1.\n\n              // val *= denominator_invs[19].\n\n              val := mulmod(val, /*denominator_invs[19]*/ mload(0x40c0), PRIME)\n\n\n\n              // res += val * coefficients[170].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[170]*/ mload(0x1940), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for ecdsa/signature0/r_and_w_nonzero: column21_row5 * column21_row4093 - 1.\n\n              let val := addmod(\n\n                mulmod(/*column21_row5*/ mload(0x2da0), /*column21_row4093*/ mload(0x3100), PRIME),\n\n                sub(PRIME, 1),\n\n                PRIME)\n\n\n\n              // Numerator: 1.\n\n              // val *= 1.\n\n              // Denominator: point^(trace_length / 4096) - 1.\n\n              // val *= denominator_invs[20].\n\n              val := mulmod(val, /*denominator_invs[20]*/ mload(0x40e0), PRIME)\n\n\n\n              // res += val * coefficients[171].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[171]*/ mload(0x1960), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for ecdsa/signature0/q_on_curve/x_squared: column21_row8187 - column21_row6 * column21_row6.\n\n              let val := addmod(\n\n                /*column21_row8187*/ mload(0x3200),\n\n                sub(\n\n                  PRIME,\n\n                  mulmod(/*column21_row6*/ mload(0x2dc0), /*column21_row6*/ mload(0x2dc0), PRIME)),\n\n                PRIME)\n\n\n\n              // Numerator: 1.\n\n              // val *= 1.\n\n              // Denominator: point^(trace_length / 8192) - 1.\n\n              // val *= denominator_invs[19].\n\n              val := mulmod(val, /*denominator_invs[19]*/ mload(0x40c0), PRIME)\n\n\n\n              // res += val * coefficients[172].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[172]*/ mload(0x1980), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for ecdsa/signature0/q_on_curve/on_curve: column21_row14 * column21_row14 - (column21_row6 * column21_row8187 + ecdsa/sig_config.alpha * column21_row6 + ecdsa/sig_config.beta).\n\n              let val := addmod(\n\n                mulmod(/*column21_row14*/ mload(0x2ec0), /*column21_row14*/ mload(0x2ec0), PRIME),\n\n                sub(\n\n                  PRIME,\n\n                  addmod(\n\n                    addmod(\n\n                      mulmod(/*column21_row6*/ mload(0x2dc0), /*column21_row8187*/ mload(0x3200), PRIME),\n\n                      mulmod(/*ecdsa/sig_config.alpha*/ mload(0x2c0), /*column21_row6*/ mload(0x2dc0), PRIME),\n\n                      PRIME),\n\n                    /*ecdsa/sig_config.beta*/ mload(0x320),\n\n                    PRIME)),\n\n                PRIME)\n\n\n\n              // Numerator: 1.\n\n              // val *= 1.\n\n              // Denominator: point^(trace_length / 8192) - 1.\n\n              // val *= denominator_invs[19].\n\n              val := mulmod(val, /*denominator_invs[19]*/ mload(0x40c0), PRIME)\n\n\n\n              // res += val * coefficients[173].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[173]*/ mload(0x19a0), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for ecdsa/init_addr: column19_row22 - initial_ecdsa_addr.\n\n              let val := addmod(\n\n                /*column19_row22*/ mload(0x29c0),\n\n                sub(PRIME, /*initial_ecdsa_addr*/ mload(0x340)),\n\n                PRIME)\n\n\n\n              // Numerator: 1.\n\n              // val *= 1.\n\n              // Denominator: point - 1.\n\n              // val *= denominator_invs[4].\n\n              val := mulmod(val, /*denominator_invs[4]*/ mload(0x3ee0), PRIME)\n\n\n\n              // res += val * coefficients[174].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[174]*/ mload(0x19c0), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for ecdsa/message_addr: column19_row4118 - (column19_row22 + 1).\n\n              let val := addmod(\n\n                /*column19_row4118*/ mload(0x2c20),\n\n                sub(PRIME, addmod(/*column19_row22*/ mload(0x29c0), 1, PRIME)),\n\n                PRIME)\n\n\n\n              // Numerator: 1.\n\n              // val *= 1.\n\n              // Denominator: point^(trace_length / 8192) - 1.\n\n              // val *= denominator_invs[19].\n\n              val := mulmod(val, /*denominator_invs[19]*/ mload(0x40c0), PRIME)\n\n\n\n              // res += val * coefficients[175].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[175]*/ mload(0x19e0), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for ecdsa/pubkey_addr: column19_row8214 - (column19_row4118 + 1).\n\n              let val := addmod(\n\n                /*column19_row8214*/ mload(0x2c60),\n\n                sub(PRIME, addmod(/*column19_row4118*/ mload(0x2c20), 1, PRIME)),\n\n                PRIME)\n\n\n\n              // Numerator: point - trace_generator^(8192 * (trace_length / 8192 - 1)).\n\n              // val *= domains[23].\n\n              val := mulmod(val, /*domains[23]*/ mload(0x3e40), PRIME)\n\n              // Denominator: point^(trace_length / 8192) - 1.\n\n              // val *= denominator_invs[19].\n\n              val := mulmod(val, /*denominator_invs[19]*/ mload(0x40c0), PRIME)\n\n\n\n              // res += val * coefficients[176].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[176]*/ mload(0x1a00), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for ecdsa/message_value0: column19_row4119 - column21_row15.\n\n              let val := addmod(\n\n                /*column19_row4119*/ mload(0x2c40),\n\n                sub(PRIME, /*column21_row15*/ mload(0x2ee0)),\n\n                PRIME)\n\n\n\n              // Numerator: 1.\n\n              // val *= 1.\n\n              // Denominator: point^(trace_length / 8192) - 1.\n\n              // val *= denominator_invs[19].\n\n              val := mulmod(val, /*denominator_invs[19]*/ mload(0x40c0), PRIME)\n\n\n\n              // res += val * coefficients[177].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[177]*/ mload(0x1a20), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n              {\n\n              // Constraint expression for ecdsa/pubkey_value0: column19_row23 - column21_row6.\n\n              let val := addmod(\n\n                /*column19_row23*/ mload(0x29e0),\n\n                sub(PRIME, /*column21_row6*/ mload(0x2dc0)),\n\n                PRIME)\n\n\n\n              // Numerator: 1.\n\n              // val *= 1.\n\n              // Denominator: point^(trace_length / 8192) - 1.\n\n              // val *= denominator_invs[19].\n\n              val := mulmod(val, /*denominator_invs[19]*/ mload(0x40c0), PRIME)\n\n\n\n              // res += val * coefficients[178].\n\n              res := addmod(res,\n\n                            mulmod(val, /*coefficients[178]*/ mload(0x1a40), PRIME),\n\n                            PRIME)\n\n              }\n\n\n\n            mstore(0, res)\n\n            return(0, 0x20)\n\n            }\n\n        }\n",
          "message": "CpuConstraintPoly.fallback uses assembly (CpuConstraintPoly.sol#91-5239)\n\t- CpuConstraintPoly.sol#93-5238\n"
        },
        {
          "name": "solc-version",
          "vulnerability_from_line": 5,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.6.12;\n",
          "message": "Detected issues with version pragma in CpuConstraintPoly.sol:\n\t- pragma solidity^0.6.12 (CpuConstraintPoly.sol#5): it allows old versions\n"
        }
      ]
    },
    "smartcheck": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 5,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.6.12;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 91,
          "vulnerability_to_line": null,
          "vulnerability_code": "    fallback() external {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 92,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint256 res;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 94,
          "vulnerability_to_line": null,
          "vulnerability_code": "            let PRIME := 0x800000000000011000000000000000000000000000000000000000000000001\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 96,
          "vulnerability_to_line": null,
          "vulnerability_code": "            calldatacopy(0x0, 0x0, /*Input data size*/ 0x3380)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 96,
          "vulnerability_to_line": null,
          "vulnerability_code": "            calldatacopy(0x0, 0x0, /*Input data size*/ 0x3380)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 97,
          "vulnerability_to_line": null,
          "vulnerability_code": "            let point := /*oods_point*/ mload(0x380)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 97,
          "vulnerability_to_line": null,
          "vulnerability_code": "            let point := /*oods_point*/ mload(0x380)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 98,
          "vulnerability_to_line": null,
          "vulnerability_code": "            function expmod(base, exponent, modulus) -> result {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 98,
          "vulnerability_to_line": null,
          "vulnerability_code": "            function expmod(base, exponent, modulus) -> result {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 98,
          "vulnerability_to_line": null,
          "vulnerability_code": "            function expmod(base, exponent, modulus) -> result {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 99,
          "vulnerability_to_line": null,
          "vulnerability_code": "              let p := /*expmod_context*/ 0x43a0\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 100,
          "vulnerability_to_line": null,
          "vulnerability_code": "              mstore(p, 0x20)                 // Length of Base.\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 101,
          "vulnerability_to_line": null,
          "vulnerability_code": "              mstore(add(p, 0x20), 0x20)      // Length of Exponent.\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 101,
          "vulnerability_to_line": null,
          "vulnerability_code": "              mstore(add(p, 0x20), 0x20)      // Length of Exponent.\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 102,
          "vulnerability_to_line": null,
          "vulnerability_code": "              mstore(add(p, 0x40), 0x20)      // Length of Modulus.\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 102,
          "vulnerability_to_line": null,
          "vulnerability_code": "              mstore(add(p, 0x40), 0x20)      // Length of Modulus.\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 103,
          "vulnerability_to_line": null,
          "vulnerability_code": "              mstore(add(p, 0x60), base)      // Base.\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 103,
          "vulnerability_to_line": null,
          "vulnerability_code": "              mstore(add(p, 0x60), base)      // Base.\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 104,
          "vulnerability_to_line": null,
          "vulnerability_code": "              mstore(add(p, 0x80), exponent)  // Exponent.\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 104,
          "vulnerability_to_line": null,
          "vulnerability_code": "              mstore(add(p, 0x80), exponent)  // Exponent.\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 105,
          "vulnerability_to_line": null,
          "vulnerability_code": "              mstore(add(p, 0xa0), modulus)   // Modulus.\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 105,
          "vulnerability_to_line": null,
          "vulnerability_code": "              mstore(add(p, 0xa0), modulus)   // Modulus.\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 107,
          "vulnerability_to_line": null,
          "vulnerability_code": "              if iszero(staticcall(not(0), 0x05, p, 0xc0, p, 0x20)) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 107,
          "vulnerability_to_line": null,
          "vulnerability_code": "              if iszero(staticcall(not(0), 0x05, p, 0xc0, p, 0x20)) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 107,
          "vulnerability_to_line": null,
          "vulnerability_code": "              if iszero(staticcall(not(0), 0x05, p, 0xc0, p, 0x20)) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 107,
          "vulnerability_to_line": null,
          "vulnerability_code": "              if iszero(staticcall(not(0), 0x05, p, 0xc0, p, 0x20)) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 107,
          "vulnerability_to_line": null,
          "vulnerability_code": "              if iszero(staticcall(not(0), 0x05, p, 0xc0, p, 0x20)) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 108,
          "vulnerability_to_line": null,
          "vulnerability_code": "                revert(0, 0)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 108,
          "vulnerability_to_line": null,
          "vulnerability_code": "                revert(0, 0)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 110,
          "vulnerability_to_line": null,
          "vulnerability_code": "              result := mload(p)\n",
          "message": null
        }
      ]
    },
    "oyente": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": []
    },
    "mythril": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": []
    },
    "osiris": {
      "successfull_analysis": false,
      "errors": [
        "Solidity compilation failed"
      ],
      "vulnerability_findings": []
    }
  }
}