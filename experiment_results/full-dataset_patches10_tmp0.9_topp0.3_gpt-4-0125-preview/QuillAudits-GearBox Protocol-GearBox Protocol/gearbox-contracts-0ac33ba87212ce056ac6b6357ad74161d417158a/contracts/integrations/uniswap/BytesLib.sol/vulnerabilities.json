{
  "smartbugs_completed": true,
  "analyzer_results": {
    "semgrep": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 19,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_length + 31 >= _length, 'slice_overflow');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 20,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_start + _length >= _start, 'slice_overflow');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 21,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_bytes.length >= _start + _length, 'slice_outOfBounds');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 81,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_start + 20 >= _start, 'toAddress_overflow');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 82,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_bytes.length >= _start + 20, 'toAddress_outOfBounds');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 93,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_start + 3 >= _start, 'toUint24_overflow');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 94,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_bytes.length >= _start + 3, 'toUint24_outOfBounds');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        }
      ]
    },
    "slither": {
      "successfull_analysis": true,
      "errors": [
        "EXIT_CODE_14"
      ],
      "vulnerability_findings": [
        {
          "name": "constant-function",
          "vulnerability_from_line": 14,
          "vulnerability_to_line": 80,
          "vulnerability_code": "    function slice(\n\n        bytes memory _bytes,\n\n        uint256 _start,\n\n        uint256 _length\n\n    ) internal pure returns (bytes memory) {\n\n        require(_length + 31 >= _length, 'slice_overflow');\n\n        require(_start + _length >= _start, 'slice_overflow');\n\n        require(_bytes.length >= _start + _length, 'slice_outOfBounds');\n\n\n\n        bytes memory tempBytes;\n\n\n\n        assembly {\n\n            switch iszero(_length)\n\n            case 0 {\n\n            // Get a location of some free memory and store it in tempBytes as\n\n            // Solidity does for memory variables.\n\n                tempBytes := mload(0x40)\n\n\n\n            // The first word of the slice result is potentially a partial\n\n            // word read from the original array. To read it, we calculate\n\n            // the length of that partial word and start copying that many\n\n            // bytes into the array. The first word we copy will start with\n\n            // data we don't care about, but the last `lengthmod` bytes will\n\n            // land at the beginning of the contents of the new array. When\n\n            // we're done copying, we overwrite the full first word with\n\n            // the actual length of the slice.\n\n                let lengthmod := and(_length, 31)\n\n\n\n            // The multiplication in the next line is necessary\n\n            // because when slicing multiples of 32 bytes (lengthmod == 0)\n\n            // the following copy loop was copying the origin's length\n\n            // and then ending prematurely not copying everything it should.\n\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n\n                let end := add(mc, _length)\n\n\n\n                for {\n\n                // The multiplication in the next line has the same exact purpose\n\n                // as the one above.\n\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n\n                } lt(mc, end) {\n\n                    mc := add(mc, 0x20)\n\n                    cc := add(cc, 0x20)\n\n                } {\n\n                    mstore(mc, mload(cc))\n\n                }\n\n\n\n                mstore(tempBytes, _length)\n\n\n\n            //update free-memory pointer\n\n            //allocating the array padded to 32 bytes like the compiler does now\n\n                mstore(0x40, and(add(mc, 31), not(31)))\n\n            }\n\n            //if we want a zero-length slice let's just return a zero-length array\n\n            default {\n\n                tempBytes := mload(0x40)\n\n            //zero out the 32 bytes slice we are about to return\n\n            //we need to do it because Solidity does not garbage collect\n\n                mstore(tempBytes, 0)\n\n\n\n                mstore(0x40, add(tempBytes, 0x20))\n\n            }\n\n        }\n\n\n\n        return tempBytes;\n\n    }\n\n\n",
          "message": "BytesLib.slice (BytesLib.sol#14-80) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 80,
          "vulnerability_to_line": 92,
          "vulnerability_code": "    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\n\n        require(_start + 20 >= _start, 'toAddress_overflow');\n\n        require(_bytes.length >= _start + 20, 'toAddress_outOfBounds');\n\n        address tempAddress;\n\n\n\n        assembly {\n\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\n\n        }\n\n\n\n        return tempAddress;\n\n    }\n\n\n",
          "message": "BytesLib.toAddress (BytesLib.sol#80-92) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 92,
          "vulnerability_to_line": 103,
          "vulnerability_code": "    function toUint24(bytes memory _bytes, uint256 _start) internal pure returns (uint24) {\n\n        require(_start + 3 >= _start, 'toUint24_overflow');\n\n        require(_bytes.length >= _start + 3, 'toUint24_outOfBounds');\n\n        uint24 tempUint;\n\n\n\n        assembly {\n\n            tempUint := mload(add(add(_bytes, 0x3), _start))\n\n        }\n\n\n\n        return tempUint;\n\n    }\n",
          "message": "BytesLib.toUint24 (BytesLib.sol#92-103) is declared view but contains assembly code\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 14,
          "vulnerability_to_line": 80,
          "vulnerability_code": "    function slice(\n\n        bytes memory _bytes,\n\n        uint256 _start,\n\n        uint256 _length\n\n    ) internal pure returns (bytes memory) {\n\n        require(_length + 31 >= _length, 'slice_overflow');\n\n        require(_start + _length >= _start, 'slice_overflow');\n\n        require(_bytes.length >= _start + _length, 'slice_outOfBounds');\n\n\n\n        bytes memory tempBytes;\n\n\n\n        assembly {\n\n            switch iszero(_length)\n\n            case 0 {\n\n            // Get a location of some free memory and store it in tempBytes as\n\n            // Solidity does for memory variables.\n\n                tempBytes := mload(0x40)\n\n\n\n            // The first word of the slice result is potentially a partial\n\n            // word read from the original array. To read it, we calculate\n\n            // the length of that partial word and start copying that many\n\n            // bytes into the array. The first word we copy will start with\n\n            // data we don't care about, but the last `lengthmod` bytes will\n\n            // land at the beginning of the contents of the new array. When\n\n            // we're done copying, we overwrite the full first word with\n\n            // the actual length of the slice.\n\n                let lengthmod := and(_length, 31)\n\n\n\n            // The multiplication in the next line is necessary\n\n            // because when slicing multiples of 32 bytes (lengthmod == 0)\n\n            // the following copy loop was copying the origin's length\n\n            // and then ending prematurely not copying everything it should.\n\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n\n                let end := add(mc, _length)\n\n\n\n                for {\n\n                // The multiplication in the next line has the same exact purpose\n\n                // as the one above.\n\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n\n                } lt(mc, end) {\n\n                    mc := add(mc, 0x20)\n\n                    cc := add(cc, 0x20)\n\n                } {\n\n                    mstore(mc, mload(cc))\n\n                }\n\n\n\n                mstore(tempBytes, _length)\n\n\n\n            //update free-memory pointer\n\n            //allocating the array padded to 32 bytes like the compiler does now\n\n                mstore(0x40, and(add(mc, 31), not(31)))\n\n            }\n\n            //if we want a zero-length slice let's just return a zero-length array\n\n            default {\n\n                tempBytes := mload(0x40)\n\n            //zero out the 32 bytes slice we are about to return\n\n            //we need to do it because Solidity does not garbage collect\n\n                mstore(tempBytes, 0)\n\n\n\n                mstore(0x40, add(tempBytes, 0x20))\n\n            }\n\n        }\n\n\n\n        return tempBytes;\n\n    }\n\n\n",
          "message": "BytesLib.slice uses assembly (BytesLib.sol#14-80)\n\t- BytesLib.sol#25-77\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 80,
          "vulnerability_to_line": 92,
          "vulnerability_code": "    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\n\n        require(_start + 20 >= _start, 'toAddress_overflow');\n\n        require(_bytes.length >= _start + 20, 'toAddress_outOfBounds');\n\n        address tempAddress;\n\n\n\n        assembly {\n\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\n\n        }\n\n\n\n        return tempAddress;\n\n    }\n\n\n",
          "message": "BytesLib.toAddress uses assembly (BytesLib.sol#80-92)\n\t- BytesLib.sol#85-89\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 92,
          "vulnerability_to_line": 103,
          "vulnerability_code": "    function toUint24(bytes memory _bytes, uint256 _start) internal pure returns (uint24) {\n\n        require(_start + 3 >= _start, 'toUint24_overflow');\n\n        require(_bytes.length >= _start + 3, 'toUint24_outOfBounds');\n\n        uint24 tempUint;\n\n\n\n        assembly {\n\n            tempUint := mload(add(add(_bytes, 0x3), _start))\n\n        }\n\n\n\n        return tempUint;\n\n    }\n",
          "message": "BytesLib.toUint24 uses assembly (BytesLib.sol#92-103)\n\t- BytesLib.sol#97-101\n"
        },
        {
          "name": "solc-version",
          "vulnerability_from_line": 11,
          "vulnerability_to_line": 13,
          "vulnerability_code": "pragma solidity >=0.5.0 <0.8.0;\n\n\n",
          "message": "Detected issues with version pragma in BytesLib.sol:\n\t- pragma solidity>=0.5.0<0.8.0 (BytesLib.sol#11-13): is has a complex pragma\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 15,
          "vulnerability_to_line": 16,
          "vulnerability_code": "        bytes memory _bytes,\n",
          "message": "Parameter '_bytes' of BytesLib.slice (BytesLib.sol#15-16) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 16,
          "vulnerability_to_line": 17,
          "vulnerability_code": "        uint256 _start,\n",
          "message": "Parameter '_start' of BytesLib.slice (BytesLib.sol#16-17) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 17,
          "vulnerability_to_line": 18,
          "vulnerability_code": "        uint256 _length\n",
          "message": "Parameter '_length' of BytesLib.slice (BytesLib.sol#17-18) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 80,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\n",
          "message": "Parameter '_bytes' of BytesLib.toAddress (BytesLib.sol#80) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 80,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\n",
          "message": "Parameter '_start' of BytesLib.toAddress (BytesLib.sol#80) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 92,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function toUint24(bytes memory _bytes, uint256 _start) internal pure returns (uint24) {\n",
          "message": "Parameter '_bytes' of BytesLib.toUint24 (BytesLib.sol#92) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 92,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function toUint24(bytes memory _bytes, uint256 _start) internal pure returns (uint24) {\n",
          "message": "Parameter '_start' of BytesLib.toUint24 (BytesLib.sol#92) is not in mixedCase\n"
        }
      ]
    },
    "smartcheck": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 11,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity >=0.5.0 <0.8.0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 11,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity >=0.5.0 <0.8.0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 14,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function slice(\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 80,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 92,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function toUint24(bytes memory _bytes, uint256 _start) internal pure returns (uint24) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 25,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 85,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 97,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        }
      ]
    },
    "oyente": {
      "successfull_analysis": false,
      "errors": [
        "exception (IndexError: pop from empty list)"
      ],
      "vulnerability_findings": []
    },
    "mythril": {
      "successfull_analysis": false,
      "errors": [
        "Solc experienced a fatal error"
      ],
      "vulnerability_findings": []
    },
    "osiris": {
      "successfull_analysis": false,
      "errors": [
        "Solidity compilation failed"
      ],
      "vulnerability_findings": []
    }
  }
}