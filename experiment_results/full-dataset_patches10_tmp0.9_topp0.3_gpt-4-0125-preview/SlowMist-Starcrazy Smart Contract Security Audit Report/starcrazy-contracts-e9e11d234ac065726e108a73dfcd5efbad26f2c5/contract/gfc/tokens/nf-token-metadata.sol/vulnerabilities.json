{
  "smartbugs_completed": true,
  "analyzer_results": {
    "semgrep": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 319,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor() public {\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 320,
          "vulnerability_to_line": null,
          "vulnerability_code": "        supportedInterfaces[0x01ffc9a7] = true; // ERC165\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 321,
          "vulnerability_to_line": null,
          "vulnerability_code": "    }\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 512,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor() public {\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 513,
          "vulnerability_to_line": null,
          "vulnerability_code": "        supportedInterfaces[0x80ac58cd] = true; // ERC721\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 514,
          "vulnerability_to_line": null,
          "vulnerability_code": "    }\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 845,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor() public {\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 846,
          "vulnerability_to_line": null,
          "vulnerability_code": "        supportedInterfaces[0x5b5e139f] = true; // ERC721Metadata\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 847,
          "vulnerability_to_line": null,
          "vulnerability_code": "    }\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 214,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(product / _factor1 == _factor2, OVERFLOW);\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 229,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_divisor > 0, DIVISION_BY_ZERO);\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 245,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_subtrahend <= _minuend, SUBTRAHEND_GREATER_THEN_MINUEND);\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 261,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(sum >= _addend1, OVERFLOW);\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 276,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_divisor != 0, DIVISION_BY_ZERO);\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        }
      ]
    },
    "slither": {
      "successfull_analysis": true,
      "errors": [
        "EXIT_CODE_67"
      ],
      "vulnerability_findings": [
        {
          "name": "uninitialized-state",
          "vulnerability_from_line": 829,
          "vulnerability_to_line": null,
          "vulnerability_code": "    string internal nftName;\n",
          "message": "NFTokenMetadata.nftName (nf-token-metadata.sol#829) is never initialized. It is used in:\n\t- name (nf-token-metadata.sol#853-856)\n"
        },
        {
          "name": "uninitialized-state",
          "vulnerability_from_line": 834,
          "vulnerability_to_line": null,
          "vulnerability_code": "    string internal nftSymbol;\n",
          "message": "NFTokenMetadata.nftSymbol (nf-token-metadata.sol#834) is never initialized. It is used in:\n\t- symbol (nf-token-metadata.sol#861-864)\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 353,
          "vulnerability_to_line": 371,
          "vulnerability_code": "    function isContract(address _addr)\n\n        internal\n\n        view\n\n        returns (bool addressCheck)\n\n    {\n\n        // This method relies in extcodesize, which returns 0 for contracts in\n\n        // construction, since the code is only stored at the end of the\n\n        // constructor execution.\n\n\n\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n\n        // for accounts without code, i.e. `keccak256('')`\n\n        bytes32 codehash;\n\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n\n        assembly {\n\n            codehash := extcodehash(_addr)\n\n        } // solhint-disable-line\n\n        addressCheck = (codehash != 0x0 && codehash != accountHash);\n",
          "message": "AddressUtils.isContract (nf-token-metadata.sol#353-371) is declared view but contains assembly code\n"
        },
        {
          "name": "erc20-interface",
          "vulnerability_from_line": 9,
          "vulnerability_to_line": 145,
          "vulnerability_code": "interface ERC721 {\n\n    /**\n\n     * @dev Emits when ownership of any NFT changes by any mechanism. This event emits when NFTs are\n\n     * created (`from` == 0) and destroyed (`to` == 0). Exception: during contract creation, any\n\n     * number of NFTs may be created and assigned without emitting Transfer. At the time of any\n\n     * transfer, the approved address for that NFT (if any) is reset to none.\n\n     */\n\n    event Transfer(\n\n        address indexed _from,\n\n        address indexed _to,\n\n        uint256 indexed _tokenId\n\n    );\n\n\n\n    /**\n\n     * @dev This emits when the approved address for an NFT is changed or reaffirmed. The zero\n\n     * address indicates there is no approved address. When a Transfer event emits, this also\n\n     * indicates that the approved address for that NFT (if any) is reset to none.\n\n     */\n\n    event Approval(\n\n        address indexed _owner,\n\n        address indexed _approved,\n\n        uint256 indexed _tokenId\n\n    );\n\n\n\n    /**\n\n     * @dev This emits when an operator is enabled or disabled for an owner. The operator can manage\n\n     * all NFTs of the owner.\n\n     */\n\n    event ApprovalForAll(\n\n        address indexed _owner,\n\n        address indexed _operator,\n\n        bool _approved\n\n    );\n\n\n\n    /**\n\n     * @dev Transfers the ownership of an NFT from one address to another address.\n\n     * @notice Throws unless `msg.sender` is the current owner, an authorized operator, or the\n\n     * approved address for this NFT. Throws if `_from` is not the current owner. Throws if `_to` is\n\n     * the zero address. Throws if `_tokenId` is not a valid NFT. When transfer is complete, this\n\n     * function checks if `_to` is a smart contract (code size > 0). If so, it calls\n\n     * `onERC721Received` on `_to` and throws if the return value is not\n\n     * `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`.\n\n     * @param _from The current owner of the NFT.\n\n     * @param _to The new owner.\n\n     * @param _tokenId The NFT to transfer.\n\n     * @param _data Additional data with no specified format, sent in call to `_to`.\n\n     */\n\n    function safeTransferFrom(\n\n        address _from,\n\n        address _to,\n\n        uint256 _tokenId,\n\n        bytes calldata _data\n\n    ) external;\n\n\n\n    /**\n\n     * @dev Transfers the ownership of an NFT from one address to another address.\n\n     * @notice This works identically to the other function with an extra data parameter, except this\n\n     * function just sets data to \"\"\n\n     * @param _from The current owner of the NFT.\n\n     * @param _to The new owner.\n\n     * @param _tokenId The NFT to transfer.\n\n     */\n\n    function safeTransferFrom(\n\n        address _from,\n\n        address _to,\n\n        uint256 _tokenId\n\n    ) external;\n\n\n\n    /**\n\n     * @dev Throws unless `msg.sender` is the current owner, an authorized operator, or the approved\n\n     * address for this NFT. Throws if `_from` is not the current owner. Throws if `_to` is the zero\n\n     * address. Throws if `_tokenId` is not a valid NFT.\n\n     * @notice The caller is responsible to confirm that `_to` is capable of receiving NFTs or else\n\n     * they mayb be permanently lost.\n\n     * @param _from The current owner of the NFT.\n\n     * @param _to The new owner.\n\n     * @param _tokenId The NFT to transfer.\n\n     */\n\n    function transferFrom(\n\n        address _from,\n\n        address _to,\n\n        uint256 _tokenId\n\n    ) external;\n\n\n\n    /**\n\n     * @dev Set or reaffirm the approved address for an NFT.\n\n     * @notice The zero address indicates there is no approved address. Throws unless `msg.sender` is\n\n     * the current NFT owner, or an authorized operator of the current owner.\n\n     * @param _approved The new approved NFT controller.\n\n     * @param _tokenId The NFT to approve.\n\n     */\n\n    function approve(address _approved, uint256 _tokenId) external;\n\n\n\n    /**\n\n     * @dev Enables or disables approval for a third party (\"operator\") to manage all of\n\n     * `msg.sender`'s assets. It also emits the ApprovalForAll event.\n\n     * @notice The contract MUST allow multiple operators per owner.\n\n     * @param _operator Address to add to the set of authorized operators.\n\n     * @param _approved True if the operators is approved, false to revoke approval.\n\n     */\n\n    function setApprovalForAll(address _operator, bool _approved) external;\n\n\n\n    /**\n\n     * @dev Returns the number of NFTs owned by `_owner`. NFTs assigned to the zero address are\n\n     * considered invalid, and this function throws for queries about the zero address.\n\n     * @param _owner Address for whom to query the balance.\n\n     * @return Balance of _owner.\n\n     */\n\n    function balanceOf(address _owner) external view returns (uint256);\n\n\n\n    /**\n\n     * @dev Returns the address of the owner of the NFT. NFTs assigned to zero address are considered\n\n     * invalid, and queries about them do throw.\n\n     * @param _tokenId The identifier for an NFT.\n\n     * @return Address of _tokenId owner.\n\n     */\n\n    function ownerOf(uint256 _tokenId) external view returns (address);\n\n\n\n    /**\n\n     * @dev Get the approved address for a single NFT.\n\n     * @notice Throws if `_tokenId` is not a valid NFT.\n\n     * @param _tokenId The NFT to find the approved address for.\n\n     * @return Address that _tokenId is approved for.\n\n     */\n\n    function getApproved(uint256 _tokenId) external view returns (address);\n\n\n\n    /**\n\n     * @dev Returns true if `_operator` is an approved operator for `_owner`, false otherwise.\n\n     * @param _owner The address that owns the NFTs.\n\n     * @param _operator The address that acts on behalf of the owner.\n\n     * @return True if approved for all, false otherwise.\n\n     */\n\n    function isApprovedForAll(address _owner, address _operator)\n\n        external\n\n        view\n\n        returns (bool);\n",
          "message": "ERC721 (nf-token-metadata.sol#9-145) has incorrect ERC20 function interface(s):\n\t-transferFrom (nf-token-metadata.sol#87-91)\n\t-approve (nf-token-metadata.sol#100)\n"
        },
        {
          "name": "erc20-interface",
          "vulnerability_from_line": 385,
          "vulnerability_to_line": 786,
          "vulnerability_code": "contract NFToken is ERC721, SupportsInterface {\n\n    using SafeMath for uint256;\n\n    using AddressUtils for address;\n\n\n\n    /**\n\n     * List of revert message codes. Implementing dApp should handle showing the correct message.\n\n     * Based on 0xcert framework error codes.\n\n     */\n\n    string constant ZERO_ADDRESS = \"003001\";\n\n    string constant NOT_VALID_NFT = \"003002\";\n\n    string constant NOT_OWNER_OR_OPERATOR = \"003003\";\n\n    string constant NOT_OWNER_APPROWED_OR_OPERATOR = \"003004\";\n\n    string constant NOT_ABLE_TO_RECEIVE_NFT = \"003005\";\n\n    string constant NFT_ALREADY_EXISTS = \"003006\";\n\n    string constant NOT_OWNER = \"003007\";\n\n    string constant IS_OWNER = \"003008\";\n\n\n\n    /**\n\n     * @dev Magic value of a smart contract that can recieve NFT.\n\n     * Equal to: bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\")).\n\n     */\n\n    bytes4 internal constant MAGIC_ON_ERC721_RECEIVED = 0x150b7a02;\n\n\n\n    /**\n\n     * @dev A mapping from NFT ID to the address that owns it.\n\n     */\n\n    mapping(uint256 => address) internal idToOwner;\n\n\n\n    /**\n\n     * @dev Mapping from NFT ID to approved address.\n\n     */\n\n    mapping(uint256 => address) internal idToApproval;\n\n\n\n    /**\n\n     * @dev Mapping from owner address to count of his tokens.\n\n     */\n\n    mapping(address => uint256) private ownerToNFTokenCount;\n\n\n\n    /**\n\n     * @dev Mapping from owner address to mapping of operator addresses.\n\n     */\n\n    mapping(address => mapping(address => bool)) internal ownerToOperators;\n\n\n\n    /**\n\n     * @dev Emits when ownership of any NFT changes by any mechanism. This event emits when NFTs are\n\n     * created (`from` == 0) and destroyed (`to` == 0). Exception: during contract creation, any\n\n     * number of NFTs may be created and assigned without emitting Transfer. At the time of any\n\n     * transfer, the approved address for that NFT (if any) is reset to none.\n\n     * @param _from Sender of NFT (if address is zero address it indicates token creation).\n\n     * @param _to Receiver of NFT (if address is zero address it indicates token destruction).\n\n     * @param _tokenId The NFT that got transfered.\n\n     */\n\n    event Transfer(\n\n        address indexed _from,\n\n        address indexed _to,\n\n        uint256 indexed _tokenId\n\n    );\n\n\n\n    /**\n\n     * @dev This emits when the approved address for an NFT is changed or reaffirmed. The zero\n\n     * address indicates there is no approved address. When a Transfer event emits, this also\n\n     * indicates that the approved address for that NFT (if any) is reset to none.\n\n     * @param _owner Owner of NFT.\n\n     * @param _approved Address that we are approving.\n\n     * @param _tokenId NFT which we are approving.\n\n     */\n\n    event Approval(\n\n        address indexed _owner,\n\n        address indexed _approved,\n\n        uint256 indexed _tokenId\n\n    );\n\n\n\n    /**\n\n     * @dev This emits when an operator is enabled or disabled for an owner. The operator can manage\n\n     * all NFTs of the owner.\n\n     * @param _owner Owner of NFT.\n\n     * @param _operator Address to which we are setting operator rights.\n\n     * @param _approved Status of operator rights(true if operator rights are given and false if\n\n     * revoked).\n\n     */\n\n    event ApprovalForAll(\n\n        address indexed _owner,\n\n        address indexed _operator,\n\n        bool _approved\n\n    );\n\n\n\n    /**\n\n     * @dev Guarantees that the msg.sender is an owner or operator of the given NFT.\n\n     * @param _tokenId ID of the NFT to validate.\n\n     */\n\n    modifier canOperate(uint256 _tokenId) {\n\n        address tokenOwner = idToOwner[_tokenId];\n\n        require(\n\n            tokenOwner == msg.sender ||\n\n                ownerToOperators[tokenOwner][msg.sender],\n\n            NOT_OWNER_OR_OPERATOR\n\n        );\n\n        _;\n\n    }\n\n\n\n    /**\n\n     * @dev Guarantees that the msg.sender is allowed to transfer NFT.\n\n     * @param _tokenId ID of the NFT to transfer.\n\n     */\n\n    modifier canTransfer(uint256 _tokenId) {\n\n        address tokenOwner = idToOwner[_tokenId];\n\n        require(\n\n            tokenOwner == msg.sender ||\n\n                idToApproval[_tokenId] == msg.sender ||\n\n                ownerToOperators[tokenOwner][msg.sender],\n\n            NOT_OWNER_APPROWED_OR_OPERATOR\n\n        );\n\n        _;\n\n    }\n\n\n\n    /**\n\n     * @dev Guarantees that _tokenId is a valid Token.\n\n     * @param _tokenId ID of the NFT to validate.\n\n     */\n\n    modifier validNFToken(uint256 _tokenId) {\n\n        require(idToOwner[_tokenId] != address(0), NOT_VALID_NFT);\n\n        _;\n\n    }\n\n\n\n    /**\n\n     * @dev Contract constructor.\n\n     */\n\n    constructor() public {\n\n        supportedInterfaces[0x80ac58cd] = true; // ERC721\n\n    }\n\n\n\n    /**\n\n     * @dev Transfers the ownership of an NFT from one address to another address. This function can\n\n     * be changed to payable.\n\n     * @notice Throws unless `msg.sender` is the current owner, an authorized operator, or the\n\n     * approved address for this NFT. Throws if `_from` is not the current owner. Throws if `_to` is\n\n     * the zero address. Throws if `_tokenId` is not a valid NFT. When transfer is complete, this\n\n     * function checks if `_to` is a smart contract (code size > 0). If so, it calls\n\n     * `onERC721Received` on `_to` and throws if the return value is not\n\n     * `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`.\n\n     * @param _from The current owner of the NFT.\n\n     * @param _to The new owner.\n\n     * @param _tokenId The NFT to transfer.\n\n     * @param _data Additional data with no specified format, sent in call to `_to`.\n\n     */\n\n    function safeTransferFrom(\n\n        address _from,\n\n        address _to,\n\n        uint256 _tokenId,\n\n        bytes calldata _data\n\n    ) external {\n\n        _safeTransferFrom(_from, _to, _tokenId, _data);\n\n    }\n\n\n\n    /**\n\n     * @dev Transfers the ownership of an NFT from one address to another address. This function can\n\n     * be changed to payable.\n\n     * @notice This works identically to the other function with an extra data parameter, except this\n\n     * function just sets data to \"\"\n\n     * @param _from The current owner of the NFT.\n\n     * @param _to The new owner.\n\n     * @param _tokenId The NFT to transfer.\n\n     */\n\n    function safeTransferFrom(\n\n        address _from,\n\n        address _to,\n\n        uint256 _tokenId\n\n    ) external {\n\n        _safeTransferFrom(_from, _to, _tokenId, \"\");\n\n    }\n\n\n\n    /**\n\n     * @dev Throws unless `msg.sender` is the current owner, an authorized operator, or the approved\n\n     * address for this NFT. Throws if `_from` is not the current owner. Throws if `_to` is the zero\n\n     * address. Throws if `_tokenId` is not a valid NFT. This function can be changed to payable.\n\n     * @notice The caller is responsible to confirm that `_to` is capable of receiving NFTs or else\n\n     * they maybe be permanently lost.\n\n     * @param _from The current owner of the NFT.\n\n     * @param _to The new owner.\n\n     * @param _tokenId The NFT to transfer.\n\n     */\n\n    function transferFrom(\n\n        address _from,\n\n        address _to,\n\n        uint256 _tokenId\n\n    ) external canTransfer(_tokenId) validNFToken(_tokenId) {\n\n        address tokenOwner = idToOwner[_tokenId];\n\n        require(tokenOwner == _from, NOT_OWNER);\n\n        require(_to != address(0), ZERO_ADDRESS);\n\n\n\n        _transfer(_to, _tokenId);\n\n    }\n\n\n\n    /**\n\n     * @dev Set or reaffirm the approved address for an NFT. This function can be changed to payable.\n\n     * @notice The zero address indicates there is no approved address. Throws unless `msg.sender` is\n\n     * the current NFT owner, or an authorized operator of the current owner.\n\n     * @param _approved Address to be approved for the given NFT ID.\n\n     * @param _tokenId ID of the token to be approved.\n\n     */\n\n    function approve(address _approved, uint256 _tokenId)\n\n        external\n\n        canOperate(_tokenId)\n\n        validNFToken(_tokenId)\n\n    {\n\n        address tokenOwner = idToOwner[_tokenId];\n\n        require(_approved != tokenOwner, IS_OWNER);\n\n\n\n        idToApproval[_tokenId] = _approved;\n\n        emit Approval(tokenOwner, _approved, _tokenId);\n\n    }\n\n\n\n    /**\n\n     * @dev Enables or disables approval for a third party (\"operator\") to manage all of\n\n     * `msg.sender`'s assets. It also emits the ApprovalForAll event.\n\n     * @notice This works even if sender doesn't own any tokens at the time.\n\n     * @param _operator Address to add to the set of authorized operators.\n\n     * @param _approved True if the operators is approved, false to revoke approval.\n\n     */\n\n    function setApprovalForAll(address _operator, bool _approved) external {\n\n        ownerToOperators[msg.sender][_operator] = _approved;\n\n        emit ApprovalForAll(msg.sender, _operator, _approved);\n\n    }\n\n\n\n    /**\n\n     * @dev Returns the number of NFTs owned by `_owner`. NFTs assigned to the zero address are\n\n     * considered invalid, and this function throws for queries about the zero address.\n\n     * @param _owner Address for whom to query the balance.\n\n     * @return Balance of _owner.\n\n     */\n\n    function balanceOf(address _owner) external view returns (uint256) {\n\n        require(_owner != address(0), ZERO_ADDRESS);\n\n        return _getOwnerNFTCount(_owner);\n\n    }\n\n\n\n    /**\n\n     * @dev Returns the address of the owner of the NFT. NFTs assigned to zero address are considered\n\n     * invalid, and queries about them do throw.\n\n     * @param _tokenId The identifier for an NFT.\n\n     * @return _owner Address of _tokenId owner.\n\n     */\n\n    function ownerOf(uint256 _tokenId) external view returns (address _owner) {\n\n        _owner = idToOwner[_tokenId];\n\n        require(_owner != address(0), NOT_VALID_NFT);\n\n    }\n\n\n\n    /**\n\n     * @dev Get the approved address for a single NFT.\n\n     * @notice Throws if `_tokenId` is not a valid NFT.\n\n     * @param _tokenId ID of the NFT to query the approval of.\n\n     * @return Address that _tokenId is approved for.\n\n     */\n\n    function getApproved(uint256 _tokenId)\n\n        external\n\n        view\n\n        validNFToken(_tokenId)\n\n        returns (address)\n\n    {\n\n        return idToApproval[_tokenId];\n\n    }\n\n\n\n    /**\n\n     * @dev Checks if `_operator` is an approved operator for `_owner`.\n\n     * @param _owner The address that owns the NFTs.\n\n     * @param _operator The address that acts on behalf of the owner.\n\n     * @return True if approved for all, false otherwise.\n\n     */\n\n    function isApprovedForAll(address _owner, address _operator)\n\n        external\n\n        view\n\n        returns (bool)\n\n    {\n\n        return ownerToOperators[_owner][_operator];\n\n    }\n\n\n\n    /**\n\n     * @dev Actually preforms the transfer.\n\n     * @notice Does NO checks.\n\n     * @param _to Address of a new owner.\n\n     * @param _tokenId The NFT that is being transferred.\n\n     */\n\n    function _transfer(address _to, uint256 _tokenId) internal {\n\n        address from = idToOwner[_tokenId];\n\n        _clearApproval(_tokenId);\n\n\n\n        _removeNFToken(from, _tokenId);\n\n        _addNFToken(_to, _tokenId);\n\n\n\n        emit Transfer(from, _to, _tokenId);\n\n    }\n\n\n\n    /**\n\n     * @dev Mints a new NFT.\n\n     * @notice This is an internal function which should be called from user-implemented external\n\n     * mint function. Its purpose is to show and properly initialize data structures when using this\n\n     * implementation.\n\n     * @param _to The address that will own the minted NFT.\n\n     * @param _tokenId of the NFT to be minted by the msg.sender.\n\n     */\n\n    function _mint(address _to, uint256 _tokenId) internal {\n\n        require(_to != address(0), ZERO_ADDRESS);\n\n        require(idToOwner[_tokenId] == address(0), NFT_ALREADY_EXISTS);\n\n\n\n        _addNFToken(_to, _tokenId);\n\n\n\n        emit Transfer(address(0), _to, _tokenId);\n\n    }\n\n\n\n    /**\n\n     * @dev Burns a NFT.\n\n     * @notice This is an internal function which should be called from user-implemented external burn\n\n     * function. Its purpose is to show and properly initialize data structures when using this\n\n     * implementation. Also, note that this burn implementation allows the minter to re-mint a burned\n\n     * NFT.\n\n     * @param _tokenId ID of the NFT to be burned.\n\n     */\n\n    function _burn(uint256 _tokenId) internal validNFToken(_tokenId) {\n\n        address tokenOwner = idToOwner[_tokenId];\n\n        _clearApproval(_tokenId);\n\n        _removeNFToken(tokenOwner, _tokenId);\n\n        emit Transfer(tokenOwner, address(0), _tokenId);\n\n    }\n\n\n\n    /**\n\n     * @dev Removes a NFT from owner.\n\n     * @notice Use and  this function with caution. Wrong usage can have serious consequences.\n\n     * @param _from Address from wich we want to remove the NFT.\n\n     * @param _tokenId Which NFT we want to remove.\n\n     */\n\n    function _removeNFToken(address _from, uint256 _tokenId) internal {\n\n        require(idToOwner[_tokenId] == _from, NOT_OWNER);\n\n        ownerToNFTokenCount[_from] = ownerToNFTokenCount[_from] - 1;\n\n        delete idToOwner[_tokenId];\n\n    }\n\n\n\n    /**\n\n     * @dev Assignes a new NFT to owner.\n\n     * @notice Use and  this function with caution. Wrong usage can have serious consequences.\n\n     * @param _to Address to wich we want to add the NFT.\n\n     * @param _tokenId Which NFT we want to add.\n\n     */\n\n    function _addNFToken(address _to, uint256 _tokenId) internal {\n\n        require(idToOwner[_tokenId] == address(0), NFT_ALREADY_EXISTS);\n\n\n\n        idToOwner[_tokenId] = _to;\n\n        ownerToNFTokenCount[_to] = ownerToNFTokenCount[_to].add(1);\n\n    }\n\n\n\n    /**\n\n     *\u00a0@dev Helper function that gets NFT count of owner. This is needed for overriding in enumerable\n\n     * extension to remove double storage (gas optimization) of owner nft count.\n\n     * @param _owner Address for whom to query the count.\n\n     * @return Number of _owner NFTs.\n\n     */\n\n    function _getOwnerNFTCount(address _owner) internal view returns (uint256) {\n\n        return ownerToNFTokenCount[_owner];\n\n    }\n\n\n\n    /**\n\n     * @dev Actually perform the safeTransferFrom.\n\n     * @param _from The current owner of the NFT.\n\n     * @param _to The new owner.\n\n     * @param _tokenId The NFT to transfer.\n\n     * @param _data Additional data with no specified format, sent in call to `_to`.\n\n     */\n\n    function _safeTransferFrom(\n\n        address _from,\n\n        address _to,\n\n        uint256 _tokenId,\n\n        bytes memory _data\n\n    ) private canTransfer(_tokenId) validNFToken(_tokenId) {\n\n        address tokenOwner = idToOwner[_tokenId];\n\n        require(tokenOwner == _from, NOT_OWNER);\n\n        require(_to != address(0), ZERO_ADDRESS);\n\n\n\n        _transfer(_to, _tokenId);\n\n\n\n        if (_to.isContract()) {\n\n            bytes4 retval = ERC721TokenReceiver(_to).onERC721Received(\n\n                msg.sender,\n\n                _from,\n\n                _tokenId,\n\n                _data\n\n            );\n\n            require(\n\n                retval == MAGIC_ON_ERC721_RECEIVED,\n\n                NOT_ABLE_TO_RECEIVE_NFT\n\n            );\n\n        }\n\n    }\n\n\n\n    /**\n\n     * @dev Clears the current approval of a given NFT ID.\n\n     * @param _tokenId ID of the NFT to be transferred.\n\n     */\n\n    function _clearApproval(uint256 _tokenId) private {\n\n        if (idToApproval[_tokenId] != address(0)) {\n\n            delete idToApproval[_tokenId];\n\n        }\n\n    }\n\n}\n",
          "message": "NFToken (nf-token-metadata.sol#385-786) has incorrect ERC20 function interface(s):\n\t-transferFrom (nf-token-metadata.sol#566-576)\n\t-approve (nf-token-metadata.sol#585-595)\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 353,
          "vulnerability_to_line": 371,
          "vulnerability_code": "    function isContract(address _addr)\n\n        internal\n\n        view\n\n        returns (bool addressCheck)\n\n    {\n\n        // This method relies in extcodesize, which returns 0 for contracts in\n\n        // construction, since the code is only stored at the end of the\n\n        // constructor execution.\n\n\n\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n\n        // for accounts without code, i.e. `keccak256('')`\n\n        bytes32 codehash;\n\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n\n        assembly {\n\n            codehash := extcodehash(_addr)\n\n        } // solhint-disable-line\n\n        addressCheck = (codehash != 0x0 && codehash != accountHash);\n",
          "message": "AddressUtils.isContract uses assembly (nf-token-metadata.sol#353-371)\n\t- nf-token-metadata.sol#367-369\n"
        },
        {
          "name": "constable-states",
          "vulnerability_from_line": 829,
          "vulnerability_to_line": null,
          "vulnerability_code": "    string internal nftName;\n",
          "message": "NFTokenMetadata.nftName should be constant (nf-token-metadata.sol#829)\nNFTokenMetadata.nftSymbol should be constant (nf-token-metadata.sol#834)\n"
        },
        {
          "name": "solc-version",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.0;\n",
          "message": "Detected issues with version pragma in nf-token-metadata.sol:\n\t- pragma solidity^0.5.0 (nf-token-metadata.sol#3): it allows old versions\n\t- pragma solidity^0.5.0 (nf-token-metadata.sol#149): it allows old versions\n\t- pragma solidity^0.5.0 (nf-token-metadata.sol#179): it allows old versions\n\t- pragma solidity^0.5.0 (nf-token-metadata.sol#283): it allows old versions\n\t- pragma solidity^0.5.0 (nf-token-metadata.sol#304): it allows old versions\n\t- pragma solidity^0.5.0 (nf-token-metadata.sol#339): it allows old versions\n\t- pragma solidity^0.5.0 (nf-token-metadata.sol#376): it allows old versions\n\t- pragma solidity^0.5.0 (nf-token-metadata.sol#789-790): it allows old versions\n\t- pragma solidity^0.5.0 (nf-token-metadata.sol#819-820): it allows old versions\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 201,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function mul(uint256 _factor1, uint256 _factor2)\n",
          "message": "Parameter '_factor1' of SafeMath.mul (nf-token-metadata.sol#201) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 201,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function mul(uint256 _factor1, uint256 _factor2)\n",
          "message": "Parameter '_factor2' of SafeMath.mul (nf-token-metadata.sol#201) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 223,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function div(uint256 _dividend, uint256 _divisor)\n",
          "message": "Parameter '_dividend' of SafeMath.div (nf-token-metadata.sol#223) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 223,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function div(uint256 _dividend, uint256 _divisor)\n",
          "message": "Parameter '_divisor' of SafeMath.div (nf-token-metadata.sol#223) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 240,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function sub(uint256 _minuend, uint256 _subtrahend)\n",
          "message": "Parameter '_minuend' of SafeMath.sub (nf-token-metadata.sol#240) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 240,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function sub(uint256 _minuend, uint256 _subtrahend)\n",
          "message": "Parameter '_subtrahend' of SafeMath.sub (nf-token-metadata.sol#240) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 255,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function add(uint256 _addend1, uint256 _addend2)\n",
          "message": "Parameter '_addend1' of SafeMath.add (nf-token-metadata.sol#255) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 255,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function add(uint256 _addend1, uint256 _addend2)\n",
          "message": "Parameter '_addend2' of SafeMath.add (nf-token-metadata.sol#255) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 271,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function mod(uint256 _dividend, uint256 _divisor)\n",
          "message": "Parameter '_dividend' of SafeMath.mod (nf-token-metadata.sol#271) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 271,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function mod(uint256 _dividend, uint256 _divisor)\n",
          "message": "Parameter '_divisor' of SafeMath.mod (nf-token-metadata.sol#271) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 328,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function supportsInterface(bytes4 _interfaceID)\n",
          "message": "Parameter '_interfaceID' of SupportsInterface.supportsInterface (nf-token-metadata.sol#328) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 531,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address _from,\n",
          "message": "Parameter '_from' of NFToken.safeTransferFrom (nf-token-metadata.sol#531) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 532,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address _to,\n",
          "message": "Parameter '_to' of NFToken.safeTransferFrom (nf-token-metadata.sol#532) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 533,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint256 _tokenId,\n",
          "message": "Parameter '_tokenId' of NFToken.safeTransferFrom (nf-token-metadata.sol#533) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 534,
          "vulnerability_to_line": null,
          "vulnerability_code": "        bytes calldata _data\n",
          "message": "Parameter '_data' of NFToken.safeTransferFrom (nf-token-metadata.sol#534) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 549,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address _from,\n",
          "message": "Parameter '_from' of NFToken.safeTransferFrom (nf-token-metadata.sol#549) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 550,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address _to,\n",
          "message": "Parameter '_to' of NFToken.safeTransferFrom (nf-token-metadata.sol#550) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 551,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint256 _tokenId\n",
          "message": "Parameter '_tokenId' of NFToken.safeTransferFrom (nf-token-metadata.sol#551) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 567,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address _from,\n",
          "message": "Parameter '_from' of NFToken.transferFrom (nf-token-metadata.sol#567) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 568,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address _to,\n",
          "message": "Parameter '_to' of NFToken.transferFrom (nf-token-metadata.sol#568) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 569,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint256 _tokenId\n",
          "message": "Parameter '_tokenId' of NFToken.transferFrom (nf-token-metadata.sol#569) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 585,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function approve(address _approved, uint256 _tokenId)\n",
          "message": "Parameter '_approved' of NFToken.approve (nf-token-metadata.sol#585) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 585,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function approve(address _approved, uint256 _tokenId)\n",
          "message": "Parameter '_tokenId' of NFToken.approve (nf-token-metadata.sol#585) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 604,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setApprovalForAll(address _operator, bool _approved) external {\n",
          "message": "Parameter '_operator' of NFToken.setApprovalForAll (nf-token-metadata.sol#604) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 604,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setApprovalForAll(address _operator, bool _approved) external {\n",
          "message": "Parameter '_approved' of NFToken.setApprovalForAll (nf-token-metadata.sol#604) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 615,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function balanceOf(address _owner) external view returns (uint256) {\n",
          "message": "Parameter '_owner' of NFToken.balanceOf (nf-token-metadata.sol#615) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 626,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function ownerOf(uint256 _tokenId) external view returns (address _owner) {\n",
          "message": "Parameter '_tokenId' of NFToken.ownerOf (nf-token-metadata.sol#626) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 637,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getApproved(uint256 _tokenId)\n",
          "message": "Parameter '_tokenId' of NFToken.getApproved (nf-token-metadata.sol#637) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 652,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function isApprovedForAll(address _owner, address _operator)\n",
          "message": "Parameter '_owner' of NFToken.isApprovedForAll (nf-token-metadata.sol#652) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 652,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function isApprovedForAll(address _owner, address _operator)\n",
          "message": "Parameter '_operator' of NFToken.isApprovedForAll (nf-token-metadata.sol#652) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 666,
          "vulnerability_to_line": 674,
          "vulnerability_code": "    function _transfer(address _to, uint256 _tokenId) internal {\n\n        address from = idToOwner[_tokenId];\n\n        _clearApproval(_tokenId);\n\n\n\n        _removeNFToken(from, _tokenId);\n\n        _addNFToken(_to, _tokenId);\n\n\n\n        emit Transfer(from, _to, _tokenId);\n",
          "message": "Function 'NFToken._transfer' (nf-token-metadata.sol#666-674) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 666,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _transfer(address _to, uint256 _tokenId) internal {\n",
          "message": "Parameter '_to' of NFToken._transfer (nf-token-metadata.sol#666) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 666,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _transfer(address _to, uint256 _tokenId) internal {\n",
          "message": "Parameter '_tokenId' of NFToken._transfer (nf-token-metadata.sol#666) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 684,
          "vulnerability_to_line": 691,
          "vulnerability_code": "    function _mint(address _to, uint256 _tokenId) internal {\n\n        require(_to != address(0), ZERO_ADDRESS);\n\n        require(idToOwner[_tokenId] == address(0), NFT_ALREADY_EXISTS);\n\n\n\n        _addNFToken(_to, _tokenId);\n\n\n\n        emit Transfer(address(0), _to, _tokenId);\n",
          "message": "Function 'NFToken._mint' (nf-token-metadata.sol#684-691) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 684,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _mint(address _to, uint256 _tokenId) internal {\n",
          "message": "Parameter '_to' of NFToken._mint (nf-token-metadata.sol#684) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 684,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _mint(address _to, uint256 _tokenId) internal {\n",
          "message": "Parameter '_tokenId' of NFToken._mint (nf-token-metadata.sol#684) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 701,
          "vulnerability_to_line": 706,
          "vulnerability_code": "    function _burn(uint256 _tokenId) internal validNFToken(_tokenId) {\n\n        address tokenOwner = idToOwner[_tokenId];\n\n        _clearApproval(_tokenId);\n\n        _removeNFToken(tokenOwner, _tokenId);\n\n        emit Transfer(tokenOwner, address(0), _tokenId);\n",
          "message": "Function 'NFToken._burn' (nf-token-metadata.sol#701-706) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 701,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _burn(uint256 _tokenId) internal validNFToken(_tokenId) {\n",
          "message": "Parameter '_tokenId' of NFToken._burn (nf-token-metadata.sol#701) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 714,
          "vulnerability_to_line": 718,
          "vulnerability_code": "    function _removeNFToken(address _from, uint256 _tokenId) internal {\n\n        require(idToOwner[_tokenId] == _from, NOT_OWNER);\n\n        ownerToNFTokenCount[_from] = ownerToNFTokenCount[_from] - 1;\n\n        delete idToOwner[_tokenId];\n",
          "message": "Function 'NFToken._removeNFToken' (nf-token-metadata.sol#714-718) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 714,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _removeNFToken(address _from, uint256 _tokenId) internal {\n",
          "message": "Parameter '_from' of NFToken._removeNFToken (nf-token-metadata.sol#714) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 714,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _removeNFToken(address _from, uint256 _tokenId) internal {\n",
          "message": "Parameter '_tokenId' of NFToken._removeNFToken (nf-token-metadata.sol#714) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 726,
          "vulnerability_to_line": 731,
          "vulnerability_code": "    function _addNFToken(address _to, uint256 _tokenId) internal {\n\n        require(idToOwner[_tokenId] == address(0), NFT_ALREADY_EXISTS);\n\n\n\n        idToOwner[_tokenId] = _to;\n\n        ownerToNFTokenCount[_to] = ownerToNFTokenCount[_to].add(1);\n",
          "message": "Function 'NFToken._addNFToken' (nf-token-metadata.sol#726-731) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 726,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _addNFToken(address _to, uint256 _tokenId) internal {\n",
          "message": "Parameter '_to' of NFToken._addNFToken (nf-token-metadata.sol#726) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 726,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _addNFToken(address _to, uint256 _tokenId) internal {\n",
          "message": "Parameter '_tokenId' of NFToken._addNFToken (nf-token-metadata.sol#726) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 739,
          "vulnerability_to_line": 742,
          "vulnerability_code": "    function _getOwnerNFTCount(address _owner) internal view returns (uint256) {\n\n        return ownerToNFTokenCount[_owner];\n\n    }\n",
          "message": "Function 'NFToken._getOwnerNFTCount' (nf-token-metadata.sol#739-742) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 739,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _getOwnerNFTCount(address _owner) internal view returns (uint256) {\n",
          "message": "Parameter '_owner' of NFToken._getOwnerNFTCount (nf-token-metadata.sol#739) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 750,
          "vulnerability_to_line": 775,
          "vulnerability_code": "    function _safeTransferFrom(\n\n        address _from,\n\n        address _to,\n\n        uint256 _tokenId,\n\n        bytes memory _data\n\n    ) private canTransfer(_tokenId) validNFToken(_tokenId) {\n\n        address tokenOwner = idToOwner[_tokenId];\n\n        require(tokenOwner == _from, NOT_OWNER);\n\n        require(_to != address(0), ZERO_ADDRESS);\n\n\n\n        _transfer(_to, _tokenId);\n\n\n\n        if (_to.isContract()) {\n\n            bytes4 retval = ERC721TokenReceiver(_to).onERC721Received(\n\n                msg.sender,\n\n                _from,\n\n                _tokenId,\n\n                _data\n\n            );\n\n            require(\n\n                retval == MAGIC_ON_ERC721_RECEIVED,\n\n                NOT_ABLE_TO_RECEIVE_NFT\n\n            );\n\n        }\n\n    }\n",
          "message": "Function 'NFToken._safeTransferFrom' (nf-token-metadata.sol#750-775) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 751,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address _from,\n",
          "message": "Parameter '_from' of NFToken._safeTransferFrom (nf-token-metadata.sol#751) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 752,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address _to,\n",
          "message": "Parameter '_to' of NFToken._safeTransferFrom (nf-token-metadata.sol#752) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 753,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint256 _tokenId,\n",
          "message": "Parameter '_tokenId' of NFToken._safeTransferFrom (nf-token-metadata.sol#753) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 754,
          "vulnerability_to_line": 755,
          "vulnerability_code": "        bytes memory _data\n",
          "message": "Parameter '_data' of NFToken._safeTransferFrom (nf-token-metadata.sol#754-755) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 780,
          "vulnerability_to_line": 785,
          "vulnerability_code": "    function _clearApproval(uint256 _tokenId) private {\n\n        if (idToApproval[_tokenId] != address(0)) {\n\n            delete idToApproval[_tokenId];\n\n        }\n\n    }\n",
          "message": "Function 'NFToken._clearApproval' (nf-token-metadata.sol#780-785) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 780,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _clearApproval(uint256 _tokenId) private {\n",
          "message": "Parameter '_tokenId' of NFToken._clearApproval (nf-token-metadata.sol#780) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 887,
          "vulnerability_to_line": 894,
          "vulnerability_code": "    function _burn(uint256 _tokenId) internal {\n\n        super._burn(_tokenId);\n\n\n\n        if (bytes(idToUri[_tokenId]).length != 0) {\n\n            delete idToUri[_tokenId];\n\n        }\n\n    }\n",
          "message": "Function 'NFTokenMetadata._burn' (nf-token-metadata.sol#887-894) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 887,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _burn(uint256 _tokenId) internal {\n",
          "message": "Parameter '_tokenId' of NFTokenMetadata._burn (nf-token-metadata.sol#887) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 870,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function tokenURI(uint256 _tokenId)\n",
          "message": "Parameter '_tokenId' of NFTokenMetadata.tokenURI (nf-token-metadata.sol#870) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 903,
          "vulnerability_to_line": 909,
          "vulnerability_code": "    function _setTokenUri(uint256 _tokenId, string memory _uri)\n\n        internal\n\n        validNFToken(_tokenId)\n\n    {\n\n        idToUri[_tokenId] = _uri;\n\n    }\n",
          "message": "Function 'NFTokenMetadata._setTokenUri' (nf-token-metadata.sol#903-909) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 903,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setTokenUri(uint256 _tokenId, string memory _uri)\n",
          "message": "Parameter '_tokenId' of NFTokenMetadata._setTokenUri (nf-token-metadata.sol#903) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 903,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setTokenUri(uint256 _tokenId, string memory _uri)\n",
          "message": "Parameter '_uri' of NFTokenMetadata._setTokenUri (nf-token-metadata.sol#903) is not in mixedCase\n"
        }
      ]
    },
    "smartcheck": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 320,
          "vulnerability_to_line": null,
          "vulnerability_code": "        supportedInterfaces[0x01ffc9a7] = true; // ERC165\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 406,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bytes4 internal constant MAGIC_ON_ERC721_RECEIVED = 0x150b7a02;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 513,
          "vulnerability_to_line": null,
          "vulnerability_code": "        supportedInterfaces[0x80ac58cd] = true; // ERC721\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 846,
          "vulnerability_to_line": null,
          "vulnerability_code": "        supportedInterfaces[0x5b5e139f] = true; // ERC721Metadata\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ERC20_APPROVE",
          "vulnerability_from_line": 585,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function approve(address _approved, uint256 _tokenId)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 149,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 179,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 283,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 304,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 339,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 376,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 789,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 819,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 421,
          "vulnerability_to_line": null,
          "vulnerability_code": "    mapping(address => uint256) private ownerToNFTokenCount;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SAFEMATH",
          "vulnerability_from_line": 386,
          "vulnerability_to_line": null,
          "vulnerability_code": "    using SafeMath for uint256;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
          "vulnerability_from_line": 353,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function isContract(address _addr)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 367,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 191,
          "vulnerability_to_line": null,
          "vulnerability_code": "    string constant OVERFLOW = \"008001\";\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 192,
          "vulnerability_to_line": null,
          "vulnerability_code": "    string constant SUBTRAHEND_GREATER_THEN_MINUEND = \"008002\";\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 193,
          "vulnerability_to_line": null,
          "vulnerability_code": "    string constant DIVISION_BY_ZERO = \"008003\";\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 393,
          "vulnerability_to_line": null,
          "vulnerability_code": "    string constant ZERO_ADDRESS = \"003001\";\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 394,
          "vulnerability_to_line": null,
          "vulnerability_code": "    string constant NOT_VALID_NFT = \"003002\";\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 395,
          "vulnerability_to_line": null,
          "vulnerability_code": "    string constant NOT_OWNER_OR_OPERATOR = \"003003\";\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 396,
          "vulnerability_to_line": null,
          "vulnerability_code": "    string constant NOT_OWNER_APPROWED_OR_OPERATOR = \"003004\";\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 397,
          "vulnerability_to_line": null,
          "vulnerability_code": "    string constant NOT_ABLE_TO_RECEIVE_NFT = \"003005\";\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 398,
          "vulnerability_to_line": null,
          "vulnerability_code": "    string constant NFT_ALREADY_EXISTS = \"003006\";\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 399,
          "vulnerability_to_line": null,
          "vulnerability_code": "    string constant NOT_OWNER = \"003007\";\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 400,
          "vulnerability_to_line": null,
          "vulnerability_code": "    string constant IS_OWNER = \"003008\";\n",
          "message": null
        }
      ]
    },
    "oyente": {
      "successfull_analysis": false,
      "errors": [
        "exception (RuntimeError: Source map error, unknown name(SHR) or instr_name(INVALID))"
      ],
      "vulnerability_findings": []
    },
    "mythril": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": []
    },
    "osiris": {
      "successfull_analysis": false,
      "errors": [
        "Solidity compilation failed"
      ],
      "vulnerability_findings": []
    }
  }
}