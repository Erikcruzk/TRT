{
  "smartbugs_completed": true,
  "analyzer_results": {
    "semgrep": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": []
    },
    "slither": {
      "successfull_analysis": true,
      "errors": [
        "EXIT_CODE_2"
      ],
      "vulnerability_findings": [
        {
          "name": "erc20-interface",
          "vulnerability_from_line": 9,
          "vulnerability_to_line": 145,
          "vulnerability_code": "interface ERC721 {\n\n    /**\n\n     * @dev Emits when ownership of any NFT changes by any mechanism. This event emits when NFTs are\n\n     * created (`from` == 0) and destroyed (`to` == 0). Exception: during contract creation, any\n\n     * number of NFTs may be created and assigned without emitting Transfer. At the time of any\n\n     * transfer, the approved address for that NFT (if any) is reset to none.\n\n     */\n\n    event Transfer(\n\n        address indexed _from,\n\n        address indexed _to,\n\n        uint256 indexed _tokenId\n\n    );\n\n\n\n    /**\n\n     * @dev This emits when the approved address for an NFT is changed or reaffirmed. The zero\n\n     * address indicates there is no approved address. When a Transfer event emits, this also\n\n     * indicates that the approved address for that NFT (if any) is reset to none.\n\n     */\n\n    event Approval(\n\n        address indexed _owner,\n\n        address indexed _approved,\n\n        uint256 indexed _tokenId\n\n    );\n\n\n\n    /**\n\n     * @dev This emits when an operator is enabled or disabled for an owner. The operator can manage\n\n     * all NFTs of the owner.\n\n     */\n\n    event ApprovalForAll(\n\n        address indexed _owner,\n\n        address indexed _operator,\n\n        bool _approved\n\n    );\n\n\n\n    /**\n\n     * @dev Transfers the ownership of an NFT from one address to another address.\n\n     * @notice Throws unless `msg.sender` is the current owner, an authorized operator, or the\n\n     * approved address for this NFT. Throws if `_from` is not the current owner. Throws if `_to` is\n\n     * the zero address. Throws if `_tokenId` is not a valid NFT. When transfer is complete, this\n\n     * function checks if `_to` is a smart contract (code size > 0). If so, it calls\n\n     * `onERC721Received` on `_to` and throws if the return value is not\n\n     * `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`.\n\n     * @param _from The current owner of the NFT.\n\n     * @param _to The new owner.\n\n     * @param _tokenId The NFT to transfer.\n\n     * @param _data Additional data with no specified format, sent in call to `_to`.\n\n     */\n\n    function safeTransferFrom(\n\n        address _from,\n\n        address _to,\n\n        uint256 _tokenId,\n\n        bytes calldata _data\n\n    ) external;\n\n\n\n    /**\n\n     * @dev Transfers the ownership of an NFT from one address to another address.\n\n     * @notice This works identically to the other function with an extra data parameter, except this\n\n     * function just sets data to \"\"\n\n     * @param _from The current owner of the NFT.\n\n     * @param _to The new owner.\n\n     * @param _tokenId The NFT to transfer.\n\n     */\n\n    function safeTransferFrom(\n\n        address _from,\n\n        address _to,\n\n        uint256 _tokenId\n\n    ) external;\n\n\n\n    /**\n\n     * @dev Throws unless `msg.sender` is the current owner, an authorized operator, or the approved\n\n     * address for this NFT. Throws if `_from` is not the current owner. Throws if `_to` is the zero\n\n     * address. Throws if `_tokenId` is not a valid NFT.\n\n     * @notice The caller is responsible to confirm that `_to` is capable of receiving NFTs or else\n\n     * they mayb be permanently lost.\n\n     * @param _from The current owner of the NFT.\n\n     * @param _to The new owner.\n\n     * @param _tokenId The NFT to transfer.\n\n     */\n\n    function transferFrom(\n\n        address _from,\n\n        address _to,\n\n        uint256 _tokenId\n\n    ) external;\n\n\n\n    /**\n\n     * @dev Set or reaffirm the approved address for an NFT.\n\n     * @notice The zero address indicates there is no approved address. Throws unless `msg.sender` is\n\n     * the current NFT owner, or an authorized operator of the current owner.\n\n     * @param _approved The new approved NFT controller.\n\n     * @param _tokenId The NFT to approve.\n\n     */\n\n    function approve(address _approved, uint256 _tokenId) external;\n\n\n\n    /**\n\n     * @dev Enables or disables approval for a third party (\"operator\") to manage all of\n\n     * `msg.sender`'s assets. It also emits the ApprovalForAll event.\n\n     * @notice The contract MUST allow multiple operators per owner.\n\n     * @param _operator Address to add to the set of authorized operators.\n\n     * @param _approved True if the operators is approved, false to revoke approval.\n\n     */\n\n    function setApprovalForAll(address _operator, bool _approved) external;\n\n\n\n    /**\n\n     * @dev Returns the number of NFTs owned by `_owner`. NFTs assigned to the zero address are\n\n     * considered invalid, and this function throws for queries about the zero address.\n\n     * @param _owner Address for whom to query the balance.\n\n     * @return Balance of _owner.\n\n     */\n\n    function balanceOf(address _owner) external view returns (uint256);\n\n\n\n    /**\n\n     * @dev Returns the address of the owner of the NFT. NFTs assigned to zero address are considered\n\n     * invalid, and queries about them do throw.\n\n     * @param _tokenId The identifier for an NFT.\n\n     * @return Address of _tokenId owner.\n\n     */\n\n    function ownerOf(uint256 _tokenId) external view returns (address);\n\n\n\n    /**\n\n     * @dev Get the approved address for a single NFT.\n\n     * @notice Throws if `_tokenId` is not a valid NFT.\n\n     * @param _tokenId The NFT to find the approved address for.\n\n     * @return Address that _tokenId is approved for.\n\n     */\n\n    function getApproved(uint256 _tokenId) external view returns (address);\n\n\n\n    /**\n\n     * @dev Returns true if `_operator` is an approved operator for `_owner`, false otherwise.\n\n     * @param _owner The address that owns the NFTs.\n\n     * @param _operator The address that acts on behalf of the owner.\n\n     * @return True if approved for all, false otherwise.\n\n     */\n\n    function isApprovedForAll(address _owner, address _operator)\n\n        external\n\n        view\n\n        returns (bool);\n",
          "message": "ERC721 (erc721.sol#9-145) has incorrect ERC20 function interface(s):\n\t-transferFrom (erc721.sol#87-91)\n\t-approve (erc721.sol#100)\n"
        },
        {
          "name": "solc-version",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.0;\n",
          "message": "Detected issues with version pragma in erc721.sol:\n\t- pragma solidity^0.5.0 (erc721.sol#3): it allows old versions\n"
        }
      ]
    },
    "smartcheck": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.0;\n",
          "message": null
        }
      ]
    },
    "oyente": {
      "successfull_analysis": false,
      "errors": [
        "execution failed"
      ],
      "vulnerability_findings": []
    },
    "mythril": {
      "successfull_analysis": false,
      "errors": [
        "input files do not contain any valid contracts"
      ],
      "vulnerability_findings": []
    },
    "osiris": {
      "successfull_analysis": false,
      "errors": [
        "Solidity compilation failed"
      ],
      "vulnerability_findings": []
    }
  }
}