{
  "smartbugs_completed": true,
  "analyzer_results": {
    "semgrep": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 13,
          "vulnerability_to_line": null,
          "vulnerability_code": "  constructor(\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 14,
          "vulnerability_to_line": null,
          "vulnerability_code": "    address _master,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 15,
          "vulnerability_to_line": null,
          "vulnerability_code": "    address _registry\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 16,
          "vulnerability_to_line": null,
          "vulnerability_code": "  )\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 17,
          "vulnerability_to_line": null,
          "vulnerability_code": "    public\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 18,
          "vulnerability_to_line": null,
          "vulnerability_code": "  {\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 19,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require(_master != address(0));\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 20,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require(_registry != address(0));\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 21,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bytes32 _proxyMasterContractSlot = proxyMasterContractSlot;\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 22,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bytes32 _proxyRegistrySlot = proxyRegistrySlot;\n",
          "message": "Consider making costructor payable to save gas."
        }
      ]
    },
    "slither": {
      "successfull_analysis": true,
      "errors": [
        "EXIT_CODE_23"
      ],
      "vulnerability_findings": [
        {
          "name": "constant-function",
          "vulnerability_from_line": 35,
          "vulnerability_to_line": 44,
          "vulnerability_code": "  function proxyMasterContract()\n\n    public\n\n    view\n\n    returns (address _masterContract)\n\n  {\n\n    bytes32 _proxyMasterContractSlot = proxyMasterContractSlot;\n\n    assembly {\n\n      _masterContract := sload(_proxyMasterContractSlot)\n\n    }\n",
          "message": "PoaProxy.proxyMasterContract (PoaProxy.sol#35-44) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 46,
          "vulnerability_to_line": 55,
          "vulnerability_code": "  function proxyRegistry()\n\n    public\n\n    view\n\n    returns (address _proxyRegistry)\n\n  {\n\n    bytes32 _proxyRegistrySlot = proxyRegistrySlot;\n\n    assembly {\n\n      _proxyRegistry := sload(_proxyRegistrySlot)\n\n    }\n",
          "message": "PoaProxy.proxyRegistry (PoaProxy.sol#46-55) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 61,
          "vulnerability_to_line": 95,
          "vulnerability_code": "  function getContractAddress(\n\n    string _name\n\n  )\n\n    public\n\n    view\n\n    returns (address _contractAddress)\n\n  {\n\n    bytes4 _sig = bytes4(keccak256(\"getContractAddress32(bytes32)\"));\n\n    bytes32 _name32 = keccak256(_name);\n\n    bytes32 _proxyRegistrySlot = proxyRegistrySlot;\n\n\n\n    assembly {\n\n      let _call := mload(0x40)          // set _call to free memory pointer\n\n      mstore(_call, _sig)               // store _sig at _call pointer\n\n      mstore(add(_call, 0x04), _name32) // store _name32 at _call offset by 4 bytes for pre-existing _sig\n\n\n\n      // staticcall(g, a, in, insize, out, outsize) => 0 on error 1 on success\n\n      let success := staticcall(\n\n        gas,    // g = gas: whatever was passed already\n\n        sload(_proxyRegistrySlot),  // a = address: address in storage\n\n        _call,  // in = mem in  mem[in..(in+insize): set to free memory pointer\n\n        0x24,   // insize = mem insize  mem[in..(in+insize): size of sig (bytes4) + bytes32 = 0x24\n\n        _call,   // out = mem out  mem[out..(out+outsize): output assigned to this storage address\n\n        0x20    // outsize = mem outsize  mem[out..(out+outsize): output should be 32byte slot (address size = 0x14 <  slot size 0x20)\n\n      )\n\n\n\n      // revert if not successful\n\n      if iszero(success) {\n\n        revert(0, 0)\n\n      }\n\n\n\n      _contractAddress := mload(_call) // assign result to return value\n\n      mstore(0x40, add(_call, 0x24)) // advance free memory pointer by largest _call size\n\n    }\n",
          "message": "PoaProxy.getContractAddress (PoaProxy.sol#61-95) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 98,
          "vulnerability_to_line": 106,
          "vulnerability_code": "  function proxyIsContract(address _address)\n\n    private\n\n    view\n\n    returns (bool)\n\n  {\n\n    uint256 _size;\n\n    assembly { _size := extcodesize(_address) }\n\n    return _size > 0;\n",
          "message": "PoaProxy.proxyIsContract (PoaProxy.sol#98-106) is declared view but contains assembly code\n"
        },
        {
          "name": "locked-ether",
          "vulnerability_from_line": 139,
          "vulnerability_to_line": 181,
          "vulnerability_code": "  function()\n\n    external\n\n    payable\n\n  {\n\n    bytes32 _proxyMasterContractSlot = proxyMasterContractSlot;\n\n    assembly {\n\n      // load address from first storage pointer\n\n      let _master := sload(_proxyMasterContractSlot)\n\n\n\n      // calldatacopy(t, f, s)\n\n      calldatacopy(\n\n        0x0, // t = mem position to\n\n        0x0, // f = mem position from\n\n        calldatasize // s = size bytes\n\n      )\n\n\n\n      // delegatecall(g, a, in, insize, out, outsize) => 0 on error 1 on success\n\n      let success := delegatecall(\n\n        gas, // g = gas\n\n        _master, // a = address\n\n        0x0, // in = mem in  mem[in..(in+insize)\n\n        calldatasize, // insize = mem insize  mem[in..(in+insize)\n\n        0x0, // out = mem out  mem[out..(out+outsize)\n\n        0 // outsize = mem outsize  mem[out..(out+outsize)\n\n      )\n\n\n\n      // returndatacopy(t, f, s)\n\n      returndatacopy(\n\n        0x0, // t = mem position to\n\n        0x0,  // f = mem position from\n\n        returndatasize // s = size bytes\n\n      )\n\n\n\n      // check if call was a success and return if no errors & revert if errors\n\n      if iszero(success) {\n\n        revert(0, 0)\n\n      }\n\n        return(\n\n          0x0,\n\n          returndatasize\n\n        )\n\n    }\n",
          "message": "Contract locking ether found in PoaProxy.sol:\n\tContract PoaProxy has payable functions:\n\t - fallback (PoaProxy.sol#139-181)\n\tBut does not have a function to withdraw the ether\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 13,
          "vulnerability_to_line": 29,
          "vulnerability_code": "  constructor(\n\n    address _master,\n\n    address _registry\n\n  )\n\n    public\n\n  {\n\n    require(_master != address(0));\n\n    require(_registry != address(0));\n\n    bytes32 _proxyMasterContractSlot = proxyMasterContractSlot;\n\n    bytes32 _proxyRegistrySlot = proxyRegistrySlot;\n\n\n\n    // all storage locations are pre-calculated using hashes of names\n\n    assembly {\n\n      sstore(_proxyMasterContractSlot, _master) // store master address in master slot\n\n      sstore(_proxyRegistrySlot, _registry) // store registry address in registry slot\n\n    }\n",
          "message": "PoaProxy.constructor uses assembly (PoaProxy.sol#13-29)\n\t- PoaProxy.sol#25-29\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 35,
          "vulnerability_to_line": 44,
          "vulnerability_code": "  function proxyMasterContract()\n\n    public\n\n    view\n\n    returns (address _masterContract)\n\n  {\n\n    bytes32 _proxyMasterContractSlot = proxyMasterContractSlot;\n\n    assembly {\n\n      _masterContract := sload(_proxyMasterContractSlot)\n\n    }\n",
          "message": "PoaProxy.proxyMasterContract uses assembly (PoaProxy.sol#35-44)\n\t- PoaProxy.sol#41-44\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 46,
          "vulnerability_to_line": 55,
          "vulnerability_code": "  function proxyRegistry()\n\n    public\n\n    view\n\n    returns (address _proxyRegistry)\n\n  {\n\n    bytes32 _proxyRegistrySlot = proxyRegistrySlot;\n\n    assembly {\n\n      _proxyRegistry := sload(_proxyRegistrySlot)\n\n    }\n",
          "message": "PoaProxy.proxyRegistry uses assembly (PoaProxy.sol#46-55)\n\t- PoaProxy.sol#52-55\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 61,
          "vulnerability_to_line": 95,
          "vulnerability_code": "  function getContractAddress(\n\n    string _name\n\n  )\n\n    public\n\n    view\n\n    returns (address _contractAddress)\n\n  {\n\n    bytes4 _sig = bytes4(keccak256(\"getContractAddress32(bytes32)\"));\n\n    bytes32 _name32 = keccak256(_name);\n\n    bytes32 _proxyRegistrySlot = proxyRegistrySlot;\n\n\n\n    assembly {\n\n      let _call := mload(0x40)          // set _call to free memory pointer\n\n      mstore(_call, _sig)               // store _sig at _call pointer\n\n      mstore(add(_call, 0x04), _name32) // store _name32 at _call offset by 4 bytes for pre-existing _sig\n\n\n\n      // staticcall(g, a, in, insize, out, outsize) => 0 on error 1 on success\n\n      let success := staticcall(\n\n        gas,    // g = gas: whatever was passed already\n\n        sload(_proxyRegistrySlot),  // a = address: address in storage\n\n        _call,  // in = mem in  mem[in..(in+insize): set to free memory pointer\n\n        0x24,   // insize = mem insize  mem[in..(in+insize): size of sig (bytes4) + bytes32 = 0x24\n\n        _call,   // out = mem out  mem[out..(out+outsize): output assigned to this storage address\n\n        0x20    // outsize = mem outsize  mem[out..(out+outsize): output should be 32byte slot (address size = 0x14 <  slot size 0x20)\n\n      )\n\n\n\n      // revert if not successful\n\n      if iszero(success) {\n\n        revert(0, 0)\n\n      }\n\n\n\n      _contractAddress := mload(_call) // assign result to return value\n\n      mstore(0x40, add(_call, 0x24)) // advance free memory pointer by largest _call size\n\n    }\n",
          "message": "PoaProxy.getContractAddress uses assembly (PoaProxy.sol#61-95)\n\t- PoaProxy.sol#72-95\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 98,
          "vulnerability_to_line": 106,
          "vulnerability_code": "  function proxyIsContract(address _address)\n\n    private\n\n    view\n\n    returns (bool)\n\n  {\n\n    uint256 _size;\n\n    assembly { _size := extcodesize(_address) }\n\n    return _size > 0;\n",
          "message": "PoaProxy.proxyIsContract uses assembly (PoaProxy.sol#98-106)\n\t- PoaProxy.sol#104-105\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 112,
          "vulnerability_to_line": 133,
          "vulnerability_code": "  function proxyChangeMaster(address _newMaster)\n\n    public\n\n    returns (bool)\n\n  {\n\n    require(msg.sender == getContractAddress(\"PoaManager\"));\n\n    require(_newMaster != address(0));\n\n    require(proxyMasterContract() != _newMaster);\n\n    require(proxyIsContract(_newMaster));\n\n    address _oldMaster = proxyMasterContract();\n\n    bytes32 _proxyMasterContractSlot = proxyMasterContractSlot;\n\n    assembly {\n\n      sstore(_proxyMasterContractSlot, _newMaster)\n\n    }\n\n\n\n    emit ProxyUpgradedEvent(_oldMaster, _newMaster);\n\n    getContractAddress(\"Logger\").call(\n\n      bytes4(keccak256(\"logProxyUpgradedEvent(address,address)\")),\n\n      _oldMaster, _newMaster\n\n    );\n\n\n\n    return true;\n",
          "message": "PoaProxy.proxyChangeMaster uses assembly (PoaProxy.sol#112-133)\n\t- PoaProxy.sol#122-126\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 139,
          "vulnerability_to_line": 181,
          "vulnerability_code": "  function()\n\n    external\n\n    payable\n\n  {\n\n    bytes32 _proxyMasterContractSlot = proxyMasterContractSlot;\n\n    assembly {\n\n      // load address from first storage pointer\n\n      let _master := sload(_proxyMasterContractSlot)\n\n\n\n      // calldatacopy(t, f, s)\n\n      calldatacopy(\n\n        0x0, // t = mem position to\n\n        0x0, // f = mem position from\n\n        calldatasize // s = size bytes\n\n      )\n\n\n\n      // delegatecall(g, a, in, insize, out, outsize) => 0 on error 1 on success\n\n      let success := delegatecall(\n\n        gas, // g = gas\n\n        _master, // a = address\n\n        0x0, // in = mem in  mem[in..(in+insize)\n\n        calldatasize, // insize = mem insize  mem[in..(in+insize)\n\n        0x0, // out = mem out  mem[out..(out+outsize)\n\n        0 // outsize = mem outsize  mem[out..(out+outsize)\n\n      )\n\n\n\n      // returndatacopy(t, f, s)\n\n      returndatacopy(\n\n        0x0, // t = mem position to\n\n        0x0,  // f = mem position from\n\n        returndatasize // s = size bytes\n\n      )\n\n\n\n      // check if call was a success and return if no errors & revert if errors\n\n      if iszero(success) {\n\n        revert(0, 0)\n\n      }\n\n        return(\n\n          0x0,\n\n          returndatasize\n\n        )\n\n    }\n",
          "message": "PoaProxy.fallback uses assembly (PoaProxy.sol#139-181)\n\t- PoaProxy.sol#144-181\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 46,
          "vulnerability_to_line": 55,
          "vulnerability_code": "  function proxyRegistry()\n\n    public\n\n    view\n\n    returns (address _proxyRegistry)\n\n  {\n\n    bytes32 _proxyRegistrySlot = proxyRegistrySlot;\n\n    assembly {\n\n      _proxyRegistry := sload(_proxyRegistrySlot)\n\n    }\n",
          "message": "PoaProxy.proxyRegistry (PoaProxy.sol#46-55) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 112,
          "vulnerability_to_line": 133,
          "vulnerability_code": "  function proxyChangeMaster(address _newMaster)\n\n    public\n\n    returns (bool)\n\n  {\n\n    require(msg.sender == getContractAddress(\"PoaManager\"));\n\n    require(_newMaster != address(0));\n\n    require(proxyMasterContract() != _newMaster);\n\n    require(proxyIsContract(_newMaster));\n\n    address _oldMaster = proxyMasterContract();\n\n    bytes32 _proxyMasterContractSlot = proxyMasterContractSlot;\n\n    assembly {\n\n      sstore(_proxyMasterContractSlot, _newMaster)\n\n    }\n\n\n\n    emit ProxyUpgradedEvent(_oldMaster, _newMaster);\n\n    getContractAddress(\"Logger\").call(\n\n      bytes4(keccak256(\"logProxyUpgradedEvent(address,address)\")),\n\n      _oldMaster, _newMaster\n\n    );\n\n\n\n    return true;\n",
          "message": "PoaProxy.proxyChangeMaster (PoaProxy.sol#112-133) should be declared external\n"
        },
        {
          "name": "solc-version",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity 0.4.23;\n",
          "message": "Detected issues with version pragma in PoaProxy.sol:\n\t- pragma solidity0.4.23 (PoaProxy.sol#3): it allows old versions\n"
        },
        {
          "name": "low-level-calls",
          "vulnerability_from_line": 112,
          "vulnerability_to_line": 133,
          "vulnerability_code": "  function proxyChangeMaster(address _newMaster)\n\n    public\n\n    returns (bool)\n\n  {\n\n    require(msg.sender == getContractAddress(\"PoaManager\"));\n\n    require(_newMaster != address(0));\n\n    require(proxyMasterContract() != _newMaster);\n\n    require(proxyIsContract(_newMaster));\n\n    address _oldMaster = proxyMasterContract();\n\n    bytes32 _proxyMasterContractSlot = proxyMasterContractSlot;\n\n    assembly {\n\n      sstore(_proxyMasterContractSlot, _newMaster)\n\n    }\n\n\n\n    emit ProxyUpgradedEvent(_oldMaster, _newMaster);\n\n    getContractAddress(\"Logger\").call(\n\n      bytes4(keccak256(\"logProxyUpgradedEvent(address,address)\")),\n\n      _oldMaster, _newMaster\n\n    );\n\n\n\n    return true;\n",
          "message": "Low level call in PoaProxy.proxyChangeMaster (PoaProxy.sol#112-133):\n\t-getContractAddress(Logger).call(bytes4(keccak256()(logProxyUpgradedEvent(address,address))),_oldMaster,_newMaster) PoaProxy.sol#127-130\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 14,
          "vulnerability_to_line": null,
          "vulnerability_code": "    address _master,\n",
          "message": "Parameter '_master' of PoaProxy. (PoaProxy.sol#14) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 15,
          "vulnerability_to_line": null,
          "vulnerability_code": "    address _registry\n",
          "message": "Parameter '_registry' of PoaProxy. (PoaProxy.sol#15) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 62,
          "vulnerability_to_line": null,
          "vulnerability_code": "    string _name\n",
          "message": "Parameter '_name' of PoaProxy.getContractAddress (PoaProxy.sol#62) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 112,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function proxyChangeMaster(address _newMaster)\n",
          "message": "Parameter '_newMaster' of PoaProxy.proxyChangeMaster (PoaProxy.sol#112) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 7,
          "vulnerability_to_line": null,
          "vulnerability_code": "  uint8 public constant version = 1;\n",
          "message": "Constant 'PoaProxy.version' (PoaProxy.sol#7) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 8,
          "vulnerability_to_line": null,
          "vulnerability_code": "  bytes32 public constant proxyMasterContractSlot = keccak256(\"masterAddress\");\n",
          "message": "Constant 'PoaProxy.proxyMasterContractSlot' (PoaProxy.sol#8) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 9,
          "vulnerability_to_line": null,
          "vulnerability_code": "  bytes32 public constant proxyRegistrySlot = keccak256(\"registry\");\n",
          "message": "Constant 'PoaProxy.proxyRegistrySlot' (PoaProxy.sol#9) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        }
      ]
    },
    "smartcheck": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
          "vulnerability_from_line": 35,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function proxyMasterContract()\n",
          "message": null
        },
        {
          "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
          "vulnerability_from_line": 46,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function proxyRegistry()\n",
          "message": null
        },
        {
          "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
          "vulnerability_from_line": 61,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function getContractAddress(\n",
          "message": null
        },
        {
          "name": "SOLIDITY_LOCKED_MONEY",
          "vulnerability_from_line": 6,
          "vulnerability_to_line": null,
          "vulnerability_code": "contract PoaProxy {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
          "vulnerability_from_line": 35,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function proxyMasterContract()\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
          "vulnerability_from_line": 46,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function proxyRegistry()\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
          "vulnerability_from_line": 61,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function getContractAddress(\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
          "vulnerability_from_line": 98,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function proxyIsContract(address _address)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UNCHECKED_CALL",
          "vulnerability_from_line": 127,
          "vulnerability_to_line": null,
          "vulnerability_code": "    getContractAddress(\"Logger\").call(\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 127,
          "vulnerability_to_line": null,
          "vulnerability_code": "    getContractAddress(\"Logger\").call(\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 62,
          "vulnerability_to_line": null,
          "vulnerability_code": "    string _name\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 25,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 41,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 52,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 72,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 122,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 144,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly {\n",
          "message": null
        }
      ]
    },
    "oyente": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "Integer Overflow",
          "vulnerability_from_line": 61,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function getContractAddress(\n",
          "message": null
        }
      ]
    },
    "mythril": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "Delegatecall to user-supplied address (SWC 112)",
          "vulnerability_from_line": 156,
          "vulnerability_to_line": null,
          "vulnerability_code": "      let success := delegatecall(\n",
          "message": "The contract delegates execution to another contract with a user-supplied address.\nThe smart contract delegates execution to a user-supplied address.This could allow an attacker to execute arbitrary code in the context of this contract account and manipulate the state of the contract account or execute actions on its behalf.\nClassification: SWC-112"
        },
        {
          "name": "Integer Arithmetic Bugs (SWC 101)",
          "vulnerability_from_line": 61,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function getContractAddress(\n",
          "message": "The arithmetic operator can overflow.\nIt is possible to cause an integer overflow or underflow in the arithmetic operation. \nClassification: SWC-101"
        },
        {
          "name": "Multiple Calls in a Single Transaction (SWC 113)",
          "vulnerability_from_line": 78,
          "vulnerability_to_line": null,
          "vulnerability_code": "      let success := staticcall(\n",
          "message": "Multiple calls are executed in the same transaction.\nThis call is executed following another call within the same transaction. It is possible that the call never gets executed if a prior call fails permanently. This might be caused intentionally by a malicious callee. If possible, refactor the code such that each transaction only executes one external call or make sure that all callees can be trusted (i.e. they\u2019re part of your own codebase).\nClassification: SWC-113"
        },
        {
          "name": "External Call To User-Supplied Address (SWC 107)",
          "vulnerability_from_line": 127,
          "vulnerability_to_line": null,
          "vulnerability_code": "    getContractAddress(\"Logger\").call(\n",
          "message": "A call to a user-supplied address is executed.\nAn external message call to an address specified by the caller is executed. Note that the callee account might contain arbitrary code and could re-enter any function within this contract. Reentering the contract in an intermediate state may lead to unexpected behaviour. Make sure that no state modifications are executed after this call and/or reentrancy guards are in place.\nClassification: SWC-107"
        },
        {
          "name": "Unchecked return value from external call. (SWC 104)",
          "vulnerability_from_line": 127,
          "vulnerability_to_line": null,
          "vulnerability_code": "    getContractAddress(\"Logger\").call(\n",
          "message": "The return value of a message call is not checked.\nExternal calls return a boolean value. If the callee halts with an exception, 'false' is returned and execution continues in the caller. The caller should check whether an exception happened and react accordingly to avoid unexpected behavior. For example it is often desirable to wrap external calls in require() so the transaction is reverted if the call fails.\nClassification: SWC-104"
        }
      ]
    },
    "osiris": {
      "successfull_analysis": true,
      "errors": [
        "UNKNOWN INSTRUCTION: STATICCALL"
      ],
      "vulnerability_findings": [
        {
          "name": "Callstack bug",
          "vulnerability_from_line": 127,
          "vulnerability_to_line": null,
          "vulnerability_code": "    getContractAddress(\"Logger\").call(\n",
          "message": null
        }
      ]
    }
  }
}