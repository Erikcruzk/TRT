{
  "smartbugs_completed": true,
  "analyzer_results": {
    "semgrep": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "use-ownable2step",
          "vulnerability_from_line": 63,
          "vulnerability_to_line": null,
          "vulnerability_code": "contract Haltable is Ownable {\n",
          "message": "By demanding that the receiver of the owner permissions actively accept via a contract call of its own,  `Ownable2Step` and `Ownable2StepUpgradeable` prevent the contract ownership from accidentally being transferred  to an address that cannot handle it."
        },
        {
          "name": "use-ownable2step",
          "vulnerability_from_line": 380,
          "vulnerability_to_line": null,
          "vulnerability_code": "contract ReleasableToken is StandardToken, Ownable {\n",
          "message": "By demanding that the receiver of the owner permissions actively accept via a contract call of its own,  `Ownable2Step` and `Ownable2StepUpgradeable` prevent the contract ownership from accidentally being transferred  to an address that cannot handle it."
        },
        {
          "name": "use-ownable2step",
          "vulnerability_from_line": 691,
          "vulnerability_to_line": null,
          "vulnerability_code": "contract MintableToken is Mintable, Ownable {\n",
          "message": "By demanding that the receiver of the owner permissions actively accept via a contract call of its own,  `Ownable2Step` and `Ownable2StepUpgradeable` prevent the contract ownership from accidentally being transferred  to an address that cannot handle it."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 1225,
          "vulnerability_to_line": null,
          "vulnerability_code": "    for (uint i = 0; i < tranches.length; i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 1247,
          "vulnerability_to_line": null,
          "vulnerability_code": "    for (uint i = 0; i < tranches.length; i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "init-variables-with-default-value",
          "vulnerability_from_line": 386,
          "vulnerability_to_line": null,
          "vulnerability_code": "  bool public released = false;\n",
          "message": "Uninitialized variables are assigned with the types default value. Explicitly initializing a variable with its default value costs unnecessary gas."
        },
        {
          "name": "init-variables-with-default-value",
          "vulnerability_from_line": 530,
          "vulnerability_to_line": null,
          "vulnerability_code": "  uint public totalUpgraded = 0;\n",
          "message": "Uninitialized variables are assigned with the types default value. Explicitly initializing a variable with its default value costs unnecessary gas."
        },
        {
          "name": "init-variables-with-default-value",
          "vulnerability_from_line": 695,
          "vulnerability_to_line": null,
          "vulnerability_code": "  bool public mintingFinished = false;\n",
          "message": "Uninitialized variables are assigned with the types default value. Explicitly initializing a variable with its default value costs unnecessary gas."
        },
        {
          "name": "init-variables-with-default-value",
          "vulnerability_from_line": 861,
          "vulnerability_to_line": null,
          "vulnerability_code": "  uint public tokensSold = 0;\n",
          "message": "Uninitialized variables are assigned with the types default value. Explicitly initializing a variable with its default value costs unnecessary gas."
        },
        {
          "name": "init-variables-with-default-value",
          "vulnerability_from_line": 864,
          "vulnerability_to_line": null,
          "vulnerability_code": "  uint public weiRaised = 0;\n",
          "message": "Uninitialized variables are assigned with the types default value. Explicitly initializing a variable with its default value costs unnecessary gas."
        },
        {
          "name": "init-variables-with-default-value",
          "vulnerability_from_line": 867,
          "vulnerability_to_line": null,
          "vulnerability_code": "  uint public investorCount = 0;\n",
          "message": "Uninitialized variables are assigned with the types default value. Explicitly initializing a variable with its default value costs unnecessary gas."
        },
        {
          "name": "init-variables-with-default-value",
          "vulnerability_from_line": 870,
          "vulnerability_to_line": null,
          "vulnerability_code": "  bool public finalized = false;\n",
          "message": "Uninitialized variables are assigned with the types default value. Explicitly initializing a variable with its default value costs unnecessary gas."
        },
        {
          "name": "init-variables-with-default-value",
          "vulnerability_from_line": 873,
          "vulnerability_to_line": null,
          "vulnerability_code": "  bool public requireCustomerId = false;\n",
          "message": "Uninitialized variables are assigned with the types default value. Explicitly initializing a variable with its default value costs unnecessary gas."
        },
        {
          "name": "init-variables-with-default-value",
          "vulnerability_from_line": 879,
          "vulnerability_to_line": null,
          "vulnerability_code": "  bool public requiredSignedAddress = false;\n",
          "message": "Uninitialized variables are assigned with the types default value. Explicitly initializing a variable with its default value costs unnecessary gas."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 1225,
          "vulnerability_to_line": null,
          "vulnerability_code": "    for (uint i = 0; i < tranches.length; i++) {\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 1239,
          "vulnerability_to_line": null,
          "vulnerability_code": "      tranches[i] = last_tranche;\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 1247,
          "vulnerability_to_line": null,
          "vulnerability_code": "    for (uint i = 0; i < tranches.length; i++) {\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 1248,
          "vulnerability_to_line": null,
          "vulnerability_code": "      if (tranches[i].start <= block.timestamp && block.timestamp < tranches[i].end && tokensSold < tranches[i].amount) {\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 1248,
          "vulnerability_to_line": null,
          "vulnerability_code": "      if (tranches[i].start <= block.timestamp && block.timestamp < tranches[i].end && tokensSold < tranches[i].amount) {\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 1248,
          "vulnerability_to_line": null,
          "vulnerability_code": "      if (tranches[i].start <= block.timestamp && block.timestamp < tranches[i].end && tokensSold < tranches[i].amount) {\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 1249,
          "vulnerability_to_line": null,
          "vulnerability_code": "        return tranches[i];\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 1225,
          "vulnerability_to_line": null,
          "vulnerability_code": "    for (uint i = 0; i < tranches.length; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 1247,
          "vulnerability_to_line": null,
          "vulnerability_code": "    for (uint i = 0; i < tranches.length; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 926,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require(start != 0 && end != 0);\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 927,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require(block.timestamp < start && start < end);\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 1232,
          "vulnerability_to_line": null,
          "vulnerability_code": "      require(block.timestamp < start && start < end);\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 1235,
          "vulnerability_to_line": null,
          "vulnerability_code": "      require(i == 0 || (end >= last_tranche.end && amount > last_tranche.amount) ||\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 1236,
          "vulnerability_to_line": null,
          "vulnerability_code": "              (end > last_tranche.end && amount >= last_tranche.amount));\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 1355,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require(startingTime > block.timestamp && startingTime < endsAt);\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 1361,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require(endingTime > block.timestamp && endingTime > startsAt);\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 1106,
          "vulnerability_to_line": null,
          "vulnerability_code": "    else if (block.timestamp <= endsAt && !isCrowdsaleFull()) return State.Funding;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 1107,
          "vulnerability_to_line": null,
          "vulnerability_code": "    else return State.Success;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 1248,
          "vulnerability_to_line": null,
          "vulnerability_code": "      if (tranches[i].start <= block.timestamp && block.timestamp < tranches[i].end && tokensSold < tranches[i].amount) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 1249,
          "vulnerability_to_line": null,
          "vulnerability_code": "        return tranches[i];\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 1250,
          "vulnerability_to_line": null,
          "vulnerability_code": "      }\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 969,
          "vulnerability_to_line": null,
          "vulnerability_code": "      investorCount++;\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 1225,
          "vulnerability_to_line": null,
          "vulnerability_code": "    for (uint i = 0; i < tranches.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 1247,
          "vulnerability_to_line": null,
          "vulnerability_code": "    for (uint i = 0; i < tranches.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        }
      ]
    },
    "slither": {
      "successfull_analysis": true,
      "errors": [
        "EXIT_CODE_75"
      ],
      "vulnerability_findings": [
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 563,
          "vulnerability_to_line": 579,
          "vulnerability_code": "  function upgrade(uint value) public {\n\n    UpgradeState state = getUpgradeState();\n\n    // Ensure it's not called in a bad state\n\n    require(state == UpgradeState.ReadyToUpgrade || state == UpgradeState.Upgrading);\n\n\n\n    // Validate input value.\n\n    require(value != 0);\n\n\n\n    // Upgrade agent reissues the tokens\n\n    upgradeAgent.upgradeFrom(msg.sender, value);\n\n    \n\n    // Take tokens out from circulation\n\n    burnTokens(msg.sender, value);\n\n    totalUpgraded = totalUpgraded.add(value);\n\n\n\n    Upgrade(msg.sender, upgradeAgent, value);\n",
          "message": "Reentrancy in UpgradeableToken.upgrade (Crowdsale.sol#563-579):\n\tExternal calls:\n\t- upgradeAgent.upgradeFrom(msg.sender,value) (Crowdsale.sol#572)\n\tState variables written after the call(s):\n\t- totalUpgraded (Crowdsale.sol#576)\n"
        },
        {
          "name": "unused-return",
          "vulnerability_from_line": 665,
          "vulnerability_to_line": 670,
          "vulnerability_code": "  function enableLostAndFound(address agent, uint tokens, EIP20Token token_contract) public {\n\n    require(msg.sender == getLostAndFoundMaster());\n\n    // We use approve instead of transfer to minimize the possibility of the lost and found master\n\n    //  getting them stuck in another address by accident.\n\n    token_contract.approve(agent, tokens);\n",
          "message": "LostAndFoundToken.enableLostAndFound (Crowdsale.sol#665-670) does not use the value returned by external calls:\n\t-token_contract.approve(agent,tokens) (Crowdsale.sol#669)\n"
        },
        {
          "name": "unused-return",
          "vulnerability_from_line": 1346,
          "vulnerability_to_line": 1351,
          "vulnerability_code": "  function finalize() public inState(State.Success) onlyOwner stopInEmergency {\n\n    token.releaseTokenTransfer();\n\n    uint unsoldTokens = token.balanceOf(address(this));\n\n    token.transfer(multisigWallet, unsoldTokens);\n\n    super.finalize();\n",
          "message": "Crowdsale.finalize (Crowdsale.sol#1346-1351) does not use the value returned by external calls:\n\t-token.transfer(multisigWallet,unsoldTokens) (Crowdsale.sol#1349)\n"
        },
        {
          "name": "unused-return",
          "vulnerability_from_line": 1312,
          "vulnerability_to_line": 1314,
          "vulnerability_code": "  function assignTokens(address receiver, uint tokenAmount) internal {\n\n    token.transfer(receiver, tokenAmount);\n",
          "message": "Crowdsale.assignTokens (Crowdsale.sol#1312-1314) does not use the value returned by external calls:\n\t-token.transfer(receiver,tokenAmount) (Crowdsale.sol#1313)\n"
        },
        {
          "name": "shadowing-local",
          "vulnerability_from_line": 269,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint allowance = allowed[from][msg.sender];\n",
          "message": "StandardToken.transferFrom.allowance (local variable @ Crowdsale.sol#269) shadows:\n\t- StandardToken.allowance (function @ Crowdsale.sol#306-308)\n\t- EIP20Token.allowance (function @ Crowdsale.sol#161)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 1346,
          "vulnerability_to_line": 1351,
          "vulnerability_code": "  function finalize() public inState(State.Success) onlyOwner stopInEmergency {\n\n    token.releaseTokenTransfer();\n\n    uint unsoldTokens = token.balanceOf(address(this));\n\n    token.transfer(multisigWallet, unsoldTokens);\n\n    super.finalize();\n",
          "message": "Reentrancy in Crowdsale.finalize (Crowdsale.sol#1346-1351):\n\tExternal calls:\n\t- token.releaseTokenTransfer() (Crowdsale.sol#1347)\n\t- unsoldTokens = token.balanceOf(address(this)) (Crowdsale.sol#1348)\n\t- token.transfer(multisigWallet,unsoldTokens) (Crowdsale.sol#1349)\n\tState variables written after the call(s):\n\t- finalized (Crowdsale.sol#1350)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 993,
          "vulnerability_to_line": 999,
          "vulnerability_code": "  function preallocate(address receiver, uint fullTokens, uint weiPrice) public onlyOwner notFinished {\n\n    require(receiver != address(0));\n\n    uint tokenAmount = fullTokens.mul(10**uint(token.decimals()));\n\n    require(tokenAmount != 0);\n\n    uint weiAmount = weiPrice.mul(tokenAmount); // This can also be 0, in which case we give out tokens for free\n\n    updateInvestorFunds(tokenAmount, weiAmount, receiver , 0);\n",
          "message": "Reentrancy in GenericCrowdsale.preallocate (Crowdsale.sol#993-999):\n\tExternal calls:\n\t- tokenAmount = fullTokens.mul(10 ** uint256(token.decimals())) (Crowdsale.sol#995)\n\tState variables written after the call(s):\n\t- investedAmountOf (Crowdsale.sol#998)\n\t- tokenAmountOf (Crowdsale.sol#998)\n\t- tokensSold (Crowdsale.sol#998)\n\t- weiRaised (Crowdsale.sol#998)\n"
        },
        {
          "name": "timestamp",
          "vulnerability_from_line": 922,
          "vulnerability_to_line": 930,
          "vulnerability_code": "  function GenericCrowdsale(address team_multisig, uint start, uint end) internal {\n\n    setMultisig(team_multisig);\n\n\n\n    // Don't mess the dates\n\n    require(start != 0 && end != 0);\n\n    require(block.timestamp < start && start < end);\n\n    startsAt = start;\n\n    endsAt = end;\n",
          "message": "GenericCrowdsale.GenericCrowdsale (Crowdsale.sol#922-930) uses timestamp for comparisons\n\tDangerous comparisons:\n\t- require(bool)(block.timestamp < start && start < end) (Crowdsale.sol#927)\n"
        },
        {
          "name": "timestamp",
          "vulnerability_from_line": 1103,
          "vulnerability_to_line": 1108,
          "vulnerability_code": "  function getState() public constant returns (State) {\n\n    if (finalized) return State.Finalized;\n\n    else if (block.timestamp < startsAt) return State.PreFunding;\n\n    else if (block.timestamp <= endsAt && !isCrowdsaleFull()) return State.Funding;\n\n    else return State.Success;\n",
          "message": "GenericCrowdsale.getState (Crowdsale.sol#1103-1108) uses timestamp for comparisons\n\tDangerous comparisons:\n\t- block.timestamp <= endsAt && ! isCrowdsaleFull() (Crowdsale.sol#1106-1107)\n\t- block.timestamp < startsAt (Crowdsale.sol#1105-1107)\n"
        },
        {
          "name": "timestamp",
          "vulnerability_from_line": 1216,
          "vulnerability_to_line": 1241,
          "vulnerability_code": "  function TokenTranchePricing(uint[] init_tranches) public {\n\n    // Need to have tuples, length check\n\n    require(init_tranches.length % tranche_size == 0);\n\n    // A tranche with amount zero can never be selected and is therefore useless.\n\n    // This check and the one inside the loop ensure no tranche can have an amount equal to zero.\n\n    require(init_tranches[amount_offset] > 0);\n\n\n\n    tranches.length = init_tranches.length.div(tranche_size);\n\n    Tranche memory last_tranche;\n\n    for (uint i = 0; i < tranches.length; i++) {\n\n      uint tranche_offset = i.mul(tranche_size);\n\n      uint amount = init_tranches[tranche_offset.add(amount_offset)];\n\n      uint start = init_tranches[tranche_offset.add(start_offset)];\n\n      uint end = init_tranches[tranche_offset.add(end_offset)];\n\n      uint price = init_tranches[tranche_offset.add(price_offset)];\n\n      // No invalid steps\n\n      require(block.timestamp < start && start < end);\n\n      // Bail out when entering unnecessary tranches\n\n      // This is preferably checked before deploying contract into any blockchain.\n\n      require(i == 0 || (end >= last_tranche.end && amount > last_tranche.amount) ||\n\n              (end > last_tranche.end && amount >= last_tranche.amount));\n\n\n\n      last_tranche = Tranche(amount, start, end, price);\n\n      tranches[i] = last_tranche;\n\n    }\n",
          "message": "TokenTranchePricing.TokenTranchePricing (Crowdsale.sol#1216-1241) uses timestamp for comparisons\n\tDangerous comparisons:\n\t- require(bool)(block.timestamp < start && start < end) (Crowdsale.sol#1232)\n"
        },
        {
          "name": "timestamp",
          "vulnerability_from_line": 1246,
          "vulnerability_to_line": 1254,
          "vulnerability_code": "  function getCurrentTranche(uint tokensSold) private constant returns (Tranche storage) {\n\n    for (uint i = 0; i < tranches.length; i++) {\n\n      if (tranches[i].start <= block.timestamp && block.timestamp < tranches[i].end && tokensSold < tranches[i].amount) {\n\n        return tranches[i];\n\n      }\n\n    }\n\n    // No tranche is currently active\n\n    revert();\n",
          "message": "TokenTranchePricing.getCurrentTranche (Crowdsale.sol#1246-1254) uses timestamp for comparisons\n\tDangerous comparisons:\n\t- tranches[i].start <= block.timestamp && block.timestamp < tranches[i].end && tokensSold < tranches[i].amount (Crowdsale.sol#1248-1250)\n"
        },
        {
          "name": "timestamp",
          "vulnerability_from_line": 1354,
          "vulnerability_to_line": 1357,
          "vulnerability_code": "  function setStartingTime(uint startingTime) public onlyOwner inState(State.PreFunding) {\n\n    require(startingTime > block.timestamp && startingTime < endsAt);\n\n    startsAt = startingTime;\n",
          "message": "Crowdsale.setStartingTime (Crowdsale.sol#1354-1357) uses timestamp for comparisons\n\tDangerous comparisons:\n\t- require(bool)(startingTime > block.timestamp && startingTime < endsAt) (Crowdsale.sol#1355)\n"
        },
        {
          "name": "timestamp",
          "vulnerability_from_line": 1360,
          "vulnerability_to_line": 1363,
          "vulnerability_code": "  function setEndingTime(uint endingTime) public onlyOwner notFinished {\n\n    require(endingTime > block.timestamp && endingTime > startsAt);\n\n    endsAt = endingTime;\n",
          "message": "Crowdsale.setEndingTime (Crowdsale.sol#1360-1363) uses timestamp for comparisons\n\tDangerous comparisons:\n\t- require(bool)(endingTime > block.timestamp && endingTime > startsAt) (Crowdsale.sol#1361)\n"
        },
        {
          "name": "constable-states",
          "vulnerability_from_line": 770,
          "vulnerability_to_line": null,
          "vulnerability_code": "  string public name = \"WorldBit Token\";\n",
          "message": "CrowdsaleToken.name should be constant (Crowdsale.sol#770)\nCrowdsaleToken.symbol should be constant (Crowdsale.sol#772)\nUpgradeAgent.originalSupply should be constant (Crowdsale.sol#476)\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 41,
          "vulnerability_to_line": 44,
          "vulnerability_code": "  function transferOwnership(address newOwner) onlyOwner public {\n\n    require(newOwner != address(0));\n\n    owner = newOwner;\n",
          "message": "Ownable.transferOwnership (Crowdsale.sol#41-44) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 157,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function balanceOf(address who) public constant returns (uint256);\n",
          "message": "EIP20Token.balanceOf (Crowdsale.sol#157) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 258,
          "vulnerability_to_line": 260,
          "vulnerability_code": "  function balanceOf(address account) public constant returns (uint balance) {\n\n    return balances[account];\n",
          "message": "StandardToken.balanceOf (Crowdsale.sol#258-260) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 287,
          "vulnerability_to_line": 298,
          "vulnerability_code": "  function approve(address spender, uint value) public returns (bool success) {\n\n\n\n    // To change the approve amount you first have to reduce the addresses'\n\n    //  allowance to zero by calling `approve(spender, 0)` if it is not\n\n    //  already 0 to mitigate the race condition described here:\n\n    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n\n    require (value == 0 || allowed[msg.sender][spender] == 0);\n\n\n\n    allowed[msg.sender][spender] = value;\n\n    Approval(msg.sender, spender, value);\n\n    return true;\n",
          "message": "StandardToken.approve (Crowdsale.sol#287-298) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 160,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function approve(address spender, uint256 value) public returns (bool success);\n",
          "message": "EIP20Token.approve (Crowdsale.sol#160) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 306,
          "vulnerability_to_line": 308,
          "vulnerability_code": "  function allowance(address account, address spender) public constant returns (uint remaining) {\n\n    return allowed[account][spender];\n",
          "message": "StandardToken.allowance (Crowdsale.sol#306-308) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 161,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function allowance(address owner, address spender) public constant returns (uint256 remaining);\n",
          "message": "EIP20Token.allowance (Crowdsale.sol#161) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 316,
          "vulnerability_to_line": 321,
          "vulnerability_code": "  function addApproval(address spender, uint addedValue) public returns (bool success) {\n\n      uint oldValue = allowed[msg.sender][spender];\n\n      allowed[msg.sender][spender] = oldValue.add(addedValue);\n\n      Approval(msg.sender, spender, allowed[msg.sender][spender]);\n\n      return true;\n",
          "message": "StandardToken.addApproval (Crowdsale.sol#316-321) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 328,
          "vulnerability_to_line": 339,
          "vulnerability_code": "  function subApproval(address spender, uint subtractedValue) public returns (bool success) {\n\n\n\n      uint oldVal = allowed[msg.sender][spender];\n\n\n\n      if (subtractedValue > oldVal) {\n\n          allowed[msg.sender][spender] = 0;\n\n      } else {\n\n          allowed[msg.sender][spender] = oldVal.sub(subtractedValue);\n\n      }\n\n      Approval(msg.sender, spender, allowed[msg.sender][spender]);\n\n      return true;\n",
          "message": "StandardToken.subApproval (Crowdsale.sol#328-339) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 397,
          "vulnerability_to_line": 400,
          "vulnerability_code": "  function setReleaseAgent(address addr) onlyOwner inReleaseState(false) public {\n\n    // We don't do interface check here as we might want to have a normal wallet address to act as a release agent.\n\n    releaseAgent = addr;\n",
          "message": "ReleasableToken.setReleaseAgent (Crowdsale.sol#397-400) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 405,
          "vulnerability_to_line": 407,
          "vulnerability_code": "  function setTransferAgent(address addr, bool state) onlyOwner inReleaseState(false) public {\n\n    transferAgents[addr] = state;\n",
          "message": "ReleasableToken.setTransferAgent (Crowdsale.sol#405-407) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 479,
          "vulnerability_to_line": 481,
          "vulnerability_code": "  function isUpgradeAgent() public constant returns (bool) {\n\n    return true;\n",
          "message": "UpgradeAgent.isUpgradeAgent (Crowdsale.sol#479-481) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 499,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function upgradeFrom(address from, uint value) public;\n",
          "message": "UpgradeAgent.upgradeFrom (Crowdsale.sol#499) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 563,
          "vulnerability_to_line": 579,
          "vulnerability_code": "  function upgrade(uint value) public {\n\n    UpgradeState state = getUpgradeState();\n\n    // Ensure it's not called in a bad state\n\n    require(state == UpgradeState.ReadyToUpgrade || state == UpgradeState.Upgrading);\n\n\n\n    // Validate input value.\n\n    require(value != 0);\n\n\n\n    // Upgrade agent reissues the tokens\n\n    upgradeAgent.upgradeFrom(msg.sender, value);\n\n    \n\n    // Take tokens out from circulation\n\n    burnTokens(msg.sender, value);\n\n    totalUpgraded = totalUpgraded.add(value);\n\n\n\n    Upgrade(msg.sender, upgradeAgent, value);\n",
          "message": "UpgradeableToken.upgrade (Crowdsale.sol#563-579) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 617,
          "vulnerability_to_line": 619,
          "vulnerability_code": "  function changeUpgradeMaster(address new_master) onlyMaster public {\n\n    setUpgradeMaster(new_master);\n",
          "message": "UpgradeableToken.changeUpgradeMaster (Crowdsale.sol#617-619) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 719,
          "vulnerability_to_line": 721,
          "vulnerability_code": "  function mint(address receiver, uint amount) onlyMintAgent canMint public {\n\n    mintInternal(receiver, amount);\n",
          "message": "MintableToken.mint (Crowdsale.sol#719-721) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 726,
          "vulnerability_to_line": 729,
          "vulnerability_code": "  function setMintAgent(address addr, bool state) onlyOwner canMint public {\n\n    mintAgents[addr] = state;\n\n    MintingAgentChanged(addr, state);\n",
          "message": "MintableToken.setMintAgent (Crowdsale.sol#726-729) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 815,
          "vulnerability_to_line": 817,
          "vulnerability_code": "  function WorldBit(address object, bytes2 operand, bytes2 command, uint256 val1, uint256 val2, string location, string str1, string str2, string comment) public {\n\n    WorldBitEvent(object, operand, command, val1, val2, location, str1, str2, comment);\n",
          "message": "CrowdsaleToken.WorldBit (Crowdsale.sol#815-817) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 937,
          "vulnerability_to_line": 939,
          "vulnerability_code": "  function() payable public {\n\n    buy();\n",
          "message": "GenericCrowdsale.fallback (Crowdsale.sol#937-939) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 993,
          "vulnerability_to_line": 999,
          "vulnerability_code": "  function preallocate(address receiver, uint fullTokens, uint weiPrice) public onlyOwner notFinished {\n\n    require(receiver != address(0));\n\n    uint tokenAmount = fullTokens.mul(10**uint(token.decimals()));\n\n    require(tokenAmount != 0);\n\n    uint weiAmount = weiPrice.mul(tokenAmount); // This can also be 0, in which case we give out tokens for free\n\n    updateInvestorFunds(tokenAmount, weiAmount, receiver , 0);\n",
          "message": "GenericCrowdsale.preallocate (Crowdsale.sol#993-999) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 1023,
          "vulnerability_to_line": 1027,
          "vulnerability_code": "  function buyWithSignedAddress(uint128 customerId, uint8 v, bytes32 r, bytes32 s) public payable validCustomerId(customerId) {\n\n    bytes32 hash = sha256(msg.sender);\n\n    require(ecrecover(hash, v, r, s) == signerAddress);\n\n    investInternal(msg.sender, customerId);\n",
          "message": "GenericCrowdsale.buyWithSignedAddress (Crowdsale.sol#1023-1027) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 1035,
          "vulnerability_to_line": 1037,
          "vulnerability_code": "  function buyWithCustomerId(uint128 customerId) public payable validCustomerId(customerId) unsignedBuyAllowed {\n\n    investInternal(msg.sender, customerId);\n",
          "message": "GenericCrowdsale.buyWithCustomerId (Crowdsale.sol#1035-1037) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 1064,
          "vulnerability_to_line": 1067,
          "vulnerability_code": "  function setRequireCustomerId(bool value) public onlyOwner {\n\n    requireCustomerId = value;\n\n    InvestmentPolicyChanged(requireCustomerId, requiredSignedAddress, signerAddress);\n",
          "message": "GenericCrowdsale.setRequireCustomerId (Crowdsale.sol#1064-1067) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 1075,
          "vulnerability_to_line": 1079,
          "vulnerability_code": "  function setRequireSignedAddress(bool value, address signer) public onlyOwner {\n\n    requiredSignedAddress = value;\n\n    signerAddress = signer;\n\n    InvestmentPolicyChanged(requireCustomerId, requiredSignedAddress, signerAddress);\n",
          "message": "GenericCrowdsale.setRequireSignedAddress (Crowdsale.sol#1075-1079) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 1084,
          "vulnerability_to_line": 1087,
          "vulnerability_code": "  function setEarlyParticipantWhitelist(address addr, bool status) public onlyOwner notFinished stopInEmergency {\n\n    earlyParticipantWhitelist[addr] = status;\n\n    Whitelisted(addr, status);\n",
          "message": "GenericCrowdsale.setEarlyParticipantWhitelist (Crowdsale.sol#1084-1087) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 1354,
          "vulnerability_to_line": 1357,
          "vulnerability_code": "  function setStartingTime(uint startingTime) public onlyOwner inState(State.PreFunding) {\n\n    require(startingTime > block.timestamp && startingTime < endsAt);\n\n    startsAt = startingTime;\n",
          "message": "Crowdsale.setStartingTime (Crowdsale.sol#1354-1357) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 1360,
          "vulnerability_to_line": 1363,
          "vulnerability_code": "  function setEndingTime(uint endingTime) public onlyOwner notFinished {\n\n    require(endingTime > block.timestamp && endingTime > startsAt);\n\n    endsAt = endingTime;\n",
          "message": "Crowdsale.setEndingTime (Crowdsale.sol#1360-1363) should be declared external\n"
        },
        {
          "name": "solc-version",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.15;\n",
          "message": "Detected issues with version pragma in Crowdsale.sol:\n\t- pragma solidity^0.4.15 (Crowdsale.sol#3): it allows old versions\n\t- pragma solidity^0.4.15 (Crowdsale.sol#50): it allows old versions\n\t- pragma solidity^0.4.15 (Crowdsale.sol#94): it allows old versions\n\t- pragma solidity^0.4.15 (Crowdsale.sol#148): it allows old versions\n\t- pragma solidity^0.4.15 (Crowdsale.sol#178): it allows old versions\n\t- pragma solidity^0.4.15 (Crowdsale.sol#191): it allows old versions\n\t- pragma solidity^0.4.15 (Crowdsale.sol#215): it allows old versions\n\t- pragma solidity^0.4.15 (Crowdsale.sol#369): it allows old versions\n\t- pragma solidity^0.4.15 (Crowdsale.sol#455): it allows old versions\n\t- pragma solidity^0.4.15 (Crowdsale.sol#505): it allows old versions\n\t- pragma solidity^0.4.15 (Crowdsale.sol#645): it allows old versions\n\t- pragma solidity^0.4.15 (Crowdsale.sol#675): it allows old versions\n\t- pragma solidity^0.4.15 (Crowdsale.sol#746): it allows old versions\n\t- pragma solidity^0.4.15 (Crowdsale.sol#825): it allows old versions\n\t- pragma solidity^0.4.15 (Crowdsale.sol#1181): it allows old versions\n\t- pragma solidity^0.4.15 (Crowdsale.sol#1267): it allows old versions\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 23,
          "vulnerability_to_line": 25,
          "vulnerability_code": "  function Ownable() internal {\n\n    owner = msg.sender;\n",
          "message": "Function 'Ownable.Ownable' (Crowdsale.sol#23-25) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 232,
          "vulnerability_to_line": null,
          "vulnerability_code": "  uint private total_supply;\n",
          "message": "Variable 'StandardToken.total_supply' (Crowdsale.sol#232) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 556,
          "vulnerability_to_line": 558,
          "vulnerability_code": "  function UpgradeableToken(address master) internal {\n\n    setUpgradeMaster(master);\n",
          "message": "Function 'UpgradeableToken.UpgradeableToken' (Crowdsale.sol#556-558) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 617,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function changeUpgradeMaster(address new_master) onlyMaster public {\n",
          "message": "Parameter 'new_master' of UpgradeableToken.changeUpgradeMaster (Crowdsale.sol#617) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 624,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function setUpgradeMaster(address new_master) private {\n",
          "message": "Parameter 'new_master' of UpgradeableToken.setUpgradeMaster (Crowdsale.sol#624) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 665,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function enableLostAndFound(address agent, uint tokens, EIP20Token token_contract) public {\n",
          "message": "Parameter 'token_contract' of LostAndFoundToken.enableLostAndFound (Crowdsale.sol#665) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 703,
          "vulnerability_to_line": 712,
          "vulnerability_code": "  function MintableToken(uint initialSupply, address multisig, bool mintable) internal {\n\n    require(multisig != address(0));\n\n    // Cannot create a token without supply and no minting\n\n    require(mintable || initialSupply != 0);\n\n    // Create initially all balance on the team multisig\n\n    if (initialSupply > 0)\n\n      mintInternal(multisig, initialSupply);\n\n    // No more new supply allowed after the token creation\n\n    mintingFinished = !mintable;\n",
          "message": "Function 'MintableToken.MintableToken' (Crowdsale.sol#703-712) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 789,
          "vulnerability_to_line": 794,
          "vulnerability_code": "  function CrowdsaleToken(uint initial_supply, uint8 token_decimals, address team_multisig, bool mintable, address token_retriever) public\n\n  UpgradeableToken(team_multisig) MintableToken(initial_supply, team_multisig, mintable) {\n\n    require(token_retriever != address(0));\n\n    decimals = token_decimals;\n\n    lost_and_found_master = token_retriever;\n",
          "message": "Function 'CrowdsaleToken.CrowdsaleToken' (Crowdsale.sol#789-794) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 789,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function CrowdsaleToken(uint initial_supply, uint8 token_decimals, address team_multisig, bool mintable, address token_retriever) public\n",
          "message": "Parameter 'initial_supply' of CrowdsaleToken.CrowdsaleToken (Crowdsale.sol#789) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 789,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function CrowdsaleToken(uint initial_supply, uint8 token_decimals, address team_multisig, bool mintable, address token_retriever) public\n",
          "message": "Parameter 'token_decimals' of CrowdsaleToken.CrowdsaleToken (Crowdsale.sol#789) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 789,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function CrowdsaleToken(uint initial_supply, uint8 token_decimals, address team_multisig, bool mintable, address token_retriever) public\n",
          "message": "Parameter 'team_multisig' of CrowdsaleToken.CrowdsaleToken (Crowdsale.sol#789) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 789,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function CrowdsaleToken(uint initial_supply, uint8 token_decimals, address team_multisig, bool mintable, address token_retriever) public\n",
          "message": "Parameter 'token_retriever' of CrowdsaleToken.CrowdsaleToken (Crowdsale.sol#789) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 815,
          "vulnerability_to_line": 817,
          "vulnerability_code": "  function WorldBit(address object, bytes2 operand, bytes2 command, uint256 val1, uint256 val2, string location, string str1, string str2, string comment) public {\n\n    WorldBitEvent(object, operand, command, val1, val2, location, str1, str2, comment);\n",
          "message": "Function 'CrowdsaleToken.WorldBit' (Crowdsale.sol#815-817) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 776,
          "vulnerability_to_line": null,
          "vulnerability_code": "  address public lost_and_found_master;\n",
          "message": "Variable 'CrowdsaleToken.lost_and_found_master' (Crowdsale.sol#776) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 922,
          "vulnerability_to_line": 930,
          "vulnerability_code": "  function GenericCrowdsale(address team_multisig, uint start, uint end) internal {\n\n    setMultisig(team_multisig);\n\n\n\n    // Don't mess the dates\n\n    require(start != 0 && end != 0);\n\n    require(block.timestamp < start && start < end);\n\n    startsAt = start;\n\n    endsAt = end;\n",
          "message": "Function 'GenericCrowdsale.GenericCrowdsale' (Crowdsale.sol#922-930) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 922,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function GenericCrowdsale(address team_multisig, uint start, uint end) internal {\n",
          "message": "Parameter 'team_multisig' of GenericCrowdsale.GenericCrowdsale (Crowdsale.sol#922) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1216,
          "vulnerability_to_line": 1241,
          "vulnerability_code": "  function TokenTranchePricing(uint[] init_tranches) public {\n\n    // Need to have tuples, length check\n\n    require(init_tranches.length % tranche_size == 0);\n\n    // A tranche with amount zero can never be selected and is therefore useless.\n\n    // This check and the one inside the loop ensure no tranche can have an amount equal to zero.\n\n    require(init_tranches[amount_offset] > 0);\n\n\n\n    tranches.length = init_tranches.length.div(tranche_size);\n\n    Tranche memory last_tranche;\n\n    for (uint i = 0; i < tranches.length; i++) {\n\n      uint tranche_offset = i.mul(tranche_size);\n\n      uint amount = init_tranches[tranche_offset.add(amount_offset)];\n\n      uint start = init_tranches[tranche_offset.add(start_offset)];\n\n      uint end = init_tranches[tranche_offset.add(end_offset)];\n\n      uint price = init_tranches[tranche_offset.add(price_offset)];\n\n      // No invalid steps\n\n      require(block.timestamp < start && start < end);\n\n      // Bail out when entering unnecessary tranches\n\n      // This is preferably checked before deploying contract into any blockchain.\n\n      require(i == 0 || (end >= last_tranche.end && amount > last_tranche.amount) ||\n\n              (end > last_tranche.end && amount >= last_tranche.amount));\n\n\n\n      last_tranche = Tranche(amount, start, end, price);\n\n      tranches[i] = last_tranche;\n\n    }\n",
          "message": "Function 'TokenTranchePricing.TokenTranchePricing' (Crowdsale.sol#1216-1241) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1216,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function TokenTranchePricing(uint[] init_tranches) public {\n",
          "message": "Parameter 'init_tranches' of TokenTranchePricing.TokenTranchePricing (Crowdsale.sol#1216) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1206,
          "vulnerability_to_line": null,
          "vulnerability_code": "  uint private constant amount_offset = 0;\n",
          "message": "Constant 'TokenTranchePricing.amount_offset' (Crowdsale.sol#1206) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1207,
          "vulnerability_to_line": null,
          "vulnerability_code": "  uint private constant start_offset = 1;\n",
          "message": "Constant 'TokenTranchePricing.start_offset' (Crowdsale.sol#1207) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1208,
          "vulnerability_to_line": null,
          "vulnerability_code": "  uint private constant end_offset = 2;\n",
          "message": "Constant 'TokenTranchePricing.end_offset' (Crowdsale.sol#1208) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1209,
          "vulnerability_to_line": null,
          "vulnerability_code": "  uint private constant price_offset = 3;\n",
          "message": "Constant 'TokenTranchePricing.price_offset' (Crowdsale.sol#1209) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1210,
          "vulnerability_to_line": null,
          "vulnerability_code": "  uint private constant tranche_size = 4;\n",
          "message": "Constant 'TokenTranchePricing.tranche_size' (Crowdsale.sol#1210) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1317,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function calculateTokenAmount(uint weiAmount, address) internal constant returns (uint weiAllowed, uint tokenAmount) {\n",
          "message": "Parameter '' of Crowdsale.calculateTokenAmount (Crowdsale.sol#1317) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1369,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function enableLostAndFound(address agent, uint tokens, EIP20Token token_contract) public {\n",
          "message": "Parameter 'token_contract' of Crowdsale.enableLostAndFound (Crowdsale.sol#1369) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1294,
          "vulnerability_to_line": 1309,
          "vulnerability_code": "  function Crowdsale(address team_multisig, uint start, uint end, address token_retriever, uint[] init_tranches)\n\n  GenericCrowdsale(team_multisig, start, end) TokenTranchePricing(init_tranches) public {\n\n    require(end == tranches[tranches.length.sub(1)].end);\n\n    // Testing values\n\n    token = new CrowdsaleToken(token_initial_supply, token_decimals, team_multisig, token_mintable, token_retriever);\n\n\n\n    // Set permissions to mint, transfer and release\n\n    token.setMintAgent(address(this), true);\n\n    token.setTransferAgent(address(this), true);\n\n    token.setReleaseAgent(address(this));\n\n\n\n    // Tokens to be sold through this contract\n\n    token.mint(address(this), sellable_tokens);\n\n    // We don't need to mint anymore during the lifetime of the contract.\n\n    token.setMintAgent(address(this), false);\n",
          "message": "Function 'Crowdsale.Crowdsale' (Crowdsale.sol#1294-1309) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1294,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function Crowdsale(address team_multisig, uint start, uint end, address token_retriever, uint[] init_tranches)\n",
          "message": "Parameter 'team_multisig' of Crowdsale.Crowdsale (Crowdsale.sol#1294) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1294,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function Crowdsale(address team_multisig, uint start, uint end, address token_retriever, uint[] init_tranches)\n",
          "message": "Parameter 'token_retriever' of Crowdsale.Crowdsale (Crowdsale.sol#1294) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1294,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function Crowdsale(address team_multisig, uint start, uint end, address token_retriever, uint[] init_tranches)\n",
          "message": "Parameter 'init_tranches' of Crowdsale.Crowdsale (Crowdsale.sol#1294) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1279,
          "vulnerability_to_line": null,
          "vulnerability_code": "  uint8 private constant token_decimals = 18;\n",
          "message": "Constant 'Crowdsale.token_decimals' (Crowdsale.sol#1279) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1280,
          "vulnerability_to_line": null,
          "vulnerability_code": "  uint private constant token_initial_supply = 1575 * (10 ** 5) * (10 ** uint(token_decimals));\n",
          "message": "Constant 'Crowdsale.token_initial_supply' (Crowdsale.sol#1280) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1281,
          "vulnerability_to_line": null,
          "vulnerability_code": "  bool private constant token_mintable = true;\n",
          "message": "Constant 'Crowdsale.token_mintable' (Crowdsale.sol#1281) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1282,
          "vulnerability_to_line": null,
          "vulnerability_code": "  uint private constant sellable_tokens = 525 * (10 ** 5) * (10 ** uint(token_decimals));\n",
          "message": "Constant 'Crowdsale.sellable_tokens' (Crowdsale.sol#1282) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        }
      ]
    },
    "smartcheck": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 607,
          "vulnerability_to_line": null,
          "vulnerability_code": "    else if (address(upgradeAgent) == 0x00) return UpgradeState.WaitingForAgent;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ARRAY_LENGTH_MANIPULATION",
          "vulnerability_from_line": 1223,
          "vulnerability_to_line": null,
          "vulnerability_code": "    tranches.length = init_tranches.length.div(tranche_size);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
          "vulnerability_from_line": 105,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function mul(uint a, uint b) internal constant returns (uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
          "vulnerability_from_line": 111,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function div(uint a, uint b) internal constant returns (uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
          "vulnerability_from_line": 118,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function sub(uint a, uint b) internal constant returns (uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
          "vulnerability_from_line": 123,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function add(uint a, uint b) internal constant returns (uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
          "vulnerability_from_line": 129,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
          "vulnerability_from_line": 133,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
          "vulnerability_from_line": 137,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function max256(uint a, uint b) internal constant returns (uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
          "vulnerability_from_line": 141,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function min256(uint a, uint b) internal constant returns (uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
          "vulnerability_from_line": 156,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function totalSupply() public constant returns (uint256);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
          "vulnerability_from_line": 157,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function balanceOf(address who) public constant returns (uint256);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
          "vulnerability_from_line": 161,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function allowance(address owner, address spender) public constant returns (uint256 remaining);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
          "vulnerability_from_line": 237,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function totalSupply() public constant returns (uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
          "vulnerability_from_line": 258,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function balanceOf(address account) public constant returns (uint balance) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
          "vulnerability_from_line": 306,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function allowance(address account, address spender) public constant returns (uint remaining) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
          "vulnerability_from_line": 479,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function isUpgradeAgent() public constant returns (bool) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
          "vulnerability_from_line": 605,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function getUpgradeState() public constant returns(UpgradeState) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
          "vulnerability_from_line": 632,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function canUpgrade() public constant returns(bool) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
          "vulnerability_from_line": 658,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function getLostAndFoundMaster() internal constant returns (address);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
          "vulnerability_from_line": 807,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function canUpgrade() public constant returns(bool) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
          "vulnerability_from_line": 811,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function getLostAndFoundMaster() internal constant returns(address) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
          "vulnerability_from_line": 1103,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function getState() public constant returns (State) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
          "vulnerability_from_line": 1118,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function isCrowdsaleFull() internal constant returns (bool full);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
          "vulnerability_from_line": 1141,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function calculateTokenAmount(uint weiAmount, address agent) internal constant returns (uint weiAllowed, uint tokenAmount);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
          "vulnerability_from_line": 1246,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function getCurrentTranche(uint tokensSold) private constant returns (Tranche storage) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
          "vulnerability_from_line": 1259,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function getCurrentPrice(uint tokensSold) internal constant returns (uint result) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
          "vulnerability_from_line": 1317,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function calculateTokenAmount(uint weiAmount, address) internal constant returns (uint weiAllowed, uint tokenAmount) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
          "vulnerability_from_line": 1332,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function isCrowdsaleFull() internal constant returns (bool) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
          "vulnerability_from_line": 1341,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function getLostAndFoundMaster() internal constant returns (address) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ERC20_APPROVE",
          "vulnerability_from_line": 287,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function approve(address spender, uint value) public returns (bool success) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 1225,
          "vulnerability_to_line": null,
          "vulnerability_code": "    for (uint i = 0; i < tranches.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 1247,
          "vulnerability_to_line": null,
          "vulnerability_code": "    for (uint i = 0; i < tranches.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 1225,
          "vulnerability_to_line": null,
          "vulnerability_code": "    for (uint i = 0; i < tranches.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 1247,
          "vulnerability_to_line": null,
          "vulnerability_code": "    for (uint i = 0; i < tranches.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_OVERPOWERED_ROLE",
          "vulnerability_from_line": 397,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function setReleaseAgent(address addr) onlyOwner inReleaseState(false) public {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_OVERPOWERED_ROLE",
          "vulnerability_from_line": 405,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function setTransferAgent(address addr, bool state) onlyOwner inReleaseState(false) public {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_OVERPOWERED_ROLE",
          "vulnerability_from_line": 726,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function setMintAgent(address addr, bool state) onlyOwner canMint public {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_OVERPOWERED_ROLE",
          "vulnerability_from_line": 1064,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function setRequireCustomerId(bool value) public onlyOwner {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_OVERPOWERED_ROLE",
          "vulnerability_from_line": 1075,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function setRequireSignedAddress(bool value, address signer) public onlyOwner {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_OVERPOWERED_ROLE",
          "vulnerability_from_line": 1084,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function setEarlyParticipantWhitelist(address addr, bool status) public onlyOwner notFinished stopInEmergency {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_OVERPOWERED_ROLE",
          "vulnerability_from_line": 1354,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function setStartingTime(uint startingTime) public onlyOwner inState(State.PreFunding) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_OVERPOWERED_ROLE",
          "vulnerability_from_line": 1360,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function setEndingTime(uint endingTime) public onlyOwner notFinished {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.15;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 50,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.15;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 94,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.15;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 148,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.15;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 178,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.15;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 191,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.15;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 215,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.15;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 369,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.15;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 455,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.15;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 505,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.15;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 645,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.15;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 675,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.15;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 746,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.15;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 825,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.15;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 1181,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.15;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 1267,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.15;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 232,
          "vulnerability_to_line": null,
          "vulnerability_code": "  uint private total_supply;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 233,
          "vulnerability_to_line": null,
          "vulnerability_code": "  mapping(address => uint) private balances;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 234,
          "vulnerability_to_line": null,
          "vulnerability_code": "  mapping(address => mapping (address => uint)) private allowed;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 1206,
          "vulnerability_to_line": null,
          "vulnerability_code": "  uint private constant amount_offset = 0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 1207,
          "vulnerability_to_line": null,
          "vulnerability_code": "  uint private constant start_offset = 1;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 1208,
          "vulnerability_to_line": null,
          "vulnerability_code": "  uint private constant end_offset = 2;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 1209,
          "vulnerability_to_line": null,
          "vulnerability_code": "  uint private constant price_offset = 3;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 1210,
          "vulnerability_to_line": null,
          "vulnerability_code": "  uint private constant tranche_size = 4;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 1279,
          "vulnerability_to_line": null,
          "vulnerability_code": "  uint8 private constant token_decimals = 18;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 1280,
          "vulnerability_to_line": null,
          "vulnerability_code": "  uint private constant token_initial_supply = 1575 * (10 ** 5) * (10 ** uint(token_decimals));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 1281,
          "vulnerability_to_line": null,
          "vulnerability_code": "  bool private constant token_mintable = true;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 1282,
          "vulnerability_to_line": null,
          "vulnerability_code": "  uint private constant sellable_tokens = 525 * (10 ** 5) * (10 ** uint(token_decimals));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SAFEMATH",
          "vulnerability_from_line": 230,
          "vulnerability_to_line": null,
          "vulnerability_code": "  using SafeMath for uint;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SAFEMATH",
          "vulnerability_from_line": 521,
          "vulnerability_to_line": null,
          "vulnerability_code": "  using SafeMath for uint;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SAFEMATH",
          "vulnerability_from_line": 693,
          "vulnerability_to_line": null,
          "vulnerability_code": "  using SafeMath for uint;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SAFEMATH",
          "vulnerability_from_line": 846,
          "vulnerability_to_line": null,
          "vulnerability_code": "  using SafeMath for uint;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SAFEMATH",
          "vulnerability_from_line": 1189,
          "vulnerability_to_line": null,
          "vulnerability_code": "  using SafeMath for uint;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 1141,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function calculateTokenAmount(uint weiAmount, address agent) internal constant returns (uint weiAllowed, uint tokenAmount);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 1317,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function calculateTokenAmount(uint weiAmount, address) internal constant returns (uint weiAllowed, uint tokenAmount) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 937,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function() payable public {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 815,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function WorldBit(address object, bytes2 operand, bytes2 command, uint256 val1, uint256 val2, string location, string str1, string str2, string comment) public {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 815,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function WorldBit(address object, bytes2 operand, bytes2 command, uint256 val1, uint256 val2, string location, string str1, string str2, string comment) public {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 815,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function WorldBit(address object, bytes2 operand, bytes2 command, uint256 val1, uint256 val2, string location, string str1, string str2, string comment) public {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 815,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function WorldBit(address object, bytes2 operand, bytes2 command, uint256 val1, uint256 val2, string location, string str1, string str2, string comment) public {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 1216,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function TokenTranchePricing(uint[] init_tranches) public {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 1294,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function Crowdsale(address team_multisig, uint start, uint end, address token_retriever, uint[] init_tranches)\n",
          "message": null
        }
      ]
    },
    "oyente": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "Integer Overflow",
          "vulnerability_from_line": 1248,
          "vulnerability_to_line": null,
          "vulnerability_code": "      if (tranches[i].start <= block.timestamp && block.timestamp < tranches[i].end && tokensSold < tranches[i].amount) {\n",
          "message": null
        },
        {
          "name": "Integer Overflow",
          "vulnerability_from_line": 124,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint c = a + b;\n",
          "message": null
        },
        {
          "name": "Integer Underflow",
          "vulnerability_from_line": 770,
          "vulnerability_to_line": null,
          "vulnerability_code": "  string public name = \"WorldBit Token\";\n",
          "message": null
        },
        {
          "name": "Integer Overflow",
          "vulnerability_from_line": 124,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint c = a + b;\n",
          "message": null
        },
        {
          "name": "Integer Overflow",
          "vulnerability_from_line": 124,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint c = a + b;\n",
          "message": null
        },
        {
          "name": "Integer Overflow",
          "vulnerability_from_line": 1212,
          "vulnerability_to_line": null,
          "vulnerability_code": "  Tranche[] public tranches;\n",
          "message": null
        }
      ]
    },
    "mythril": {
      "successfull_analysis": false,
      "errors": [
        "DOCKER_TIMEOUT"
      ],
      "vulnerability_findings": []
    },
    "osiris": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": []
    }
  }
}