{
  "smartbugs_completed": true,
  "analyzer_results": {
    "semgrep": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 109,
          "vulnerability_to_line": null,
          "vulnerability_code": "    for (uint i = 0; i < tranches.length; i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 131,
          "vulnerability_to_line": null,
          "vulnerability_code": "    for (uint i = 0; i < tranches.length; i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 109,
          "vulnerability_to_line": null,
          "vulnerability_code": "    for (uint i = 0; i < tranches.length; i++) {\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 123,
          "vulnerability_to_line": null,
          "vulnerability_code": "      tranches[i] = last_tranche;\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 131,
          "vulnerability_to_line": null,
          "vulnerability_code": "    for (uint i = 0; i < tranches.length; i++) {\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 132,
          "vulnerability_to_line": null,
          "vulnerability_code": "      if (tranches[i].start <= block.timestamp && block.timestamp < tranches[i].end && tokensSold < tranches[i].amount) {\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 132,
          "vulnerability_to_line": null,
          "vulnerability_code": "      if (tranches[i].start <= block.timestamp && block.timestamp < tranches[i].end && tokensSold < tranches[i].amount) {\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 132,
          "vulnerability_to_line": null,
          "vulnerability_code": "      if (tranches[i].start <= block.timestamp && block.timestamp < tranches[i].end && tokensSold < tranches[i].amount) {\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 133,
          "vulnerability_to_line": null,
          "vulnerability_code": "        return tranches[i];\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 109,
          "vulnerability_to_line": null,
          "vulnerability_code": "    for (uint i = 0; i < tranches.length; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 131,
          "vulnerability_to_line": null,
          "vulnerability_code": "    for (uint i = 0; i < tranches.length; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 116,
          "vulnerability_to_line": null,
          "vulnerability_code": "      require(block.timestamp < start && start < end);\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 119,
          "vulnerability_to_line": null,
          "vulnerability_code": "      require(i == 0 || (end >= last_tranche.end && amount > last_tranche.amount) ||\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 120,
          "vulnerability_to_line": null,
          "vulnerability_code": "              (end > last_tranche.end && amount >= last_tranche.amount));\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 132,
          "vulnerability_to_line": null,
          "vulnerability_code": "      if (tranches[i].start <= block.timestamp && block.timestamp < tranches[i].end && tokensSold < tranches[i].amount) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 133,
          "vulnerability_to_line": null,
          "vulnerability_code": "        return tranches[i];\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 134,
          "vulnerability_to_line": null,
          "vulnerability_code": "      }\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 109,
          "vulnerability_to_line": null,
          "vulnerability_code": "    for (uint i = 0; i < tranches.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 131,
          "vulnerability_to_line": null,
          "vulnerability_code": "    for (uint i = 0; i < tranches.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        }
      ]
    },
    "slither": {
      "successfull_analysis": true,
      "errors": [
        "EXIT_CODE_10"
      ],
      "vulnerability_findings": [
        {
          "name": "timestamp",
          "vulnerability_from_line": 100,
          "vulnerability_to_line": 125,
          "vulnerability_code": "  function TokenTranchePricing(uint[] init_tranches) public {\n\n    // Need to have tuples, length check\n\n    require(init_tranches.length % tranche_size == 0);\n\n    // A tranche with amount zero can never be selected and is therefore useless.\n\n    // This check and the one inside the loop ensure no tranche can have an amount equal to zero.\n\n    require(init_tranches[amount_offset] > 0);\n\n\n\n    tranches.length = init_tranches.length.div(tranche_size);\n\n    Tranche memory last_tranche;\n\n    for (uint i = 0; i < tranches.length; i++) {\n\n      uint tranche_offset = i.mul(tranche_size);\n\n      uint amount = init_tranches[tranche_offset.add(amount_offset)];\n\n      uint start = init_tranches[tranche_offset.add(start_offset)];\n\n      uint end = init_tranches[tranche_offset.add(end_offset)];\n\n      uint price = init_tranches[tranche_offset.add(price_offset)];\n\n      // No invalid steps\n\n      require(block.timestamp < start && start < end);\n\n      // Bail out when entering unnecessary tranches\n\n      // This is preferably checked before deploying contract into any blockchain.\n\n      require(i == 0 || (end >= last_tranche.end && amount > last_tranche.amount) ||\n\n              (end > last_tranche.end && amount >= last_tranche.amount));\n\n\n\n      last_tranche = Tranche(amount, start, end, price);\n\n      tranches[i] = last_tranche;\n\n    }\n",
          "message": "TokenTranchePricing.TokenTranchePricing (TokenTranchePricing.sol#100-125) uses timestamp for comparisons\n\tDangerous comparisons:\n\t- require(bool)(block.timestamp < start && start < end) (TokenTranchePricing.sol#116)\n"
        },
        {
          "name": "timestamp",
          "vulnerability_from_line": 130,
          "vulnerability_to_line": 138,
          "vulnerability_code": "  function getCurrentTranche(uint tokensSold) private constant returns (Tranche storage) {\n\n    for (uint i = 0; i < tranches.length; i++) {\n\n      if (tranches[i].start <= block.timestamp && block.timestamp < tranches[i].end && tokensSold < tranches[i].amount) {\n\n        return tranches[i];\n\n      }\n\n    }\n\n    // No tranche is currently active\n\n    revert();\n",
          "message": "TokenTranchePricing.getCurrentTranche (TokenTranchePricing.sol#130-138) uses timestamp for comparisons\n\tDangerous comparisons:\n\t- tranches[i].start <= block.timestamp && block.timestamp < tranches[i].end && tokensSold < tranches[i].amount (TokenTranchePricing.sol#132-134)\n"
        },
        {
          "name": "solc-version",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.15;\n",
          "message": "Detected issues with version pragma in TokenTranchePricing.sol:\n\t- pragma solidity^0.4.15 (TokenTranchePricing.sol#3): it allows old versions\n\t- pragma solidity^0.4.15 (TokenTranchePricing.sol#65): it allows old versions\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 100,
          "vulnerability_to_line": 125,
          "vulnerability_code": "  function TokenTranchePricing(uint[] init_tranches) public {\n\n    // Need to have tuples, length check\n\n    require(init_tranches.length % tranche_size == 0);\n\n    // A tranche with amount zero can never be selected and is therefore useless.\n\n    // This check and the one inside the loop ensure no tranche can have an amount equal to zero.\n\n    require(init_tranches[amount_offset] > 0);\n\n\n\n    tranches.length = init_tranches.length.div(tranche_size);\n\n    Tranche memory last_tranche;\n\n    for (uint i = 0; i < tranches.length; i++) {\n\n      uint tranche_offset = i.mul(tranche_size);\n\n      uint amount = init_tranches[tranche_offset.add(amount_offset)];\n\n      uint start = init_tranches[tranche_offset.add(start_offset)];\n\n      uint end = init_tranches[tranche_offset.add(end_offset)];\n\n      uint price = init_tranches[tranche_offset.add(price_offset)];\n\n      // No invalid steps\n\n      require(block.timestamp < start && start < end);\n\n      // Bail out when entering unnecessary tranches\n\n      // This is preferably checked before deploying contract into any blockchain.\n\n      require(i == 0 || (end >= last_tranche.end && amount > last_tranche.amount) ||\n\n              (end > last_tranche.end && amount >= last_tranche.amount));\n\n\n\n      last_tranche = Tranche(amount, start, end, price);\n\n      tranches[i] = last_tranche;\n\n    }\n",
          "message": "Function 'TokenTranchePricing.TokenTranchePricing' (TokenTranchePricing.sol#100-125) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 100,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function TokenTranchePricing(uint[] init_tranches) public {\n",
          "message": "Parameter 'init_tranches' of TokenTranchePricing.TokenTranchePricing (TokenTranchePricing.sol#100) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 90,
          "vulnerability_to_line": null,
          "vulnerability_code": "  uint private constant amount_offset = 0;\n",
          "message": "Constant 'TokenTranchePricing.amount_offset' (TokenTranchePricing.sol#90) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 91,
          "vulnerability_to_line": null,
          "vulnerability_code": "  uint private constant start_offset = 1;\n",
          "message": "Constant 'TokenTranchePricing.start_offset' (TokenTranchePricing.sol#91) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 92,
          "vulnerability_to_line": null,
          "vulnerability_code": "  uint private constant end_offset = 2;\n",
          "message": "Constant 'TokenTranchePricing.end_offset' (TokenTranchePricing.sol#92) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 93,
          "vulnerability_to_line": null,
          "vulnerability_code": "  uint private constant price_offset = 3;\n",
          "message": "Constant 'TokenTranchePricing.price_offset' (TokenTranchePricing.sol#93) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 94,
          "vulnerability_to_line": null,
          "vulnerability_code": "  uint private constant tranche_size = 4;\n",
          "message": "Constant 'TokenTranchePricing.tranche_size' (TokenTranchePricing.sol#94) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        }
      ]
    },
    "smartcheck": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "SOLIDITY_ARRAY_LENGTH_MANIPULATION",
          "vulnerability_from_line": 107,
          "vulnerability_to_line": null,
          "vulnerability_code": "    tranches.length = init_tranches.length.div(tranche_size);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
          "vulnerability_from_line": 14,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function mul(uint a, uint b) internal constant returns (uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
          "vulnerability_from_line": 20,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function div(uint a, uint b) internal constant returns (uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
          "vulnerability_from_line": 27,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function sub(uint a, uint b) internal constant returns (uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
          "vulnerability_from_line": 32,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function add(uint a, uint b) internal constant returns (uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
          "vulnerability_from_line": 38,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
          "vulnerability_from_line": 42,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
          "vulnerability_from_line": 46,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function max256(uint a, uint b) internal constant returns (uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
          "vulnerability_from_line": 50,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function min256(uint a, uint b) internal constant returns (uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
          "vulnerability_from_line": 130,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function getCurrentTranche(uint tokensSold) private constant returns (Tranche storage) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
          "vulnerability_from_line": 143,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function getCurrentPrice(uint tokensSold) internal constant returns (uint result) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 109,
          "vulnerability_to_line": null,
          "vulnerability_code": "    for (uint i = 0; i < tranches.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 131,
          "vulnerability_to_line": null,
          "vulnerability_code": "    for (uint i = 0; i < tranches.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 109,
          "vulnerability_to_line": null,
          "vulnerability_code": "    for (uint i = 0; i < tranches.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 131,
          "vulnerability_to_line": null,
          "vulnerability_code": "    for (uint i = 0; i < tranches.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.15;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 65,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.15;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 90,
          "vulnerability_to_line": null,
          "vulnerability_code": "  uint private constant amount_offset = 0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 91,
          "vulnerability_to_line": null,
          "vulnerability_code": "  uint private constant start_offset = 1;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 92,
          "vulnerability_to_line": null,
          "vulnerability_code": "  uint private constant end_offset = 2;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 93,
          "vulnerability_to_line": null,
          "vulnerability_code": "  uint private constant price_offset = 3;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 94,
          "vulnerability_to_line": null,
          "vulnerability_code": "  uint private constant tranche_size = 4;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SAFEMATH",
          "vulnerability_from_line": 73,
          "vulnerability_to_line": null,
          "vulnerability_code": "  using SafeMath for uint;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 100,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function TokenTranchePricing(uint[] init_tranches) public {\n",
          "message": null
        }
      ]
    },
    "oyente": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "Integer Overflow",
          "vulnerability_from_line": 96,
          "vulnerability_to_line": null,
          "vulnerability_code": "  Tranche[] public tranches;\n",
          "message": null
        }
      ]
    },
    "mythril": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "Exception State (SWC 110)",
          "vulnerability_from_line": null,
          "vulnerability_to_line": null,
          "vulnerability_code": null,
          "message": "An assertion violation was triggered.\nIt is possible to trigger an assertion violation. Note that Solidity assert() statements should only be used to check invariants. Review the transaction trace generated for this issue and either make sure your program logic is correct, or use require() instead of assert() if your goal is to constrain user inputs or enforce preconditions. Remember to validate inputs from both callers (for instance, via passed arguments) and callees (for instance, via return values). This issue is reported for internal compiler generated code.\nClassification: SWC-110"
        }
      ]
    },
    "osiris": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": []
    }
  }
}