{
  "smartbugs_completed": true,
  "analyzer_results": {
    "semgrep": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 167,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor (address tokenAddress) public {\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 168,
          "vulnerability_to_line": null,
          "vulnerability_code": "        token = ERC20CompatibleToken(tokenAddress);\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 169,
          "vulnerability_to_line": null,
          "vulnerability_code": "    }\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 148,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(merchantRegistry[merchantId].merchant == msg.sender, \"Sender is not a merchant\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 154,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(billingRegistry[billingId].customer == msg.sender, \"Sender is not a customer\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 160,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == address(token), \"Sender is not a token\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 204,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(merchantChargingAccountAllowed[merchantId][msg.sender], \"Sender is not allowed to charge\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 205,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(merchantId != 0, \"Billing does not exist\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 206,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(lastChargeAt.add(period) <= now, \"Charged too early\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 215,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 216,
          "vulnerability_to_line": null,
          "vulnerability_code": "            token.transferFrom(billingRecord.customer, merchantRegistry[merchantId].beneficiary, value),\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 217,
          "vulnerability_to_line": null,
          "vulnerability_code": "            \"Unable to charge customer\"\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 218,
          "vulnerability_to_line": null,
          "vulnerability_code": "        );\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 235,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(data.length == 64, \"Invalid data length\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 244,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(billingRegistry[billingId].customer == sender, \"Unable to cancel recurring billing of another customer\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 247,
          "vulnerability_to_line": null,
          "vulnerability_code": "            revert(\"Unknown action provided\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 280,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 281,
          "vulnerability_to_line": null,
          "vulnerability_code": "            value < 2 ** 144\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 282,
          "vulnerability_to_line": null,
          "vulnerability_code": "            && lastChargeAt < 2 ** 48\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 283,
          "vulnerability_to_line": null,
          "vulnerability_code": "            && merchantId < 2 ** 32\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 284,
          "vulnerability_to_line": null,
          "vulnerability_code": "            && period < 2 ** 32,\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 285,
          "vulnerability_to_line": null,
          "vulnerability_code": "            \"Invalid input sizes to encode\"\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 286,
          "vulnerability_to_line": null,
          "vulnerability_code": "        );\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 321,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(merchantId <= lastMerchantId && merchantId != 0, \"Invalid merchant specified\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 322,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(period < now, \"Invalid period specified\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 323,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(token.balanceOf(customer) >= value, \"Not enough tokens for the first charge\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 324,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(token.allowance(customer, address(this)) >= value, \"Tokens are not approved for this smart contract\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 325,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(billingRegistry[billingId].customer == address(0x0), \"Recurring billing with this ID is already registered\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 280,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 281,
          "vulnerability_to_line": null,
          "vulnerability_code": "            value < 2 ** 144\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 282,
          "vulnerability_to_line": null,
          "vulnerability_code": "            && lastChargeAt < 2 ** 48\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 283,
          "vulnerability_to_line": null,
          "vulnerability_code": "            && merchantId < 2 ** 32\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 284,
          "vulnerability_to_line": null,
          "vulnerability_code": "            && period < 2 ** 32,\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 285,
          "vulnerability_to_line": null,
          "vulnerability_code": "            \"Invalid input sizes to encode\"\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 286,
          "vulnerability_to_line": null,
          "vulnerability_code": "        );\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 321,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(merchantId <= lastMerchantId && merchantId != 0, \"Invalid merchant specified\");\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 244,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(billingRegistry[billingId].customer == sender, \"Unable to cancel recurring billing of another customer\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 323,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(token.balanceOf(customer) >= value, \"Not enough tokens for the first charge\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 324,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(token.allowance(customer, address(this)) >= value, \"Tokens are not approved for this smart contract\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 325,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(billingRegistry[billingId].customer == address(0x0), \"Recurring billing with this ID is already registered\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        }
      ]
    },
    "slither": {
      "successfull_analysis": true,
      "errors": [
        "EXIT_CODE_16"
      ],
      "vulnerability_findings": [
        {
          "name": "constant-function",
          "vulnerability_from_line": 342,
          "vulnerability_to_line": 345,
          "vulnerability_code": "    function bytesToUint256(bytes memory input, uint offset) internal pure returns (uint256 output) {\n\n        assembly { output := mload(add(add(input, 32), offset)) }\n\n    }\n",
          "message": "TokenRecurringBilling.bytesToUint256 (TokenRecurringBilling.sol#342-345) is declared view but contains assembly code\n"
        },
        {
          "name": "incorrect-equality",
          "vulnerability_from_line": 313,
          "vulnerability_to_line": 334,
          "vulnerability_code": "    function allowRecurringBillingInternal (\n\n        address customer,\n\n        uint256 merchantId,\n\n        uint256 billingId,\n\n        uint256 value,\n\n        uint256 period\n\n    ) internal {\n\n\n\n        require(merchantId <= lastMerchantId && merchantId != 0, \"Invalid merchant specified\");\n\n        require(period < now, \"Invalid period specified\");\n\n        require(token.balanceOf(customer) >= value, \"Not enough tokens for the first charge\");\n\n        require(token.allowance(customer, address(this)) >= value, \"Tokens are not approved for this smart contract\");\n\n        require(billingRegistry[billingId].customer == address(0x0), \"Recurring billing with this ID is already registered\");\n\n\n\n        BillingRecord storage newRecurringBilling = billingRegistry[billingId];\n\n        newRecurringBilling.metadata = encodeBillingMetadata(value, now.sub(period), merchantId, period);\n\n        newRecurringBilling.customer = customer;\n\n\n\n        emit BillingAllowed(billingId, customer, merchantId, now, period, value);\n\n\n\n    }\n",
          "message": "TokenRecurringBilling.allowRecurringBillingInternal (TokenRecurringBilling.sol#313-334) uses a dangerous strict equality:\n\t- require(bool,string)(billingRegistry[billingId].customer == address(0x0),Recurring billing with this ID is already registered)\n"
        },
        {
          "name": "incorrect-equality",
          "vulnerability_from_line": 313,
          "vulnerability_to_line": 334,
          "vulnerability_code": "    function allowRecurringBillingInternal (\n\n        address customer,\n\n        uint256 merchantId,\n\n        uint256 billingId,\n\n        uint256 value,\n\n        uint256 period\n\n    ) internal {\n\n\n\n        require(merchantId <= lastMerchantId && merchantId != 0, \"Invalid merchant specified\");\n\n        require(period < now, \"Invalid period specified\");\n\n        require(token.balanceOf(customer) >= value, \"Not enough tokens for the first charge\");\n\n        require(token.allowance(customer, address(this)) >= value, \"Tokens are not approved for this smart contract\");\n\n        require(billingRegistry[billingId].customer == address(0x0), \"Recurring billing with this ID is already registered\");\n\n\n\n        BillingRecord storage newRecurringBilling = billingRegistry[billingId];\n\n        newRecurringBilling.metadata = encodeBillingMetadata(value, now.sub(period), merchantId, period);\n\n        newRecurringBilling.customer = customer;\n\n\n\n        emit BillingAllowed(billingId, customer, merchantId, now, period, value);\n\n\n\n    }\n",
          "message": "TokenRecurringBilling.allowRecurringBillingInternal (TokenRecurringBilling.sol#313-334) uses a dangerous strict equality:\n\t- require(bool,string)(billingRegistry[billingId].customer == address(0x0),Recurring billing with this ID is already registered)\nTokenRecurringBilling.isCustomer (TokenRecurringBilling.sol#153-157) uses a dangerous strict equality:\n\t- require(bool,string)(billingRegistry[billingId].customer == msg.sender,Sender is not a customer)\n\t- require(bool,string)(billingRegistry[billingId].customer == msg.sender,Sender is not a customer)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 199,
          "vulnerability_to_line": 225,
          "vulnerability_code": "    function charge (uint256 billingId) public {\n\n\n\n        BillingRecord storage billingRecord = billingRegistry[billingId];\n\n        (uint256 value, uint256 lastChargeAt, uint256 merchantId, uint256 period) = decodeBillingMetadata(billingRecord.metadata);\n\n\n\n        require(merchantChargingAccountAllowed[merchantId][msg.sender], \"Sender is not allowed to charge\");\n\n        require(merchantId != 0, \"Billing does not exist\");\n\n        require(lastChargeAt.add(period) <= now, \"Charged too early\");\n\n\n\n        // If 2 periods have already passed since the last charge (or beginning), no further charges are possible\n\n        // and recurring billing is canceled in case of a charge.\n\n        if (now > lastChargeAt.add(period.mul(2))) {\n\n            cancelRecurringBillingInternal(billingId);\n\n            return;\n\n        }\n\n\n\n        require(\n\n            token.transferFrom(billingRecord.customer, merchantRegistry[merchantId].beneficiary, value),\n\n            \"Unable to charge customer\"\n\n        );\n\n\n\n        billingRecord.metadata = encodeBillingMetadata(value, lastChargeAt.add(period), merchantId, period);\n\n\n\n        emit BillingCharged(billingId, now, lastChargeAt.add(period.mul(2)));\n\n\n\n    }\n",
          "message": "Reentrancy in TokenRecurringBilling.charge (TokenRecurringBilling.sol#199-225):\n\tExternal calls:\n\t- require(bool,string)(token.transferFrom(billingRecord.customer,merchantRegistry[merchantId].beneficiary,value),Unable to charge customer) (TokenRecurringBilling.sol#215-218)\n\tState variables written after the call(s):\n\t- billingRegistry (TokenRecurringBilling.sol#220)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 313,
          "vulnerability_to_line": 334,
          "vulnerability_code": "    function allowRecurringBillingInternal (\n\n        address customer,\n\n        uint256 merchantId,\n\n        uint256 billingId,\n\n        uint256 value,\n\n        uint256 period\n\n    ) internal {\n\n\n\n        require(merchantId <= lastMerchantId && merchantId != 0, \"Invalid merchant specified\");\n\n        require(period < now, \"Invalid period specified\");\n\n        require(token.balanceOf(customer) >= value, \"Not enough tokens for the first charge\");\n\n        require(token.allowance(customer, address(this)) >= value, \"Tokens are not approved for this smart contract\");\n\n        require(billingRegistry[billingId].customer == address(0x0), \"Recurring billing with this ID is already registered\");\n\n\n\n        BillingRecord storage newRecurringBilling = billingRegistry[billingId];\n\n        newRecurringBilling.metadata = encodeBillingMetadata(value, now.sub(period), merchantId, period);\n\n        newRecurringBilling.customer = customer;\n\n\n\n        emit BillingAllowed(billingId, customer, merchantId, now, period, value);\n\n\n\n    }\n",
          "message": "Reentrancy in TokenRecurringBilling.allowRecurringBillingInternal (TokenRecurringBilling.sol#313-334):\n\tExternal calls:\n\t- require(bool,string)(token.balanceOf(customer) >= value,Not enough tokens for the first charge) (TokenRecurringBilling.sol#323)\n\t- require(bool,string)(token.allowance(customer,address(this)) >= value,Tokens are not approved for this smart contract) (TokenRecurringBilling.sol#324)\n\tState variables written after the call(s):\n\t- billingRegistry (TokenRecurringBilling.sol#328)\n\t- billingRegistry (TokenRecurringBilling.sol#329)\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 342,
          "vulnerability_to_line": 345,
          "vulnerability_code": "    function bytesToUint256(bytes memory input, uint offset) internal pure returns (uint256 output) {\n\n        assembly { output := mload(add(add(input, 32), offset)) }\n\n    }\n",
          "message": "TokenRecurringBilling.bytesToUint256 uses assembly (TokenRecurringBilling.sol#342-345)\n\t- TokenRecurringBilling.sol#343-345\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 59,
          "vulnerability_to_line": 64,
          "vulnerability_code": "    function newRecurringBillingContract (address tokenAddress) public returns (address recurringBillingContractAddress) {\n\n        TokenRecurringBilling rb = new TokenRecurringBilling(tokenAddress);\n\n        emit NewRecurringBillingContractCreated(tokenAddress, address(rb));\n\n        return address(rb);\n\n    }\n",
          "message": "RecurringBillingContractFactory.newRecurringBillingContract (TokenRecurringBilling.sol#59-64) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 174,
          "vulnerability_to_line": 177,
          "vulnerability_code": "    function allowRecurringBilling (uint256 billingId, uint256 merchantId, uint256 value, uint256 period) public {\n\n        allowRecurringBillingInternal(msg.sender, merchantId, billingId, value, period);\n\n    }\n",
          "message": "TokenRecurringBilling.allowRecurringBilling (TokenRecurringBilling.sol#174-177) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 179,
          "vulnerability_to_line": 190,
          "vulnerability_code": "    function registerNewMerchant (address beneficiary, address chargingAccount) public returns (uint256 merchantId) {\n\n\n\n        merchantId = ++lastMerchantId;\n\n        Merchant storage record = merchantRegistry[merchantId];\n\n        record.merchant = msg.sender;\n\n        record.beneficiary = beneficiary;\n\n        emit MerchantRegistered(merchantId, msg.sender, beneficiary);\n\n\n\n        changeMerchantChargingAccount(merchantId, chargingAccount, true);\n\n\n\n    }\n",
          "message": "TokenRecurringBilling.registerNewMerchant (TokenRecurringBilling.sol#179-190) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 194,
          "vulnerability_to_line": 197,
          "vulnerability_code": "    function cancelRecurringBilling (uint256 billingId) public isCustomer(billingId) {\n\n        cancelRecurringBillingInternal(billingId);\n\n    }\n",
          "message": "TokenRecurringBilling.cancelRecurringBilling (TokenRecurringBilling.sol#194-197) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 199,
          "vulnerability_to_line": 225,
          "vulnerability_code": "    function charge (uint256 billingId) public {\n\n\n\n        BillingRecord storage billingRecord = billingRegistry[billingId];\n\n        (uint256 value, uint256 lastChargeAt, uint256 merchantId, uint256 period) = decodeBillingMetadata(billingRecord.metadata);\n\n\n\n        require(merchantChargingAccountAllowed[merchantId][msg.sender], \"Sender is not allowed to charge\");\n\n        require(merchantId != 0, \"Billing does not exist\");\n\n        require(lastChargeAt.add(period) <= now, \"Charged too early\");\n\n\n\n        // If 2 periods have already passed since the last charge (or beginning), no further charges are possible\n\n        // and recurring billing is canceled in case of a charge.\n\n        if (now > lastChargeAt.add(period.mul(2))) {\n\n            cancelRecurringBillingInternal(billingId);\n\n            return;\n\n        }\n\n\n\n        require(\n\n            token.transferFrom(billingRecord.customer, merchantRegistry[merchantId].beneficiary, value),\n\n            \"Unable to charge customer\"\n\n        );\n\n\n\n        billingRecord.metadata = encodeBillingMetadata(value, lastChargeAt.add(period), merchantId, period);\n\n\n\n        emit BillingCharged(billingId, now, lastChargeAt.add(period.mul(2)));\n\n\n\n    }\n",
          "message": "TokenRecurringBilling.charge (TokenRecurringBilling.sol#199-225) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 253,
          "vulnerability_to_line": 257,
          "vulnerability_code": "    function changeMerchantAccount (uint256 merchantId, address newMerchantAccount) public isMerchant(merchantId) {\n\n        merchantRegistry[merchantId].merchant = newMerchantAccount;\n\n        emit MerchantAccountChanged(merchantId, newMerchantAccount);\n\n    }\n",
          "message": "TokenRecurringBilling.changeMerchantAccount (TokenRecurringBilling.sol#253-257) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 259,
          "vulnerability_to_line": 263,
          "vulnerability_code": "    function changeMerchantBeneficiaryAddress (uint256 merchantId, address newBeneficiaryAddress) public isMerchant(merchantId) {\n\n        merchantRegistry[merchantId].beneficiary = newBeneficiaryAddress;\n\n        emit MerchantBeneficiaryAddressChanged(merchantId, newBeneficiaryAddress);\n\n    }\n",
          "message": "TokenRecurringBilling.changeMerchantBeneficiaryAddress (TokenRecurringBilling.sol#259-263) should be declared external\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 232,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function receiveApproval (address sender, uint, address, bytes calldata data) external tokenOnly {\n",
          "message": "Parameter '' of TokenRecurringBilling.receiveApproval (TokenRecurringBilling.sol#232) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 232,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function receiveApproval (address sender, uint, address, bytes calldata data) external tokenOnly {\n",
          "message": "Parameter '_scope_0' of TokenRecurringBilling.receiveApproval (TokenRecurringBilling.sol#232) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 134,
          "vulnerability_to_line": 138,
          "vulnerability_code": "    enum receiveApprovalAction { // In receiveApproval, `lastChargeAt` in passed `metadata` specifies an action to execute.\n\n        allowRecurringBilling,   // == 0\n\n        cancelRecurringBilling   // == 1\n\n    }\n",
          "message": "Enum 'TokenRecurringBilling.receiveApprovalAction' (TokenRecurringBilling.sol#134-138) is not in CapWords\n"
        }
      ]
    },
    "smartcheck": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 325,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(billingRegistry[billingId].customer == address(0x0), \"Recurring billing with this ID is already registered\");\n",
          "message": null
        },
        {
          "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
          "vulnerability_from_line": 342,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function bytesToUint256(bytes memory input, uint offset) internal pure returns (uint256 output) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_REVERT_REQUIRE",
          "vulnerability_from_line": 243,
          "vulnerability_to_line": null,
          "vulnerability_code": "        } else if (action == uint256(receiveApprovalAction.cancelRecurringBilling)) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SAFEMATH",
          "vulnerability_from_line": 110,
          "vulnerability_to_line": null,
          "vulnerability_code": "    using SafeMath for uint256;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 342,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function bytesToUint256(bytes memory input, uint offset) internal pure returns (uint256 output) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 298,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function decodeBillingMetadata (uint256 encodedData) public pure returns (\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 343,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly { output := mload(add(add(input, 32), offset)) }\n",
          "message": null
        }
      ]
    },
    "oyente": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "Integer Overflow",
          "vulnerability_from_line": 143,
          "vulnerability_to_line": null,
          "vulnerability_code": "    mapping(uint256 => Merchant) public merchantRegistry;                               // List of all merchants registered by ID.\n",
          "message": null
        }
      ]
    },
    "mythril": {
      "successfull_analysis": false,
      "errors": [
        "DOCKER_TIMEOUT"
      ],
      "vulnerability_findings": []
    },
    "osiris": {
      "successfull_analysis": true,
      "errors": [
        "UNKNOWN INSTRUCTION: STATICCALL"
      ],
      "vulnerability_findings": [
        {
          "name": "Overflow bugs",
          "vulnerability_from_line": 1,
          "vulnerability_to_line": null,
          "vulnerability_code": "// File: ../sc_datasets/DAppSCAN/Coinfabrik-DreamTeam Token Audit/smart-contracts-master/contracts/token/TokenRecurringBilling.sol\n",
          "message": null
        },
        {
          "name": "Overflow bugs",
          "vulnerability_from_line": 181,
          "vulnerability_to_line": null,
          "vulnerability_code": "        merchantId = ++lastMerchantId;\n",
          "message": null
        },
        {
          "name": "Truncation bugs",
          "vulnerability_from_line": 304,
          "vulnerability_to_line": null,
          "vulnerability_code": "        value = uint144(encodedData);\n",
          "message": null
        }
      ]
    }
  }
}