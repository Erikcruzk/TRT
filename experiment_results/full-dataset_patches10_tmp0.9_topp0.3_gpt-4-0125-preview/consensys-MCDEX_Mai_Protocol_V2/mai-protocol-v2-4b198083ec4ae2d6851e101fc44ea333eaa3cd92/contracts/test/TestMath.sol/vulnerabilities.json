{
  "smartbugs_completed": true,
  "analyzer_results": {
    "semgrep": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 29,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(!(a == -1 && b == _INT256_MIN), \"wmultiplication overflow\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 32,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(c / a == b, \"wmultiplication overflow\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 41,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(b != 0, \"wdivision by zero\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 42,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(!(b == -1 && a == _INT256_MIN), \"wdivision overflow\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 54,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require((b >= 0 && c <= a) || (b < 0 && c > a), \"subtraction overflow\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 64,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require((b >= 0 && c >= a) || (b < 0 && c < a), \"addition overflow\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 101,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(x >= 0, \"int overflow\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 130,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(y > 0, \"roundHalfUp only supports y > 0\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 156,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(x > 0, \"logE of negative number\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 157,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(x <= 10000000000000000000000000000000000000000, \"logE only accepts v <= 1e22 * 1e18\"); // in order to prevent using safe-math\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 223,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(x >= 0, \"ceil need x >= 0\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 224,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(m > 0, \"ceil need m > 0\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 240,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(c >= a, \"Unaddition overflow\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 246,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(b <= a, \"Unsubtraction overflow\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 261,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(c / a == b, \"Unmultiplication overflow\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 268,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(b > 0, \"Undivision by zero\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 296,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(x <= _UINT256_MAX, \"uint256 overflow\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 301,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(m != 0, \"mod by zero\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 306,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(m > 0, \"ceil need m > 0\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 29,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(!(a == -1 && b == _INT256_MIN), \"wmultiplication overflow\");\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 42,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(!(b == -1 && a == _INT256_MIN), \"wdivision overflow\");\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 54,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require((b >= 0 && c <= a) || (b < 0 && c > a), \"subtraction overflow\");\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 64,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require((b >= 0 && c >= a) || (b < 0 && c < a), \"addition overflow\");\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 157,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(x <= 10000000000000000000000000000000000000000, \"logE only accepts v <= 1e22 * 1e18\"); // in order to prevent using safe-math\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        }
      ]
    },
    "slither": {
      "successfull_analysis": true,
      "errors": [
        "EXIT_CODE_32"
      ],
      "vulnerability_findings": [
        {
          "name": "external-function",
          "vulnerability_from_line": 318,
          "vulnerability_to_line": 322,
          "vulnerability_code": "    function wfrac(int256 a, int256 b, int256 c) public pure returns (int256) {\n\n        return a.wfrac(b, c);\n\n    }\n\n\n",
          "message": "TestSignedMath.wfrac (TestMath.sol#318-322) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 322,
          "vulnerability_to_line": 326,
          "vulnerability_code": "    function wmul(int256 a, int256 b) public pure returns (int256) {\n\n        return a.wmul(b);\n\n    }\n\n\n",
          "message": "TestSignedMath.wmul (TestMath.sol#322-326) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 326,
          "vulnerability_to_line": 330,
          "vulnerability_code": "    function wdiv(int256 a, int256 b) public pure returns (int256) {\n\n        return a.wdiv(b);\n\n    }\n\n\n",
          "message": "TestSignedMath.wdiv (TestMath.sol#326-330) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 330,
          "vulnerability_to_line": 334,
          "vulnerability_code": "    function ceil(int256 a, int256 m) public pure returns (int256) {\n\n        return a.ceil(m);\n\n    }\n\n\n",
          "message": "TestSignedMath.ceil (TestMath.sol#330-334) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 334,
          "vulnerability_to_line": 338,
          "vulnerability_code": "    function wpowi(int256 x, int256 y) public pure returns (int256) {\n\n        return x.wpowi(y);\n\n    }\n\n\n",
          "message": "TestSignedMath.wpowi (TestMath.sol#334-338) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 338,
          "vulnerability_to_line": 342,
          "vulnerability_code": "    function roundHalfUp(int256 v, int256 t) public pure returns (int256) {\n\n        return v.roundHalfUp(t);\n\n    }\n\n\n",
          "message": "TestSignedMath.roundHalfUp (TestMath.sol#338-342) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 342,
          "vulnerability_to_line": 346,
          "vulnerability_code": "    function wln(int256 x) public pure returns (int256) {\n\n        return x.wln();\n\n    }\n\n\n",
          "message": "TestSignedMath.wln (TestMath.sol#342-346) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 346,
          "vulnerability_to_line": 350,
          "vulnerability_code": "    function logBase(int256 b, int256 x) public pure returns (int256) {\n\n        return b.logBase(x);\n\n    }\n\n\n",
          "message": "TestSignedMath.logBase (TestMath.sol#346-350) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 350,
          "vulnerability_to_line": 354,
          "vulnerability_code": "    function mul(int256 a, int256 b) public pure returns (int256) {\n\n        return a.mul(b);\n\n    }\n\n\n",
          "message": "TestSignedMath.mul (TestMath.sol#350-354) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 354,
          "vulnerability_to_line": 358,
          "vulnerability_code": "    function div(int256 a, int256 b) public pure returns (int256) {\n\n        return a.div(b);\n\n    }\n\n\n",
          "message": "TestSignedMath.div (TestMath.sol#354-358) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 358,
          "vulnerability_to_line": 362,
          "vulnerability_code": "    function sub(int256 a, int256 b) public pure returns (int256) {\n\n        return a.sub(b);\n\n    }\n\n\n",
          "message": "TestSignedMath.sub (TestMath.sol#358-362) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 362,
          "vulnerability_to_line": 366,
          "vulnerability_code": "    function add(int256 a, int256 b) public pure returns (int256) {\n\n        return a.add(b);\n\n    }\n\n\n",
          "message": "TestSignedMath.add (TestMath.sol#362-366) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 366,
          "vulnerability_to_line": 372,
          "vulnerability_code": "    function toUint256(int256 x) public pure returns (uint256) {\n\n        return x.toUint256();\n\n    }\n\n}\n\n\n\n\n",
          "message": "TestSignedMath.toUint256 (TestMath.sol#366-372) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 375,
          "vulnerability_to_line": 379,
          "vulnerability_code": "    function WAD() public pure returns (uint256) {\n\n        return LibMathUnsigned.WAD();\n\n    }\n\n\n",
          "message": "TestUnsignedMath.WAD (TestMath.sol#375-379) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 379,
          "vulnerability_to_line": 383,
          "vulnerability_code": "    function wfrac(uint256 a, uint256 b, uint256 c) public pure returns (uint256) {\n\n        return a.wfrac(b, c);\n\n    }\n\n\n",
          "message": "TestUnsignedMath.wfrac (TestMath.sol#379-383) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 383,
          "vulnerability_to_line": 387,
          "vulnerability_code": "    function add(uint256 a, uint256 b) public pure returns (uint256) {\n\n        return a.add(b);\n\n    }\n\n\n",
          "message": "TestUnsignedMath.add (TestMath.sol#383-387) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 387,
          "vulnerability_to_line": 391,
          "vulnerability_code": "    function wmul(uint256 a, uint256 b) public pure returns (uint256) {\n\n        return a.wmul(b);\n\n    }\n\n\n",
          "message": "TestUnsignedMath.wmul (TestMath.sol#387-391) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 391,
          "vulnerability_to_line": 395,
          "vulnerability_code": "    function div(uint256 a, uint256 b) public pure returns (uint256) {\n\n        return a.div(b);\n\n    }\n\n\n",
          "message": "TestUnsignedMath.div (TestMath.sol#391-395) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 395,
          "vulnerability_to_line": 399,
          "vulnerability_code": "    function wdiv(uint256 a, uint256 b) public pure returns (uint256) {\n\n        return a.wdiv(b);\n\n    }\n\n\n",
          "message": "TestUnsignedMath.wdiv (TestMath.sol#395-399) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 399,
          "vulnerability_to_line": 403,
          "vulnerability_code": "    function max(uint256 x, uint256 y) public pure returns (uint256 z) {\n\n        return x.max(y);\n\n    }\n\n\n",
          "message": "TestUnsignedMath.max (TestMath.sol#399-403) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 403,
          "vulnerability_to_line": 407,
          "vulnerability_code": "    function mod(uint256 x, uint256 m) public pure returns (uint256) {\n\n        return x.mod(m);\n\n    }\n\n\n",
          "message": "TestUnsignedMath.mod (TestMath.sol#403-407) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 407,
          "vulnerability_to_line": 410,
          "vulnerability_code": "    function ceil(uint256 x, uint256 m) public pure returns (uint256) {\n\n        return x.ceil(m);\n\n    }\n",
          "message": "TestUnsignedMath.ceil (TestMath.sol#407-410) should be declared external\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 10,
          "vulnerability_to_line": 12,
          "vulnerability_code": "    function WAD() internal pure returns (int256) {\n\n        return _WAD;\n",
          "message": "Function 'LibMathSigned.WAD' (TestMath.sol#10-12) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 120,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint8 internal constant fixed_digits = 18;\n",
          "message": "Constant 'LibMathSigned.fixed_digits' (TestMath.sol#120) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 121,
          "vulnerability_to_line": null,
          "vulnerability_code": "    int256 internal constant fixed_1 = 1000000000000000000;\n",
          "message": "Constant 'LibMathSigned.fixed_1' (TestMath.sol#121) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 122,
          "vulnerability_to_line": null,
          "vulnerability_code": "    int256 internal constant fixed_e = 2718281828459045235;\n",
          "message": "Constant 'LibMathSigned.fixed_e' (TestMath.sol#122) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 123,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint8 internal constant longer_digits = 36;\n",
          "message": "Constant 'LibMathSigned.longer_digits' (TestMath.sol#123) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 124,
          "vulnerability_to_line": null,
          "vulnerability_code": "    int256 internal constant longer_fixed_log_e_1_5 = 405465108108164381978013115464349137;\n",
          "message": "Constant 'LibMathSigned.longer_fixed_log_e_1_5' (TestMath.sol#124) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 125,
          "vulnerability_to_line": null,
          "vulnerability_code": "    int256 internal constant longer_fixed_1 = 1000000000000000000000000000000000000;\n",
          "message": "Constant 'LibMathSigned.longer_fixed_1' (TestMath.sol#125) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 126,
          "vulnerability_to_line": null,
          "vulnerability_code": "    int256 internal constant longer_fixed_log_e_10 = 2302585092994045684017991454684364208;\n",
          "message": "Constant 'LibMathSigned.longer_fixed_log_e_10' (TestMath.sol#126) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 234,
          "vulnerability_to_line": 238,
          "vulnerability_code": "    function WAD() internal pure returns (uint256) {\n\n        return _WAD;\n\n    }\n\n\n",
          "message": "Function 'LibMathUnsigned.WAD' (TestMath.sol#234-238) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 375,
          "vulnerability_to_line": 379,
          "vulnerability_code": "    function WAD() public pure returns (uint256) {\n\n        return LibMathUnsigned.WAD();\n\n    }\n\n\n",
          "message": "Function 'TestUnsignedMath.WAD' (TestMath.sol#375-379) is not in mixedCase\n"
        }
      ]
    },
    "smartcheck": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "SOLIDITY_DIV_MUL",
          "vulnerability_from_line": 225,
          "vulnerability_to_line": null,
          "vulnerability_code": "        return (sub(add(x, m), 1) / m) * m;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_DIV_MUL",
          "vulnerability_from_line": 307,
          "vulnerability_to_line": null,
          "vulnerability_code": "        return (sub(add(x, m), 1) / m) * m;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 162,
          "vulnerability_to_line": null,
          "vulnerability_code": "        while (x <= fixed_1 / 10) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 166,
          "vulnerability_to_line": null,
          "vulnerability_code": "        while (x >= 10 * fixed_1) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 170,
          "vulnerability_to_line": null,
          "vulnerability_code": "        while (x < fixed_1) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 174,
          "vulnerability_to_line": null,
          "vulnerability_code": "        while (x > fixed_e) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 206,
          "vulnerability_to_line": null,
          "vulnerability_code": "        while (true) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.2;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 313,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.2;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 7,
          "vulnerability_to_line": null,
          "vulnerability_code": "    int256 private constant _WAD = 10**18;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 8,
          "vulnerability_to_line": null,
          "vulnerability_code": "    int256 private constant _INT256_MIN = -2**255;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 231,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint256 private constant _WAD = 10**18;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 232,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint256 private constant _UINT256_MAX = 2**255 - 1;\n",
          "message": null
        }
      ]
    },
    "oyente": {
      "successfull_analysis": false,
      "errors": [
        "exception (IndexError: pop from empty list)"
      ],
      "vulnerability_findings": []
    },
    "mythril": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "Exception State (SWC 110)",
          "vulnerability_from_line": 252,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n",
          "message": "An assertion violation was triggered.\nIt is possible to trigger an assertion violation. Note that Solidity assert() statements should only be used to check invariants. Review the transaction trace generated for this issue and either make sure your program logic is correct, or use require() instead of assert() if your goal is to constrain user inputs or enforce preconditions. Remember to validate inputs from both callers (for instance, via passed arguments) and callees (for instance, via return values).\nClassification: SWC-110"
        },
        {
          "name": "Exception State (SWC 110)",
          "vulnerability_from_line": 238,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n",
          "message": "An assertion violation was triggered.\nIt is possible to trigger an assertion violation. Note that Solidity assert() statements should only be used to check invariants. Review the transaction trace generated for this issue and either make sure your program logic is correct, or use require() instead of assert() if your goal is to constrain user inputs or enforce preconditions. Remember to validate inputs from both callers (for instance, via passed arguments) and callees (for instance, via return values).\nClassification: SWC-110"
        },
        {
          "name": "Integer Arithmetic Bugs (SWC 101)",
          "vulnerability_from_line": 164,
          "vulnerability_to_line": null,
          "vulnerability_code": "            r -= longer_fixed_log_e_10;\n",
          "message": "The arithmetic operator can underflow.\nIt is possible to cause an integer overflow or underflow in the arithmetic operation. \nClassification: SWC-101"
        },
        {
          "name": "Integer Arithmetic Bugs (SWC 101)",
          "vulnerability_from_line": 63,
          "vulnerability_to_line": null,
          "vulnerability_code": "        int256 c = a + b;\n",
          "message": "The arithmetic operator can overflow.\nIt is possible to cause an integer overflow or underflow in the arithmetic operation. \nClassification: SWC-101"
        },
        {
          "name": "Integer Arithmetic Bugs (SWC 101)",
          "vulnerability_from_line": 53,
          "vulnerability_to_line": null,
          "vulnerability_code": "        int256 c = a - b;\n",
          "message": "The arithmetic operator can underflow.\nIt is possible to cause an integer overflow or underflow in the arithmetic operation. \nClassification: SWC-101"
        },
        {
          "name": "Integer Arithmetic Bugs (SWC 101)",
          "vulnerability_from_line": 76,
          "vulnerability_to_line": null,
          "vulnerability_code": "            y = -y;\n",
          "message": "The arithmetic operator can underflow.\nIt is possible to cause an integer overflow or underflow in the arithmetic operation. \nClassification: SWC-101"
        },
        {
          "name": "Integer Arithmetic Bugs (SWC 101)",
          "vulnerability_from_line": 77,
          "vulnerability_to_line": null,
          "vulnerability_code": "            x = -x;\n",
          "message": "The arithmetic operator can underflow.\nIt is possible to cause an integer overflow or underflow in the arithmetic operation. \nClassification: SWC-101"
        },
        {
          "name": "Integer Arithmetic Bugs (SWC 101)",
          "vulnerability_from_line": 31,
          "vulnerability_to_line": null,
          "vulnerability_code": "        int256 c = a * b;\n",
          "message": "The arithmetic operator can overflow.\nIt is possible to cause an integer overflow or underflow in the arithmetic operation. \nClassification: SWC-101"
        },
        {
          "name": "Integer Arithmetic Bugs (SWC 101)",
          "vulnerability_from_line": 31,
          "vulnerability_to_line": null,
          "vulnerability_code": "        int256 c = a * b;\n",
          "message": "The arithmetic operator can overflow.\nIt is possible to cause an integer overflow or underflow in the arithmetic operation. \nClassification: SWC-101"
        },
        {
          "name": "Integer Arithmetic Bugs (SWC 101)",
          "vulnerability_from_line": 31,
          "vulnerability_to_line": null,
          "vulnerability_code": "        int256 c = a * b;\n",
          "message": "The arithmetic operator can overflow.\nIt is possible to cause an integer overflow or underflow in the arithmetic operation. \nClassification: SWC-101"
        },
        {
          "name": "Integer Arithmetic Bugs (SWC 101)",
          "vulnerability_from_line": 31,
          "vulnerability_to_line": null,
          "vulnerability_code": "        int256 c = a * b;\n",
          "message": "The arithmetic operator can overflow.\nIt is possible to cause an integer overflow or underflow in the arithmetic operation. \nClassification: SWC-101"
        },
        {
          "name": "Integer Arithmetic Bugs (SWC 101)",
          "vulnerability_from_line": 86,
          "vulnerability_to_line": null,
          "vulnerability_code": "            z = -z;\n",
          "message": "The arithmetic operator can underflow.\nIt is possible to cause an integer overflow or underflow in the arithmetic operation. \nClassification: SWC-101"
        },
        {
          "name": "Integer Arithmetic Bugs (SWC 101)",
          "vulnerability_from_line": 87,
          "vulnerability_to_line": null,
          "vulnerability_code": "            t = -t;\n",
          "message": "The arithmetic operator can underflow.\nIt is possible to cause an integer overflow or underflow in the arithmetic operation. \nClassification: SWC-101"
        }
      ]
    },
    "osiris": {
      "successfull_analysis": false,
      "errors": [
        "Solidity compilation failed"
      ],
      "vulnerability_findings": []
    }
  }
}