{
  "smartbugs_completed": true,
  "analyzer_results": {
    "semgrep": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 76,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(valid, \"AZTEC array index is out of bounds\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 76,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(valid, \"AZTEC array index is out of bounds\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        }
      ]
    },
    "slither": {
      "successfull_analysis": true,
      "errors": [
        "EXIT_CODE_26"
      ],
      "vulnerability_findings": [
        {
          "name": "constant-function",
          "vulnerability_from_line": 33,
          "vulnerability_to_line": 41,
          "vulnerability_code": "    function getLength(bytes memory _proofOutputsOrNotes) internal pure returns (\n\n        uint len\n\n    ) {\n\n        assembly {\n\n            // first word = the raw byte length\n\n            // second word = the actual number of entries (hence the 0x20 offset)\n\n            len := mload(add(_proofOutputsOrNotes, 0x20))\n\n        }\n",
          "message": "NoteUtils.getLength (NoteUtilsTest.sol#33-41) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 49,
          "vulnerability_to_line": 77,
          "vulnerability_code": "    function get(bytes memory _proofOutputsOrNotes, uint _i) internal pure returns (\n\n        bytes memory out\n\n    ) {\n\n        bool valid;\n\n        assembly {\n\n            // check that i < the number of entries\n\n            valid := lt(\n\n                _i,\n\n                mload(add(_proofOutputsOrNotes, 0x20))\n\n            )\n\n            // memory map of the array is as follows:\n\n            // 0x00 - 0x20 : byte length of array\n\n            // 0x20 - 0x40 : n, the number of entries\n\n            // 0x40 - 0x40 + (0x20 * i) : relative memory offset to start of i'th entry (i <= n)\n\n\n\n            // Step 1: compute location of relative memory offset: _proofOutputsOrNotes + 0x40 + (0x20 * i) \n\n            // Step 2: loaded relative offset and add to _proofOutputsOrNotes to get absolute memory location\n\n            out := add(\n\n                mload(\n\n                    add(\n\n                        add(_proofOutputsOrNotes, 0x40),\n\n                        mul(_i, 0x20)\n\n                    )\n\n                ),\n\n                _proofOutputsOrNotes\n\n            )\n\n        }\n\n        require(valid, \"AZTEC array index is out of bounds\");\n",
          "message": "NoteUtils.get (NoteUtilsTest.sol#49-77) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 89,
          "vulnerability_to_line": 111,
          "vulnerability_code": "    function extractProofOutput(bytes memory _proofOutput) internal pure returns (\n\n        bytes memory inputNotes,\n\n        bytes memory outputNotes,\n\n        address publicOwner,\n\n        int256 publicValue\n\n    ) {\n\n        assembly {\n\n            // memory map of a proofOutput:\n\n            // 0x00 - 0x20 : byte length of proofOutput\n\n            // 0x20 - 0x40 : relative offset to inputNotes\n\n            // 0x40 - 0x60 : relative offset to outputNotes\n\n            // 0x60 - 0x80 : publicOwner\n\n            // 0x80 - 0xa0 : publicValue\n\n            // 0xa0 - 0xc0 : challenge\n\n            inputNotes := add(_proofOutput, mload(add(_proofOutput, 0x20)))\n\n            outputNotes := add(_proofOutput, mload(add(_proofOutput, 0x40)))\n\n            publicOwner := and(\n\n                mload(add(_proofOutput, 0x60)),\n\n                0xffffffffffffffffffffffffffffffffffffffff\n\n            )\n\n            publicValue := mload(add(_proofOutput, 0x80))\n\n        }\n",
          "message": "NoteUtils.extractProofOutput (NoteUtilsTest.sol#89-111) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 118,
          "vulnerability_to_line": 124,
          "vulnerability_code": "    function extractChallenge(bytes memory _proofOutput) internal pure returns (\n\n        bytes32 challenge\n\n    ) {\n\n        assembly {\n\n            challenge := mload(add(_proofOutput, 0xa0))\n\n        }\n",
          "message": "NoteUtils.extractChallenge (NoteUtilsTest.sol#118-124) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 133,
          "vulnerability_to_line": 152,
          "vulnerability_code": "    function extractNote(bytes memory _note) internal pure returns (\n\n            address owner,\n\n            bytes32 noteHash,\n\n            bytes memory metadata\n\n    ) {\n\n        assembly {\n\n            // memory map of a note:\n\n            // 0x00 - 0x20 : byte length of note\n\n            // 0x20 - 0x40 : note type\n\n            // 0x40 - 0x60 : owner\n\n            // 0x60 - 0x80 : noteHash\n\n            // 0x80 - 0xa0 : start of metadata byte array\n\n            owner := and(\n\n                mload(add(_note, 0x40)),\n\n                0xffffffffffffffffffffffffffffffffffffffff\n\n            )\n\n            noteHash := mload(add(_note, 0x60))\n\n            metadata := add(_note, 0x80)\n\n        }\n",
          "message": "NoteUtils.extractNote (NoteUtilsTest.sol#133-152) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 159,
          "vulnerability_to_line": 165,
          "vulnerability_code": "    function getNoteType(bytes memory _note) internal pure returns (\n\n        uint256 noteType\n\n    ) {\n\n        assembly {\n\n            noteType := mload(add(_note, 0x20))\n\n        }\n",
          "message": "NoteUtils.getNoteType (NoteUtilsTest.sol#159-165) is declared view but contains assembly code\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 33,
          "vulnerability_to_line": 41,
          "vulnerability_code": "    function getLength(bytes memory _proofOutputsOrNotes) internal pure returns (\n\n        uint len\n\n    ) {\n\n        assembly {\n\n            // first word = the raw byte length\n\n            // second word = the actual number of entries (hence the 0x20 offset)\n\n            len := mload(add(_proofOutputsOrNotes, 0x20))\n\n        }\n",
          "message": "NoteUtils.getLength uses assembly (NoteUtilsTest.sol#33-41)\n\t- NoteUtilsTest.sol#36-40\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 49,
          "vulnerability_to_line": 77,
          "vulnerability_code": "    function get(bytes memory _proofOutputsOrNotes, uint _i) internal pure returns (\n\n        bytes memory out\n\n    ) {\n\n        bool valid;\n\n        assembly {\n\n            // check that i < the number of entries\n\n            valid := lt(\n\n                _i,\n\n                mload(add(_proofOutputsOrNotes, 0x20))\n\n            )\n\n            // memory map of the array is as follows:\n\n            // 0x00 - 0x20 : byte length of array\n\n            // 0x20 - 0x40 : n, the number of entries\n\n            // 0x40 - 0x40 + (0x20 * i) : relative memory offset to start of i'th entry (i <= n)\n\n\n\n            // Step 1: compute location of relative memory offset: _proofOutputsOrNotes + 0x40 + (0x20 * i) \n\n            // Step 2: loaded relative offset and add to _proofOutputsOrNotes to get absolute memory location\n\n            out := add(\n\n                mload(\n\n                    add(\n\n                        add(_proofOutputsOrNotes, 0x40),\n\n                        mul(_i, 0x20)\n\n                    )\n\n                ),\n\n                _proofOutputsOrNotes\n\n            )\n\n        }\n\n        require(valid, \"AZTEC array index is out of bounds\");\n",
          "message": "NoteUtils.get uses assembly (NoteUtilsTest.sol#49-77)\n\t- NoteUtilsTest.sol#53-75\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 89,
          "vulnerability_to_line": 111,
          "vulnerability_code": "    function extractProofOutput(bytes memory _proofOutput) internal pure returns (\n\n        bytes memory inputNotes,\n\n        bytes memory outputNotes,\n\n        address publicOwner,\n\n        int256 publicValue\n\n    ) {\n\n        assembly {\n\n            // memory map of a proofOutput:\n\n            // 0x00 - 0x20 : byte length of proofOutput\n\n            // 0x20 - 0x40 : relative offset to inputNotes\n\n            // 0x40 - 0x60 : relative offset to outputNotes\n\n            // 0x60 - 0x80 : publicOwner\n\n            // 0x80 - 0xa0 : publicValue\n\n            // 0xa0 - 0xc0 : challenge\n\n            inputNotes := add(_proofOutput, mload(add(_proofOutput, 0x20)))\n\n            outputNotes := add(_proofOutput, mload(add(_proofOutput, 0x40)))\n\n            publicOwner := and(\n\n                mload(add(_proofOutput, 0x60)),\n\n                0xffffffffffffffffffffffffffffffffffffffff\n\n            )\n\n            publicValue := mload(add(_proofOutput, 0x80))\n\n        }\n",
          "message": "NoteUtils.extractProofOutput uses assembly (NoteUtilsTest.sol#89-111)\n\t- NoteUtilsTest.sol#95-110\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 118,
          "vulnerability_to_line": 124,
          "vulnerability_code": "    function extractChallenge(bytes memory _proofOutput) internal pure returns (\n\n        bytes32 challenge\n\n    ) {\n\n        assembly {\n\n            challenge := mload(add(_proofOutput, 0xa0))\n\n        }\n",
          "message": "NoteUtils.extractChallenge uses assembly (NoteUtilsTest.sol#118-124)\n\t- NoteUtilsTest.sol#121-123\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 133,
          "vulnerability_to_line": 152,
          "vulnerability_code": "    function extractNote(bytes memory _note) internal pure returns (\n\n            address owner,\n\n            bytes32 noteHash,\n\n            bytes memory metadata\n\n    ) {\n\n        assembly {\n\n            // memory map of a note:\n\n            // 0x00 - 0x20 : byte length of note\n\n            // 0x20 - 0x40 : note type\n\n            // 0x40 - 0x60 : owner\n\n            // 0x60 - 0x80 : noteHash\n\n            // 0x80 - 0xa0 : start of metadata byte array\n\n            owner := and(\n\n                mload(add(_note, 0x40)),\n\n                0xffffffffffffffffffffffffffffffffffffffff\n\n            )\n\n            noteHash := mload(add(_note, 0x60))\n\n            metadata := add(_note, 0x80)\n\n        }\n",
          "message": "NoteUtils.extractNote uses assembly (NoteUtilsTest.sol#133-152)\n\t- NoteUtilsTest.sol#138-151\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 159,
          "vulnerability_to_line": 165,
          "vulnerability_code": "    function getNoteType(bytes memory _note) internal pure returns (\n\n        uint256 noteType\n\n    ) {\n\n        assembly {\n\n            noteType := mload(add(_note, 0x20))\n\n        }\n",
          "message": "NoteUtils.getNoteType uses assembly (NoteUtilsTest.sol#159-165)\n\t- NoteUtilsTest.sol#162-164\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 201,
          "vulnerability_to_line": 205,
          "vulnerability_code": "    function getLength(bytes memory _proofOutputsOrNotes) public pure returns (\n\n        uint len\n\n    ) {\n\n        return _proofOutputsOrNotes.getLength();\n",
          "message": "NoteUtilsTest.getLength (NoteUtilsTest.sol#201-205) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 213,
          "vulnerability_to_line": 217,
          "vulnerability_code": "    function get(bytes memory _proofOutputsOrNotes, uint _i) public pure returns (\n\n        bytes memory out\n\n    ) {\n\n        return _proofOutputsOrNotes.get(_i);\n",
          "message": "NoteUtilsTest.get (NoteUtilsTest.sol#213-217) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 229,
          "vulnerability_to_line": 236,
          "vulnerability_code": "    function extractProofOutput(bytes memory _proofOutput) public pure returns (\n\n        bytes memory inputNotes,\n\n        bytes memory outputNotes,\n\n        address publicOwner,\n\n        int256 publicValue\n\n    ) {\n\n        return _proofOutput.extractProofOutput();\n",
          "message": "NoteUtilsTest.extractProofOutput (NoteUtilsTest.sol#229-236) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 243,
          "vulnerability_to_line": 247,
          "vulnerability_code": "    function extractChallenge(bytes memory _proofOutput) public pure returns (\n\n        bytes32 challenge\n\n    ) {\n\n        return _proofOutput.extractChallenge();\n",
          "message": "NoteUtilsTest.extractChallenge (NoteUtilsTest.sol#243-247) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 256,
          "vulnerability_to_line": 262,
          "vulnerability_code": "    function extractNote(bytes memory _note) public pure returns (\n\n        address owner,\n\n        bytes32 noteHash,\n\n        bytes memory metadata\n\n    ) {\n\n        return _note.extractNote();\n",
          "message": "NoteUtilsTest.extractNote (NoteUtilsTest.sol#256-262) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 269,
          "vulnerability_to_line": 273,
          "vulnerability_code": "    function getNoteType(bytes memory _note) public pure returns (\n\n        uint256 noteType\n\n    ) {\n\n        return _note.getNoteType();\n",
          "message": "NoteUtilsTest.getNoteType (NoteUtilsTest.sol#269-273) should be declared external\n"
        },
        {
          "name": "solc-version",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
          "message": "Detected issues with version pragma in NoteUtilsTest.sol:\n\t- pragma solidity>=0.5.0<0.6.0 (NoteUtilsTest.sol#3): it allows old versions\n\t- pragma solidity>=0.5.0<0.6.0 (NoteUtilsTest.sol#170): it allows old versions\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 201,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getLength(bytes memory _proofOutputsOrNotes) public pure returns (\n",
          "message": "Parameter '_proofOutputsOrNotes' of NoteUtilsTest.getLength (NoteUtilsTest.sol#201) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 213,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function get(bytes memory _proofOutputsOrNotes, uint _i) public pure returns (\n",
          "message": "Parameter '_proofOutputsOrNotes' of NoteUtilsTest.get (NoteUtilsTest.sol#213) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 213,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function get(bytes memory _proofOutputsOrNotes, uint _i) public pure returns (\n",
          "message": "Parameter '_i' of NoteUtilsTest.get (NoteUtilsTest.sol#213) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 229,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function extractProofOutput(bytes memory _proofOutput) public pure returns (\n",
          "message": "Parameter '_proofOutput' of NoteUtilsTest.extractProofOutput (NoteUtilsTest.sol#229) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 243,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function extractChallenge(bytes memory _proofOutput) public pure returns (\n",
          "message": "Parameter '_proofOutput' of NoteUtilsTest.extractChallenge (NoteUtilsTest.sol#243) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 256,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function extractNote(bytes memory _note) public pure returns (\n",
          "message": "Parameter '_note' of NoteUtilsTest.extractNote (NoteUtilsTest.sol#256) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 269,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getNoteType(bytes memory _note) public pure returns (\n",
          "message": "Parameter '_note' of NoteUtilsTest.getNoteType (NoteUtilsTest.sol#269) is not in mixedCase\n"
        }
      ]
    },
    "smartcheck": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
          "vulnerability_from_line": 33,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getLength(bytes memory _proofOutputsOrNotes) internal pure returns (\n",
          "message": null
        },
        {
          "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
          "vulnerability_from_line": 49,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function get(bytes memory _proofOutputsOrNotes, uint _i) internal pure returns (\n",
          "message": null
        },
        {
          "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
          "vulnerability_from_line": 89,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function extractProofOutput(bytes memory _proofOutput) internal pure returns (\n",
          "message": null
        },
        {
          "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
          "vulnerability_from_line": 118,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function extractChallenge(bytes memory _proofOutput) internal pure returns (\n",
          "message": null
        },
        {
          "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
          "vulnerability_from_line": 133,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function extractNote(bytes memory _note) internal pure returns (\n",
          "message": null
        },
        {
          "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
          "vulnerability_from_line": 159,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getNoteType(bytes memory _note) internal pure returns (\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 170,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 170,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 33,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getLength(bytes memory _proofOutputsOrNotes) internal pure returns (\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 49,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function get(bytes memory _proofOutputsOrNotes, uint _i) internal pure returns (\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 89,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function extractProofOutput(bytes memory _proofOutput) internal pure returns (\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 118,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function extractChallenge(bytes memory _proofOutput) internal pure returns (\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 133,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function extractNote(bytes memory _note) internal pure returns (\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 159,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getNoteType(bytes memory _note) internal pure returns (\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 89,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function extractProofOutput(bytes memory _proofOutput) internal pure returns (\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 133,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function extractNote(bytes memory _note) internal pure returns (\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 229,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function extractProofOutput(bytes memory _proofOutput) public pure returns (\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 256,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function extractNote(bytes memory _note) public pure returns (\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 36,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 53,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 95,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 121,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 138,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 162,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        }
      ]
    },
    "oyente": {
      "successfull_analysis": false,
      "errors": [
        "exception (RuntimeError: Source map error, unknown name(SHR) or instr_name(INVALID))"
      ],
      "vulnerability_findings": []
    },
    "mythril": {
      "successfull_analysis": false,
      "errors": [
        "Solc experienced a fatal error"
      ],
      "vulnerability_findings": []
    },
    "osiris": {
      "successfull_analysis": false,
      "errors": [
        "Solidity compilation failed"
      ],
      "vulnerability_findings": []
    }
  }
}