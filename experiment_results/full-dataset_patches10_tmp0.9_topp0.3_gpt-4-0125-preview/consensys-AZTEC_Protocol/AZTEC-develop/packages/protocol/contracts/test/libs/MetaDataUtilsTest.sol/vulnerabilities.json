{
  "smartbugs_completed": true,
  "analyzer_results": {
    "semgrep": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 60,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 61,
          "vulnerability_to_line": null,
          "vulnerability_code": "            addressPos < numAddresses, \n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 62,
          "vulnerability_to_line": null,
          "vulnerability_code": "            'addressPos out of bounds - addressPos must be less than the number of addresses to be approved'\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 63,
          "vulnerability_to_line": null,
          "vulnerability_code": "        );\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 60,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 61,
          "vulnerability_to_line": null,
          "vulnerability_code": "            addressPos < numAddresses, \n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 62,
          "vulnerability_to_line": null,
          "vulnerability_code": "            'addressPos out of bounds - addressPos must be less than the number of addresses to be approved'\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 63,
          "vulnerability_to_line": null,
          "vulnerability_code": "        );\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        }
      ]
    },
    "slither": {
      "successfull_analysis": true,
      "errors": [
        "EXIT_CODE_5"
      ],
      "vulnerability_findings": [
        {
          "name": "constant-function",
          "vulnerability_from_line": 31,
          "vulnerability_to_line": 64,
          "vulnerability_code": "    function extractAddress(bytes memory metaData, uint256 addressPos) pure internal returns (address desiredAddress) {\n\n        /**\n\n        * Memory map of metaData. This is the ABI encoding of metaData, supplied by the client\n\n        * The first word of any dynamic bytes array within this map, is the number of discrete elements in that \n\n        * bytes array. e.g. first word at 0xe1 is the number of approvedAddresses\n\n        * 0x00 - 0x20 : length of metaData\n\n        * 0x20 - 0x81 : ephemeral key\n\n        * 0x81 - 0xa1 : approved addresses offset\n\n        * 0xa1 - 0xc1 : encrypted view keys offset\n\n        * 0xc1 - 0xe1 : app data offset\n\n        * 0xe1 - L_addresses : approvedAddresses\n\n        * (0xe1 + L_addresses) - (0xe1 + L_addresses + L_encryptedViewKeys) : encrypted view keys\n\n        * (0xe1 + L_addresses + L_encryptedViewKeys) - (0xe1 + L_addresses + L_encryptedViewKeys + L_appData) : appData\n\n        */\n\n\n\n        uint256 numAddresses;\n\n        assembly {\n\n            numAddresses := mload(add(metaData, 0x20))\n\n            desiredAddress := mload(\n\n                add(\n\n                    add(\n\n                        metaData,\n\n                        add(0xe1, 0x20)  // go to the start of addresses, jump over first word\n\n                    ),\n\n                    mul(addressPos, 0x20) // jump to the desired address\n\n                )\n\n            )\n\n        }\n\n\n\n        require(\n\n            addressPos < numAddresses, \n\n            'addressPos out of bounds - addressPos must be less than the number of addresses to be approved'\n\n        );\n",
          "message": "MetaDataUtils.extractAddress (MetaDataUtilsTest.sol#31-64) is declared view but contains assembly code\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 31,
          "vulnerability_to_line": 64,
          "vulnerability_code": "    function extractAddress(bytes memory metaData, uint256 addressPos) pure internal returns (address desiredAddress) {\n\n        /**\n\n        * Memory map of metaData. This is the ABI encoding of metaData, supplied by the client\n\n        * The first word of any dynamic bytes array within this map, is the number of discrete elements in that \n\n        * bytes array. e.g. first word at 0xe1 is the number of approvedAddresses\n\n        * 0x00 - 0x20 : length of metaData\n\n        * 0x20 - 0x81 : ephemeral key\n\n        * 0x81 - 0xa1 : approved addresses offset\n\n        * 0xa1 - 0xc1 : encrypted view keys offset\n\n        * 0xc1 - 0xe1 : app data offset\n\n        * 0xe1 - L_addresses : approvedAddresses\n\n        * (0xe1 + L_addresses) - (0xe1 + L_addresses + L_encryptedViewKeys) : encrypted view keys\n\n        * (0xe1 + L_addresses + L_encryptedViewKeys) - (0xe1 + L_addresses + L_encryptedViewKeys + L_appData) : appData\n\n        */\n\n\n\n        uint256 numAddresses;\n\n        assembly {\n\n            numAddresses := mload(add(metaData, 0x20))\n\n            desiredAddress := mload(\n\n                add(\n\n                    add(\n\n                        metaData,\n\n                        add(0xe1, 0x20)  // go to the start of addresses, jump over first word\n\n                    ),\n\n                    mul(addressPos, 0x20) // jump to the desired address\n\n                )\n\n            )\n\n        }\n\n\n\n        require(\n\n            addressPos < numAddresses, \n\n            'addressPos out of bounds - addressPos must be less than the number of addresses to be approved'\n\n        );\n",
          "message": "MetaDataUtils.extractAddress uses assembly (MetaDataUtilsTest.sol#31-64)\n\t- MetaDataUtilsTest.sol#47-58\n"
        },
        {
          "name": "pragma",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity >=0.5.0 <= 0.6.0;\n",
          "message": "Different versions of Solidity is used in MetaDataUtilsTest.sol:\n\t- Version used: ['>=0.5.0<0.6.0', '>=0.5.0<=0.6.0']\n\t- MetaDataUtilsTest.sol#3 declares pragma solidity>=0.5.0<=0.6.0\n\t- MetaDataUtilsTest.sol#69 declares pragma solidity>=0.5.0<0.6.0\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 99,
          "vulnerability_to_line": 101,
          "vulnerability_code": "    function extractAddress(bytes memory metaData, uint256 addressPos) public pure returns (address desiredAddress) {\n\n        return metaData.extractAddress(addressPos);\n",
          "message": "MetaDataUtilsTest.extractAddress (MetaDataUtilsTest.sol#99-101) should be declared external\n"
        },
        {
          "name": "solc-version",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity >=0.5.0 <= 0.6.0;\n",
          "message": "Detected issues with version pragma in MetaDataUtilsTest.sol:\n\t- pragma solidity>=0.5.0<=0.6.0 (MetaDataUtilsTest.sol#3): is has a complex pragma\n\t- pragma solidity>=0.5.0<0.6.0 (MetaDataUtilsTest.sol#69): it allows old versions\n"
        }
      ]
    },
    "smartcheck": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
          "vulnerability_from_line": 31,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function extractAddress(bytes memory metaData, uint256 addressPos) pure internal returns (address desiredAddress) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity >=0.5.0 <= 0.6.0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity >=0.5.0 <= 0.6.0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 69,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity >= 0.5.0 <0.6.0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 69,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity >= 0.5.0 <0.6.0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 31,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function extractAddress(bytes memory metaData, uint256 addressPos) pure internal returns (address desiredAddress) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 47,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        }
      ]
    },
    "oyente": {
      "successfull_analysis": false,
      "errors": [
        "exception (RuntimeError: Source map error, unknown name(SHR) or instr_name(INVALID))"
      ],
      "vulnerability_findings": []
    },
    "mythril": {
      "successfull_analysis": false,
      "errors": [
        "Solc experienced a fatal error"
      ],
      "vulnerability_findings": []
    },
    "osiris": {
      "successfull_analysis": false,
      "errors": [
        "Solidity compilation failed"
      ],
      "vulnerability_findings": []
    }
  }
}