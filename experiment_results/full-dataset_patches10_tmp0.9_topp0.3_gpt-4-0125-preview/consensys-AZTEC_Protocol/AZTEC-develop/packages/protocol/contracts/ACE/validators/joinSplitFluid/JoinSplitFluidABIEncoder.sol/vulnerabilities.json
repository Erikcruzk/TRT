{
  "smartbugs_completed": true,
  "analyzer_results": {
    "semgrep": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": []
    },
    "slither": {
      "successfull_analysis": true,
      "errors": [
        "EXIT_CODE_3"
      ],
      "vulnerability_findings": [
        {
          "name": "constant-function",
          "vulnerability_from_line": 50,
          "vulnerability_to_line": 330,
          "vulnerability_code": "    function encodeAndExit() internal pure {\n\n        assembly {\n\n            // set up initial variables\n\n            let notes := add(0x104, calldataload(0x144))\n\n            let n := calldataload(notes)\n\n            let inputOwners := add(0x124, calldataload(0x164)) // one word after input owners = 1st\n\n            let outputOwners := add(0x124, calldataload(0x184)) // one word after outputOwners = 1st\n\n            let metadata := add(0x144, calldataload(0x1a4)) // two words after metadata = 1st\n\n\n\n            // memory map of `proofOutputs`\n\n\n\n            // `returndata` starts at 0x160\n\n            // `proofOutputs` starts at 0x180\n\n            // 0x160 - 0x180 = relative offset in returndata to first bytes argument (0x20)\n\n            // 0x180 - 0x1a0 = byte length of `proofOutputs`\n\n            // 0x1a0 - 0x1c0 = number of `proofOutputs` entries (2)\n\n            // 0x1c0 - 0x1e0 = relative memory offset between `v` and start of `proofOutput`\n\n\n\n            // `proofOutput A` - t, starts at 0x1e0\n\n            // 0x1e0 - 0x200 = length of `proofOutputA`\n\n            // 0x200 - 0x220 = relative offset between `t` and `inputNotes`\n\n            // 0x220 - 0x240 = relative offset between `t` and `outputNotes`\n\n            // 0x240 - 0x260 = `publicOwner`\n\n            // 0x260 - 0x280 = `publicValue`\n\n            // 0x280 - 0x2a0 = `challenge`\n\n\n\n            // `inputNotes A` starts at 0x2a0\n\n            // structure of `inputNotes` and `outputNotes`\n\n            // 0x00 - 0x20 = byte length of notes array\n\n            // 0x20 - 0x40 = number of notes `i`\n\n            // the next `i` consecutive blocks of 0x20-sized memory contain relative offset between\n\n            // start of notes array and the location of the `note`\n\n\n\n            // `proofOutput B` - r\n\n            // 0x00 - 0x20 = length of `proofOutput B`\n\n            // 0x20 - 0x40 = relative offset between `r` and `inputNotes`\n\n            // 0x40 - 0x60 = relative offset between `r` and `outputNotes`\n\n            // 0x60 - 0x80 = `publicOwner`\n\n            // 0x80 - 0xa0 = `publicValue`\n\n            // 0xa0 - 0xc0 = `challenge`\n\n\n\n            // 'inputNotes B'\n\n            // structure of `inputNotes` and `outputNotes`\n\n            // 0x00 - 0x20 = byte length of notes array\n\n            // 0x20 - 0x40 = number of notes `i`\n\n            // the next `i` consecutive blocks of 0x20-sized memory contain relative offset between\n\n            // start of notes array and the location of the `note`\n\n\n\n            // structure of a `note`\n\n            // 0x00 - 0x20 = size of `note`\n\n            // 0x20 - 0x40 = `noteType`\n\n            // 0x40 - 0x60 = `owner`\n\n            // 0x60 - 0x80 = `noteHash`\n\n            // 0x80 - 0xa0 = size of note `data`\n\n            // 0xa0 - 0xc0 = compressed note coordinate `gamma` (part of `data`)\n\n            // 0xc0 - 0xe0 = compressed note coordinate `sigma` (part of `data`)\n\n            // 0xe0 - ???? = remaining note metadata\n\n\n\n            // `proofOutputs` must form a monolithic block of memory that we can return.\n\n            // `s` points to the memory location of the start of the current note\n\n            // `inputPtr` points to the start of the current `notes` dynamic bytes array\n\n\n\n            // length of proofOutputs is at s\n\n            mstore(0x1a0, 0x02)                            // there are two proofOutput objects for a join-split fluid\n\n            mstore(0x1c0, 0x80)                            // offset to 1st proof\n\n            // 0x1e0 = offset to 2nd proof\n\n            // length of proofOutput is at s + 0x60\n\n            mstore(0x220, 0xc0)                            // location of inputNotes\n\n            mstore(0x260, 0x00)                            // publicOwner is 0\n\n            mstore(0x280, 0x00)                            // publicValue is 0\n\n\n\n            mstore(0x2a0, calldataload(0x124))\n\n\n\n            // set note pointer, offsetting lookup indices for each input note\n\n\n\n            /////////////////// PROOF OUTPUT A: START OF INPUT NOTES //////////////////\n\n            // 0x2c0 = number of bytes in `inputNotes` (leave blank for now)\n\n            // 0x2e0 = number of input notes\n\n            mstore(0x2e0, 0x01)\n\n\n\n            // 0x300 = relative offset to 1st input note (0x60)\n\n            mstore(0x300, 0x60)\n\n\n\n            // Start of inputNote[0]\n\n            // get pointer to metadata\n\n            let metadataIndex := calldataload(metadata)\n\n\n\n            // copy note data to 0x20 - 0xa0\n\n            mstore(0x00, 0x01)\n\n            calldatacopy(0x20, add(notes, 0x120), 0x80) // get gamma, sigma\n\n\n\n            // store note length in `s` = 0x320\n\n            mstore(0x320, 0xc0)\n\n            // store note type (UXTO type, 0x01) in `s + 0x20`\n\n            mstore(0x340, 0x01)\n\n            // store the owner of the note in `s + 0x40`\n\n            mstore(0x360, calldataload(outputOwners))\n\n            // store note hash\n\n            mstore(0x380, keccak256(0x00, 0xa0))\n\n            // store noteData length in `s + 0x80`\n\n            mstore(0x3a0, 0x40)\n\n            // store compressed note coordinate gamma in `s + 0xa0`\n\n            mstore(\n\n                0x3c0,\n\n                or(\n\n                    mload(0x20),\n\n                    shl(255, and(mload(0x40), 0x01))\n\n                )\n\n            )\n\n            // store compressed note coordinate sigma in `s + 0xc0`\n\n            mstore(\n\n                0x3e0,\n\n                or(\n\n                    mload(0x60),\n\n                    shl(255, and(mload(0x80), 0x01))\n\n                )\n\n            )\n\n            // inputNote, so no metaData to store\n\n\n\n            // store relative memory offset to outputNotes\n\n            mstore(0x240, 0x200)\n\n            // store the length of inputNotes at 0x2c0\n\n            mstore(0x2c0, 0x120)\n\n            ///////////////// PROOF OUTPUT A: START OF OUTPUT NOTES (1) ///////////////////\n\n\n\n            // transition between input and output notes\n\n\n\n            // 0x400 + metadataLength = byte length of output notes (0x120)\n\n            // 0x420 + metadataLength = # of output notes (1)\n\n            // 0x440 + metadataLength = offset to outputNotes[0] (0x60)\n\n            let metadataLength := calldataload(add(metadataIndex, sub(metadata, 0x40)))\n\n\n\n            mstore(0x400, add(0x120, metadataLength)) // store length of output notes\n\n            mstore(0x420, 0x01) // store number of output notes\n\n            mstore(0x440, 0x60) // store offset to outputNotes[0]\n\n\n\n            // construct note hash\n\n            // copy 1st note note to 0x20 - 0xa0\n\n            calldatacopy(0x20, add(notes, 0x60), 0x80) // get gamma, sigma\n\n\n\n            // store note length in `s`\n\n            mstore(0x460, add(0xc0, metadataLength))\n\n            // store note type (UXTO type, 0x01) in `s + 0x20`\n\n            mstore(0x480, 0x01)\n\n            // store note owner in `s + 0x40`\n\n            mstore(0x4a0, calldataload(inputOwners))\n\n            // store note hash in `s + 0x60`\n\n            mstore(0x4c0, keccak256(0x00, 0xa0))\n\n            // store note metadata length in `s + 0x80` (just the coordinates)\n\n            mstore(0x4e0, add(0x40, metadataLength))\n\n            // store compressed note coordinate gamma in `s + 0xa0`\n\n            mstore(\n\n                0x500,\n\n                or(\n\n                    mload(0x20),\n\n                    shl(255, and(mload(0x40), 0x01))\n\n                )\n\n            )\n\n            // store compressed note coordinate sigma in `s + 0xc0`\n\n            mstore(\n\n                0x520,\n\n                or(\n\n                    mload(0x60),\n\n                    shl(255, and(mload(0x80), 0x01))\n\n                )\n\n            )\n\n\n\n            calldatacopy(0x540, add(metadataIndex, sub(metadata, 0x20)), metadataLength)\n\n\n\n            // compute the relative offset to index this note in our returndata\n\n            mstore(add(0x440, 0), 0x60) // relative offset to note\n\n\n\n            // now we need to transition between first and second proofOutput\n\n            // s is going to point to the end of the outputNotes array\n\n            // so, s is our absolute pointer to the start of the 2nd proofOutputs entry\n\n            // we know that 'proofOutputs' starts at 0x180\n\n            // so (s - 0x180) = relative offset to second proofOutputs entry\n\n            let startOfProofOutput := add(0x540, metadataLength)\n\n\n\n            // proofOutput[0].length = start of proofOutput[1] - start of proofOutput[0] - 0x20\n\n            // proofOutput[0].length = (0x540 + metadataLength) - 0x200 - 0x20 = 0x320 + metadataLength\n\n            mstore(0x200, add(0x320, metadataLength)) // length of proofOutput\n\n            mstore(0x1e0, add(0x3c0, metadataLength)) // offset to get to second proofOutput\n\n\n\n            // s points to the start of proofOutputs[0]\n\n            let s := startOfProofOutput\n\n            mstore(add(s, 0x20), 0xc0)   // location of inputNotes\n\n            mstore(add(s, 0x40), 0x100)  // location of outputNotes\n\n            mstore(add(s, 0x60), 0x00)   // publicOwner\n\n            mstore(add(s, 0x80), 0x00)   // publicValue\n\n\n\n            // compute challenge = kecck256(challenge)\n\n            mstore(0x20, calldataload(0x124))\n\n            mstore(add(s, 0xa0), keccak256(0x20, 0x20)) // challenge\n\n            // 0x00 length of proofOutput\n\n            // 0x20 location of inputNotes\n\n            // 0x40 location of outputNotes\n\n            // 0x60 publicOwner\n\n            // 0x80 publicValue\n\n            // 0xa0 = inputNoteData\n\n            mstore(add(s, 0xc0), 0x20) // length of input notes array (1 word)\n\n            mstore(add(s, 0xe0), 0x00) // number of entries (0 words)\n\n\n\n            // set notesPtr = proofOutputs[1].outputNotes\n\n            let notesPtr := add(s, 0x100)\n\n\n\n            // s + 0x20 = number of notes = n - 2\n\n            mstore(add(notesPtr, 0x20), sub(n, 2))\n\n\n\n            // set s to point to proofOutputs[1].outputNotes[0]\n\n            s := add(add(s, 0x140), mul(0x20, sub(n, 2)))\n\n\n\n            // Output notes:\n\n            // first output note needs to go into the first proofOutput object\n\n            // second output note onwards, needs to go into the second proofOutput object\n\n            for { let i := 0x02 } lt(i, n) { i := add(i, 0x01) } {\n\n\n\n            /////////////////// START OF PROOF OUTPUT B  ////////////////////\n\n\n\n                // get pointer to metadata\n\n                metadataIndex := calldataload(add(metadata, mul(sub(i, 0x01), 0x20)))\n\n                // get size of metadata\n\n                metadataLength := calldataload(add(sub(metadata, 0x40), metadataIndex))\n\n\n\n                mstore(0x00, 0x01)\n\n                // copy note data to 0x20 - 0xa0\n\n                calldatacopy(\n\n                    0x20,\n\n                    add(add(notes, 0x60), mul(i, 0xc0)),\n\n                    0x80\n\n                ) // get gamma, sigma\n\n\n\n                // store note length in `s`\n\n                mstore(s, add(0xc0, metadataLength))\n\n                // store note type (UXTO type, 0x01) in `s + 0x20`\n\n                mstore(add(s, 0x20), 0x01)\n\n                // store the owner of the note in `s + 0x40`\n\n                mstore(add(s, 0x40), calldataload(add(outputOwners, mul(sub(i, 0x01), 0x20))))\n\n                // store note hash\n\n                mstore(add(s, 0x60), keccak256(0x00, 0xa0))\n\n                // store note metadata length if `s + 0x80`\n\n                mstore(add(s, 0x80), add(0x40, metadataLength))\n\n                // store compressed note coordinate gamma in `s + 0xa0`\n\n                mstore(\n\n                    add(s, 0xa0),\n\n                    or(\n\n                        mload(0x20),\n\n                        shl(255, and(mload(0x40), 0x01))\n\n                    )\n\n                )\n\n                // store compressed note coordinate sigma in `s + 0xc0`\n\n                mstore(\n\n                    add(s, 0xc0),\n\n                    or(\n\n                        mload(0x60),\n\n                        shl(255, and(mload(0x80), 0x01))\n\n                    )\n\n                )\n\n                // copy metadata into `s + 0xe0`\n\n                calldatacopy(add(s, 0xe0), add(metadataIndex, sub(metadata, 0x20)), metadataLength)\n\n                // compute the relative offset to index this note in our returndata\n\n                mstore(add(notesPtr, mul(i, 0x20)), sub(s, notesPtr)) // relative offset to note\n\n\n\n                // increase s by note length\n\n                s := add(s, add(mload(s), 0x20))\n\n            }\n\n\n\n            // inputPtr used to point to start of inputNotes for proofOutputs[0]\n\n            // now we want inputPtr to point to start of inputNotes for proofOutputs[1]\n\n            // 1. length of proofOutput\n\n            // 2. length of outputNotes\n\n            // length of outputNotes = s - inputPtr, stored at inputPtr\n\n            mstore(notesPtr, sub(sub(s, notesPtr), 0x20)) // store length of outputNotes at start of outputNotes\n\n            // length of proofOutput\n\n            let proofOutputLength := sub(s, startOfProofOutput)\n\n            mstore(startOfProofOutput, sub(proofOutputLength, 0x20))\n\n            mstore(0x180, sub(s, 0x1a0)) // store length of proofOutputs at 0x100\n\n            mstore(0x160, 0x20)\n\n            return(0x160, sub(s, 0x160)) // return the final byte array\n\n        }\n",
          "message": "JoinSplitFluidABIEncoder.encodeAndExit (JoinSplitFluidABIEncoder.sol#50-330) is declared view but contains assembly code\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 50,
          "vulnerability_to_line": 330,
          "vulnerability_code": "    function encodeAndExit() internal pure {\n\n        assembly {\n\n            // set up initial variables\n\n            let notes := add(0x104, calldataload(0x144))\n\n            let n := calldataload(notes)\n\n            let inputOwners := add(0x124, calldataload(0x164)) // one word after input owners = 1st\n\n            let outputOwners := add(0x124, calldataload(0x184)) // one word after outputOwners = 1st\n\n            let metadata := add(0x144, calldataload(0x1a4)) // two words after metadata = 1st\n\n\n\n            // memory map of `proofOutputs`\n\n\n\n            // `returndata` starts at 0x160\n\n            // `proofOutputs` starts at 0x180\n\n            // 0x160 - 0x180 = relative offset in returndata to first bytes argument (0x20)\n\n            // 0x180 - 0x1a0 = byte length of `proofOutputs`\n\n            // 0x1a0 - 0x1c0 = number of `proofOutputs` entries (2)\n\n            // 0x1c0 - 0x1e0 = relative memory offset between `v` and start of `proofOutput`\n\n\n\n            // `proofOutput A` - t, starts at 0x1e0\n\n            // 0x1e0 - 0x200 = length of `proofOutputA`\n\n            // 0x200 - 0x220 = relative offset between `t` and `inputNotes`\n\n            // 0x220 - 0x240 = relative offset between `t` and `outputNotes`\n\n            // 0x240 - 0x260 = `publicOwner`\n\n            // 0x260 - 0x280 = `publicValue`\n\n            // 0x280 - 0x2a0 = `challenge`\n\n\n\n            // `inputNotes A` starts at 0x2a0\n\n            // structure of `inputNotes` and `outputNotes`\n\n            // 0x00 - 0x20 = byte length of notes array\n\n            // 0x20 - 0x40 = number of notes `i`\n\n            // the next `i` consecutive blocks of 0x20-sized memory contain relative offset between\n\n            // start of notes array and the location of the `note`\n\n\n\n            // `proofOutput B` - r\n\n            // 0x00 - 0x20 = length of `proofOutput B`\n\n            // 0x20 - 0x40 = relative offset between `r` and `inputNotes`\n\n            // 0x40 - 0x60 = relative offset between `r` and `outputNotes`\n\n            // 0x60 - 0x80 = `publicOwner`\n\n            // 0x80 - 0xa0 = `publicValue`\n\n            // 0xa0 - 0xc0 = `challenge`\n\n\n\n            // 'inputNotes B'\n\n            // structure of `inputNotes` and `outputNotes`\n\n            // 0x00 - 0x20 = byte length of notes array\n\n            // 0x20 - 0x40 = number of notes `i`\n\n            // the next `i` consecutive blocks of 0x20-sized memory contain relative offset between\n\n            // start of notes array and the location of the `note`\n\n\n\n            // structure of a `note`\n\n            // 0x00 - 0x20 = size of `note`\n\n            // 0x20 - 0x40 = `noteType`\n\n            // 0x40 - 0x60 = `owner`\n\n            // 0x60 - 0x80 = `noteHash`\n\n            // 0x80 - 0xa0 = size of note `data`\n\n            // 0xa0 - 0xc0 = compressed note coordinate `gamma` (part of `data`)\n\n            // 0xc0 - 0xe0 = compressed note coordinate `sigma` (part of `data`)\n\n            // 0xe0 - ???? = remaining note metadata\n\n\n\n            // `proofOutputs` must form a monolithic block of memory that we can return.\n\n            // `s` points to the memory location of the start of the current note\n\n            // `inputPtr` points to the start of the current `notes` dynamic bytes array\n\n\n\n            // length of proofOutputs is at s\n\n            mstore(0x1a0, 0x02)                            // there are two proofOutput objects for a join-split fluid\n\n            mstore(0x1c0, 0x80)                            // offset to 1st proof\n\n            // 0x1e0 = offset to 2nd proof\n\n            // length of proofOutput is at s + 0x60\n\n            mstore(0x220, 0xc0)                            // location of inputNotes\n\n            mstore(0x260, 0x00)                            // publicOwner is 0\n\n            mstore(0x280, 0x00)                            // publicValue is 0\n\n\n\n            mstore(0x2a0, calldataload(0x124))\n\n\n\n            // set note pointer, offsetting lookup indices for each input note\n\n\n\n            /////////////////// PROOF OUTPUT A: START OF INPUT NOTES //////////////////\n\n            // 0x2c0 = number of bytes in `inputNotes` (leave blank for now)\n\n            // 0x2e0 = number of input notes\n\n            mstore(0x2e0, 0x01)\n\n\n\n            // 0x300 = relative offset to 1st input note (0x60)\n\n            mstore(0x300, 0x60)\n\n\n\n            // Start of inputNote[0]\n\n            // get pointer to metadata\n\n            let metadataIndex := calldataload(metadata)\n\n\n\n            // copy note data to 0x20 - 0xa0\n\n            mstore(0x00, 0x01)\n\n            calldatacopy(0x20, add(notes, 0x120), 0x80) // get gamma, sigma\n\n\n\n            // store note length in `s` = 0x320\n\n            mstore(0x320, 0xc0)\n\n            // store note type (UXTO type, 0x01) in `s + 0x20`\n\n            mstore(0x340, 0x01)\n\n            // store the owner of the note in `s + 0x40`\n\n            mstore(0x360, calldataload(outputOwners))\n\n            // store note hash\n\n            mstore(0x380, keccak256(0x00, 0xa0))\n\n            // store noteData length in `s + 0x80`\n\n            mstore(0x3a0, 0x40)\n\n            // store compressed note coordinate gamma in `s + 0xa0`\n\n            mstore(\n\n                0x3c0,\n\n                or(\n\n                    mload(0x20),\n\n                    shl(255, and(mload(0x40), 0x01))\n\n                )\n\n            )\n\n            // store compressed note coordinate sigma in `s + 0xc0`\n\n            mstore(\n\n                0x3e0,\n\n                or(\n\n                    mload(0x60),\n\n                    shl(255, and(mload(0x80), 0x01))\n\n                )\n\n            )\n\n            // inputNote, so no metaData to store\n\n\n\n            // store relative memory offset to outputNotes\n\n            mstore(0x240, 0x200)\n\n            // store the length of inputNotes at 0x2c0\n\n            mstore(0x2c0, 0x120)\n\n            ///////////////// PROOF OUTPUT A: START OF OUTPUT NOTES (1) ///////////////////\n\n\n\n            // transition between input and output notes\n\n\n\n            // 0x400 + metadataLength = byte length of output notes (0x120)\n\n            // 0x420 + metadataLength = # of output notes (1)\n\n            // 0x440 + metadataLength = offset to outputNotes[0] (0x60)\n\n            let metadataLength := calldataload(add(metadataIndex, sub(metadata, 0x40)))\n\n\n\n            mstore(0x400, add(0x120, metadataLength)) // store length of output notes\n\n            mstore(0x420, 0x01) // store number of output notes\n\n            mstore(0x440, 0x60) // store offset to outputNotes[0]\n\n\n\n            // construct note hash\n\n            // copy 1st note note to 0x20 - 0xa0\n\n            calldatacopy(0x20, add(notes, 0x60), 0x80) // get gamma, sigma\n\n\n\n            // store note length in `s`\n\n            mstore(0x460, add(0xc0, metadataLength))\n\n            // store note type (UXTO type, 0x01) in `s + 0x20`\n\n            mstore(0x480, 0x01)\n\n            // store note owner in `s + 0x40`\n\n            mstore(0x4a0, calldataload(inputOwners))\n\n            // store note hash in `s + 0x60`\n\n            mstore(0x4c0, keccak256(0x00, 0xa0))\n\n            // store note metadata length in `s + 0x80` (just the coordinates)\n\n            mstore(0x4e0, add(0x40, metadataLength))\n\n            // store compressed note coordinate gamma in `s + 0xa0`\n\n            mstore(\n\n                0x500,\n\n                or(\n\n                    mload(0x20),\n\n                    shl(255, and(mload(0x40), 0x01))\n\n                )\n\n            )\n\n            // store compressed note coordinate sigma in `s + 0xc0`\n\n            mstore(\n\n                0x520,\n\n                or(\n\n                    mload(0x60),\n\n                    shl(255, and(mload(0x80), 0x01))\n\n                )\n\n            )\n\n\n\n            calldatacopy(0x540, add(metadataIndex, sub(metadata, 0x20)), metadataLength)\n\n\n\n            // compute the relative offset to index this note in our returndata\n\n            mstore(add(0x440, 0), 0x60) // relative offset to note\n\n\n\n            // now we need to transition between first and second proofOutput\n\n            // s is going to point to the end of the outputNotes array\n\n            // so, s is our absolute pointer to the start of the 2nd proofOutputs entry\n\n            // we know that 'proofOutputs' starts at 0x180\n\n            // so (s - 0x180) = relative offset to second proofOutputs entry\n\n            let startOfProofOutput := add(0x540, metadataLength)\n\n\n\n            // proofOutput[0].length = start of proofOutput[1] - start of proofOutput[0] - 0x20\n\n            // proofOutput[0].length = (0x540 + metadataLength) - 0x200 - 0x20 = 0x320 + metadataLength\n\n            mstore(0x200, add(0x320, metadataLength)) // length of proofOutput\n\n            mstore(0x1e0, add(0x3c0, metadataLength)) // offset to get to second proofOutput\n\n\n\n            // s points to the start of proofOutputs[0]\n\n            let s := startOfProofOutput\n\n            mstore(add(s, 0x20), 0xc0)   // location of inputNotes\n\n            mstore(add(s, 0x40), 0x100)  // location of outputNotes\n\n            mstore(add(s, 0x60), 0x00)   // publicOwner\n\n            mstore(add(s, 0x80), 0x00)   // publicValue\n\n\n\n            // compute challenge = kecck256(challenge)\n\n            mstore(0x20, calldataload(0x124))\n\n            mstore(add(s, 0xa0), keccak256(0x20, 0x20)) // challenge\n\n            // 0x00 length of proofOutput\n\n            // 0x20 location of inputNotes\n\n            // 0x40 location of outputNotes\n\n            // 0x60 publicOwner\n\n            // 0x80 publicValue\n\n            // 0xa0 = inputNoteData\n\n            mstore(add(s, 0xc0), 0x20) // length of input notes array (1 word)\n\n            mstore(add(s, 0xe0), 0x00) // number of entries (0 words)\n\n\n\n            // set notesPtr = proofOutputs[1].outputNotes\n\n            let notesPtr := add(s, 0x100)\n\n\n\n            // s + 0x20 = number of notes = n - 2\n\n            mstore(add(notesPtr, 0x20), sub(n, 2))\n\n\n\n            // set s to point to proofOutputs[1].outputNotes[0]\n\n            s := add(add(s, 0x140), mul(0x20, sub(n, 2)))\n\n\n\n            // Output notes:\n\n            // first output note needs to go into the first proofOutput object\n\n            // second output note onwards, needs to go into the second proofOutput object\n\n            for { let i := 0x02 } lt(i, n) { i := add(i, 0x01) } {\n\n\n\n            /////////////////// START OF PROOF OUTPUT B  ////////////////////\n\n\n\n                // get pointer to metadata\n\n                metadataIndex := calldataload(add(metadata, mul(sub(i, 0x01), 0x20)))\n\n                // get size of metadata\n\n                metadataLength := calldataload(add(sub(metadata, 0x40), metadataIndex))\n\n\n\n                mstore(0x00, 0x01)\n\n                // copy note data to 0x20 - 0xa0\n\n                calldatacopy(\n\n                    0x20,\n\n                    add(add(notes, 0x60), mul(i, 0xc0)),\n\n                    0x80\n\n                ) // get gamma, sigma\n\n\n\n                // store note length in `s`\n\n                mstore(s, add(0xc0, metadataLength))\n\n                // store note type (UXTO type, 0x01) in `s + 0x20`\n\n                mstore(add(s, 0x20), 0x01)\n\n                // store the owner of the note in `s + 0x40`\n\n                mstore(add(s, 0x40), calldataload(add(outputOwners, mul(sub(i, 0x01), 0x20))))\n\n                // store note hash\n\n                mstore(add(s, 0x60), keccak256(0x00, 0xa0))\n\n                // store note metadata length if `s + 0x80`\n\n                mstore(add(s, 0x80), add(0x40, metadataLength))\n\n                // store compressed note coordinate gamma in `s + 0xa0`\n\n                mstore(\n\n                    add(s, 0xa0),\n\n                    or(\n\n                        mload(0x20),\n\n                        shl(255, and(mload(0x40), 0x01))\n\n                    )\n\n                )\n\n                // store compressed note coordinate sigma in `s + 0xc0`\n\n                mstore(\n\n                    add(s, 0xc0),\n\n                    or(\n\n                        mload(0x60),\n\n                        shl(255, and(mload(0x80), 0x01))\n\n                    )\n\n                )\n\n                // copy metadata into `s + 0xe0`\n\n                calldatacopy(add(s, 0xe0), add(metadataIndex, sub(metadata, 0x20)), metadataLength)\n\n                // compute the relative offset to index this note in our returndata\n\n                mstore(add(notesPtr, mul(i, 0x20)), sub(s, notesPtr)) // relative offset to note\n\n\n\n                // increase s by note length\n\n                s := add(s, add(mload(s), 0x20))\n\n            }\n\n\n\n            // inputPtr used to point to start of inputNotes for proofOutputs[0]\n\n            // now we want inputPtr to point to start of inputNotes for proofOutputs[1]\n\n            // 1. length of proofOutput\n\n            // 2. length of outputNotes\n\n            // length of outputNotes = s - inputPtr, stored at inputPtr\n\n            mstore(notesPtr, sub(sub(s, notesPtr), 0x20)) // store length of outputNotes at start of outputNotes\n\n            // length of proofOutput\n\n            let proofOutputLength := sub(s, startOfProofOutput)\n\n            mstore(startOfProofOutput, sub(proofOutputLength, 0x20))\n\n            mstore(0x180, sub(s, 0x1a0)) // store length of proofOutputs at 0x100\n\n            mstore(0x160, 0x20)\n\n            return(0x160, sub(s, 0x160)) // return the final byte array\n\n        }\n",
          "message": "JoinSplitFluidABIEncoder.encodeAndExit uses assembly (JoinSplitFluidABIEncoder.sol#50-330)\n\t- JoinSplitFluidABIEncoder.sol#51-329\n"
        },
        {
          "name": "solc-version",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
          "message": "Detected issues with version pragma in JoinSplitFluidABIEncoder.sol:\n\t- pragma solidity>=0.5.0<0.6.0 (JoinSplitFluidABIEncoder.sol#3): it allows old versions\n"
        }
      ]
    },
    "smartcheck": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 50,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function encodeAndExit() internal pure {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 51,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        }
      ]
    },
    "oyente": {
      "successfull_analysis": false,
      "errors": [
        "exception (IndexError: pop from empty list)"
      ],
      "vulnerability_findings": []
    },
    "mythril": {
      "successfull_analysis": false,
      "errors": [
        "Solc experienced a fatal error"
      ],
      "vulnerability_findings": []
    },
    "osiris": {
      "successfull_analysis": false,
      "errors": [
        "Solidity compilation failed"
      ],
      "vulnerability_findings": []
    }
  }
}