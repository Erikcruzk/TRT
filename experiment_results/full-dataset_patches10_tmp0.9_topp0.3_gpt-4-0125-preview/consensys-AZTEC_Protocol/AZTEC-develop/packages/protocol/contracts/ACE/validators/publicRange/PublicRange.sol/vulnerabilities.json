{
  "smartbugs_completed": true,
  "analyzer_results": {
    "semgrep": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": []
    },
    "slither": {
      "successfull_analysis": true,
      "errors": [
        "EXIT_CODE_7"
      ],
      "vulnerability_findings": [
        {
          "name": "constant-function",
          "vulnerability_from_line": 49,
          "vulnerability_to_line": 232,
          "vulnerability_code": "    function encodeAndExit() internal pure {\n\n        assembly {\n\n            // set up initial variables\n\n            let notes := add(0x104, calldataload(0x164))\n\n            let n := 2\n\n            let m := 1\n\n            let inputOwners := add(0x124, calldataload(0x184)) // one word after inputOwners = 1st\n\n            let outputOwners := add(0x124, calldataload(0x1a4)) // one word after outputOwners = 1st\n\n            let metadata := add(0x144, calldataload(0x1c4)) // two words after metadata = 1st\n\n\n\n            // `returndata` starts at 0x160\n\n            // `proofOutputs` starts at 0x180\n\n            // 0x160 - 0x180 = relative offset in returndata to first bytes argument (0x20)\n\n            // 0x180 - 0x1a0 = byte length of `proofOutputs`\n\n            // 0x1a0 - 0x1c0 = number of `proofOutputs` entries (1)\n\n            // 0x1c0 - 0x1e0 = relative memory offset between `v` and start of `proofOutput`\n\n\n\n            // `proofOutput` - t, starts at 0x1e0\n\n            // 0x1e0 - 0x200 = length of `proofOutput`\n\n            // 0x200 - 0x220 = relative offset between `t` and `inputNotes`\n\n            // 0x220 - 0x240 = relative offset between `t` and `outputNotes`\n\n            // 0x240 - 0x260 = `publicOwner`\n\n            // 0x260 - 0x280 = `publicValue`\n\n\n\n            // `inputNotes` starts at 0x2a0\n\n            // structure of `inputNotes` and `outputNotes`\n\n            // 0x00 - 0x20 = byte length of notes array\n\n            // 0x20 - 0x40 = number of notes `i`\n\n            // DONE the next `i` consecutive blocks of 0x20-sized memory contain relative offset between\n\n            // start of notes array and the location of the `note`\n\n\n\n            // structure of a `note`\n\n            // 0x00 - 0x20 = size of `note`\n\n            // 0x20 - 0x40 = `noteType`\n\n            // 0x40 - 0x60 = `owner`\n\n            // 0x60 - 0x80 = `noteHash`\n\n            // 0x80 - 0xa0 = size of note `data`\n\n            // 0xa0 - 0xc0 = compressed note coordinate `gamma` (part of `data`)\n\n            // 0xc0 - 0xe0 = compressed note coordinate `sigma` (part of `data`)\n\n            // 0xe0 - ???? = remaining note metadata\n\n\n\n            // `proofOutputs` must form a monolithic block of memory that we can return.\n\n            // `s` points to the memory location of the start of the current note\n\n            // `inputPtr` points to the start of the current `notes` dynamic bytes array\n\n\n\n            // length of proofOutputs is at s\n\n            mstore(0x1a0, 0x01)                            // number of proofs\n\n            mstore(0x1c0, 0x60)                            // offset to 1st proof\n\n            // length of proofOutput is at s + 0x60\n\n            mstore(0x200, 0xc0)                            // location of inputNotes\n\n            // location of outputNotes is at s + 0xc0\n\n            mstore(0x240, 0x00)             // publicOwner\n\n\n\n            mstore(0x260, 0) // store kPublic (public value) = 0\n\n\n\n            // 0x280 = challenge\n\n            mstore(0x280, calldataload(0x124))\n\n\n\n            let inputPtr := 0x2a0                                 // point to inputNotes\n\n            mstore(add(inputPtr, 0x20), m)                        // number of input notes\n\n            // set note pointer, offsetting lookup indices for each input note\n\n            let s := add(0x2e0, mul(m, 0x20))\n\n\n\n            for { let i := 0 } lt(i, m) { i := add(i, 0x01) } {\n\n                let noteIndex := add(add(notes, 0x20), mul(i, 0xc0))\n\n                // copy note data to 0x00 - 0x80\n\n                mstore(0x00, 0x01) // store note type at 0x00\n\n                calldatacopy(0x20, add(noteIndex, 0x40), 0x80) // get gamma, sigma\n\n\n\n\n\n                // store note length in `s`\n\n                mstore(s, 0xc0)\n\n                // store note type (UXTO = 1) in `s+0x20`\n\n                mstore(add(s, 0x20), 0x01)\n\n                // store note owner in `s + 0x40`\n\n                mstore(add(s, 0x40), calldataload(inputOwners))\n\n            \n\n                // store note hash in `s + 0x60`\n\n                mstore(add(s, 0x60), keccak256(0x00, 0xa0))\n\n\n\n                // store note metadata length in `s + 0x80` (just the coordinates)\n\n                mstore(add(s, 0x80), 0x40)\n\n                // store compressed note coordinate gamma in `s + 0x80`\n\n                mstore(\n\n                    add(s, 0xa0),\n\n                    or(\n\n                        calldataload(add(noteIndex, 0x40)),\n\n                        mul(\n\n                            and(calldataload(add(noteIndex, 0x60)), 0x01),\n\n                            0x8000000000000000000000000000000000000000000000000000000000000000\n\n                        )\n\n                    )\n\n                )\n\n                // store compressed note coordinate sigma in `s + 0xa0`\n\n                mstore(\n\n                    add(s, 0xc0),\n\n                    or(\n\n                        calldataload(add(noteIndex, 0x80)),\n\n                        mul(\n\n                            and(calldataload(add(noteIndex, 0xa0)), 0x01),\n\n                            0x8000000000000000000000000000000000000000000000000000000000000000\n\n                        )\n\n                    )\n\n                )\n\n                // compute the relative offset to index this note in our returndata\n\n                mstore(add(add(inputPtr, 0x40), mul(i, 0x20)), sub(s, inputPtr)) // relative offset to note\n\n        \n\n                // increase s by note length\n\n                s := add(s, 0xe0)\n\n            }\n\n\n\n            // store total length of inputNotes at first index of inputNotes \n\n            mstore(inputPtr, sub(sub(s, inputPtr), 0x20))\n\n            mstore(0x220, add(0xc0, sub(s, inputPtr))) // store relative memory offset to outputNotes\n\n            inputPtr := s\n\n            mstore(add(inputPtr, 0x20), sub(n, m)) // store number of output notes\n\n            s := add(s, add(0x40, mul(sub(n, m), 0x20)))\n\n\n\n            // output notes\n\n            for { let i := m } lt(i, n) { i := add(i, 0x01) } {\n\n                // get note index\n\n                let noteIndex := add(add(notes, 0x20), mul(i, 0xc0))\n\n                // get pointer to metadata\n\n                let metadataIndex := calldataload(add(metadata, mul(sub(i, m), 0x20)))\n\n                // get size of metadata\n\n                let metadataLength := calldataload(add(sub(metadata, 0x40), metadataIndex))\n\n\n\n                mstore(0x00, 0x01) // store note type at 0x00\n\n                // copy note data to 0x20 - 0xa0\n\n                calldatacopy(0x20, add(noteIndex, 0x40), 0x80) // get gamma, sigma\n\n\n\n                // store note length in `s`\n\n                mstore(s, add(0xc0, metadataLength))\n\n                // store note type (UXTO = 1) in `s+0x20`\n\n                mstore(add(s, 0x20), 0x01)\n\n                // store the owner of the note in `s + 0x20`\n\n                mstore(add(s, 0x40), calldataload(add(outputOwners, mul(sub(i, m), 0x20))))\n\n                // store note hash\n\n                mstore(add(s, 0x60), keccak256(0x00, 0xa0))\n\n                // store note metadata length if `s + 0x60`\n\n                mstore(add(s, 0x80), add(0x40, metadataLength))\n\n                // store compressed note coordinate gamma in `s + 0x80`\n\n                mstore(\n\n                    add(s, 0xa0),\n\n                    or(\n\n                        mload(0x20),\n\n                        mul(\n\n                            and(mload(0x40), 0x01),\n\n                            0x8000000000000000000000000000000000000000000000000000000000000000\n\n                        )\n\n                    )\n\n                )\n\n                // store compressed note coordinate sigma in `s + 0xa0`\n\n                mstore(\n\n                add(s, 0xc0),\n\n                or(\n\n                    mload(0x60),\n\n                    mul(\n\n                        and(mload(0x80), 0x01),\n\n                        0x8000000000000000000000000000000000000000000000000000000000000000\n\n                    )\n\n                )\n\n                )\n\n                // copy metadata into `s + 0xc0`\n\n                calldatacopy(add(s, 0xe0), add(metadataIndex, sub(metadata, 0x20)), metadataLength)\n\n                // compute the relative offset to index this note in our returndata\n\n                mstore(add(add(inputPtr, 0x40), mul(sub(i, m), 0x20)), sub(s, inputPtr)) // relative offset to note\n\n\n\n                // increase s by note length\n\n                s := add(s, add(mload(s), 0x20))\n\n            }\n\n\n\n            // cleanup. the length of the outputNotes = s - inputPtr\n\n            mstore(inputPtr, sub(sub(s, inputPtr), 0x20)) // store length of outputNotes at start of outputNotes\n\n            let notesLength := sub(s, 0x2a0)\n\n            // store length of proofOutput at 0x160. 0xa0 comes from:\n\n            // (offset to input notes, offset to output notes, publicOwner, publicValue, challenge)\n\n            mstore(0x1e0, add(0xa0, notesLength))\n\n            mstore(0x180, add(0x100, notesLength)) // store length of proofOutputs at 0x100\n\n\n\n            mstore(0x160, 0x20)\n\n            return(0x160, add(0x140, notesLength)) // return the final byte array\n\n        }\n",
          "message": "PublicRangeABIEncoder.encodeAndExit (PublicRange.sol#49-232) is declared view but contains assembly code\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 49,
          "vulnerability_to_line": 232,
          "vulnerability_code": "    function encodeAndExit() internal pure {\n\n        assembly {\n\n            // set up initial variables\n\n            let notes := add(0x104, calldataload(0x164))\n\n            let n := 2\n\n            let m := 1\n\n            let inputOwners := add(0x124, calldataload(0x184)) // one word after inputOwners = 1st\n\n            let outputOwners := add(0x124, calldataload(0x1a4)) // one word after outputOwners = 1st\n\n            let metadata := add(0x144, calldataload(0x1c4)) // two words after metadata = 1st\n\n\n\n            // `returndata` starts at 0x160\n\n            // `proofOutputs` starts at 0x180\n\n            // 0x160 - 0x180 = relative offset in returndata to first bytes argument (0x20)\n\n            // 0x180 - 0x1a0 = byte length of `proofOutputs`\n\n            // 0x1a0 - 0x1c0 = number of `proofOutputs` entries (1)\n\n            // 0x1c0 - 0x1e0 = relative memory offset between `v` and start of `proofOutput`\n\n\n\n            // `proofOutput` - t, starts at 0x1e0\n\n            // 0x1e0 - 0x200 = length of `proofOutput`\n\n            // 0x200 - 0x220 = relative offset between `t` and `inputNotes`\n\n            // 0x220 - 0x240 = relative offset between `t` and `outputNotes`\n\n            // 0x240 - 0x260 = `publicOwner`\n\n            // 0x260 - 0x280 = `publicValue`\n\n\n\n            // `inputNotes` starts at 0x2a0\n\n            // structure of `inputNotes` and `outputNotes`\n\n            // 0x00 - 0x20 = byte length of notes array\n\n            // 0x20 - 0x40 = number of notes `i`\n\n            // DONE the next `i` consecutive blocks of 0x20-sized memory contain relative offset between\n\n            // start of notes array and the location of the `note`\n\n\n\n            // structure of a `note`\n\n            // 0x00 - 0x20 = size of `note`\n\n            // 0x20 - 0x40 = `noteType`\n\n            // 0x40 - 0x60 = `owner`\n\n            // 0x60 - 0x80 = `noteHash`\n\n            // 0x80 - 0xa0 = size of note `data`\n\n            // 0xa0 - 0xc0 = compressed note coordinate `gamma` (part of `data`)\n\n            // 0xc0 - 0xe0 = compressed note coordinate `sigma` (part of `data`)\n\n            // 0xe0 - ???? = remaining note metadata\n\n\n\n            // `proofOutputs` must form a monolithic block of memory that we can return.\n\n            // `s` points to the memory location of the start of the current note\n\n            // `inputPtr` points to the start of the current `notes` dynamic bytes array\n\n\n\n            // length of proofOutputs is at s\n\n            mstore(0x1a0, 0x01)                            // number of proofs\n\n            mstore(0x1c0, 0x60)                            // offset to 1st proof\n\n            // length of proofOutput is at s + 0x60\n\n            mstore(0x200, 0xc0)                            // location of inputNotes\n\n            // location of outputNotes is at s + 0xc0\n\n            mstore(0x240, 0x00)             // publicOwner\n\n\n\n            mstore(0x260, 0) // store kPublic (public value) = 0\n\n\n\n            // 0x280 = challenge\n\n            mstore(0x280, calldataload(0x124))\n\n\n\n            let inputPtr := 0x2a0                                 // point to inputNotes\n\n            mstore(add(inputPtr, 0x20), m)                        // number of input notes\n\n            // set note pointer, offsetting lookup indices for each input note\n\n            let s := add(0x2e0, mul(m, 0x20))\n\n\n\n            for { let i := 0 } lt(i, m) { i := add(i, 0x01) } {\n\n                let noteIndex := add(add(notes, 0x20), mul(i, 0xc0))\n\n                // copy note data to 0x00 - 0x80\n\n                mstore(0x00, 0x01) // store note type at 0x00\n\n                calldatacopy(0x20, add(noteIndex, 0x40), 0x80) // get gamma, sigma\n\n\n\n\n\n                // store note length in `s`\n\n                mstore(s, 0xc0)\n\n                // store note type (UXTO = 1) in `s+0x20`\n\n                mstore(add(s, 0x20), 0x01)\n\n                // store note owner in `s + 0x40`\n\n                mstore(add(s, 0x40), calldataload(inputOwners))\n\n            \n\n                // store note hash in `s + 0x60`\n\n                mstore(add(s, 0x60), keccak256(0x00, 0xa0))\n\n\n\n                // store note metadata length in `s + 0x80` (just the coordinates)\n\n                mstore(add(s, 0x80), 0x40)\n\n                // store compressed note coordinate gamma in `s + 0x80`\n\n                mstore(\n\n                    add(s, 0xa0),\n\n                    or(\n\n                        calldataload(add(noteIndex, 0x40)),\n\n                        mul(\n\n                            and(calldataload(add(noteIndex, 0x60)), 0x01),\n\n                            0x8000000000000000000000000000000000000000000000000000000000000000\n\n                        )\n\n                    )\n\n                )\n\n                // store compressed note coordinate sigma in `s + 0xa0`\n\n                mstore(\n\n                    add(s, 0xc0),\n\n                    or(\n\n                        calldataload(add(noteIndex, 0x80)),\n\n                        mul(\n\n                            and(calldataload(add(noteIndex, 0xa0)), 0x01),\n\n                            0x8000000000000000000000000000000000000000000000000000000000000000\n\n                        )\n\n                    )\n\n                )\n\n                // compute the relative offset to index this note in our returndata\n\n                mstore(add(add(inputPtr, 0x40), mul(i, 0x20)), sub(s, inputPtr)) // relative offset to note\n\n        \n\n                // increase s by note length\n\n                s := add(s, 0xe0)\n\n            }\n\n\n\n            // store total length of inputNotes at first index of inputNotes \n\n            mstore(inputPtr, sub(sub(s, inputPtr), 0x20))\n\n            mstore(0x220, add(0xc0, sub(s, inputPtr))) // store relative memory offset to outputNotes\n\n            inputPtr := s\n\n            mstore(add(inputPtr, 0x20), sub(n, m)) // store number of output notes\n\n            s := add(s, add(0x40, mul(sub(n, m), 0x20)))\n\n\n\n            // output notes\n\n            for { let i := m } lt(i, n) { i := add(i, 0x01) } {\n\n                // get note index\n\n                let noteIndex := add(add(notes, 0x20), mul(i, 0xc0))\n\n                // get pointer to metadata\n\n                let metadataIndex := calldataload(add(metadata, mul(sub(i, m), 0x20)))\n\n                // get size of metadata\n\n                let metadataLength := calldataload(add(sub(metadata, 0x40), metadataIndex))\n\n\n\n                mstore(0x00, 0x01) // store note type at 0x00\n\n                // copy note data to 0x20 - 0xa0\n\n                calldatacopy(0x20, add(noteIndex, 0x40), 0x80) // get gamma, sigma\n\n\n\n                // store note length in `s`\n\n                mstore(s, add(0xc0, metadataLength))\n\n                // store note type (UXTO = 1) in `s+0x20`\n\n                mstore(add(s, 0x20), 0x01)\n\n                // store the owner of the note in `s + 0x20`\n\n                mstore(add(s, 0x40), calldataload(add(outputOwners, mul(sub(i, m), 0x20))))\n\n                // store note hash\n\n                mstore(add(s, 0x60), keccak256(0x00, 0xa0))\n\n                // store note metadata length if `s + 0x60`\n\n                mstore(add(s, 0x80), add(0x40, metadataLength))\n\n                // store compressed note coordinate gamma in `s + 0x80`\n\n                mstore(\n\n                    add(s, 0xa0),\n\n                    or(\n\n                        mload(0x20),\n\n                        mul(\n\n                            and(mload(0x40), 0x01),\n\n                            0x8000000000000000000000000000000000000000000000000000000000000000\n\n                        )\n\n                    )\n\n                )\n\n                // store compressed note coordinate sigma in `s + 0xa0`\n\n                mstore(\n\n                add(s, 0xc0),\n\n                or(\n\n                    mload(0x60),\n\n                    mul(\n\n                        and(mload(0x80), 0x01),\n\n                        0x8000000000000000000000000000000000000000000000000000000000000000\n\n                    )\n\n                )\n\n                )\n\n                // copy metadata into `s + 0xc0`\n\n                calldatacopy(add(s, 0xe0), add(metadataIndex, sub(metadata, 0x20)), metadataLength)\n\n                // compute the relative offset to index this note in our returndata\n\n                mstore(add(add(inputPtr, 0x40), mul(sub(i, m), 0x20)), sub(s, inputPtr)) // relative offset to note\n\n\n\n                // increase s by note length\n\n                s := add(s, add(mload(s), 0x20))\n\n            }\n\n\n\n            // cleanup. the length of the outputNotes = s - inputPtr\n\n            mstore(inputPtr, sub(sub(s, inputPtr), 0x20)) // store length of outputNotes at start of outputNotes\n\n            let notesLength := sub(s, 0x2a0)\n\n            // store length of proofOutput at 0x160. 0xa0 comes from:\n\n            // (offset to input notes, offset to output notes, publicOwner, publicValue, challenge)\n\n            mstore(0x1e0, add(0xa0, notesLength))\n\n            mstore(0x180, add(0x100, notesLength)) // store length of proofOutputs at 0x100\n\n\n\n            mstore(0x160, 0x20)\n\n            return(0x160, add(0x140, notesLength)) // return the final byte array\n\n        }\n",
          "message": "PublicRangeABIEncoder.encodeAndExit uses assembly (PublicRange.sol#49-232)\n\t- PublicRange.sol#50-231\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 306,
          "vulnerability_to_line": 631,
          "vulnerability_code": "    function() external {\n\n        assembly {\n\n\n\n            // We don't check for function signatures, there's only one function that \n\n            // ever gets called: validatePublicRange()\n\n            // We still assume calldata is offset by 4 bytes so that we can represent \n\n            // this contract through a compatible ABI\n\n            validatePublicRange()\n\n\n\n            // if we get to here, the proof is valid. We now 'fall through' the assembly block\n\n            // and into PublicRange.validatePublicRange()\n\n            // reset the free memory pointer because we're touching Solidity code again\n\n            mstore(0x40, 0x60)\n\n            /**\n\n             * New calldata map\n\n             * 0x04:0x24      = calldata location of proofData byte array \n\n             * 0x24:0x44      = message sender // sender\n\n             * 0x44:0x64      = h_x     // crs\n\n             * 0x64:0x84      = h_y     // crs\n\n             * 0x84:0xa4      = t2_x0   // crs\n\n             * 0xa4:0xc4      = t2_x1   // crs\n\n             * 0xa4:0xc4      = t2_x1   // crs\n\n             * 0xc4:0xe4      = t2_y0   // crs\n\n             * 0xe4:0x104     = t2_y1   // crs\n\n             * 0x104:0x124    = length of proofData byte array \n\n             * 0x124:0x144    = challenge\n\n             * 0x144:0x164    = publicComparison\n\n             * 0x164:0x184    = offset in byte array to notes\n\n             * 0x184:0x1a4    = offset in byte array to inputOwners\n\n             * 0x1a4:0x1c4    = offset in byte array to outputOwners\n\n             * 0x1c4:0x1e4    = offset in byte array to metadata\n\n             *\n\n             *\n\n             * Note data map (uint[6]) is\n\n             * 0x00:0x20       = Z_p element \\bar{k}_i\n\n             * 0x20:0x40       = Z_p element \\bar{a}_i\n\n             * 0x40:0x80       = G1 element \\gamma_i\n\n             * 0x80:0xc0       = G1 element \\sigma_i\n\n             *\n\n             * We use a hard-coded memory map to reduce gas costs - if this is not called as an \n\n             * external contract then terrible things will happen!\n\n             *\n\n             * 0x00:0x20       = scratch data to store result of keccak256 calls\n\n             * 0x20:0x80       = scratch data to store \\gamma_i and a multiplication scalar\n\n             * 0x80:0xc0       = x-coordinate of generator h\n\n             * 0xc0:0xe0       = y-coordinate of generator h\n\n             * 0xe0:0x100      = scratch data to store a scalar we plan to multiply h by\n\n             * 0x100:0x160     = scratch data to store \\sigma_i and a multiplication scalar\n\n             * 0x160:0x1a0     = stratch data to store result of G1 point additions\n\n             * 0x1a0:0x1c0     = scratch data to store result of \\sigma_i^{-cx_{i-m-1}}\n\n             * 0x220:0x260     = scratch data to store \\gamma_i^{cx_{i-m-1}}\n\n             * 0x2e0:0x300     = msg.sender (contract should be called via delegatecall/staticcall)\n\n             * 0x300:???       = block of memory that contains (\\gamma_i, \\sigma_i)_{i=0}^{n-1} \n\n             *                   concatenated with (B_i)_{i=0}^{n-1}\n\n             **/\n\n            function validatePublicRange() {\n\n                /*\n\n                ///////////////////////////////////////////  SETUP  //////////////////////////////////////////////\n\n                */\n\n\n\n                mstore(0x80, calldataload(0x44)) // h_x\n\n                mstore(0xa0, calldataload(0x64)) // h_y\n\n                let notes := add(0x104, calldataload(0x164)) // start position of notes\n\n                let n := 2\n\n                let m := 1\n\n                let gen_order := 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001\n\n                let challenge := mod(calldataload(0x124), gen_order)\n\n                let publicComparison := mod(calldataload(0x144), gen_order)\n\n\n\n                mstore(0x2e0, calldataload(0x24)) // store the msg.sender, to be hashed later\n\n                mstore(0x300, publicComparison) \n\n                mstore(0x320, 0) // add kPublic = 0 to the hash\n\n                mstore(0x340, 0) // add publicOwner to the hash\n\n                hashCommitments(notes, n)\n\n                let b := add(0x360, mul(n, 0x80))\n\n\n\n                /*\n\n                ///////////////////////////  CALCULATE BLINDING FACTORS  /////////////////////////////////////\n\n                */\n\n\n\n                let x := 1\n\n\n\n                // Iterate over every note and calculate the blinding factor B_i = \\gamma_i^{kBar}h^{aBar}\\sigma_i^{-c}.\n\n                for { let i := 0 } lt(i, n) { i := add(i, 0x01) } {\n\n                    // Get the calldata index of this note and associated parameters\n\n                    let noteIndex := add(add(notes, 0x20), mul(i, 0xc0))\n\n                    let k\n\n                    let a := calldataload(add(noteIndex, 0x20))\n\n                    let c := challenge\n\n\n\n                    switch gt(i, 0)\n\n                    case 1 {\n\n                        /*\n\n                        Enforce the condition k_2 = k_1 - c*publicComparison\n\n                        */\n\n                        k := addmod(\n\n                            calldataload(sub(noteIndex, 0xc0)), // k_1\n\n                            mulmod(sub(gen_order, c), publicComparison, gen_order), \n\n                            gen_order\n\n                        )\n\n                    } \n\n                        \n\n                    case 0 {\n\n                        k := calldataload(noteIndex)\n\n\n\n                    }\n\n\n\n                    // Check this commitment is well formed\n\n                    validateCommitment(noteIndex, k, a)\n\n\n\n                    x := mulmod(x, mload(0x00), gen_order) // x is the kecca hash of the input commitments\n\n\n\n                    if gt(i, 0) {\n\n                        // Set k = kx_j, a = ax_j, c = cx_j, where j = i - (m+1)\n\n                        k := mulmod(k, x, gen_order) // kx\n\n                        a := mulmod(a, x, gen_order) // ax\n\n                        c := mulmod(challenge, x, gen_order) // cx\n\n                    }\n\n\n\n                    // Calculate the G1 element \\gamma_i^{k}h^{a}\\sigma_i^{-c} = B_i\n\n                    // Memory map:\n\n                    // 0x20: \\gamma_iX\n\n                    // 0x40: \\gamma_iY\n\n                    // 0x60: k_i\n\n                    // 0x80: hX\n\n                    // 0xa0: hY\n\n                    // 0xc0: a_i\n\n                    // 0xe0: \\sigma_iX\n\n                    // 0x100: \\sigma_iY\n\n                    // 0x120: -c\n\n\n\n\n\n                    // * Note data map (uint[6]) is\n\n                    // * 0x00:0x20       = Z_p element \\bar{k}_i\n\n                    // * 0x20:0x40       = Z_p element \\bar{a}_i\n\n                    // * 0x40:0x80       = G1 element \\gamma_i\n\n                    // * 0x80:0xc0       = G1 element \\sigma_i\n\n\n\n                    // loading into memory\n\n                    calldatacopy(0xe0, add(noteIndex, 0x80), 0x40)\n\n                    calldatacopy(0x20, add(noteIndex, 0x40), 0x40)\n\n                    mstore(0x120, sub(gen_order, c)) \n\n                    mstore(0x60, k)\n\n                    mstore(0xc0, a)\n\n\n\n                    // Call bn128 scalar multiplication precompiles\n\n                    // Represent point + multiplication scalar in 3 consecutive blocks of memory\n\n                    // Store \\sigma_i^{-c} at 0x1a0:0x200\n\n                    // Store \\gamma_i^{k} at 0x120:0x160\n\n                    // Store h^{a} at 0x160:0x1a0\n\n                    let result := staticcall(gas, 7, 0xe0, 0x60, 0x1a0, 0x40) // sigmai^-c\n\n                    result := and(result, staticcall(gas, 7, 0x20, 0x60, 0x120, 0x40))\n\n                    result := and(result, staticcall(gas, 7, 0x80, 0x60, 0x160, 0x40))\n\n\n\n                    // Call bn128 group addition precompiles\n\n                    // \\gamma_i^{k} and h^{a} in memory block 0x120:0x1a0\n\n                    // Store result of addition at 0x160:0x1a0\n\n                    result := and(result, staticcall(gas, 6, 0x120, 0x80, 0x160, 0x40))\n\n\n\n                    // \\gamma_i^{k}h^{a} and \\sigma^{-c} in memory block 0x160:0x1e0\n\n                    // Store resulting point B at memory index b\n\n                    result := and(result, staticcall(gas, 6, 0x160, 0x80, b, 0x40))\n\n\n\n                    // Perform the pairing check for all notes - we do this by rolling all note coordinates into the\n\n                    // accumulator, upon which the pairing check is performed. \n\n                    // We do this adding \\sigma^{-c} and \\sigma_{acc} and storing the result at \n\n                    // \\sigma_{acc} (0x1e0:0x200). We then calculate \\gamma^{cx} and add into \\gamma_{acc}\n\n                    mstore(0x60, c)\n\n                    result := and(result, staticcall(gas, 7, 0x20, 0x60, 0x220, 0x40))\n\n\n\n                    // \\gamma_i^{cx} now at 0x220:0x260, \\gamma_{acc} is at 0x260:0x2a0\n\n                    result := and(result, staticcall(gas, 6, 0x220, 0x80, 0x260, 0x40))\n\n\n\n                    // add \\sigma_i^{-cx} and \\sigma_{acc} into \\sigma_{acc} at 0x1e0\n\n                    result := and(result, staticcall(gas, 6, 0x1a0, 0x80, 0x1e0, 0x40))\n\n\n\n                    // throw transaction if any calls to precompiled contracts failed\n\n                    if iszero(result) { mstore(0x00, 400) revert(0x00, 0x20) }\n\n                    b := add(b, 0x40) // increase B pointer by 2 words\n\n                }\n\n\n\n                    // Can assume by induction that k_1 is the output of a previous AZTEC transaction, and therefore \n\n                    // it already satisfies a range proof. Only need to perform an explicit range check on k2\n\n                    validatePairing(0x84)\n\n            \n\n                /*\n\n                ////////////////////  RECONSTRUCT INITIAL CHALLENGE AND VERIFY A MATCH  ////////////////////////////////\n\n                */\n\n\n\n                // We now have the note commitments and the calculated blinding factors in a block of memory\n\n                // starting at 0x2e0, of size (b - 0x2e0).\n\n                // Hash this block to reconstruct the initial challenge and validate that they match\n\n                let expected := mod(keccak256(0x2e0, sub(b, 0x2e0)), gen_order)\n\n\n\n                if iszero(eq(expected, challenge)) {\n\n\n\n                    // No! Bad! No soup for you!\n\n                    mstore(0x00, 404)\n\n                    revert(0x00, 0x20)\n\n                }\n\n            }\n\n\n\n            /**\n\n             * @dev check that this note's points are on the altbn128 curve(y^2 = x^3 + 3)\n\n             * and that signatures 'k' and 'a' are modulo the order of the curve. Transaction\n\n             * throws if this is not the case.\n\n             * @param note the calldata loation of the note\n\n             **/\n\n            function validateCommitment(note, k, a) {\n\n                let gen_order := 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001\n\n                let field_order := 0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47\n\n                let gammaX := calldataload(add(note, 0x40))\n\n                let gammaY := calldataload(add(note, 0x60))\n\n                let sigmaX := calldataload(add(note, 0x80))\n\n                let sigmaY := calldataload(add(note, 0xa0))\n\n                if iszero(\n\n                    and(\n\n                        and(\n\n                            and(\n\n                                eq(mod(a, gen_order), a), // a is modulo generator order?\n\n                                gt(a, 1)                  // can't be 0 or 1 either!\n\n                            ),\n\n                            and(\n\n                                eq(mod(k, gen_order), k), // k is modulo generator order?\n\n                                gt(k, 1)                  // and not 0 or 1\n\n                            )\n\n                        ),\n\n                        and(\n\n                            eq( // y^2 ?= x^3 + 3\n\n                                addmod(mulmod(\n\n                                    mulmod(sigmaX, sigmaX, field_order), sigmaX, field_order), \n\n                                    3, \n\n                                    field_order),\n\n                                mulmod(sigmaY, sigmaY, field_order)\n\n                            ),\n\n                            eq( // y^2 ?= x^3 + 3\n\n                                addmod(mulmod(\n\n                                    mulmod(gammaX, gammaX, field_order), \n\n                                    gammaX, \n\n                                    field_order), \n\n                                    3, field_order),\n\n                                mulmod(gammaY, gammaY, field_order)\n\n                            )\n\n                        )\n\n                    )\n\n                ) {\n\n                    mstore(0x00, 400)\n\n                    revert(0x00, 0x20)\n\n                }\n\n            }\n\n\n\n            /**        \n\n             * @dev evaluate if e(P1, t2) . e(P2, g2) == 0.\n\n             * @notice we don't hard-code t2 so that contracts that call this library can use different trusted setups.\n\n             **/\n\n            function validatePairing(t2) {\n\n                let field_order := 0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47\n\n                let t2_x_1 := calldataload(t2)\n\n                let t2_x_2 := calldataload(add(t2, 0x20))\n\n                let t2_y_1 := calldataload(add(t2, 0x40))\n\n                let t2_y_2 := calldataload(add(t2, 0x60))\n\n\n\n                // check provided setup pubkey is not zero or g2\n\n                if or(or(or(or(or(or(or(\n\n                    iszero(t2_x_1),\n\n                    iszero(t2_x_2)),\n\n                    iszero(t2_y_1)),\n\n                    iszero(t2_y_2)),\n\n                    eq(t2_x_1, 0x1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6ed)),\n\n                    eq(t2_x_2, 0x198e9393920d483a7260bfb731fb5d25f1aa493335a9e71297e485b7aef312c2)),\n\n                    eq(t2_y_1, 0x12c85ea5db8c6deb4aab71808dcb408fe3d1e7690c43d37b4ce6cc0166fa7daa)),\n\n                    eq(t2_y_2, 0x90689d0585ff075ec9e99ad690c3395bc4b313370b38ef355acdadcd122975b))\n\n                {\n\n                    mstore(0x00, 400)\n\n                    revert(0x00, 0x20)\n\n                }\n\n\n\n                // store coords in memory\n\n                // indices are a bit off, scipr lab's libff limb ordering (c0, c1) is opposite\n\n                // to what precompile expects. We can overwrite the memory we used previously as this function\n\n                // is called at the end of the validation routine.\n\n                mstore(0x20, mload(0x1e0)) // sigma accumulator x\n\n                mstore(0x40, mload(0x200)) // sigma accumulator y\n\n                mstore(0x80, 0x1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6ed)\n\n                mstore(0x60, 0x198e9393920d483a7260bfb731fb5d25f1aa493335a9e71297e485b7aef312c2)\n\n                mstore(0xc0, 0x12c85ea5db8c6deb4aab71808dcb408fe3d1e7690c43d37b4ce6cc0166fa7daa)\n\n                mstore(0xa0, 0x90689d0585ff075ec9e99ad690c3395bc4b313370b38ef355acdadcd122975b)\n\n                mstore(0xe0, mload(0x260)) // gamma accumulator x\n\n                mstore(0x100, mload(0x280)) // gamma accumulator y\n\n                mstore(0x140, t2_x_1)\n\n                mstore(0x120, t2_x_2)\n\n                mstore(0x180, t2_y_1)\n\n                mstore(0x160, t2_y_2)\n\n\n\n                let success := staticcall(gas, 8, 0x20, 0x180, 0x20, 0x20)\n\n\n\n                if or(iszero(success), iszero(mload(0x20))) {\n\n                    mstore(0x00, 400)\n\n                    revert(0x00, 0x20)\n\n                }\n\n            }\n\n\n\n            /**\n\n             * @dev Calculate the keccak256 hash of the commitments for both \n\n             * input notes and output notes. This is used both as an input to \n\n             * validate the challenge `c` and also to generate pseudorandom relationships\n\n             * between commitments for different outputNotes, so that we can combine \n\n             * them into a single multi-exponentiation for the purposes of validating \n\n             * the bilinear pairing relationships.\n\n             * @param notes calldata location notes\n\n             * @param n number of notes\n\n             **/\n\n            function hashCommitments(notes, n) {\n\n                for { let i := 0 } lt(i, n) { i := add(i, 0x01) } {\n\n                let index := add(add(notes, mul(i, 0xc0)), 0x60)\n\n                calldatacopy(add(0x360, mul(i, 0x80)), index, 0x80)\n\n                }\n\n                // storing at position 0x00 in memory, the kecca hash of everything from \n\n                // start of the commitments to the end\n\n                mstore(0x00, keccak256(0x360, mul(n, 0x80)))\n\n            }\n\n        }\n\n        // if we've reached here, we've validated the public range proof and haven't thrown an error.\n\n        // Encode the output according to the ACE standard and exit.\n\n        PublicRangeABIEncoder.encodeAndExit();\n",
          "message": "PublicRange.fallback uses assembly (PublicRange.sol#306-631)\n\t- PublicRange.sol#307-627\n"
        },
        {
          "name": "solc-version",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
          "message": "Detected issues with version pragma in PublicRange.sol:\n\t- pragma solidity>=0.5.0<0.6.0 (PublicRange.sol#3): it allows old versions\n\t- pragma solidity>=0.5.0<0.6.0 (PublicRange.sol#237): it allows old versions\n\t- pragma solidity>=0.5.0<0.6.0 (PublicRange.sol#269): it allows old versions\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 261,
          "vulnerability_to_line": null,
          "vulnerability_code": "        bytes calldata, \n",
          "message": "Parameter '' of PublicRangeInterface.validatePublicRange (PublicRange.sol#261) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 262,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address, \n",
          "message": "Parameter '_scope_0' of PublicRangeInterface.validatePublicRange (PublicRange.sol#262) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 263,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint[6] calldata\n",
          "message": "Parameter '_scope_1' of PublicRangeInterface.validatePublicRange (PublicRange.sol#263) is not in mixedCase\n"
        }
      ]
    },
    "smartcheck": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 237,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 237,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 269,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 269,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 49,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function encodeAndExit() internal pure {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 50,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 307,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        }
      ]
    },
    "oyente": {
      "successfull_analysis": true,
      "errors": [
        "exception (IndexError: pop from empty list)"
      ],
      "vulnerability_findings": [
        {
          "name": "Integer Overflow",
          "vulnerability_from_line": 368,
          "vulnerability_to_line": null,
          "vulnerability_code": "                let notes := add(0x104, calldataload(0x164)) // start position of notes\n",
          "message": null
        }
      ]
    },
    "mythril": {
      "successfull_analysis": false,
      "errors": [
        "Solc experienced a fatal error"
      ],
      "vulnerability_findings": []
    },
    "osiris": {
      "successfull_analysis": false,
      "errors": [
        "Solidity compilation failed"
      ],
      "vulnerability_findings": []
    }
  }
}