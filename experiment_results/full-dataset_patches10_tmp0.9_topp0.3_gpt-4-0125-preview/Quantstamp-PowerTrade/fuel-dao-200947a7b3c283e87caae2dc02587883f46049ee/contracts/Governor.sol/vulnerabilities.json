{
  "smartbugs_completed": true,
  "analyzer_results": {
    "semgrep": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 193,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < proposal.targets.length; i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 209,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < proposal.targets.length; i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 223,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < proposal.targets.length; i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 139,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor(address timelock_, address fuel_, address guardian_, uint quorumVotes_, uint proposalThreshold_, uint votingPeriodBlocks_, uint votingDelayBlocks_) public {\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 140,
          "vulnerability_to_line": null,
          "vulnerability_code": "        timelock = TimelockInterface(timelock_);\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 141,
          "vulnerability_to_line": null,
          "vulnerability_code": "        fuel = FuelTokenInterface(fuel_);\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 142,
          "vulnerability_to_line": null,
          "vulnerability_code": "        guardian = guardian_;\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 143,
          "vulnerability_to_line": null,
          "vulnerability_code": "        quorumVotes = quorumVotes_;\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 144,
          "vulnerability_to_line": null,
          "vulnerability_code": "        proposalThreshold = proposalThreshold_;\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 145,
          "vulnerability_to_line": null,
          "vulnerability_code": "        votingPeriod = votingPeriodBlocks_;\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 146,
          "vulnerability_to_line": null,
          "vulnerability_code": "        votingDelay = votingDelayBlocks_;\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 147,
          "vulnerability_to_line": null,
          "vulnerability_code": "    }\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 210,
          "vulnerability_to_line": null,
          "vulnerability_code": "            timelock.executeTransaction.value(proposal.values[i])(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], proposal.eta);\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 224,
          "vulnerability_to_line": null,
          "vulnerability_code": "            timelock.cancelTransaction(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], proposal.eta);\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 193,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < proposal.targets.length; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 209,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < proposal.targets.length; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 223,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < proposal.targets.length; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 150,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(fuel.getPriorVotes(msg.sender, sub256(block.number, 1)) > proposalThreshold, \"Governor::propose: proposer votes below proposal threshold\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 151,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(targets.length == values.length && targets.length == signatures.length && targets.length == calldatas.length, \"Governor::propose: proposal function information arity mismatch\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 152,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(targets.length != 0, \"Governor::propose: must provide actions\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 153,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(targets.length <= proposalMaxOperations, \"Governor::propose: too many actions\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 158,
          "vulnerability_to_line": null,
          "vulnerability_code": "          require(proposersLatestProposalState != ProposalState.Active, \"Governor::propose: one live proposal per proposer, found an already active proposal\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 159,
          "vulnerability_to_line": null,
          "vulnerability_code": "          require(proposersLatestProposalState != ProposalState.Pending, \"Governor::propose: one live proposal per proposer, found an already pending proposal\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 190,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(state(proposalId) == ProposalState.Succeeded, \"Governor::queue: proposal can only be queued if it is succeeded\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 201,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(!timelock.queuedTransactions(keccak256(abi.encode(target, value, signature, data, eta))), \"Governor::_queueOrRevert: proposal action already queued at eta\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 206,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(state(proposalId) == ProposalState.Queued, \"Governor::execute: proposal can only be executed if it is queued\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 217,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(state != ProposalState.Executed, \"Governor::cancel: cannot cancel executed proposal\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 220,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == guardian || fuel.getPriorVotes(proposal.proposer, sub256(block.number, 1)) < proposalThreshold, \"Governor::cancel: proposer above threshold\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 240,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(proposalCount >= proposalId && proposalId > 0, \"Governor::state: invalid proposal id\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 270,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(signatory != address(0), \"Governor::castVoteBySig: invalid signature\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 275,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(state(proposalId) == ProposalState.Active, \"Governor::_castVote: voting is closed\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 278,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(receipt.hasVoted == false, \"Governor::_castVote: voter already voted\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 295,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == guardian, \"Governor::__acceptAdmin: sender must be gov guardian\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 300,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == guardian, \"Governor::__abdicate: sender must be gov guardian\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 305,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == guardian, \"Governor::__moveGuardianship: sender must be gov guardian\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 306,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_guardian != address(0), \"Governor::__moveGuardianship: new guardian cannot be address zero\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 312,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(c >= a, \"addition overflow\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 317,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(b <= a, \"subtraction underflow\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 151,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(targets.length == values.length && targets.length == signatures.length && targets.length == calldatas.length, \"Governor::propose: proposal function information arity mismatch\");\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 240,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(proposalCount >= proposalId && proposalId > 0, \"Governor::state: invalid proposal id\");\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 165,
          "vulnerability_to_line": null,
          "vulnerability_code": "        proposalCount++;\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 193,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < proposal.targets.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 209,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < proposal.targets.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 223,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < proposal.targets.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 150,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(fuel.getPriorVotes(msg.sender, sub256(block.number, 1)) > proposalThreshold, \"Governor::propose: proposer votes below proposal threshold\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 151,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(targets.length == values.length && targets.length == signatures.length && targets.length == calldatas.length, \"Governor::propose: proposal function information arity mismatch\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 152,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(targets.length != 0, \"Governor::propose: must provide actions\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 153,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(targets.length <= proposalMaxOperations, \"Governor::propose: too many actions\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 158,
          "vulnerability_to_line": null,
          "vulnerability_code": "          require(proposersLatestProposalState != ProposalState.Active, \"Governor::propose: one live proposal per proposer, found an already active proposal\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 159,
          "vulnerability_to_line": null,
          "vulnerability_code": "          require(proposersLatestProposalState != ProposalState.Pending, \"Governor::propose: one live proposal per proposer, found an already pending proposal\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 190,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(state(proposalId) == ProposalState.Succeeded, \"Governor::queue: proposal can only be queued if it is succeeded\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 201,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(!timelock.queuedTransactions(keccak256(abi.encode(target, value, signature, data, eta))), \"Governor::_queueOrRevert: proposal action already queued at eta\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 206,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(state(proposalId) == ProposalState.Queued, \"Governor::execute: proposal can only be executed if it is queued\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 217,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(state != ProposalState.Executed, \"Governor::cancel: cannot cancel executed proposal\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 220,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == guardian || fuel.getPriorVotes(proposal.proposer, sub256(block.number, 1)) < proposalThreshold, \"Governor::cancel: proposer above threshold\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 240,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(proposalCount >= proposalId && proposalId > 0, \"Governor::state: invalid proposal id\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 270,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(signatory != address(0), \"Governor::castVoteBySig: invalid signature\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 275,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(state(proposalId) == ProposalState.Active, \"Governor::_castVote: voting is closed\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 278,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(receipt.hasVoted == false, \"Governor::_castVote: voter already voted\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 295,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == guardian, \"Governor::__acceptAdmin: sender must be gov guardian\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 300,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == guardian, \"Governor::__abdicate: sender must be gov guardian\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 305,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == guardian, \"Governor::__moveGuardianship: sender must be gov guardian\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 306,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_guardian != address(0), \"Governor::__moveGuardianship: new guardian cannot be address zero\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        }
      ]
    },
    "slither": {
      "successfull_analysis": true,
      "errors": [
        "EXIT_CODE_36"
      ],
      "vulnerability_findings": [
        {
          "name": "arbitrary-send",
          "vulnerability_from_line": 205,
          "vulnerability_to_line": 213,
          "vulnerability_code": "    function execute(uint proposalId) public payable {\n\n        require(state(proposalId) == ProposalState.Queued, \"Governor::execute: proposal can only be executed if it is queued\");\n\n        Proposal storage proposal = proposals[proposalId];\n\n        proposal.executed = true;\n\n        for (uint i = 0; i < proposal.targets.length; i++) {\n\n            timelock.executeTransaction.value(proposal.values[i])(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], proposal.eta);\n\n        }\n\n        emit ProposalExecuted(proposalId);\n",
          "message": "Governor.execute (Governor.sol#205-213) sends eth to arbitrary user\n\tDangerous calls:\n\t- timelock.executeTransaction.value(proposal.values[i])(proposal.targets[i],proposal.values[i],proposal.signatures[i],proposal.calldatas[i],proposal.eta) (Governor.sol#210)\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 321,
          "vulnerability_to_line": 325,
          "vulnerability_code": "    function getChainId() internal pure returns (uint) {\n\n        uint chainId;\n\n        assembly { chainId := chainid() }\n\n        return chainId;\n",
          "message": "Governor.getChainId (Governor.sol#321-325) is declared view but contains assembly code\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 274,
          "vulnerability_to_line": 292,
          "vulnerability_code": "    function _castVote(address voter, uint proposalId, bool support) internal {\n\n        require(state(proposalId) == ProposalState.Active, \"Governor::_castVote: voting is closed\");\n\n        Proposal storage proposal = proposals[proposalId];\n\n        Receipt storage receipt = proposal.receipts[voter];\n\n        require(receipt.hasVoted == false, \"Governor::_castVote: voter already voted\");\n\n        uint96 votes = fuel.getPriorVotes(voter, proposal.startBlock);\n\n\n\n        if (support) {\n\n            proposal.forVotes = add256(proposal.forVotes, votes);\n\n        } else {\n\n            proposal.againstVotes = add256(proposal.againstVotes, votes);\n\n        }\n\n\n\n        receipt.hasVoted = true;\n\n        receipt.support = support;\n\n        receipt.votes = votes;\n\n\n\n        emit VoteCast(voter, proposalId, support, votes);\n",
          "message": "Reentrancy in Governor._castVote (Governor.sol#274-292):\n\tExternal calls:\n\t- require(bool,string)(state(proposalId) == ProposalState.Active,Governor::_castVote: voting is closed) (Governor.sol#275)\n\t- votes = fuel.getPriorVotes(voter,proposal.startBlock) (Governor.sol#279)\n\tState variables written after the call(s):\n\t- proposals (Governor.sol#282)\n\t- proposals (Governor.sol#284)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 215,
          "vulnerability_to_line": 228,
          "vulnerability_code": "    function cancel(uint proposalId) public {\n\n        ProposalState state = state(proposalId);\n\n        require(state != ProposalState.Executed, \"Governor::cancel: cannot cancel executed proposal\");\n\n\n\n        Proposal storage proposal = proposals[proposalId];\n\n        require(msg.sender == guardian || fuel.getPriorVotes(proposal.proposer, sub256(block.number, 1)) < proposalThreshold, \"Governor::cancel: proposer above threshold\");\n\n\n\n        proposal.canceled = true;\n\n        for (uint i = 0; i < proposal.targets.length; i++) {\n\n            timelock.cancelTransaction(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], proposal.eta);\n\n        }\n\n\n\n        emit ProposalCanceled(proposalId);\n",
          "message": "Reentrancy in Governor.cancel (Governor.sol#215-228):\n\tExternal calls:\n\t- state = state(proposalId) (Governor.sol#216)\n\t- require(bool,string)(msg.sender == guardian || fuel.getPriorVotes(proposal.proposer,sub256(block.number,1)) < proposalThreshold,Governor::cancel: proposer above threshold) (Governor.sol#220)\n\tState variables written after the call(s):\n\t- proposals (Governor.sol#222)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 205,
          "vulnerability_to_line": 213,
          "vulnerability_code": "    function execute(uint proposalId) public payable {\n\n        require(state(proposalId) == ProposalState.Queued, \"Governor::execute: proposal can only be executed if it is queued\");\n\n        Proposal storage proposal = proposals[proposalId];\n\n        proposal.executed = true;\n\n        for (uint i = 0; i < proposal.targets.length; i++) {\n\n            timelock.executeTransaction.value(proposal.values[i])(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], proposal.eta);\n\n        }\n\n        emit ProposalExecuted(proposalId);\n",
          "message": "Reentrancy in Governor.execute (Governor.sol#205-213):\n\tExternal calls:\n\t- require(bool,string)(state(proposalId) == ProposalState.Queued,Governor::execute: proposal can only be executed if it is queued) (Governor.sol#206)\n\tState variables written after the call(s):\n\t- proposals (Governor.sol#208)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 149,
          "vulnerability_to_line": 187,
          "vulnerability_code": "    function propose(address[] memory targets, uint[] memory values, string[] memory signatures, bytes[] memory calldatas, string memory description) public returns (uint) {\n\n        require(fuel.getPriorVotes(msg.sender, sub256(block.number, 1)) > proposalThreshold, \"Governor::propose: proposer votes below proposal threshold\");\n\n        require(targets.length == values.length && targets.length == signatures.length && targets.length == calldatas.length, \"Governor::propose: proposal function information arity mismatch\");\n\n        require(targets.length != 0, \"Governor::propose: must provide actions\");\n\n        require(targets.length <= proposalMaxOperations, \"Governor::propose: too many actions\");\n\n\n\n        uint latestProposalId = latestProposalIds[msg.sender];\n\n        if (latestProposalId != 0) {\n\n          ProposalState proposersLatestProposalState = state(latestProposalId);\n\n          require(proposersLatestProposalState != ProposalState.Active, \"Governor::propose: one live proposal per proposer, found an already active proposal\");\n\n          require(proposersLatestProposalState != ProposalState.Pending, \"Governor::propose: one live proposal per proposer, found an already pending proposal\");\n\n        }\n\n\n\n        uint startBlock = add256(block.number, votingDelay);\n\n        uint endBlock = add256(startBlock, votingPeriod);\n\n\n\n        proposalCount++;\n\n        Proposal memory newProposal = Proposal({\n\n            id: proposalCount,\n\n            proposer: msg.sender,\n\n            eta: 0,\n\n            targets: targets,\n\n            values: values,\n\n            signatures: signatures,\n\n            calldatas: calldatas,\n\n            startBlock: startBlock,\n\n            endBlock: endBlock,\n\n            forVotes: 0,\n\n            againstVotes: 0,\n\n            canceled: false,\n\n            executed: false\n\n        });\n\n\n\n        proposals[newProposal.id] = newProposal;\n\n        latestProposalIds[newProposal.proposer] = newProposal.id;\n\n\n\n        emit ProposalCreated(newProposal.id, msg.sender, targets, values, signatures, calldatas, startBlock, endBlock, description);\n\n        return newProposal.id;\n",
          "message": "Reentrancy in Governor.propose (Governor.sol#149-187):\n\tExternal calls:\n\t- require(bool,string)(fuel.getPriorVotes(msg.sender,sub256(block.number,1)) > proposalThreshold,Governor::propose: proposer votes below proposal threshold) (Governor.sol#150)\n\t- proposersLatestProposalState = state(latestProposalId) (Governor.sol#157)\n\tState variables written after the call(s):\n\t- latestProposalIds (Governor.sol#183)\n\t- proposalCount (Governor.sol#165)\n\t- proposals (Governor.sol#182)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 189,
          "vulnerability_to_line": 198,
          "vulnerability_code": "    function queue(uint proposalId) public {\n\n        require(state(proposalId) == ProposalState.Succeeded, \"Governor::queue: proposal can only be queued if it is succeeded\");\n\n        Proposal storage proposal = proposals[proposalId];\n\n        uint eta = add256(block.timestamp, timelock.delay());\n\n        for (uint i = 0; i < proposal.targets.length; i++) {\n\n            _queueOrRevert(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], eta);\n\n        }\n\n        proposal.eta = eta;\n\n        emit ProposalQueued(proposalId, eta);\n",
          "message": "Reentrancy in Governor.queue (Governor.sol#189-198):\n\tExternal calls:\n\t- require(bool,string)(state(proposalId) == ProposalState.Succeeded,Governor::queue: proposal can only be queued if it is succeeded) (Governor.sol#190)\n\t- eta = add256(block.timestamp,timelock.delay()) (Governor.sol#192)\n\tState variables written after the call(s):\n\t- proposals (Governor.sol#196)\n"
        },
        {
          "name": "unused-return",
          "vulnerability_from_line": 200,
          "vulnerability_to_line": 203,
          "vulnerability_code": "    function _queueOrRevert(address target, uint value, string memory signature, bytes memory data, uint eta) internal {\n\n        require(!timelock.queuedTransactions(keccak256(abi.encode(target, value, signature, data, eta))), \"Governor::_queueOrRevert: proposal action already queued at eta\");\n\n        timelock.queueTransaction(target, value, signature, data, eta);\n",
          "message": "Governor._queueOrRevert (Governor.sol#200-203) does not use the value returned by external calls:\n\t-timelock.queueTransaction(target,value,signature,data,eta) (Governor.sol#202)\n"
        },
        {
          "name": "unused-return",
          "vulnerability_from_line": 205,
          "vulnerability_to_line": 213,
          "vulnerability_code": "    function execute(uint proposalId) public payable {\n\n        require(state(proposalId) == ProposalState.Queued, \"Governor::execute: proposal can only be executed if it is queued\");\n\n        Proposal storage proposal = proposals[proposalId];\n\n        proposal.executed = true;\n\n        for (uint i = 0; i < proposal.targets.length; i++) {\n\n            timelock.executeTransaction.value(proposal.values[i])(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], proposal.eta);\n\n        }\n\n        emit ProposalExecuted(proposalId);\n",
          "message": "Governor.execute (Governor.sol#205-213) does not use the value returned by external calls:\n\t-timelock.executeTransaction.value(proposal.values[i])(proposal.targets[i],proposal.values[i],proposal.signatures[i],proposal.calldatas[i],proposal.eta) (Governor.sol#210)\n"
        },
        {
          "name": "shadowing-local",
          "vulnerability_from_line": 216,
          "vulnerability_to_line": null,
          "vulnerability_code": "        ProposalState state = state(proposalId);\n",
          "message": "Governor.cancel.state (local variable @ Governor.sol#216) shadows:\n\t- Governor.state (function @ Governor.sol#239-259)\n"
        },
        {
          "name": "calls-loop",
          "vulnerability_from_line": 210,
          "vulnerability_to_line": null,
          "vulnerability_code": "            timelock.executeTransaction.value(proposal.values[i])(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], proposal.eta);\n",
          "message": "Governor.execute has external calls inside a loop:\n\t- timelock.executeTransaction.value(proposal.values[i])(proposal.targets[i],proposal.values[i],proposal.signatures[i],proposal.calldatas[i],proposal.eta) (Governor.sol#210)\n"
        },
        {
          "name": "calls-loop",
          "vulnerability_from_line": 224,
          "vulnerability_to_line": null,
          "vulnerability_code": "            timelock.cancelTransaction(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], proposal.eta);\n",
          "message": "Governor.cancel has external calls inside a loop:\n\t- timelock.cancelTransaction(proposal.targets[i],proposal.values[i],proposal.signatures[i],proposal.calldatas[i],proposal.eta) (Governor.sol#224)\n"
        },
        {
          "name": "timestamp",
          "vulnerability_from_line": 200,
          "vulnerability_to_line": 203,
          "vulnerability_code": "    function _queueOrRevert(address target, uint value, string memory signature, bytes memory data, uint eta) internal {\n\n        require(!timelock.queuedTransactions(keccak256(abi.encode(target, value, signature, data, eta))), \"Governor::_queueOrRevert: proposal action already queued at eta\");\n\n        timelock.queueTransaction(target, value, signature, data, eta);\n",
          "message": "Governor._queueOrRevert (Governor.sol#200-203) uses timestamp for comparisons\n\tDangerous comparisons:\n\t- require(bool,string)(! timelock.queuedTransactions(keccak256(bytes)(abi.encode(target,value,signature,data,eta))),Governor::_queueOrRevert: proposal action already queued at eta) (Governor.sol#201)\n"
        },
        {
          "name": "timestamp",
          "vulnerability_from_line": 239,
          "vulnerability_to_line": 259,
          "vulnerability_code": "    function state(uint proposalId) public view returns (ProposalState) {\n\n        require(proposalCount >= proposalId && proposalId > 0, \"Governor::state: invalid proposal id\");\n\n        Proposal storage proposal = proposals[proposalId];\n\n        if (proposal.canceled) {\n\n            return ProposalState.Canceled;\n\n        } else if (block.number <= proposal.startBlock) {\n\n            return ProposalState.Pending;\n\n        } else if (block.number <= proposal.endBlock) {\n\n            return ProposalState.Active;\n\n        } else if (proposal.forVotes <= proposal.againstVotes || proposal.forVotes < quorumVotes) {\n\n            return ProposalState.Defeated;\n\n        } else if (proposal.eta == 0) {\n\n            return ProposalState.Succeeded;\n\n        } else if (proposal.executed) {\n\n            return ProposalState.Executed;\n\n        } else if (block.timestamp >= add256(proposal.eta, timelock.gracePeriod())) {\n\n            return ProposalState.Expired;\n\n        } else {\n\n            return ProposalState.Queued;\n\n        }\n",
          "message": "Governor.state (Governor.sol#239-259) uses timestamp for comparisons\n\tDangerous comparisons:\n\t- block.timestamp >= add256(proposal.eta,timelock.gracePeriod()) (Governor.sol#254-258)\n"
        },
        {
          "name": "timestamp",
          "vulnerability_from_line": 310,
          "vulnerability_to_line": 314,
          "vulnerability_code": "    function add256(uint256 a, uint256 b) internal pure returns (uint) {\n\n        uint c = a + b;\n\n        require(c >= a, \"addition overflow\");\n\n        return c;\n",
          "message": "Governor.add256 (Governor.sol#310-314) uses timestamp for comparisons\n\tDangerous comparisons:\n\t- require(bool,string)(c >= a,addition overflow) (Governor.sol#312)\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 321,
          "vulnerability_to_line": 325,
          "vulnerability_code": "    function getChainId() internal pure returns (uint) {\n\n        uint chainId;\n\n        assembly { chainId := chainid() }\n\n        return chainId;\n",
          "message": "Governor.getChainId uses assembly (Governor.sol#321-325)\n\t- Governor.sol#323\n"
        },
        {
          "name": "constable-states",
          "vulnerability_from_line": 24,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint public proposalMaxOperations = 20;\n",
          "message": "Governor.proposalMaxOperations should be constant (Governor.sol#24)\n"
        },
        {
          "name": "pragma",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": "Different versions of Solidity is used in Governor.sol:\n\t- Version used: ['ABIEncoderV2', '^0.5.16']\n\t- Governor.sol#3 declares pragma solidity^0.5.16\n\t- Governor.sol#4 declares pragma experimentalABIEncoderV2\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 149,
          "vulnerability_to_line": 187,
          "vulnerability_code": "    function propose(address[] memory targets, uint[] memory values, string[] memory signatures, bytes[] memory calldatas, string memory description) public returns (uint) {\n\n        require(fuel.getPriorVotes(msg.sender, sub256(block.number, 1)) > proposalThreshold, \"Governor::propose: proposer votes below proposal threshold\");\n\n        require(targets.length == values.length && targets.length == signatures.length && targets.length == calldatas.length, \"Governor::propose: proposal function information arity mismatch\");\n\n        require(targets.length != 0, \"Governor::propose: must provide actions\");\n\n        require(targets.length <= proposalMaxOperations, \"Governor::propose: too many actions\");\n\n\n\n        uint latestProposalId = latestProposalIds[msg.sender];\n\n        if (latestProposalId != 0) {\n\n          ProposalState proposersLatestProposalState = state(latestProposalId);\n\n          require(proposersLatestProposalState != ProposalState.Active, \"Governor::propose: one live proposal per proposer, found an already active proposal\");\n\n          require(proposersLatestProposalState != ProposalState.Pending, \"Governor::propose: one live proposal per proposer, found an already pending proposal\");\n\n        }\n\n\n\n        uint startBlock = add256(block.number, votingDelay);\n\n        uint endBlock = add256(startBlock, votingPeriod);\n\n\n\n        proposalCount++;\n\n        Proposal memory newProposal = Proposal({\n\n            id: proposalCount,\n\n            proposer: msg.sender,\n\n            eta: 0,\n\n            targets: targets,\n\n            values: values,\n\n            signatures: signatures,\n\n            calldatas: calldatas,\n\n            startBlock: startBlock,\n\n            endBlock: endBlock,\n\n            forVotes: 0,\n\n            againstVotes: 0,\n\n            canceled: false,\n\n            executed: false\n\n        });\n\n\n\n        proposals[newProposal.id] = newProposal;\n\n        latestProposalIds[newProposal.proposer] = newProposal.id;\n\n\n\n        emit ProposalCreated(newProposal.id, msg.sender, targets, values, signatures, calldatas, startBlock, endBlock, description);\n\n        return newProposal.id;\n",
          "message": "Governor.propose (Governor.sol#149-187) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 189,
          "vulnerability_to_line": 198,
          "vulnerability_code": "    function queue(uint proposalId) public {\n\n        require(state(proposalId) == ProposalState.Succeeded, \"Governor::queue: proposal can only be queued if it is succeeded\");\n\n        Proposal storage proposal = proposals[proposalId];\n\n        uint eta = add256(block.timestamp, timelock.delay());\n\n        for (uint i = 0; i < proposal.targets.length; i++) {\n\n            _queueOrRevert(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], eta);\n\n        }\n\n        proposal.eta = eta;\n\n        emit ProposalQueued(proposalId, eta);\n",
          "message": "Governor.queue (Governor.sol#189-198) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 205,
          "vulnerability_to_line": 213,
          "vulnerability_code": "    function execute(uint proposalId) public payable {\n\n        require(state(proposalId) == ProposalState.Queued, \"Governor::execute: proposal can only be executed if it is queued\");\n\n        Proposal storage proposal = proposals[proposalId];\n\n        proposal.executed = true;\n\n        for (uint i = 0; i < proposal.targets.length; i++) {\n\n            timelock.executeTransaction.value(proposal.values[i])(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], proposal.eta);\n\n        }\n\n        emit ProposalExecuted(proposalId);\n",
          "message": "Governor.execute (Governor.sol#205-213) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 215,
          "vulnerability_to_line": 228,
          "vulnerability_code": "    function cancel(uint proposalId) public {\n\n        ProposalState state = state(proposalId);\n\n        require(state != ProposalState.Executed, \"Governor::cancel: cannot cancel executed proposal\");\n\n\n\n        Proposal storage proposal = proposals[proposalId];\n\n        require(msg.sender == guardian || fuel.getPriorVotes(proposal.proposer, sub256(block.number, 1)) < proposalThreshold, \"Governor::cancel: proposer above threshold\");\n\n\n\n        proposal.canceled = true;\n\n        for (uint i = 0; i < proposal.targets.length; i++) {\n\n            timelock.cancelTransaction(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], proposal.eta);\n\n        }\n\n\n\n        emit ProposalCanceled(proposalId);\n",
          "message": "Governor.cancel (Governor.sol#215-228) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 230,
          "vulnerability_to_line": 233,
          "vulnerability_code": "    function getActions(uint proposalId) public view returns (address[] memory targets, uint[] memory values, string[] memory signatures, bytes[] memory calldatas) {\n\n        Proposal storage p = proposals[proposalId];\n\n        return (p.targets, p.values, p.signatures, p.calldatas);\n",
          "message": "Governor.getActions (Governor.sol#230-233) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 235,
          "vulnerability_to_line": 237,
          "vulnerability_code": "    function getReceipt(uint proposalId, address voter) public view returns (Receipt memory) {\n\n        return proposals[proposalId].receipts[voter];\n",
          "message": "Governor.getReceipt (Governor.sol#235-237) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 261,
          "vulnerability_to_line": 263,
          "vulnerability_code": "    function castVote(uint proposalId, bool support) public {\n\n        return _castVote(msg.sender, proposalId, support);\n",
          "message": "Governor.castVote (Governor.sol#261-263) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 265,
          "vulnerability_to_line": 272,
          "vulnerability_code": "    function castVoteBySig(uint proposalId, bool support, uint8 v, bytes32 r, bytes32 s) public {\n\n        bytes32 domainSeparator = keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), getChainId(), address(this)));\n\n        bytes32 structHash = keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support));\n\n        bytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n\n        address signatory = ecrecover(digest, v, r, s);\n\n        require(signatory != address(0), \"Governor::castVoteBySig: invalid signature\");\n\n        return _castVote(signatory, proposalId, support);\n",
          "message": "Governor.castVoteBySig (Governor.sol#265-272) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 294,
          "vulnerability_to_line": 297,
          "vulnerability_code": "    function __acceptAdmin() public {\n\n        require(msg.sender == guardian, \"Governor::__acceptAdmin: sender must be gov guardian\");\n\n        timelock.acceptAdmin();\n",
          "message": "Governor.__acceptAdmin (Governor.sol#294-297) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 299,
          "vulnerability_to_line": 302,
          "vulnerability_code": "    function __abdicate() public {\n\n        require(msg.sender == guardian, \"Governor::__abdicate: sender must be gov guardian\");\n\n        guardian = address(0);\n",
          "message": "Governor.__abdicate (Governor.sol#299-302) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 304,
          "vulnerability_to_line": 308,
          "vulnerability_code": "    function __moveGuardianship(address _guardian) public {\n\n        require(msg.sender == guardian, \"Governor::__moveGuardianship: sender must be gov guardian\");\n\n        require(_guardian != address(0), \"Governor::__moveGuardianship: new guardian cannot be address zero\");\n\n        guardian = _guardian;\n",
          "message": "Governor.__moveGuardianship (Governor.sol#304-308) should be declared external\n"
        },
        {
          "name": "solc-version",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": "Detected issues with version pragma in Governor.sol:\n\t- pragma solidity^0.5.16 (Governor.sol#3): it allows old versions\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 200,
          "vulnerability_to_line": 203,
          "vulnerability_code": "    function _queueOrRevert(address target, uint value, string memory signature, bytes memory data, uint eta) internal {\n\n        require(!timelock.queuedTransactions(keccak256(abi.encode(target, value, signature, data, eta))), \"Governor::_queueOrRevert: proposal action already queued at eta\");\n\n        timelock.queueTransaction(target, value, signature, data, eta);\n",
          "message": "Function 'Governor._queueOrRevert' (Governor.sol#200-203) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 274,
          "vulnerability_to_line": 292,
          "vulnerability_code": "    function _castVote(address voter, uint proposalId, bool support) internal {\n\n        require(state(proposalId) == ProposalState.Active, \"Governor::_castVote: voting is closed\");\n\n        Proposal storage proposal = proposals[proposalId];\n\n        Receipt storage receipt = proposal.receipts[voter];\n\n        require(receipt.hasVoted == false, \"Governor::_castVote: voter already voted\");\n\n        uint96 votes = fuel.getPriorVotes(voter, proposal.startBlock);\n\n\n\n        if (support) {\n\n            proposal.forVotes = add256(proposal.forVotes, votes);\n\n        } else {\n\n            proposal.againstVotes = add256(proposal.againstVotes, votes);\n\n        }\n\n\n\n        receipt.hasVoted = true;\n\n        receipt.support = support;\n\n        receipt.votes = votes;\n\n\n\n        emit VoteCast(voter, proposalId, support, votes);\n",
          "message": "Function 'Governor._castVote' (Governor.sol#274-292) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 294,
          "vulnerability_to_line": 297,
          "vulnerability_code": "    function __acceptAdmin() public {\n\n        require(msg.sender == guardian, \"Governor::__acceptAdmin: sender must be gov guardian\");\n\n        timelock.acceptAdmin();\n",
          "message": "Function 'Governor.__acceptAdmin' (Governor.sol#294-297) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 299,
          "vulnerability_to_line": 302,
          "vulnerability_code": "    function __abdicate() public {\n\n        require(msg.sender == guardian, \"Governor::__abdicate: sender must be gov guardian\");\n\n        guardian = address(0);\n",
          "message": "Function 'Governor.__abdicate' (Governor.sol#299-302) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 304,
          "vulnerability_to_line": 308,
          "vulnerability_code": "    function __moveGuardianship(address _guardian) public {\n\n        require(msg.sender == guardian, \"Governor::__moveGuardianship: sender must be gov guardian\");\n\n        require(_guardian != address(0), \"Governor::__moveGuardianship: new guardian cannot be address zero\");\n\n        guardian = _guardian;\n",
          "message": "Function 'Governor.__moveGuardianship' (Governor.sol#304-308) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 304,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function __moveGuardianship(address _guardian) public {\n",
          "message": "Parameter '_guardian' of Governor.__moveGuardianship (Governor.sol#304) is not in mixedCase\n"
        }
      ]
    },
    "smartcheck": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 301,
          "vulnerability_to_line": null,
          "vulnerability_code": "        guardian = address(0);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 193,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < proposal.targets.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 209,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < proposal.targets.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 223,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < proposal.targets.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 193,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < proposal.targets.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 209,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < proposal.targets.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 223,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < proposal.targets.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 321,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getChainId() internal pure returns (uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 230,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getActions(uint proposalId) public view returns (address[] memory targets, uint[] memory values, string[] memory signatures, bytes[] memory calldatas) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 323,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly { chainId := chainid() }\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 333,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function queueTransaction(address target, uint value, string calldata signature, bytes calldata data, uint eta) external returns (bytes32);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 334,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function cancelTransaction(address target, uint value, string calldata signature, bytes calldata data, uint eta) external;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 335,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function executeTransaction(address target, uint value, string calldata signature, bytes calldata data, uint eta) external payable returns (bytes memory);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 333,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function queueTransaction(address target, uint value, string calldata signature, bytes calldata data, uint eta) external returns (bytes32);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 333,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function queueTransaction(address target, uint value, string calldata signature, bytes calldata data, uint eta) external returns (bytes32);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 333,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function queueTransaction(address target, uint value, string calldata signature, bytes calldata data, uint eta) external returns (bytes32);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 333,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function queueTransaction(address target, uint value, string calldata signature, bytes calldata data, uint eta) external returns (bytes32);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 333,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function queueTransaction(address target, uint value, string calldata signature, bytes calldata data, uint eta) external returns (bytes32);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 334,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function cancelTransaction(address target, uint value, string calldata signature, bytes calldata data, uint eta) external;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 334,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function cancelTransaction(address target, uint value, string calldata signature, bytes calldata data, uint eta) external;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 334,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function cancelTransaction(address target, uint value, string calldata signature, bytes calldata data, uint eta) external;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 334,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function cancelTransaction(address target, uint value, string calldata signature, bytes calldata data, uint eta) external;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 335,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function executeTransaction(address target, uint value, string calldata signature, bytes calldata data, uint eta) external payable returns (bytes memory);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 335,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function executeTransaction(address target, uint value, string calldata signature, bytes calldata data, uint eta) external payable returns (bytes memory);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 335,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function executeTransaction(address target, uint value, string calldata signature, bytes calldata data, uint eta) external payable returns (bytes memory);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 335,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function executeTransaction(address target, uint value, string calldata signature, bytes calldata data, uint eta) external payable returns (bytes memory);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 335,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function executeTransaction(address target, uint value, string calldata signature, bytes calldata data, uint eta) external payable returns (bytes memory);\n",
          "message": null
        }
      ]
    },
    "oyente": {
      "successfull_analysis": false,
      "errors": [
        "exception (RuntimeError: Source map error, unknown name(SHR) or instr_name(INVALID))"
      ],
      "vulnerability_findings": []
    },
    "mythril": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": []
    },
    "osiris": {
      "successfull_analysis": false,
      "errors": [
        "Solidity compilation failed"
      ],
      "vulnerability_findings": []
    }
  }
}