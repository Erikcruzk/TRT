{
  "smartbugs_completed": true,
  "analyzer_results": {
    "semgrep": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 162,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < purposes.length; i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 164,
          "vulnerability_to_line": null,
          "vulnerability_code": "                purposes[i] = purposes[purposes.length - 1];\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 165,
          "vulnerability_to_line": null,
          "vulnerability_code": "                delete purposes[purposes.length - 1];\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 166,
          "vulnerability_to_line": null,
          "vulnerability_code": "                purposes.length--;\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 178,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint j = 0; j < keys.length; j++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 180,
          "vulnerability_to_line": null,
          "vulnerability_code": "                keys[j] = keys[keys.length - 1];\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 181,
          "vulnerability_to_line": null,
          "vulnerability_code": "                delete keys[keys.length - 1];\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 182,
          "vulnerability_to_line": null,
          "vulnerability_code": "                keys.length--;\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 201,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < purposes.length; i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 162,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < purposes.length; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 178,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint j = 0; j < keys.length; j++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 201,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < purposes.length; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 78,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_keyHolderData.keys[_key].key != _key, \"Key already exists\"); // Key should not already exist\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 80,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 1), \"Sender does not have management key\"); // Sender has MANAGEMENT_KEY\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 98,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 2), \"Sender does not have action key\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 99,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(!_keyHolderData.executions[_id].executed, \"Already executed\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 134,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(!_keyHolderData.executions[_keyHolderData.executionNonce].executed, \"Already executed\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 154,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 1), \"Sender does not have management key\"); // Sender has MANAGEMENT_KEY\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 157,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_keyHolderData.keys[_key].key == _key, \"No such key\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-prefix-decrement-not-postfix",
          "vulnerability_from_line": 166,
          "vulnerability_to_line": null,
          "vulnerability_code": "                purposes.length--;\n",
          "message": "Consider using the prefix decrement expression whenever the return value is not needed. The prefix decrement expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-decrement-not-postfix",
          "vulnerability_from_line": 182,
          "vulnerability_to_line": null,
          "vulnerability_code": "                keys.length--;\n",
          "message": "Consider using the prefix decrement expression whenever the return value is not needed. The prefix decrement expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 145,
          "vulnerability_to_line": null,
          "vulnerability_code": "        _keyHolderData.executionNonce++;\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 162,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < purposes.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 178,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint j = 0; j < keys.length; j++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 201,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < purposes.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 80,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 1), \"Sender does not have management key\"); // Sender has MANAGEMENT_KEY\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 154,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 1), \"Sender does not have management key\"); // Sender has MANAGEMENT_KEY\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        }
      ]
    },
    "slither": {
      "successfull_analysis": true,
      "errors": [
        "EXIT_CODE_33"
      ],
      "vulnerability_findings": [
        {
          "name": "uninitialized-local",
          "vulnerability_from_line": 195,
          "vulnerability_to_line": null,
          "vulnerability_code": "        bool isThere;\n",
          "message": "isThere in KeyHolderLibrary.keyHasPurpose (KeyHolderLibrary.sol#195) is a local variable never initialiazed\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 35,
          "vulnerability_to_line": 44,
          "vulnerability_code": "    function init(KeyHolderData storage _keyHolderData)\n\n        public\n\n    {\n\n        bytes32 _key = keccak256(abi.encodePacked(msg.sender));\n\n        _keyHolderData.keys[_key].key = _key;\n\n        _keyHolderData.keys[_key].purposes.push(1);\n\n        _keyHolderData.keys[_key].keyType = 1;\n\n        _keyHolderData.keysByPurpose[1].push(_key);\n\n        emit KeyAdded(_key, 1, 1);\n",
          "message": "KeyHolderLibrary.init (KeyHolderLibrary.sol#35-44) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 46,
          "vulnerability_to_line": 56,
          "vulnerability_code": "    function getKey(KeyHolderData storage _keyHolderData, bytes32 _key)\n\n        public\n\n        view\n\n        returns(uint256[] purposes, uint256 keyType, bytes32 key)\n\n    {\n\n        return (\n\n            _keyHolderData.keys[_key].purposes,\n\n            _keyHolderData.keys[_key].keyType,\n\n            _keyHolderData.keys[_key].key\n\n        );\n",
          "message": "KeyHolderLibrary.getKey (KeyHolderLibrary.sol#46-56) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 58,
          "vulnerability_to_line": 64,
          "vulnerability_code": "    function getKeyPurposes(KeyHolderData storage _keyHolderData, bytes32 _key)\n\n        public\n\n        view\n\n        returns(uint256[] purposes)\n\n    {\n\n        return (_keyHolderData.keys[_key].purposes);\n",
          "message": "KeyHolderLibrary.getKeyPurposes (KeyHolderLibrary.sol#58-64) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 66,
          "vulnerability_to_line": 72,
          "vulnerability_code": "    function getKeysByPurpose(KeyHolderData storage _keyHolderData, uint256 _purpose)\n\n        public\n\n        view\n\n        returns(bytes32[] _keys)\n\n    {\n\n        return _keyHolderData.keysByPurpose[_purpose];\n",
          "message": "KeyHolderLibrary.getKeysByPurpose (KeyHolderLibrary.sol#66-72) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 74,
          "vulnerability_to_line": 92,
          "vulnerability_code": "    function addKey(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose, uint256 _type)\n\n        public\n\n        returns (bool success)\n\n    {\n\n        require(_keyHolderData.keys[_key].key != _key, \"Key already exists\"); // Key should not already exist\n\n        if (msg.sender != address(this)) {\n\n            require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 1), \"Sender does not have management key\"); // Sender has MANAGEMENT_KEY\n\n        }\n\n\n\n        _keyHolderData.keys[_key].key = _key;\n\n        _keyHolderData.keys[_key].purposes.push(_purpose);\n\n        _keyHolderData.keys[_key].keyType = _type;\n\n\n\n        _keyHolderData.keysByPurpose[_purpose].push(_key);\n\n\n\n        emit KeyAdded(_key, _purpose, _type);\n\n\n\n        return true;\n",
          "message": "KeyHolderLibrary.addKey (KeyHolderLibrary.sol#74-92) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 130,
          "vulnerability_to_line": 147,
          "vulnerability_code": "    function execute(KeyHolderData storage _keyHolderData, address _to, uint256 _value, bytes _data)\n\n        public\n\n        returns (uint256 executionId)\n\n    {\n\n        require(!_keyHolderData.executions[_keyHolderData.executionNonce].executed, \"Already executed\");\n\n        _keyHolderData.executions[_keyHolderData.executionNonce].to = _to;\n\n        _keyHolderData.executions[_keyHolderData.executionNonce].value = _value;\n\n        _keyHolderData.executions[_keyHolderData.executionNonce].data = _data;\n\n\n\n        emit ExecutionRequested(_keyHolderData.executionNonce, _to, _value, _data);\n\n\n\n        if (keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)),1) || keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)),2)) {\n\n            approve(_keyHolderData, _keyHolderData.executionNonce, true);\n\n        }\n\n\n\n        _keyHolderData.executionNonce++;\n\n        return _keyHolderData.executionNonce-1;\n",
          "message": "KeyHolderLibrary.execute (KeyHolderLibrary.sol#130-147) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 149,
          "vulnerability_to_line": 188,
          "vulnerability_code": "    function removeKey(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose)\n\n        public\n\n        returns (bool success)\n\n    {\n\n        if (msg.sender != address(this)) {\n\n            require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 1), \"Sender does not have management key\"); // Sender has MANAGEMENT_KEY\n\n        }\n\n\n\n        require(_keyHolderData.keys[_key].key == _key, \"No such key\");\n\n        emit KeyRemoved(_key, _purpose, _keyHolderData.keys[_key].keyType);\n\n\n\n        // Remove purpose from key\n\n        uint256[] storage purposes = _keyHolderData.keys[_key].purposes;\n\n        for (uint i = 0; i < purposes.length; i++) {\n\n            if (purposes[i] == _purpose) {\n\n                purposes[i] = purposes[purposes.length - 1];\n\n                delete purposes[purposes.length - 1];\n\n                purposes.length--;\n\n                break;\n\n            }\n\n        }\n\n\n\n        // If no more purposes, delete key\n\n        if (purposes.length == 0) {\n\n            delete _keyHolderData.keys[_key];\n\n        }\n\n\n\n        // Remove key from keysByPurpose\n\n        bytes32[] storage keys = _keyHolderData.keysByPurpose[_purpose];\n\n        for (uint j = 0; j < keys.length; j++) {\n\n            if (keys[j] == _key) {\n\n                keys[j] = keys[keys.length - 1];\n\n                delete keys[keys.length - 1];\n\n                keys.length--;\n\n                break;\n\n            }\n\n        }\n\n\n\n        return true;\n",
          "message": "KeyHolderLibrary.removeKey (KeyHolderLibrary.sol#149-188) should be declared external\n"
        },
        {
          "name": "low-level-calls",
          "vulnerability_from_line": 94,
          "vulnerability_to_line": 128,
          "vulnerability_code": "    function approve(KeyHolderData storage _keyHolderData, uint256 _id, bool _approve)\n\n        public\n\n        returns (bool success)\n\n    {\n\n        require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 2), \"Sender does not have action key\");\n\n        require(!_keyHolderData.executions[_id].executed, \"Already executed\");\n\n\n\n        emit Approved(_id, _approve);\n\n\n\n        if (_approve == true) {\n\n            _keyHolderData.executions[_id].approved = true;\n\n            success = _keyHolderData.executions[_id].to.call(_keyHolderData.executions[_id].data, 0);\n\n            if (success) {\n\n                _keyHolderData.executions[_id].executed = true;\n\n                emit Executed(\n\n                    _id,\n\n                    _keyHolderData.executions[_id].to,\n\n                    _keyHolderData.executions[_id].value,\n\n                    _keyHolderData.executions[_id].data\n\n                );\n\n                return;\n\n            } else {\n\n                emit ExecutionFailed(\n\n                    _id,\n\n                    _keyHolderData.executions[_id].to,\n\n                    _keyHolderData.executions[_id].value,\n\n                    _keyHolderData.executions[_id].data\n\n                );\n\n                return;\n\n            }\n\n        } else {\n\n            _keyHolderData.executions[_id].approved = false;\n\n        }\n\n        return true;\n",
          "message": "Low level call in KeyHolderLibrary.approve (KeyHolderLibrary.sol#94-128):\n\t-success = _keyHolderData.executions[_id].to.call(_keyHolderData.executions[_id].data,0) KeyHolderLibrary.sol#105\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 35,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function init(KeyHolderData storage _keyHolderData)\n",
          "message": "Parameter '_keyHolderData' of KeyHolderLibrary.init (KeyHolderLibrary.sol#35) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 46,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getKey(KeyHolderData storage _keyHolderData, bytes32 _key)\n",
          "message": "Parameter '_keyHolderData' of KeyHolderLibrary.getKey (KeyHolderLibrary.sol#46) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 46,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getKey(KeyHolderData storage _keyHolderData, bytes32 _key)\n",
          "message": "Parameter '_key' of KeyHolderLibrary.getKey (KeyHolderLibrary.sol#46) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 58,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getKeyPurposes(KeyHolderData storage _keyHolderData, bytes32 _key)\n",
          "message": "Parameter '_keyHolderData' of KeyHolderLibrary.getKeyPurposes (KeyHolderLibrary.sol#58) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 58,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getKeyPurposes(KeyHolderData storage _keyHolderData, bytes32 _key)\n",
          "message": "Parameter '_key' of KeyHolderLibrary.getKeyPurposes (KeyHolderLibrary.sol#58) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 66,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getKeysByPurpose(KeyHolderData storage _keyHolderData, uint256 _purpose)\n",
          "message": "Parameter '_keyHolderData' of KeyHolderLibrary.getKeysByPurpose (KeyHolderLibrary.sol#66) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 66,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getKeysByPurpose(KeyHolderData storage _keyHolderData, uint256 _purpose)\n",
          "message": "Parameter '_purpose' of KeyHolderLibrary.getKeysByPurpose (KeyHolderLibrary.sol#66) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 74,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function addKey(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose, uint256 _type)\n",
          "message": "Parameter '_keyHolderData' of KeyHolderLibrary.addKey (KeyHolderLibrary.sol#74) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 74,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function addKey(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose, uint256 _type)\n",
          "message": "Parameter '_key' of KeyHolderLibrary.addKey (KeyHolderLibrary.sol#74) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 74,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function addKey(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose, uint256 _type)\n",
          "message": "Parameter '_purpose' of KeyHolderLibrary.addKey (KeyHolderLibrary.sol#74) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 74,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function addKey(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose, uint256 _type)\n",
          "message": "Parameter '_type' of KeyHolderLibrary.addKey (KeyHolderLibrary.sol#74) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 94,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function approve(KeyHolderData storage _keyHolderData, uint256 _id, bool _approve)\n",
          "message": "Parameter '_keyHolderData' of KeyHolderLibrary.approve (KeyHolderLibrary.sol#94) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 94,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function approve(KeyHolderData storage _keyHolderData, uint256 _id, bool _approve)\n",
          "message": "Parameter '_id' of KeyHolderLibrary.approve (KeyHolderLibrary.sol#94) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 94,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function approve(KeyHolderData storage _keyHolderData, uint256 _id, bool _approve)\n",
          "message": "Parameter '_approve' of KeyHolderLibrary.approve (KeyHolderLibrary.sol#94) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 130,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function execute(KeyHolderData storage _keyHolderData, address _to, uint256 _value, bytes _data)\n",
          "message": "Parameter '_keyHolderData' of KeyHolderLibrary.execute (KeyHolderLibrary.sol#130) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 130,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function execute(KeyHolderData storage _keyHolderData, address _to, uint256 _value, bytes _data)\n",
          "message": "Parameter '_to' of KeyHolderLibrary.execute (KeyHolderLibrary.sol#130) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 130,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function execute(KeyHolderData storage _keyHolderData, address _to, uint256 _value, bytes _data)\n",
          "message": "Parameter '_value' of KeyHolderLibrary.execute (KeyHolderLibrary.sol#130) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 130,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function execute(KeyHolderData storage _keyHolderData, address _to, uint256 _value, bytes _data)\n",
          "message": "Parameter '_data' of KeyHolderLibrary.execute (KeyHolderLibrary.sol#130) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 149,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function removeKey(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose)\n",
          "message": "Parameter '_keyHolderData' of KeyHolderLibrary.removeKey (KeyHolderLibrary.sol#149) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 149,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function removeKey(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose)\n",
          "message": "Parameter '_key' of KeyHolderLibrary.removeKey (KeyHolderLibrary.sol#149) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 149,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function removeKey(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose)\n",
          "message": "Parameter '_purpose' of KeyHolderLibrary.removeKey (KeyHolderLibrary.sol#149) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 190,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function keyHasPurpose(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose)\n",
          "message": "Parameter '_keyHolderData' of KeyHolderLibrary.keyHasPurpose (KeyHolderLibrary.sol#190) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 190,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function keyHasPurpose(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose)\n",
          "message": "Parameter '_key' of KeyHolderLibrary.keyHasPurpose (KeyHolderLibrary.sol#190) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 190,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function keyHasPurpose(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose)\n",
          "message": "Parameter '_purpose' of KeyHolderLibrary.keyHasPurpose (KeyHolderLibrary.sol#190) is not in mixedCase\n"
        }
      ]
    },
    "smartcheck": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "SOLIDITY_ARRAY_LENGTH_MANIPULATION",
          "vulnerability_from_line": 166,
          "vulnerability_to_line": null,
          "vulnerability_code": "                purposes.length--;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ARRAY_LENGTH_MANIPULATION",
          "vulnerability_from_line": 182,
          "vulnerability_to_line": null,
          "vulnerability_code": "                keys.length--;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 162,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < purposes.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 178,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint j = 0; j < keys.length; j++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 201,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < purposes.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 162,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < purposes.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 178,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint j = 0; j < keys.length; j++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 201,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < purposes.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.24;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 105,
          "vulnerability_to_line": null,
          "vulnerability_code": "            success = _keyHolderData.executions[_id].to.call(_keyHolderData.executions[_id].data, 0);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 49,
          "vulnerability_to_line": null,
          "vulnerability_code": "        returns(uint256[] purposes, uint256 keyType, bytes32 key)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 61,
          "vulnerability_to_line": null,
          "vulnerability_code": "        returns(uint256[] purposes)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 69,
          "vulnerability_to_line": null,
          "vulnerability_code": "        returns(bytes32[] _keys)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 130,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function execute(KeyHolderData storage _keyHolderData, address _to, uint256 _value, bytes _data)\n",
          "message": null
        }
      ]
    },
    "oyente": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "Callstack Depth Attack Vulnerability",
          "vulnerability_from_line": 105,
          "vulnerability_to_line": null,
          "vulnerability_code": "            success = _keyHolderData.executions[_id].to.call(_keyHolderData.executions[_id].data, 0);\n",
          "message": null
        },
        {
          "name": "Integer Overflow",
          "vulnerability_from_line": 63,
          "vulnerability_to_line": null,
          "vulnerability_code": "        return (_keyHolderData.keys[_key].purposes);\n",
          "message": null
        },
        {
          "name": "Integer Underflow",
          "vulnerability_from_line": 38,
          "vulnerability_to_line": null,
          "vulnerability_code": "        bytes32 _key = keccak256(abi.encodePacked(msg.sender));\n",
          "message": null
        }
      ]
    },
    "mythril": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": []
    },
    "osiris": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "Callstack bug",
          "vulnerability_from_line": 105,
          "vulnerability_to_line": null,
          "vulnerability_code": "            success = _keyHolderData.executions[_id].to.call(_keyHolderData.executions[_id].data, 0);\n",
          "message": null
        },
        {
          "name": "Overflow bugs",
          "vulnerability_from_line": 1,
          "vulnerability_to_line": null,
          "vulnerability_code": "// File: ../sc_datasets/DAppSCAN/Trail_of_Bits-origin/origin-4b31657825523962434c6d4e4c61feb0bb1ee518/origin-contracts/contracts/identity/KeyHolderLibrary.sol\n",
          "message": null
        },
        {
          "name": "Overflow bugs",
          "vulnerability_from_line": 46,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getKey(KeyHolderData storage _keyHolderData, bytes32 _key)\n",
          "message": null
        },
        {
          "name": "Overflow bugs",
          "vulnerability_from_line": 51,
          "vulnerability_to_line": null,
          "vulnerability_code": "        return (\n",
          "message": null
        },
        {
          "name": "Overflow bugs",
          "vulnerability_from_line": 58,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getKeyPurposes(KeyHolderData storage _keyHolderData, bytes32 _key)\n",
          "message": null
        },
        {
          "name": "Overflow bugs",
          "vulnerability_from_line": 63,
          "vulnerability_to_line": null,
          "vulnerability_code": "        return (_keyHolderData.keys[_key].purposes);\n",
          "message": null
        },
        {
          "name": "Overflow bugs",
          "vulnerability_from_line": 66,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getKeysByPurpose(KeyHolderData storage _keyHolderData, uint256 _purpose)\n",
          "message": null
        },
        {
          "name": "Overflow bugs",
          "vulnerability_from_line": 71,
          "vulnerability_to_line": null,
          "vulnerability_code": "        return _keyHolderData.keysByPurpose[_purpose];\n",
          "message": null
        },
        {
          "name": "Overflow bugs",
          "vulnerability_from_line": 137,
          "vulnerability_to_line": null,
          "vulnerability_code": "        _keyHolderData.executions[_keyHolderData.executionNonce].data = _data;\n",
          "message": null
        }
      ]
    }
  }
}