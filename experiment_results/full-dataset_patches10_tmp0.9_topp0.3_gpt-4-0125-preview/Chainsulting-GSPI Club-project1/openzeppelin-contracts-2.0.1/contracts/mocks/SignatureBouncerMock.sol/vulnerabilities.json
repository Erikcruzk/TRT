{
  "smartbugs_completed": true,
  "analyzer_results": {
    "semgrep": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 265,
          "vulnerability_to_line": null,
          "vulnerability_code": "    for (uint i = 0; i < data.length; i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 286,
          "vulnerability_to_line": null,
          "vulnerability_code": "    for (uint i = 0; i < data.length; i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 60,
          "vulnerability_to_line": null,
          "vulnerability_code": "  constructor() internal {\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 61,
          "vulnerability_to_line": null,
          "vulnerability_code": "    _addSigner(msg.sender);\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 62,
          "vulnerability_to_line": null,
          "vulnerability_code": "  }\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 211,
          "vulnerability_to_line": null,
          "vulnerability_code": "  constructor() internal {}\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 265,
          "vulnerability_to_line": null,
          "vulnerability_code": "    for (uint i = 0; i < data.length; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 286,
          "vulnerability_to_line": null,
          "vulnerability_code": "    for (uint i = 0; i < data.length; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 140,
          "vulnerability_to_line": null,
          "vulnerability_code": "    if (v != 27 && v != 28) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 141,
          "vulnerability_to_line": null,
          "vulnerability_code": "      return (address(0));\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 142,
          "vulnerability_to_line": null,
          "vulnerability_code": "    } else {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 143,
          "vulnerability_to_line": null,
          "vulnerability_code": "      // solium-disable-next-line arg-overflow\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 144,
          "vulnerability_to_line": null,
          "vulnerability_code": "      return ecrecover(hash, v, r, s);\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 145,
          "vulnerability_to_line": null,
          "vulnerability_code": "    }\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 265,
          "vulnerability_to_line": null,
          "vulnerability_code": "    for (uint i = 0; i < data.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 286,
          "vulnerability_to_line": null,
          "vulnerability_code": "    for (uint i = 0; i < data.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        }
      ]
    },
    "slither": {
      "successfull_analysis": true,
      "errors": [
        "EXIT_CODE_25"
      ],
      "vulnerability_findings": [
        {
          "name": "constant-function",
          "vulnerability_from_line": 110,
          "vulnerability_to_line": 146,
          "vulnerability_code": "  function recover(bytes32 hash, bytes signature)\n\n    internal\n\n    pure\n\n    returns (address)\n\n  {\n\n    bytes32 r;\n\n    bytes32 s;\n\n    uint8 v;\n\n\n\n    // Check the signature length\n\n    if (signature.length != 65) {\n\n      return (address(0));\n\n    }\n\n\n\n    // Divide the signature in r, s and v variables\n\n    // ecrecover takes the signature parameters, and the only way to get them\n\n    // currently is to use assembly.\n\n    // solium-disable-next-line security/no-inline-assembly\n\n    assembly {\n\n      r := mload(add(signature, 0x20))\n\n      s := mload(add(signature, 0x40))\n\n      v := byte(0, mload(add(signature, 0x60)))\n\n    }\n\n\n\n    // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\n\n    if (v < 27) {\n\n      v += 27;\n\n    }\n\n\n\n    // If the version is correct return the signer address\n\n    if (v != 27 && v != 28) {\n\n      return (address(0));\n\n    } else {\n\n      // solium-disable-next-line arg-overflow\n\n      return ecrecover(hash, v, r, s);\n\n    }\n",
          "message": "ECDSA.recover (SignatureBouncerMock.sol#110-146) is declared view but contains assembly code\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 110,
          "vulnerability_to_line": 146,
          "vulnerability_code": "  function recover(bytes32 hash, bytes signature)\n\n    internal\n\n    pure\n\n    returns (address)\n\n  {\n\n    bytes32 r;\n\n    bytes32 s;\n\n    uint8 v;\n\n\n\n    // Check the signature length\n\n    if (signature.length != 65) {\n\n      return (address(0));\n\n    }\n\n\n\n    // Divide the signature in r, s and v variables\n\n    // ecrecover takes the signature parameters, and the only way to get them\n\n    // currently is to use assembly.\n\n    // solium-disable-next-line security/no-inline-assembly\n\n    assembly {\n\n      r := mload(add(signature, 0x20))\n\n      s := mload(add(signature, 0x40))\n\n      v := byte(0, mload(add(signature, 0x60)))\n\n    }\n\n\n\n    // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\n\n    if (v < 27) {\n\n      v += 27;\n\n    }\n\n\n\n    // If the version is correct return the signer address\n\n    if (v != 27 && v != 28) {\n\n      return (address(0));\n\n    } else {\n\n      // solium-disable-next-line arg-overflow\n\n      return ecrecover(hash, v, r, s);\n\n    }\n",
          "message": "ECDSA.recover uses assembly (SignatureBouncerMock.sol#110-146)\n\t- SignatureBouncerMock.sol#128-135\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 73,
          "vulnerability_to_line": 75,
          "vulnerability_code": "  function addSigner(address account) public onlySigner {\n\n    _addSigner(account);\n",
          "message": "SignerRole.addSigner (SignatureBouncerMock.sol#73-75) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 77,
          "vulnerability_to_line": 79,
          "vulnerability_code": "  function renounceSigner() public {\n\n    _removeSigner(msg.sender);\n",
          "message": "SignerRole.renounceSigner (SignatureBouncerMock.sol#77-79) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 318,
          "vulnerability_to_line": 320,
          "vulnerability_code": "  function removeSigner(address account) public {\n\n    _removeSigner(account);\n",
          "message": "SignerRoleMock.removeSigner (SignatureBouncerMock.sol#318-320) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 322,
          "vulnerability_to_line": 323,
          "vulnerability_code": "  function onlySignerMock() public view onlySigner {\n",
          "message": "SignerRoleMock.onlySignerMock (SignatureBouncerMock.sol#322-323) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 337,
          "vulnerability_to_line": 343,
          "vulnerability_code": "  function checkValidSignature(address account, bytes signature)\n\n    public\n\n    view\n\n    returns (bool)\n\n  {\n\n    return _isValidSignature(account, signature);\n",
          "message": "SignatureBouncerMock.checkValidSignature (SignatureBouncerMock.sol#337-343) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 345,
          "vulnerability_to_line": 351,
          "vulnerability_code": "  function onlyWithValidSignature(bytes signature)\n\n    public\n\n    onlyValidSignature(signature)\n\n    view\n\n  {\n\n\n",
          "message": "SignatureBouncerMock.onlyWithValidSignature (SignatureBouncerMock.sol#345-351) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 353,
          "vulnerability_to_line": 359,
          "vulnerability_code": "  function checkValidSignatureAndMethod(address account, bytes signature)\n\n    public\n\n    view\n\n    returns (bool)\n\n  {\n\n    return _isValidSignatureAndMethod(account, signature);\n",
          "message": "SignatureBouncerMock.checkValidSignatureAndMethod (SignatureBouncerMock.sol#353-359) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 361,
          "vulnerability_to_line": 367,
          "vulnerability_code": "  function onlyWithValidSignatureAndMethod(bytes signature)\n\n    public\n\n    onlyValidSignatureAndMethod(signature)\n\n    view\n\n  {\n\n\n",
          "message": "SignatureBouncerMock.onlyWithValidSignatureAndMethod (SignatureBouncerMock.sol#361-367) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 369,
          "vulnerability_to_line": 380,
          "vulnerability_code": "  function checkValidSignatureAndData(\n\n    address account,\n\n    bytes,\n\n    uint,\n\n    bytes signature\n\n  )\n\n    public\n\n    view\n\n    returns (bool)\n\n  {\n\n    return _isValidSignatureAndData(account, signature);\n",
          "message": "SignatureBouncerMock.checkValidSignatureAndData (SignatureBouncerMock.sol#369-380) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 382,
          "vulnerability_to_line": 388,
          "vulnerability_code": "  function onlyWithValidSignatureAndData(uint, bytes signature)\n\n    public\n\n    onlyValidSignatureAndData(signature)\n\n    view\n\n  {\n\n\n",
          "message": "SignatureBouncerMock.onlyWithValidSignatureAndData (SignatureBouncerMock.sol#382-388) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 390,
          "vulnerability_to_line": 395,
          "vulnerability_code": "  function theWrongMethod(bytes)\n\n    public\n\n    pure\n\n  {\n\n\n",
          "message": "SignatureBouncerMock.theWrongMethod (SignatureBouncerMock.sol#390-395) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 397,
          "vulnerability_to_line": 402,
          "vulnerability_code": "  function tooShortMsgData()\n\n    public\n\n    onlyValidSignatureAndData(\"\")\n\n    view\n\n  {\n",
          "message": "SignatureBouncerMock.tooShortMsgData (SignatureBouncerMock.sol#397-402) should be declared external\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 81,
          "vulnerability_to_line": 84,
          "vulnerability_code": "  function _addSigner(address account) internal {\n\n    signers.add(account);\n\n    emit SignerAdded(account);\n",
          "message": "Function 'SignerRole._addSigner' (SignatureBouncerMock.sol#81-84) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 86,
          "vulnerability_to_line": 89,
          "vulnerability_code": "  function _removeSigner(address account) internal {\n\n    signers.remove(account);\n\n    emit SignerRemoved(account);\n",
          "message": "Function 'SignerRole._removeSigner' (SignatureBouncerMock.sol#86-89) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 244,
          "vulnerability_to_line": 253,
          "vulnerability_code": "  function _isValidSignature(address account, bytes signature)\n\n    internal\n\n    view\n\n    returns (bool)\n\n  {\n\n    return _isValidDataHash(\n\n      keccak256(abi.encodePacked(address(this), account)),\n\n      signature\n\n    );\n",
          "message": "Function 'SignatureBouncer._isValidSignature' (SignatureBouncerMock.sol#244-253) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 259,
          "vulnerability_to_line": 272,
          "vulnerability_code": "  function _isValidSignatureAndMethod(address account, bytes signature)\n\n    internal\n\n    view\n\n    returns (bool)\n\n  {\n\n    bytes memory data = new bytes(_METHOD_ID_SIZE);\n\n    for (uint i = 0; i < data.length; i++) {\n\n      data[i] = msg.data[i];\n\n    }\n\n    return _isValidDataHash(\n\n      keccak256(abi.encodePacked(address(this), account, data)),\n\n      signature\n\n    );\n",
          "message": "Function 'SignatureBouncer._isValidSignatureAndMethod' (SignatureBouncerMock.sol#259-272) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 279,
          "vulnerability_to_line": 293,
          "vulnerability_code": "  function _isValidSignatureAndData(address account, bytes signature)\n\n    internal\n\n    view\n\n    returns (bool)\n\n  {\n\n    require(msg.data.length > _SIGNATURE_SIZE);\n\n    bytes memory data = new bytes(msg.data.length - _SIGNATURE_SIZE);\n\n    for (uint i = 0; i < data.length; i++) {\n\n      data[i] = msg.data[i];\n\n    }\n\n    return _isValidDataHash(\n\n      keccak256(abi.encodePacked(address(this), account, data)),\n\n      signature\n\n    );\n",
          "message": "Function 'SignatureBouncer._isValidSignatureAndData' (SignatureBouncerMock.sol#279-293) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 300,
          "vulnerability_to_line": 310,
          "vulnerability_code": "  function _isValidDataHash(bytes32 hash, bytes signature)\n\n    internal\n\n    view\n\n    returns (bool)\n\n  {\n\n    address signer = hash\n\n      .toEthSignedMessageHash()\n\n      .recover(signature);\n\n\n\n    return signer != address(0) && isSigner(signer);\n",
          "message": "Function 'SignatureBouncer._isValidDataHash' (SignatureBouncerMock.sol#300-310) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 326,
          "vulnerability_to_line": 328,
          "vulnerability_code": "  function _removeSigner(address account) internal {\n\n    super._removeSigner(account);\n",
          "message": "Function 'SignerRoleMock._removeSigner' (SignatureBouncerMock.sol#326-328) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 371,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bytes,\n",
          "message": "Parameter '' of SignatureBouncerMock.checkValidSignatureAndData (SignatureBouncerMock.sol#371) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 372,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint,\n",
          "message": "Parameter '_scope_0' of SignatureBouncerMock.checkValidSignatureAndData (SignatureBouncerMock.sol#372) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 382,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function onlyWithValidSignatureAndData(uint, bytes signature)\n",
          "message": "Parameter '' of SignatureBouncerMock.onlyWithValidSignatureAndData (SignatureBouncerMock.sol#382) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 390,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function theWrongMethod(bytes)\n",
          "message": "Parameter '' of SignatureBouncerMock.theWrongMethod (SignatureBouncerMock.sol#390) is not in mixedCase\n"
        }
      ]
    },
    "smartcheck": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 121,
          "vulnerability_to_line": null,
          "vulnerability_code": "      return (address(0));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 141,
          "vulnerability_to_line": null,
          "vulnerability_code": "      return (address(0));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 265,
          "vulnerability_to_line": null,
          "vulnerability_code": "    for (uint i = 0; i < data.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 286,
          "vulnerability_to_line": null,
          "vulnerability_code": "    for (uint i = 0; i < data.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 265,
          "vulnerability_to_line": null,
          "vulnerability_code": "    for (uint i = 0; i < data.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 286,
          "vulnerability_to_line": null,
          "vulnerability_code": "    for (uint i = 0; i < data.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.24;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 50,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.24;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 94,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.24;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 168,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.24;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 315,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.24;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 333,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.24;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 58,
          "vulnerability_to_line": null,
          "vulnerability_code": "  Roles.Role private signers;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 207,
          "vulnerability_to_line": null,
          "vulnerability_code": "  uint256 private constant _METHOD_ID_SIZE = 4;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 209,
          "vulnerability_to_line": null,
          "vulnerability_code": "  uint256 private constant _SIGNATURE_SIZE = 96;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 110,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function recover(bytes32 hash, bytes signature)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 110,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function recover(bytes32 hash, bytes signature)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 244,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function _isValidSignature(address account, bytes signature)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 259,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function _isValidSignatureAndMethod(address account, bytes signature)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 279,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function _isValidSignatureAndData(address account, bytes signature)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 300,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function _isValidDataHash(bytes32 hash, bytes signature)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 337,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function checkValidSignature(address account, bytes signature)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 345,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function onlyWithValidSignature(bytes signature)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 353,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function checkValidSignatureAndMethod(address account, bytes signature)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 361,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function onlyWithValidSignatureAndMethod(bytes signature)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 371,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bytes,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 373,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bytes signature\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 382,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function onlyWithValidSignatureAndData(uint, bytes signature)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 390,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function theWrongMethod(bytes)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 128,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly {\n",
          "message": null
        }
      ]
    },
    "oyente": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "Integer Overflow",
          "vulnerability_from_line": 361,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function onlyWithValidSignatureAndMethod(bytes signature)\n",
          "message": null
        }
      ]
    },
    "mythril": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "Integer Arithmetic Bugs (SWC 101)",
          "vulnerability_from_line": 337,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function checkValidSignature(address account, bytes signature)\n",
          "message": "The arithmetic operator can overflow.\nIt is possible to cause an integer overflow or underflow in the arithmetic operation. \nClassification: SWC-101"
        },
        {
          "name": "Integer Arithmetic Bugs (SWC 101)",
          "vulnerability_from_line": 337,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function checkValidSignature(address account, bytes signature)\n",
          "message": "The arithmetic operator can overflow.\nIt is possible to cause an integer overflow or underflow in the arithmetic operation. \nClassification: SWC-101"
        }
      ]
    },
    "osiris": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": []
    }
  }
}