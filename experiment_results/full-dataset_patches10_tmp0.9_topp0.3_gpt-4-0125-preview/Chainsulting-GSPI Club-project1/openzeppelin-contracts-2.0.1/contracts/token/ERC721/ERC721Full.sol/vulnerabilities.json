{
  "smartbugs_completed": true,
  "analyzer_results": {
    "semgrep": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 232,
          "vulnerability_to_line": null,
          "vulnerability_code": "  constructor()\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 233,
          "vulnerability_to_line": null,
          "vulnerability_code": "    internal\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 234,
          "vulnerability_to_line": null,
          "vulnerability_code": "  {\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 235,
          "vulnerability_to_line": null,
          "vulnerability_code": "    _registerInterface(_InterfaceId_ERC165);\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 236,
          "vulnerability_to_line": null,
          "vulnerability_code": "  }\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 307,
          "vulnerability_to_line": null,
          "vulnerability_code": "  constructor()\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 308,
          "vulnerability_to_line": null,
          "vulnerability_code": "    public\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 309,
          "vulnerability_to_line": null,
          "vulnerability_code": "  {\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 310,
          "vulnerability_to_line": null,
          "vulnerability_code": "    // register the supported interfaces to conform to ERC721 via ERC165\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 311,
          "vulnerability_to_line": null,
          "vulnerability_code": "    _registerInterface(_InterfaceId_ERC721);\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 312,
          "vulnerability_to_line": null,
          "vulnerability_code": "  }\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 642,
          "vulnerability_to_line": null,
          "vulnerability_code": "  constructor() public {\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 643,
          "vulnerability_to_line": null,
          "vulnerability_code": "    // register the supported interface to conform to ERC721 via ERC165\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 644,
          "vulnerability_to_line": null,
          "vulnerability_code": "    _registerInterface(_InterfaceId_ERC721Enumerable);\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 645,
          "vulnerability_to_line": null,
          "vulnerability_code": "  }\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 804,
          "vulnerability_to_line": null,
          "vulnerability_code": "  constructor(string name, string symbol) public {\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 805,
          "vulnerability_to_line": null,
          "vulnerability_code": "    _name = name;\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 806,
          "vulnerability_to_line": null,
          "vulnerability_code": "    _symbol = symbol;\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 807,
          "vulnerability_to_line": null,
          "vulnerability_code": "\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 808,
          "vulnerability_to_line": null,
          "vulnerability_code": "    // register the supported interfaces to conform to ERC721 via ERC165\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 809,
          "vulnerability_to_line": null,
          "vulnerability_code": "    _registerInterface(InterfaceId_ERC721Metadata);\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 810,
          "vulnerability_to_line": null,
          "vulnerability_code": "  }\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 878,
          "vulnerability_to_line": null,
          "vulnerability_code": "  constructor(string name, string symbol) ERC721Metadata(name, symbol)\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 879,
          "vulnerability_to_line": null,
          "vulnerability_code": "    public\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 880,
          "vulnerability_to_line": null,
          "vulnerability_code": "  {\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 881,
          "vulnerability_to_line": null,
          "vulnerability_code": "  }\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "use-prefix-decrement-not-postfix",
          "vulnerability_from_line": 717,
          "vulnerability_to_line": null,
          "vulnerability_code": "    _ownedTokens[from].length--;\n",
          "message": "Consider using the prefix decrement expression whenever the return value is not needed. The prefix decrement expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-decrement-not-postfix",
          "vulnerability_from_line": 757,
          "vulnerability_to_line": null,
          "vulnerability_code": "    _allTokens.length--;\n",
          "message": "Consider using the prefix decrement expression whenever the return value is not needed. The prefix decrement expression is cheaper in terms of gas."
        },
        {
          "name": "erc721-reentrancy",
          "vulnerability_from_line": 462,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require(_checkOnERC721Received(from, to, tokenId, _data));\n",
          "message": "ERC721 onERC721Received() reentrancy"
        }
      ]
    },
    "slither": {
      "successfull_analysis": true,
      "errors": [
        "EXIT_CODE_40"
      ],
      "vulnerability_findings": [
        {
          "name": "constant-function",
          "vulnerability_from_line": 191,
          "vulnerability_to_line": 202,
          "vulnerability_code": "  function isContract(address account) internal view returns (bool) {\n\n    uint256 size;\n\n    // XXX Currently there is no better way to check if there is a contract in an address\n\n    // than to check the size of the code at that address.\n\n    // See https://ethereum.stackexchange.com/a/14016/36603\n\n    // for more details about how this works.\n\n    // TODO Check this again before the Serenity release, because all addresses will be\n\n    // contracts then.\n\n    // solium-disable-next-line security/no-inline-assembly\n\n    assembly { size := extcodesize(account) }\n\n    return size > 0;\n",
          "message": "Address.isContract (ERC721Full.sol#191-202) is declared view but contains assembly code\n"
        },
        {
          "name": "erc20-interface",
          "vulnerability_from_line": 31,
          "vulnerability_to_line": 71,
          "vulnerability_code": "contract IERC721 is IERC165 {\n\n\n\n  event Transfer(\n\n    address indexed from,\n\n    address indexed to,\n\n    uint256 indexed tokenId\n\n  );\n\n  event Approval(\n\n    address indexed owner,\n\n    address indexed approved,\n\n    uint256 indexed tokenId\n\n  );\n\n  event ApprovalForAll(\n\n    address indexed owner,\n\n    address indexed operator,\n\n    bool approved\n\n  );\n\n\n\n  function balanceOf(address owner) public view returns (uint256 balance);\n\n  function ownerOf(uint256 tokenId) public view returns (address owner);\n\n\n\n  function approve(address to, uint256 tokenId) public;\n\n  function getApproved(uint256 tokenId)\n\n    public view returns (address operator);\n\n\n\n  function setApprovalForAll(address operator, bool _approved) public;\n\n  function isApprovedForAll(address owner, address operator)\n\n    public view returns (bool);\n\n\n\n  function transferFrom(address from, address to, uint256 tokenId) public;\n\n  function safeTransferFrom(address from, address to, uint256 tokenId)\n\n    public;\n\n\n\n  function safeTransferFrom(\n\n    address from,\n\n    address to,\n\n    uint256 tokenId,\n\n    bytes data\n\n  )\n\n    public;\n",
          "message": "IERC721 (ERC721Full.sol#31-71) has incorrect ERC20 function interface(s):\n\t-approve (ERC721Full.sol#52)\n\t-transferFrom (ERC721Full.sol#60)\n"
        },
        {
          "name": "erc20-interface",
          "vulnerability_from_line": 272,
          "vulnerability_to_line": 589,
          "vulnerability_code": "contract ERC721 is ERC165, IERC721 {\n\n\n\n  using SafeMath for uint256;\n\n  using Address for address;\n\n\n\n  // Equals to `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n\n  // which can be also obtained as `IERC721Receiver(0).onERC721Received.selector`\n\n  bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\n\n\n\n  // Mapping from token ID to owner\n\n  mapping (uint256 => address) private _tokenOwner;\n\n\n\n  // Mapping from token ID to approved address\n\n  mapping (uint256 => address) private _tokenApprovals;\n\n\n\n  // Mapping from owner to number of owned token\n\n  mapping (address => uint256) private _ownedTokensCount;\n\n\n\n  // Mapping from owner to operator approvals\n\n  mapping (address => mapping (address => bool)) private _operatorApprovals;\n\n\n\n  bytes4 private constant _InterfaceId_ERC721 = 0x80ac58cd;\n\n  /*\n\n   * 0x80ac58cd ===\n\n   *   bytes4(keccak256('balanceOf(address)')) ^\n\n   *   bytes4(keccak256('ownerOf(uint256)')) ^\n\n   *   bytes4(keccak256('approve(address,uint256)')) ^\n\n   *   bytes4(keccak256('getApproved(uint256)')) ^\n\n   *   bytes4(keccak256('setApprovalForAll(address,bool)')) ^\n\n   *   bytes4(keccak256('isApprovedForAll(address,address)')) ^\n\n   *   bytes4(keccak256('transferFrom(address,address,uint256)')) ^\n\n   *   bytes4(keccak256('safeTransferFrom(address,address,uint256)')) ^\n\n   *   bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)'))\n\n   */\n\n\n\n  constructor()\n\n    public\n\n  {\n\n    // register the supported interfaces to conform to ERC721 via ERC165\n\n    _registerInterface(_InterfaceId_ERC721);\n\n  }\n\n\n\n  /**\n\n   * @dev Gets the balance of the specified address\n\n   * @param owner address to query the balance of\n\n   * @return uint256 representing the amount owned by the passed address\n\n   */\n\n  function balanceOf(address owner) public view returns (uint256) {\n\n    require(owner != address(0));\n\n    return _ownedTokensCount[owner];\n\n  }\n\n\n\n  /**\n\n   * @dev Gets the owner of the specified token ID\n\n   * @param tokenId uint256 ID of the token to query the owner of\n\n   * @return owner address currently marked as the owner of the given token ID\n\n   */\n\n  function ownerOf(uint256 tokenId) public view returns (address) {\n\n    address owner = _tokenOwner[tokenId];\n\n    require(owner != address(0));\n\n    return owner;\n\n  }\n\n\n\n  /**\n\n   * @dev Approves another address to transfer the given token ID\n\n   * The zero address indicates there is no approved address.\n\n   * There can only be one approved address per token at a given time.\n\n   * Can only be called by the token owner or an approved operator.\n\n   * @param to address to be approved for the given token ID\n\n   * @param tokenId uint256 ID of the token to be approved\n\n   */\n\n  function approve(address to, uint256 tokenId) public {\n\n    address owner = ownerOf(tokenId);\n\n    require(to != owner);\n\n    require(msg.sender == owner || isApprovedForAll(owner, msg.sender));\n\n\n\n    _tokenApprovals[tokenId] = to;\n\n    emit Approval(owner, to, tokenId);\n\n  }\n\n\n\n  /**\n\n   * @dev Gets the approved address for a token ID, or zero if no address set\n\n   * Reverts if the token ID does not exist.\n\n   * @param tokenId uint256 ID of the token to query the approval of\n\n   * @return address currently approved for the given token ID\n\n   */\n\n  function getApproved(uint256 tokenId) public view returns (address) {\n\n    require(_exists(tokenId));\n\n    return _tokenApprovals[tokenId];\n\n  }\n\n\n\n  /**\n\n   * @dev Sets or unsets the approval of a given operator\n\n   * An operator is allowed to transfer all tokens of the sender on their behalf\n\n   * @param to operator address to set the approval\n\n   * @param approved representing the status of the approval to be set\n\n   */\n\n  function setApprovalForAll(address to, bool approved) public {\n\n    require(to != msg.sender);\n\n    _operatorApprovals[msg.sender][to] = approved;\n\n    emit ApprovalForAll(msg.sender, to, approved);\n\n  }\n\n\n\n  /**\n\n   * @dev Tells whether an operator is approved by a given owner\n\n   * @param owner owner address which you want to query the approval of\n\n   * @param operator operator address which you want to query the approval of\n\n   * @return bool whether the given operator is approved by the given owner\n\n   */\n\n  function isApprovedForAll(\n\n    address owner,\n\n    address operator\n\n  )\n\n    public\n\n    view\n\n    returns (bool)\n\n  {\n\n    return _operatorApprovals[owner][operator];\n\n  }\n\n\n\n  /**\n\n   * @dev Transfers the ownership of a given token ID to another address\n\n   * Usage of this method is discouraged, use `safeTransferFrom` whenever possible\n\n   * Requires the msg sender to be the owner, approved, or operator\n\n   * @param from current owner of the token\n\n   * @param to address to receive the ownership of the given token ID\n\n   * @param tokenId uint256 ID of the token to be transferred\n\n  */\n\n  function transferFrom(\n\n    address from,\n\n    address to,\n\n    uint256 tokenId\n\n  )\n\n    public\n\n  {\n\n    require(_isApprovedOrOwner(msg.sender, tokenId));\n\n    require(to != address(0));\n\n\n\n    _clearApproval(from, tokenId);\n\n    _removeTokenFrom(from, tokenId);\n\n    _addTokenTo(to, tokenId);\n\n\n\n    emit Transfer(from, to, tokenId);\n\n  }\n\n\n\n  /**\n\n   * @dev Safely transfers the ownership of a given token ID to another address\n\n   * If the target address is a contract, it must implement `onERC721Received`,\n\n   * which is called upon a safe transfer, and return the magic value\n\n   * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\n\n   * the transfer is reverted.\n\n   *\n\n   * Requires the msg sender to be the owner, approved, or operator\n\n   * @param from current owner of the token\n\n   * @param to address to receive the ownership of the given token ID\n\n   * @param tokenId uint256 ID of the token to be transferred\n\n  */\n\n  function safeTransferFrom(\n\n    address from,\n\n    address to,\n\n    uint256 tokenId\n\n  )\n\n    public\n\n  {\n\n    // solium-disable-next-line arg-overflow\n\n    safeTransferFrom(from, to, tokenId, \"\");\n\n  }\n\n\n\n  /**\n\n   * @dev Safely transfers the ownership of a given token ID to another address\n\n   * If the target address is a contract, it must implement `onERC721Received`,\n\n   * which is called upon a safe transfer, and return the magic value\n\n   * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\n\n   * the transfer is reverted.\n\n   * Requires the msg sender to be the owner, approved, or operator\n\n   * @param from current owner of the token\n\n   * @param to address to receive the ownership of the given token ID\n\n   * @param tokenId uint256 ID of the token to be transferred\n\n   * @param _data bytes data to send along with a safe transfer check\n\n   */\n\n  function safeTransferFrom(\n\n    address from,\n\n    address to,\n\n    uint256 tokenId,\n\n    bytes _data\n\n  )\n\n    public\n\n  {\n\n    transferFrom(from, to, tokenId);\n\n    // solium-disable-next-line arg-overflow\n\n    require(_checkOnERC721Received(from, to, tokenId, _data));\n\n  }\n\n\n\n  /**\n\n   * @dev Returns whether the specified token exists\n\n   * @param tokenId uint256 ID of the token to query the existence of\n\n   * @return whether the token exists\n\n   */\n\n  function _exists(uint256 tokenId) internal view returns (bool) {\n\n    address owner = _tokenOwner[tokenId];\n\n    return owner != address(0);\n\n  }\n\n\n\n  /**\n\n   * @dev Returns whether the given spender can transfer a given token ID\n\n   * @param spender address of the spender to query\n\n   * @param tokenId uint256 ID of the token to be transferred\n\n   * @return bool whether the msg.sender is approved for the given token ID,\n\n   *  is an operator of the owner, or is the owner of the token\n\n   */\n\n  function _isApprovedOrOwner(\n\n    address spender,\n\n    uint256 tokenId\n\n  )\n\n    internal\n\n    view\n\n    returns (bool)\n\n  {\n\n    address owner = ownerOf(tokenId);\n\n    // Disable solium check because of\n\n    // https://github.com/duaraghav8/Solium/issues/175\n\n    // solium-disable-next-line operator-whitespace\n\n    return (\n\n      spender == owner ||\n\n      getApproved(tokenId) == spender ||\n\n      isApprovedForAll(owner, spender)\n\n    );\n\n  }\n\n\n\n  /**\n\n   * @dev Internal function to mint a new token\n\n   * Reverts if the given token ID already exists\n\n   * @param to The address that will own the minted token\n\n   * @param tokenId uint256 ID of the token to be minted by the msg.sender\n\n   */\n\n  function _mint(address to, uint256 tokenId) internal {\n\n    require(to != address(0));\n\n    _addTokenTo(to, tokenId);\n\n    emit Transfer(address(0), to, tokenId);\n\n  }\n\n\n\n  /**\n\n   * @dev Internal function to burn a specific token\n\n   * Reverts if the token does not exist\n\n   * @param tokenId uint256 ID of the token being burned by the msg.sender\n\n   */\n\n  function _burn(address owner, uint256 tokenId) internal {\n\n    _clearApproval(owner, tokenId);\n\n    _removeTokenFrom(owner, tokenId);\n\n    emit Transfer(owner, address(0), tokenId);\n\n  }\n\n\n\n  /**\n\n   * @dev Internal function to add a token ID to the list of a given address\n\n   * Note that this function is left internal to make ERC721Enumerable possible, but is not\n\n   * intended to be called by custom derived contracts: in particular, it emits no Transfer event.\n\n   * @param to address representing the new owner of the given token ID\n\n   * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\n\n   */\n\n  function _addTokenTo(address to, uint256 tokenId) internal {\n\n    require(_tokenOwner[tokenId] == address(0));\n\n    _tokenOwner[tokenId] = to;\n\n    _ownedTokensCount[to] = _ownedTokensCount[to].add(1);\n\n  }\n\n\n\n  /**\n\n   * @dev Internal function to remove a token ID from the list of a given address\n\n   * Note that this function is left internal to make ERC721Enumerable possible, but is not\n\n   * intended to be called by custom derived contracts: in particular, it emits no Transfer event,\n\n   * and doesn't clear approvals.\n\n   * @param from address representing the previous owner of the given token ID\n\n   * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\n\n   */\n\n  function _removeTokenFrom(address from, uint256 tokenId) internal {\n\n    require(ownerOf(tokenId) == from);\n\n    _ownedTokensCount[from] = _ownedTokensCount[from].sub(1);\n\n    _tokenOwner[tokenId] = address(0);\n\n  }\n\n\n\n  /**\n\n   * @dev Internal function to invoke `onERC721Received` on a target address\n\n   * The call is not executed if the target address is not a contract\n\n   * @param from address representing the previous owner of the given token ID\n\n   * @param to target address that will receive the tokens\n\n   * @param tokenId uint256 ID of the token to be transferred\n\n   * @param _data bytes optional data to send along with the call\n\n   * @return whether the call correctly returned the expected magic value\n\n   */\n\n  function _checkOnERC721Received(\n\n    address from,\n\n    address to,\n\n    uint256 tokenId,\n\n    bytes _data\n\n  )\n\n    internal\n\n    returns (bool)\n\n  {\n\n    if (!to.isContract()) {\n\n      return true;\n\n    }\n\n    bytes4 retval = IERC721Receiver(to).onERC721Received(\n\n      msg.sender, from, tokenId, _data);\n\n    return (retval == _ERC721_RECEIVED);\n\n  }\n\n\n\n  /**\n\n   * @dev Private function to clear current approval of a given token ID\n\n   * Reverts if the given address is not indeed the owner of the token\n\n   * @param owner owner of the token\n\n   * @param tokenId uint256 ID of the token to be transferred\n\n   */\n\n  function _clearApproval(address owner, uint256 tokenId) private {\n\n    require(ownerOf(tokenId) == owner);\n\n    if (_tokenApprovals[tokenId] != address(0)) {\n\n      _tokenApprovals[tokenId] = address(0);\n\n    }\n\n  }\n",
          "message": "ERC721 (ERC721Full.sol#272-589) has incorrect ERC20 function interface(s):\n\t-approve (ERC721Full.sol#343-350)\n\t-transferFrom (ERC721Full.sol#400-415)\n"
        },
        {
          "name": "shadowing-local",
          "vulnerability_from_line": 804,
          "vulnerability_to_line": null,
          "vulnerability_code": "  constructor(string name, string symbol) public {\n",
          "message": "ERC721Metadata.constructor.name (local variable @ ERC721Full.sol#804) shadows:\n\t- ERC721Metadata.name (function @ ERC721Full.sol#816-818)\n\t- IERC721Metadata.name (function @ ERC721Full.sol#772)\n"
        },
        {
          "name": "shadowing-local",
          "vulnerability_from_line": 804,
          "vulnerability_to_line": null,
          "vulnerability_code": "  constructor(string name, string symbol) public {\n",
          "message": "ERC721Metadata.constructor.symbol (local variable @ ERC721Full.sol#804) shadows:\n\t- ERC721Metadata.symbol (function @ ERC721Full.sol#824-826)\n\t- IERC721Metadata.symbol (function @ ERC721Full.sol#773)\n"
        },
        {
          "name": "shadowing-local",
          "vulnerability_from_line": 878,
          "vulnerability_to_line": null,
          "vulnerability_code": "  constructor(string name, string symbol) ERC721Metadata(name, symbol)\n",
          "message": "ERC721Full.constructor.name (local variable @ ERC721Full.sol#878) shadows:\n\t- ERC721Metadata.name (function @ ERC721Full.sol#816-818)\n\t- IERC721Metadata.name (function @ ERC721Full.sol#772)\n"
        },
        {
          "name": "shadowing-local",
          "vulnerability_from_line": 878,
          "vulnerability_to_line": null,
          "vulnerability_code": "  constructor(string name, string symbol) ERC721Metadata(name, symbol)\n",
          "message": "ERC721Full.constructor.symbol (local variable @ ERC721Full.sol#878) shadows:\n\t- ERC721Metadata.symbol (function @ ERC721Full.sol#824-826)\n\t- IERC721Metadata.symbol (function @ ERC721Full.sol#773)\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 191,
          "vulnerability_to_line": 202,
          "vulnerability_code": "  function isContract(address account) internal view returns (bool) {\n\n    uint256 size;\n\n    // XXX Currently there is no better way to check if there is a contract in an address\n\n    // than to check the size of the code at that address.\n\n    // See https://ethereum.stackexchange.com/a/14016/36603\n\n    // for more details about how this works.\n\n    // TODO Check this again before the Serenity release, because all addresses will be\n\n    // contracts then.\n\n    // solium-disable-next-line security/no-inline-assembly\n\n    assembly { size := extcodesize(account) }\n\n    return size > 0;\n",
          "message": "Address.isContract uses assembly (ERC721Full.sol#191-202)\n\t- ERC721Full.sol#200-201\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 343,
          "vulnerability_to_line": 350,
          "vulnerability_code": "  function approve(address to, uint256 tokenId) public {\n\n    address owner = ownerOf(tokenId);\n\n    require(to != owner);\n\n    require(msg.sender == owner || isApprovedForAll(owner, msg.sender));\n\n\n\n    _tokenApprovals[tokenId] = to;\n\n    emit Approval(owner, to, tokenId);\n",
          "message": "ERC721.approve (ERC721Full.sol#343-350) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 52,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function approve(address to, uint256 tokenId) public;\n",
          "message": "IERC721.approve (ERC721Full.sol#52) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 369,
          "vulnerability_to_line": 373,
          "vulnerability_code": "  function setApprovalForAll(address to, bool approved) public {\n\n    require(to != msg.sender);\n\n    _operatorApprovals[msg.sender][to] = approved;\n\n    emit ApprovalForAll(msg.sender, to, approved);\n",
          "message": "ERC721.setApprovalForAll (ERC721Full.sol#369-373) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 56,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function setApprovalForAll(address operator, bool _approved) public;\n",
          "message": "IERC721.setApprovalForAll (ERC721Full.sol#56) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 429,
          "vulnerability_to_line": 438,
          "vulnerability_code": "  function safeTransferFrom(\n\n    address from,\n\n    address to,\n\n    uint256 tokenId\n\n  )\n\n    public\n\n  {\n\n    // solium-disable-next-line arg-overflow\n\n    safeTransferFrom(from, to, tokenId, \"\");\n",
          "message": "ERC721.safeTransferFrom (ERC721Full.sol#429-438) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 61,
          "vulnerability_to_line": 62,
          "vulnerability_code": "  function safeTransferFrom(address from, address to, uint256 tokenId)\n",
          "message": "IERC721.safeTransferFrom (ERC721Full.sol#61-62) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 97,
          "vulnerability_to_line": 104,
          "vulnerability_code": "  function onERC721Received(\n\n    address operator,\n\n    address from,\n\n    uint256 tokenId,\n\n    bytes data\n\n  )\n\n    public\n",
          "message": "IERC721Receiver.onERC721Received (ERC721Full.sol#97-104) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 601,
          "vulnerability_to_line": 607,
          "vulnerability_code": "  function tokenOfOwnerByIndex(\n\n    address owner,\n\n    uint256 index\n\n  )\n\n    public\n\n    view\n",
          "message": "IERC721Enumerable.tokenOfOwnerByIndex (ERC721Full.sol#601-607) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 653,
          "vulnerability_to_line": 663,
          "vulnerability_code": "  function tokenOfOwnerByIndex(\n\n    address owner,\n\n    uint256 index\n\n  )\n\n    public\n\n    view\n\n    returns (uint256)\n\n  {\n\n    require(index < balanceOf(owner));\n\n    return _ownedTokens[owner][index];\n",
          "message": "ERC721Enumerable.tokenOfOwnerByIndex (ERC721Full.sol#653-663) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 609,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function tokenByIndex(uint256 index) public view returns (uint256);\n",
          "message": "IERC721Enumerable.tokenByIndex (ERC721Full.sol#609) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 679,
          "vulnerability_to_line": 682,
          "vulnerability_code": "  function tokenByIndex(uint256 index) public view returns (uint256) {\n\n    require(index < totalSupply());\n\n    return _allTokens[index];\n",
          "message": "ERC721Enumerable.tokenByIndex (ERC721Full.sol#679-682) should be declared external\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 252,
          "vulnerability_to_line": 257,
          "vulnerability_code": "  function _registerInterface(bytes4 interfaceId)\n\n    internal\n\n  {\n\n    require(interfaceId != 0xffffffff);\n\n    _supportedInterfaces[interfaceId] = true;\n",
          "message": "Function 'ERC165._registerInterface' (ERC721Full.sol#252-257) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 217,
          "vulnerability_to_line": null,
          "vulnerability_code": "  bytes4 private constant _InterfaceId_ERC165 = 0x01ffc9a7;\n",
          "message": "Constant 'ERC165._InterfaceId_ERC165' (ERC721Full.sol#217) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 456,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bytes _data\n",
          "message": "Parameter '_data' of ERC721.safeTransferFrom (ERC721Full.sol#456) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 470,
          "vulnerability_to_line": 473,
          "vulnerability_code": "  function _exists(uint256 tokenId) internal view returns (bool) {\n\n    address owner = _tokenOwner[tokenId];\n\n    return owner != address(0);\n",
          "message": "Function 'ERC721._exists' (ERC721Full.sol#470-473) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 482,
          "vulnerability_to_line": 499,
          "vulnerability_code": "  function _isApprovedOrOwner(\n\n    address spender,\n\n    uint256 tokenId\n\n  )\n\n    internal\n\n    view\n\n    returns (bool)\n\n  {\n\n    address owner = ownerOf(tokenId);\n\n    // Disable solium check because of\n\n    // https://github.com/duaraghav8/Solium/issues/175\n\n    // solium-disable-next-line operator-whitespace\n\n    return (\n\n      spender == owner ||\n\n      getApproved(tokenId) == spender ||\n\n      isApprovedForAll(owner, spender)\n\n    );\n",
          "message": "Function 'ERC721._isApprovedOrOwner' (ERC721Full.sol#482-499) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 507,
          "vulnerability_to_line": 511,
          "vulnerability_code": "  function _mint(address to, uint256 tokenId) internal {\n\n    require(to != address(0));\n\n    _addTokenTo(to, tokenId);\n\n    emit Transfer(address(0), to, tokenId);\n",
          "message": "Function 'ERC721._mint' (ERC721Full.sol#507-511) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 518,
          "vulnerability_to_line": 522,
          "vulnerability_code": "  function _burn(address owner, uint256 tokenId) internal {\n\n    _clearApproval(owner, tokenId);\n\n    _removeTokenFrom(owner, tokenId);\n\n    emit Transfer(owner, address(0), tokenId);\n",
          "message": "Function 'ERC721._burn' (ERC721Full.sol#518-522) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 531,
          "vulnerability_to_line": 535,
          "vulnerability_code": "  function _addTokenTo(address to, uint256 tokenId) internal {\n\n    require(_tokenOwner[tokenId] == address(0));\n\n    _tokenOwner[tokenId] = to;\n\n    _ownedTokensCount[to] = _ownedTokensCount[to].add(1);\n",
          "message": "Function 'ERC721._addTokenTo' (ERC721Full.sol#531-535) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 545,
          "vulnerability_to_line": 549,
          "vulnerability_code": "  function _removeTokenFrom(address from, uint256 tokenId) internal {\n\n    require(ownerOf(tokenId) == from);\n\n    _ownedTokensCount[from] = _ownedTokensCount[from].sub(1);\n\n    _tokenOwner[tokenId] = address(0);\n",
          "message": "Function 'ERC721._removeTokenFrom' (ERC721Full.sol#545-549) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 560,
          "vulnerability_to_line": 575,
          "vulnerability_code": "  function _checkOnERC721Received(\n\n    address from,\n\n    address to,\n\n    uint256 tokenId,\n\n    bytes _data\n\n  )\n\n    internal\n\n    returns (bool)\n\n  {\n\n    if (!to.isContract()) {\n\n      return true;\n\n    }\n\n    bytes4 retval = IERC721Receiver(to).onERC721Received(\n\n      msg.sender, from, tokenId, _data);\n\n    return (retval == _ERC721_RECEIVED);\n",
          "message": "Function 'ERC721._checkOnERC721Received' (ERC721Full.sol#560-575) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 564,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bytes _data\n",
          "message": "Parameter '_data' of ERC721._checkOnERC721Received (ERC721Full.sol#564) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 583,
          "vulnerability_to_line": 588,
          "vulnerability_code": "  function _clearApproval(address owner, uint256 tokenId) private {\n\n    require(ownerOf(tokenId) == owner);\n\n    if (_tokenApprovals[tokenId] != address(0)) {\n\n      _tokenApprovals[tokenId] = address(0);\n\n    }\n",
          "message": "Function 'ERC721._clearApproval' (ERC721Full.sol#583-588) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 293,
          "vulnerability_to_line": null,
          "vulnerability_code": "  bytes4 private constant _InterfaceId_ERC721 = 0x80ac58cd;\n",
          "message": "Constant 'ERC721._InterfaceId_ERC721' (ERC721Full.sol#293) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 733,
          "vulnerability_to_line": 738,
          "vulnerability_code": "  function _mint(address to, uint256 tokenId) internal {\n\n    super._mint(to, tokenId);\n\n\n\n    _allTokensIndex[tokenId] = _allTokens.length;\n\n    _allTokens.push(tokenId);\n",
          "message": "Function 'ERC721Enumerable._mint' (ERC721Full.sol#733-738) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 746,
          "vulnerability_to_line": 760,
          "vulnerability_code": "  function _burn(address owner, uint256 tokenId) internal {\n\n    super._burn(owner, tokenId);\n\n\n\n    // Reorg all tokens array\n\n    uint256 tokenIndex = _allTokensIndex[tokenId];\n\n    uint256 lastTokenIndex = _allTokens.length.sub(1);\n\n    uint256 lastToken = _allTokens[lastTokenIndex];\n\n\n\n    _allTokens[tokenIndex] = lastToken;\n\n    _allTokens[lastTokenIndex] = 0;\n\n\n\n    _allTokens.length--;\n\n    _allTokensIndex[tokenId] = 0;\n\n    _allTokensIndex[lastToken] = tokenIndex;\n",
          "message": "Function 'ERC721Enumerable._burn' (ERC721Full.sol#746-760) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 691,
          "vulnerability_to_line": 696,
          "vulnerability_code": "  function _addTokenTo(address to, uint256 tokenId) internal {\n\n    super._addTokenTo(to, tokenId);\n\n    uint256 length = _ownedTokens[to].length;\n\n    _ownedTokens[to].push(tokenId);\n\n    _ownedTokensIndex[tokenId] = length;\n",
          "message": "Function 'ERC721Enumerable._addTokenTo' (ERC721Full.sol#691-696) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 706,
          "vulnerability_to_line": 725,
          "vulnerability_code": "  function _removeTokenFrom(address from, uint256 tokenId) internal {\n\n    super._removeTokenFrom(from, tokenId);\n\n\n\n    // To prevent a gap in the array, we store the last token in the index of the token to delete, and\n\n    // then delete the last slot.\n\n    uint256 tokenIndex = _ownedTokensIndex[tokenId];\n\n    uint256 lastTokenIndex = _ownedTokens[from].length.sub(1);\n\n    uint256 lastToken = _ownedTokens[from][lastTokenIndex];\n\n\n\n    _ownedTokens[from][tokenIndex] = lastToken;\n\n    // This also deletes the contents at the last position of the array\n\n    _ownedTokens[from].length--;\n\n\n\n    // Note that this will handle single-element arrays. In that case, both tokenIndex and lastTokenIndex are going to\n\n    // be zero. Then we can make sure that we will remove tokenId from the ownedTokens list since we are first swapping\n\n    // the lastToken to the first position, and then dropping the element placed in the last position of the list\n\n\n\n    _ownedTokensIndex[tokenId] = 0;\n\n    _ownedTokensIndex[lastToken] = tokenIndex;\n",
          "message": "Function 'ERC721Enumerable._removeTokenFrom' (ERC721Full.sol#706-725) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 631,
          "vulnerability_to_line": null,
          "vulnerability_code": "  bytes4 private constant _InterfaceId_ERC721Enumerable = 0x780e9d63;\n",
          "message": "Constant 'ERC721Enumerable._InterfaceId_ERC721Enumerable' (ERC721Full.sol#631) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 855,
          "vulnerability_to_line": 862,
          "vulnerability_code": "  function _burn(address owner, uint256 tokenId) internal {\n\n    super._burn(owner, tokenId);\n\n\n\n    // Clear metadata (if any)\n\n    if (bytes(_tokenURIs[tokenId]).length != 0) {\n\n      delete _tokenURIs[tokenId];\n\n    }\n",
          "message": "Function 'ERC721Metadata._burn' (ERC721Full.sol#855-862) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 844,
          "vulnerability_to_line": 847,
          "vulnerability_code": "  function _setTokenURI(uint256 tokenId, string uri) internal {\n\n    require(_exists(tokenId));\n\n    _tokenURIs[tokenId] = uri;\n",
          "message": "Function 'ERC721Metadata._setTokenURI' (ERC721Full.sol#844-847) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 793,
          "vulnerability_to_line": null,
          "vulnerability_code": "  bytes4 private constant InterfaceId_ERC721Metadata = 0x5b5e139f;\n",
          "message": "Constant 'ERC721Metadata.InterfaceId_ERC721Metadata' (ERC721Full.sol#793) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        }
      ]
    },
    "smartcheck": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 217,
          "vulnerability_to_line": null,
          "vulnerability_code": "  bytes4 private constant _InterfaceId_ERC165 = 0x01ffc9a7;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 255,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require(interfaceId != 0xffffffff);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 279,
          "vulnerability_to_line": null,
          "vulnerability_code": "  bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 293,
          "vulnerability_to_line": null,
          "vulnerability_code": "  bytes4 private constant _InterfaceId_ERC721 = 0x80ac58cd;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 631,
          "vulnerability_to_line": null,
          "vulnerability_code": "  bytes4 private constant _InterfaceId_ERC721Enumerable = 0x780e9d63;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 793,
          "vulnerability_to_line": null,
          "vulnerability_code": "  bytes4 private constant InterfaceId_ERC721Metadata = 0x5b5e139f;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 548,
          "vulnerability_to_line": null,
          "vulnerability_code": "    _tokenOwner[tokenId] = address(0);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 586,
          "vulnerability_to_line": null,
          "vulnerability_code": "      _tokenApprovals[tokenId] = address(0);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ARRAY_LENGTH_MANIPULATION",
          "vulnerability_from_line": 717,
          "vulnerability_to_line": null,
          "vulnerability_code": "    _ownedTokens[from].length--;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ARRAY_LENGTH_MANIPULATION",
          "vulnerability_from_line": 757,
          "vulnerability_to_line": null,
          "vulnerability_code": "    _allTokens.length--;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.24;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 25,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.24;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 75,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.24;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 109,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.24;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 177,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.24;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 208,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.24;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 262,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.24;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 593,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.24;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 614,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.24;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 765,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.24;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 779,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.24;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 867,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.24;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 217,
          "vulnerability_to_line": null,
          "vulnerability_code": "  bytes4 private constant _InterfaceId_ERC165 = 0x01ffc9a7;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 226,
          "vulnerability_to_line": null,
          "vulnerability_code": "  mapping(bytes4 => bool) private _supportedInterfaces;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 279,
          "vulnerability_to_line": null,
          "vulnerability_code": "  bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 282,
          "vulnerability_to_line": null,
          "vulnerability_code": "  mapping (uint256 => address) private _tokenOwner;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 285,
          "vulnerability_to_line": null,
          "vulnerability_code": "  mapping (uint256 => address) private _tokenApprovals;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 288,
          "vulnerability_to_line": null,
          "vulnerability_code": "  mapping (address => uint256) private _ownedTokensCount;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 291,
          "vulnerability_to_line": null,
          "vulnerability_code": "  mapping (address => mapping (address => bool)) private _operatorApprovals;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 293,
          "vulnerability_to_line": null,
          "vulnerability_code": "  bytes4 private constant _InterfaceId_ERC721 = 0x80ac58cd;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 620,
          "vulnerability_to_line": null,
          "vulnerability_code": "  mapping(address => uint256[]) private _ownedTokens;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 623,
          "vulnerability_to_line": null,
          "vulnerability_code": "  mapping(uint256 => uint256) private _ownedTokensIndex;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 626,
          "vulnerability_to_line": null,
          "vulnerability_code": "  uint256[] private _allTokens;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 629,
          "vulnerability_to_line": null,
          "vulnerability_code": "  mapping(uint256 => uint256) private _allTokensIndex;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 631,
          "vulnerability_to_line": null,
          "vulnerability_code": "  bytes4 private constant _InterfaceId_ERC721Enumerable = 0x780e9d63;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 785,
          "vulnerability_to_line": null,
          "vulnerability_code": "  string private _name;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 788,
          "vulnerability_to_line": null,
          "vulnerability_code": "  string private _symbol;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 791,
          "vulnerability_to_line": null,
          "vulnerability_code": "  mapping(uint256 => string) private _tokenURIs;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 793,
          "vulnerability_to_line": null,
          "vulnerability_code": "  bytes4 private constant InterfaceId_ERC721Metadata = 0x5b5e139f;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SAFEMATH",
          "vulnerability_from_line": 274,
          "vulnerability_to_line": null,
          "vulnerability_code": "  using SafeMath for uint256;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
          "vulnerability_from_line": 191,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function isContract(address account) internal view returns (bool) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 68,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bytes data\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 101,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bytes data\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 456,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bytes _data\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 564,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bytes _data\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 804,
          "vulnerability_to_line": null,
          "vulnerability_code": "  constructor(string name, string symbol) public {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 804,
          "vulnerability_to_line": null,
          "vulnerability_code": "  constructor(string name, string symbol) public {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 844,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function _setTokenURI(uint256 tokenId, string uri) internal {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 878,
          "vulnerability_to_line": null,
          "vulnerability_code": "  constructor(string name, string symbol) ERC721Metadata(name, symbol)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 878,
          "vulnerability_to_line": null,
          "vulnerability_code": "  constructor(string name, string symbol) ERC721Metadata(name, symbol)\n",
          "message": null
        }
      ]
    },
    "oyente": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "Integer Overflow",
          "vulnerability_from_line": 452,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function safeTransferFrom(\n",
          "message": null
        },
        {
          "name": "Integer Overflow",
          "vulnerability_from_line": 662,
          "vulnerability_to_line": null,
          "vulnerability_code": "    return _ownedTokens[owner][index];\n",
          "message": null
        },
        {
          "name": "Integer Overflow",
          "vulnerability_from_line": 662,
          "vulnerability_to_line": null,
          "vulnerability_code": "    return _ownedTokens[owner][index];\n",
          "message": null
        },
        {
          "name": "Integer Underflow",
          "vulnerability_from_line": 817,
          "vulnerability_to_line": null,
          "vulnerability_code": "    return _name;\n",
          "message": null
        },
        {
          "name": "Integer Overflow",
          "vulnerability_from_line": 452,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function safeTransferFrom(\n",
          "message": null
        },
        {
          "name": "Integer Underflow",
          "vulnerability_from_line": 817,
          "vulnerability_to_line": null,
          "vulnerability_code": "    return _name;\n",
          "message": null
        }
      ]
    },
    "mythril": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": []
    },
    "osiris": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": []
    }
  }
}