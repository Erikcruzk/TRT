{
  "smartbugs_completed": true,
  "analyzer_results": {
    "semgrep": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 390,
          "vulnerability_to_line": null,
          "vulnerability_code": "            balances[id][_from] = balances[id][_from].sub(value);\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 390,
          "vulnerability_to_line": null,
          "vulnerability_code": "            balances[id][_from] = balances[id][_from].sub(value);\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 391,
          "vulnerability_to_line": null,
          "vulnerability_code": "            balances[id][_to]   = value.add(balances[id][_to]);\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 391,
          "vulnerability_to_line": null,
          "vulnerability_code": "            balances[id][_to]   = value.add(balances[id][_to]);\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 436,
          "vulnerability_to_line": null,
          "vulnerability_code": "            balances_[i] = balances[_ids[i]][_owners[i]];\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 384,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 i = 0; i < _ids.length; ++i) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 435,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 i = 0; i < _owners.length; ++i) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 343,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_to != address(0x0), \"_to must be non-zero.\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 344,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_from == msg.sender || operatorApproval[_from][msg.sender] == true, \"Need operator approval for 3rd party transfers.\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 380,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_to != address(0x0), \"destination address must be non-zero.\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 381,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_ids.length == _values.length, \"_ids and _values array length must match.\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 382,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_from == msg.sender || operatorApproval[_from][msg.sender] == true, \"Need operator approval for 3rd party transfers.\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 473,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(ERC1155TokenReceiver(_to).onERC1155Received(_operator, _from, _id, _value, _data) == ERC1155_ACCEPTED, \"contract returned an unknown value from onERC1155Received\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 483,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(ERC1155TokenReceiver(_to).onERC1155BatchReceived(_operator, _from, _ids, _values, _data) == ERC1155_BATCH_ACCEPTED, \"contract returned an unknown value from onERC1155BatchReceived\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 344,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_from == msg.sender || operatorApproval[_from][msg.sender] == true, \"Need operator approval for 3rd party transfers.\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 380,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_to != address(0x0), \"destination address must be non-zero.\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 381,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_ids.length == _values.length, \"_ids and _values array length must match.\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 382,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_from == msg.sender || operatorApproval[_from][msg.sender] == true, \"Need operator approval for 3rd party transfers.\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 473,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(ERC1155TokenReceiver(_to).onERC1155Received(_operator, _from, _id, _value, _data) == ERC1155_ACCEPTED, \"contract returned an unknown value from onERC1155Received\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 483,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(ERC1155TokenReceiver(_to).onERC1155BatchReceived(_operator, _from, _ids, _values, _data) == ERC1155_BATCH_ACCEPTED, \"contract returned an unknown value from onERC1155BatchReceived\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        }
      ]
    },
    "slither": {
      "successfull_analysis": true,
      "errors": [
        "EXIT_CODE_40"
      ],
      "vulnerability_findings": [
        {
          "name": "constant-function",
          "vulnerability_from_line": 73,
          "vulnerability_to_line": 84,
          "vulnerability_code": "    function isContract(address account) internal view returns (bool) {\n\n        uint256 size;\n\n        // XXX Currently there is no better way to check if there is a contract in an address\n\n        // than to check the size of the code at that address.\n\n        // See https://ethereum.stackexchange.com/a/14016/36603\n\n        // for more details about how this works.\n\n        // TODO Check this again before the Serenity release, because all addresses will be\n\n        // contracts then.\n\n        // solium-disable-next-line security/no-inline-assembly\n\n        assembly { size := extcodesize(account) }\n\n        return size > 0;\n",
          "message": "Address.isContract (ERC1155.sol#73-84) is declared view but contains assembly code\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 73,
          "vulnerability_to_line": 84,
          "vulnerability_code": "    function isContract(address account) internal view returns (bool) {\n\n        uint256 size;\n\n        // XXX Currently there is no better way to check if there is a contract in an address\n\n        // than to check the size of the code at that address.\n\n        // See https://ethereum.stackexchange.com/a/14016/36603\n\n        // for more details about how this works.\n\n        // TODO Check this again before the Serenity release, because all addresses will be\n\n        // contracts then.\n\n        // solium-disable-next-line security/no-inline-assembly\n\n        assembly { size := extcodesize(account) }\n\n        return size > 0;\n",
          "message": "Address.isContract uses assembly (ERC1155.sol#73-84)\n\t- ERC1155.sol#82\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 459,
          "vulnerability_to_line": 461,
          "vulnerability_code": "    function isApprovedForAll(address _owner, address _operator) public view returns (bool) {\n\n        return operatorApproval[_owner][_operator];\n",
          "message": "ERC1155.isApprovedForAll (ERC1155.sol#459-461) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 273,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function isApprovedForAll(address _owner, address _operator) external view returns (bool);\n",
          "message": "IERC1155.isApprovedForAll (ERC1155.sol#273) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 313,
          "vulnerability_to_line": 323,
          "vulnerability_code": "    function supportsInterface(bytes4 _interfaceId)\n\n    public\n\n    view\n\n    returns (bool) {\n\n         if (_interfaceId == INTERFACE_SIGNATURE_ERC165 ||\n\n             _interfaceId == INTERFACE_SIGNATURE_ERC1155) {\n\n            return true;\n\n         }\n\n\n\n         return false;\n",
          "message": "ERC1155.supportsInterface (ERC1155.sol#313-323) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 157,
          "vulnerability_to_line": 160,
          "vulnerability_code": "    function supportsInterface(bytes4 _interfaceId)\n\n    external\n\n    view\n",
          "message": "ERC165.supportsInterface (ERC1155.sol#157-160) should be declared external\n"
        },
        {
          "name": "solc-version",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.0;\n",
          "message": "Detected issues with version pragma in ERC1155.sol:\n\t- pragma solidity^0.5.0 (ERC1155.sol#3): it allows old versions\n\t- pragma solidity^0.5.0 (ERC1155.sol#58): it allows old versions\n\t- pragma solidity^0.5.0 (ERC1155.sol#90): it allows old versions\n\t- pragma solidity^0.5.0 (ERC1155.sol#103): it allows old versions\n\t- pragma solidity^0.5.0 (ERC1155.sol#142): it allows old versions\n\t- pragma solidity^0.5.0 (ERC1155.sol#165): it allows old versions\n\t- pragma solidity^0.5.0 (ERC1155.sol#278): it allows old versions\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 341,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function safeTransferFrom(address _from, address _to, uint256 _id, uint256 _value, bytes calldata _data) external {\n",
          "message": "Parameter '_from' of ERC1155.safeTransferFrom (ERC1155.sol#341) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 341,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function safeTransferFrom(address _from, address _to, uint256 _id, uint256 _value, bytes calldata _data) external {\n",
          "message": "Parameter '_to' of ERC1155.safeTransferFrom (ERC1155.sol#341) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 341,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function safeTransferFrom(address _from, address _to, uint256 _id, uint256 _value, bytes calldata _data) external {\n",
          "message": "Parameter '_id' of ERC1155.safeTransferFrom (ERC1155.sol#341) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 341,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function safeTransferFrom(address _from, address _to, uint256 _id, uint256 _value, bytes calldata _data) external {\n",
          "message": "Parameter '_value' of ERC1155.safeTransferFrom (ERC1155.sol#341) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 341,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function safeTransferFrom(address _from, address _to, uint256 _id, uint256 _value, bytes calldata _data) external {\n",
          "message": "Parameter '_data' of ERC1155.safeTransferFrom (ERC1155.sol#341) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 377,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function safeBatchTransferFrom(address _from, address _to, uint256[] calldata _ids, uint256[] calldata _values, bytes calldata _data) external {\n",
          "message": "Parameter '_from' of ERC1155.safeBatchTransferFrom (ERC1155.sol#377) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 377,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function safeBatchTransferFrom(address _from, address _to, uint256[] calldata _ids, uint256[] calldata _values, bytes calldata _data) external {\n",
          "message": "Parameter '_to' of ERC1155.safeBatchTransferFrom (ERC1155.sol#377) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 377,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function safeBatchTransferFrom(address _from, address _to, uint256[] calldata _ids, uint256[] calldata _values, bytes calldata _data) external {\n",
          "message": "Parameter '_ids' of ERC1155.safeBatchTransferFrom (ERC1155.sol#377) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 377,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function safeBatchTransferFrom(address _from, address _to, uint256[] calldata _ids, uint256[] calldata _values, bytes calldata _data) external {\n",
          "message": "Parameter '_values' of ERC1155.safeBatchTransferFrom (ERC1155.sol#377) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 377,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function safeBatchTransferFrom(address _from, address _to, uint256[] calldata _ids, uint256[] calldata _values, bytes calldata _data) external {\n",
          "message": "Parameter '_data' of ERC1155.safeBatchTransferFrom (ERC1155.sol#377) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 415,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function balanceOf(address _owner, uint256 _id) external view returns (uint256) {\n",
          "message": "Parameter '_owner' of ERC1155.balanceOf (ERC1155.sol#415) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 415,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function balanceOf(address _owner, uint256 _id) external view returns (uint256) {\n",
          "message": "Parameter '_id' of ERC1155.balanceOf (ERC1155.sol#415) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 429,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function balanceOfBatch(address[] calldata _owners, uint256[] calldata _ids) external view returns (uint256[] memory) {\n",
          "message": "Parameter '_owners' of ERC1155.balanceOfBatch (ERC1155.sol#429) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 429,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function balanceOfBatch(address[] calldata _owners, uint256[] calldata _ids) external view returns (uint256[] memory) {\n",
          "message": "Parameter '_ids' of ERC1155.balanceOfBatch (ERC1155.sol#429) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 448,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setApprovalForAll(address _operator, bool _approved) external {\n",
          "message": "Parameter '_operator' of ERC1155.setApprovalForAll (ERC1155.sol#448) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 448,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setApprovalForAll(address _operator, bool _approved) external {\n",
          "message": "Parameter '_approved' of ERC1155.setApprovalForAll (ERC1155.sol#448) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 459,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function isApprovedForAll(address _owner, address _operator) public view returns (bool) {\n",
          "message": "Parameter '_owner' of ERC1155.isApprovedForAll (ERC1155.sol#459) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 459,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function isApprovedForAll(address _owner, address _operator) public view returns (bool) {\n",
          "message": "Parameter '_operator' of ERC1155.isApprovedForAll (ERC1155.sol#459) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 313,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function supportsInterface(bytes4 _interfaceId)\n",
          "message": "Parameter '_interfaceId' of ERC1155.supportsInterface (ERC1155.sol#313) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 465,
          "vulnerability_to_line": 474,
          "vulnerability_code": "    function _doSafeTransferAcceptanceCheck(address _operator, address _from, address _to, uint256 _id, uint256 _value, bytes memory _data) internal {\n\n\n\n        // If this was a hybrid standards solution you would have to check ERC165(_to).supportsInterface(0x4e2312e0) here but as this is a pure implementation of an ERC-1155 token set as recommended by\n\n        // the standard, it is not necessary. The below should revert in all failure cases i.e. _to isn't a receiver, or it is and either returns an unknown value or it reverts in the call to indicate non-acceptance.\n\n\n\n\n\n        // Note: if the below reverts in the onERC1155Received function of the _to address you will have an undefined revert reason returned rather than the one in the require test.\n\n        // If you want predictable revert reasons consider using low level _to.call() style instead so the revert does not bubble up and you can revert yourself on the ERC1155_ACCEPTED test.\n\n        require(ERC1155TokenReceiver(_to).onERC1155Received(_operator, _from, _id, _value, _data) == ERC1155_ACCEPTED, \"contract returned an unknown value from onERC1155Received\");\n",
          "message": "Function 'ERC1155._doSafeTransferAcceptanceCheck' (ERC1155.sol#465-474) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 465,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _doSafeTransferAcceptanceCheck(address _operator, address _from, address _to, uint256 _id, uint256 _value, bytes memory _data) internal {\n",
          "message": "Parameter '_operator' of ERC1155._doSafeTransferAcceptanceCheck (ERC1155.sol#465) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 465,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _doSafeTransferAcceptanceCheck(address _operator, address _from, address _to, uint256 _id, uint256 _value, bytes memory _data) internal {\n",
          "message": "Parameter '_from' of ERC1155._doSafeTransferAcceptanceCheck (ERC1155.sol#465) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 465,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _doSafeTransferAcceptanceCheck(address _operator, address _from, address _to, uint256 _id, uint256 _value, bytes memory _data) internal {\n",
          "message": "Parameter '_to' of ERC1155._doSafeTransferAcceptanceCheck (ERC1155.sol#465) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 465,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _doSafeTransferAcceptanceCheck(address _operator, address _from, address _to, uint256 _id, uint256 _value, bytes memory _data) internal {\n",
          "message": "Parameter '_id' of ERC1155._doSafeTransferAcceptanceCheck (ERC1155.sol#465) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 465,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _doSafeTransferAcceptanceCheck(address _operator, address _from, address _to, uint256 _id, uint256 _value, bytes memory _data) internal {\n",
          "message": "Parameter '_value' of ERC1155._doSafeTransferAcceptanceCheck (ERC1155.sol#465) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 465,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _doSafeTransferAcceptanceCheck(address _operator, address _from, address _to, uint256 _id, uint256 _value, bytes memory _data) internal {\n",
          "message": "Parameter '_data' of ERC1155._doSafeTransferAcceptanceCheck (ERC1155.sol#465) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 476,
          "vulnerability_to_line": 484,
          "vulnerability_code": "    function _doSafeBatchTransferAcceptanceCheck(address _operator, address _from, address _to, uint256[] memory _ids, uint256[] memory _values, bytes memory _data) internal {\n\n\n\n        // If this was a hybrid standards solution you would have to check ERC165(_to).supportsInterface(0x4e2312e0) here but as this is a pure implementation of an ERC-1155 token set as recommended by\n\n        // the standard, it is not necessary. The below should revert in all failure cases i.e. _to isn't a receiver, or it is and either returns an unknown value or it reverts in the call to indicate non-acceptance.\n\n\n\n        // Note: if the below reverts in the onERC1155BatchReceived function of the _to address you will have an undefined revert reason returned rather than the one in the require test.\n\n        // If you want predictable revert reasons consider using low level _to.call() style instead so the revert does not bubble up and you can revert yourself on the ERC1155_BATCH_ACCEPTED test.\n\n        require(ERC1155TokenReceiver(_to).onERC1155BatchReceived(_operator, _from, _ids, _values, _data) == ERC1155_BATCH_ACCEPTED, \"contract returned an unknown value from onERC1155BatchReceived\");\n",
          "message": "Function 'ERC1155._doSafeBatchTransferAcceptanceCheck' (ERC1155.sol#476-484) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 476,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _doSafeBatchTransferAcceptanceCheck(address _operator, address _from, address _to, uint256[] memory _ids, uint256[] memory _values, bytes memory _data) internal {\n",
          "message": "Parameter '_operator' of ERC1155._doSafeBatchTransferAcceptanceCheck (ERC1155.sol#476) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 476,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _doSafeBatchTransferAcceptanceCheck(address _operator, address _from, address _to, uint256[] memory _ids, uint256[] memory _values, bytes memory _data) internal {\n",
          "message": "Parameter '_from' of ERC1155._doSafeBatchTransferAcceptanceCheck (ERC1155.sol#476) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 476,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _doSafeBatchTransferAcceptanceCheck(address _operator, address _from, address _to, uint256[] memory _ids, uint256[] memory _values, bytes memory _data) internal {\n",
          "message": "Parameter '_to' of ERC1155._doSafeBatchTransferAcceptanceCheck (ERC1155.sol#476) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 476,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _doSafeBatchTransferAcceptanceCheck(address _operator, address _from, address _to, uint256[] memory _ids, uint256[] memory _values, bytes memory _data) internal {\n",
          "message": "Parameter '_ids' of ERC1155._doSafeBatchTransferAcceptanceCheck (ERC1155.sol#476) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 476,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _doSafeBatchTransferAcceptanceCheck(address _operator, address _from, address _to, uint256[] memory _ids, uint256[] memory _values, bytes memory _data) internal {\n",
          "message": "Parameter '_values' of ERC1155._doSafeBatchTransferAcceptanceCheck (ERC1155.sol#476) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 476,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _doSafeBatchTransferAcceptanceCheck(address _operator, address _from, address _to, uint256[] memory _ids, uint256[] memory _values, bytes memory _data) internal {\n",
          "message": "Parameter '_data' of ERC1155._doSafeBatchTransferAcceptanceCheck (ERC1155.sol#476) is not in mixedCase\n"
        }
      ]
    },
    "smartcheck": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 97,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bytes4 constant internal ERC1155_ACCEPTED = 0xf23a6e61; // bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 98,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bytes4 constant internal ERC1155_BATCH_ACCEPTED = 0xbc197c81; // bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 301,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bytes4 constant private INTERFACE_SIGNATURE_ERC165 = 0x01ffc9a7;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 311,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bytes4 constant private INTERFACE_SIGNATURE_ERC1155 = 0xd9b67a26;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 343,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_to != address(0x0), \"_to must be non-zero.\");\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 58,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 90,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 103,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 142,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 165,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 278,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 301,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bytes4 constant private INTERFACE_SIGNATURE_ERC165 = 0x01ffc9a7;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 311,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bytes4 constant private INTERFACE_SIGNATURE_ERC1155 = 0xd9b67a26;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SAFEMATH",
          "vulnerability_from_line": 287,
          "vulnerability_to_line": null,
          "vulnerability_code": "    using SafeMath for uint256;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
          "vulnerability_from_line": 73,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function isContract(address account) internal view returns (bool) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 137,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function onERC1155BatchReceived(address _operator, address _from, uint256[] calldata _ids, uint256[] calldata _values, bytes calldata _data) external returns(bytes4);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 241,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function safeBatchTransferFrom(address _from, address _to, uint256[] calldata _ids, uint256[] calldata _values, bytes calldata _data) external;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 377,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function safeBatchTransferFrom(address _from, address _to, uint256[] calldata _ids, uint256[] calldata _values, bytes calldata _data) external {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 137,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function onERC1155BatchReceived(address _operator, address _from, uint256[] calldata _ids, uint256[] calldata _values, bytes calldata _data) external returns(bytes4);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 137,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function onERC1155BatchReceived(address _operator, address _from, uint256[] calldata _ids, uint256[] calldata _values, bytes calldata _data) external returns(bytes4);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 137,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function onERC1155BatchReceived(address _operator, address _from, uint256[] calldata _ids, uint256[] calldata _values, bytes calldata _data) external returns(bytes4);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 137,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function onERC1155BatchReceived(address _operator, address _from, uint256[] calldata _ids, uint256[] calldata _values, bytes calldata _data) external returns(bytes4);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 137,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function onERC1155BatchReceived(address _operator, address _from, uint256[] calldata _ids, uint256[] calldata _values, bytes calldata _data) external returns(bytes4);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 241,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function safeBatchTransferFrom(address _from, address _to, uint256[] calldata _ids, uint256[] calldata _values, bytes calldata _data) external;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 241,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function safeBatchTransferFrom(address _from, address _to, uint256[] calldata _ids, uint256[] calldata _values, bytes calldata _data) external;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 241,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function safeBatchTransferFrom(address _from, address _to, uint256[] calldata _ids, uint256[] calldata _values, bytes calldata _data) external;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 241,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function safeBatchTransferFrom(address _from, address _to, uint256[] calldata _ids, uint256[] calldata _values, bytes calldata _data) external;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 377,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function safeBatchTransferFrom(address _from, address _to, uint256[] calldata _ids, uint256[] calldata _values, bytes calldata _data) external {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 377,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function safeBatchTransferFrom(address _from, address _to, uint256[] calldata _ids, uint256[] calldata _values, bytes calldata _data) external {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 377,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function safeBatchTransferFrom(address _from, address _to, uint256[] calldata _ids, uint256[] calldata _values, bytes calldata _data) external {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 377,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function safeBatchTransferFrom(address _from, address _to, uint256[] calldata _ids, uint256[] calldata _values, bytes calldata _data) external {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 380,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_to != address(0x0), \"destination address must be non-zero.\");\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 380,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_to != address(0x0), \"destination address must be non-zero.\");\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 380,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_to != address(0x0), \"destination address must be non-zero.\");\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 381,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_ids.length == _values.length, \"_ids and _values array length must match.\");\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 381,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_ids.length == _values.length, \"_ids and _values array length must match.\");\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 381,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_ids.length == _values.length, \"_ids and _values array length must match.\");\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 382,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_from == msg.sender || operatorApproval[_from][msg.sender] == true, \"Need operator approval for 3rd party transfers.\");\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 382,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_from == msg.sender || operatorApproval[_from][msg.sender] == true, \"Need operator approval for 3rd party transfers.\");\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 382,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_from == msg.sender || operatorApproval[_from][msg.sender] == true, \"Need operator approval for 3rd party transfers.\");\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 382,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_from == msg.sender || operatorApproval[_from][msg.sender] == true, \"Need operator approval for 3rd party transfers.\");\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 384,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 i = 0; i < _ids.length; ++i) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 384,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 i = 0; i < _ids.length; ++i) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 384,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 i = 0; i < _ids.length; ++i) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 384,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 i = 0; i < _ids.length; ++i) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 385,
          "vulnerability_to_line": null,
          "vulnerability_code": "            uint256 id = _ids[i];\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 386,
          "vulnerability_to_line": null,
          "vulnerability_code": "            uint256 value = _values[i];\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 390,
          "vulnerability_to_line": null,
          "vulnerability_code": "            balances[id][_from] = balances[id][_from].sub(value);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 390,
          "vulnerability_to_line": null,
          "vulnerability_code": "            balances[id][_from] = balances[id][_from].sub(value);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 390,
          "vulnerability_to_line": null,
          "vulnerability_code": "            balances[id][_from] = balances[id][_from].sub(value);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 390,
          "vulnerability_to_line": null,
          "vulnerability_code": "            balances[id][_from] = balances[id][_from].sub(value);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 391,
          "vulnerability_to_line": null,
          "vulnerability_code": "            balances[id][_to]   = value.add(balances[id][_to]);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 391,
          "vulnerability_to_line": null,
          "vulnerability_code": "            balances[id][_to]   = value.add(balances[id][_to]);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 391,
          "vulnerability_to_line": null,
          "vulnerability_code": "            balances[id][_to]   = value.add(balances[id][_to]);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 391,
          "vulnerability_to_line": null,
          "vulnerability_code": "            balances[id][_to]   = value.add(balances[id][_to]);\n",
          "message": null
        }
      ]
    },
    "oyente": {
      "successfull_analysis": false,
      "errors": [
        "exception (IndexError: pop from empty list)"
      ],
      "vulnerability_findings": []
    },
    "mythril": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "Exception State (SWC 110)",
          "vulnerability_from_line": 348,
          "vulnerability_to_line": null,
          "vulnerability_code": "        balances[_id][_from] = balances[_id][_from].sub(_value);\n",
          "message": "An assertion violation was triggered.\nIt is possible to trigger an assertion violation. Note that Solidity assert() statements should only be used to check invariants. Review the transaction trace generated for this issue and either make sure your program logic is correct, or use require() instead of assert() if your goal is to constrain user inputs or enforce preconditions. Remember to validate inputs from both callers (for instance, via passed arguments) and callees (for instance, via return values).\nClassification: SWC-110"
        }
      ]
    },
    "osiris": {
      "successfull_analysis": false,
      "errors": [
        "Solidity compilation failed"
      ],
      "vulnerability_findings": []
    }
  }
}