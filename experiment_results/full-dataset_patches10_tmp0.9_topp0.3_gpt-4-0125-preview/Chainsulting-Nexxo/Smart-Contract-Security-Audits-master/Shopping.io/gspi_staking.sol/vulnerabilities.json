{
  "smartbugs_completed": true,
  "analyzer_results": {
    "semgrep": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 281,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i=0;i<b.length;i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 282,
          "vulnerability_to_line": null,
          "vulnerability_code": "            number = number + uint(uint8(b[i]))*(2**(8*(b.length-(i+1))));\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "inefficient-state-variable-increment",
          "vulnerability_from_line": 215,
          "vulnerability_to_line": null,
          "vulnerability_code": "        totalPowerStaked += amount;\n",
          "message": "<x> += <y> costs more gas than <x> = <x> + <y> for state variables."
        },
        {
          "name": "inefficient-state-variable-increment",
          "vulnerability_from_line": 216,
          "vulnerability_to_line": null,
          "vulnerability_code": "        totalStakePower += stakePower;\n",
          "message": "<x> += <y> costs more gas than <x> = <x> + <y> for state variables."
        },
        {
          "name": "inefficient-state-variable-increment",
          "vulnerability_from_line": 255,
          "vulnerability_to_line": null,
          "vulnerability_code": "        profitPerShare += amount * magnitude / totalStakePower;\n",
          "message": "<x> += <y> costs more gas than <x> = <x> + <y> for state variables."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 193,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor() public {\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 194,
          "vulnerability_to_line": null,
          "vulnerability_code": "        stakingBonus[0] = StakingOption(7 days, 0);\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 195,
          "vulnerability_to_line": null,
          "vulnerability_code": "        stakingBonus[1] = StakingOption(14 days, 10);\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 196,
          "vulnerability_to_line": null,
          "vulnerability_code": "        stakingBonus[2] = StakingOption(30 days, 25);\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 197,
          "vulnerability_to_line": null,
          "vulnerability_code": "    }\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 270,
          "vulnerability_to_line": null,
          "vulnerability_code": "            Frozen memory freeze = playersFreezes[player][i];\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 269,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 i = 0; i < numListings; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 281,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i=0;i<b.length;i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 33,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(c >= a, \"SafeMath: addition overflow\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 87,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(c / a == b, \"SafeMath: multiplication overflow\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 200,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == admin, \"msg.sender is not authorized\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 208,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(token.transferFrom(player, address(this), amount), \"transferFrom failed on token contract. Are we approved?\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 211,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(stakingOptions.unlockEpoch > 0, \"unlockEpoch invalid\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 254,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(token.transferFrom(msg.sender, address(this), amount), \"transferFrom failed on token contract. Are we approved?\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 202,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(stakeBonus > 0 && stakeBonus <= 200);\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 264,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (startIndex == 0 && endIndex == 0) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 265,
          "vulnerability_to_line": null,
          "vulnerability_code": "            numListings = playersFreezes[player].length;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 266,
          "vulnerability_to_line": null,
          "vulnerability_code": "        }\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-prefix-decrement-not-postfix",
          "vulnerability_from_line": 242,
          "vulnerability_to_line": null,
          "vulnerability_code": "        playersFreezes[msg.sender].length--;\n",
          "message": "Consider using the prefix decrement expression whenever the return value is not needed. The prefix decrement expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 269,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 i = 0; i < numListings; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 281,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i=0;i<b.length;i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 87,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(c / a == b, \"SafeMath: multiplication overflow\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 208,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(token.transferFrom(player, address(this), amount), \"transferFrom failed on token contract. Are we approved?\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 254,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(token.transferFrom(msg.sender, address(this), amount), \"transferFrom failed on token contract. Are we approved?\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        }
      ]
    },
    "slither": {
      "successfull_analysis": true,
      "errors": [
        "EXIT_CODE_10"
      ],
      "vulnerability_findings": [
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 222,
          "vulnerability_to_line": 245,
          "vulnerability_code": "    function unstake(uint256 index) external {\n\n        uint256 playersFreezeCount = playersFreezes[msg.sender].length;\n\n        require(index < playersFreezeCount);\n\n        Frozen memory freeze = playersFreezes[msg.sender][index];\n\n        require(freeze.amount > 0);\n\n        require(freeze.unlockEpoch <= now);\n\n        \n\n        withdrawEarnings();\n\n        \n\n        uint256 stakePower = (freeze.amount * (100 + freeze.stakeBonus)) / 100;\n\n        totalPowerStaked -= freeze.amount;\n\n        totalStakePower -= stakePower;\n\n        playersStakePower[msg.sender] -= stakePower;\n\n        payoutsTo[msg.sender] -= (int256) (profitPerShare * stakePower);\n\n        \n\n        if (playersFreezeCount > 1) {\n\n            playersFreezes[msg.sender][index] = playersFreezes[msg.sender][playersFreezeCount - 1];\n\n        }\n\n        \n\n        delete playersFreezes[msg.sender][playersFreezeCount - 1];\n\n        playersFreezes[msg.sender].length--;\n\n        \n\n        token.transfer(msg.sender, freeze.amount);\n",
          "message": "Reentrancy in Lock.unstake (gspi_staking.sol#222-245):\n\tExternal calls:\n\t- withdrawEarnings() (gspi_staking.sol#229)\n\tState variables written after the call(s):\n\t- payoutsTo (gspi_staking.sol#235)\n\t- playersFreezes (gspi_staking.sol#238)\n\t- playersFreezes (gspi_staking.sol#241)\n\t- playersFreezes (gspi_staking.sol#242)\n\t- playersStakePower (gspi_staking.sol#234)\n"
        },
        {
          "name": "unused-return",
          "vulnerability_from_line": 222,
          "vulnerability_to_line": 245,
          "vulnerability_code": "    function unstake(uint256 index) external {\n\n        uint256 playersFreezeCount = playersFreezes[msg.sender].length;\n\n        require(index < playersFreezeCount);\n\n        Frozen memory freeze = playersFreezes[msg.sender][index];\n\n        require(freeze.amount > 0);\n\n        require(freeze.unlockEpoch <= now);\n\n        \n\n        withdrawEarnings();\n\n        \n\n        uint256 stakePower = (freeze.amount * (100 + freeze.stakeBonus)) / 100;\n\n        totalPowerStaked -= freeze.amount;\n\n        totalStakePower -= stakePower;\n\n        playersStakePower[msg.sender] -= stakePower;\n\n        payoutsTo[msg.sender] -= (int256) (profitPerShare * stakePower);\n\n        \n\n        if (playersFreezeCount > 1) {\n\n            playersFreezes[msg.sender][index] = playersFreezes[msg.sender][playersFreezeCount - 1];\n\n        }\n\n        \n\n        delete playersFreezes[msg.sender][playersFreezeCount - 1];\n\n        playersFreezes[msg.sender].length--;\n\n        \n\n        token.transfer(msg.sender, freeze.amount);\n",
          "message": "Lock.unstake (gspi_staking.sol#222-245) does not use the value returned by external calls:\n\t-token.transfer(msg.sender,freeze.amount) (gspi_staking.sol#244)\n"
        },
        {
          "name": "unused-return",
          "vulnerability_from_line": 247,
          "vulnerability_to_line": 251,
          "vulnerability_code": "    function withdrawEarnings() public {\n\n        uint256 dividends = dividendsOf(msg.sender);\n\n        payoutsTo[msg.sender] += (int256) (dividends * magnitude);\n\n        token.transfer(msg.sender, dividends);\n",
          "message": "Lock.withdrawEarnings (gspi_staking.sol#247-251) does not use the value returned by external calls:\n\t-token.transfer(msg.sender,dividends) (gspi_staking.sol#250)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 253,
          "vulnerability_to_line": 256,
          "vulnerability_code": "    function distributeDivs(uint256 amount) external {\n\n        require(token.transferFrom(msg.sender, address(this), amount), \"transferFrom failed on token contract. Are we approved?\");\n\n        profitPerShare += amount * magnitude / totalStakePower;\n",
          "message": "Reentrancy in Lock.distributeDivs (gspi_staking.sol#253-256):\n\tExternal calls:\n\t- require(bool,string)(token.transferFrom(msg.sender,address(this),amount),transferFrom failed on token contract. Are we approved?) (gspi_staking.sol#254)\n\tState variables written after the call(s):\n\t- profitPerShare (gspi_staking.sol#255)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 206,
          "vulnerability_to_line": 220,
          "vulnerability_code": "    function stake(address player, uint256 amount, bytes calldata data) external {\n\n        require(amount >= 1 * (10 ** 18));\n\n        require(token.transferFrom(player, address(this), amount), \"transferFrom failed on token contract. Are we approved?\");\n\n        \n\n        StakingOption memory stakingOptions = stakingBonus[bytesToUint(data)];\n\n        require(stakingOptions.unlockEpoch > 0, \"unlockEpoch invalid\");\n\n        uint256 stakeBonus = stakingOptions.stakeBonus;\n\n        uint256 unlockEpoch = now + stakingOptions.unlockEpoch;\n\n        uint256 stakePower = (amount * (100 + stakeBonus)) / 100;\n\n        totalPowerStaked += amount;\n\n        totalStakePower += stakePower;\n\n        playersStakePower[player] += stakePower;\n\n        payoutsTo[player] += (int256) (profitPerShare * stakePower);\n\n        playersFreezes[player].push(Frozen(uint128(amount), uint64(unlockEpoch), uint32(stakeBonus)));\n",
          "message": "Reentrancy in Lock.stake (gspi_staking.sol#206-220):\n\tExternal calls:\n\t- require(bool,string)(token.transferFrom(player,address(this),amount),transferFrom failed on token contract. Are we approved?) (gspi_staking.sol#208)\n\tState variables written after the call(s):\n\t- payoutsTo (gspi_staking.sol#218)\n\t- playersFreezes (gspi_staking.sol#219)\n\t- playersStakePower (gspi_staking.sol#217)\n\t- totalPowerStaked (gspi_staking.sol#215)\n\t- totalStakePower (gspi_staking.sol#216)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 222,
          "vulnerability_to_line": 245,
          "vulnerability_code": "    function unstake(uint256 index) external {\n\n        uint256 playersFreezeCount = playersFreezes[msg.sender].length;\n\n        require(index < playersFreezeCount);\n\n        Frozen memory freeze = playersFreezes[msg.sender][index];\n\n        require(freeze.amount > 0);\n\n        require(freeze.unlockEpoch <= now);\n\n        \n\n        withdrawEarnings();\n\n        \n\n        uint256 stakePower = (freeze.amount * (100 + freeze.stakeBonus)) / 100;\n\n        totalPowerStaked -= freeze.amount;\n\n        totalStakePower -= stakePower;\n\n        playersStakePower[msg.sender] -= stakePower;\n\n        payoutsTo[msg.sender] -= (int256) (profitPerShare * stakePower);\n\n        \n\n        if (playersFreezeCount > 1) {\n\n            playersFreezes[msg.sender][index] = playersFreezes[msg.sender][playersFreezeCount - 1];\n\n        }\n\n        \n\n        delete playersFreezes[msg.sender][playersFreezeCount - 1];\n\n        playersFreezes[msg.sender].length--;\n\n        \n\n        token.transfer(msg.sender, freeze.amount);\n",
          "message": "Reentrancy in Lock.unstake (gspi_staking.sol#222-245):\n\tExternal calls:\n\t- withdrawEarnings() (gspi_staking.sol#229)\n\tState variables written after the call(s):\n\t- totalPowerStaked (gspi_staking.sol#232)\n\t- totalStakePower (gspi_staking.sol#233)\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 262,
          "vulnerability_to_line": 277,
          "vulnerability_code": "    function getPlayersFreezings(address player, uint256 startIndex, uint256 endIndex) public view returns (uint256[3][] memory) {\n\n        uint256 numListings = (endIndex - startIndex) + 1;\n\n        if (startIndex == 0 && endIndex == 0) {\n\n            numListings = playersFreezes[player].length;\n\n        }\n\n\n\n        uint256[3][] memory freezeData = new uint256[3][](numListings);\n\n        for (uint256 i = 0; i < numListings; i++) {\n\n            Frozen memory freeze = playersFreezes[player][i];\n\n            freezeData[i][0] = freeze.amount;\n\n            freezeData[i][1] = freeze.unlockEpoch;\n\n            freezeData[i][2] = freeze.stakeBonus;\n\n        }\n\n\n\n        return (freezeData);\n",
          "message": "Lock.getPlayersFreezings (gspi_staking.sol#262-277) should be declared external\n"
        },
        {
          "name": "solc-version",
          "vulnerability_from_line": 5,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity 0.5.13;\n",
          "message": "Detected issues with version pragma in gspi_staking.sol:\n\t- pragma solidity0.5.13 (gspi_staking.sol#5): it allows old versions\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 166,
          "vulnerability_to_line": null,
          "vulnerability_code": "    ERC20 constant token = ERC20(0xB42e1c3902b85b410334f5fff79cDc51fBeE6950);\n",
          "message": "Constant 'Lock.token' (gspi_staking.sol#166) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 169,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint256 constant internal magnitude = 2 ** 64;\n",
          "message": "Constant 'Lock.magnitude' (gspi_staking.sol#169) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        }
      ]
    },
    "smartcheck": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 166,
          "vulnerability_to_line": null,
          "vulnerability_code": "    ERC20 constant token = ERC20(0xB42e1c3902b85b410334f5fff79cDc51fBeE6950);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ARRAY_LENGTH_MANIPULATION",
          "vulnerability_from_line": 242,
          "vulnerability_to_line": null,
          "vulnerability_code": "        playersFreezes[msg.sender].length--;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 281,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i=0;i<b.length;i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 269,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 i = 0; i < numListings; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 281,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i=0;i<b.length;i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SAFEMATH",
          "vulnerability_from_line": 164,
          "vulnerability_to_line": null,
          "vulnerability_code": "    using SafeMath for uint256;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 166,
          "vulnerability_to_line": null,
          "vulnerability_code": "    ERC20 constant token = ERC20(0xB42e1c3902b85b410334f5fff79cDc51fBeE6950);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 168,
          "vulnerability_to_line": null,
          "vulnerability_code": "    address admin = msg.sender;\n",
          "message": null
        }
      ]
    },
    "oyente": {
      "successfull_analysis": false,
      "errors": [
        "exception (RuntimeError: Source map error, unknown name(SHR) or instr_name(INVALID))"
      ],
      "vulnerability_findings": []
    },
    "mythril": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "Integer Arithmetic Bugs (SWC 101)",
          "vulnerability_from_line": 282,
          "vulnerability_to_line": null,
          "vulnerability_code": "            number = number + uint(uint8(b[i]))*(2**(8*(b.length-(i+1))));\n",
          "message": "The arithmetic operator can overflow.\nIt is possible to cause an integer overflow or underflow in the arithmetic operation. \nClassification: SWC-101"
        },
        {
          "name": "Integer Arithmetic Bugs (SWC 101)",
          "vulnerability_from_line": 282,
          "vulnerability_to_line": null,
          "vulnerability_code": "            number = number + uint(uint8(b[i]))*(2**(8*(b.length-(i+1))));\n",
          "message": "The arithmetic operator can overflow.\nIt is possible to cause an integer overflow or underflow in the arithmetic operation. \nClassification: SWC-101"
        },
        {
          "name": "Integer Arithmetic Bugs (SWC 101)",
          "vulnerability_from_line": 263,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint256 numListings = (endIndex - startIndex) + 1;\n",
          "message": "The arithmetic operator can underflow.\nIt is possible to cause an integer overflow or underflow in the arithmetic operation. \nClassification: SWC-101"
        },
        {
          "name": "Integer Arithmetic Bugs (SWC 101)",
          "vulnerability_from_line": 263,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint256 numListings = (endIndex - startIndex) + 1;\n",
          "message": "The arithmetic operator can overflow.\nIt is possible to cause an integer overflow or underflow in the arithmetic operation. \nClassification: SWC-101"
        },
        {
          "name": "Exception State (SWC 110)",
          "vulnerability_from_line": null,
          "vulnerability_to_line": null,
          "vulnerability_code": null,
          "message": "An assertion violation was triggered.\nIt is possible to trigger an assertion violation. Note that Solidity assert() statements should only be used to check invariants. Review the transaction trace generated for this issue and either make sure your program logic is correct, or use require() instead of assert() if your goal is to constrain user inputs or enforce preconditions. Remember to validate inputs from both callers (for instance, via passed arguments) and callees (for instance, via return values). This issue is reported for internal compiler generated code.\nClassification: SWC-110"
        },
        {
          "name": "Exception State (SWC 110)",
          "vulnerability_from_line": 178,
          "vulnerability_to_line": null,
          "vulnerability_code": "    mapping(address => Frozen[]) public playersFreezes;\n",
          "message": "An assertion violation was triggered.\nIt is possible to trigger an assertion violation. Note that Solidity assert() statements should only be used to check invariants. Review the transaction trace generated for this issue and either make sure your program logic is correct, or use require() instead of assert() if your goal is to constrain user inputs or enforce preconditions. Remember to validate inputs from both callers (for instance, via passed arguments) and callees (for instance, via return values).\nClassification: SWC-110"
        }
      ]
    },
    "osiris": {
      "successfull_analysis": false,
      "errors": [
        "UNKNOWN INSTRUCTION: SHR"
      ],
      "vulnerability_findings": []
    }
  }
}