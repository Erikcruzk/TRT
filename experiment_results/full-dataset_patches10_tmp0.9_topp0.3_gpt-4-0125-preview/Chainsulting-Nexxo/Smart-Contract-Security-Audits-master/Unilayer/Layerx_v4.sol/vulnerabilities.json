{
  "smartbugs_completed": true,
  "analyzer_results": {
    "semgrep": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 294,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < _stakes[account].length; i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 354,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < customers.length; i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 376,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < _stakes[_address].length; i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 394,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < customers.length; i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "init-variables-with-default-value",
          "vulnerability_from_line": 108,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint public totalEthRewards = 0;\n",
          "message": "Uninitialized variables are assigned with the types default value. Explicitly initializing a variable with its default value costs unnecessary gas."
        },
        {
          "name": "init-variables-with-default-value",
          "vulnerability_from_line": 109,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint stakeNum = 0;\n",
          "message": "Uninitialized variables are assigned with the types default value. Explicitly initializing a variable with its default value costs unnecessary gas."
        },
        {
          "name": "init-variables-with-default-value",
          "vulnerability_from_line": 112,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bool public isPaused = false;\n",
          "message": "Uninitialized variables are assigned with the types default value. Explicitly initializing a variable with its default value costs unnecessary gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 158,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor(address payable _owner, address layer_token) public {\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 159,
          "vulnerability_to_line": null,
          "vulnerability_code": "        owner = _owner;\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 160,
          "vulnerability_to_line": null,
          "vulnerability_code": "        stakeCreator = owner;\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 161,
          "vulnerability_to_line": null,
          "vulnerability_code": "        symbol = \"LAYERX\";\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 162,
          "vulnerability_to_line": null,
          "vulnerability_code": "        name = \"UNILAYERX\";\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 163,
          "vulnerability_to_line": null,
          "vulnerability_code": "        decimals = 18;\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 164,
          "vulnerability_to_line": null,
          "vulnerability_code": "        _totalSupply = 40000 * 10**uint(decimals);\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 165,
          "vulnerability_to_line": null,
          "vulnerability_code": "        balances[owner] = _totalSupply;\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 166,
          "vulnerability_to_line": null,
          "vulnerability_code": "        emit Transfer(address(0), owner, _totalSupply);\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 167,
          "vulnerability_to_line": null,
          "vulnerability_code": "        stakes[0] = Stake(now, 0, 0, 0, 0);\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 294,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < _stakes[account].length; i++) {\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 295,
          "vulnerability_to_line": null,
          "vulnerability_code": "            stake = stake.add(uint256(_stakes[account][i].layerLocked));\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 354,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < customers.length; i++) {\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 355,
          "vulnerability_to_line": null,
          "vulnerability_code": "            uint256 _amountAge = _getAmountAge(customers[i], stake.end);\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 358,
          "vulnerability_to_line": null,
          "vulnerability_code": "                Rewards memory rwds = rewards[customers[i]];\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 358,
          "vulnerability_to_line": null,
          "vulnerability_code": "                Rewards memory rwds = rewards[customers[i]];\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 361,
          "vulnerability_to_line": null,
          "vulnerability_code": "                rewards[customers[i]] = rwds;\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 361,
          "vulnerability_to_line": null,
          "vulnerability_code": "                rewards[customers[i]] = rwds;\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 376,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < _stakes[_address].length; i++) {\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 379,
          "vulnerability_to_line": null,
          "vulnerability_code": "            if(_stakes[_address][i].time < stake.start) {\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 382,
          "vulnerability_to_line": null,
          "vulnerability_code": "                nAmountSeconds = _now.sub(_stakes[_address][i].time);\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 385,
          "vulnerability_to_line": null,
          "vulnerability_code": "            _amountAge = _amountAge.add(_stakes[_address][i].layerLocked.mul(nAmountSeconds).div(1 days));\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 394,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < customers.length; i++) {\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 396,
          "vulnerability_to_line": null,
          "vulnerability_code": "            _amountAge = _getAmountAge(customers[i], _now);\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 294,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < _stakes[account].length; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 354,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < customers.length; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 376,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < _stakes[_address].length; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 394,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < customers.length; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 18,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(c / a == b,\"Calculation error\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 27,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(b > 0,\"Calculation error\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 37,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(b <= a,\"Calculation error\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 47,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(c >= a,\"Calculation error\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 56,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(b != 0,\"Calculation error\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 87,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_newOwner != address(0), \"Ownable: new owner is the zero address\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 140,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(isPaused == false, \"This contract was paused by the owner!\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 145,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(index <= stakeNum, 'This stake does not exist.');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 224,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(value > 0, \"Invalid Amount.\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 225,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_totalSupply >= value, \"Invalid account state.\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 226,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(balances[owner] >= value, \"Invalid account balances state.\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 237,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_stakeCreator != address(0), 'Do not use 0 address');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 262,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(amount > 0, 'Payment must be greater than 0.');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 263,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(UNILAYER.balanceOf(msg.sender) >= amount, 'Holder does not have enough tokens.');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 264,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(UNILAYER.allowance(msg.sender, address(this)) >= amount, 'Call Approve function firstly.');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 315,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(unlockAmount > 0, 'You do not have locked tokens.');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 316,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(UNILAYER.balanceOf(address(this))  >= unlockAmount, 'Insufficient account balance!');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 333,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == stakeCreator, 'You cannot call this function');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 336,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(now >= stake.start.add(stakePeriod), 'You cannot call this function until stakePeriod is over');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 414,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require((ethReward > 0 || layerxReward > 0), 'You have no any rewards to withdraw');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 415,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(balances[owner] >= layerxReward, 'Insufficient account balance!');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 416,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(address(this).balance >= ethReward,'Invalid account state, not enough funds.');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 294,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < _stakes[account].length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 354,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < customers.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 365,
          "vulnerability_to_line": null,
          "vulnerability_code": "        stakeNum++;\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 376,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < _stakes[_address].length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 394,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < customers.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 87,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_newOwner != address(0), \"Ownable: new owner is the zero address\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 140,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(isPaused == false, \"This contract was paused by the owner!\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 263,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(UNILAYER.balanceOf(msg.sender) >= amount, 'Holder does not have enough tokens.');\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 336,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(now >= stake.start.add(stakePeriod), 'You cannot call this function until stakePeriod is over');\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 414,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require((ethReward > 0 || layerxReward > 0), 'You have no any rewards to withdraw');\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 416,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(address(this).balance >= ethReward,'Invalid account state, not enough funds.');\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        }
      ]
    },
    "slither": {
      "successfull_analysis": true,
      "errors": [
        "EXIT_CODE_42"
      ],
      "vulnerability_findings": [
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 312,
          "vulnerability_to_line": 327,
          "vulnerability_code": "    function unlock() external paused {\n\n        uint256 unlockAmount = stakeOf(msg.sender);\n\n\n\n        require(unlockAmount > 0, 'You do not have locked tokens.');\n\n        require(UNILAYER.balanceOf(address(this))  >= unlockAmount, 'Insufficient account balance!');\n\n\n\n        Stake memory stake = stakes[stakeNum];\n\n        stake.layerLockedTotal = stake.layerLockedTotal.sub(unlockAmount);\n\n        stakes[stakeNum] = stake;\n\n\n\n        UNILAYER.transfer(msg.sender, unlockAmount);\n\n        delete _stakes[msg.sender];\n\n        regCustomer[msg.sender] = false;\n\n        \n\n        emit logUnlockedTokens(msg.sender, unlockAmount, block.timestamp, stakeNum);\n",
          "message": "Reentrancy in Layerx.unlock (Layerx_v4.sol#312-327):\n\tExternal calls:\n\t- require(bool,string)(UNILAYER.balanceOf(address(this)) >= unlockAmount,Insufficient account balance!) (Layerx_v4.sol#316)\n\t- UNILAYER.transfer(msg.sender,unlockAmount) (Layerx_v4.sol#322)\n\tState variables written after the call(s):\n\t- _stakes (Layerx_v4.sol#323)\n"
        },
        {
          "name": "uninitialized-local",
          "vulnerability_from_line": 269,
          "vulnerability_to_line": null,
          "vulnerability_code": "        StakeStruct memory newStake;\n",
          "message": "newStake in Layerx.lock (Layerx_v4.sol#269) is a local variable never initialiazed\n"
        },
        {
          "name": "unused-return",
          "vulnerability_from_line": 261,
          "vulnerability_to_line": 283,
          "vulnerability_code": "    function lock(uint amount) external paused {\n\n        require(amount > 0, 'Payment must be greater than 0.');\n\n        require(UNILAYER.balanceOf(msg.sender) >= amount, 'Holder does not have enough tokens.');\n\n        require(UNILAYER.allowance(msg.sender, address(this)) >= amount, 'Call Approve function firstly.');\n\n\n\n        UNILAYER.transferFrom(msg.sender, address(this), amount);\n\n\n\n        Stake memory stake = stakes[stakeNum];\n\n        StakeStruct memory newStake;\n\n        newStake.layerLocked = amount;\n\n        newStake.time = block.timestamp;\n\n        _stakes[msg.sender].push(newStake);\n\n\n\n        stake.layerLockedTotal = stake.layerLockedTotal.add(amount);\n\n        stakes[stakeNum] = stake;\n\n\n\n        if(!regCustomer[msg.sender]) {\n\n            customers.push(msg.sender);\n\n            regCustomer[msg.sender] = true;\n\n        }\n\n\n\n        emit logLockedTokens(msg.sender, amount, newStake.time, stakeNum);\n",
          "message": "Layerx.lock (Layerx_v4.sol#261-283) does not use the value returned by external calls:\n\t-UNILAYER.transferFrom(msg.sender,address(this),amount) (Layerx_v4.sol#266)\n"
        },
        {
          "name": "unused-return",
          "vulnerability_from_line": 312,
          "vulnerability_to_line": 327,
          "vulnerability_code": "    function unlock() external paused {\n\n        uint256 unlockAmount = stakeOf(msg.sender);\n\n\n\n        require(unlockAmount > 0, 'You do not have locked tokens.');\n\n        require(UNILAYER.balanceOf(address(this))  >= unlockAmount, 'Insufficient account balance!');\n\n\n\n        Stake memory stake = stakes[stakeNum];\n\n        stake.layerLockedTotal = stake.layerLockedTotal.sub(unlockAmount);\n\n        stakes[stakeNum] = stake;\n\n\n\n        UNILAYER.transfer(msg.sender, unlockAmount);\n\n        delete _stakes[msg.sender];\n\n        regCustomer[msg.sender] = false;\n\n        \n\n        emit logUnlockedTokens(msg.sender, unlockAmount, block.timestamp, stakeNum);\n",
          "message": "Layerx.unlock (Layerx_v4.sol#312-327) does not use the value returned by external calls:\n\t-UNILAYER.transfer(msg.sender,unlockAmount) (Layerx_v4.sol#322)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 261,
          "vulnerability_to_line": 283,
          "vulnerability_code": "    function lock(uint amount) external paused {\n\n        require(amount > 0, 'Payment must be greater than 0.');\n\n        require(UNILAYER.balanceOf(msg.sender) >= amount, 'Holder does not have enough tokens.');\n\n        require(UNILAYER.allowance(msg.sender, address(this)) >= amount, 'Call Approve function firstly.');\n\n\n\n        UNILAYER.transferFrom(msg.sender, address(this), amount);\n\n\n\n        Stake memory stake = stakes[stakeNum];\n\n        StakeStruct memory newStake;\n\n        newStake.layerLocked = amount;\n\n        newStake.time = block.timestamp;\n\n        _stakes[msg.sender].push(newStake);\n\n\n\n        stake.layerLockedTotal = stake.layerLockedTotal.add(amount);\n\n        stakes[stakeNum] = stake;\n\n\n\n        if(!regCustomer[msg.sender]) {\n\n            customers.push(msg.sender);\n\n            regCustomer[msg.sender] = true;\n\n        }\n\n\n\n        emit logLockedTokens(msg.sender, amount, newStake.time, stakeNum);\n",
          "message": "Reentrancy in Layerx.lock (Layerx_v4.sol#261-283):\n\tExternal calls:\n\t- require(bool,string)(UNILAYER.balanceOf(msg.sender) >= amount,Holder does not have enough tokens.) (Layerx_v4.sol#263)\n\t- require(bool,string)(UNILAYER.allowance(msg.sender,address(this)) >= amount,Call Approve function firstly.) (Layerx_v4.sol#264)\n\t- UNILAYER.transferFrom(msg.sender,address(this),amount) (Layerx_v4.sol#266)\n\tState variables written after the call(s):\n\t- _stakes (Layerx_v4.sol#272)\n\t- customers (Layerx_v4.sol#278)\n\t- regCustomer (Layerx_v4.sol#279)\n\t- stakes (Layerx_v4.sol#275)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 312,
          "vulnerability_to_line": 327,
          "vulnerability_code": "    function unlock() external paused {\n\n        uint256 unlockAmount = stakeOf(msg.sender);\n\n\n\n        require(unlockAmount > 0, 'You do not have locked tokens.');\n\n        require(UNILAYER.balanceOf(address(this))  >= unlockAmount, 'Insufficient account balance!');\n\n\n\n        Stake memory stake = stakes[stakeNum];\n\n        stake.layerLockedTotal = stake.layerLockedTotal.sub(unlockAmount);\n\n        stakes[stakeNum] = stake;\n\n\n\n        UNILAYER.transfer(msg.sender, unlockAmount);\n\n        delete _stakes[msg.sender];\n\n        regCustomer[msg.sender] = false;\n\n        \n\n        emit logUnlockedTokens(msg.sender, unlockAmount, block.timestamp, stakeNum);\n",
          "message": "Reentrancy in Layerx.unlock (Layerx_v4.sol#312-327):\n\tExternal calls:\n\t- require(bool,string)(UNILAYER.balanceOf(address(this)) >= unlockAmount,Insufficient account balance!) (Layerx_v4.sol#316)\n\tState variables written after the call(s):\n\t- stakes (Layerx_v4.sol#320)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 312,
          "vulnerability_to_line": 327,
          "vulnerability_code": "    function unlock() external paused {\n\n        uint256 unlockAmount = stakeOf(msg.sender);\n\n\n\n        require(unlockAmount > 0, 'You do not have locked tokens.');\n\n        require(UNILAYER.balanceOf(address(this))  >= unlockAmount, 'Insufficient account balance!');\n\n\n\n        Stake memory stake = stakes[stakeNum];\n\n        stake.layerLockedTotal = stake.layerLockedTotal.sub(unlockAmount);\n\n        stakes[stakeNum] = stake;\n\n\n\n        UNILAYER.transfer(msg.sender, unlockAmount);\n\n        delete _stakes[msg.sender];\n\n        regCustomer[msg.sender] = false;\n\n        \n\n        emit logUnlockedTokens(msg.sender, unlockAmount, block.timestamp, stakeNum);\n",
          "message": "Reentrancy in Layerx.unlock (Layerx_v4.sol#312-327):\n\tExternal calls:\n\t- require(bool,string)(UNILAYER.balanceOf(address(this)) >= unlockAmount,Insufficient account balance!) (Layerx_v4.sol#316)\n\t- UNILAYER.transfer(msg.sender,unlockAmount) (Layerx_v4.sol#322)\n\tState variables written after the call(s):\n\t- regCustomer (Layerx_v4.sol#324)\n"
        },
        {
          "name": "constable-states",
          "vulnerability_from_line": 110,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint amtByDay = 27397260274000000000;\n",
          "message": "Layerx.amtByDay should be constant (Layerx_v4.sol#110)\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 86,
          "vulnerability_to_line": 90,
          "vulnerability_code": "    function transferOwnership(address payable _newOwner) public onlyOwner {\n\n        require(_newOwner != address(0), \"Ownable: new owner is the zero address\");\n\n        emit OwnershipTransferred(owner, _newOwner);\n\n        owner = _newOwner;\n",
          "message": "Owned.transferOwnership (Layerx_v4.sol#86-90) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 94,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function receiveApproval(address from, uint256 tokens, address token, bytes memory data) public;\n",
          "message": "ApproveAndCallFallBack.receiveApproval (Layerx_v4.sol#94) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 174,
          "vulnerability_to_line": 176,
          "vulnerability_code": "    function totalSupply() public view returns (uint) {\n\n        return _totalSupply.sub(balances[address(0)]);\n",
          "message": "Layerx.totalSupply (Layerx_v4.sol#174-176) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 66,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function totalSupply() external view returns (uint256);\n",
          "message": "IERC20.totalSupply (Layerx_v4.sol#66) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 67,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function balanceOf(address account) external view returns (uint256);\n",
          "message": "IERC20.balanceOf (Layerx_v4.sol#67) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 183,
          "vulnerability_to_line": 185,
          "vulnerability_code": "    function balanceOf(address tokenOwner) public view returns (uint balance) {\n\n        return balances[tokenOwner];\n",
          "message": "Layerx.balanceOf (Layerx_v4.sol#183-185) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 68,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function transfer(address recipient, uint256 amount) external returns (bool);\n",
          "message": "IERC20.transfer (Layerx_v4.sol#68) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 187,
          "vulnerability_to_line": 192,
          "vulnerability_code": "    function transfer(address to, uint tokens) public returns (bool success) {\n\n        balances[msg.sender] = balances[msg.sender].sub(tokens);\n\n        balances[to] = balances[to].add(tokens);\n\n        emit Transfer(msg.sender, to, tokens);\n\n        return true;\n",
          "message": "Layerx.transfer (Layerx_v4.sol#187-192) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 208,
          "vulnerability_to_line": 210,
          "vulnerability_code": "    function allowance(address tokenOwner, address spender) public view returns (uint remaining) {\n\n        return allowed[tokenOwner][spender];\n",
          "message": "Layerx.allowance (Layerx_v4.sol#208-210) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 69,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function allowance(address owner, address spender) external view returns (uint256);\n",
          "message": "IERC20.allowance (Layerx_v4.sol#69) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 194,
          "vulnerability_to_line": 198,
          "vulnerability_code": "    function approve(address spender, uint tokens) public returns (bool success) {\n\n        allowed[msg.sender][spender] = tokens;\n\n        emit Approval(msg.sender, spender, tokens);\n\n        return true;\n",
          "message": "Layerx.approve (Layerx_v4.sol#194-198) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 70,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function approve(address spender, uint256 amount) external returns (bool);\n",
          "message": "IERC20.approve (Layerx_v4.sol#70) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 71,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n",
          "message": "IERC20.transferFrom (Layerx_v4.sol#71) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 200,
          "vulnerability_to_line": 206,
          "vulnerability_code": "    function transferFrom(address from, address to, uint tokens) public returns (bool success) {\n\n        balances[from] = balances[from].sub(tokens);\n\n        allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);\n\n        balances[to] = balances[to].add(tokens);\n\n        emit Transfer(from, to, tokens);\n\n        return true;\n",
          "message": "Layerx.transferFrom (Layerx_v4.sol#200-206) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 212,
          "vulnerability_to_line": 217,
          "vulnerability_code": "    function approveAndCall(address spender, uint tokens, bytes memory data) public returns (bool success) {\n\n        allowed[msg.sender][spender] = tokens;\n\n        emit Approval(msg.sender, spender, tokens);\n\n        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, address(this), data);\n\n        return true;\n",
          "message": "Layerx.approveAndCall (Layerx_v4.sol#212-217) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 223,
          "vulnerability_to_line": 230,
          "vulnerability_code": "    function burn(uint256 value) public onlyOwner {\n\n        require(value > 0, \"Invalid Amount.\");\n\n        require(_totalSupply >= value, \"Invalid account state.\");\n\n        require(balances[owner] >= value, \"Invalid account balances state.\");\n\n        _totalSupply = _totalSupply.sub(value);\n\n        balances[owner] = balances[owner].sub(value);\n\n        emit Transfer(owner, address(0), value);\n",
          "message": "Layerx.burn (Layerx_v4.sol#223-230) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 305,
          "vulnerability_to_line": 307,
          "vulnerability_code": "    function getStakesCount(address holder) public view returns(uint) {\n\n        return _stakes[holder].length;\n",
          "message": "Layerx.getStakesCount (Layerx_v4.sol#305-307) should be declared external\n"
        },
        {
          "name": "solc-version",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.0;\n",
          "message": "Detected issues with version pragma in Layerx_v4.sol:\n\t- pragma solidity^0.5.0 (Layerx_v4.sol#3): it allows old versions\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 86,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function transferOwnership(address payable _newOwner) public onlyOwner {\n",
          "message": "Parameter '_newOwner' of Owned.transferOwnership (Layerx_v4.sol#86) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 134,
          "vulnerability_to_line": null,
          "vulnerability_code": "    event logLockedTokens(address holder, uint amountLocked, uint timeLocked, uint stakeNum);\n",
          "message": "Event 'Layerx.logLockedTokens' (Layerx_v4.sol#134) is not in CapWords\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 135,
          "vulnerability_to_line": null,
          "vulnerability_code": "    event logUnlockedTokens(address holder, uint amountUnlocked, uint timeUnlocked, uint stakeNum);\n",
          "message": "Event 'Layerx.logUnlockedTokens' (Layerx_v4.sol#135) is not in CapWords\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 136,
          "vulnerability_to_line": null,
          "vulnerability_code": "    event logWithdraw(address holder, uint layerx, uint eth, uint time);\n",
          "message": "Event 'Layerx.logWithdraw' (Layerx_v4.sol#136) is not in CapWords\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 137,
          "vulnerability_to_line": null,
          "vulnerability_code": "    event logCloseStake(address stakeOwner, uint stakeNum, uint timeClosed);\n",
          "message": "Event 'Layerx.logCloseStake' (Layerx_v4.sol#137) is not in CapWords\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 158,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor(address payable _owner, address layer_token) public {\n",
          "message": "Parameter '_owner' of Layerx. (Layerx_v4.sol#158) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 158,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor(address payable _owner, address layer_token) public {\n",
          "message": "Parameter 'layer_token' of Layerx. (Layerx_v4.sol#158) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 236,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setNewStakeCreator(address _stakeCreator) external onlyOwner {\n",
          "message": "Parameter '_stakeCreator' of Layerx.setNewStakeCreator (Layerx_v4.sol#236) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 370,
          "vulnerability_to_line": 389,
          "vulnerability_code": "    function _getAmountAge(address _address, uint256 _now) internal view returns (uint256) {\n\n        if (_stakes[_address].length <= 0) return 0;\n\n        \n\n        uint256 _amountAge = 0;\n\n        Stake memory stake = stakes[stakeNum];\n\n\n\n        for (uint i = 0; i < _stakes[_address].length; i++) {\n\n            uint256 nAmountSeconds = 0;\n\n            \n\n            if(_stakes[_address][i].time < stake.start) {\n\n                nAmountSeconds = _now.sub(stake.start);\n\n            } else {\n\n                nAmountSeconds = _now.sub(_stakes[_address][i].time);\n\n            }\n\n            \n\n            _amountAge = _amountAge.add(_stakes[_address][i].layerLocked.mul(nAmountSeconds).div(1 days));\n\n        }\n\n\n\n        return _amountAge;\n",
          "message": "Function 'Layerx._getAmountAge' (Layerx_v4.sol#370-389) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 370,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _getAmountAge(address _address, uint256 _now) internal view returns (uint256) {\n",
          "message": "Parameter '_address' of Layerx._getAmountAge (Layerx_v4.sol#370) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 370,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _getAmountAge(address _address, uint256 _now) internal view returns (uint256) {\n",
          "message": "Parameter '_now' of Layerx._getAmountAge (Layerx_v4.sol#370) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 391,
          "vulnerability_to_line": 404,
          "vulnerability_code": "    function _getSumAmountAge(uint256 _now) internal view returns (uint256) {\n\n        uint256 _sumAmountAge = 0;\n\n\n\n        for (uint i = 0; i < customers.length; i++) {\n\n            uint256 _amountAge = 0;\n\n            _amountAge = _getAmountAge(customers[i], _now);\n\n            \n\n            if(_amountAge > 0) {\n\n                _sumAmountAge = _sumAmountAge.add(_amountAge);\n\n            }\n\n        }\n\n\n\n        return _sumAmountAge;\n",
          "message": "Function 'Layerx._getSumAmountAge' (Layerx_v4.sol#391-404) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 391,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _getSumAmountAge(uint256 _now) internal view returns (uint256) {\n",
          "message": "Parameter '_now' of Layerx._getSumAmountAge (Layerx_v4.sol#391) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 107,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint _totalSupply;\n",
          "message": "Variable 'Layerx._totalSupply' (Layerx_v4.sol#107) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 150,
          "vulnerability_to_line": null,
          "vulnerability_code": "    mapping (address => StakeStruct[]) public _stakes;\n",
          "message": "Variable 'Layerx._stakes' (Layerx_v4.sol#150) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 156,
          "vulnerability_to_line": null,
          "vulnerability_code": "    IERC20 public UNILAYER;\n",
          "message": "Variable 'Layerx.UNILAYER' (Layerx_v4.sol#156) is not in mixedCase\n"
        }
      ]
    },
    "smartcheck": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "SOLIDITY_LOCKED_MONEY",
          "vulnerability_from_line": 76,
          "vulnerability_to_line": null,
          "vulnerability_code": "contract Owned {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_LOCKED_MONEY",
          "vulnerability_from_line": 101,
          "vulnerability_to_line": null,
          "vulnerability_code": "contract Layerx is IERC20, Owned {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SAFEMATH",
          "vulnerability_from_line": 102,
          "vulnerability_to_line": null,
          "vulnerability_code": "    using SafeMath for uint256;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 86,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function transferOwnership(address payable _newOwner) public onlyOwner {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 158,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor(address payable _owner, address layer_token) public {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 87,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_newOwner != address(0), \"Ownable: new owner is the zero address\");\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 87,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_newOwner != address(0), \"Ownable: new owner is the zero address\");\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 87,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_newOwner != address(0), \"Ownable: new owner is the zero address\");\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 88,
          "vulnerability_to_line": null,
          "vulnerability_code": "        emit OwnershipTransferred(owner, _newOwner);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 88,
          "vulnerability_to_line": null,
          "vulnerability_code": "        emit OwnershipTransferred(owner, _newOwner);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 89,
          "vulnerability_to_line": null,
          "vulnerability_code": "        owner = _newOwner;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 107,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint _totalSupply;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 109,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint stakeNum = 0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 110,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint amtByDay = 27397260274000000000;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 153,
          "vulnerability_to_line": null,
          "vulnerability_code": "    mapping (address => uint) balances;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 154,
          "vulnerability_to_line": null,
          "vulnerability_code": "    mapping (address => mapping(address => uint)) allowed;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 158,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor(address payable _owner, address layer_token) public {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 158,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor(address payable _owner, address layer_token) public {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 159,
          "vulnerability_to_line": null,
          "vulnerability_code": "        owner = _owner;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 160,
          "vulnerability_to_line": null,
          "vulnerability_code": "        stakeCreator = owner;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 161,
          "vulnerability_to_line": null,
          "vulnerability_code": "        symbol = \"LAYERX\";\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 162,
          "vulnerability_to_line": null,
          "vulnerability_code": "        name = \"UNILAYERX\";\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 163,
          "vulnerability_to_line": null,
          "vulnerability_code": "        decimals = 18;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 164,
          "vulnerability_to_line": null,
          "vulnerability_code": "        _totalSupply = 40000 * 10**uint(decimals);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 164,
          "vulnerability_to_line": null,
          "vulnerability_code": "        _totalSupply = 40000 * 10**uint(decimals);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 165,
          "vulnerability_to_line": null,
          "vulnerability_code": "        balances[owner] = _totalSupply;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 166,
          "vulnerability_to_line": null,
          "vulnerability_code": "        emit Transfer(address(0), owner, _totalSupply);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 166,
          "vulnerability_to_line": null,
          "vulnerability_code": "        emit Transfer(address(0), owner, _totalSupply);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 166,
          "vulnerability_to_line": null,
          "vulnerability_code": "        emit Transfer(address(0), owner, _totalSupply);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 166,
          "vulnerability_to_line": null,
          "vulnerability_code": "        emit Transfer(address(0), owner, _totalSupply);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 167,
          "vulnerability_to_line": null,
          "vulnerability_code": "        stakes[0] = Stake(now, 0, 0, 0, 0);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 167,
          "vulnerability_to_line": null,
          "vulnerability_code": "        stakes[0] = Stake(now, 0, 0, 0, 0);\n",
          "message": null
        }
      ]
    },
    "oyente": {
      "successfull_analysis": false,
      "errors": [
        "exception (RuntimeError: Source map error, unknown name(SHR) or instr_name(INVALID))"
      ],
      "vulnerability_findings": []
    },
    "mythril": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": []
    },
    "osiris": {
      "successfull_analysis": false,
      "errors": [
        "Solidity compilation failed"
      ],
      "vulnerability_findings": []
    }
  }
}