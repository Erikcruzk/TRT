{
  "smartbugs_completed": true,
  "analyzer_results": {
    "semgrep": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 405,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i; i < path.length - 1; i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 416,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = path.length - 1; i > 0; i--) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 526,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < _pairs.length; i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 546,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < _pairs.length; i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 489,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor() public {\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 490,
          "vulnerability_to_line": null,
          "vulnerability_code": "        governance = msg.sender;\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 491,
          "vulnerability_to_line": null,
          "vulnerability_code": "    }\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 526,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < _pairs.length; i++) {\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 527,
          "vulnerability_to_line": null,
          "vulnerability_code": "            if (_update(_pairs[i])) {\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 535,
          "vulnerability_to_line": null,
          "vulnerability_code": "            if (_update(_pairs[i])) {\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 546,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < _pairs.length; i++) {\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 547,
          "vulnerability_to_line": null,
          "vulnerability_code": "            if (workable(_pairs[i])) {\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 617,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    pairObservations[pair][i].price0Cumulative,\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 618,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    pairObservations[pair][nextIndex].price0Cumulative, pairObservations[pair][nextIndex].timeElapsed, amountIn);\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 618,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    pairObservations[pair][nextIndex].price0Cumulative, pairObservations[pair][nextIndex].timeElapsed, amountIn);\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 624,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    pairObservations[pair][i].price1Cumulative,\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 625,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    pairObservations[pair][nextIndex].price1Cumulative, pairObservations[pair][nextIndex].timeElapsed, amountIn);\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 625,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    pairObservations[pair][nextIndex].price1Cumulative, pairObservations[pair][nextIndex].timeElapsed, amountIn);\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 405,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i; i < path.length - 1; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 526,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < _pairs.length; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 546,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < _pairs.length; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 101,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(x != 0, 'FixedPoint: DIV_BY_ZERO');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 109,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(y == 0 || (z = uint(self._x) * y) / y == uint(self._x), \"FixedPoint: MULTIPLICATION_OVERFLOW\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 116,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(denominator > 0, \"FixedPoint: DIV_BY_ZERO\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 188,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(c >= a, \"SafeMath: addition overflow\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 252,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(c / a == b, \"SafeMath: multiplication overflow\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 351,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 353,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 376,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(amountA > 0, 'UniswapV2Library: INSUFFICIENT_AMOUNT');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 377,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(reserveA > 0 && reserveB > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 383,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(amountIn > 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 384,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 393,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(amountOut > 0, 'UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 394,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 402,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 413,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 441,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(KP3R.isKeeper(msg.sender), \"::isKeeper: keeper is not registered\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 446,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(KP3R.isKeeper(msg.sender), \"::isKeeper: keeper is not registered\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 459,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == governance, \"setGovernance: !gov\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 467,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == pendingGovernance, \"acceptGovernance: !pendingGov\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 503,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == governance, \"UniswapV2Oracle::add: !gov\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 505,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(!_known[pair], \"known\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 517,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(worked, \"UniswapV2Oracle: !work\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 522,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(worked, \"UniswapV2Oracle: !work\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 584,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_valid(pair, periodSize.mul(2)), \"UniswapV2Oracle::quote: stale prices\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 604,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_valid(pair, periodSize.mul(granularity)), \"UniswapV2Oracle::quote: stale prices\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 377,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(reserveA > 0 && reserveB > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 384,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 394,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-prefix-decrement-not-postfix",
          "vulnerability_from_line": 416,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = path.length - 1; i > 0; i--) {\n",
          "message": "Consider using the prefix decrement expression whenever the return value is not needed. The prefix decrement expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 405,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i; i < path.length - 1; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 526,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < _pairs.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 534,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (; i < length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 546,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < _pairs.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 614,
          "vulnerability_to_line": null,
          "vulnerability_code": "            for (; i < length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 621,
          "vulnerability_to_line": null,
          "vulnerability_code": "            for (; i < length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 109,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(y == 0 || (z = uint(self._x) * y) / y == uint(self._x), \"FixedPoint: MULTIPLICATION_OVERFLOW\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 252,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(c / a == b, \"SafeMath: multiplication overflow\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 351,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 376,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(amountA > 0, 'UniswapV2Library: INSUFFICIENT_AMOUNT');\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 377,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(reserveA > 0 && reserveB > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 383,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(amountIn > 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT');\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 384,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 393,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(amountOut > 0, 'UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT');\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 394,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 441,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(KP3R.isKeeper(msg.sender), \"::isKeeper: keeper is not registered\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 446,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(KP3R.isKeeper(msg.sender), \"::isKeeper: keeper is not registered\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 584,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_valid(pair, periodSize.mul(2)), \"UniswapV2Oracle::quote: stale prices\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 604,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_valid(pair, periodSize.mul(granularity)), \"UniswapV2Oracle::quote: stale prices\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        }
      ]
    },
    "slither": {
      "successfull_analysis": true,
      "errors": [
        "EXIT_CODE_29"
      ],
      "vulnerability_findings": [
        {
          "name": "incorrect-equality",
          "vulnerability_from_line": 582,
          "vulnerability_to_line": 600,
          "vulnerability_code": "    function current(address tokenIn, uint amountIn, address tokenOut) external view returns (uint amountOut) {\n\n        address pair = UniswapV2Library.pairFor(factory, tokenIn, tokenOut);\n\n        require(_valid(pair, periodSize.mul(2)), \"UniswapV2Oracle::quote: stale prices\");\n\n        (address token0,) = UniswapV2Library.sortTokens(tokenIn, tokenOut);\n\n\n\n        Observation memory _observation = lastObservation[pair];\n\n        (uint price0Cumulative, uint price1Cumulative,) = UniswapV2OracleLibrary.currentCumulativePrices(pair);\n\n        if (block.timestamp == _observation.timestamp) {\n\n            _observation = pairObservations[pair][pairObservations[pair].length-2];\n\n        }\n\n\n\n        uint timeElapsed = block.timestamp - _observation.timestamp;\n\n        timeElapsed = timeElapsed == 0 ? 1 : timeElapsed;\n\n        if (token0 == tokenIn) {\n\n            return computeAmountOut(_observation.price0Cumulative, price0Cumulative, timeElapsed, amountIn);\n\n        } else {\n\n            return computeAmountOut(_observation.price1Cumulative, price1Cumulative, timeElapsed, amountIn);\n\n        }\n",
          "message": "UniswapV2Oracle.current (UniswapV2Oracle.sol#582-600) uses a dangerous strict equality:\n\t- block.timestamp == _observation.timestamp\n\t- timeElapsed == 0\n"
        },
        {
          "name": "uninitialized-local",
          "vulnerability_from_line": 405,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i; i < path.length - 1; i++) {\n",
          "message": "i in UniswapV2Library.getAmountsOut (UniswapV2Oracle.sol#405) is a local variable never initialiazed\n"
        },
        {
          "name": "uninitialized-local",
          "vulnerability_from_line": 108,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint z;\n",
          "message": "z in FixedPoint.mul (UniswapV2Oracle.sol#108) is a local variable never initialiazed\n"
        },
        {
          "name": "timestamp",
          "vulnerability_from_line": 541,
          "vulnerability_to_line": 543,
          "vulnerability_code": "    function workable(address pair) public view returns (bool) {\n\n        return (block.timestamp - lastUpdated[pair]) > periodSize;\n",
          "message": "UniswapV2Oracle.workable (UniswapV2Oracle.sol#541-543) uses timestamp for comparisons\n\tDangerous comparisons:\n\t- (block.timestamp - lastUpdated[pair]) > periodSize (UniswapV2Oracle.sol#542)\n"
        },
        {
          "name": "timestamp",
          "vulnerability_from_line": 554,
          "vulnerability_to_line": 565,
          "vulnerability_code": "    function _update(address pair) internal returns (bool) {\n\n        // we only want to commit updates once per period (i.e. windowSize / granularity)\n\n        uint timeElapsed = block.timestamp - lastUpdated[pair];\n\n        if (timeElapsed > periodSize) {\n\n            (uint price0Cumulative, uint price1Cumulative,) = UniswapV2OracleLibrary.currentCumulativePrices(pair);\n\n            lastObservation[pair] = Observation(block.timestamp, price0Cumulative, price1Cumulative, timeElapsed);\n\n            pairObservations[pair].push(lastObservation[pair]);\n\n            lastUpdated[pair] = block.timestamp;\n\n            return true;\n\n        }\n\n        return false;\n",
          "message": "UniswapV2Oracle._update (UniswapV2Oracle.sol#554-565) uses timestamp for comparisons\n\tDangerous comparisons:\n\t- timeElapsed > periodSize (UniswapV2Oracle.sol#557-563)\n"
        },
        {
          "name": "timestamp",
          "vulnerability_from_line": 578,
          "vulnerability_to_line": 580,
          "vulnerability_code": "    function _valid(address pair, uint age) internal view returns (bool) {\n\n        return (block.timestamp - lastUpdated[pair]) <= age;\n",
          "message": "UniswapV2Oracle._valid (UniswapV2Oracle.sol#578-580) uses timestamp for comparisons\n\tDangerous comparisons:\n\t- (block.timestamp - lastUpdated[pair]) <= age (UniswapV2Oracle.sol#579)\n"
        },
        {
          "name": "timestamp",
          "vulnerability_from_line": 582,
          "vulnerability_to_line": 600,
          "vulnerability_code": "    function current(address tokenIn, uint amountIn, address tokenOut) external view returns (uint amountOut) {\n\n        address pair = UniswapV2Library.pairFor(factory, tokenIn, tokenOut);\n\n        require(_valid(pair, periodSize.mul(2)), \"UniswapV2Oracle::quote: stale prices\");\n\n        (address token0,) = UniswapV2Library.sortTokens(tokenIn, tokenOut);\n\n\n\n        Observation memory _observation = lastObservation[pair];\n\n        (uint price0Cumulative, uint price1Cumulative,) = UniswapV2OracleLibrary.currentCumulativePrices(pair);\n\n        if (block.timestamp == _observation.timestamp) {\n\n            _observation = pairObservations[pair][pairObservations[pair].length-2];\n\n        }\n\n\n\n        uint timeElapsed = block.timestamp - _observation.timestamp;\n\n        timeElapsed = timeElapsed == 0 ? 1 : timeElapsed;\n\n        if (token0 == tokenIn) {\n\n            return computeAmountOut(_observation.price0Cumulative, price0Cumulative, timeElapsed, amountIn);\n\n        } else {\n\n            return computeAmountOut(_observation.price1Cumulative, price1Cumulative, timeElapsed, amountIn);\n\n        }\n",
          "message": "UniswapV2Oracle.current (UniswapV2Oracle.sol#582-600) uses timestamp for comparisons\n\tDangerous comparisons:\n\t- timeElapsed == 0 (UniswapV2Oracle.sol#594)\n\t- block.timestamp == _observation.timestamp (UniswapV2Oracle.sol#589-591)\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 515,
          "vulnerability_to_line": 518,
          "vulnerability_code": "    function work() public upkeep {\n\n        bool worked = _updateAll();\n\n        require(worked, \"UniswapV2Oracle: !work\");\n",
          "message": "UniswapV2Oracle.work (UniswapV2Oracle.sol#515-518) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 520,
          "vulnerability_to_line": 523,
          "vulnerability_code": "    function workForFree() public keeper {\n\n        bool worked = _updateAll();\n\n        require(worked, \"UniswapV2Oracle: !work\");\n",
          "message": "UniswapV2Oracle.workForFree (UniswapV2Oracle.sol#520-523) should be declared external\n"
        },
        {
          "name": "solc-version",
          "vulnerability_from_line": 4,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.6.12;\n",
          "message": "Detected issues with version pragma in UniswapV2Oracle.sol:\n\t- pragma solidity^0.6.12 (UniswapV2Oracle.sol#4): it allows old versions\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 13,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function allPairs(uint) external view returns (address pair);\n",
          "message": "Parameter '' of IUniswapV2Factory.allPairs (UniswapV2Oracle.sol#13) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 18,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setFeeTo(address) external;\n",
          "message": "Parameter '' of IUniswapV2Factory.setFeeTo (UniswapV2Oracle.sol#18) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 19,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setFeeToSetter(address) external;\n",
          "message": "Parameter '' of IUniswapV2Factory.setFeeToSetter (UniswapV2Oracle.sol#19) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 37,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function DOMAIN_SEPARATOR() external view returns (bytes32);\n",
          "message": "Function 'IUniswapV2Pair.DOMAIN_SEPARATOR' (UniswapV2Oracle.sol#37) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 38,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function PERMIT_TYPEHASH() external pure returns (bytes32);\n",
          "message": "Function 'IUniswapV2Pair.PERMIT_TYPEHASH' (UniswapV2Oracle.sol#38) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 55,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function MINIMUM_LIQUIDITY() external pure returns (uint);\n",
          "message": "Function 'IUniswapV2Pair.MINIMUM_LIQUIDITY' (UniswapV2Oracle.sol#55) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 70,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function initialize(address, address) external;\n",
          "message": "Parameter '' of IUniswapV2Pair.initialize (UniswapV2Oracle.sol#70) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 70,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function initialize(address, address) external;\n",
          "message": "Parameter '_scope_0' of IUniswapV2Pair.initialize (UniswapV2Oracle.sol#70) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 77,
          "vulnerability_to_line": 79,
          "vulnerability_code": "    struct uq112x112 {\n\n        uint224 _x;\n",
          "message": "Struct 'FixedPoint.uq112x112' (UniswapV2Oracle.sol#77-79) is not in CapWords\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 83,
          "vulnerability_to_line": 85,
          "vulnerability_code": "    struct uq144x112 {\n\n        uint _x;\n",
          "message": "Struct 'FixedPoint.uq144x112' (UniswapV2Oracle.sol#83-85) is not in CapWords\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 424,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function isKeeper(address) external returns (bool);\n",
          "message": "Parameter '' of IKeep3rV1.isKeeper (UniswapV2Oracle.sol#424) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 458,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setGovernance(address _governance) external {\n",
          "message": "Parameter '_governance' of UniswapV2Oracle.setGovernance (UniswapV2Oracle.sol#458) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 525,
          "vulnerability_to_line": 531,
          "vulnerability_code": "    function _updateAll() internal returns (bool updated) {\n\n        for (uint i = 0; i < _pairs.length; i++) {\n\n            if (_update(_pairs[i])) {\n\n                updated = true;\n\n            }\n\n        }\n",
          "message": "Function 'UniswapV2Oracle._updateAll' (UniswapV2Oracle.sol#525-531) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 554,
          "vulnerability_to_line": 565,
          "vulnerability_code": "    function _update(address pair) internal returns (bool) {\n\n        // we only want to commit updates once per period (i.e. windowSize / granularity)\n\n        uint timeElapsed = block.timestamp - lastUpdated[pair];\n\n        if (timeElapsed > periodSize) {\n\n            (uint price0Cumulative, uint price1Cumulative,) = UniswapV2OracleLibrary.currentCumulativePrices(pair);\n\n            lastObservation[pair] = Observation(block.timestamp, price0Cumulative, price1Cumulative, timeElapsed);\n\n            pairObservations[pair].push(lastObservation[pair]);\n\n            lastUpdated[pair] = block.timestamp;\n\n            return true;\n\n        }\n\n        return false;\n",
          "message": "Function 'UniswapV2Oracle._update' (UniswapV2Oracle.sol#554-565) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 578,
          "vulnerability_to_line": 580,
          "vulnerability_code": "    function _valid(address pair, uint age) internal view returns (bool) {\n\n        return (block.timestamp - lastUpdated[pair]) <= age;\n",
          "message": "Function 'UniswapV2Oracle._valid' (UniswapV2Oracle.sol#578-580) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 473,
          "vulnerability_to_line": null,
          "vulnerability_code": "    address public constant factory = 0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f;\n",
          "message": "Constant 'UniswapV2Oracle.factory' (UniswapV2Oracle.sol#473) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 475,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint public constant periodSize = 1800;\n",
          "message": "Constant 'UniswapV2Oracle.periodSize' (UniswapV2Oracle.sol#475) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 477,
          "vulnerability_to_line": null,
          "vulnerability_code": "    address[] internal _pairs;\n",
          "message": "Variable 'UniswapV2Oracle._pairs' (UniswapV2Oracle.sol#477) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 478,
          "vulnerability_to_line": null,
          "vulnerability_code": "    mapping(address => bool) internal _known;\n",
          "message": "Variable 'UniswapV2Oracle._known' (UniswapV2Oracle.sol#478) is not in mixedCase\n"
        }
      ]
    },
    "smartcheck": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 471,
          "vulnerability_to_line": null,
          "vulnerability_code": "    IKeep3rV1 public constant KP3R = IKeep3rV1(0x1cEB5cB57C4D4E2b2433641b95Dd330A33185A44);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 473,
          "vulnerability_to_line": null,
          "vulnerability_code": "    address public constant factory = 0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXACT_TIME",
          "vulnerability_from_line": 589,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (block.timestamp == _observation.timestamp) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 405,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i; i < path.length - 1; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 526,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < _pairs.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 546,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < _pairs.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 526,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < _pairs.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 546,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < _pairs.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_OVERPOWERED_ROLE",
          "vulnerability_from_line": 458,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setGovernance(address _governance) external {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 4,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.6.12;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 87,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint8 private constant RESOLUTION = 112;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SAFEMATH",
          "vulnerability_from_line": 347,
          "vulnerability_to_line": null,
          "vulnerability_code": "    using SafeMath for uint;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SAFEMATH",
          "vulnerability_from_line": 431,
          "vulnerability_to_line": null,
          "vulnerability_code": "    using SafeMath for uint;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 59,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 65,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function burn(address to) external returns (uint amount0, uint amount1);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 143,
          "vulnerability_to_line": null,
          "vulnerability_code": "    ) internal view returns (uint price0Cumulative, uint price1Cumulative, uint32 blockTimestamp) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 350,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 368,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getReserves(address factory, address tokenA, address tokenB) internal view returns (uint reserveA, uint reserveB) {\n",
          "message": null
        }
      ]
    },
    "oyente": {
      "successfull_analysis": false,
      "errors": [
        "exception (IndexError: pop from empty list)"
      ],
      "vulnerability_findings": []
    },
    "mythril": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "Integer Arithmetic Bugs (SWC 101)",
          "vulnerability_from_line": 542,
          "vulnerability_to_line": null,
          "vulnerability_code": "        return (block.timestamp - lastUpdated[pair]) > periodSize;\n",
          "message": "The arithmetic operator can underflow.\nIt is possible to cause an integer overflow or underflow in the arithmetic operation. \nClassification: SWC-101"
        },
        {
          "name": "Dependence on predictable environment variable (SWC 116)",
          "vulnerability_from_line": 584,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_valid(pair, periodSize.mul(2)), \"UniswapV2Oracle::quote: stale prices\");\n",
          "message": "A control flow decision is made based on The block.timestamp environment variable.\nThe block.timestamp environment variable is used to determine a control flow decision. Note that the values of variables like coinbase, gaslimit, block number and timestamp are predictable and can be manipulated by a malicious miner. Also keep in mind that attackers know hashes of earlier blocks. Don't use any of those environment variables as sources of randomness and be aware that use of these variables introduces a certain level of trust into miners.\nClassification: SWC-116"
        },
        {
          "name": "Dependence on predictable environment variable (SWC 116)",
          "vulnerability_from_line": 589,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (block.timestamp == _observation.timestamp) {\n",
          "message": "A control flow decision is made based on The block.timestamp environment variable.\nThe block.timestamp environment variable is used to determine a control flow decision. Note that the values of variables like coinbase, gaslimit, block number and timestamp are predictable and can be manipulated by a malicious miner. Also keep in mind that attackers know hashes of earlier blocks. Don't use any of those environment variables as sources of randomness and be aware that use of these variables introduces a certain level of trust into miners.\nClassification: SWC-116"
        },
        {
          "name": "Exception State (SWC 110)",
          "vulnerability_from_line": 141,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function currentCumulativePrices(\n",
          "message": "An assertion violation was triggered.\nIt is possible to trigger an assertion violation. Note that Solidity assert() statements should only be used to check invariants. Review the transaction trace generated for this issue and either make sure your program logic is correct, or use require() instead of assert() if your goal is to constrain user inputs or enforce preconditions. Remember to validate inputs from both callers (for instance, via passed arguments) and callees (for instance, via return values).\nClassification: SWC-110"
        },
        {
          "name": "Dependence on predictable environment variable (SWC 116)",
          "vulnerability_from_line": 604,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_valid(pair, periodSize.mul(granularity)), \"UniswapV2Oracle::quote: stale prices\");\n",
          "message": "A control flow decision is made based on The block.timestamp environment variable.\nThe block.timestamp environment variable is used to determine a control flow decision. Note that the values of variables like coinbase, gaslimit, block number and timestamp are predictable and can be manipulated by a malicious miner. Also keep in mind that attackers know hashes of earlier blocks. Don't use any of those environment variables as sources of randomness and be aware that use of these variables introduces a certain level of trust into miners.\nClassification: SWC-116"
        },
        {
          "name": "Exception State (SWC 110)",
          "vulnerability_from_line": 216,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n",
          "message": "An assertion violation was triggered.\nIt is possible to trigger an assertion violation. Note that Solidity assert() statements should only be used to check invariants. Review the transaction trace generated for this issue and either make sure your program logic is correct, or use require() instead of assert() if your goal is to constrain user inputs or enforce preconditions. Remember to validate inputs from both callers (for instance, via passed arguments) and callees (for instance, via return values).\nClassification: SWC-110"
        },
        {
          "name": "Exception State (SWC 110)",
          "vulnerability_from_line": 485,
          "vulnerability_to_line": null,
          "vulnerability_code": "    mapping(address => Observation[]) public pairObservations;\n",
          "message": "An assertion violation was triggered.\nIt is possible to trigger an assertion violation. Note that Solidity assert() statements should only be used to check invariants. Review the transaction trace generated for this issue and either make sure your program logic is correct, or use require() instead of assert() if your goal is to constrain user inputs or enforce preconditions. Remember to validate inputs from both callers (for instance, via passed arguments) and callees (for instance, via return values).\nClassification: SWC-110"
        },
        {
          "name": "Multiple Calls in a Single Transaction (SWC 113)",
          "vulnerability_from_line": 146,
          "vulnerability_to_line": null,
          "vulnerability_code": "        price1Cumulative = IUniswapV2Pair(pair).price1CumulativeLast();\n",
          "message": "Multiple calls are executed in the same transaction.\nThis call is executed following another call within the same transaction. It is possible that the call never gets executed if a prior call fails permanently. This might be caused intentionally by a malicious callee. If possible, refactor the code such that each transaction only executes one external call or make sure that all callees can be trusted (i.e. they\u2019re part of your own codebase).\nClassification: SWC-113"
        },
        {
          "name": "Dependence on predictable environment variable (SWC 116)",
          "vulnerability_from_line": 150,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (blockTimestampLast != blockTimestamp) {\n",
          "message": "A control flow decision is made based on The block.timestamp environment variable.\nThe block.timestamp environment variable is used to determine a control flow decision. Note that the values of variables like coinbase, gaslimit, block number and timestamp are predictable and can be manipulated by a malicious miner. Also keep in mind that attackers know hashes of earlier blocks. Don't use any of those environment variables as sources of randomness and be aware that use of these variables introduces a certain level of trust into miners.\nClassification: SWC-116"
        }
      ]
    },
    "osiris": {
      "successfull_analysis": false,
      "errors": [
        "Solidity compilation failed"
      ],
      "vulnerability_findings": []
    }
  }
}