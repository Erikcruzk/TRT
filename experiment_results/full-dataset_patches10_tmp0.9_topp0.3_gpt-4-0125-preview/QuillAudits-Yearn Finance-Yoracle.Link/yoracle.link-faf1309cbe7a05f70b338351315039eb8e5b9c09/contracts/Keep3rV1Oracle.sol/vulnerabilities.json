{
  "smartbugs_completed": true,
  "analyzer_results": {
    "semgrep": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 414,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i; i < path.length - 1; i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 425,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = path.length - 1; i > 0; i--) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 586,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < _pairs.length; i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 607,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < _pairs.length; i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 800,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(uint i = 0; i < numbers.length; i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 806,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(i = 0; i < numbers.length; i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 546,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor() public {\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 547,
          "vulnerability_to_line": null,
          "vulnerability_code": "        governance = msg.sender;\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 548,
          "vulnerability_to_line": null,
          "vulnerability_code": "    }\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 586,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < _pairs.length; i++) {\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 587,
          "vulnerability_to_line": null,
          "vulnerability_code": "            if (_update(_pairs[i])) {\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 595,
          "vulnerability_to_line": null,
          "vulnerability_code": "            if (_update(_pairs[i])) {\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 607,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < _pairs.length; i++) {\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 608,
          "vulnerability_to_line": null,
          "vulnerability_code": "            if (workable(_pairs[i])) {\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 682,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    observations[pair][i].price0Cumulative,\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 683,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    observations[pair][nextIndex].price0Cumulative,\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 685,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    observations[pair][nextIndex].timestamp - observations[pair][i].timestamp, amountIn);\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 685,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    observations[pair][nextIndex].timestamp - observations[pair][i].timestamp, amountIn);\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 693,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    observations[pair][i].price1Cumulative,\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 694,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    observations[pair][nextIndex].price1Cumulative,\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 696,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    observations[pair][nextIndex].timestamp - observations[pair][i].timestamp, amountIn);\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 696,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    observations[pair][nextIndex].timestamp - observations[pair][i].timestamp, amountIn);\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 723,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    observations[pair][i].price0Cumulative,\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 724,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    observations[pair][nextIndex].price0Cumulative,\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 726,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    observations[pair][nextIndex].timestamp - observations[pair][i].timestamp, amountIn);\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 726,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    observations[pair][nextIndex].timestamp - observations[pair][i].timestamp, amountIn);\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 736,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    observations[pair][i].price1Cumulative,\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 737,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    observations[pair][nextIndex].price1Cumulative,\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 739,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    observations[pair][nextIndex].timestamp - observations[pair][i].timestamp, amountIn);\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 739,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    observations[pair][nextIndex].timestamp - observations[pair][i].timestamp, amountIn);\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 414,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i; i < path.length - 1; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 586,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < _pairs.length; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 607,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < _pairs.length; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 800,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(uint i = 0; i < numbers.length; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 102,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(x != 0, 'FixedPoint: DIV_BY_ZERO');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 112,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(y == 0 || (z = uint(self._x) * y) / y == uint(self._x), \"FixedPoint: MULTIPLICATION_OVERFLOW\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 119,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(denominator > 0, \"FixedPoint: DIV_BY_ZERO\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 194,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(c >= a, \"SafeMath: addition overflow\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 258,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(c / a == b, \"SafeMath: multiplication overflow\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 357,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 359,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 382,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(amountA > 0, 'UniswapV2Library: INSUFFICIENT_AMOUNT');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 383,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(reserveA > 0 && reserveB > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 390,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(amountIn > 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 391,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 401,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(amountOut > 0, 'UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 402,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 411,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 422,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 478,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(KP3R.isMinKeeper(msg.sender, minKeep, 0, 0), \"::isKeeper: keeper is not registered\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 484,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(KP3R.isMinKeeper(msg.sender, minKeep, 0, 0), \"::isKeeper: keeper is not registered\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 496,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == governance, \"setGovernance: !gov\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 505,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == governance, \"setGovernance: !gov\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 513,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == pendingGovernance, \"acceptGovernance: !pendingGov\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 560,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == governance, \"UniswapV2Oracle::add: !gov\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 562,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(!_known[pair], \"known\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 572,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(worked, \"UniswapV2Oracle: !work\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 577,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(worked, \"UniswapV2Oracle: !work\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 645,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_valid(pair, periodSize.mul(2)), \"UniswapV2Oracle::quote: stale prices\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 666,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_valid(pair, periodSize.mul(granularity)), \"UniswapV2Oracle::quote: stale prices\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 383,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(reserveA > 0 && reserveB > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 391,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 402,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-prefix-decrement-not-postfix",
          "vulnerability_from_line": 425,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = path.length - 1; i > 0; i--) {\n",
          "message": "Consider using the prefix decrement expression whenever the return value is not needed. The prefix decrement expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 414,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i; i < path.length - 1; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 586,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < _pairs.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 594,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (; i < length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 607,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < _pairs.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 678,
          "vulnerability_to_line": null,
          "vulnerability_code": "            for (; i < length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 688,
          "vulnerability_to_line": null,
          "vulnerability_code": "            for (; i < length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 800,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(uint i = 0; i < numbers.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 806,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(i = 0; i < numbers.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 112,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(y == 0 || (z = uint(self._x) * y) / y == uint(self._x), \"FixedPoint: MULTIPLICATION_OVERFLOW\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 258,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(c / a == b, \"SafeMath: multiplication overflow\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 357,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 382,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(amountA > 0, 'UniswapV2Library: INSUFFICIENT_AMOUNT');\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 383,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(reserveA > 0 && reserveB > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 390,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(amountIn > 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT');\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 391,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 401,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(amountOut > 0, 'UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT');\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 402,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 478,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(KP3R.isMinKeeper(msg.sender, minKeep, 0, 0), \"::isKeeper: keeper is not registered\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 484,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(KP3R.isMinKeeper(msg.sender, minKeep, 0, 0), \"::isKeeper: keeper is not registered\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 645,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_valid(pair, periodSize.mul(2)), \"UniswapV2Oracle::quote: stale prices\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 666,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_valid(pair, periodSize.mul(granularity)), \"UniswapV2Oracle::quote: stale prices\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "no-slippage-check",
          "vulnerability_from_line": 857,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint[] memory amounts = UNI.swapExactTokensForTokens(_amount, uint256(0), path, address(this), now.add(1800));\n",
          "message": "No slippage check in a Uniswap v2/v3 trade"
        }
      ]
    },
    "slither": {
      "successfull_analysis": true,
      "errors": [
        "EXIT_CODE_41"
      ],
      "vulnerability_findings": [
        {
          "name": "incorrect-equality",
          "vulnerability_from_line": 643,
          "vulnerability_to_line": 662,
          "vulnerability_code": "    function current(address tokenIn, uint amountIn, address tokenOut) external view returns (uint amountOut) {\n\n        address pair = UniswapV2Library.pairFor(factory, tokenIn, tokenOut);\n\n        require(_valid(pair, periodSize.mul(2)), \"UniswapV2Oracle::quote: stale prices\");\n\n        (address token0,) = UniswapV2Library.sortTokens(tokenIn, tokenOut);\n\n\n\n        Observation memory _observation = lastObservation(pair);\n\n        (uint price0Cumulative, uint price1Cumulative,) = UniswapV2OracleLibrary.currentCumulativePrices(pair);\n\n        if (block.timestamp == _observation.timestamp) {\n\n            _observation = observations[pair][observations[pair].length-2];\n\n        }\n\n\n\n        // SWC-Integer Overflow and Underflow: L651\n\n        uint timeElapsed = block.timestamp - _observation.timestamp;\n\n        timeElapsed = timeElapsed == 0 ? 1 : timeElapsed;\n\n        if (token0 == tokenIn) {\n\n            return computeAmountOut(_observation.price0Cumulative, price0Cumulative, timeElapsed, amountIn);\n\n        } else {\n\n            return computeAmountOut(_observation.price1Cumulative, price1Cumulative, timeElapsed, amountIn);\n\n        }\n",
          "message": "Keep3rV1Oracle.current (Keep3rV1Oracle.sol#643-662) uses a dangerous strict equality:\n\t- block.timestamp == _observation.timestamp\n\t- timeElapsed == 0\n"
        },
        {
          "name": "uninitialized-local",
          "vulnerability_from_line": 414,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i; i < path.length - 1; i++) {\n",
          "message": "i in UniswapV2Library.getAmountsOut (Keep3rV1Oracle.sol#414) is a local variable never initialiazed\n"
        },
        {
          "name": "uninitialized-local",
          "vulnerability_from_line": 110,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint z;\n",
          "message": "z in FixedPoint.mul (Keep3rV1Oracle.sol#110) is a local variable never initialiazed\n"
        },
        {
          "name": "unused-return",
          "vulnerability_from_line": 849,
          "vulnerability_to_line": 860,
          "vulnerability_code": "    function _swap(uint _amount) internal returns (uint) {\n\n        // SWC-Unchecked Call Return Value: L848\n\n        KP3R.approve(address(UNI), _amount);\n\n\n\n        address[] memory path = new address[](2);\n\n        path[0] = address(KP3R);\n\n        path[1] = address(WETH);\n\n\n\n        uint[] memory amounts = UNI.swapExactTokensForTokens(_amount, uint256(0), path, address(this), now.add(1800));\n\n        WETH.withdraw(amounts[1]);\n\n        return amounts[1];\n",
          "message": "Keep3rV1Oracle._swap (Keep3rV1Oracle.sol#849-860) does not use the value returned by external calls:\n\t-KP3R.approve(address(UNI),_amount) (Keep3rV1Oracle.sol#851)\n"
        },
        {
          "name": "timestamp",
          "vulnerability_from_line": 601,
          "vulnerability_to_line": 603,
          "vulnerability_code": "    function workable(address pair) public view returns (bool) {\n\n        return (block.timestamp - lastObservation(pair).timestamp) > periodSize;\n",
          "message": "Keep3rV1Oracle.workable (Keep3rV1Oracle.sol#601-603) uses timestamp for comparisons\n\tDangerous comparisons:\n\t- (block.timestamp - lastObservation(pair).timestamp) > periodSize (Keep3rV1Oracle.sol#602)\n"
        },
        {
          "name": "timestamp",
          "vulnerability_from_line": 615,
          "vulnerability_to_line": 625,
          "vulnerability_code": "    function _update(address pair) internal returns (bool) {\n\n        // we only want to commit updates once per period (i.e. windowSize / granularity)\n\n        Observation memory _point = lastObservation(pair);\n\n        uint timeElapsed = block.timestamp - _point.timestamp;\n\n        if (timeElapsed > periodSize) {\n\n            (uint price0Cumulative, uint price1Cumulative,) = UniswapV2OracleLibrary.currentCumulativePrices(pair);\n\n            observations[pair].push(Observation(block.timestamp, price0Cumulative, price1Cumulative));\n\n            return true;\n\n        }\n\n        return false;\n",
          "message": "Keep3rV1Oracle._update (Keep3rV1Oracle.sol#615-625) uses timestamp for comparisons\n\tDangerous comparisons:\n\t- timeElapsed > periodSize (Keep3rV1Oracle.sol#619-623)\n"
        },
        {
          "name": "timestamp",
          "vulnerability_from_line": 639,
          "vulnerability_to_line": 641,
          "vulnerability_code": "    function _valid(address pair, uint age) internal view returns (bool) {\n\n        return (block.timestamp - lastObservation(pair).timestamp) <= age;\n",
          "message": "Keep3rV1Oracle._valid (Keep3rV1Oracle.sol#639-641) uses timestamp for comparisons\n\tDangerous comparisons:\n\t- (block.timestamp - lastObservation(pair).timestamp) <= age (Keep3rV1Oracle.sol#640)\n"
        },
        {
          "name": "timestamp",
          "vulnerability_from_line": 643,
          "vulnerability_to_line": 662,
          "vulnerability_code": "    function current(address tokenIn, uint amountIn, address tokenOut) external view returns (uint amountOut) {\n\n        address pair = UniswapV2Library.pairFor(factory, tokenIn, tokenOut);\n\n        require(_valid(pair, periodSize.mul(2)), \"UniswapV2Oracle::quote: stale prices\");\n\n        (address token0,) = UniswapV2Library.sortTokens(tokenIn, tokenOut);\n\n\n\n        Observation memory _observation = lastObservation(pair);\n\n        (uint price0Cumulative, uint price1Cumulative,) = UniswapV2OracleLibrary.currentCumulativePrices(pair);\n\n        if (block.timestamp == _observation.timestamp) {\n\n            _observation = observations[pair][observations[pair].length-2];\n\n        }\n\n\n\n        // SWC-Integer Overflow and Underflow: L651\n\n        uint timeElapsed = block.timestamp - _observation.timestamp;\n\n        timeElapsed = timeElapsed == 0 ? 1 : timeElapsed;\n\n        if (token0 == tokenIn) {\n\n            return computeAmountOut(_observation.price0Cumulative, price0Cumulative, timeElapsed, amountIn);\n\n        } else {\n\n            return computeAmountOut(_observation.price1Cumulative, price1Cumulative, timeElapsed, amountIn);\n\n        }\n",
          "message": "Keep3rV1Oracle.current (Keep3rV1Oracle.sol#643-662) uses timestamp for comparisons\n\tDangerous comparisons:\n\t- timeElapsed == 0 (Keep3rV1Oracle.sol#656)\n\t- block.timestamp == _observation.timestamp (Keep3rV1Oracle.sol#650-652)\n"
        },
        {
          "name": "pragma",
          "vulnerability_from_line": 4,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.6.12;\n",
          "message": "Different versions of Solidity is used in Keep3rV1Oracle.sol:\n\t- Version used: ['ABIEncoderV2', '^0.6.12']\n\t- Keep3rV1Oracle.sol#4 declares pragma solidity^0.6.12\n\t- Keep3rV1Oracle.sol#5 declares pragma experimentalABIEncoderV2\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 570,
          "vulnerability_to_line": 573,
          "vulnerability_code": "    function work() public upkeep {\n\n        bool worked = _updateAll();\n\n        require(worked, \"UniswapV2Oracle: !work\");\n",
          "message": "Keep3rV1Oracle.work (Keep3rV1Oracle.sol#570-573) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 575,
          "vulnerability_to_line": 578,
          "vulnerability_code": "    function workForFree() public keeper {\n\n        bool worked = _updateAll();\n\n        require(worked, \"UniswapV2Oracle: !work\");\n",
          "message": "Keep3rV1Oracle.workForFree (Keep3rV1Oracle.sol#575-578) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 838,
          "vulnerability_to_line": 845,
          "vulnerability_code": "    function retBasedBlackScholesEstimate(\n\n        uint256[] memory _numbers,\n\n        uint256 _underlying,\n\n        uint256 _time\n\n    ) public pure {\n\n        uint _vol = stddev(_numbers);\n\n        blackScholesEstimate(_vol, _underlying, _time);\n",
          "message": "Keep3rV1Oracle.retBasedBlackScholesEstimate (Keep3rV1Oracle.sol#838-845) should be declared external\n"
        },
        {
          "name": "solc-version",
          "vulnerability_from_line": 4,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.6.12;\n",
          "message": "Detected issues with version pragma in Keep3rV1Oracle.sol:\n\t- pragma solidity^0.6.12 (Keep3rV1Oracle.sol#4): it allows old versions\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 14,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function allPairs(uint) external view returns (address pair);\n",
          "message": "Parameter '' of IUniswapV2Factory.allPairs (Keep3rV1Oracle.sol#14) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 19,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setFeeTo(address) external;\n",
          "message": "Parameter '' of IUniswapV2Factory.setFeeTo (Keep3rV1Oracle.sol#19) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 20,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setFeeToSetter(address) external;\n",
          "message": "Parameter '' of IUniswapV2Factory.setFeeToSetter (Keep3rV1Oracle.sol#20) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 38,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function DOMAIN_SEPARATOR() external view returns (bytes32);\n",
          "message": "Function 'IUniswapV2Pair.DOMAIN_SEPARATOR' (Keep3rV1Oracle.sol#38) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 39,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function PERMIT_TYPEHASH() external pure returns (bytes32);\n",
          "message": "Function 'IUniswapV2Pair.PERMIT_TYPEHASH' (Keep3rV1Oracle.sol#39) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 56,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function MINIMUM_LIQUIDITY() external pure returns (uint);\n",
          "message": "Function 'IUniswapV2Pair.MINIMUM_LIQUIDITY' (Keep3rV1Oracle.sol#56) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 71,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function initialize(address, address) external;\n",
          "message": "Parameter '' of IUniswapV2Pair.initialize (Keep3rV1Oracle.sol#71) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 71,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function initialize(address, address) external;\n",
          "message": "Parameter '_scope_0' of IUniswapV2Pair.initialize (Keep3rV1Oracle.sol#71) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 78,
          "vulnerability_to_line": 80,
          "vulnerability_code": "    struct uq112x112 {\n\n        uint224 _x;\n",
          "message": "Struct 'FixedPoint.uq112x112' (Keep3rV1Oracle.sol#78-80) is not in CapWords\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 84,
          "vulnerability_to_line": 86,
          "vulnerability_code": "    struct uq144x112 {\n\n        uint _x;\n",
          "message": "Struct 'FixedPoint.uq144x112' (Keep3rV1Oracle.sol#84-86) is not in CapWords\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 457,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function KPRH() external view returns (IKeep3rV1Helper);\n",
          "message": "Function 'IKeep3rV1.KPRH' (Keep3rV1Oracle.sol#457) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 495,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setMinKeep(uint _keep) external {\n",
          "message": "Parameter '_keep' of Keep3rV1Oracle.setMinKeep (Keep3rV1Oracle.sol#495) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 504,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setGovernance(address _governance) external {\n",
          "message": "Parameter '_governance' of Keep3rV1Oracle.setGovernance (Keep3rV1Oracle.sol#504) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 584,
          "vulnerability_to_line": 591,
          "vulnerability_code": "    function _updateAll() internal returns (bool updated) {\n\n        // SWC-DoS With Block Gas Limit: L584 - L588\n\n        for (uint i = 0; i < _pairs.length; i++) {\n\n            if (_update(_pairs[i])) {\n\n                updated = true;\n\n            }\n\n        }\n",
          "message": "Function 'Keep3rV1Oracle._updateAll' (Keep3rV1Oracle.sol#584-591) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 615,
          "vulnerability_to_line": 625,
          "vulnerability_code": "    function _update(address pair) internal returns (bool) {\n\n        // we only want to commit updates once per period (i.e. windowSize / granularity)\n\n        Observation memory _point = lastObservation(pair);\n\n        uint timeElapsed = block.timestamp - _point.timestamp;\n\n        if (timeElapsed > periodSize) {\n\n            (uint price0Cumulative, uint price1Cumulative,) = UniswapV2OracleLibrary.currentCumulativePrices(pair);\n\n            observations[pair].push(Observation(block.timestamp, price0Cumulative, price1Cumulative));\n\n            return true;\n\n        }\n\n        return false;\n",
          "message": "Function 'Keep3rV1Oracle._update' (Keep3rV1Oracle.sol#615-625) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 639,
          "vulnerability_to_line": 641,
          "vulnerability_code": "    function _valid(address pair, uint age) internal view returns (bool) {\n\n        return (block.timestamp - lastObservation(pair).timestamp) <= age;\n",
          "message": "Function 'Keep3rV1Oracle._valid' (Keep3rV1Oracle.sol#639-641) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 823,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint256 _vol,\n",
          "message": "Parameter '_vol' of Keep3rV1Oracle.blackScholesEstimate (Keep3rV1Oracle.sol#823) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 824,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint256 _underlying,\n",
          "message": "Parameter '_underlying' of Keep3rV1Oracle.blackScholesEstimate (Keep3rV1Oracle.sol#824) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 825,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint256 _time\n",
          "message": "Parameter '_time' of Keep3rV1Oracle.blackScholesEstimate (Keep3rV1Oracle.sol#825) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 839,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint256[] memory _numbers,\n",
          "message": "Parameter '_numbers' of Keep3rV1Oracle.retBasedBlackScholesEstimate (Keep3rV1Oracle.sol#839) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 840,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint256 _underlying,\n",
          "message": "Parameter '_underlying' of Keep3rV1Oracle.retBasedBlackScholesEstimate (Keep3rV1Oracle.sol#840) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 841,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint256 _time\n",
          "message": "Parameter '_time' of Keep3rV1Oracle.retBasedBlackScholesEstimate (Keep3rV1Oracle.sol#841) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 849,
          "vulnerability_to_line": 860,
          "vulnerability_code": "    function _swap(uint _amount) internal returns (uint) {\n\n        // SWC-Unchecked Call Return Value: L848\n\n        KP3R.approve(address(UNI), _amount);\n\n\n\n        address[] memory path = new address[](2);\n\n        path[0] = address(KP3R);\n\n        path[1] = address(WETH);\n\n\n\n        uint[] memory amounts = UNI.swapExactTokensForTokens(_amount, uint256(0), path, address(this), now.add(1800));\n\n        WETH.withdraw(amounts[1]);\n\n        return amounts[1];\n",
          "message": "Function 'Keep3rV1Oracle._swap' (Keep3rV1Oracle.sol#849-860) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 849,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _swap(uint _amount) internal returns (uint) {\n",
          "message": "Parameter '_amount' of Keep3rV1Oracle._swap (Keep3rV1Oracle.sol#849) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 521,
          "vulnerability_to_line": null,
          "vulnerability_code": "    address public constant factory = 0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f;\n",
          "message": "Constant 'Keep3rV1Oracle.factory' (Keep3rV1Oracle.sol#521) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 523,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint public constant periodSize = 1800;\n",
          "message": "Constant 'Keep3rV1Oracle.periodSize' (Keep3rV1Oracle.sol#523) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 525,
          "vulnerability_to_line": null,
          "vulnerability_code": "    address[] internal _pairs;\n",
          "message": "Variable 'Keep3rV1Oracle._pairs' (Keep3rV1Oracle.sol#525) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 526,
          "vulnerability_to_line": null,
          "vulnerability_code": "    mapping(address => bool) internal _known;\n",
          "message": "Variable 'Keep3rV1Oracle._known' (Keep3rV1Oracle.sol#526) is not in mixedCase\n"
        }
      ]
    },
    "smartcheck": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 517,
          "vulnerability_to_line": null,
          "vulnerability_code": "    IKeep3rV1 public constant KP3R = IKeep3rV1(0x1cEB5cB57C4D4E2b2433641b95Dd330A33185A44);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 518,
          "vulnerability_to_line": null,
          "vulnerability_code": "    WETH9 public constant WETH = WETH9(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 519,
          "vulnerability_to_line": null,
          "vulnerability_code": "    IUniswapV2Router public constant UNI = IUniswapV2Router(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 521,
          "vulnerability_to_line": null,
          "vulnerability_code": "    address public constant factory = 0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXACT_TIME",
          "vulnerability_from_line": 650,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (block.timestamp == _observation.timestamp) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 414,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i; i < path.length - 1; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 586,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < _pairs.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 607,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < _pairs.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 800,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(uint i = 0; i < numbers.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 806,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(i = 0; i < numbers.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 586,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < _pairs.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 607,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < _pairs.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 800,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(uint i = 0; i < numbers.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 806,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(i = 0; i < numbers.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 784,
          "vulnerability_to_line": null,
          "vulnerability_code": "        while (c < b) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_OVERPOWERED_ROLE",
          "vulnerability_from_line": 495,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setMinKeep(uint _keep) external {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_OVERPOWERED_ROLE",
          "vulnerability_from_line": 504,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setGovernance(address _governance) external {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 4,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.6.12;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 88,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint8 private constant RESOLUTION = 112;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SAFEMATH",
          "vulnerability_from_line": 353,
          "vulnerability_to_line": null,
          "vulnerability_code": "    using SafeMath for uint;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SAFEMATH",
          "vulnerability_from_line": 467,
          "vulnerability_to_line": null,
          "vulnerability_code": "    using SafeMath for uint;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 60,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 66,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function burn(address to) external returns (uint amount0, uint amount1);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 147,
          "vulnerability_to_line": null,
          "vulnerability_code": "    ) internal view returns (uint price0Cumulative, uint price1Cumulative, uint32 blockTimestamp) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 356,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 374,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getReserves(address factory, address tokenA, address tokenB) internal view returns (uint reserveA, uint reserveB) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 437,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function swapExactTokensForTokens(\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 440,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address[] calldata path,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 441,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address to,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 442,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint deadline\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 443,
          "vulnerability_to_line": null,
          "vulnerability_code": "    ) external returns (uint[] memory amounts);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 847,
          "vulnerability_to_line": null,
          "vulnerability_code": "    receive() external payable {}\n",
          "message": null
        }
      ]
    },
    "oyente": {
      "successfull_analysis": false,
      "errors": [
        "exception (IndexError: pop from empty list)"
      ],
      "vulnerability_findings": []
    },
    "mythril": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "Exception State (SWC 110)",
          "vulnerability_from_line": 532,
          "vulnerability_to_line": null,
          "vulnerability_code": "    mapping(address => Observation[]) public observations;\n",
          "message": "An assertion violation was triggered.\nIt is possible to trigger an assertion violation. Note that Solidity assert() statements should only be used to check invariants. Review the transaction trace generated for this issue and either make sure your program logic is correct, or use require() instead of assert() if your goal is to constrain user inputs or enforce preconditions. Remember to validate inputs from both callers (for instance, via passed arguments) and callees (for instance, via return values).\nClassification: SWC-110"
        },
        {
          "name": "Integer Arithmetic Bugs (SWC 101)",
          "vulnerability_from_line": 711,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint length = observations[pair].length-1;\n",
          "message": "The arithmetic operator can underflow.\nIt is possible to cause an integer overflow or underflow in the arithmetic operation. \nClassification: SWC-101"
        },
        {
          "name": "Integer Arithmetic Bugs (SWC 101)",
          "vulnerability_from_line": 711,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint length = observations[pair].length-1;\n",
          "message": "The arithmetic operator can underflow.\nIt is possible to cause an integer overflow or underflow in the arithmetic operation. \nClassification: SWC-101"
        },
        {
          "name": "Integer Arithmetic Bugs (SWC 101)",
          "vulnerability_from_line": 711,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint length = observations[pair].length-1;\n",
          "message": "The arithmetic operator can underflow.\nIt is possible to cause an integer overflow or underflow in the arithmetic operation. \nClassification: SWC-101"
        },
        {
          "name": "Integer Arithmetic Bugs (SWC 101)",
          "vulnerability_from_line": 711,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint length = observations[pair].length-1;\n",
          "message": "The arithmetic operator can underflow.\nIt is possible to cause an integer overflow or underflow in the arithmetic operation. \nClassification: SWC-101"
        },
        {
          "name": "Integer Arithmetic Bugs (SWC 101)",
          "vulnerability_from_line": 711,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint length = observations[pair].length-1;\n",
          "message": "The arithmetic operator can underflow.\nIt is possible to cause an integer overflow or underflow in the arithmetic operation. \nClassification: SWC-101"
        },
        {
          "name": "Exception State (SWC 110)",
          "vulnerability_from_line": 222,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n",
          "message": "An assertion violation was triggered.\nIt is possible to trigger an assertion violation. Note that Solidity assert() statements should only be used to check invariants. Review the transaction trace generated for this issue and either make sure your program logic is correct, or use require() instead of assert() if your goal is to constrain user inputs or enforce preconditions. Remember to validate inputs from both callers (for instance, via passed arguments) and callees (for instance, via return values).\nClassification: SWC-110"
        },
        {
          "name": "Exception State (SWC 110)",
          "vulnerability_from_line": null,
          "vulnerability_to_line": null,
          "vulnerability_code": null,
          "message": "An assertion violation was triggered.\nIt is possible to trigger an assertion violation. Note that Solidity assert() statements should only be used to check invariants. Review the transaction trace generated for this issue and either make sure your program logic is correct, or use require() instead of assert() if your goal is to constrain user inputs or enforce preconditions. Remember to validate inputs from both callers (for instance, via passed arguments) and callees (for instance, via return values).\nClassification: SWC-110"
        },
        {
          "name": "Integer Arithmetic Bugs (SWC 101)",
          "vulnerability_from_line": 827,
          "vulnerability_to_line": null,
          "vulnerability_code": "        estimate = 40 * _vol * _underlying * sqrt(_time);\n",
          "message": "The arithmetic operator can overflow.\nIt is possible to cause an integer overflow or underflow in the arithmetic operation. \nClassification: SWC-101"
        },
        {
          "name": "Integer Arithmetic Bugs (SWC 101)",
          "vulnerability_from_line": 827,
          "vulnerability_to_line": null,
          "vulnerability_code": "        estimate = 40 * _vol * _underlying * sqrt(_time);\n",
          "message": "The arithmetic operator can overflow.\nIt is possible to cause an integer overflow or underflow in the arithmetic operation. \nClassification: SWC-101"
        },
        {
          "name": "Exception State (SWC 110)",
          "vulnerability_from_line": 780,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function sqrt(uint256 x) public pure returns (uint256) {\n",
          "message": "An assertion violation was triggered.\nIt is possible to trigger an assertion violation. Note that Solidity assert() statements should only be used to check invariants. Review the transaction trace generated for this issue and either make sure your program logic is correct, or use require() instead of assert() if your goal is to constrain user inputs or enforce preconditions. Remember to validate inputs from both callers (for instance, via passed arguments) and callees (for instance, via return values).\nClassification: SWC-110"
        },
        {
          "name": "Exception State (SWC 110)",
          "vulnerability_from_line": 827,
          "vulnerability_to_line": null,
          "vulnerability_code": "        estimate = 40 * _vol * _underlying * sqrt(_time);\n",
          "message": "An assertion violation was triggered.\nIt is possible to trigger an assertion violation. Note that Solidity assert() statements should only be used to check invariants. Review the transaction trace generated for this issue and either make sure your program logic is correct, or use require() instead of assert() if your goal is to constrain user inputs or enforce preconditions. Remember to validate inputs from both callers (for instance, via passed arguments) and callees (for instance, via return values).\nClassification: SWC-110"
        },
        {
          "name": "Exception State (SWC 110)",
          "vulnerability_from_line": 798,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function stddev(uint[] memory numbers) public pure returns (uint256 sd) {\n",
          "message": "An assertion violation was triggered.\nIt is possible to trigger an assertion violation. Note that Solidity assert() statements should only be used to check invariants. Review the transaction trace generated for this issue and either make sure your program logic is correct, or use require() instead of assert() if your goal is to constrain user inputs or enforce preconditions. Remember to validate inputs from both callers (for instance, via passed arguments) and callees (for instance, via return values).\nClassification: SWC-110"
        },
        {
          "name": "Exception State (SWC 110)",
          "vulnerability_from_line": 843,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint _vol = stddev(_numbers);\n",
          "message": "An assertion violation was triggered.\nIt is possible to trigger an assertion violation. Note that Solidity assert() statements should only be used to check invariants. Review the transaction trace generated for this issue and either make sure your program logic is correct, or use require() instead of assert() if your goal is to constrain user inputs or enforce preconditions. Remember to validate inputs from both callers (for instance, via passed arguments) and callees (for instance, via return values).\nClassification: SWC-110"
        },
        {
          "name": "Exception State (SWC 110)",
          "vulnerability_from_line": 759,
          "vulnerability_to_line": null,
          "vulnerability_code": "        return stddev(sample(tokenIn, amountIn, tokenOut, points, window));\n",
          "message": "An assertion violation was triggered.\nIt is possible to trigger an assertion violation. Note that Solidity assert() statements should only be used to check invariants. Review the transaction trace generated for this issue and either make sure your program logic is correct, or use require() instead of assert() if your goal is to constrain user inputs or enforce preconditions. Remember to validate inputs from both callers (for instance, via passed arguments) and callees (for instance, via return values).\nClassification: SWC-110"
        },
        {
          "name": "Exception State (SWC 110)",
          "vulnerability_from_line": 806,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(i = 0; i < numbers.length; i++) {\n",
          "message": "An assertion violation was triggered.\nIt is possible to trigger an assertion violation. Note that Solidity assert() statements should only be used to check invariants. Review the transaction trace generated for this issue and either make sure your program logic is correct, or use require() instead of assert() if your goal is to constrain user inputs or enforce preconditions. Remember to validate inputs from both callers (for instance, via passed arguments) and callees (for instance, via return values).\nClassification: SWC-110"
        }
      ]
    },
    "osiris": {
      "successfull_analysis": false,
      "errors": [
        "Solidity compilation failed"
      ],
      "vulnerability_findings": []
    }
  }
}