{
  "smartbugs_completed": true,
  "analyzer_results": {
    "semgrep": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "use-abi-encodecall-instead-of-encodewithselector",
          "vulnerability_from_line": 44,
          "vulnerability_to_line": null,
          "vulnerability_code": "        return abi.encodeWithSelector(INVALID_BYTE_OPERATION_ERROR_SELECTOR, errorCode, offset, required);\n",
          "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
        },
        {
          "name": "use-abi-encodecall-instead-of-encodewithselector",
          "vulnerability_from_line": 81,
          "vulnerability_to_line": null,
          "vulnerability_code": "        return abi.encodeWithSelector(STANDARD_ERROR_SELECTOR, bytes(message));\n",
          "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 579,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 i = 0; i != firstHopCalls.length; ++i) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 580,
          "vulnerability_to_line": null,
          "vulnerability_code": "            firstHopCalls[i].writeUint256(firstHopCalls[i].length - 32, sellAmount);\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 583,
          "vulnerability_to_line": null,
          "vulnerability_code": "                uint256 amount = returnData.readUint256(returnData.length - 32);\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 594,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 j = 0; j != secondHopCalls.length; ++j) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 595,
          "vulnerability_to_line": null,
          "vulnerability_code": "            secondHopCalls[j].writeUint256(secondHopCalls[j].length - 32, intermediateAssetAmount);\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 598,
          "vulnerability_to_line": null,
          "vulnerability_code": "                uint256 amount = returnData.readUint256(returnData.length - 32);\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 623,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 j = 0; j != secondHopCalls.length; ++j) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 624,
          "vulnerability_to_line": null,
          "vulnerability_code": "            secondHopCalls[j].writeUint256(secondHopCalls[j].length - 32, buyAmount);\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 627,
          "vulnerability_to_line": null,
          "vulnerability_code": "                uint256 amount = returnData.readUint256(returnData.length - 32);\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 641,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 i = 0; i != firstHopCalls.length; ++i) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 642,
          "vulnerability_to_line": null,
          "vulnerability_code": "            firstHopCalls[i].writeUint256(firstHopCalls[i].length - 32, intermediateAssetAmount);\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 645,
          "vulnerability_to_line": null,
          "vulnerability_code": "                uint256 amount = returnData.readUint256(returnData.length - 32);\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 579,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 i = 0; i != firstHopCalls.length; ++i) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 594,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 j = 0; j != secondHopCalls.length; ++j) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 623,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 j = 0; j != secondHopCalls.length; ++j) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 641,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 i = 0; i != firstHopCalls.length; ++i) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 628,
          "vulnerability_to_line": null,
          "vulnerability_code": "                if (\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 629,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    amount > 0 &&\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 630,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    amount < intermediateAssetAmount\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 631,
          "vulnerability_to_line": null,
          "vulnerability_code": "                ) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 632,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    intermediateAssetAmount = amount;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 633,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    secondHop.sourceIndex = j;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 634,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    secondHop.returnData = returnData;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 635,
          "vulnerability_to_line": null,
          "vulnerability_code": "                }\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 646,
          "vulnerability_to_line": null,
          "vulnerability_code": "                if (\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 647,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    amount > 0 &&\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 648,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    amount < sellAmount\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 649,
          "vulnerability_to_line": null,
          "vulnerability_code": "                ) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 650,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    sellAmount = amount;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 651,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    firstHop.sourceIndex = i;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 652,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    firstHop.returnData = returnData;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 653,
          "vulnerability_to_line": null,
          "vulnerability_code": "                }\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        }
      ]
    },
    "slither": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": []
    },
    "smartcheck": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 37,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bytes4 internal constant INVALID_BYTE_OPERATION_ERROR_SELECTOR = 0x28006595;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 73,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bytes4 internal constant STANDARD_ERROR_SELECTOR = 0x08c379a0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 579,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 i = 0; i != firstHopCalls.length; ++i) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 594,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 j = 0; j != secondHopCalls.length; ++j) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 623,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 j = 0; j != secondHopCalls.length; ++j) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 641,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 i = 0; i != firstHopCalls.length; ++i) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 22,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.6.5;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 69,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.6.5;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 114,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.6.5;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 554,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.6;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 86,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 125,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function rawAddress(bytes memory input) internal pure returns (uint256 memoryAddress) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 135,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function contentAddress(bytes memory input) internal pure returns (uint256 memoryAddress) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 146,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function memCopy(uint256 dest, uint256 source, uint256 length) internal pure {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 288,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function sliceDestructive(bytes memory b, uint256 from, uint256 to) internal pure returns (bytes memory result) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 321,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function popLastByte(bytes memory b) internal pure returns (bytes1 result) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 358,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function readAddress(bytes memory b, uint256 index) internal pure returns (address result) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 388,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function writeAddress(bytes memory b, uint256 index, address input) internal pure {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 432,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function readBytes32(bytes memory b, uint256 index) internal pure returns (bytes32 result) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 457,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function writeBytes32(bytes memory b, uint256 index, bytes32 input) internal pure {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 498,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function readBytes4(bytes memory b, uint256 index) internal pure returns (bytes4 result) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 527,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function writeLength(bytes memory b, uint256 length) internal pure {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 572,
          "vulnerability_to_line": null,
          "vulnerability_code": "        returns (\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 615,
          "vulnerability_to_line": null,
          "vulnerability_code": "        returns (\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UNCHECKED_CALL",
          "vulnerability_from_line": 581,
          "vulnerability_to_line": null,
          "vulnerability_code": "            (bool didSucceed, bytes memory returnData) = address(this).staticcall(firstHopCalls[i]);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UNCHECKED_CALL",
          "vulnerability_from_line": 596,
          "vulnerability_to_line": null,
          "vulnerability_code": "            (bool didSucceed, bytes memory returnData) = address(this).staticcall(secondHopCalls[j]);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UNCHECKED_CALL",
          "vulnerability_from_line": 625,
          "vulnerability_to_line": null,
          "vulnerability_code": "            (bool didSucceed, bytes memory returnData) = address(this).staticcall(secondHopCalls[j]);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UNCHECKED_CALL",
          "vulnerability_from_line": 643,
          "vulnerability_to_line": null,
          "vulnerability_code": "            (bool didSucceed, bytes memory returnData) = address(this).staticcall(firstHopCalls[i]);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 87,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 126,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 136,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 151,
          "vulnerability_to_line": null,
          "vulnerability_code": "            assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 179,
          "vulnerability_to_line": null,
          "vulnerability_code": "                assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 211,
          "vulnerability_to_line": null,
          "vulnerability_code": "                assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 311,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 335,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 375,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 405,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 447,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 472,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 513,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 528,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        }
      ]
    },
    "oyente": {
      "successfull_analysis": false,
      "errors": [
        "Solidity compilation failed"
      ],
      "vulnerability_findings": []
    },
    "mythril": {
      "successfull_analysis": false,
      "errors": [
        "Solc experienced a fatal error"
      ],
      "vulnerability_findings": []
    },
    "osiris": {
      "successfull_analysis": false,
      "errors": [
        "Solidity compilation failed"
      ],
      "vulnerability_findings": []
    }
  }
}