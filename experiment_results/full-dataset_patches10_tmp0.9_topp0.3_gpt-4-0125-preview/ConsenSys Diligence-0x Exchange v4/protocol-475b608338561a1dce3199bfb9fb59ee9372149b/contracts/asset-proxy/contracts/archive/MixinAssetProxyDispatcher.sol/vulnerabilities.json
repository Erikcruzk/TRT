{
  "smartbugs_completed": true,
  "analyzer_results": {
    "semgrep": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "use-ownable2step",
          "vulnerability_from_line": 184,
          "vulnerability_to_line": null,
          "vulnerability_code": "    Ownable,\n",
          "message": "By demanding that the receiver of the owner permissions actively accept via a contract call of its own,  `Ownable2Step` and `Ownable2StepUpgradeable` prevent the contract ownership from accidentally being transferred  to an address that cannot handle it."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 43,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor ()\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 44,
          "vulnerability_to_line": null,
          "vulnerability_code": "        public\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 45,
          "vulnerability_to_line": null,
          "vulnerability_code": "    {\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 46,
          "vulnerability_to_line": null,
          "vulnerability_code": "        owner = msg.sender;\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 47,
          "vulnerability_to_line": null,
          "vulnerability_code": "    }\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 50,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 51,
          "vulnerability_to_line": null,
          "vulnerability_code": "            msg.sender == owner,\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 52,
          "vulnerability_to_line": null,
          "vulnerability_code": "            \"ONLY_CONTRACT_OWNER\"\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 53,
          "vulnerability_to_line": null,
          "vulnerability_code": "        );\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 200,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 201,
          "vulnerability_to_line": null,
          "vulnerability_code": "            currentAssetProxy == address(0),\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 202,
          "vulnerability_to_line": null,
          "vulnerability_code": "            \"ASSET_PROXY_ALREADY_EXISTS\"\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 203,
          "vulnerability_to_line": null,
          "vulnerability_code": "        );\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 240,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 241,
          "vulnerability_to_line": null,
          "vulnerability_code": "                assetData.length > 3,\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 242,
          "vulnerability_to_line": null,
          "vulnerability_code": "                \"LENGTH_GREATER_THAN_3_REQUIRED\"\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 243,
          "vulnerability_to_line": null,
          "vulnerability_code": "            );\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 256,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 257,
          "vulnerability_to_line": null,
          "vulnerability_code": "                assetProxy != address(0),\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 258,
          "vulnerability_to_line": null,
          "vulnerability_code": "                \"ASSET_PROXY_DOES_NOT_EXIST\"\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 259,
          "vulnerability_to_line": null,
          "vulnerability_code": "            );\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 238,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (amount > 0 && from != to) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 239,
          "vulnerability_to_line": null,
          "vulnerability_code": "            // Ensure assetData length is valid\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 240,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 241,
          "vulnerability_to_line": null,
          "vulnerability_code": "                assetData.length > 3,\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 242,
          "vulnerability_to_line": null,
          "vulnerability_code": "                \"LENGTH_GREATER_THAN_3_REQUIRED\"\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 243,
          "vulnerability_to_line": null,
          "vulnerability_code": "            );\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 244,
          "vulnerability_to_line": null,
          "vulnerability_code": "\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 245,
          "vulnerability_to_line": null,
          "vulnerability_code": "            // Lookup assetProxy. We do not use `LibBytes.readBytes4` for gas efficiency reasons.\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 246,
          "vulnerability_to_line": null,
          "vulnerability_code": "            bytes4 assetProxyId;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 247,
          "vulnerability_to_line": null,
          "vulnerability_code": "            assembly {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        }
      ]
    },
    "slither": {
      "successfull_analysis": true,
      "errors": [
        "EXIT_CODE_6"
      ],
      "vulnerability_findings": [
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 193,
          "vulnerability_to_line": 211,
          "vulnerability_code": "    function registerAssetProxy(address assetProxy)\n\n        external\n\n        onlyOwner\n\n    {\n\n        // Ensure that no asset proxy exists with current id.\n\n        bytes4 assetProxyId = IAssetProxy(assetProxy).getProxyId();\n\n        address currentAssetProxy = assetProxies[assetProxyId];\n\n        require(\n\n            currentAssetProxy == address(0),\n\n            \"ASSET_PROXY_ALREADY_EXISTS\"\n\n        );\n\n\n\n        // Add asset proxy and log registration.\n\n        assetProxies[assetProxyId] = assetProxy;\n\n        emit AssetProxyRegistered(\n\n            assetProxyId,\n\n            assetProxy\n\n        );\n",
          "message": "Reentrancy in MixinAssetProxyDispatcher.registerAssetProxy (MixinAssetProxyDispatcher.sol#193-211):\n\tExternal calls:\n\t- assetProxyId = IAssetProxy(assetProxy).getProxyId() (MixinAssetProxyDispatcher.sol#198)\n\tState variables written after the call(s):\n\t- assetProxies (MixinAssetProxyDispatcher.sol#206)\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 229,
          "vulnerability_to_line": 328,
          "vulnerability_code": "    function _dispatchTransferFrom(\n\n        bytes memory assetData,\n\n        address from,\n\n        address to,\n\n        uint256 amount\n\n    )\n\n        internal\n\n    {\n\n        // Do nothing if no amount should be transferred.\n\n        if (amount > 0 && from != to) {\n\n            // Ensure assetData length is valid\n\n            require(\n\n                assetData.length > 3,\n\n                \"LENGTH_GREATER_THAN_3_REQUIRED\"\n\n            );\n\n\n\n            // Lookup assetProxy. We do not use `LibBytes.readBytes4` for gas efficiency reasons.\n\n            bytes4 assetProxyId;\n\n            assembly {\n\n                assetProxyId := and(mload(\n\n                    add(assetData, 32)),\n\n                    0xFFFFFFFF00000000000000000000000000000000000000000000000000000000\n\n                )\n\n            }\n\n            address assetProxy = assetProxies[assetProxyId];\n\n\n\n            // Ensure that assetProxy exists\n\n            require(\n\n                assetProxy != address(0),\n\n                \"ASSET_PROXY_DOES_NOT_EXIST\"\n\n            );\n\n\n\n            // We construct calldata for the `assetProxy.transferFrom` ABI.\n\n            // The layout of this calldata is in the table below.\n\n            //\n\n            // | Area     | Offset | Length  | Contents                                    |\n\n            // | -------- |--------|---------|-------------------------------------------- |\n\n            // | Header   | 0      | 4       | function selector                           |\n\n            // | Params   |        | 4 * 32  | function parameters:                        |\n\n            // |          | 4      |         |   1. offset to assetData (*)                |\n\n            // |          | 36     |         |   2. from                                   |\n\n            // |          | 68     |         |   3. to                                     |\n\n            // |          | 100    |         |   4. amount                                 |\n\n            // | Data     |        |         | assetData:                                  |\n\n            // |          | 132    | 32      | assetData Length                            |\n\n            // |          | 164    | **      | assetData Contents                          |\n\n\n\n            assembly {\n\n                /////// Setup State ///////\n\n                // `cdStart` is the start of the calldata for `assetProxy.transferFrom` (equal to free memory ptr).\n\n                let cdStart := mload(64)\n\n                // `dataAreaLength` is the total number of words needed to store `assetData`\n\n                //  As-per the ABI spec, this value is padded up to the nearest multiple of 32,\n\n                //  and includes 32-bytes for length.\n\n                let dataAreaLength := and(add(mload(assetData), 63), 0xFFFFFFFFFFFE0)\n\n                // `cdEnd` is the end of the calldata for `assetProxy.transferFrom`.\n\n                let cdEnd := add(cdStart, add(132, dataAreaLength))\n\n\n\n\n\n                /////// Setup Header Area ///////\n\n                // This area holds the 4-byte `transferFromSelector`.\n\n                // bytes4(keccak256(\"transferFrom(bytes,address,address,uint256)\")) = 0xa85e59e4\n\n                mstore(cdStart, 0xa85e59e400000000000000000000000000000000000000000000000000000000)\n\n\n\n                /////// Setup Params Area ///////\n\n                // Each parameter is padded to 32-bytes. The entire Params Area is 128 bytes.\n\n                // Notes:\n\n                //   1. The offset to `assetData` is the length of the Params Area (128 bytes).\n\n                //   2. A 20-byte mask is applied to addresses to zero-out the unused bytes.\n\n                mstore(add(cdStart, 4), 128)\n\n                mstore(add(cdStart, 36), and(from, 0xffffffffffffffffffffffffffffffffffffffff))\n\n                mstore(add(cdStart, 68), and(to, 0xffffffffffffffffffffffffffffffffffffffff))\n\n                mstore(add(cdStart, 100), amount)\n\n\n\n                /////// Setup Data Area ///////\n\n                // This area holds `assetData`.\n\n                let dataArea := add(cdStart, 132)\n\n                // solhint-disable-next-line no-empty-blocks\n\n                for {} lt(dataArea, cdEnd) {} {\n\n                    mstore(dataArea, mload(assetData))\n\n                    dataArea := add(dataArea, 32)\n\n                    assetData := add(assetData, 32)\n\n                }\n\n\n\n                /////// Call `assetProxy.transferFrom` using the constructed calldata ///////\n\n                let success := call(\n\n                    gas,                    // forward all gas\n\n                    assetProxy,             // call address of asset proxy\n\n                    0,                      // don't send any ETH\n\n                    cdStart,                // pointer to start of input\n\n                    sub(cdEnd, cdStart),    // length of input\n\n                    cdStart,                // write output over input\n\n                    512                     // reserve 512 bytes for output\n\n                )\n\n                if iszero(success) {\n\n                    revert(cdStart, returndatasize())\n\n                }\n\n            }\n\n        }\n",
          "message": "MixinAssetProxyDispatcher._dispatchTransferFrom uses assembly (MixinAssetProxyDispatcher.sol#229-328)\n\t- MixinAssetProxyDispatcher.sol#247-252\n\t- MixinAssetProxyDispatcher.sol#276-326\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 57,
          "vulnerability_to_line": 64,
          "vulnerability_code": "    function transferOwnership(address newOwner)\n\n        public\n\n        onlyOwner\n\n    {\n\n        if (newOwner != address(0)) {\n\n            owner = newOwner;\n\n        }\n",
          "message": "Ownable.transferOwnership (MixinAssetProxyDispatcher.sol#57-64) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 31,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function transferOwnership(address newOwner) public;\n",
          "message": "IOwnable.transferOwnership (MixinAssetProxyDispatcher.sol#31) should be declared external\n"
        },
        {
          "name": "solc-version",
          "vulnerability_from_line": 21,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.9;\n",
          "message": "Detected issues with version pragma in MixinAssetProxyDispatcher.sol:\n\t- pragma solidity^0.5.9 (MixinAssetProxyDispatcher.sol#21): it allows old versions\n\t- pragma solidity^0.5.9 (MixinAssetProxyDispatcher.sol#36): it allows old versions\n\t- pragma solidity^0.5.9 (MixinAssetProxyDispatcher.sol#87): it allows old versions\n\t- pragma solidity^0.5.9 (MixinAssetProxyDispatcher.sol#133): it allows old versions\n\t- pragma solidity^0.5.9 (MixinAssetProxyDispatcher.sol#179): it allows old versions\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 229,
          "vulnerability_to_line": 328,
          "vulnerability_code": "    function _dispatchTransferFrom(\n\n        bytes memory assetData,\n\n        address from,\n\n        address to,\n\n        uint256 amount\n\n    )\n\n        internal\n\n    {\n\n        // Do nothing if no amount should be transferred.\n\n        if (amount > 0 && from != to) {\n\n            // Ensure assetData length is valid\n\n            require(\n\n                assetData.length > 3,\n\n                \"LENGTH_GREATER_THAN_3_REQUIRED\"\n\n            );\n\n\n\n            // Lookup assetProxy. We do not use `LibBytes.readBytes4` for gas efficiency reasons.\n\n            bytes4 assetProxyId;\n\n            assembly {\n\n                assetProxyId := and(mload(\n\n                    add(assetData, 32)),\n\n                    0xFFFFFFFF00000000000000000000000000000000000000000000000000000000\n\n                )\n\n            }\n\n            address assetProxy = assetProxies[assetProxyId];\n\n\n\n            // Ensure that assetProxy exists\n\n            require(\n\n                assetProxy != address(0),\n\n                \"ASSET_PROXY_DOES_NOT_EXIST\"\n\n            );\n\n\n\n            // We construct calldata for the `assetProxy.transferFrom` ABI.\n\n            // The layout of this calldata is in the table below.\n\n            //\n\n            // | Area     | Offset | Length  | Contents                                    |\n\n            // | -------- |--------|---------|-------------------------------------------- |\n\n            // | Header   | 0      | 4       | function selector                           |\n\n            // | Params   |        | 4 * 32  | function parameters:                        |\n\n            // |          | 4      |         |   1. offset to assetData (*)                |\n\n            // |          | 36     |         |   2. from                                   |\n\n            // |          | 68     |         |   3. to                                     |\n\n            // |          | 100    |         |   4. amount                                 |\n\n            // | Data     |        |         | assetData:                                  |\n\n            // |          | 132    | 32      | assetData Length                            |\n\n            // |          | 164    | **      | assetData Contents                          |\n\n\n\n            assembly {\n\n                /////// Setup State ///////\n\n                // `cdStart` is the start of the calldata for `assetProxy.transferFrom` (equal to free memory ptr).\n\n                let cdStart := mload(64)\n\n                // `dataAreaLength` is the total number of words needed to store `assetData`\n\n                //  As-per the ABI spec, this value is padded up to the nearest multiple of 32,\n\n                //  and includes 32-bytes for length.\n\n                let dataAreaLength := and(add(mload(assetData), 63), 0xFFFFFFFFFFFE0)\n\n                // `cdEnd` is the end of the calldata for `assetProxy.transferFrom`.\n\n                let cdEnd := add(cdStart, add(132, dataAreaLength))\n\n\n\n\n\n                /////// Setup Header Area ///////\n\n                // This area holds the 4-byte `transferFromSelector`.\n\n                // bytes4(keccak256(\"transferFrom(bytes,address,address,uint256)\")) = 0xa85e59e4\n\n                mstore(cdStart, 0xa85e59e400000000000000000000000000000000000000000000000000000000)\n\n\n\n                /////// Setup Params Area ///////\n\n                // Each parameter is padded to 32-bytes. The entire Params Area is 128 bytes.\n\n                // Notes:\n\n                //   1. The offset to `assetData` is the length of the Params Area (128 bytes).\n\n                //   2. A 20-byte mask is applied to addresses to zero-out the unused bytes.\n\n                mstore(add(cdStart, 4), 128)\n\n                mstore(add(cdStart, 36), and(from, 0xffffffffffffffffffffffffffffffffffffffff))\n\n                mstore(add(cdStart, 68), and(to, 0xffffffffffffffffffffffffffffffffffffffff))\n\n                mstore(add(cdStart, 100), amount)\n\n\n\n                /////// Setup Data Area ///////\n\n                // This area holds `assetData`.\n\n                let dataArea := add(cdStart, 132)\n\n                // solhint-disable-next-line no-empty-blocks\n\n                for {} lt(dataArea, cdEnd) {} {\n\n                    mstore(dataArea, mload(assetData))\n\n                    dataArea := add(dataArea, 32)\n\n                    assetData := add(assetData, 32)\n\n                }\n\n\n\n                /////// Call `assetProxy.transferFrom` using the constructed calldata ///////\n\n                let success := call(\n\n                    gas,                    // forward all gas\n\n                    assetProxy,             // call address of asset proxy\n\n                    0,                      // don't send any ETH\n\n                    cdStart,                // pointer to start of input\n\n                    sub(cdEnd, cdStart),    // length of input\n\n                    cdStart,                // write output over input\n\n                    512                     // reserve 512 bytes for output\n\n                )\n\n                if iszero(success) {\n\n                    revert(cdStart, returndatasize())\n\n                }\n\n            }\n\n        }\n",
          "message": "Function 'MixinAssetProxyDispatcher._dispatchTransferFrom' (MixinAssetProxyDispatcher.sol#229-328) is not in mixedCase\n"
        }
      ]
    },
    "smartcheck": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 21,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.9;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 36,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.9;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 87,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.9;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 133,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.9;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 179,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.9;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 247,
          "vulnerability_to_line": null,
          "vulnerability_code": "            assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 276,
          "vulnerability_to_line": null,
          "vulnerability_code": "            assembly {\n",
          "message": null
        }
      ]
    },
    "oyente": {
      "successfull_analysis": false,
      "errors": [
        "exception (RuntimeError: Source map error, unknown name(SHR) or instr_name(INVALID))"
      ],
      "vulnerability_findings": []
    },
    "mythril": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": []
    },
    "osiris": {
      "successfull_analysis": false,
      "errors": [
        "Solidity compilation failed"
      ],
      "vulnerability_findings": []
    }
  }
}