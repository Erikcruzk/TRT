{
  "smartbugs_completed": true,
  "analyzer_results": {
    "semgrep": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "use-abi-encodecall-instead-of-encodewithselector",
          "vulnerability_from_line": 34,
          "vulnerability_to_line": null,
          "vulnerability_code": "        return abi.encodeWithSelector(STANDARD_ERROR_SELECTOR, bytes(message));\n",
          "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
        },
        {
          "name": "use-abi-encodecall-instead-of-encodewithselector",
          "vulnerability_from_line": 78,
          "vulnerability_to_line": null,
          "vulnerability_code": "        return abi.encodeWithSelector(\n",
          "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
        },
        {
          "name": "use-abi-encodecall-instead-of-encodewithselector",
          "vulnerability_from_line": 79,
          "vulnerability_to_line": null,
          "vulnerability_code": "            bytes4(keccak256(\"OnlyCallableBySelfError(address)\")),\n",
          "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
        },
        {
          "name": "use-abi-encodecall-instead-of-encodewithselector",
          "vulnerability_from_line": 80,
          "vulnerability_to_line": null,
          "vulnerability_code": "            sender\n",
          "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
        },
        {
          "name": "use-abi-encodecall-instead-of-encodewithselector",
          "vulnerability_from_line": 81,
          "vulnerability_to_line": null,
          "vulnerability_code": "        );\n",
          "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
        },
        {
          "name": "use-abi-encodecall-instead-of-encodewithselector",
          "vulnerability_from_line": 89,
          "vulnerability_to_line": null,
          "vulnerability_code": "        return abi.encodeWithSelector(\n",
          "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
        },
        {
          "name": "use-abi-encodecall-instead-of-encodewithselector",
          "vulnerability_from_line": 90,
          "vulnerability_to_line": null,
          "vulnerability_code": "            bytes4(keccak256(\"IllegalReentrancyError(bytes4,uint256)\")),\n",
          "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
        },
        {
          "name": "use-abi-encodecall-instead-of-encodewithselector",
          "vulnerability_from_line": 91,
          "vulnerability_to_line": null,
          "vulnerability_code": "            selector,\n",
          "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
        },
        {
          "name": "use-abi-encodecall-instead-of-encodewithselector",
          "vulnerability_from_line": 92,
          "vulnerability_to_line": null,
          "vulnerability_code": "            reentrancyFlags\n",
          "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
        },
        {
          "name": "use-abi-encodecall-instead-of-encodewithselector",
          "vulnerability_from_line": 93,
          "vulnerability_to_line": null,
          "vulnerability_code": "        );\n",
          "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
        },
        {
          "name": "use-abi-encodecall-instead-of-encodewithselector",
          "vulnerability_from_line": 132,
          "vulnerability_to_line": null,
          "vulnerability_code": "        return abi.encodeWithSelector(\n",
          "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
        },
        {
          "name": "use-abi-encodecall-instead-of-encodewithselector",
          "vulnerability_from_line": 133,
          "vulnerability_to_line": null,
          "vulnerability_code": "            bytes4(keccak256(\"OnlyOwnerError(address,address)\")),\n",
          "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
        },
        {
          "name": "use-abi-encodecall-instead-of-encodewithselector",
          "vulnerability_from_line": 134,
          "vulnerability_to_line": null,
          "vulnerability_code": "            sender,\n",
          "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
        },
        {
          "name": "use-abi-encodecall-instead-of-encodewithselector",
          "vulnerability_from_line": 135,
          "vulnerability_to_line": null,
          "vulnerability_code": "            owner\n",
          "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
        },
        {
          "name": "use-abi-encodecall-instead-of-encodewithselector",
          "vulnerability_from_line": 136,
          "vulnerability_to_line": null,
          "vulnerability_code": "        );\n",
          "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
        },
        {
          "name": "use-abi-encodecall-instead-of-encodewithselector",
          "vulnerability_from_line": 144,
          "vulnerability_to_line": null,
          "vulnerability_code": "        return abi.encodeWithSelector(\n",
          "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
        },
        {
          "name": "use-abi-encodecall-instead-of-encodewithselector",
          "vulnerability_from_line": 145,
          "vulnerability_to_line": null,
          "vulnerability_code": "            bytes4(keccak256(\"TransferOwnerToZeroError()\"))\n",
          "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
        },
        {
          "name": "use-abi-encodecall-instead-of-encodewithselector",
          "vulnerability_from_line": 146,
          "vulnerability_to_line": null,
          "vulnerability_code": "        );\n",
          "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
        },
        {
          "name": "use-abi-encodecall-instead-of-encodewithselector",
          "vulnerability_from_line": 154,
          "vulnerability_to_line": null,
          "vulnerability_code": "        return abi.encodeWithSelector(\n",
          "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
        },
        {
          "name": "use-abi-encodecall-instead-of-encodewithselector",
          "vulnerability_from_line": 155,
          "vulnerability_to_line": null,
          "vulnerability_code": "            bytes4(keccak256(\"MigrateCallFailedError(address,bytes)\")),\n",
          "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
        },
        {
          "name": "use-abi-encodecall-instead-of-encodewithselector",
          "vulnerability_from_line": 156,
          "vulnerability_to_line": null,
          "vulnerability_code": "            target,\n",
          "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
        },
        {
          "name": "use-abi-encodecall-instead-of-encodewithselector",
          "vulnerability_from_line": 157,
          "vulnerability_to_line": null,
          "vulnerability_code": "            resultData\n",
          "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
        },
        {
          "name": "use-abi-encodecall-instead-of-encodewithselector",
          "vulnerability_from_line": 158,
          "vulnerability_to_line": null,
          "vulnerability_code": "        );\n",
          "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
        }
      ]
    },
    "slither": {
      "successfull_analysis": true,
      "errors": [
        "EXIT_CODE_13"
      ],
      "vulnerability_findings": [
        {
          "name": "constant-function",
          "vulnerability_from_line": 39,
          "vulnerability_to_line": 43,
          "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
          "message": "LibRichErrorsV06.rrevert (FixinEIP712.sol#39-43) is declared view but contains assembly code\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 39,
          "vulnerability_to_line": 43,
          "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
          "message": "LibRichErrorsV06.rrevert uses assembly (FixinEIP712.sol#39-43)\n\t- FixinEIP712.sol#40-42\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 193,
          "vulnerability_to_line": 215,
          "vulnerability_code": "    constructor(address zeroExAddress) internal {\n\n        // Compute `EIP712_DOMAIN_SEPARATOR`\n\n        {\n\n            uint256 chainId;\n\n            assembly { chainId := chainid() }\n\n            EIP712_DOMAIN_SEPARATOR = keccak256(\n\n                abi.encode(\n\n                    keccak256(\n\n                        \"EIP712Domain(\"\n\n                            \"string name,\"\n\n                            \"string version,\"\n\n                            \"uint256 chainId,\"\n\n                            \"address verifyingContract\"\n\n                        \")\"\n\n                    ),\n\n                    keccak256(\"ZeroEx\"),\n\n                    keccak256(\"1.0.0\"),\n\n                    chainId,\n\n                    zeroExAddress\n\n                )\n\n            );\n\n        }\n",
          "message": "FixinEIP712.constructor uses assembly (FixinEIP712.sol#193-215)\n\t- FixinEIP712.sol#197\n"
        },
        {
          "name": "pragma",
          "vulnerability_from_line": 22,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.6.5;\n",
          "message": "Different versions of Solidity is used in FixinEIP712.sol:\n\t- Version used: ['ABIEncoderV2', '^0.6.5']\n\t- FixinEIP712.sol#22 declares pragma solidity^0.6.5\n\t- FixinEIP712.sol#66 declares pragma solidity^0.6.5\n\t- FixinEIP712.sol#117 declares pragma solidity^0.6.5\n\t- FixinEIP712.sol#182 declares pragma solidity^0.6.5\n\t- FixinEIP712.sol#183 declares pragma experimentalABIEncoderV2\n"
        },
        {
          "name": "solc-version",
          "vulnerability_from_line": 22,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.6.5;\n",
          "message": "Detected issues with version pragma in FixinEIP712.sol:\n\t- pragma solidity^0.6.5 (FixinEIP712.sol#22): it allows old versions\n\t- pragma solidity^0.6.5 (FixinEIP712.sol#66): it allows old versions\n\t- pragma solidity^0.6.5 (FixinEIP712.sol#117): it allows old versions\n\t- pragma solidity^0.6.5 (FixinEIP712.sol#182): it allows old versions\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 33,
          "vulnerability_to_line": 35,
          "vulnerability_code": "    function StandardError(string memory message) internal pure returns (bytes memory) {\n\n        return abi.encodeWithSelector(STANDARD_ERROR_SELECTOR, bytes(message));\n",
          "message": "Function 'LibRichErrorsV06.StandardError' (FixinEIP712.sol#33-35) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 73,
          "vulnerability_to_line": 82,
          "vulnerability_code": "    function OnlyCallableBySelfError(address sender)\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            bytes4(keccak256(\"OnlyCallableBySelfError(address)\")),\n\n            sender\n\n        );\n",
          "message": "Function 'LibCommonRichErrors.OnlyCallableBySelfError' (FixinEIP712.sol#73-82) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 84,
          "vulnerability_to_line": 94,
          "vulnerability_code": "    function IllegalReentrancyError(bytes4 selector, uint256 reentrancyFlags)\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            bytes4(keccak256(\"IllegalReentrancyError(bytes4,uint256)\")),\n\n            selector,\n\n            reentrancyFlags\n\n        );\n",
          "message": "Function 'LibCommonRichErrors.IllegalReentrancyError' (FixinEIP712.sol#84-94) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 124,
          "vulnerability_to_line": 137,
          "vulnerability_code": "    function OnlyOwnerError(\n\n        address sender,\n\n        address owner\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            bytes4(keccak256(\"OnlyOwnerError(address,address)\")),\n\n            sender,\n\n            owner\n\n        );\n",
          "message": "Function 'LibOwnableRichErrors.OnlyOwnerError' (FixinEIP712.sol#124-137) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 139,
          "vulnerability_to_line": 147,
          "vulnerability_code": "    function TransferOwnerToZeroError()\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            bytes4(keccak256(\"TransferOwnerToZeroError()\"))\n\n        );\n",
          "message": "Function 'LibOwnableRichErrors.TransferOwnerToZeroError' (FixinEIP712.sol#139-147) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 149,
          "vulnerability_to_line": 159,
          "vulnerability_code": "    function MigrateCallFailedError(address target, bytes memory resultData)\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            bytes4(keccak256(\"MigrateCallFailedError(address,bytes)\")),\n\n            target,\n\n            resultData\n\n        );\n",
          "message": "Function 'LibOwnableRichErrors.MigrateCallFailedError' (FixinEIP712.sol#149-159) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 217,
          "vulnerability_to_line": 227,
          "vulnerability_code": "    function _getEIP712Hash(bytes32 structHash)\n\n        internal\n\n        view\n\n        returns (bytes32 eip712Hash)\n\n    {\n\n        return keccak256(abi.encodePacked(\n\n            hex\"1901\",\n\n            EIP712_DOMAIN_SEPARATOR,\n\n            structHash\n\n        ));\n",
          "message": "Function 'FixinEIP712._getEIP712Hash' (FixinEIP712.sol#217-227) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 191,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bytes32 public immutable EIP712_DOMAIN_SEPARATOR;\n",
          "message": "Variable 'FixinEIP712.EIP712_DOMAIN_SEPARATOR' (FixinEIP712.sol#191) is not in mixedCase\n"
        }
      ]
    },
    "smartcheck": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 26,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bytes4 internal constant STANDARD_ERROR_SELECTOR = 0x08c379a0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 22,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.6.5;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 66,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.6.5;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 117,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.6.5;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 182,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.6.5;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 39,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 40,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 197,
          "vulnerability_to_line": null,
          "vulnerability_code": "            assembly { chainId := chainid() }\n",
          "message": null
        }
      ]
    },
    "oyente": {
      "successfull_analysis": false,
      "errors": [
        "exception (IndexError: pop from empty list)"
      ],
      "vulnerability_findings": []
    },
    "mythril": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": []
    },
    "osiris": {
      "successfull_analysis": false,
      "errors": [
        "Solidity compilation failed"
      ],
      "vulnerability_findings": []
    }
  }
}