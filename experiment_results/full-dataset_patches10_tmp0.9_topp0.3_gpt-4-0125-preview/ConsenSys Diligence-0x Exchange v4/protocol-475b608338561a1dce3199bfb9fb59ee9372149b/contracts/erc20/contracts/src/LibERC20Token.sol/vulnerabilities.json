{
  "smartbugs_completed": true,
  "analyzer_results": {
    "semgrep": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "use-abi-encodecall-instead-of-encodewithselector",
          "vulnerability_from_line": 33,
          "vulnerability_to_line": null,
          "vulnerability_code": "        return abi.encodeWithSelector(STANDARD_ERROR_SELECTOR, bytes(message));\n",
          "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
        },
        {
          "name": "use-abi-encodecall-instead-of-encodewithselector",
          "vulnerability_from_line": 87,
          "vulnerability_to_line": null,
          "vulnerability_code": "        return abi.encodeWithSelector(INVALID_BYTE_OPERATION_ERROR_SELECTOR, errorCode, offset, required);\n",
          "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
        },
        {
          "name": "use-abi-encodecall-instead-of-encodewithselector",
          "vulnerability_from_line": 660,
          "vulnerability_to_line": null,
          "vulnerability_code": "        bytes memory callData = abi.encodeWithSelector(\n",
          "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
        },
        {
          "name": "use-abi-encodecall-instead-of-encodewithselector",
          "vulnerability_from_line": 661,
          "vulnerability_to_line": null,
          "vulnerability_code": "            IERC20Token(0).approve.selector,\n",
          "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
        },
        {
          "name": "use-abi-encodecall-instead-of-encodewithselector",
          "vulnerability_from_line": 662,
          "vulnerability_to_line": null,
          "vulnerability_code": "            spender,\n",
          "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
        },
        {
          "name": "use-abi-encodecall-instead-of-encodewithselector",
          "vulnerability_from_line": 663,
          "vulnerability_to_line": null,
          "vulnerability_code": "            allowance\n",
          "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
        },
        {
          "name": "use-abi-encodecall-instead-of-encodewithselector",
          "vulnerability_from_line": 664,
          "vulnerability_to_line": null,
          "vulnerability_code": "        );\n",
          "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
        },
        {
          "name": "use-abi-encodecall-instead-of-encodewithselector",
          "vulnerability_from_line": 700,
          "vulnerability_to_line": null,
          "vulnerability_code": "        bytes memory callData = abi.encodeWithSelector(\n",
          "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
        },
        {
          "name": "use-abi-encodecall-instead-of-encodewithselector",
          "vulnerability_from_line": 701,
          "vulnerability_to_line": null,
          "vulnerability_code": "            IERC20Token(0).transfer.selector,\n",
          "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
        },
        {
          "name": "use-abi-encodecall-instead-of-encodewithselector",
          "vulnerability_from_line": 702,
          "vulnerability_to_line": null,
          "vulnerability_code": "            to,\n",
          "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
        },
        {
          "name": "use-abi-encodecall-instead-of-encodewithselector",
          "vulnerability_from_line": 703,
          "vulnerability_to_line": null,
          "vulnerability_code": "            amount\n",
          "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
        },
        {
          "name": "use-abi-encodecall-instead-of-encodewithselector",
          "vulnerability_from_line": 704,
          "vulnerability_to_line": null,
          "vulnerability_code": "        );\n",
          "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
        },
        {
          "name": "use-abi-encodecall-instead-of-encodewithselector",
          "vulnerability_from_line": 723,
          "vulnerability_to_line": null,
          "vulnerability_code": "        bytes memory callData = abi.encodeWithSelector(\n",
          "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
        },
        {
          "name": "use-abi-encodecall-instead-of-encodewithselector",
          "vulnerability_from_line": 724,
          "vulnerability_to_line": null,
          "vulnerability_code": "            IERC20Token(0).transferFrom.selector,\n",
          "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
        },
        {
          "name": "use-abi-encodecall-instead-of-encodewithselector",
          "vulnerability_from_line": 725,
          "vulnerability_to_line": null,
          "vulnerability_code": "            from,\n",
          "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
        },
        {
          "name": "use-abi-encodecall-instead-of-encodewithselector",
          "vulnerability_from_line": 726,
          "vulnerability_to_line": null,
          "vulnerability_code": "            to,\n",
          "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
        },
        {
          "name": "use-abi-encodecall-instead-of-encodewithselector",
          "vulnerability_from_line": 727,
          "vulnerability_to_line": null,
          "vulnerability_code": "            amount\n",
          "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
        },
        {
          "name": "use-abi-encodecall-instead-of-encodewithselector",
          "vulnerability_from_line": 728,
          "vulnerability_to_line": null,
          "vulnerability_code": "        );\n",
          "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
        },
        {
          "name": "use-abi-encodecall-instead-of-encodewithselector",
          "vulnerability_from_line": 759,
          "vulnerability_to_line": null,
          "vulnerability_code": "        (bool didSucceed, bytes memory resultData) = token.staticcall(\n",
          "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
        },
        {
          "name": "use-abi-encodecall-instead-of-encodewithselector",
          "vulnerability_from_line": 760,
          "vulnerability_to_line": null,
          "vulnerability_code": "            abi.encodeWithSelector(\n",
          "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
        },
        {
          "name": "use-abi-encodecall-instead-of-encodewithselector",
          "vulnerability_from_line": 761,
          "vulnerability_to_line": null,
          "vulnerability_code": "                IERC20Token(0).allowance.selector,\n",
          "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
        },
        {
          "name": "use-abi-encodecall-instead-of-encodewithselector",
          "vulnerability_from_line": 762,
          "vulnerability_to_line": null,
          "vulnerability_code": "                owner,\n",
          "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
        },
        {
          "name": "use-abi-encodecall-instead-of-encodewithselector",
          "vulnerability_from_line": 763,
          "vulnerability_to_line": null,
          "vulnerability_code": "                spender\n",
          "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
        },
        {
          "name": "use-abi-encodecall-instead-of-encodewithselector",
          "vulnerability_from_line": 764,
          "vulnerability_to_line": null,
          "vulnerability_code": "            )\n",
          "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
        },
        {
          "name": "use-abi-encodecall-instead-of-encodewithselector",
          "vulnerability_from_line": 765,
          "vulnerability_to_line": null,
          "vulnerability_code": "        );\n",
          "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
        },
        {
          "name": "use-abi-encodecall-instead-of-encodewithselector",
          "vulnerability_from_line": 781,
          "vulnerability_to_line": null,
          "vulnerability_code": "        (bool didSucceed, bytes memory resultData) = token.staticcall(\n",
          "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
        },
        {
          "name": "use-abi-encodecall-instead-of-encodewithselector",
          "vulnerability_from_line": 782,
          "vulnerability_to_line": null,
          "vulnerability_code": "            abi.encodeWithSelector(\n",
          "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
        },
        {
          "name": "use-abi-encodecall-instead-of-encodewithselector",
          "vulnerability_from_line": 783,
          "vulnerability_to_line": null,
          "vulnerability_code": "                IERC20Token(0).balanceOf.selector,\n",
          "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
        },
        {
          "name": "use-abi-encodecall-instead-of-encodewithselector",
          "vulnerability_from_line": 784,
          "vulnerability_to_line": null,
          "vulnerability_code": "                owner\n",
          "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
        },
        {
          "name": "use-abi-encodecall-instead-of-encodewithselector",
          "vulnerability_from_line": 785,
          "vulnerability_to_line": null,
          "vulnerability_code": "            )\n",
          "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
        },
        {
          "name": "use-abi-encodecall-instead-of-encodewithselector",
          "vulnerability_from_line": 786,
          "vulnerability_to_line": null,
          "vulnerability_code": "        );\n",
          "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 743,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (didSucceed && resultData.length == 32) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 744,
          "vulnerability_to_line": null,
          "vulnerability_code": "            tokenDecimals = uint8(LibBytes.readUint256(resultData, 0));\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 745,
          "vulnerability_to_line": null,
          "vulnerability_code": "        }\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 766,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (didSucceed && resultData.length == 32) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 767,
          "vulnerability_to_line": null,
          "vulnerability_code": "            allowance_ = LibBytes.readUint256(resultData, 0);\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 768,
          "vulnerability_to_line": null,
          "vulnerability_code": "        }\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 787,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (didSucceed && resultData.length == 32) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 788,
          "vulnerability_to_line": null,
          "vulnerability_code": "            balance = LibBytes.readUint256(resultData, 0);\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 789,
          "vulnerability_to_line": null,
          "vulnerability_code": "        }\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        }
      ]
    },
    "slither": {
      "successfull_analysis": true,
      "errors": [
        "EXIT_CODE_33"
      ],
      "vulnerability_findings": [
        {
          "name": "constant-function",
          "vulnerability_from_line": 38,
          "vulnerability_to_line": 42,
          "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
          "message": "LibRichErrors.rrevert (LibERC20Token.sol#38-42) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 122,
          "vulnerability_to_line": 127,
          "vulnerability_code": "    function rawAddress(bytes memory input) internal pure returns (uint256 memoryAddress) {\n\n        assembly {\n\n            memoryAddress := input\n\n        }\n\n        return memoryAddress;\n",
          "message": "LibBytes.rawAddress (LibERC20Token.sol#122-127) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 132,
          "vulnerability_to_line": 137,
          "vulnerability_code": "    function contentAddress(bytes memory input) internal pure returns (uint256 memoryAddress) {\n\n        assembly {\n\n            memoryAddress := add(input, 32)\n\n        }\n\n        return memoryAddress;\n",
          "message": "LibBytes.contentAddress (LibERC20Token.sol#132-137) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 143,
          "vulnerability_to_line": 243,
          "vulnerability_code": "    function memCopy(uint256 dest, uint256 source, uint256 length) internal pure {\n\n        if (length < 32) {\n\n            // Handle a partial word by reading destination and masking\n\n            // off the bits we are interested in.\n\n            // This correctly handles overlap, zero lengths and source == dest\n\n            assembly {\n\n                let mask := sub(exp(256, sub(32, length)), 1)\n\n                let s := and(mload(source), not(mask))\n\n                let d := and(mload(dest), mask)\n\n                mstore(dest, or(s, d))\n\n            }\n\n        } else {\n\n            // Skip the O(length) loop when source == dest.\n\n            if (source == dest) {\n\n                return;\n\n            }\n\n\n\n            // For large copies we copy whole words at a time. The final\n\n            // word is aligned to the end of the range (instead of after the\n\n            // previous) to handle partial words. So a copy will look like this:\n\n            //\n\n            //  ####\n\n            //      ####\n\n            //          ####\n\n            //            ####\n\n            //\n\n            // We handle overlap in the source and destination range by\n\n            // changing the copying direction. This prevents us from\n\n            // overwriting parts of source that we still need to copy.\n\n            //\n\n            // This correctly handles source == dest\n\n            //\n\n            if (source > dest) {\n\n                assembly {\n\n                    // We subtract 32 from `sEnd` and `dEnd` because it\n\n                    // is easier to compare with in the loop, and these\n\n                    // are also the addresses we need for copying the\n\n                    // last bytes.\n\n                    length := sub(length, 32)\n\n                    let sEnd := add(source, length)\n\n                    let dEnd := add(dest, length)\n\n\n\n                    // Remember the last 32 bytes of source\n\n                    // This needs to be done here and not after the loop\n\n                    // because we may have overwritten the last bytes in\n\n                    // source already due to overlap.\n\n                    let last := mload(sEnd)\n\n\n\n                    // Copy whole words front to back\n\n                    // Note: the first check is always true,\n\n                    // this could have been a do-while loop.\n\n                    for {\n\n\n\n                    } lt(source, sEnd) {\n\n\n\n                    } {\n\n                        mstore(dest, mload(source))\n\n                        source := add(source, 32)\n\n                        dest := add(dest, 32)\n\n                    }\n\n\n\n                    // Write the last 32 bytes\n\n                    mstore(dEnd, last)\n\n                }\n\n            } else {\n\n                assembly {\n\n                    // We subtract 32 from `sEnd` and `dEnd` because those\n\n                    // are the starting points when copying a word at the end.\n\n                    length := sub(length, 32)\n\n                    let sEnd := add(source, length)\n\n                    let dEnd := add(dest, length)\n\n\n\n                    // Remember the first 32 bytes of source\n\n                    // This needs to be done here and not after the loop\n\n                    // because we may have overwritten the first bytes in\n\n                    // source already due to overlap.\n\n                    let first := mload(source)\n\n\n\n                    // Copy whole words back to front\n\n                    // We use a signed comparisson here to allow dEnd to become\n\n                    // negative (happens when source and dest < 32). Valid\n\n                    // addresses in local memory will never be larger than\n\n                    // 2**255, so they can be safely re-interpreted as signed.\n\n                    // Note: the first check is always true,\n\n                    // this could have been a do-while loop.\n\n                    for {\n\n\n\n                    } slt(dest, dEnd) {\n\n\n\n                    } {\n\n                        mstore(dEnd, mload(sEnd))\n\n                        sEnd := sub(sEnd, 32)\n\n                        dEnd := sub(dEnd, 32)\n\n                    }\n\n\n\n                    // Write the first 32 bytes\n\n                    mstore(dest, first)\n\n                }\n\n            }\n\n        }\n",
          "message": "LibBytes.memCopy (LibERC20Token.sol#143-243) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 284,
          "vulnerability_to_line": 312,
          "vulnerability_code": "    function sliceDestructive(bytes memory b, uint256 from, uint256 to) internal pure returns (bytes memory result) {\n\n        // Ensure that the from and to positions are valid positions for a slice within\n\n        // the byte array that is being used.\n\n        if (from > to) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.FromLessThanOrEqualsToRequired,\n\n                    from,\n\n                    to\n\n                )\n\n            );\n\n        }\n\n        if (to > b.length) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.ToLessThanOrEqualsLengthRequired,\n\n                    to,\n\n                    b.length\n\n                )\n\n            );\n\n        }\n\n\n\n        // Create a new bytes structure around [from, to) in-place.\n\n        assembly {\n\n            result := add(b, from)\n\n            mstore(result, sub(to, from))\n\n        }\n\n        return result;\n",
          "message": "LibBytes.sliceDestructive (LibERC20Token.sol#284-312) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 317,
          "vulnerability_to_line": 337,
          "vulnerability_code": "    function popLastByte(bytes memory b) internal pure returns (bytes1 result) {\n\n        if (b.length == 0) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanZeroRequired,\n\n                    b.length,\n\n                    0\n\n                )\n\n            );\n\n        }\n\n\n\n        // Store last byte.\n\n        result = b[b.length - 1];\n\n\n\n        assembly {\n\n            // Decrement length of byte array.\n\n            let newLen := sub(mload(b), 1)\n\n            mstore(b, newLen)\n\n        }\n\n        return result;\n",
          "message": "LibBytes.popLastByte (LibERC20Token.sol#317-337) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 354,
          "vulnerability_to_line": 378,
          "vulnerability_code": "    function readAddress(bytes memory b, uint256 index) internal pure returns (address result) {\n\n        if (b.length < index + 20) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsTwentyRequired,\n\n                    b.length,\n\n                    index + 20 // 20 is length of address\n\n                )\n\n            );\n\n        }\n\n\n\n        // Add offset to index:\n\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\n\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\n\n        index += 20;\n\n\n\n        // Read address from array memory\n\n        assembly {\n\n            // 1. Add index to address of bytes array\n\n            // 2. Load 32-byte word from memory\n\n            // 3. Apply 20-byte mask to obtain address\n\n            result := and(mload(add(b, index)), 0xffffffffffffffffffffffffffffffffffffffff)\n\n        }\n\n        return result;\n",
          "message": "LibBytes.readAddress (LibERC20Token.sol#354-378) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 384,
          "vulnerability_to_line": 422,
          "vulnerability_code": "    function writeAddress(bytes memory b, uint256 index, address input) internal pure {\n\n        if (b.length < index + 20) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsTwentyRequired,\n\n                    b.length,\n\n                    index + 20 // 20 is length of address\n\n                )\n\n            );\n\n        }\n\n\n\n        // Add offset to index:\n\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\n\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\n\n        index += 20;\n\n\n\n        // Store address into array memory\n\n        assembly {\n\n            // The address occupies 20 bytes and mstore stores 32 bytes.\n\n            // First fetch the 32-byte word where we'll be storing the address, then\n\n            // apply a mask so we have only the bytes in the word that the address will not occupy.\n\n            // Then combine these bytes with the address and store the 32 bytes back to memory with mstore.\n\n\n\n            // 1. Add index to address of bytes array\n\n            // 2. Load 32-byte word from memory\n\n            // 3. Apply 12-byte mask to obtain extra bytes occupying word of memory where we'll store the address\n\n            let neighbors := and(\n\n                mload(add(b, index)),\n\n                0xffffffffffffffffffffffff0000000000000000000000000000000000000000\n\n            )\n\n\n\n            // Make sure input address is clean.\n\n            // (Solidity does not guarantee this)\n\n            input := and(input, 0xffffffffffffffffffffffffffffffffffffffff)\n\n\n\n            // Store the neighbors and address into memory\n\n            mstore(add(b, index), xor(input, neighbors))\n\n        }\n",
          "message": "LibBytes.writeAddress (LibERC20Token.sol#384-422) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 428,
          "vulnerability_to_line": 447,
          "vulnerability_code": "    function readBytes32(bytes memory b, uint256 index) internal pure returns (bytes32 result) {\n\n        if (b.length < index + 32) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsThirtyTwoRequired,\n\n                    b.length,\n\n                    index + 32\n\n                )\n\n            );\n\n        }\n\n\n\n        // Arrays are prefixed by a 256 bit length parameter\n\n        index += 32;\n\n\n\n        // Read the bytes32 from array memory\n\n        assembly {\n\n            result := mload(add(b, index))\n\n        }\n\n        return result;\n",
          "message": "LibBytes.readBytes32 (LibERC20Token.sol#428-447) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 453,
          "vulnerability_to_line": 471,
          "vulnerability_code": "    function writeBytes32(bytes memory b, uint256 index, bytes32 input) internal pure {\n\n        if (b.length < index + 32) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsThirtyTwoRequired,\n\n                    b.length,\n\n                    index + 32\n\n                )\n\n            );\n\n        }\n\n\n\n        // Arrays are prefixed by a 256 bit length parameter\n\n        index += 32;\n\n\n\n        // Read the bytes32 from array memory\n\n        assembly {\n\n            mstore(add(b, index), input)\n\n        }\n",
          "message": "LibBytes.writeBytes32 (LibERC20Token.sol#453-471) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 494,
          "vulnerability_to_line": 516,
          "vulnerability_code": "    function readBytes4(bytes memory b, uint256 index) internal pure returns (bytes4 result) {\n\n        if (b.length < index + 4) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsFourRequired,\n\n                    b.length,\n\n                    index + 4\n\n                )\n\n            );\n\n        }\n\n\n\n        // Arrays are prefixed by a 32 byte length field\n\n        index += 32;\n\n\n\n        // Read the bytes4 from array memory\n\n        assembly {\n\n            result := mload(add(b, index))\n\n            // Solidity does not require us to clean the trailing bytes.\n\n            // We do it anyway\n\n            result := and(result, 0xFFFFFFFF00000000000000000000000000000000000000000000000000000000)\n\n        }\n\n        return result;\n",
          "message": "LibBytes.readBytes4 (LibERC20Token.sol#494-516) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 523,
          "vulnerability_to_line": 527,
          "vulnerability_code": "    function writeLength(bytes memory b, uint256 length) internal pure {\n\n        assembly {\n\n            mstore(b, length)\n\n        }\n",
          "message": "LibBytes.writeLength (LibERC20Token.sol#523-527) is declared view but contains assembly code\n"
        },
        {
          "name": "shadowing-local",
          "vulnerability_from_line": 656,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint256 allowance\n",
          "message": "LibERC20Token.approve.allowance (local variable @ LibERC20Token.sol#656) shadows:\n\t- LibERC20Token.allowance (function @ LibERC20Token.sol#754-769)\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 38,
          "vulnerability_to_line": 42,
          "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
          "message": "LibRichErrors.rrevert uses assembly (LibERC20Token.sol#38-42)\n\t- LibERC20Token.sol#39-41\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 122,
          "vulnerability_to_line": 127,
          "vulnerability_code": "    function rawAddress(bytes memory input) internal pure returns (uint256 memoryAddress) {\n\n        assembly {\n\n            memoryAddress := input\n\n        }\n\n        return memoryAddress;\n",
          "message": "LibBytes.rawAddress uses assembly (LibERC20Token.sol#122-127)\n\t- LibERC20Token.sol#123-125\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 132,
          "vulnerability_to_line": 137,
          "vulnerability_code": "    function contentAddress(bytes memory input) internal pure returns (uint256 memoryAddress) {\n\n        assembly {\n\n            memoryAddress := add(input, 32)\n\n        }\n\n        return memoryAddress;\n",
          "message": "LibBytes.contentAddress uses assembly (LibERC20Token.sol#132-137)\n\t- LibERC20Token.sol#133-135\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 143,
          "vulnerability_to_line": 243,
          "vulnerability_code": "    function memCopy(uint256 dest, uint256 source, uint256 length) internal pure {\n\n        if (length < 32) {\n\n            // Handle a partial word by reading destination and masking\n\n            // off the bits we are interested in.\n\n            // This correctly handles overlap, zero lengths and source == dest\n\n            assembly {\n\n                let mask := sub(exp(256, sub(32, length)), 1)\n\n                let s := and(mload(source), not(mask))\n\n                let d := and(mload(dest), mask)\n\n                mstore(dest, or(s, d))\n\n            }\n\n        } else {\n\n            // Skip the O(length) loop when source == dest.\n\n            if (source == dest) {\n\n                return;\n\n            }\n\n\n\n            // For large copies we copy whole words at a time. The final\n\n            // word is aligned to the end of the range (instead of after the\n\n            // previous) to handle partial words. So a copy will look like this:\n\n            //\n\n            //  ####\n\n            //      ####\n\n            //          ####\n\n            //            ####\n\n            //\n\n            // We handle overlap in the source and destination range by\n\n            // changing the copying direction. This prevents us from\n\n            // overwriting parts of source that we still need to copy.\n\n            //\n\n            // This correctly handles source == dest\n\n            //\n\n            if (source > dest) {\n\n                assembly {\n\n                    // We subtract 32 from `sEnd` and `dEnd` because it\n\n                    // is easier to compare with in the loop, and these\n\n                    // are also the addresses we need for copying the\n\n                    // last bytes.\n\n                    length := sub(length, 32)\n\n                    let sEnd := add(source, length)\n\n                    let dEnd := add(dest, length)\n\n\n\n                    // Remember the last 32 bytes of source\n\n                    // This needs to be done here and not after the loop\n\n                    // because we may have overwritten the last bytes in\n\n                    // source already due to overlap.\n\n                    let last := mload(sEnd)\n\n\n\n                    // Copy whole words front to back\n\n                    // Note: the first check is always true,\n\n                    // this could have been a do-while loop.\n\n                    for {\n\n\n\n                    } lt(source, sEnd) {\n\n\n\n                    } {\n\n                        mstore(dest, mload(source))\n\n                        source := add(source, 32)\n\n                        dest := add(dest, 32)\n\n                    }\n\n\n\n                    // Write the last 32 bytes\n\n                    mstore(dEnd, last)\n\n                }\n\n            } else {\n\n                assembly {\n\n                    // We subtract 32 from `sEnd` and `dEnd` because those\n\n                    // are the starting points when copying a word at the end.\n\n                    length := sub(length, 32)\n\n                    let sEnd := add(source, length)\n\n                    let dEnd := add(dest, length)\n\n\n\n                    // Remember the first 32 bytes of source\n\n                    // This needs to be done here and not after the loop\n\n                    // because we may have overwritten the first bytes in\n\n                    // source already due to overlap.\n\n                    let first := mload(source)\n\n\n\n                    // Copy whole words back to front\n\n                    // We use a signed comparisson here to allow dEnd to become\n\n                    // negative (happens when source and dest < 32). Valid\n\n                    // addresses in local memory will never be larger than\n\n                    // 2**255, so they can be safely re-interpreted as signed.\n\n                    // Note: the first check is always true,\n\n                    // this could have been a do-while loop.\n\n                    for {\n\n\n\n                    } slt(dest, dEnd) {\n\n\n\n                    } {\n\n                        mstore(dEnd, mload(sEnd))\n\n                        sEnd := sub(sEnd, 32)\n\n                        dEnd := sub(dEnd, 32)\n\n                    }\n\n\n\n                    // Write the first 32 bytes\n\n                    mstore(dest, first)\n\n                }\n\n            }\n\n        }\n",
          "message": "LibBytes.memCopy uses assembly (LibERC20Token.sol#143-243)\n\t- LibERC20Token.sol#148-153\n\t- LibERC20Token.sol#176-206\n\t- LibERC20Token.sol#208-240\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 284,
          "vulnerability_to_line": 312,
          "vulnerability_code": "    function sliceDestructive(bytes memory b, uint256 from, uint256 to) internal pure returns (bytes memory result) {\n\n        // Ensure that the from and to positions are valid positions for a slice within\n\n        // the byte array that is being used.\n\n        if (from > to) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.FromLessThanOrEqualsToRequired,\n\n                    from,\n\n                    to\n\n                )\n\n            );\n\n        }\n\n        if (to > b.length) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.ToLessThanOrEqualsLengthRequired,\n\n                    to,\n\n                    b.length\n\n                )\n\n            );\n\n        }\n\n\n\n        // Create a new bytes structure around [from, to) in-place.\n\n        assembly {\n\n            result := add(b, from)\n\n            mstore(result, sub(to, from))\n\n        }\n\n        return result;\n",
          "message": "LibBytes.sliceDestructive uses assembly (LibERC20Token.sol#284-312)\n\t- LibERC20Token.sol#307-310\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 317,
          "vulnerability_to_line": 337,
          "vulnerability_code": "    function popLastByte(bytes memory b) internal pure returns (bytes1 result) {\n\n        if (b.length == 0) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanZeroRequired,\n\n                    b.length,\n\n                    0\n\n                )\n\n            );\n\n        }\n\n\n\n        // Store last byte.\n\n        result = b[b.length - 1];\n\n\n\n        assembly {\n\n            // Decrement length of byte array.\n\n            let newLen := sub(mload(b), 1)\n\n            mstore(b, newLen)\n\n        }\n\n        return result;\n",
          "message": "LibBytes.popLastByte uses assembly (LibERC20Token.sol#317-337)\n\t- LibERC20Token.sol#331-335\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 354,
          "vulnerability_to_line": 378,
          "vulnerability_code": "    function readAddress(bytes memory b, uint256 index) internal pure returns (address result) {\n\n        if (b.length < index + 20) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsTwentyRequired,\n\n                    b.length,\n\n                    index + 20 // 20 is length of address\n\n                )\n\n            );\n\n        }\n\n\n\n        // Add offset to index:\n\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\n\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\n\n        index += 20;\n\n\n\n        // Read address from array memory\n\n        assembly {\n\n            // 1. Add index to address of bytes array\n\n            // 2. Load 32-byte word from memory\n\n            // 3. Apply 20-byte mask to obtain address\n\n            result := and(mload(add(b, index)), 0xffffffffffffffffffffffffffffffffffffffff)\n\n        }\n\n        return result;\n",
          "message": "LibBytes.readAddress uses assembly (LibERC20Token.sol#354-378)\n\t- LibERC20Token.sol#371-376\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 384,
          "vulnerability_to_line": 422,
          "vulnerability_code": "    function writeAddress(bytes memory b, uint256 index, address input) internal pure {\n\n        if (b.length < index + 20) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsTwentyRequired,\n\n                    b.length,\n\n                    index + 20 // 20 is length of address\n\n                )\n\n            );\n\n        }\n\n\n\n        // Add offset to index:\n\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\n\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\n\n        index += 20;\n\n\n\n        // Store address into array memory\n\n        assembly {\n\n            // The address occupies 20 bytes and mstore stores 32 bytes.\n\n            // First fetch the 32-byte word where we'll be storing the address, then\n\n            // apply a mask so we have only the bytes in the word that the address will not occupy.\n\n            // Then combine these bytes with the address and store the 32 bytes back to memory with mstore.\n\n\n\n            // 1. Add index to address of bytes array\n\n            // 2. Load 32-byte word from memory\n\n            // 3. Apply 12-byte mask to obtain extra bytes occupying word of memory where we'll store the address\n\n            let neighbors := and(\n\n                mload(add(b, index)),\n\n                0xffffffffffffffffffffffff0000000000000000000000000000000000000000\n\n            )\n\n\n\n            // Make sure input address is clean.\n\n            // (Solidity does not guarantee this)\n\n            input := and(input, 0xffffffffffffffffffffffffffffffffffffffff)\n\n\n\n            // Store the neighbors and address into memory\n\n            mstore(add(b, index), xor(input, neighbors))\n\n        }\n",
          "message": "LibBytes.writeAddress uses assembly (LibERC20Token.sol#384-422)\n\t- LibERC20Token.sol#401-421\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 428,
          "vulnerability_to_line": 447,
          "vulnerability_code": "    function readBytes32(bytes memory b, uint256 index) internal pure returns (bytes32 result) {\n\n        if (b.length < index + 32) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsThirtyTwoRequired,\n\n                    b.length,\n\n                    index + 32\n\n                )\n\n            );\n\n        }\n\n\n\n        // Arrays are prefixed by a 256 bit length parameter\n\n        index += 32;\n\n\n\n        // Read the bytes32 from array memory\n\n        assembly {\n\n            result := mload(add(b, index))\n\n        }\n\n        return result;\n",
          "message": "LibBytes.readBytes32 uses assembly (LibERC20Token.sol#428-447)\n\t- LibERC20Token.sol#443-445\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 453,
          "vulnerability_to_line": 471,
          "vulnerability_code": "    function writeBytes32(bytes memory b, uint256 index, bytes32 input) internal pure {\n\n        if (b.length < index + 32) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsThirtyTwoRequired,\n\n                    b.length,\n\n                    index + 32\n\n                )\n\n            );\n\n        }\n\n\n\n        // Arrays are prefixed by a 256 bit length parameter\n\n        index += 32;\n\n\n\n        // Read the bytes32 from array memory\n\n        assembly {\n\n            mstore(add(b, index), input)\n\n        }\n",
          "message": "LibBytes.writeBytes32 uses assembly (LibERC20Token.sol#453-471)\n\t- LibERC20Token.sol#468-470\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 494,
          "vulnerability_to_line": 516,
          "vulnerability_code": "    function readBytes4(bytes memory b, uint256 index) internal pure returns (bytes4 result) {\n\n        if (b.length < index + 4) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsFourRequired,\n\n                    b.length,\n\n                    index + 4\n\n                )\n\n            );\n\n        }\n\n\n\n        // Arrays are prefixed by a 32 byte length field\n\n        index += 32;\n\n\n\n        // Read the bytes4 from array memory\n\n        assembly {\n\n            result := mload(add(b, index))\n\n            // Solidity does not require us to clean the trailing bytes.\n\n            // We do it anyway\n\n            result := and(result, 0xFFFFFFFF00000000000000000000000000000000000000000000000000000000)\n\n        }\n\n        return result;\n",
          "message": "LibBytes.readBytes4 uses assembly (LibERC20Token.sol#494-516)\n\t- LibERC20Token.sol#509-514\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 523,
          "vulnerability_to_line": 527,
          "vulnerability_code": "    function writeLength(bytes memory b, uint256 length) internal pure {\n\n        assembly {\n\n            mstore(b, length)\n\n        }\n",
          "message": "LibBytes.writeLength uses assembly (LibERC20Token.sol#523-527)\n\t- LibERC20Token.sol#524-526\n"
        },
        {
          "name": "solc-version",
          "vulnerability_from_line": 21,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.9;\n",
          "message": "Detected issues with version pragma in LibERC20Token.sol:\n\t- pragma solidity^0.5.9 (LibERC20Token.sol#21): it allows old versions\n\t- pragma solidity^0.5.9 (LibERC20Token.sol#65): it allows old versions\n\t- pragma solidity^0.5.9 (LibERC20Token.sol#111): it allows old versions\n\t- pragma solidity^0.5.9 (LibERC20Token.sol#550): it allows old versions\n\t- pragma solidity^0.5.9 (LibERC20Token.sol#640): it allows old versions\n"
        },
        {
          "name": "low-level-calls",
          "vulnerability_from_line": 736,
          "vulnerability_to_line": 746,
          "vulnerability_code": "    function decimals(address token)\n\n        internal\n\n        view\n\n        returns (uint8 tokenDecimals)\n\n    {\n\n        tokenDecimals = 18;\n\n        (bool didSucceed, bytes memory resultData) = token.staticcall(DECIMALS_CALL_DATA);\n\n        if (didSucceed && resultData.length == 32) {\n\n            tokenDecimals = uint8(LibBytes.readUint256(resultData, 0));\n\n        }\n",
          "message": "Low level call in LibERC20Token.decimals (LibERC20Token.sol#736-746):\n\t-(didSucceed,resultData) = token.staticcall(DECIMALS_CALL_DATA) LibERC20Token.sol#742\n"
        },
        {
          "name": "low-level-calls",
          "vulnerability_from_line": 754,
          "vulnerability_to_line": 769,
          "vulnerability_code": "    function allowance(address token, address owner, address spender)\n\n        internal\n\n        view\n\n        returns (uint256 allowance_)\n\n    {\n\n        (bool didSucceed, bytes memory resultData) = token.staticcall(\n\n            abi.encodeWithSelector(\n\n                IERC20Token(0).allowance.selector,\n\n                owner,\n\n                spender\n\n            )\n\n        );\n\n        if (didSucceed && resultData.length == 32) {\n\n            allowance_ = LibBytes.readUint256(resultData, 0);\n\n        }\n",
          "message": "Low level call in LibERC20Token.allowance (LibERC20Token.sol#754-769):\n\t-(didSucceed,resultData) = token.staticcall(abi.encodeWithSelector(IERC20Token(0).allowance.selector,owner,spender)) LibERC20Token.sol#759-765\n"
        },
        {
          "name": "low-level-calls",
          "vulnerability_from_line": 776,
          "vulnerability_to_line": 790,
          "vulnerability_code": "    function balanceOf(address token, address owner)\n\n        internal\n\n        view\n\n        returns (uint256 balance)\n\n    {\n\n        (bool didSucceed, bytes memory resultData) = token.staticcall(\n\n            abi.encodeWithSelector(\n\n                IERC20Token(0).balanceOf.selector,\n\n                owner\n\n            )\n\n        );\n\n        if (didSucceed && resultData.length == 32) {\n\n            balance = LibBytes.readUint256(resultData, 0);\n\n        }\n",
          "message": "Low level call in LibERC20Token.balanceOf (LibERC20Token.sol#776-790):\n\t-(didSucceed,resultData) = token.staticcall(abi.encodeWithSelector(IERC20Token(0).balanceOf.selector,owner)) LibERC20Token.sol#781-786\n"
        },
        {
          "name": "low-level-calls",
          "vulnerability_from_line": 797,
          "vulnerability_to_line": 816,
          "vulnerability_code": "    function _callWithOptionalBooleanResult(\n\n        address target,\n\n        bytes memory callData\n\n    )\n\n        private\n\n    {\n\n        (bool didSucceed, bytes memory resultData) = target.call(callData);\n\n        if (didSucceed) {\n\n            if (resultData.length == 0) {\n\n                return;\n\n            }\n\n            if (resultData.length == 32) {\n\n                uint256 result = LibBytes.readUint256(resultData, 0);\n\n                if (result == 1) {\n\n                    return;\n\n                }\n\n            }\n\n        }\n\n        LibRichErrors.rrevert(resultData);\n",
          "message": "Low level call in LibERC20Token._callWithOptionalBooleanResult (LibERC20Token.sol#797-816):\n\t-(didSucceed,resultData) = target.call(callData) LibERC20Token.sol#803\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 32,
          "vulnerability_to_line": 34,
          "vulnerability_code": "    function StandardError(string memory message) internal pure returns (bytes memory) {\n\n        return abi.encodeWithSelector(STANDARD_ERROR_SELECTOR, bytes(message));\n",
          "message": "Function 'LibRichErrors.StandardError' (LibERC20Token.sol#32-34) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 82,
          "vulnerability_to_line": 88,
          "vulnerability_code": "    function InvalidByteOperationError(\n\n        InvalidByteOperationErrorCodes errorCode,\n\n        uint256 offset,\n\n        uint256 required\n\n    ) internal pure returns (bytes memory) {\n\n        return abi.encodeWithSelector(INVALID_BYTE_OPERATION_ERROR_SELECTOR, errorCode, offset, required);\n",
          "message": "Function 'LibBytesRichErrors.InvalidByteOperationError' (LibERC20Token.sol#82-88) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 797,
          "vulnerability_to_line": 816,
          "vulnerability_code": "    function _callWithOptionalBooleanResult(\n\n        address target,\n\n        bytes memory callData\n\n    )\n\n        private\n\n    {\n\n        (bool didSucceed, bytes memory resultData) = target.call(callData);\n\n        if (didSucceed) {\n\n            if (resultData.length == 0) {\n\n                return;\n\n            }\n\n            if (resultData.length == 32) {\n\n                uint256 result = LibBytes.readUint256(resultData, 0);\n\n                if (result == 1) {\n\n                    return;\n\n                }\n\n            }\n\n        }\n\n        LibRichErrors.rrevert(resultData);\n",
          "message": "Function 'LibERC20Token._callWithOptionalBooleanResult' (LibERC20Token.sol#797-816) is not in mixedCase\n"
        }
      ]
    },
    "smartcheck": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 25,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bytes4 internal constant STANDARD_ERROR_SELECTOR = 0x08c379a0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 80,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bytes4 internal constant INVALID_BYTE_OPERATION_ERROR_SELECTOR = 0x28006595;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 21,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.9;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 65,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.9;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 111,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.9;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 550,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.9;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 640,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.9;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 645,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bytes constant private DECIMALS_CALL_DATA = hex\"313ce567\";\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 38,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 122,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function rawAddress(bytes memory input) internal pure returns (uint256 memoryAddress) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 132,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function contentAddress(bytes memory input) internal pure returns (uint256 memoryAddress) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 143,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function memCopy(uint256 dest, uint256 source, uint256 length) internal pure {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 284,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function sliceDestructive(bytes memory b, uint256 from, uint256 to) internal pure returns (bytes memory result) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 317,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function popLastByte(bytes memory b) internal pure returns (bytes1 result) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 354,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function readAddress(bytes memory b, uint256 index) internal pure returns (address result) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 384,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function writeAddress(bytes memory b, uint256 index, address input) internal pure {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 428,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function readBytes32(bytes memory b, uint256 index) internal pure returns (bytes32 result) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 453,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function writeBytes32(bytes memory b, uint256 index, bytes32 input) internal pure {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 494,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function readBytes4(bytes memory b, uint256 index) internal pure returns (bytes4 result) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 523,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function writeLength(bytes memory b, uint256 length) internal pure {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UNCHECKED_CALL",
          "vulnerability_from_line": 665,
          "vulnerability_to_line": null,
          "vulnerability_code": "        _callWithOptionalBooleanResult(token, callData);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UNCHECKED_CALL",
          "vulnerability_from_line": 705,
          "vulnerability_to_line": null,
          "vulnerability_code": "        _callWithOptionalBooleanResult(token, callData);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UNCHECKED_CALL",
          "vulnerability_from_line": 729,
          "vulnerability_to_line": null,
          "vulnerability_code": "        _callWithOptionalBooleanResult(token, callData);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UNCHECKED_CALL",
          "vulnerability_from_line": 742,
          "vulnerability_to_line": null,
          "vulnerability_code": "        (bool didSucceed, bytes memory resultData) = token.staticcall(DECIMALS_CALL_DATA);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UNCHECKED_CALL",
          "vulnerability_from_line": 759,
          "vulnerability_to_line": null,
          "vulnerability_code": "        (bool didSucceed, bytes memory resultData) = token.staticcall(\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UNCHECKED_CALL",
          "vulnerability_from_line": 781,
          "vulnerability_to_line": null,
          "vulnerability_code": "        (bool didSucceed, bytes memory resultData) = token.staticcall(\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UNCHECKED_CALL",
          "vulnerability_from_line": 803,
          "vulnerability_to_line": null,
          "vulnerability_code": "        (bool didSucceed, bytes memory resultData) = target.call(callData);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 39,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 123,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 133,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 148,
          "vulnerability_to_line": null,
          "vulnerability_code": "            assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 176,
          "vulnerability_to_line": null,
          "vulnerability_code": "                assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 208,
          "vulnerability_to_line": null,
          "vulnerability_code": "                assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 307,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 331,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 371,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 401,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 443,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 468,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 509,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 524,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        }
      ]
    },
    "oyente": {
      "successfull_analysis": false,
      "errors": [
        "exception (IndexError: pop from empty list)"
      ],
      "vulnerability_findings": []
    },
    "mythril": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": []
    },
    "osiris": {
      "successfull_analysis": false,
      "errors": [
        "Solidity compilation failed"
      ],
      "vulnerability_findings": []
    }
  }
}