{
  "smartbugs_completed": true,
  "analyzer_results": {
    "semgrep": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 262,
          "vulnerability_to_line": null,
          "vulnerability_code": "            for (i = 0; i < previousValidators.length; i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 265,
          "vulnerability_to_line": null,
          "vulnerability_code": "            for (i = 0; i < currentValidators.length; i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 557,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (i = 0; i < prevValidators.length; i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 565,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (i = 0; i < _queueValidators.length; i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 662,
          "vulnerability_to_line": null,
          "vulnerability_code": "                for (uint256 i = 0; i < newValidators.length; i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 708,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 i = 0; i < miningAddresses.length; i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 711,
          "vulnerability_to_line": null,
          "vulnerability_code": "                miningAddresses[i] = miningAddresses[miningAddresses.length - 1];\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 712,
          "vulnerability_to_line": null,
          "vulnerability_code": "                miningAddresses.length--;\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 771,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (i = 0; i < _stakingAddresses.length; i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 776,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (i = 0; i < poolsToBeRemoved.length; i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 1095,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 m = 0; m < reportedValidators.length; m++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 316,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 i = 0; i < _initialMiningAddresses.length; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 662,
          "vulnerability_to_line": null,
          "vulnerability_code": "                for (uint256 i = 0; i < newValidators.length; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 708,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 i = 0; i < miningAddresses.length; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 1095,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 m = 0; m < reportedValidators.length; m++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 254,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (validatorSetApplyBlock() == 0 && newStakingEpoch) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 255,
          "vulnerability_to_line": null,
          "vulnerability_code": "            // Apply a new validator set formed by the `newValidatorSet` function\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 256,
          "vulnerability_to_line": null,
          "vulnerability_code": "\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 257,
          "vulnerability_to_line": null,
          "vulnerability_code": "            address[] memory previousValidators = getPreviousValidators();\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 258,
          "vulnerability_to_line": null,
          "vulnerability_code": "            address[] memory currentValidators = getValidators();\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 259,
          "vulnerability_to_line": null,
          "vulnerability_code": "            uint256 i;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 260,
          "vulnerability_to_line": null,
          "vulnerability_code": "\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 261,
          "vulnerability_to_line": null,
          "vulnerability_code": "            // Save the previous validator set\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 262,
          "vulnerability_to_line": null,
          "vulnerability_code": "            for (i = 0; i < previousValidators.length; i++) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 263,
          "vulnerability_to_line": null,
          "vulnerability_code": "                _setIsValidatorOnPreviousEpoch(previousValidators[i], false);\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 648,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 649,
          "vulnerability_to_line": null,
          "vulnerability_code": "            poolsToBeElected.length >= MAX_VALIDATORS &&\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 650,
          "vulnerability_to_line": null,
          "vulnerability_code": "            (poolsToBeElected.length != MAX_VALIDATORS || unremovableStakingAddress != address(0))\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 651,
          "vulnerability_to_line": null,
          "vulnerability_code": "        ) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 652,
          "vulnerability_to_line": null,
          "vulnerability_code": "            uint256 randomNumber = IRandom(randomContract()).getCurrentSeed();\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 653,
          "vulnerability_to_line": null,
          "vulnerability_code": "\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 654,
          "vulnerability_to_line": null,
          "vulnerability_code": "            (int256[] memory likelihood, int256 likelihoodSum) = staking.getPoolsLikelihood();\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 655,
          "vulnerability_to_line": null,
          "vulnerability_code": "\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 656,
          "vulnerability_to_line": null,
          "vulnerability_code": "            if (likelihood.length > 0 && likelihoodSum > 0) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 657,
          "vulnerability_to_line": null,
          "vulnerability_code": "                address[] memory newValidators = new address[](\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 656,
          "vulnerability_to_line": null,
          "vulnerability_code": "            if (likelihood.length > 0 && likelihoodSum > 0) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 657,
          "vulnerability_to_line": null,
          "vulnerability_code": "                address[] memory newValidators = new address[](\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 658,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    unremovableStakingAddress == address(0) ? MAX_VALIDATORS : MAX_VALIDATORS - 1\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 659,
          "vulnerability_to_line": null,
          "vulnerability_code": "                );\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 660,
          "vulnerability_to_line": null,
          "vulnerability_code": "\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 661,
          "vulnerability_to_line": null,
          "vulnerability_code": "                uint256 poolsToBeElectedLength = poolsToBeElected.length;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 662,
          "vulnerability_to_line": null,
          "vulnerability_code": "                for (uint256 i = 0; i < newValidators.length; i++) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 663,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    randomNumber = uint256(keccak256(abi.encode(randomNumber)));\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 664,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    uint256 randomPoolIndex = _getRandomIndex(likelihood, likelihoodSum, randomNumber);\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 665,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    newValidators[i] = poolsToBeElected[randomPoolIndex];\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 1076,
          "vulnerability_to_line": null,
          "vulnerability_code": "            if (reportsNumber > validatorsNumber * 50 && reportsNumber > averageReportsNumber * 10) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 1077,
          "vulnerability_to_line": null,
          "vulnerability_code": "                return (false, true);\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 1078,
          "vulnerability_to_line": null,
          "vulnerability_code": "            }\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 1086,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (currentBlock > ancientBlocksLimit && _blockNumber < currentBlock - ancientBlocksLimit) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 1087,
          "vulnerability_to_line": null,
          "vulnerability_code": "            return (false, false); // avoid reporting about ancient blocks\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 1088,
          "vulnerability_to_line": null,
          "vulnerability_code": "        }\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-prefix-decrement-not-postfix",
          "vulnerability_from_line": 592,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (int256 i = queueLast; i >= queueFirst; i--) {\n",
          "message": "Consider using the prefix decrement expression whenever the return value is not needed. The prefix decrement expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-decrement-not-postfix",
          "vulnerability_from_line": 667,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    poolsToBeElectedLength--;\n",
          "message": "Consider using the prefix decrement expression whenever the return value is not needed. The prefix decrement expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-decrement-not-postfix",
          "vulnerability_from_line": 712,
          "vulnerability_to_line": null,
          "vulnerability_code": "                miningAddresses.length--;\n",
          "message": "Consider using the prefix decrement expression whenever the return value is not needed. The prefix decrement expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 262,
          "vulnerability_to_line": null,
          "vulnerability_code": "            for (i = 0; i < previousValidators.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 265,
          "vulnerability_to_line": null,
          "vulnerability_code": "            for (i = 0; i < currentValidators.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 316,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 i = 0; i < _initialMiningAddresses.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 557,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (i = 0; i < prevValidators.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 565,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (i = 0; i < _queueValidators.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 577,
          "vulnerability_to_line": null,
          "vulnerability_code": "            uintStorage[keccak256(abi.encode(BAN_COUNTER, _miningAddress))]++;\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 602,
          "vulnerability_to_line": null,
          "vulnerability_code": "        queueLast++;\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 627,
          "vulnerability_to_line": null,
          "vulnerability_code": "            intStorage[QUEUE_PV_FIRST]++;\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 634,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uintStorage[CHANGE_REQUEST_COUNT]++;\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 662,
          "vulnerability_to_line": null,
          "vulnerability_code": "                for (uint256 i = 0; i < newValidators.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 708,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 i = 0; i < miningAddresses.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 737,
          "vulnerability_to_line": null,
          "vulnerability_code": "            uintStorage[keccak256(abi.encode(VALIDATOR_COUNTER, _miningAddress))]++;\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 771,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (i = 0; i < _stakingAddresses.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 776,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (i = 0; i < poolsToBeRemoved.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 858,
          "vulnerability_to_line": null,
          "vulnerability_code": "            index++;\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 1095,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 m = 0; m < reportedValidators.length; m++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 1145,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uintStorage[keccak256(abi.encode(REPORTING_COUNTER, _reportingMiningAddress, currentStakingEpoch))]++;\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 1146,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uintStorage[keccak256(abi.encode(REPORTING_COUNTER_TOTAL, currentStakingEpoch))]++;\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        }
      ]
    },
    "slither": {
      "successfull_analysis": true,
      "errors": [
        "DOCKER_RECEIVED_SIGNAL_33"
      ],
      "vulnerability_findings": [
        {
          "name": "uninitialized-state",
          "vulnerability_from_line": 89,
          "vulnerability_to_line": null,
          "vulnerability_code": "    address internal _owner;\n",
          "message": "EternalStorage._owner (ValidatorSetAuRaMock.sol#89) is never initialized. It is used in:\n\t- clearUnremovableValidator (ValidatorSetAuRaMock.sol#218-223)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 1142,
          "vulnerability_to_line": 1147,
          "vulnerability_code": "    function _incrementReportingCounter(address _reportingMiningAddress) internal {\n\n        if (!isReportValidatorValid(_reportingMiningAddress)) return;\n\n        uint256 currentStakingEpoch = IStaking(stakingContract()).stakingEpoch();\n\n        uintStorage[keccak256(abi.encode(REPORTING_COUNTER, _reportingMiningAddress, currentStakingEpoch))]++;\n\n        uintStorage[keccak256(abi.encode(REPORTING_COUNTER_TOTAL, currentStakingEpoch))]++;\n",
          "message": "Reentrancy in ValidatorSetAuRa._incrementReportingCounter (ValidatorSetAuRaMock.sol#1142-1147):\n\tExternal calls:\n\t- ! isReportValidatorValid(_reportingMiningAddress) (ValidatorSetAuRaMock.sol#1143)\n\t- currentStakingEpoch = IStaking(stakingContract()).stakingEpoch() (ValidatorSetAuRaMock.sol#1144)\n\tState variables written after the call(s):\n\t- uintStorage (ValidatorSetAuRaMock.sol#1145)\n\t- uintStorage (ValidatorSetAuRaMock.sol#1146)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 642,
          "vulnerability_to_line": 687,
          "vulnerability_code": "    function _newValidatorSet() internal returns(uint256) {\n\n        IStaking staking = IStaking(stakingContract());\n\n        address[] memory poolsToBeElected = staking.getPoolsToBeElected();\n\n        address unremovableStakingAddress = unremovableValidator();\n\n\n\n        // Choose new validators\n\n        if (\n\n            poolsToBeElected.length >= MAX_VALIDATORS &&\n\n            (poolsToBeElected.length != MAX_VALIDATORS || unremovableStakingAddress != address(0))\n\n        ) {\n\n            uint256 randomNumber = IRandom(randomContract()).getCurrentSeed();\n\n\n\n            (int256[] memory likelihood, int256 likelihoodSum) = staking.getPoolsLikelihood();\n\n\n\n            if (likelihood.length > 0 && likelihoodSum > 0) {\n\n                address[] memory newValidators = new address[](\n\n                    unremovableStakingAddress == address(0) ? MAX_VALIDATORS : MAX_VALIDATORS - 1\n\n                );\n\n\n\n                uint256 poolsToBeElectedLength = poolsToBeElected.length;\n\n                for (uint256 i = 0; i < newValidators.length; i++) {\n\n                    randomNumber = uint256(keccak256(abi.encode(randomNumber)));\n\n                    uint256 randomPoolIndex = _getRandomIndex(likelihood, likelihoodSum, randomNumber);\n\n                    newValidators[i] = poolsToBeElected[randomPoolIndex];\n\n                    likelihoodSum -= likelihood[randomPoolIndex];\n\n                    poolsToBeElectedLength--;\n\n                    poolsToBeElected[randomPoolIndex] = poolsToBeElected[poolsToBeElectedLength];\n\n                    likelihood[randomPoolIndex] = likelihood[poolsToBeElectedLength];\n\n                }\n\n\n\n                _setPendingValidators(staking, newValidators, unremovableStakingAddress);\n\n            }\n\n        } else {\n\n            _setPendingValidators(staking, poolsToBeElected, unremovableStakingAddress);\n\n        }\n\n\n\n        // From this moment the `getPendingValidators()` will return a new validator set\n\n\n\n        staking.incrementStakingEpoch();\n\n        _setValidatorSetApplyBlock(0);\n\n\n\n        _incrementChangeRequestCount();\n\n        _enqueuePendingValidators(true);\n\n\n\n        return poolsToBeElected.length;\n",
          "message": "Reentrancy in ValidatorSetBase._newValidatorSet (ValidatorSetAuRaMock.sol#642-687):\n\tExternal calls:\n\t- poolsToBeElected = staking.getPoolsToBeElected() (ValidatorSetAuRaMock.sol#644)\n\t- randomNumber = IRandom(randomContract()).getCurrentSeed() (ValidatorSetAuRaMock.sol#652)\n\t- (likelihood,likelihoodSum) = staking.getPoolsLikelihood() (ValidatorSetAuRaMock.sol#654)\n\t- _setPendingValidators(staking,newValidators,unremovableStakingAddress) (ValidatorSetAuRaMock.sol#672)\n\t- _setPendingValidators(staking,poolsToBeElected,unremovableStakingAddress) (ValidatorSetAuRaMock.sol#675)\n\t- staking.incrementStakingEpoch() (ValidatorSetAuRaMock.sol#680)\n\tState variables written after the call(s):\n\t- addressArrayStorage (ValidatorSetAuRaMock.sol#684)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 1153,
          "vulnerability_to_line": 1165,
          "vulnerability_code": "    function _removeMaliciousValidatorAuRa(address _miningAddress) internal {\n\n        if (isValidatorBanned(_miningAddress)) {\n\n            // The malicious validator is already banned\n\n            return;\n\n        }\n\n\n\n        if (_removeMaliciousValidator(_miningAddress)) {\n\n            // From this moment `getPendingValidators()` will return the new validator set\n\n            _incrementChangeRequestCount();\n\n            _enqueuePendingValidators(false);\n\n            _clearReportingCounter(_miningAddress);\n\n        }\n",
          "message": "Reentrancy in ValidatorSetAuRa._removeMaliciousValidatorAuRa (ValidatorSetAuRaMock.sol#1153-1165):\n\tExternal calls:\n\t- _removeMaliciousValidator(_miningAddress) (ValidatorSetAuRaMock.sol#1159-1164)\n\tState variables written after the call(s):\n\t- addressArrayStorage (ValidatorSetAuRaMock.sol#1162)\n\t- uintStorage (ValidatorSetAuRaMock.sol#1161)\n\t- uintStorage (ValidatorSetAuRaMock.sol#1162)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 1153,
          "vulnerability_to_line": 1165,
          "vulnerability_code": "    function _removeMaliciousValidatorAuRa(address _miningAddress) internal {\n\n        if (isValidatorBanned(_miningAddress)) {\n\n            // The malicious validator is already banned\n\n            return;\n\n        }\n\n\n\n        if (_removeMaliciousValidator(_miningAddress)) {\n\n            // From this moment `getPendingValidators()` will return the new validator set\n\n            _incrementChangeRequestCount();\n\n            _enqueuePendingValidators(false);\n\n            _clearReportingCounter(_miningAddress);\n\n        }\n",
          "message": "Reentrancy in ValidatorSetAuRa._removeMaliciousValidatorAuRa (ValidatorSetAuRaMock.sol#1153-1165):\n\tExternal calls:\n\t- _removeMaliciousValidator(_miningAddress) (ValidatorSetAuRaMock.sol#1159-1164)\n\t- _clearReportingCounter(_miningAddress) (ValidatorSetAuRaMock.sol#1163)\n\tState variables written after the call(s):\n\t- uintStorage (ValidatorSetAuRaMock.sol#1163)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 960,
          "vulnerability_to_line": 1011,
          "vulnerability_code": "    function reportMalicious(\n\n        address _maliciousMiningAddress,\n\n        uint256 _blockNumber,\n\n        bytes calldata\n\n    ) external onlyInitialized {\n\n        address reportingMiningAddress = msg.sender;\n\n\n\n        _incrementReportingCounter(reportingMiningAddress);\n\n\n\n        (\n\n            bool callable,\n\n            bool removeReportingValidator\n\n        ) = reportMaliciousCallable(\n\n            reportingMiningAddress,\n\n            _maliciousMiningAddress,\n\n            _blockNumber\n\n        );\n\n\n\n        if (!callable) {\n\n            if (removeReportingValidator) {\n\n                // Reporting validator reported too often, so\n\n                // treat them as a malicious as well\n\n                _removeMaliciousValidatorAuRa(reportingMiningAddress);\n\n            }\n\n            return;\n\n        }\n\n\n\n        address[] storage reportedValidators = addressArrayStorage[keccak256(abi.encode(\n\n            MALICE_REPORTED_FOR_BLOCK, _maliciousMiningAddress, _blockNumber\n\n        ))];\n\n\n\n        reportedValidators.push(reportingMiningAddress);\n\n\n\n        emit ReportedMalicious(reportingMiningAddress, _maliciousMiningAddress, _blockNumber);\n\n\n\n        uint256 validatorsLength = getValidators().length;\n\n        bool remove;\n\n\n\n        if (validatorsLength > 3) {\n\n            // If more than 2/3 of validators reported about malicious validator\n\n            // for the same `blockNumber`\n\n            remove = reportedValidators.length.mul(3) > validatorsLength.mul(2);\n\n        } else {\n\n            // If more than 1/2 of validators reported about malicious validator\n\n            // for the same `blockNumber`\n\n            remove = reportedValidators.length.mul(2) > validatorsLength;\n\n        }\n\n\n\n        if (remove) {\n\n            _removeMaliciousValidatorAuRa(_maliciousMiningAddress);\n\n        }\n",
          "message": "Reentrancy in ValidatorSetAuRa.reportMalicious (ValidatorSetAuRaMock.sol#960-1011):\n\tExternal calls:\n\t- _incrementReportingCounter(reportingMiningAddress) (ValidatorSetAuRaMock.sol#967)\n\t- (callable,removeReportingValidator) = reportMaliciousCallable(reportingMiningAddress,_maliciousMiningAddress,_blockNumber) (ValidatorSetAuRaMock.sol#969-976)\n\t- _removeMaliciousValidatorAuRa(reportingMiningAddress) (ValidatorSetAuRaMock.sol#982)\n\tState variables written after the call(s):\n\t- addressArrayStorage (ValidatorSetAuRaMock.sol#982)\n\t- boolStorage (ValidatorSetAuRaMock.sol#982)\n\t- uintStorage (ValidatorSetAuRaMock.sol#982)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 960,
          "vulnerability_to_line": 1011,
          "vulnerability_code": "    function reportMalicious(\n\n        address _maliciousMiningAddress,\n\n        uint256 _blockNumber,\n\n        bytes calldata\n\n    ) external onlyInitialized {\n\n        address reportingMiningAddress = msg.sender;\n\n\n\n        _incrementReportingCounter(reportingMiningAddress);\n\n\n\n        (\n\n            bool callable,\n\n            bool removeReportingValidator\n\n        ) = reportMaliciousCallable(\n\n            reportingMiningAddress,\n\n            _maliciousMiningAddress,\n\n            _blockNumber\n\n        );\n\n\n\n        if (!callable) {\n\n            if (removeReportingValidator) {\n\n                // Reporting validator reported too often, so\n\n                // treat them as a malicious as well\n\n                _removeMaliciousValidatorAuRa(reportingMiningAddress);\n\n            }\n\n            return;\n\n        }\n\n\n\n        address[] storage reportedValidators = addressArrayStorage[keccak256(abi.encode(\n\n            MALICE_REPORTED_FOR_BLOCK, _maliciousMiningAddress, _blockNumber\n\n        ))];\n\n\n\n        reportedValidators.push(reportingMiningAddress);\n\n\n\n        emit ReportedMalicious(reportingMiningAddress, _maliciousMiningAddress, _blockNumber);\n\n\n\n        uint256 validatorsLength = getValidators().length;\n\n        bool remove;\n\n\n\n        if (validatorsLength > 3) {\n\n            // If more than 2/3 of validators reported about malicious validator\n\n            // for the same `blockNumber`\n\n            remove = reportedValidators.length.mul(3) > validatorsLength.mul(2);\n\n        } else {\n\n            // If more than 1/2 of validators reported about malicious validator\n\n            // for the same `blockNumber`\n\n            remove = reportedValidators.length.mul(2) > validatorsLength;\n\n        }\n\n\n\n        if (remove) {\n\n            _removeMaliciousValidatorAuRa(_maliciousMiningAddress);\n\n        }\n",
          "message": "Reentrancy in ValidatorSetAuRa.reportMalicious (ValidatorSetAuRaMock.sol#960-1011):\n\tExternal calls:\n\t- _incrementReportingCounter(reportingMiningAddress) (ValidatorSetAuRaMock.sol#967)\n\t- (callable,removeReportingValidator) = reportMaliciousCallable(reportingMiningAddress,_maliciousMiningAddress,_blockNumber) (ValidatorSetAuRaMock.sol#969-976)\n\t- _removeMaliciousValidatorAuRa(_maliciousMiningAddress) (ValidatorSetAuRaMock.sol#1009)\n\tState variables written after the call(s):\n\t- addressArrayStorage (ValidatorSetAuRaMock.sol#1009)\n\t- boolStorage (ValidatorSetAuRaMock.sol#1009)\n\t- uintStorage (ValidatorSetAuRaMock.sol#1009)\n"
        },
        {
          "name": "shadowing-local",
          "vulnerability_from_line": 941,
          "vulnerability_to_line": null,
          "vulnerability_code": "        IStakingAuRa stakingContract = IStakingAuRa(stakingContract());\n",
          "message": "ValidatorSetAuRa.newValidatorSet.stakingContract (local variable @ ValidatorSetAuRaMock.sol#941) shadows:\n\t- ValidatorSetBase.stakingContract (function @ ValidatorSetAuRaMock.sol#485-487)\n\t- IValidatorSet.stakingContract (function @ ValidatorSetAuRaMock.sol#73)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 1124,
          "vulnerability_to_line": 1136,
          "vulnerability_code": "    function _clearReportingCounter(address _miningAddress) internal {\n\n        uint256 currentStakingEpoch = IStaking(stakingContract()).stakingEpoch();\n\n        uint256 total = reportingCounterTotal(currentStakingEpoch);\n\n        uint256 counter = reportingCounter(_miningAddress, currentStakingEpoch);\n\n\n\n        uintStorage[keccak256(abi.encode(REPORTING_COUNTER, _miningAddress, currentStakingEpoch))] = 0;\n\n\n\n        if (total >= counter) {\n\n            uintStorage[keccak256(abi.encode(REPORTING_COUNTER_TOTAL, currentStakingEpoch))] -= counter;\n\n        } else {\n\n            uintStorage[keccak256(abi.encode(REPORTING_COUNTER_TOTAL, currentStakingEpoch))] = 0;\n\n        }\n",
          "message": "Reentrancy in ValidatorSetAuRa._clearReportingCounter (ValidatorSetAuRaMock.sol#1124-1136):\n\tExternal calls:\n\t- currentStakingEpoch = IStaking(stakingContract()).stakingEpoch() (ValidatorSetAuRaMock.sol#1125)\n\tState variables written after the call(s):\n\t- uintStorage (ValidatorSetAuRaMock.sol#1129)\n\t- uintStorage (ValidatorSetAuRaMock.sol#1132)\n\t- uintStorage (ValidatorSetAuRaMock.sol#1134)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 642,
          "vulnerability_to_line": 687,
          "vulnerability_code": "    function _newValidatorSet() internal returns(uint256) {\n\n        IStaking staking = IStaking(stakingContract());\n\n        address[] memory poolsToBeElected = staking.getPoolsToBeElected();\n\n        address unremovableStakingAddress = unremovableValidator();\n\n\n\n        // Choose new validators\n\n        if (\n\n            poolsToBeElected.length >= MAX_VALIDATORS &&\n\n            (poolsToBeElected.length != MAX_VALIDATORS || unremovableStakingAddress != address(0))\n\n        ) {\n\n            uint256 randomNumber = IRandom(randomContract()).getCurrentSeed();\n\n\n\n            (int256[] memory likelihood, int256 likelihoodSum) = staking.getPoolsLikelihood();\n\n\n\n            if (likelihood.length > 0 && likelihoodSum > 0) {\n\n                address[] memory newValidators = new address[](\n\n                    unremovableStakingAddress == address(0) ? MAX_VALIDATORS : MAX_VALIDATORS - 1\n\n                );\n\n\n\n                uint256 poolsToBeElectedLength = poolsToBeElected.length;\n\n                for (uint256 i = 0; i < newValidators.length; i++) {\n\n                    randomNumber = uint256(keccak256(abi.encode(randomNumber)));\n\n                    uint256 randomPoolIndex = _getRandomIndex(likelihood, likelihoodSum, randomNumber);\n\n                    newValidators[i] = poolsToBeElected[randomPoolIndex];\n\n                    likelihoodSum -= likelihood[randomPoolIndex];\n\n                    poolsToBeElectedLength--;\n\n                    poolsToBeElected[randomPoolIndex] = poolsToBeElected[poolsToBeElectedLength];\n\n                    likelihood[randomPoolIndex] = likelihood[poolsToBeElectedLength];\n\n                }\n\n\n\n                _setPendingValidators(staking, newValidators, unremovableStakingAddress);\n\n            }\n\n        } else {\n\n            _setPendingValidators(staking, poolsToBeElected, unremovableStakingAddress);\n\n        }\n\n\n\n        // From this moment the `getPendingValidators()` will return a new validator set\n\n\n\n        staking.incrementStakingEpoch();\n\n        _setValidatorSetApplyBlock(0);\n\n\n\n        _incrementChangeRequestCount();\n\n        _enqueuePendingValidators(true);\n\n\n\n        return poolsToBeElected.length;\n",
          "message": "Reentrancy in ValidatorSetBase._newValidatorSet (ValidatorSetAuRaMock.sol#642-687):\n\tExternal calls:\n\t- poolsToBeElected = staking.getPoolsToBeElected() (ValidatorSetAuRaMock.sol#644)\n\t- randomNumber = IRandom(randomContract()).getCurrentSeed() (ValidatorSetAuRaMock.sol#652)\n\t- (likelihood,likelihoodSum) = staking.getPoolsLikelihood() (ValidatorSetAuRaMock.sol#654)\n\t- _setPendingValidators(staking,newValidators,unremovableStakingAddress) (ValidatorSetAuRaMock.sol#672)\n\t- _setPendingValidators(staking,poolsToBeElected,unremovableStakingAddress) (ValidatorSetAuRaMock.sol#675)\n\t- staking.incrementStakingEpoch() (ValidatorSetAuRaMock.sol#680)\n\tState variables written after the call(s):\n\t- boolStorage (ValidatorSetAuRaMock.sol#684)\n\t- intStorage (ValidatorSetAuRaMock.sol#684)\n\t- uintStorage (ValidatorSetAuRaMock.sol#681)\n\t- uintStorage (ValidatorSetAuRaMock.sol#683)\n\t- uintStorage (ValidatorSetAuRaMock.sol#684)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 693,
          "vulnerability_to_line": 718,
          "vulnerability_code": "    function _removeMaliciousValidator(address _miningAddress) internal returns(bool) {\n\n        address stakingAddress = stakingByMiningAddress(_miningAddress);\n\n\n\n        if (stakingAddress == unremovableValidator()) {\n\n            return false;\n\n        }\n\n\n\n        // Ban the malicious validator for the next 3 months\n\n        _banValidator(_miningAddress);\n\n\n\n        // Remove malicious validator from the `pools`\n\n        IStaking(stakingContract()).removePool(stakingAddress);\n\n\n\n        address[] storage miningAddresses = addressArrayStorage[PENDING_VALIDATORS];\n\n\n\n        for (uint256 i = 0; i < miningAddresses.length; i++) {\n\n            if (miningAddresses[i] == _miningAddress) {\n\n                // Remove the malicious validator from `pendingValidators`\n\n                miningAddresses[i] = miningAddresses[miningAddresses.length - 1];\n\n                miningAddresses.length--;\n\n                return true;\n\n            }\n\n        }\n\n\n\n        return false;\n",
          "message": "Reentrancy in ValidatorSetBase._removeMaliciousValidator (ValidatorSetAuRaMock.sol#693-718):\n\tExternal calls:\n\t- IStaking(stakingContract()).removePool(stakingAddress) (ValidatorSetAuRaMock.sol#704)\n\tState variables written after the call(s):\n\t- addressArrayStorage (ValidatorSetAuRaMock.sol#711)\n\t- addressArrayStorage (ValidatorSetAuRaMock.sol#712)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 1153,
          "vulnerability_to_line": 1165,
          "vulnerability_code": "    function _removeMaliciousValidatorAuRa(address _miningAddress) internal {\n\n        if (isValidatorBanned(_miningAddress)) {\n\n            // The malicious validator is already banned\n\n            return;\n\n        }\n\n\n\n        if (_removeMaliciousValidator(_miningAddress)) {\n\n            // From this moment `getPendingValidators()` will return the new validator set\n\n            _incrementChangeRequestCount();\n\n            _enqueuePendingValidators(false);\n\n            _clearReportingCounter(_miningAddress);\n\n        }\n",
          "message": "Reentrancy in ValidatorSetAuRa._removeMaliciousValidatorAuRa (ValidatorSetAuRaMock.sol#1153-1165):\n\tExternal calls:\n\t- _removeMaliciousValidator(_miningAddress) (ValidatorSetAuRaMock.sol#1159-1164)\n\tState variables written after the call(s):\n\t- boolStorage (ValidatorSetAuRaMock.sol#1162)\n\t- intStorage (ValidatorSetAuRaMock.sol#1162)\n"
        },
        {
          "name": "constable-states",
          "vulnerability_from_line": 89,
          "vulnerability_to_line": null,
          "vulnerability_code": "    address internal _owner;\n",
          "message": "EternalStorage._owner should be constant (ValidatorSetAuRaMock.sol#89)\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 61,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function changeRequestCount() external view returns(uint256);\n",
          "message": "IValidatorSet.changeRequestCount (ValidatorSetAuRaMock.sol#61) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 365,
          "vulnerability_to_line": 367,
          "vulnerability_code": "    function changeRequestCount() public view returns(uint256) {\n\n        return uintStorage[CHANGE_REQUEST_COUNT];\n",
          "message": "ValidatorSetBase.changeRequestCount (ValidatorSetAuRaMock.sol#365-367) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 506,
          "vulnerability_to_line": 508,
          "vulnerability_code": "    function validatorIndex(address _miningAddress) public view returns(uint256) {\n\n        return uintStorage[keccak256(abi.encode(VALIDATOR_INDEX, _miningAddress))];\n",
          "message": "ValidatorSetBase.validatorIndex (ValidatorSetAuRaMock.sol#506-508) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 75,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function validatorIndex(address) external view returns(uint256);\n",
          "message": "IValidatorSet.validatorIndex (ValidatorSetAuRaMock.sol#75) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 345,
          "vulnerability_to_line": 347,
          "vulnerability_code": "    function banCounter(address _miningAddress) public view returns(uint256) {\n\n        return uintStorage[keccak256(abi.encode(BAN_COUNTER, _miningAddress))];\n",
          "message": "ValidatorSetBase.banCounter (ValidatorSetAuRaMock.sol#345-347) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 497,
          "vulnerability_to_line": 499,
          "vulnerability_code": "    function validatorCounter(address _miningAddress) public view returns(uint256) {\n\n        return uintStorage[keccak256(abi.encode(VALIDATOR_COUNTER, _miningAddress))];\n",
          "message": "ValidatorSetBase.validatorCounter (ValidatorSetAuRaMock.sol#497-499) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 1019,
          "vulnerability_to_line": 1026,
          "vulnerability_code": "    function maliceReportedForBlock(\n\n        address _maliciousMiningAddress,\n\n        uint256 _blockNumber\n\n    ) public view returns(address[] memory) {\n\n        return addressArrayStorage[keccak256(abi.encode(\n\n            MALICE_REPORTED_FOR_BLOCK, _maliciousMiningAddress, _blockNumber\n\n        ))];\n",
          "message": "ValidatorSetAuRa.maliceReportedForBlock (ValidatorSetAuRaMock.sol#1019-1026) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 1183,
          "vulnerability_to_line": 1185,
          "vulnerability_code": "    function clearPendingValidators() public {\n\n        delete addressArrayStorage[PENDING_VALIDATORS];\n",
          "message": "ValidatorSetAuRaMock.clearPendingValidators (ValidatorSetAuRaMock.sol#1183-1185) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 1187,
          "vulnerability_to_line": 1189,
          "vulnerability_code": "    function enqueuePendingValidators() public {\n\n        _enqueuePendingValidators(true);\n",
          "message": "ValidatorSetAuRaMock.enqueuePendingValidators (ValidatorSetAuRaMock.sol#1187-1189) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 1191,
          "vulnerability_to_line": 1193,
          "vulnerability_code": "    function setBannedUntil(address _miningAddress, uint256 _bannedUntil) public {\n\n        uintStorage[keccak256(abi.encode(BANNED_UNTIL, _miningAddress))] = _bannedUntil;\n",
          "message": "ValidatorSetAuRaMock.setBannedUntil (ValidatorSetAuRaMock.sol#1191-1193) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 1195,
          "vulnerability_to_line": 1197,
          "vulnerability_code": "    function setBlockRewardContract(address _address) public {\n\n        addressStorage[BLOCK_REWARD_CONTRACT] = _address;\n",
          "message": "ValidatorSetAuRaMock.setBlockRewardContract (ValidatorSetAuRaMock.sol#1195-1197) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 1199,
          "vulnerability_to_line": 1201,
          "vulnerability_code": "    function setCurrentBlockNumber(uint256 _blockNumber) public {\n\n        uintStorage[keccak256(\"currentBlockNumber\")] = _blockNumber;\n",
          "message": "ValidatorSetAuRaMock.setCurrentBlockNumber (ValidatorSetAuRaMock.sol#1199-1201) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 1203,
          "vulnerability_to_line": 1205,
          "vulnerability_code": "    function setRandomContract(address _address) public {\n\n        addressStorage[RANDOM_CONTRACT] = _address;\n",
          "message": "ValidatorSetAuRaMock.setRandomContract (ValidatorSetAuRaMock.sol#1203-1205) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 1207,
          "vulnerability_to_line": 1209,
          "vulnerability_code": "    function setSystemAddress(address _systemAddress) public {\n\n        addressStorage[keccak256(\"systemAddress\")] = _systemAddress;\n",
          "message": "ValidatorSetAuRaMock.setSystemAddress (ValidatorSetAuRaMock.sol#1207-1209) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 1211,
          "vulnerability_to_line": 1213,
          "vulnerability_code": "    function setValidatorSetApplyBlock(uint256 _blockNumber) public {\n\n        _setValidatorSetApplyBlock(_blockNumber);\n",
          "message": "ValidatorSetAuRaMock.setValidatorSetApplyBlock (ValidatorSetAuRaMock.sol#1211-1213) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 1217,
          "vulnerability_to_line": 1227,
          "vulnerability_code": "    function getRandomIndex(\n\n        int256[] memory _likelihood,\n\n        int256 _likelihoodSum,\n\n        uint256 _randomNumber\n\n    ) public pure returns(uint256) {\n\n        return _getRandomIndex(\n\n            _likelihood,\n\n            _likelihoodSum,\n\n            uint256(keccak256(abi.encode(_randomNumber)))\n\n        );\n",
          "message": "ValidatorSetAuRaMock.getRandomIndex (ValidatorSetAuRaMock.sol#1217-1227) should be declared external\n"
        },
        {
          "name": "solc-version",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity 0.5.9;\n",
          "message": "Detected issues with version pragma in ValidatorSetAuRaMock.sol:\n\t- pragma solidity0.5.9 (ValidatorSetAuRaMock.sol#3): it allows old versions\n\t- pragma solidity0.5.9 (ValidatorSetAuRaMock.sol#17): it allows old versions\n\t- pragma solidity0.5.9 (ValidatorSetAuRaMock.sol#26): it allows old versions\n\t- pragma solidity0.5.9 (ValidatorSetAuRaMock.sol#46): it allows old versions\n\t- pragma solidity0.5.9 (ValidatorSetAuRaMock.sol#81): it allows old versions\n\t- pragma solidity0.5.9 (ValidatorSetAuRaMock.sol#112): it allows old versions\n\t- pragma solidity0.5.9 (ValidatorSetAuRaMock.sol#130): it allows old versions\n\t- pragma solidity0.5.9 (ValidatorSetAuRaMock.sol#169): it allows old versions\n\t- pragma solidity0.5.9 (ValidatorSetAuRaMock.sol#866): it allows old versions\n\t- pragma solidity0.5.9 (ValidatorSetAuRaMock.sol#876): it allows old versions\n\t- pragma solidity0.5.9 (ValidatorSetAuRaMock.sol#898): it allows old versions\n\t- pragma solidity0.5.9 (ValidatorSetAuRaMock.sol#1170): it allows old versions\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 7,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function initialize(address) external;\n",
          "message": "Parameter '' of IBlockReward.initialize (ValidatorSetAuRaMock.sol#7) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 8,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function DELEGATORS_ALIQUOT() external view returns(uint256); // solhint-disable-line func-name-mixedcase\n",
          "message": "Function 'IBlockReward.DELEGATORS_ALIQUOT' (ValidatorSetAuRaMock.sol#8) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 30,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function clearUnremovableValidator(address) external;\n",
          "message": "Parameter '' of IStaking.clearUnremovableValidator (ValidatorSetAuRaMock.sol#30) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 32,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function removePool(address) external;\n",
          "message": "Parameter '' of IStaking.removePool (ValidatorSetAuRaMock.sol#32) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 38,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function poolDelegators(address) external view returns(address[] memory);\n",
          "message": "Parameter '' of IStaking.poolDelegators (ValidatorSetAuRaMock.sol#38) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 39,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function stakeAmountMinusOrderedWithdraw(address, address) external view returns(uint256);\n",
          "message": "Parameter '' of IStaking.stakeAmountMinusOrderedWithdraw (ValidatorSetAuRaMock.sol#39) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 39,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function stakeAmountMinusOrderedWithdraw(address, address) external view returns(uint256);\n",
          "message": "Parameter '_scope_0' of IStaking.stakeAmountMinusOrderedWithdraw (ValidatorSetAuRaMock.sol#39) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 40,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function stakeAmountTotalMinusOrderedWithdraw(address) external view returns(uint256);\n",
          "message": "Parameter '' of IStaking.stakeAmountTotalMinusOrderedWithdraw (ValidatorSetAuRaMock.sol#40) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 51,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address,\n",
          "message": "Parameter '' of IValidatorSet.initialize (ValidatorSetAuRaMock.sol#51) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 52,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address,\n",
          "message": "Parameter '_scope_0' of IValidatorSet.initialize (ValidatorSetAuRaMock.sol#52) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 53,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address,\n",
          "message": "Parameter '_scope_1' of IValidatorSet.initialize (ValidatorSetAuRaMock.sol#53) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 54,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address[] calldata,\n",
          "message": "Parameter '_scope_2' of IValidatorSet.initialize (ValidatorSetAuRaMock.sol#54) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 55,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address[] calldata,\n",
          "message": "Parameter '_scope_3' of IValidatorSet.initialize (ValidatorSetAuRaMock.sol#55) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 56,
          "vulnerability_to_line": null,
          "vulnerability_code": "        bool\n",
          "message": "Parameter '_scope_4' of IValidatorSet.initialize (ValidatorSetAuRaMock.sol#56) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 59,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setStakingAddress(address, address) external;\n",
          "message": "Parameter '' of IValidatorSet.setStakingAddress (ValidatorSetAuRaMock.sol#59) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 59,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setStakingAddress(address, address) external;\n",
          "message": "Parameter '_scope_0' of IValidatorSet.setStakingAddress (ValidatorSetAuRaMock.sol#59) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 66,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function isReportValidatorValid(address) external view returns(bool);\n",
          "message": "Parameter '' of IValidatorSet.isReportValidatorValid (ValidatorSetAuRaMock.sol#66) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 67,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function isValidator(address) external view returns(bool);\n",
          "message": "Parameter '' of IValidatorSet.isValidator (ValidatorSetAuRaMock.sol#67) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 68,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function isValidatorBanned(address) external view returns(bool);\n",
          "message": "Parameter '' of IValidatorSet.isValidatorBanned (ValidatorSetAuRaMock.sol#68) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 69,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function MAX_VALIDATORS() external view returns(uint256); // solhint-disable-line func-name-mixedcase\n",
          "message": "Function 'IValidatorSet.MAX_VALIDATORS' (ValidatorSetAuRaMock.sol#69) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 70,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function miningByStakingAddress(address) external view returns(address);\n",
          "message": "Parameter '' of IValidatorSet.miningByStakingAddress (ValidatorSetAuRaMock.sol#70) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 72,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function stakingByMiningAddress(address) external view returns(address);\n",
          "message": "Parameter '' of IValidatorSet.stakingByMiningAddress (ValidatorSetAuRaMock.sol#72) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 75,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function validatorIndex(address) external view returns(uint256);\n",
          "message": "Parameter '' of IValidatorSet.validatorIndex (ValidatorSetAuRaMock.sol#75) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 89,
          "vulnerability_to_line": null,
          "vulnerability_code": "    address internal _owner;\n",
          "message": "Variable 'EternalStorage._owner' (ValidatorSetAuRaMock.sol#89) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 294,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address _blockRewardContract,\n",
          "message": "Parameter '_blockRewardContract' of ValidatorSetBase.initialize (ValidatorSetAuRaMock.sol#294) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 295,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address _randomContract,\n",
          "message": "Parameter '_randomContract' of ValidatorSetBase.initialize (ValidatorSetAuRaMock.sol#295) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 296,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address _stakingContract,\n",
          "message": "Parameter '_stakingContract' of ValidatorSetBase.initialize (ValidatorSetAuRaMock.sol#296) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 297,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address[] calldata _initialMiningAddresses,\n",
          "message": "Parameter '_initialMiningAddresses' of ValidatorSetBase.initialize (ValidatorSetAuRaMock.sol#297) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 298,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address[] calldata _initialStakingAddresses,\n",
          "message": "Parameter '_initialStakingAddresses' of ValidatorSetBase.initialize (ValidatorSetAuRaMock.sol#298) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 299,
          "vulnerability_to_line": null,
          "vulnerability_code": "        bool _firstValidatorIsUnremovable\n",
          "message": "Parameter '_firstValidatorIsUnremovable' of ValidatorSetBase.initialize (ValidatorSetAuRaMock.sol#299) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 337,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setStakingAddress(address _miningAddress, address _stakingAddress) external onlyStakingContract {\n",
          "message": "Parameter '_miningAddress' of ValidatorSetBase.setStakingAddress (ValidatorSetAuRaMock.sol#337) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 337,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setStakingAddress(address _miningAddress, address _stakingAddress) external onlyStakingContract {\n",
          "message": "Parameter '_stakingAddress' of ValidatorSetBase.setStakingAddress (ValidatorSetAuRaMock.sol#337) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 428,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function isReportValidatorValid(address _miningAddress) public view returns(bool) {\n",
          "message": "Parameter '_miningAddress' of ValidatorSetBase.isReportValidatorValid (ValidatorSetAuRaMock.sol#428) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 447,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function isValidator(address _miningAddress) public view returns(bool) {\n",
          "message": "Parameter '_miningAddress' of ValidatorSetBase.isValidator (ValidatorSetAuRaMock.sol#447) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 461,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function isValidatorBanned(address _miningAddress) public view returns(bool) {\n",
          "message": "Parameter '_miningAddress' of ValidatorSetBase.isValidatorBanned (ValidatorSetAuRaMock.sol#461) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 468,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function miningByStakingAddress(address _stakingAddress) public view returns(address) {\n",
          "message": "Parameter '_stakingAddress' of ValidatorSetBase.miningByStakingAddress (ValidatorSetAuRaMock.sol#468) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 480,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function stakingByMiningAddress(address _miningAddress) public view returns(address) {\n",
          "message": "Parameter '_miningAddress' of ValidatorSetBase.stakingByMiningAddress (ValidatorSetAuRaMock.sol#480) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 506,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function validatorIndex(address _miningAddress) public view returns(uint256) {\n",
          "message": "Parameter '_miningAddress' of ValidatorSetBase.validatorIndex (ValidatorSetAuRaMock.sol#506) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 345,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function banCounter(address _miningAddress) public view returns(uint256) {\n",
          "message": "Parameter '_miningAddress' of ValidatorSetBase.banCounter (ValidatorSetAuRaMock.sol#345) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 354,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function bannedUntil(address _miningAddress) public view returns(uint256) {\n",
          "message": "Parameter '_miningAddress' of ValidatorSetBase.bannedUntil (ValidatorSetAuRaMock.sol#354) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 454,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function isValidatorOnPreviousEpoch(address _miningAddress) public view returns(bool) {\n",
          "message": "Parameter '_miningAddress' of ValidatorSetBase.isValidatorOnPreviousEpoch (ValidatorSetAuRaMock.sol#454) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 497,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function validatorCounter(address _miningAddress) public view returns(uint256) {\n",
          "message": "Parameter '_miningAddress' of ValidatorSetBase.validatorCounter (ValidatorSetAuRaMock.sol#497) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 552,
          "vulnerability_to_line": 569,
          "vulnerability_code": "    function _applyQueueValidators(address[] memory _queueValidators) internal {\n\n        address[] memory prevValidators = getValidators();\n\n        uint256 i;\n\n\n\n        // Clear indexes for old validator set\n\n        for (i = 0; i < prevValidators.length; i++) {\n\n            _setValidatorIndex(prevValidators[i], 0);\n\n            _setIsValidator(prevValidators[i], false);\n\n        }\n\n\n\n        addressArrayStorage[CURRENT_VALIDATORS] = _queueValidators;\n\n\n\n        // Set indexes for new validator set\n\n        for (i = 0; i < _queueValidators.length; i++) {\n\n            _setValidatorIndex(_queueValidators[i], i);\n\n            _setIsValidator(_queueValidators[i], true);\n\n        }\n",
          "message": "Function 'ValidatorSetBase._applyQueueValidators' (ValidatorSetAuRaMock.sol#552-569) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 552,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _applyQueueValidators(address[] memory _queueValidators) internal {\n",
          "message": "Parameter '_queueValidators' of ValidatorSetBase._applyQueueValidators (ValidatorSetAuRaMock.sol#552) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 575,
          "vulnerability_to_line": 581,
          "vulnerability_code": "    function _banValidator(address _miningAddress) internal {\n\n        if (_banStart() > bannedUntil(_miningAddress)) {\n\n            uintStorage[keccak256(abi.encode(BAN_COUNTER, _miningAddress))]++;\n\n        }\n\n\n\n        uintStorage[keccak256(abi.encode(BANNED_UNTIL, _miningAddress))] = _banUntil();\n",
          "message": "Function 'ValidatorSetBase._banValidator' (ValidatorSetAuRaMock.sol#575-581) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 575,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _banValidator(address _miningAddress) internal {\n",
          "message": "Parameter '_miningAddress' of ValidatorSetBase._banValidator (ValidatorSetAuRaMock.sol#575) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 588,
          "vulnerability_to_line": 607,
          "vulnerability_code": "    function _enqueuePendingValidators(bool _newStakingEpoch) internal {\n\n        int256 queueFirst = intStorage[QUEUE_PV_FIRST];\n\n        int256 queueLast = intStorage[QUEUE_PV_LAST];\n\n\n\n        for (int256 i = queueLast; i >= queueFirst; i--) {\n\n            if (uintStorage[keccak256(abi.encode(QUEUE_PV_BLOCK, i))] == _getCurrentBlockNumber()) {\n\n                addressArrayStorage[keccak256(abi.encode(QUEUE_PV_LIST, i))] = getPendingValidators();\n\n                if (_newStakingEpoch) {\n\n                    boolStorage[keccak256(abi.encode(QUEUE_PV_NEW_EPOCH, i))] = true;\n\n                }\n\n                return;\n\n            }\n\n        }\n\n\n\n        queueLast++;\n\n        addressArrayStorage[keccak256(abi.encode(QUEUE_PV_LIST, queueLast))] = getPendingValidators();\n\n        boolStorage[keccak256(abi.encode(QUEUE_PV_NEW_EPOCH, queueLast))] = _newStakingEpoch;\n\n        uintStorage[keccak256(abi.encode(QUEUE_PV_BLOCK, queueLast))] = _getCurrentBlockNumber();\n\n        intStorage[QUEUE_PV_LAST] = queueLast;\n",
          "message": "Function 'ValidatorSetBase._enqueuePendingValidators' (ValidatorSetAuRaMock.sol#588-607) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 588,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _enqueuePendingValidators(bool _newStakingEpoch) internal {\n",
          "message": "Parameter '_newStakingEpoch' of ValidatorSetBase._enqueuePendingValidators (ValidatorSetAuRaMock.sol#588) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 614,
          "vulnerability_to_line": 629,
          "vulnerability_code": "    function _dequeuePendingValidators() internal returns(address[] memory newSet, bool newStakingEpoch) {\n\n        int256 queueFirst = intStorage[QUEUE_PV_FIRST];\n\n        int256 queueLast = intStorage[QUEUE_PV_LAST];\n\n\n\n        if (queueLast < queueFirst) {\n\n            newSet = new address[](0);\n\n            newStakingEpoch = false;\n\n        } else {\n\n            newSet = addressArrayStorage[keccak256(abi.encode(QUEUE_PV_LIST, queueFirst))];\n\n            newStakingEpoch = boolStorage[keccak256(abi.encode(QUEUE_PV_NEW_EPOCH, queueFirst))];\n\n            delete addressArrayStorage[keccak256(abi.encode(QUEUE_PV_LIST, queueFirst))];\n\n            delete boolStorage[keccak256(abi.encode(QUEUE_PV_NEW_EPOCH, queueFirst))];\n\n            delete uintStorage[keccak256(abi.encode(QUEUE_PV_BLOCK, queueFirst))];\n\n            intStorage[QUEUE_PV_FIRST]++;\n\n        }\n",
          "message": "Function 'ValidatorSetBase._dequeuePendingValidators' (ValidatorSetAuRaMock.sol#614-629) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 633,
          "vulnerability_to_line": 635,
          "vulnerability_code": "    function _incrementChangeRequestCount() internal {\n\n        uintStorage[CHANGE_REQUEST_COUNT]++;\n",
          "message": "Function 'ValidatorSetBase._incrementChangeRequestCount' (ValidatorSetAuRaMock.sol#633-635) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 642,
          "vulnerability_to_line": 687,
          "vulnerability_code": "    function _newValidatorSet() internal returns(uint256) {\n\n        IStaking staking = IStaking(stakingContract());\n\n        address[] memory poolsToBeElected = staking.getPoolsToBeElected();\n\n        address unremovableStakingAddress = unremovableValidator();\n\n\n\n        // Choose new validators\n\n        if (\n\n            poolsToBeElected.length >= MAX_VALIDATORS &&\n\n            (poolsToBeElected.length != MAX_VALIDATORS || unremovableStakingAddress != address(0))\n\n        ) {\n\n            uint256 randomNumber = IRandom(randomContract()).getCurrentSeed();\n\n\n\n            (int256[] memory likelihood, int256 likelihoodSum) = staking.getPoolsLikelihood();\n\n\n\n            if (likelihood.length > 0 && likelihoodSum > 0) {\n\n                address[] memory newValidators = new address[](\n\n                    unremovableStakingAddress == address(0) ? MAX_VALIDATORS : MAX_VALIDATORS - 1\n\n                );\n\n\n\n                uint256 poolsToBeElectedLength = poolsToBeElected.length;\n\n                for (uint256 i = 0; i < newValidators.length; i++) {\n\n                    randomNumber = uint256(keccak256(abi.encode(randomNumber)));\n\n                    uint256 randomPoolIndex = _getRandomIndex(likelihood, likelihoodSum, randomNumber);\n\n                    newValidators[i] = poolsToBeElected[randomPoolIndex];\n\n                    likelihoodSum -= likelihood[randomPoolIndex];\n\n                    poolsToBeElectedLength--;\n\n                    poolsToBeElected[randomPoolIndex] = poolsToBeElected[poolsToBeElectedLength];\n\n                    likelihood[randomPoolIndex] = likelihood[poolsToBeElectedLength];\n\n                }\n\n\n\n                _setPendingValidators(staking, newValidators, unremovableStakingAddress);\n\n            }\n\n        } else {\n\n            _setPendingValidators(staking, poolsToBeElected, unremovableStakingAddress);\n\n        }\n\n\n\n        // From this moment the `getPendingValidators()` will return a new validator set\n\n\n\n        staking.incrementStakingEpoch();\n\n        _setValidatorSetApplyBlock(0);\n\n\n\n        _incrementChangeRequestCount();\n\n        _enqueuePendingValidators(true);\n\n\n\n        return poolsToBeElected.length;\n",
          "message": "Function 'ValidatorSetBase._newValidatorSet' (ValidatorSetAuRaMock.sol#642-687) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 693,
          "vulnerability_to_line": 718,
          "vulnerability_code": "    function _removeMaliciousValidator(address _miningAddress) internal returns(bool) {\n\n        address stakingAddress = stakingByMiningAddress(_miningAddress);\n\n\n\n        if (stakingAddress == unremovableValidator()) {\n\n            return false;\n\n        }\n\n\n\n        // Ban the malicious validator for the next 3 months\n\n        _banValidator(_miningAddress);\n\n\n\n        // Remove malicious validator from the `pools`\n\n        IStaking(stakingContract()).removePool(stakingAddress);\n\n\n\n        address[] storage miningAddresses = addressArrayStorage[PENDING_VALIDATORS];\n\n\n\n        for (uint256 i = 0; i < miningAddresses.length; i++) {\n\n            if (miningAddresses[i] == _miningAddress) {\n\n                // Remove the malicious validator from `pendingValidators`\n\n                miningAddresses[i] = miningAddresses[miningAddresses.length - 1];\n\n                miningAddresses.length--;\n\n                return true;\n\n            }\n\n        }\n\n\n\n        return false;\n",
          "message": "Function 'ValidatorSetBase._removeMaliciousValidator' (ValidatorSetAuRaMock.sol#693-718) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 693,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _removeMaliciousValidator(address _miningAddress) internal returns(bool) {\n",
          "message": "Parameter '_miningAddress' of ValidatorSetBase._removeMaliciousValidator (ValidatorSetAuRaMock.sol#693) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 724,
          "vulnerability_to_line": 726,
          "vulnerability_code": "    function _setInitiateChangeAllowed(bool _allowed) internal {\n\n        boolStorage[INITIATE_CHANGE_ALLOWED] = _allowed;\n",
          "message": "Function 'ValidatorSetBase._setInitiateChangeAllowed' (ValidatorSetAuRaMock.sol#724-726) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 724,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setInitiateChangeAllowed(bool _allowed) internal {\n",
          "message": "Parameter '_allowed' of ValidatorSetBase._setInitiateChangeAllowed (ValidatorSetAuRaMock.sol#724) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 733,
          "vulnerability_to_line": 739,
          "vulnerability_code": "    function _setIsValidator(address _miningAddress, bool _isValidator) internal {\n\n        boolStorage[keccak256(abi.encode(IS_VALIDATOR, _miningAddress))] = _isValidator;\n\n\n\n        if (_isValidator) {\n\n            uintStorage[keccak256(abi.encode(VALIDATOR_COUNTER, _miningAddress))]++;\n\n        }\n",
          "message": "Function 'ValidatorSetBase._setIsValidator' (ValidatorSetAuRaMock.sol#733-739) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 733,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setIsValidator(address _miningAddress, bool _isValidator) internal {\n",
          "message": "Parameter '_miningAddress' of ValidatorSetBase._setIsValidator (ValidatorSetAuRaMock.sol#733) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 733,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setIsValidator(address _miningAddress, bool _isValidator) internal {\n",
          "message": "Parameter '_isValidator' of ValidatorSetBase._setIsValidator (ValidatorSetAuRaMock.sol#733) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 745,
          "vulnerability_to_line": 747,
          "vulnerability_code": "    function _setIsValidatorOnPreviousEpoch(address _miningAddress, bool _isValidator) internal {\n\n        boolStorage[keccak256(abi.encode(IS_VALIDATOR_ON_PREVIOUS_EPOCH, _miningAddress))] = _isValidator;\n",
          "message": "Function 'ValidatorSetBase._setIsValidatorOnPreviousEpoch' (ValidatorSetAuRaMock.sol#745-747) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 745,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setIsValidatorOnPreviousEpoch(address _miningAddress, bool _isValidator) internal {\n",
          "message": "Parameter '_miningAddress' of ValidatorSetBase._setIsValidatorOnPreviousEpoch (ValidatorSetAuRaMock.sol#745) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 745,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setIsValidatorOnPreviousEpoch(address _miningAddress, bool _isValidator) internal {\n",
          "message": "Parameter '_isValidator' of ValidatorSetBase._setIsValidatorOnPreviousEpoch (ValidatorSetAuRaMock.sol#745) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 756,
          "vulnerability_to_line": 779,
          "vulnerability_code": "    function _setPendingValidators(\n\n        IStaking _stakingContract,\n\n        address[] memory _stakingAddresses,\n\n        address _unremovableStakingAddress\n\n    ) internal {\n\n        if (_stakingAddresses.length == 0) return;\n\n\n\n        uint256 i;\n\n\n\n        delete addressArrayStorage[PENDING_VALIDATORS];\n\n\n\n        if (_unremovableStakingAddress != address(0)) {\n\n            addressArrayStorage[PENDING_VALIDATORS].push(miningByStakingAddress(_unremovableStakingAddress));\n\n        }\n\n\n\n        for (i = 0; i < _stakingAddresses.length; i++) {\n\n            addressArrayStorage[PENDING_VALIDATORS].push(miningByStakingAddress(_stakingAddresses[i]));\n\n        }\n\n\n\n        address[] memory poolsToBeRemoved = _stakingContract.getPoolsToBeRemoved();\n\n        for (i = 0; i < poolsToBeRemoved.length; i++) {\n\n            _stakingContract.removePool(poolsToBeRemoved[i]);\n\n        }\n",
          "message": "Function 'ValidatorSetBase._setPendingValidators' (ValidatorSetAuRaMock.sol#756-779) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 757,
          "vulnerability_to_line": null,
          "vulnerability_code": "        IStaking _stakingContract,\n",
          "message": "Parameter '_stakingContract' of ValidatorSetBase._setPendingValidators (ValidatorSetAuRaMock.sol#757) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 758,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address[] memory _stakingAddresses,\n",
          "message": "Parameter '_stakingAddresses' of ValidatorSetBase._setPendingValidators (ValidatorSetAuRaMock.sol#758) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 759,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address _unremovableStakingAddress\n",
          "message": "Parameter '_unremovableStakingAddress' of ValidatorSetBase._setPendingValidators (ValidatorSetAuRaMock.sol#759) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 786,
          "vulnerability_to_line": 789,
          "vulnerability_code": "    function _setQueueValidators(address[] memory _miningAddresses, bool _newStakingEpoch) internal {\n\n        addressArrayStorage[QUEUE_VALIDATORS] = _miningAddresses;\n\n        boolStorage[QUEUE_VALIDATORS_NEW_STAKING_EPOCH] = _newStakingEpoch;\n",
          "message": "Function 'ValidatorSetBase._setQueueValidators' (ValidatorSetAuRaMock.sol#786-789) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 786,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setQueueValidators(address[] memory _miningAddresses, bool _newStakingEpoch) internal {\n",
          "message": "Parameter '_miningAddresses' of ValidatorSetBase._setQueueValidators (ValidatorSetAuRaMock.sol#786) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 786,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setQueueValidators(address[] memory _miningAddresses, bool _newStakingEpoch) internal {\n",
          "message": "Parameter '_newStakingEpoch' of ValidatorSetBase._setQueueValidators (ValidatorSetAuRaMock.sol#786) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 795,
          "vulnerability_to_line": 805,
          "vulnerability_code": "    function _setStakingAddress(address _miningAddress, address _stakingAddress) internal {\n\n        require(_miningAddress != address(0));\n\n        require(_stakingAddress != address(0));\n\n        require(_miningAddress != _stakingAddress);\n\n        require(miningByStakingAddress(_stakingAddress) == address(0));\n\n        require(miningByStakingAddress(_miningAddress) == address(0));\n\n        require(stakingByMiningAddress(_stakingAddress) == address(0));\n\n        require(stakingByMiningAddress(_miningAddress) == address(0));\n\n        addressStorage[keccak256(abi.encode(MINING_BY_STAKING_ADDRESS, _stakingAddress))] = _miningAddress;\n\n        addressStorage[keccak256(abi.encode(STAKING_BY_MINING_ADDRESS, _miningAddress))] = _stakingAddress;\n",
          "message": "Function 'ValidatorSetBase._setStakingAddress' (ValidatorSetAuRaMock.sol#795-805) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 795,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setStakingAddress(address _miningAddress, address _stakingAddress) internal {\n",
          "message": "Parameter '_miningAddress' of ValidatorSetBase._setStakingAddress (ValidatorSetAuRaMock.sol#795) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 795,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setStakingAddress(address _miningAddress, address _stakingAddress) internal {\n",
          "message": "Parameter '_stakingAddress' of ValidatorSetBase._setStakingAddress (ValidatorSetAuRaMock.sol#795) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 810,
          "vulnerability_to_line": 812,
          "vulnerability_code": "    function _setUnremovableValidator(address _stakingAddress) internal {\n\n        addressStorage[UNREMOVABLE_STAKING_ADDRESS] = _stakingAddress;\n",
          "message": "Function 'ValidatorSetBase._setUnremovableValidator' (ValidatorSetAuRaMock.sol#810-812) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 810,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setUnremovableValidator(address _stakingAddress) internal {\n",
          "message": "Parameter '_stakingAddress' of ValidatorSetBase._setUnremovableValidator (ValidatorSetAuRaMock.sol#810) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 818,
          "vulnerability_to_line": 820,
          "vulnerability_code": "    function _setValidatorIndex(address _miningAddress, uint256 _index) internal {\n\n        uintStorage[keccak256(abi.encode(VALIDATOR_INDEX, _miningAddress))] = _index;\n",
          "message": "Function 'ValidatorSetBase._setValidatorIndex' (ValidatorSetAuRaMock.sol#818-820) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 818,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setValidatorIndex(address _miningAddress, uint256 _index) internal {\n",
          "message": "Parameter '_miningAddress' of ValidatorSetBase._setValidatorIndex (ValidatorSetAuRaMock.sol#818) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 818,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setValidatorIndex(address _miningAddress, uint256 _index) internal {\n",
          "message": "Parameter '_index' of ValidatorSetBase._setValidatorIndex (ValidatorSetAuRaMock.sol#818) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 826,
          "vulnerability_to_line": 828,
          "vulnerability_code": "    function _setValidatorSetApplyBlock(uint256 _blockNumber) internal {\n\n        uintStorage[VALIDATOR_SET_APPLY_BLOCK] = _blockNumber;\n",
          "message": "Function 'ValidatorSetBase._setValidatorSetApplyBlock' (ValidatorSetAuRaMock.sol#826-828) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 826,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setValidatorSetApplyBlock(uint256 _blockNumber) internal {\n",
          "message": "Parameter '_blockNumber' of ValidatorSetBase._setValidatorSetApplyBlock (ValidatorSetAuRaMock.sol#826) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 832,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _banStart() internal view returns(uint256);\n",
          "message": "Function 'ValidatorSetBase._banStart' (ValidatorSetAuRaMock.sol#832) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 836,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _banUntil() internal view returns(uint256);\n",
          "message": "Function 'ValidatorSetBase._banUntil' (ValidatorSetAuRaMock.sol#836) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 839,
          "vulnerability_to_line": 841,
          "vulnerability_code": "    function _getCurrentBlockNumber() internal view returns(uint256) {\n\n        return block.number;\n",
          "message": "Function 'ValidatorSetBase._getCurrentBlockNumber' (ValidatorSetAuRaMock.sol#839-841) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 848,
          "vulnerability_to_line": 861,
          "vulnerability_code": "    function _getRandomIndex(int256[] memory _likelihood, int256 _likelihoodSum, uint256 _randomNumber)\n\n        internal\n\n        pure\n\n        returns(uint256)\n\n    {\n\n        int256 r = int256(_randomNumber % uint256(_likelihoodSum)) + 1;\n\n        uint256 index = 0;\n\n        while (true) {\n\n            r -= _likelihood[index];\n\n            if (r <= 0) break;\n\n            index++;\n\n        }\n\n        return index;\n",
          "message": "Function 'ValidatorSetBase._getRandomIndex' (ValidatorSetAuRaMock.sol#848-861) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 848,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _getRandomIndex(int256[] memory _likelihood, int256 _likelihoodSum, uint256 _randomNumber)\n",
          "message": "Parameter '_likelihood' of ValidatorSetBase._getRandomIndex (ValidatorSetAuRaMock.sol#848) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 848,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _getRandomIndex(int256[] memory _likelihood, int256 _likelihoodSum, uint256 _randomNumber)\n",
          "message": "Parameter '_likelihoodSum' of ValidatorSetBase._getRandomIndex (ValidatorSetAuRaMock.sol#848) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 848,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _getRandomIndex(int256[] memory _likelihood, int256 _likelihoodSum, uint256 _randomNumber)\n",
          "message": "Parameter '_randomNumber' of ValidatorSetBase._getRandomIndex (ValidatorSetAuRaMock.sol#848) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 870,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function removeMaliciousValidator(address) external;\n",
          "message": "Parameter '' of IValidatorSetAuRa.removeMaliciousValidator (ValidatorSetAuRaMock.sol#870) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 871,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function reportMaliciousCallable(address, address, uint256) external view returns(bool, bool);\n",
          "message": "Parameter '' of IValidatorSetAuRa.reportMaliciousCallable (ValidatorSetAuRaMock.sol#871) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 871,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function reportMaliciousCallable(address, address, uint256) external view returns(bool, bool);\n",
          "message": "Parameter '_scope_0' of IValidatorSetAuRa.reportMaliciousCallable (ValidatorSetAuRaMock.sol#871) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 871,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function reportMaliciousCallable(address, address, uint256) external view returns(bool, bool);\n",
          "message": "Parameter '_scope_1' of IValidatorSetAuRa.reportMaliciousCallable (ValidatorSetAuRaMock.sol#871) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 881,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address,\n",
          "message": "Parameter '' of IStakingAuRa.initialize (ValidatorSetAuRaMock.sol#881) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 882,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address[] calldata,\n",
          "message": "Parameter '_scope_0' of IStakingAuRa.initialize (ValidatorSetAuRaMock.sol#882) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 883,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint256,\n",
          "message": "Parameter '_scope_1' of IStakingAuRa.initialize (ValidatorSetAuRaMock.sol#883) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 884,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint256,\n",
          "message": "Parameter '_scope_2' of IStakingAuRa.initialize (ValidatorSetAuRaMock.sol#884) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 885,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint256,\n",
          "message": "Parameter '_scope_3' of IStakingAuRa.initialize (ValidatorSetAuRaMock.sol#885) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 886,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint256,\n",
          "message": "Parameter '_scope_4' of IStakingAuRa.initialize (ValidatorSetAuRaMock.sol#886) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 887,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint256,\n",
          "message": "Parameter '_scope_5' of IStakingAuRa.initialize (ValidatorSetAuRaMock.sol#887) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 888,
          "vulnerability_to_line": null,
          "vulnerability_code": "        bool\n",
          "message": "Parameter '_scope_6' of IStakingAuRa.initialize (ValidatorSetAuRaMock.sol#888) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 890,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setStakingEpochStartBlock(uint256) external;\n",
          "message": "Parameter '' of IStakingAuRa.setStakingEpochStartBlock (ValidatorSetAuRaMock.sol#890) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 950,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function removeMaliciousValidator(address _miningAddress) external onlyRandomContract {\n",
          "message": "Parameter '_miningAddress' of ValidatorSetAuRa.removeMaliciousValidator (ValidatorSetAuRaMock.sol#950) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1057,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address _reportingMiningAddress,\n",
          "message": "Parameter '_reportingMiningAddress' of ValidatorSetAuRa.reportMaliciousCallable (ValidatorSetAuRaMock.sol#1057) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1058,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address _maliciousMiningAddress,\n",
          "message": "Parameter '_maliciousMiningAddress' of ValidatorSetAuRa.reportMaliciousCallable (ValidatorSetAuRaMock.sol#1058) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1059,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint256 _blockNumber\n",
          "message": "Parameter '_blockNumber' of ValidatorSetAuRa.reportMaliciousCallable (ValidatorSetAuRaMock.sol#1059) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1111,
          "vulnerability_to_line": 1113,
          "vulnerability_code": "    function _banStart() internal view returns(uint256) {\n\n        return _getCurrentBlockNumber();\n",
          "message": "Function 'ValidatorSetAuRa._banStart' (ValidatorSetAuRaMock.sol#1111-1113) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1116,
          "vulnerability_to_line": 1118,
          "vulnerability_code": "    function _banUntil() internal view returns(uint256) {\n\n        return _banStart() + 1555200; // 90 days (for 5 seconds block)\n",
          "message": "Function 'ValidatorSetAuRa._banUntil' (ValidatorSetAuRaMock.sol#1116-1118) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 961,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address _maliciousMiningAddress,\n",
          "message": "Parameter '_maliciousMiningAddress' of ValidatorSetAuRa.reportMalicious (ValidatorSetAuRaMock.sol#961) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 962,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint256 _blockNumber,\n",
          "message": "Parameter '_blockNumber' of ValidatorSetAuRa.reportMalicious (ValidatorSetAuRaMock.sol#962) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 963,
          "vulnerability_to_line": null,
          "vulnerability_code": "        bytes calldata\n",
          "message": "Parameter '' of ValidatorSetAuRa.reportMalicious (ValidatorSetAuRaMock.sol#963) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1020,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address _maliciousMiningAddress,\n",
          "message": "Parameter '_maliciousMiningAddress' of ValidatorSetAuRa.maliceReportedForBlock (ValidatorSetAuRaMock.sol#1020) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1021,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint256 _blockNumber\n",
          "message": "Parameter '_blockNumber' of ValidatorSetAuRa.maliceReportedForBlock (ValidatorSetAuRaMock.sol#1021) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1032,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function reportingCounter(address _reportingMiningAddress, uint256 _stakingEpoch) public view returns(uint256) {\n",
          "message": "Parameter '_reportingMiningAddress' of ValidatorSetAuRa.reportingCounter (ValidatorSetAuRaMock.sol#1032) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1032,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function reportingCounter(address _reportingMiningAddress, uint256 _stakingEpoch) public view returns(uint256) {\n",
          "message": "Parameter '_stakingEpoch' of ValidatorSetAuRa.reportingCounter (ValidatorSetAuRaMock.sol#1032) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1039,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function reportingCounterTotal(uint256 _stakingEpoch) public view returns(uint256) {\n",
          "message": "Parameter '_stakingEpoch' of ValidatorSetAuRa.reportingCounterTotal (ValidatorSetAuRaMock.sol#1039) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1124,
          "vulnerability_to_line": 1136,
          "vulnerability_code": "    function _clearReportingCounter(address _miningAddress) internal {\n\n        uint256 currentStakingEpoch = IStaking(stakingContract()).stakingEpoch();\n\n        uint256 total = reportingCounterTotal(currentStakingEpoch);\n\n        uint256 counter = reportingCounter(_miningAddress, currentStakingEpoch);\n\n\n\n        uintStorage[keccak256(abi.encode(REPORTING_COUNTER, _miningAddress, currentStakingEpoch))] = 0;\n\n\n\n        if (total >= counter) {\n\n            uintStorage[keccak256(abi.encode(REPORTING_COUNTER_TOTAL, currentStakingEpoch))] -= counter;\n\n        } else {\n\n            uintStorage[keccak256(abi.encode(REPORTING_COUNTER_TOTAL, currentStakingEpoch))] = 0;\n\n        }\n",
          "message": "Function 'ValidatorSetAuRa._clearReportingCounter' (ValidatorSetAuRaMock.sol#1124-1136) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1124,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _clearReportingCounter(address _miningAddress) internal {\n",
          "message": "Parameter '_miningAddress' of ValidatorSetAuRa._clearReportingCounter (ValidatorSetAuRaMock.sol#1124) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1142,
          "vulnerability_to_line": 1147,
          "vulnerability_code": "    function _incrementReportingCounter(address _reportingMiningAddress) internal {\n\n        if (!isReportValidatorValid(_reportingMiningAddress)) return;\n\n        uint256 currentStakingEpoch = IStaking(stakingContract()).stakingEpoch();\n\n        uintStorage[keccak256(abi.encode(REPORTING_COUNTER, _reportingMiningAddress, currentStakingEpoch))]++;\n\n        uintStorage[keccak256(abi.encode(REPORTING_COUNTER_TOTAL, currentStakingEpoch))]++;\n",
          "message": "Function 'ValidatorSetAuRa._incrementReportingCounter' (ValidatorSetAuRaMock.sol#1142-1147) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1142,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _incrementReportingCounter(address _reportingMiningAddress) internal {\n",
          "message": "Parameter '_reportingMiningAddress' of ValidatorSetAuRa._incrementReportingCounter (ValidatorSetAuRaMock.sol#1142) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1153,
          "vulnerability_to_line": 1165,
          "vulnerability_code": "    function _removeMaliciousValidatorAuRa(address _miningAddress) internal {\n\n        if (isValidatorBanned(_miningAddress)) {\n\n            // The malicious validator is already banned\n\n            return;\n\n        }\n\n\n\n        if (_removeMaliciousValidator(_miningAddress)) {\n\n            // From this moment `getPendingValidators()` will return the new validator set\n\n            _incrementChangeRequestCount();\n\n            _enqueuePendingValidators(false);\n\n            _clearReportingCounter(_miningAddress);\n\n        }\n",
          "message": "Function 'ValidatorSetAuRa._removeMaliciousValidatorAuRa' (ValidatorSetAuRaMock.sol#1153-1165) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1153,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _removeMaliciousValidatorAuRa(address _miningAddress) internal {\n",
          "message": "Parameter '_miningAddress' of ValidatorSetAuRa._removeMaliciousValidatorAuRa (ValidatorSetAuRaMock.sol#1153) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1231,
          "vulnerability_to_line": 1233,
          "vulnerability_code": "    function _getCurrentBlockNumber() internal view returns(uint256) {\n\n        return uintStorage[keccak256(\"currentBlockNumber\")];\n",
          "message": "Function 'ValidatorSetAuRaMock._getCurrentBlockNumber' (ValidatorSetAuRaMock.sol#1231-1233) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1191,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setBannedUntil(address _miningAddress, uint256 _bannedUntil) public {\n",
          "message": "Parameter '_miningAddress' of ValidatorSetAuRaMock.setBannedUntil (ValidatorSetAuRaMock.sol#1191) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1191,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setBannedUntil(address _miningAddress, uint256 _bannedUntil) public {\n",
          "message": "Parameter '_bannedUntil' of ValidatorSetAuRaMock.setBannedUntil (ValidatorSetAuRaMock.sol#1191) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1195,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setBlockRewardContract(address _address) public {\n",
          "message": "Parameter '_address' of ValidatorSetAuRaMock.setBlockRewardContract (ValidatorSetAuRaMock.sol#1195) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1199,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setCurrentBlockNumber(uint256 _blockNumber) public {\n",
          "message": "Parameter '_blockNumber' of ValidatorSetAuRaMock.setCurrentBlockNumber (ValidatorSetAuRaMock.sol#1199) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1203,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setRandomContract(address _address) public {\n",
          "message": "Parameter '_address' of ValidatorSetAuRaMock.setRandomContract (ValidatorSetAuRaMock.sol#1203) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1207,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setSystemAddress(address _systemAddress) public {\n",
          "message": "Parameter '_systemAddress' of ValidatorSetAuRaMock.setSystemAddress (ValidatorSetAuRaMock.sol#1207) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1211,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setValidatorSetApplyBlock(uint256 _blockNumber) public {\n",
          "message": "Parameter '_blockNumber' of ValidatorSetAuRaMock.setValidatorSetApplyBlock (ValidatorSetAuRaMock.sol#1211) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1218,
          "vulnerability_to_line": null,
          "vulnerability_code": "        int256[] memory _likelihood,\n",
          "message": "Parameter '_likelihood' of ValidatorSetAuRaMock.getRandomIndex (ValidatorSetAuRaMock.sol#1218) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1219,
          "vulnerability_to_line": null,
          "vulnerability_code": "        int256 _likelihoodSum,\n",
          "message": "Parameter '_likelihoodSum' of ValidatorSetAuRaMock.getRandomIndex (ValidatorSetAuRaMock.sol#1219) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1220,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint256 _randomNumber\n",
          "message": "Parameter '_randomNumber' of ValidatorSetAuRaMock.getRandomIndex (ValidatorSetAuRaMock.sol#1220) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1235,
          "vulnerability_to_line": 1237,
          "vulnerability_code": "    function _getSystemAddress() internal view returns(address) {\n\n        return addressStorage[keccak256(\"systemAddress\")];\n",
          "message": "Function 'ValidatorSetAuRaMock._getSystemAddress' (ValidatorSetAuRaMock.sol#1235-1237) is not in mixedCase\n"
        },
        {
          "name": "unused-state",
          "vulnerability_from_line": 93,
          "vulnerability_to_line": null,
          "vulnerability_code": "    mapping(bytes32 => string) internal stringStorage;\n",
          "message": "EternalStorage.stringStorage (ValidatorSetAuRaMock.sol#93) is never used in ValidatorSetAuRaMock\nEternalStorage.bytesStorage (ValidatorSetAuRaMock.sol#95) is never used in ValidatorSetAuRaMock\nEternalStorage.bytes32Storage (ValidatorSetAuRaMock.sol#98) is never used in ValidatorSetAuRaMock\nEternalStorage.uintArrayStorage (ValidatorSetAuRaMock.sol#100) is never used in ValidatorSetAuRaMock\nEternalStorage.stringArrayStorage (ValidatorSetAuRaMock.sol#101) is never used in ValidatorSetAuRaMock\nEternalStorage.bytesArrayStorage (ValidatorSetAuRaMock.sol#103) is never used in ValidatorSetAuRaMock\nEternalStorage.boolArrayStorage (ValidatorSetAuRaMock.sol#104) is never used in ValidatorSetAuRaMock\nEternalStorage.intArrayStorage (ValidatorSetAuRaMock.sol#105) is never used in ValidatorSetAuRaMock\nEternalStorage.bytes32ArrayStorage (ValidatorSetAuRaMock.sol#106) is never used in ValidatorSetAuRaMock\n"
        }
      ]
    },
    "smartcheck": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 210,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == 0xffffFFFfFFffffffffffffffFfFFFfffFFFfFFfE);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 221,
          "vulnerability_to_line": null,
          "vulnerability_code": "        _setUnremovableValidator(address(0));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 262,
          "vulnerability_to_line": null,
          "vulnerability_code": "            for (i = 0; i < previousValidators.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 265,
          "vulnerability_to_line": null,
          "vulnerability_code": "            for (i = 0; i < currentValidators.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 1095,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 m = 0; m < reportedValidators.length; m++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 262,
          "vulnerability_to_line": null,
          "vulnerability_code": "            for (i = 0; i < previousValidators.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 265,
          "vulnerability_to_line": null,
          "vulnerability_code": "            for (i = 0; i < currentValidators.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 1095,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 m = 0; m < reportedValidators.length; m++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SAFEMATH",
          "vulnerability_from_line": 178,
          "vulnerability_to_line": null,
          "vulnerability_code": "    using SafeMath for uint256;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 35,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getPoolsLikelihood() external view returns(int256[] memory, int256);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 58,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function newValidatorSet() external returns(bool, uint256);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 871,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function reportMaliciousCallable(address, address, uint256) external view returns(bool, bool);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 939,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function newValidatorSet() external onlyBlockRewardContract returns(bool called, uint256 poolsToBeElectedLength) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 1060,
          "vulnerability_to_line": null,
          "vulnerability_code": "    ) public view returns(bool callable, bool removeReportingValidator) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 293,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function initialize(\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 297,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address[] calldata _initialMiningAddresses,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 298,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address[] calldata _initialStakingAddresses,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 298,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address[] calldata _initialStakingAddresses,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 299,
          "vulnerability_to_line": null,
          "vulnerability_code": "        bool _firstValidatorIsUnremovable\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 301,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(!isInitialized()); // initialization can only be done once\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 301,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(!isInitialized()); // initialization can only be done once\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 302,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_blockRewardContract != address(0));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 302,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_blockRewardContract != address(0));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 302,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_blockRewardContract != address(0));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 303,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_randomContract != address(0));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 303,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_randomContract != address(0));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 303,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_randomContract != address(0));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 304,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_stakingContract != address(0));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 304,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_stakingContract != address(0));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 304,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_stakingContract != address(0));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 305,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_initialMiningAddresses.length > 0);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 305,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_initialMiningAddresses.length > 0);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 306,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_initialMiningAddresses.length == _initialStakingAddresses.length);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 306,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_initialMiningAddresses.length == _initialStakingAddresses.length);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 306,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_initialMiningAddresses.length == _initialStakingAddresses.length);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 308,
          "vulnerability_to_line": null,
          "vulnerability_code": "        addressStorage[BLOCK_REWARD_CONTRACT] = _blockRewardContract;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 309,
          "vulnerability_to_line": null,
          "vulnerability_code": "        addressStorage[RANDOM_CONTRACT] = _randomContract;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 310,
          "vulnerability_to_line": null,
          "vulnerability_code": "        addressStorage[STAKING_CONTRACT] = _stakingContract;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 312,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address[] storage currentValidators = addressArrayStorage[CURRENT_VALIDATORS];\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 313,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address[] storage pendingValidators = addressArrayStorage[PENDING_VALIDATORS];\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 316,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 i = 0; i < _initialMiningAddresses.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 316,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 i = 0; i < _initialMiningAddresses.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 316,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 i = 0; i < _initialMiningAddresses.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 317,
          "vulnerability_to_line": null,
          "vulnerability_code": "            currentValidators.push(_initialMiningAddresses[i]);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 317,
          "vulnerability_to_line": null,
          "vulnerability_code": "            currentValidators.push(_initialMiningAddresses[i]);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 318,
          "vulnerability_to_line": null,
          "vulnerability_code": "            pendingValidators.push(_initialMiningAddresses[i]);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 318,
          "vulnerability_to_line": null,
          "vulnerability_code": "            pendingValidators.push(_initialMiningAddresses[i]);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 319,
          "vulnerability_to_line": null,
          "vulnerability_code": "            _setValidatorIndex(_initialMiningAddresses[i], i);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 319,
          "vulnerability_to_line": null,
          "vulnerability_code": "            _setValidatorIndex(_initialMiningAddresses[i], i);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 319,
          "vulnerability_to_line": null,
          "vulnerability_code": "            _setValidatorIndex(_initialMiningAddresses[i], i);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 320,
          "vulnerability_to_line": null,
          "vulnerability_code": "            _setIsValidator(_initialMiningAddresses[i], true);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 320,
          "vulnerability_to_line": null,
          "vulnerability_code": "            _setIsValidator(_initialMiningAddresses[i], true);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 321,
          "vulnerability_to_line": null,
          "vulnerability_code": "            _setStakingAddress(_initialMiningAddresses[i], _initialStakingAddresses[i]);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 321,
          "vulnerability_to_line": null,
          "vulnerability_code": "            _setStakingAddress(_initialMiningAddresses[i], _initialStakingAddresses[i]);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 321,
          "vulnerability_to_line": null,
          "vulnerability_code": "            _setStakingAddress(_initialMiningAddresses[i], _initialStakingAddresses[i]);\n",
          "message": null
        }
      ]
    },
    "oyente": {
      "successfull_analysis": false,
      "errors": [
        "exception (IndexError: pop from empty list)"
      ],
      "vulnerability_findings": []
    },
    "mythril": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": []
    },
    "osiris": {
      "successfull_analysis": false,
      "errors": [
        "exception (IndexError: pop from empty list)"
      ],
      "vulnerability_findings": []
    }
  }
}