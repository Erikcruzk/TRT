{
  "smartbugs_completed": true,
  "analyzer_results": {
    "semgrep": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 288,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (i = 0; i < oldBridgesAllowed.length; i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 306,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (i = 0; i < oldBridgesAllowed.length; i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 324,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (i = 0; i < oldBridgesAllowed.length; i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 548,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (i = extraLength; i < receivers.length; i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 819,
          "vulnerability_to_line": null,
          "vulnerability_code": "            for (uint256 i = 0; i < newValidatorSet.length; i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 1001,
          "vulnerability_to_line": null,
          "vulnerability_code": "                for (i = 0; i < validators.length; i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 1009,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    for (i = 0; i < validators.length; i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 1020,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    for (i = 0; i < validators.length; i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 1043,
          "vulnerability_to_line": null,
          "vulnerability_code": "                for (i = 0; i < validators.length; i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 1054,
          "vulnerability_to_line": null,
          "vulnerability_code": "                for (i = 0; i < validators.length; i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 664,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 i = from; i < to; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 819,
          "vulnerability_to_line": null,
          "vulnerability_code": "            for (uint256 i = 0; i < newValidatorSet.length; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 1162,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 i = 0; i < DELEGATORS_ALIQUOT; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 641,
          "vulnerability_to_line": null,
          "vulnerability_code": "            if (validatorStake != 0 && totalStaked != 0) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 642,
          "vulnerability_to_line": null,
          "vulnerability_code": "                if (validatorHasMore30Per) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 643,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    rewardPercent = REWARD_PERCENT_MULTIPLIER * validatorStake / totalStaked;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 644,
          "vulnerability_to_line": null,
          "vulnerability_code": "                } else {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 645,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    rewardPercent = REWARD_PERCENT_MULTIPLIER * 3 / 10;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 646,
          "vulnerability_to_line": null,
          "vulnerability_code": "                }\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 647,
          "vulnerability_to_line": null,
          "vulnerability_code": "            }\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 803,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (validatorSet.validatorSetApplyBlock() != 0 && block.number <= rewardPointBlock) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 804,
          "vulnerability_to_line": null,
          "vulnerability_code": "            if (stakingEpoch != 0) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 805,
          "vulnerability_to_line": null,
          "vulnerability_code": "                // Accumulate blocks producing statistics for each of the\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 806,
          "vulnerability_to_line": null,
          "vulnerability_code": "                // active validators during the current staking epoch\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 807,
          "vulnerability_to_line": null,
          "vulnerability_code": "                uintStorage[keccak256(abi.encode(BLOCKS_CREATED, stakingEpoch, benefactors[0]))]++;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 808,
          "vulnerability_to_line": null,
          "vulnerability_code": "            }\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 809,
          "vulnerability_to_line": null,
          "vulnerability_code": "        }\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 995,
          "vulnerability_to_line": null,
          "vulnerability_code": "            if (\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 996,
          "vulnerability_to_line": null,
          "vulnerability_code": "                totalReward != 0 && _erc20TokenContract != address(0) ||\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 997,
          "vulnerability_to_line": null,
          "vulnerability_code": "                uintStorage[BRIDGE_NATIVE_FEE] != 0 ||\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 998,
          "vulnerability_to_line": null,
          "vulnerability_code": "                _erc20Restricted\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 999,
          "vulnerability_to_line": null,
          "vulnerability_code": "            ) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 1000,
          "vulnerability_to_line": null,
          "vulnerability_code": "                j = 0;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 1001,
          "vulnerability_to_line": null,
          "vulnerability_code": "                for (i = 0; i < validators.length; i++) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 1002,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    ratio[i] = uintStorage[keccak256(abi.encode(\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 1003,
          "vulnerability_to_line": null,
          "vulnerability_code": "                        BLOCKS_CREATED, _stakingEpoch, validators[i]\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 1004,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    ))];\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 288,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (i = 0; i < oldBridgesAllowed.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 294,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (i = 0; i < _bridgesAllowed.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 306,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (i = 0; i < oldBridgesAllowed.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 312,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (i = 0; i < _bridgesAllowed.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 324,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (i = 0; i < oldBridgesAllowed.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 330,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (i = 0; i < _bridgesAllowed.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 541,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (i = 0; i < extraLength; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 548,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (i = extraLength; i < receivers.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 551,
          "vulnerability_to_line": null,
          "vulnerability_code": "            j++;\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 582,
          "vulnerability_to_line": null,
          "vulnerability_code": "            uintStorage[QUEUE_ER_FIRST]++;\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 664,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 i = from; i < to; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 807,
          "vulnerability_to_line": null,
          "vulnerability_code": "                uintStorage[keccak256(abi.encode(BLOCKS_CREATED, stakingEpoch, benefactors[0]))]++;\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 819,
          "vulnerability_to_line": null,
          "vulnerability_code": "            for (uint256 i = 0; i < newValidatorSet.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 1001,
          "vulnerability_to_line": null,
          "vulnerability_code": "                for (i = 0; i < validators.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 1009,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    for (i = 0; i < validators.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 1020,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    for (i = 0; i < validators.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 1043,
          "vulnerability_to_line": null,
          "vulnerability_code": "                for (i = 0; i < validators.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 1054,
          "vulnerability_to_line": null,
          "vulnerability_code": "                for (i = 0; i < validators.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 1110,
          "vulnerability_to_line": null,
          "vulnerability_code": "                for (i = range[1]; i < range[2]; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 1126,
          "vulnerability_to_line": null,
          "vulnerability_code": "                for (i = range[1]; i < range[2]; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 1153,
          "vulnerability_to_line": null,
          "vulnerability_code": "            uintStorage[QUEUE_V_FIRST]++;\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 1162,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 i = 0; i < DELEGATORS_ALIQUOT; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        }
      ]
    },
    "slither": {
      "successfull_analysis": true,
      "errors": [
        "DOCKER_RECEIVED_SIGNAL_20"
      ],
      "vulnerability_findings": [
        {
          "name": "uninitialized-state",
          "vulnerability_from_line": 80,
          "vulnerability_to_line": null,
          "vulnerability_code": "    address internal _owner;\n",
          "message": "EternalStorage._owner (BlockRewardAuRaMock.sol#80) is never initialized. It is used in:\n"
        },
        {
          "name": "incorrect-equality",
          "vulnerability_from_line": 954,
          "vulnerability_to_line": 1138,
          "vulnerability_code": "    function _distributeRewards(\n\n        IValidatorSet _validatorSetContract,\n\n        address _erc20TokenContract,\n\n        bool _erc20Restricted,\n\n        IStakingAuRa _stakingContract,\n\n        uint256 _stakingEpoch,\n\n        uint256 _rewardPointBlock\n\n    ) internal returns(address[] memory receivers, uint256[] memory rewards, bool noop) {\n\n        uint256 i;\n\n        uint256 j;\n\n\n\n        receivers = new address[](0);\n\n        rewards = new uint256[](0);\n\n        noop = true;\n\n\n\n        if (block.number == _rewardPointBlock - 1) {\n\n            boolStorage[IS_REWARDING] = true;\n\n        } else if (block.number == _rewardPointBlock) {\n\n            address[] memory validators = _validatorSetContract.getValidators();\n\n            uint256[] memory ratio = new uint256[](validators.length);\n\n\n\n            uint256 totalReward;\n\n            bool isRewarding = false;\n\n\n\n            totalReward = uintStorage[BRIDGE_TOKEN_FEE];\n\n\n\n            if (!_erc20Restricted) {\n\n                // Accumulated bridge fee plus token inflation\n\n                uint256 inflationPercent;\n\n                if (_stakingEpoch <= 24) {\n\n                    inflationPercent = 32;\n\n                } else if (_stakingEpoch <= 48) {\n\n                    inflationPercent = 16;\n\n                } else if (_stakingEpoch <= 72) {\n\n                    inflationPercent = 8;\n\n                } else {\n\n                    inflationPercent = 4;\n\n                }\n\n                totalReward += snapshotTotalStakeAmount() * inflationPercent / 4800;\n\n            }\n\n\n\n            if (\n\n                totalReward != 0 && _erc20TokenContract != address(0) ||\n\n                uintStorage[BRIDGE_NATIVE_FEE] != 0 ||\n\n                _erc20Restricted\n\n            ) {\n\n                j = 0;\n\n                for (i = 0; i < validators.length; i++) {\n\n                    ratio[i] = uintStorage[keccak256(abi.encode(\n\n                        BLOCKS_CREATED, _stakingEpoch, validators[i]\n\n                    ))];\n\n                    j += ratio[i];\n\n                    validators[i] = _validatorSetContract.stakingByMiningAddress(validators[i]);\n\n                }\n\n                if (j != 0) {\n\n                    for (i = 0; i < validators.length; i++) {\n\n                        ratio[i] = REWARD_PERCENT_MULTIPLIER * ratio[i] / j;\n\n                    }\n\n                }\n\n            }\n\n            if (totalReward != 0) {\n\n                uintStorage[BRIDGE_TOKEN_FEE] = 0;\n\n\n\n                totalReward += uintStorage[TOKEN_REWARD_UNDISTRIBUTED];\n\n\n\n                if (_erc20TokenContract != address(0)) {\n\n                    for (i = 0; i < validators.length; i++) {\n\n                        uintStorage[keccak256(abi.encode(\n\n                            EPOCH_POOL_TOKEN_REWARD, _stakingEpoch, validators[i]\n\n                        ))] = totalReward * ratio[i] / REWARD_PERCENT_MULTIPLIER;\n\n                    }\n\n                    isRewarding = true;\n\n                }\n\n\n\n                uintStorage[TOKEN_REWARD_UNDISTRIBUTED] = totalReward;\n\n            }\n\n\n\n            totalReward = uintStorage[BRIDGE_NATIVE_FEE];\n\n\n\n            if (_erc20Restricted) {\n\n                // Accumulated bridge fee plus 2.5% per year coin inflation\n\n                totalReward += _stakingContract.stakingEpochDuration() * 1 ether;\n\n            }\n\n\n\n            if (totalReward != 0) {\n\n                uintStorage[BRIDGE_NATIVE_FEE] = 0;\n\n\n\n                totalReward += uintStorage[NATIVE_REWARD_UNDISTRIBUTED];\n\n\n\n                for (i = 0; i < validators.length; i++) {\n\n                    uintStorage[keccak256(abi.encode(\n\n                        EPOCH_POOL_NATIVE_REWARD, _stakingEpoch, validators[i]\n\n                    ))] = totalReward * ratio[i] / REWARD_PERCENT_MULTIPLIER;\n\n                }\n\n                isRewarding = true;\n\n\n\n                uintStorage[NATIVE_REWARD_UNDISTRIBUTED] = totalReward;\n\n            }\n\n\n\n            if (isRewarding) {\n\n                for (i = 0; i < validators.length; i++) {\n\n                    _enqueueValidator(validators[i]);\n\n                }\n\n                if (validators.length == 0) {\n\n                    boolStorage[IS_REWARDING] = false;\n\n                }\n\n            } else {\n\n                boolStorage[IS_REWARDING] = false;\n\n            }\n\n\n\n            noop = false;\n\n        } else if (block.number > _rewardPointBlock) {\n\n            address stakingAddress = _dequeueValidator();\n\n\n\n            if (stakingAddress == address(0)) {\n\n                return (receivers, rewards, true);\n\n            }\n\n\n\n            if (_validatorsQueueSize() == 0) {\n\n                boolStorage[IS_REWARDING] = false;\n\n            }\n\n\n\n            if (_validatorSetContract.isValidatorBanned(_validatorSetContract.miningByStakingAddress(stakingAddress))) {\n\n                return (receivers, rewards, true);\n\n            }\n\n\n\n            address[] storage stakers = addressArrayStorage[keccak256(abi.encode(SNAPSHOT_STAKERS, stakingAddress))];\n\n            uint256[] memory range = new uint256[](3); // array instead of local vars because the stack is too deep\n\n            range[0] = (_validatorsQueueSize() + 1) % DELEGATORS_ALIQUOT; // offset\n\n            range[1] = range[0] * stakers.length / DELEGATORS_ALIQUOT; // from\n\n            range[2] = (range[0] + 1) * stakers.length / DELEGATORS_ALIQUOT; // to\n\n\n\n            if (range[0] == 0) {\n\n                range[2] += stakers.length % DELEGATORS_ALIQUOT;\n\n            } else {\n\n                range[1] += stakers.length % DELEGATORS_ALIQUOT;\n\n            }\n\n\n\n            if (range[1] >= range[2]) {\n\n                return (receivers, rewards, true);\n\n            }\n\n\n\n            uint256[] storage rewardPercents = uintArrayStorage[keccak256(abi.encode(\n\n                SNAPSHOT_REWARD_PERCENTS, stakingAddress\n\n            ))];\n\n            uint256 accrued;\n\n            uint256 poolReward;\n\n\n\n            receivers = new address[](range[2] - range[1]);\n\n            rewards = new uint256[](receivers.length);\n\n\n\n            poolReward = uintStorage[keccak256(abi.encode(\n\n                EPOCH_POOL_TOKEN_REWARD, _stakingEpoch, stakingAddress\n\n            ))];\n\n            if (poolReward != 0) {\n\n                accrued = 0;\n\n                for (i = range[1]; i < range[2]; i++) {\n\n                    j = i - range[1];\n\n                    receivers[j] = stakers[i];\n\n                    rewards[j] = poolReward * rewardPercents[i] / REWARD_PERCENT_MULTIPLIER;\n\n                    accrued += rewards[j];\n\n                }\n\n                IERC20Minting(_erc20TokenContract).mintReward(receivers, rewards);\n\n                _subTokenRewardUndistributed(accrued);\n\n                noop = false;\n\n            }\n\n\n\n            poolReward = uintStorage[keccak256(abi.encode(\n\n                EPOCH_POOL_NATIVE_REWARD, _stakingEpoch, stakingAddress\n\n            ))];\n\n            if (poolReward != 0) {\n\n                accrued = 0;\n\n                for (i = range[1]; i < range[2]; i++) {\n\n                    j = i - range[1];\n\n                    receivers[j] = stakers[i];\n\n                    rewards[j] = poolReward * rewardPercents[i] / REWARD_PERCENT_MULTIPLIER;\n\n                    accrued += rewards[j];\n\n                }\n\n                _subNativeRewardUndistributed(accrued);\n\n                noop = false;\n\n            } else {\n\n                return (new address[](0), new uint256[](0), noop);\n\n            }\n\n        }\n",
          "message": "BlockRewardAuRa._distributeRewards (BlockRewardAuRaMock.sol#954-1138) uses a dangerous strict equality:\n\t- block.number == _rewardPointBlock - 1\n\t- block.number == _rewardPointBlock\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 954,
          "vulnerability_to_line": 1138,
          "vulnerability_code": "    function _distributeRewards(\n\n        IValidatorSet _validatorSetContract,\n\n        address _erc20TokenContract,\n\n        bool _erc20Restricted,\n\n        IStakingAuRa _stakingContract,\n\n        uint256 _stakingEpoch,\n\n        uint256 _rewardPointBlock\n\n    ) internal returns(address[] memory receivers, uint256[] memory rewards, bool noop) {\n\n        uint256 i;\n\n        uint256 j;\n\n\n\n        receivers = new address[](0);\n\n        rewards = new uint256[](0);\n\n        noop = true;\n\n\n\n        if (block.number == _rewardPointBlock - 1) {\n\n            boolStorage[IS_REWARDING] = true;\n\n        } else if (block.number == _rewardPointBlock) {\n\n            address[] memory validators = _validatorSetContract.getValidators();\n\n            uint256[] memory ratio = new uint256[](validators.length);\n\n\n\n            uint256 totalReward;\n\n            bool isRewarding = false;\n\n\n\n            totalReward = uintStorage[BRIDGE_TOKEN_FEE];\n\n\n\n            if (!_erc20Restricted) {\n\n                // Accumulated bridge fee plus token inflation\n\n                uint256 inflationPercent;\n\n                if (_stakingEpoch <= 24) {\n\n                    inflationPercent = 32;\n\n                } else if (_stakingEpoch <= 48) {\n\n                    inflationPercent = 16;\n\n                } else if (_stakingEpoch <= 72) {\n\n                    inflationPercent = 8;\n\n                } else {\n\n                    inflationPercent = 4;\n\n                }\n\n                totalReward += snapshotTotalStakeAmount() * inflationPercent / 4800;\n\n            }\n\n\n\n            if (\n\n                totalReward != 0 && _erc20TokenContract != address(0) ||\n\n                uintStorage[BRIDGE_NATIVE_FEE] != 0 ||\n\n                _erc20Restricted\n\n            ) {\n\n                j = 0;\n\n                for (i = 0; i < validators.length; i++) {\n\n                    ratio[i] = uintStorage[keccak256(abi.encode(\n\n                        BLOCKS_CREATED, _stakingEpoch, validators[i]\n\n                    ))];\n\n                    j += ratio[i];\n\n                    validators[i] = _validatorSetContract.stakingByMiningAddress(validators[i]);\n\n                }\n\n                if (j != 0) {\n\n                    for (i = 0; i < validators.length; i++) {\n\n                        ratio[i] = REWARD_PERCENT_MULTIPLIER * ratio[i] / j;\n\n                    }\n\n                }\n\n            }\n\n            if (totalReward != 0) {\n\n                uintStorage[BRIDGE_TOKEN_FEE] = 0;\n\n\n\n                totalReward += uintStorage[TOKEN_REWARD_UNDISTRIBUTED];\n\n\n\n                if (_erc20TokenContract != address(0)) {\n\n                    for (i = 0; i < validators.length; i++) {\n\n                        uintStorage[keccak256(abi.encode(\n\n                            EPOCH_POOL_TOKEN_REWARD, _stakingEpoch, validators[i]\n\n                        ))] = totalReward * ratio[i] / REWARD_PERCENT_MULTIPLIER;\n\n                    }\n\n                    isRewarding = true;\n\n                }\n\n\n\n                uintStorage[TOKEN_REWARD_UNDISTRIBUTED] = totalReward;\n\n            }\n\n\n\n            totalReward = uintStorage[BRIDGE_NATIVE_FEE];\n\n\n\n            if (_erc20Restricted) {\n\n                // Accumulated bridge fee plus 2.5% per year coin inflation\n\n                totalReward += _stakingContract.stakingEpochDuration() * 1 ether;\n\n            }\n\n\n\n            if (totalReward != 0) {\n\n                uintStorage[BRIDGE_NATIVE_FEE] = 0;\n\n\n\n                totalReward += uintStorage[NATIVE_REWARD_UNDISTRIBUTED];\n\n\n\n                for (i = 0; i < validators.length; i++) {\n\n                    uintStorage[keccak256(abi.encode(\n\n                        EPOCH_POOL_NATIVE_REWARD, _stakingEpoch, validators[i]\n\n                    ))] = totalReward * ratio[i] / REWARD_PERCENT_MULTIPLIER;\n\n                }\n\n                isRewarding = true;\n\n\n\n                uintStorage[NATIVE_REWARD_UNDISTRIBUTED] = totalReward;\n\n            }\n\n\n\n            if (isRewarding) {\n\n                for (i = 0; i < validators.length; i++) {\n\n                    _enqueueValidator(validators[i]);\n\n                }\n\n                if (validators.length == 0) {\n\n                    boolStorage[IS_REWARDING] = false;\n\n                }\n\n            } else {\n\n                boolStorage[IS_REWARDING] = false;\n\n            }\n\n\n\n            noop = false;\n\n        } else if (block.number > _rewardPointBlock) {\n\n            address stakingAddress = _dequeueValidator();\n\n\n\n            if (stakingAddress == address(0)) {\n\n                return (receivers, rewards, true);\n\n            }\n\n\n\n            if (_validatorsQueueSize() == 0) {\n\n                boolStorage[IS_REWARDING] = false;\n\n            }\n\n\n\n            if (_validatorSetContract.isValidatorBanned(_validatorSetContract.miningByStakingAddress(stakingAddress))) {\n\n                return (receivers, rewards, true);\n\n            }\n\n\n\n            address[] storage stakers = addressArrayStorage[keccak256(abi.encode(SNAPSHOT_STAKERS, stakingAddress))];\n\n            uint256[] memory range = new uint256[](3); // array instead of local vars because the stack is too deep\n\n            range[0] = (_validatorsQueueSize() + 1) % DELEGATORS_ALIQUOT; // offset\n\n            range[1] = range[0] * stakers.length / DELEGATORS_ALIQUOT; // from\n\n            range[2] = (range[0] + 1) * stakers.length / DELEGATORS_ALIQUOT; // to\n\n\n\n            if (range[0] == 0) {\n\n                range[2] += stakers.length % DELEGATORS_ALIQUOT;\n\n            } else {\n\n                range[1] += stakers.length % DELEGATORS_ALIQUOT;\n\n            }\n\n\n\n            if (range[1] >= range[2]) {\n\n                return (receivers, rewards, true);\n\n            }\n\n\n\n            uint256[] storage rewardPercents = uintArrayStorage[keccak256(abi.encode(\n\n                SNAPSHOT_REWARD_PERCENTS, stakingAddress\n\n            ))];\n\n            uint256 accrued;\n\n            uint256 poolReward;\n\n\n\n            receivers = new address[](range[2] - range[1]);\n\n            rewards = new uint256[](receivers.length);\n\n\n\n            poolReward = uintStorage[keccak256(abi.encode(\n\n                EPOCH_POOL_TOKEN_REWARD, _stakingEpoch, stakingAddress\n\n            ))];\n\n            if (poolReward != 0) {\n\n                accrued = 0;\n\n                for (i = range[1]; i < range[2]; i++) {\n\n                    j = i - range[1];\n\n                    receivers[j] = stakers[i];\n\n                    rewards[j] = poolReward * rewardPercents[i] / REWARD_PERCENT_MULTIPLIER;\n\n                    accrued += rewards[j];\n\n                }\n\n                IERC20Minting(_erc20TokenContract).mintReward(receivers, rewards);\n\n                _subTokenRewardUndistributed(accrued);\n\n                noop = false;\n\n            }\n\n\n\n            poolReward = uintStorage[keccak256(abi.encode(\n\n                EPOCH_POOL_NATIVE_REWARD, _stakingEpoch, stakingAddress\n\n            ))];\n\n            if (poolReward != 0) {\n\n                accrued = 0;\n\n                for (i = range[1]; i < range[2]; i++) {\n\n                    j = i - range[1];\n\n                    receivers[j] = stakers[i];\n\n                    rewards[j] = poolReward * rewardPercents[i] / REWARD_PERCENT_MULTIPLIER;\n\n                    accrued += rewards[j];\n\n                }\n\n                _subNativeRewardUndistributed(accrued);\n\n                noop = false;\n\n            } else {\n\n                return (new address[](0), new uint256[](0), noop);\n\n            }\n\n        }\n",
          "message": "Reentrancy in BlockRewardAuRa._distributeRewards (BlockRewardAuRaMock.sol#954-1138):\n\tExternal calls:\n\t- validators = _validatorSetContract.getValidators() (BlockRewardAuRaMock.sol#972)\n\t- totalReward += _stakingContract.stakingEpochDuration() * 1000000000000000000 (BlockRewardAuRaMock.sol#1035)\n\tState variables written after the call(s):\n\t- uintStorage (BlockRewardAuRaMock.sol#1039)\n\t- uintStorage (BlockRewardAuRaMock.sol#1043-1047)\n\t- uintStorage (BlockRewardAuRaMock.sol#1044-1046)\n\t- uintStorage (BlockRewardAuRaMock.sol#1050)\n\t- uintStorage (BlockRewardAuRaMock.sol#1055)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 954,
          "vulnerability_to_line": 1138,
          "vulnerability_code": "    function _distributeRewards(\n\n        IValidatorSet _validatorSetContract,\n\n        address _erc20TokenContract,\n\n        bool _erc20Restricted,\n\n        IStakingAuRa _stakingContract,\n\n        uint256 _stakingEpoch,\n\n        uint256 _rewardPointBlock\n\n    ) internal returns(address[] memory receivers, uint256[] memory rewards, bool noop) {\n\n        uint256 i;\n\n        uint256 j;\n\n\n\n        receivers = new address[](0);\n\n        rewards = new uint256[](0);\n\n        noop = true;\n\n\n\n        if (block.number == _rewardPointBlock - 1) {\n\n            boolStorage[IS_REWARDING] = true;\n\n        } else if (block.number == _rewardPointBlock) {\n\n            address[] memory validators = _validatorSetContract.getValidators();\n\n            uint256[] memory ratio = new uint256[](validators.length);\n\n\n\n            uint256 totalReward;\n\n            bool isRewarding = false;\n\n\n\n            totalReward = uintStorage[BRIDGE_TOKEN_FEE];\n\n\n\n            if (!_erc20Restricted) {\n\n                // Accumulated bridge fee plus token inflation\n\n                uint256 inflationPercent;\n\n                if (_stakingEpoch <= 24) {\n\n                    inflationPercent = 32;\n\n                } else if (_stakingEpoch <= 48) {\n\n                    inflationPercent = 16;\n\n                } else if (_stakingEpoch <= 72) {\n\n                    inflationPercent = 8;\n\n                } else {\n\n                    inflationPercent = 4;\n\n                }\n\n                totalReward += snapshotTotalStakeAmount() * inflationPercent / 4800;\n\n            }\n\n\n\n            if (\n\n                totalReward != 0 && _erc20TokenContract != address(0) ||\n\n                uintStorage[BRIDGE_NATIVE_FEE] != 0 ||\n\n                _erc20Restricted\n\n            ) {\n\n                j = 0;\n\n                for (i = 0; i < validators.length; i++) {\n\n                    ratio[i] = uintStorage[keccak256(abi.encode(\n\n                        BLOCKS_CREATED, _stakingEpoch, validators[i]\n\n                    ))];\n\n                    j += ratio[i];\n\n                    validators[i] = _validatorSetContract.stakingByMiningAddress(validators[i]);\n\n                }\n\n                if (j != 0) {\n\n                    for (i = 0; i < validators.length; i++) {\n\n                        ratio[i] = REWARD_PERCENT_MULTIPLIER * ratio[i] / j;\n\n                    }\n\n                }\n\n            }\n\n            if (totalReward != 0) {\n\n                uintStorage[BRIDGE_TOKEN_FEE] = 0;\n\n\n\n                totalReward += uintStorage[TOKEN_REWARD_UNDISTRIBUTED];\n\n\n\n                if (_erc20TokenContract != address(0)) {\n\n                    for (i = 0; i < validators.length; i++) {\n\n                        uintStorage[keccak256(abi.encode(\n\n                            EPOCH_POOL_TOKEN_REWARD, _stakingEpoch, validators[i]\n\n                        ))] = totalReward * ratio[i] / REWARD_PERCENT_MULTIPLIER;\n\n                    }\n\n                    isRewarding = true;\n\n                }\n\n\n\n                uintStorage[TOKEN_REWARD_UNDISTRIBUTED] = totalReward;\n\n            }\n\n\n\n            totalReward = uintStorage[BRIDGE_NATIVE_FEE];\n\n\n\n            if (_erc20Restricted) {\n\n                // Accumulated bridge fee plus 2.5% per year coin inflation\n\n                totalReward += _stakingContract.stakingEpochDuration() * 1 ether;\n\n            }\n\n\n\n            if (totalReward != 0) {\n\n                uintStorage[BRIDGE_NATIVE_FEE] = 0;\n\n\n\n                totalReward += uintStorage[NATIVE_REWARD_UNDISTRIBUTED];\n\n\n\n                for (i = 0; i < validators.length; i++) {\n\n                    uintStorage[keccak256(abi.encode(\n\n                        EPOCH_POOL_NATIVE_REWARD, _stakingEpoch, validators[i]\n\n                    ))] = totalReward * ratio[i] / REWARD_PERCENT_MULTIPLIER;\n\n                }\n\n                isRewarding = true;\n\n\n\n                uintStorage[NATIVE_REWARD_UNDISTRIBUTED] = totalReward;\n\n            }\n\n\n\n            if (isRewarding) {\n\n                for (i = 0; i < validators.length; i++) {\n\n                    _enqueueValidator(validators[i]);\n\n                }\n\n                if (validators.length == 0) {\n\n                    boolStorage[IS_REWARDING] = false;\n\n                }\n\n            } else {\n\n                boolStorage[IS_REWARDING] = false;\n\n            }\n\n\n\n            noop = false;\n\n        } else if (block.number > _rewardPointBlock) {\n\n            address stakingAddress = _dequeueValidator();\n\n\n\n            if (stakingAddress == address(0)) {\n\n                return (receivers, rewards, true);\n\n            }\n\n\n\n            if (_validatorsQueueSize() == 0) {\n\n                boolStorage[IS_REWARDING] = false;\n\n            }\n\n\n\n            if (_validatorSetContract.isValidatorBanned(_validatorSetContract.miningByStakingAddress(stakingAddress))) {\n\n                return (receivers, rewards, true);\n\n            }\n\n\n\n            address[] storage stakers = addressArrayStorage[keccak256(abi.encode(SNAPSHOT_STAKERS, stakingAddress))];\n\n            uint256[] memory range = new uint256[](3); // array instead of local vars because the stack is too deep\n\n            range[0] = (_validatorsQueueSize() + 1) % DELEGATORS_ALIQUOT; // offset\n\n            range[1] = range[0] * stakers.length / DELEGATORS_ALIQUOT; // from\n\n            range[2] = (range[0] + 1) * stakers.length / DELEGATORS_ALIQUOT; // to\n\n\n\n            if (range[0] == 0) {\n\n                range[2] += stakers.length % DELEGATORS_ALIQUOT;\n\n            } else {\n\n                range[1] += stakers.length % DELEGATORS_ALIQUOT;\n\n            }\n\n\n\n            if (range[1] >= range[2]) {\n\n                return (receivers, rewards, true);\n\n            }\n\n\n\n            uint256[] storage rewardPercents = uintArrayStorage[keccak256(abi.encode(\n\n                SNAPSHOT_REWARD_PERCENTS, stakingAddress\n\n            ))];\n\n            uint256 accrued;\n\n            uint256 poolReward;\n\n\n\n            receivers = new address[](range[2] - range[1]);\n\n            rewards = new uint256[](receivers.length);\n\n\n\n            poolReward = uintStorage[keccak256(abi.encode(\n\n                EPOCH_POOL_TOKEN_REWARD, _stakingEpoch, stakingAddress\n\n            ))];\n\n            if (poolReward != 0) {\n\n                accrued = 0;\n\n                for (i = range[1]; i < range[2]; i++) {\n\n                    j = i - range[1];\n\n                    receivers[j] = stakers[i];\n\n                    rewards[j] = poolReward * rewardPercents[i] / REWARD_PERCENT_MULTIPLIER;\n\n                    accrued += rewards[j];\n\n                }\n\n                IERC20Minting(_erc20TokenContract).mintReward(receivers, rewards);\n\n                _subTokenRewardUndistributed(accrued);\n\n                noop = false;\n\n            }\n\n\n\n            poolReward = uintStorage[keccak256(abi.encode(\n\n                EPOCH_POOL_NATIVE_REWARD, _stakingEpoch, stakingAddress\n\n            ))];\n\n            if (poolReward != 0) {\n\n                accrued = 0;\n\n                for (i = range[1]; i < range[2]; i++) {\n\n                    j = i - range[1];\n\n                    receivers[j] = stakers[i];\n\n                    rewards[j] = poolReward * rewardPercents[i] / REWARD_PERCENT_MULTIPLIER;\n\n                    accrued += rewards[j];\n\n                }\n\n                _subNativeRewardUndistributed(accrued);\n\n                noop = false;\n\n            } else {\n\n                return (new address[](0), new uint256[](0), noop);\n\n            }\n\n        }\n",
          "message": "Reentrancy in BlockRewardAuRa._distributeRewards (BlockRewardAuRaMock.sol#954-1138):\n\tExternal calls:\n\t- IERC20Minting(_erc20TokenContract).mintReward(receivers,rewards) (BlockRewardAuRaMock.sol#1116)\n\tState variables written after the call(s):\n\t- uintStorage (BlockRewardAuRaMock.sol#1117)\n\t- uintStorage (BlockRewardAuRaMock.sol#1132)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 271,
          "vulnerability_to_line": 279,
          "vulnerability_code": "    function migrateMintingStatistics(address _bridge, IBlockReward _prevBlockRewardContract) external onlyOwner {\n\n        require(mintedTotally() == 0);\n\n        uint256 prevMinted = _prevBlockRewardContract.mintedTotally();\n\n        uint256 prevMintedByBridge = _prevBlockRewardContract.mintedTotallyByBridge(_bridge);\n\n        require(prevMinted != 0);\n\n        require(prevMintedByBridge != 0);\n\n        uintStorage[MINTED_TOTALLY] = prevMinted;\n\n        uintStorage[keccak256(abi.encode(MINTED_TOTALLY_BY_BRIDGE, _bridge))] = prevMintedByBridge;\n",
          "message": "Reentrancy in BlockRewardBase.migrateMintingStatistics (BlockRewardAuRaMock.sol#271-279):\n\tExternal calls:\n\t- prevMinted = _prevBlockRewardContract.mintedTotally() (BlockRewardAuRaMock.sol#273)\n\t- prevMintedByBridge = _prevBlockRewardContract.mintedTotallyByBridge(_bridge) (BlockRewardAuRaMock.sol#274)\n\tState variables written after the call(s):\n\t- uintStorage (BlockRewardAuRaMock.sol#277)\n\t- uintStorage (BlockRewardAuRaMock.sol#278)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 763,
          "vulnerability_to_line": 872,
          "vulnerability_code": "    function reward(address[] calldata benefactors, uint16[] calldata kind)\n\n        external\n\n        onlySystem\n\n        returns(address[] memory receiversNative, uint256[] memory rewardsNative)\n\n    {\n\n        if (benefactors.length != kind.length || benefactors.length != 1 || kind[0] != 0) {\n\n            return (new address[](0), new uint256[](0));\n\n        }\n\n\n\n        IValidatorSet validatorSet = validatorSetContract();\n\n\n\n        // Check if the validator is existed\n\n        if (!validatorSet.isValidator(benefactors[0])) {\n\n            return (new address[](0), new uint256[](0));\n\n        }\n\n\n\n        receiversNative = new address[](0);\n\n        rewardsNative = new uint256[](0);\n\n\n\n        // Check the current validators at the end of each collection round whether\n\n        // they revealed their secrets, and remove a validator as a malicious if needed\n\n        IRandomAuRa(validatorSet.randomContract()).onFinishCollectRound();\n\n\n\n        // Initialize queues\n\n        if (!boolStorage[QUEUE_V_INITIALIZED]) {\n\n            uintStorage[QUEUE_V_FIRST] = 1;\n\n            uintStorage[QUEUE_V_LAST] = 0;\n\n            boolStorage[QUEUE_V_INITIALIZED] = true;\n\n        }\n\n        if (!boolStorage[QUEUE_ER_INITIALIZED]) {\n\n            uintStorage[QUEUE_ER_FIRST] = 1;\n\n            uintStorage[QUEUE_ER_LAST] = 0;\n\n            boolStorage[QUEUE_ER_INITIALIZED] = true;\n\n        }\n\n\n\n        IStaking stakingContract = IStaking(validatorSet.stakingContract());\n\n        uint256 bridgeQueueLimit = 100;\n\n        uint256 stakingEpoch = stakingContract.stakingEpoch();\n\n        uint256 rewardPointBlock = _rewardPointBlock(IStakingAuRa(address(stakingContract)), validatorSet);\n\n\n\n        if (validatorSet.validatorSetApplyBlock() != 0 && block.number <= rewardPointBlock) {\n\n            if (stakingEpoch != 0) {\n\n                // Accumulate blocks producing statistics for each of the\n\n                // active validators during the current staking epoch\n\n                uintStorage[keccak256(abi.encode(BLOCKS_CREATED, stakingEpoch, benefactors[0]))]++;\n\n            }\n\n        }\n\n\n\n        // Start a new staking epoch every `stakingEpochDuration()` blocks\n\n        (bool newStakingEpochHasBegun, uint256 poolsToBeElectedLength) = validatorSet.newValidatorSet();\n\n\n\n        if (newStakingEpochHasBegun) {\n\n            // A new staking epoch has begun, so prepare for reward coefficients snapshotting\n\n            // process which begins right from the following block\n\n            address[] memory newValidatorSet = validatorSet.getPendingValidators();\n\n\n\n            for (uint256 i = 0; i < newValidatorSet.length; i++) {\n\n                address stakingAddress = validatorSet.stakingByMiningAddress(newValidatorSet[i]);\n\n\n\n                _enqueueValidator(stakingAddress);\n\n\n\n                delete addressArrayStorage[keccak256(abi.encode(SNAPSHOT_STAKERS, stakingAddress))];\n\n                delete uintArrayStorage[keccak256(abi.encode(SNAPSHOT_REWARD_PERCENTS, stakingAddress))];\n\n            }\n\n\n\n            delete addressArrayStorage[SNAPSHOT_STAKING_ADDRESSES];\n\n            uintStorage[SNAPSHOT_TOTAL_STAKE_AMOUNT] = 0;\n\n            boolStorage[IS_SNAPSHOTTING] = (newValidatorSet.length != 0);\n\n\n\n            if (poolsToBeElectedLength > 2000) {\n\n                bridgeQueueLimit = 0;\n\n            } else if (poolsToBeElectedLength > 1000) {\n\n                bridgeQueueLimit = 30;\n\n            } else {\n\n                bridgeQueueLimit = 50;\n\n            }\n\n        } else if (boolStorage[IS_SNAPSHOTTING]) {\n\n            // Snapshot reward coefficients for each new validator and their delegators\n\n            // during the very first blocks of a new staking epoch\n\n            address stakingAddress = _dequeueValidator();\n\n\n\n            if (stakingAddress != address(0)) {\n\n                uint256 validatorsQueueSize = _validatorsQueueSize();\n\n                _setSnapshot(stakingAddress, stakingContract, (validatorsQueueSize + 1) % DELEGATORS_ALIQUOT);\n\n                if (validatorsQueueSize == 0) {\n\n                    // Snapshotting process has been finished\n\n                    boolStorage[IS_SNAPSHOTTING] = false;\n\n                }\n\n                bridgeQueueLimit = 50;\n\n            }\n\n        } else if (stakingEpoch != 0) {\n\n            // Distribute rewards at the end of staking epoch during the last\n\n            // MAX_VALIDATORS * DELEGATORS_ALIQUOT blocks\n\n            bool noop;\n\n            (receiversNative, rewardsNative, noop) = _distributeRewards(\n\n                validatorSet,\n\n                stakingContract.erc20TokenContract(),\n\n                stakingContract.erc20Restricted(),\n\n                IStakingAuRa(address(stakingContract)),\n\n                stakingEpoch,\n\n                rewardPointBlock\n\n            );\n\n            if (!noop) {\n\n                bridgeQueueLimit = 50;\n\n            }\n\n        }\n\n\n\n        // Mint native coins if needed\n\n        return _mintNativeCoins(receiversNative, rewardsNative, bridgeQueueLimit);\n",
          "message": "Reentrancy in BlockRewardAuRa.reward (BlockRewardAuRaMock.sol#763-872):\n\tExternal calls:\n\t- ! validatorSet.isValidator(benefactors[0]) (BlockRewardAuRaMock.sol#775-777)\n\t- IRandomAuRa(validatorSet.randomContract()).onFinishCollectRound() (BlockRewardAuRaMock.sol#784)\n\t- stakingContract = IStaking(validatorSet.stakingContract()) (BlockRewardAuRaMock.sol#798)\n\t- stakingEpoch = stakingContract.stakingEpoch() (BlockRewardAuRaMock.sol#800)\n\t- rewardPointBlock = _rewardPointBlock(IStakingAuRa(address(stakingContract)),validatorSet) (BlockRewardAuRaMock.sol#801)\n\t- validatorSet.validatorSetApplyBlock() != 0 && block.number <= rewardPointBlock (BlockRewardAuRaMock.sol#803-809)\n\t- (newStakingEpochHasBegun,poolsToBeElectedLength) = validatorSet.newValidatorSet() (BlockRewardAuRaMock.sol#812)\n\t- newValidatorSet = validatorSet.getPendingValidators() (BlockRewardAuRaMock.sol#817)\n\t- stakingAddress = validatorSet.stakingByMiningAddress(newValidatorSet[i]) (BlockRewardAuRaMock.sol#820)\n\tState variables written after the call(s):\n\t- addressArrayStorage (BlockRewardAuRaMock.sol#824)\n\t- addressStorage (BlockRewardAuRaMock.sol#822)\n\t- boolStorage (BlockRewardAuRaMock.sol#830)\n\t- uintArrayStorage (BlockRewardAuRaMock.sol#825)\n\t- uintStorage (BlockRewardAuRaMock.sol#822)\n\t- uintStorage (BlockRewardAuRaMock.sol#829)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 763,
          "vulnerability_to_line": 872,
          "vulnerability_code": "    function reward(address[] calldata benefactors, uint16[] calldata kind)\n\n        external\n\n        onlySystem\n\n        returns(address[] memory receiversNative, uint256[] memory rewardsNative)\n\n    {\n\n        if (benefactors.length != kind.length || benefactors.length != 1 || kind[0] != 0) {\n\n            return (new address[](0), new uint256[](0));\n\n        }\n\n\n\n        IValidatorSet validatorSet = validatorSetContract();\n\n\n\n        // Check if the validator is existed\n\n        if (!validatorSet.isValidator(benefactors[0])) {\n\n            return (new address[](0), new uint256[](0));\n\n        }\n\n\n\n        receiversNative = new address[](0);\n\n        rewardsNative = new uint256[](0);\n\n\n\n        // Check the current validators at the end of each collection round whether\n\n        // they revealed their secrets, and remove a validator as a malicious if needed\n\n        IRandomAuRa(validatorSet.randomContract()).onFinishCollectRound();\n\n\n\n        // Initialize queues\n\n        if (!boolStorage[QUEUE_V_INITIALIZED]) {\n\n            uintStorage[QUEUE_V_FIRST] = 1;\n\n            uintStorage[QUEUE_V_LAST] = 0;\n\n            boolStorage[QUEUE_V_INITIALIZED] = true;\n\n        }\n\n        if (!boolStorage[QUEUE_ER_INITIALIZED]) {\n\n            uintStorage[QUEUE_ER_FIRST] = 1;\n\n            uintStorage[QUEUE_ER_LAST] = 0;\n\n            boolStorage[QUEUE_ER_INITIALIZED] = true;\n\n        }\n\n\n\n        IStaking stakingContract = IStaking(validatorSet.stakingContract());\n\n        uint256 bridgeQueueLimit = 100;\n\n        uint256 stakingEpoch = stakingContract.stakingEpoch();\n\n        uint256 rewardPointBlock = _rewardPointBlock(IStakingAuRa(address(stakingContract)), validatorSet);\n\n\n\n        if (validatorSet.validatorSetApplyBlock() != 0 && block.number <= rewardPointBlock) {\n\n            if (stakingEpoch != 0) {\n\n                // Accumulate blocks producing statistics for each of the\n\n                // active validators during the current staking epoch\n\n                uintStorage[keccak256(abi.encode(BLOCKS_CREATED, stakingEpoch, benefactors[0]))]++;\n\n            }\n\n        }\n\n\n\n        // Start a new staking epoch every `stakingEpochDuration()` blocks\n\n        (bool newStakingEpochHasBegun, uint256 poolsToBeElectedLength) = validatorSet.newValidatorSet();\n\n\n\n        if (newStakingEpochHasBegun) {\n\n            // A new staking epoch has begun, so prepare for reward coefficients snapshotting\n\n            // process which begins right from the following block\n\n            address[] memory newValidatorSet = validatorSet.getPendingValidators();\n\n\n\n            for (uint256 i = 0; i < newValidatorSet.length; i++) {\n\n                address stakingAddress = validatorSet.stakingByMiningAddress(newValidatorSet[i]);\n\n\n\n                _enqueueValidator(stakingAddress);\n\n\n\n                delete addressArrayStorage[keccak256(abi.encode(SNAPSHOT_STAKERS, stakingAddress))];\n\n                delete uintArrayStorage[keccak256(abi.encode(SNAPSHOT_REWARD_PERCENTS, stakingAddress))];\n\n            }\n\n\n\n            delete addressArrayStorage[SNAPSHOT_STAKING_ADDRESSES];\n\n            uintStorage[SNAPSHOT_TOTAL_STAKE_AMOUNT] = 0;\n\n            boolStorage[IS_SNAPSHOTTING] = (newValidatorSet.length != 0);\n\n\n\n            if (poolsToBeElectedLength > 2000) {\n\n                bridgeQueueLimit = 0;\n\n            } else if (poolsToBeElectedLength > 1000) {\n\n                bridgeQueueLimit = 30;\n\n            } else {\n\n                bridgeQueueLimit = 50;\n\n            }\n\n        } else if (boolStorage[IS_SNAPSHOTTING]) {\n\n            // Snapshot reward coefficients for each new validator and their delegators\n\n            // during the very first blocks of a new staking epoch\n\n            address stakingAddress = _dequeueValidator();\n\n\n\n            if (stakingAddress != address(0)) {\n\n                uint256 validatorsQueueSize = _validatorsQueueSize();\n\n                _setSnapshot(stakingAddress, stakingContract, (validatorsQueueSize + 1) % DELEGATORS_ALIQUOT);\n\n                if (validatorsQueueSize == 0) {\n\n                    // Snapshotting process has been finished\n\n                    boolStorage[IS_SNAPSHOTTING] = false;\n\n                }\n\n                bridgeQueueLimit = 50;\n\n            }\n\n        } else if (stakingEpoch != 0) {\n\n            // Distribute rewards at the end of staking epoch during the last\n\n            // MAX_VALIDATORS * DELEGATORS_ALIQUOT blocks\n\n            bool noop;\n\n            (receiversNative, rewardsNative, noop) = _distributeRewards(\n\n                validatorSet,\n\n                stakingContract.erc20TokenContract(),\n\n                stakingContract.erc20Restricted(),\n\n                IStakingAuRa(address(stakingContract)),\n\n                stakingEpoch,\n\n                rewardPointBlock\n\n            );\n\n            if (!noop) {\n\n                bridgeQueueLimit = 50;\n\n            }\n\n        }\n\n\n\n        // Mint native coins if needed\n\n        return _mintNativeCoins(receiversNative, rewardsNative, bridgeQueueLimit);\n",
          "message": "Reentrancy in BlockRewardAuRa.reward (BlockRewardAuRaMock.sol#763-872):\n\tExternal calls:\n\t- ! validatorSet.isValidator(benefactors[0]) (BlockRewardAuRaMock.sol#775-777)\n\t- IRandomAuRa(validatorSet.randomContract()).onFinishCollectRound() (BlockRewardAuRaMock.sol#784)\n\t- stakingContract = IStaking(validatorSet.stakingContract()) (BlockRewardAuRaMock.sol#798)\n\t- stakingEpoch = stakingContract.stakingEpoch() (BlockRewardAuRaMock.sol#800)\n\t- rewardPointBlock = _rewardPointBlock(IStakingAuRa(address(stakingContract)),validatorSet) (BlockRewardAuRaMock.sol#801)\n\t- validatorSet.validatorSetApplyBlock() != 0 && block.number <= rewardPointBlock (BlockRewardAuRaMock.sol#803-809)\n\t- (newStakingEpochHasBegun,poolsToBeElectedLength) = validatorSet.newValidatorSet() (BlockRewardAuRaMock.sol#812)\n\tState variables written after the call(s):\n\t- addressStorage (BlockRewardAuRaMock.sol#842)\n\t- uintStorage (BlockRewardAuRaMock.sol#842)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 763,
          "vulnerability_to_line": 872,
          "vulnerability_code": "    function reward(address[] calldata benefactors, uint16[] calldata kind)\n\n        external\n\n        onlySystem\n\n        returns(address[] memory receiversNative, uint256[] memory rewardsNative)\n\n    {\n\n        if (benefactors.length != kind.length || benefactors.length != 1 || kind[0] != 0) {\n\n            return (new address[](0), new uint256[](0));\n\n        }\n\n\n\n        IValidatorSet validatorSet = validatorSetContract();\n\n\n\n        // Check if the validator is existed\n\n        if (!validatorSet.isValidator(benefactors[0])) {\n\n            return (new address[](0), new uint256[](0));\n\n        }\n\n\n\n        receiversNative = new address[](0);\n\n        rewardsNative = new uint256[](0);\n\n\n\n        // Check the current validators at the end of each collection round whether\n\n        // they revealed their secrets, and remove a validator as a malicious if needed\n\n        IRandomAuRa(validatorSet.randomContract()).onFinishCollectRound();\n\n\n\n        // Initialize queues\n\n        if (!boolStorage[QUEUE_V_INITIALIZED]) {\n\n            uintStorage[QUEUE_V_FIRST] = 1;\n\n            uintStorage[QUEUE_V_LAST] = 0;\n\n            boolStorage[QUEUE_V_INITIALIZED] = true;\n\n        }\n\n        if (!boolStorage[QUEUE_ER_INITIALIZED]) {\n\n            uintStorage[QUEUE_ER_FIRST] = 1;\n\n            uintStorage[QUEUE_ER_LAST] = 0;\n\n            boolStorage[QUEUE_ER_INITIALIZED] = true;\n\n        }\n\n\n\n        IStaking stakingContract = IStaking(validatorSet.stakingContract());\n\n        uint256 bridgeQueueLimit = 100;\n\n        uint256 stakingEpoch = stakingContract.stakingEpoch();\n\n        uint256 rewardPointBlock = _rewardPointBlock(IStakingAuRa(address(stakingContract)), validatorSet);\n\n\n\n        if (validatorSet.validatorSetApplyBlock() != 0 && block.number <= rewardPointBlock) {\n\n            if (stakingEpoch != 0) {\n\n                // Accumulate blocks producing statistics for each of the\n\n                // active validators during the current staking epoch\n\n                uintStorage[keccak256(abi.encode(BLOCKS_CREATED, stakingEpoch, benefactors[0]))]++;\n\n            }\n\n        }\n\n\n\n        // Start a new staking epoch every `stakingEpochDuration()` blocks\n\n        (bool newStakingEpochHasBegun, uint256 poolsToBeElectedLength) = validatorSet.newValidatorSet();\n\n\n\n        if (newStakingEpochHasBegun) {\n\n            // A new staking epoch has begun, so prepare for reward coefficients snapshotting\n\n            // process which begins right from the following block\n\n            address[] memory newValidatorSet = validatorSet.getPendingValidators();\n\n\n\n            for (uint256 i = 0; i < newValidatorSet.length; i++) {\n\n                address stakingAddress = validatorSet.stakingByMiningAddress(newValidatorSet[i]);\n\n\n\n                _enqueueValidator(stakingAddress);\n\n\n\n                delete addressArrayStorage[keccak256(abi.encode(SNAPSHOT_STAKERS, stakingAddress))];\n\n                delete uintArrayStorage[keccak256(abi.encode(SNAPSHOT_REWARD_PERCENTS, stakingAddress))];\n\n            }\n\n\n\n            delete addressArrayStorage[SNAPSHOT_STAKING_ADDRESSES];\n\n            uintStorage[SNAPSHOT_TOTAL_STAKE_AMOUNT] = 0;\n\n            boolStorage[IS_SNAPSHOTTING] = (newValidatorSet.length != 0);\n\n\n\n            if (poolsToBeElectedLength > 2000) {\n\n                bridgeQueueLimit = 0;\n\n            } else if (poolsToBeElectedLength > 1000) {\n\n                bridgeQueueLimit = 30;\n\n            } else {\n\n                bridgeQueueLimit = 50;\n\n            }\n\n        } else if (boolStorage[IS_SNAPSHOTTING]) {\n\n            // Snapshot reward coefficients for each new validator and their delegators\n\n            // during the very first blocks of a new staking epoch\n\n            address stakingAddress = _dequeueValidator();\n\n\n\n            if (stakingAddress != address(0)) {\n\n                uint256 validatorsQueueSize = _validatorsQueueSize();\n\n                _setSnapshot(stakingAddress, stakingContract, (validatorsQueueSize + 1) % DELEGATORS_ALIQUOT);\n\n                if (validatorsQueueSize == 0) {\n\n                    // Snapshotting process has been finished\n\n                    boolStorage[IS_SNAPSHOTTING] = false;\n\n                }\n\n                bridgeQueueLimit = 50;\n\n            }\n\n        } else if (stakingEpoch != 0) {\n\n            // Distribute rewards at the end of staking epoch during the last\n\n            // MAX_VALIDATORS * DELEGATORS_ALIQUOT blocks\n\n            bool noop;\n\n            (receiversNative, rewardsNative, noop) = _distributeRewards(\n\n                validatorSet,\n\n                stakingContract.erc20TokenContract(),\n\n                stakingContract.erc20Restricted(),\n\n                IStakingAuRa(address(stakingContract)),\n\n                stakingEpoch,\n\n                rewardPointBlock\n\n            );\n\n            if (!noop) {\n\n                bridgeQueueLimit = 50;\n\n            }\n\n        }\n\n\n\n        // Mint native coins if needed\n\n        return _mintNativeCoins(receiversNative, rewardsNative, bridgeQueueLimit);\n",
          "message": "Reentrancy in BlockRewardAuRa.reward (BlockRewardAuRaMock.sol#763-872):\n\tExternal calls:\n\t- ! validatorSet.isValidator(benefactors[0]) (BlockRewardAuRaMock.sol#775-777)\n\t- IRandomAuRa(validatorSet.randomContract()).onFinishCollectRound() (BlockRewardAuRaMock.sol#784)\n\t- stakingContract = IStaking(validatorSet.stakingContract()) (BlockRewardAuRaMock.sol#798)\n\t- stakingEpoch = stakingContract.stakingEpoch() (BlockRewardAuRaMock.sol#800)\n\t- rewardPointBlock = _rewardPointBlock(IStakingAuRa(address(stakingContract)),validatorSet) (BlockRewardAuRaMock.sol#801)\n\t- validatorSet.validatorSetApplyBlock() != 0 && block.number <= rewardPointBlock (BlockRewardAuRaMock.sol#803-809)\n\t- (newStakingEpochHasBegun,poolsToBeElectedLength) = validatorSet.newValidatorSet() (BlockRewardAuRaMock.sol#812)\n\t- _setSnapshot(stakingAddress_scope_0,stakingContract,(validatorsQueueSize + 1) % DELEGATORS_ALIQUOT) (BlockRewardAuRaMock.sol#846)\n\tState variables written after the call(s):\n\t- boolStorage (BlockRewardAuRaMock.sol#849)\n\t- uintStorage (BlockRewardAuRaMock.sol#846)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 763,
          "vulnerability_to_line": 872,
          "vulnerability_code": "    function reward(address[] calldata benefactors, uint16[] calldata kind)\n\n        external\n\n        onlySystem\n\n        returns(address[] memory receiversNative, uint256[] memory rewardsNative)\n\n    {\n\n        if (benefactors.length != kind.length || benefactors.length != 1 || kind[0] != 0) {\n\n            return (new address[](0), new uint256[](0));\n\n        }\n\n\n\n        IValidatorSet validatorSet = validatorSetContract();\n\n\n\n        // Check if the validator is existed\n\n        if (!validatorSet.isValidator(benefactors[0])) {\n\n            return (new address[](0), new uint256[](0));\n\n        }\n\n\n\n        receiversNative = new address[](0);\n\n        rewardsNative = new uint256[](0);\n\n\n\n        // Check the current validators at the end of each collection round whether\n\n        // they revealed their secrets, and remove a validator as a malicious if needed\n\n        IRandomAuRa(validatorSet.randomContract()).onFinishCollectRound();\n\n\n\n        // Initialize queues\n\n        if (!boolStorage[QUEUE_V_INITIALIZED]) {\n\n            uintStorage[QUEUE_V_FIRST] = 1;\n\n            uintStorage[QUEUE_V_LAST] = 0;\n\n            boolStorage[QUEUE_V_INITIALIZED] = true;\n\n        }\n\n        if (!boolStorage[QUEUE_ER_INITIALIZED]) {\n\n            uintStorage[QUEUE_ER_FIRST] = 1;\n\n            uintStorage[QUEUE_ER_LAST] = 0;\n\n            boolStorage[QUEUE_ER_INITIALIZED] = true;\n\n        }\n\n\n\n        IStaking stakingContract = IStaking(validatorSet.stakingContract());\n\n        uint256 bridgeQueueLimit = 100;\n\n        uint256 stakingEpoch = stakingContract.stakingEpoch();\n\n        uint256 rewardPointBlock = _rewardPointBlock(IStakingAuRa(address(stakingContract)), validatorSet);\n\n\n\n        if (validatorSet.validatorSetApplyBlock() != 0 && block.number <= rewardPointBlock) {\n\n            if (stakingEpoch != 0) {\n\n                // Accumulate blocks producing statistics for each of the\n\n                // active validators during the current staking epoch\n\n                uintStorage[keccak256(abi.encode(BLOCKS_CREATED, stakingEpoch, benefactors[0]))]++;\n\n            }\n\n        }\n\n\n\n        // Start a new staking epoch every `stakingEpochDuration()` blocks\n\n        (bool newStakingEpochHasBegun, uint256 poolsToBeElectedLength) = validatorSet.newValidatorSet();\n\n\n\n        if (newStakingEpochHasBegun) {\n\n            // A new staking epoch has begun, so prepare for reward coefficients snapshotting\n\n            // process which begins right from the following block\n\n            address[] memory newValidatorSet = validatorSet.getPendingValidators();\n\n\n\n            for (uint256 i = 0; i < newValidatorSet.length; i++) {\n\n                address stakingAddress = validatorSet.stakingByMiningAddress(newValidatorSet[i]);\n\n\n\n                _enqueueValidator(stakingAddress);\n\n\n\n                delete addressArrayStorage[keccak256(abi.encode(SNAPSHOT_STAKERS, stakingAddress))];\n\n                delete uintArrayStorage[keccak256(abi.encode(SNAPSHOT_REWARD_PERCENTS, stakingAddress))];\n\n            }\n\n\n\n            delete addressArrayStorage[SNAPSHOT_STAKING_ADDRESSES];\n\n            uintStorage[SNAPSHOT_TOTAL_STAKE_AMOUNT] = 0;\n\n            boolStorage[IS_SNAPSHOTTING] = (newValidatorSet.length != 0);\n\n\n\n            if (poolsToBeElectedLength > 2000) {\n\n                bridgeQueueLimit = 0;\n\n            } else if (poolsToBeElectedLength > 1000) {\n\n                bridgeQueueLimit = 30;\n\n            } else {\n\n                bridgeQueueLimit = 50;\n\n            }\n\n        } else if (boolStorage[IS_SNAPSHOTTING]) {\n\n            // Snapshot reward coefficients for each new validator and their delegators\n\n            // during the very first blocks of a new staking epoch\n\n            address stakingAddress = _dequeueValidator();\n\n\n\n            if (stakingAddress != address(0)) {\n\n                uint256 validatorsQueueSize = _validatorsQueueSize();\n\n                _setSnapshot(stakingAddress, stakingContract, (validatorsQueueSize + 1) % DELEGATORS_ALIQUOT);\n\n                if (validatorsQueueSize == 0) {\n\n                    // Snapshotting process has been finished\n\n                    boolStorage[IS_SNAPSHOTTING] = false;\n\n                }\n\n                bridgeQueueLimit = 50;\n\n            }\n\n        } else if (stakingEpoch != 0) {\n\n            // Distribute rewards at the end of staking epoch during the last\n\n            // MAX_VALIDATORS * DELEGATORS_ALIQUOT blocks\n\n            bool noop;\n\n            (receiversNative, rewardsNative, noop) = _distributeRewards(\n\n                validatorSet,\n\n                stakingContract.erc20TokenContract(),\n\n                stakingContract.erc20Restricted(),\n\n                IStakingAuRa(address(stakingContract)),\n\n                stakingEpoch,\n\n                rewardPointBlock\n\n            );\n\n            if (!noop) {\n\n                bridgeQueueLimit = 50;\n\n            }\n\n        }\n\n\n\n        // Mint native coins if needed\n\n        return _mintNativeCoins(receiversNative, rewardsNative, bridgeQueueLimit);\n",
          "message": "Reentrancy in BlockRewardAuRa.reward (BlockRewardAuRaMock.sol#763-872):\n\tExternal calls:\n\t- ! validatorSet.isValidator(benefactors[0]) (BlockRewardAuRaMock.sol#775-777)\n\t- IRandomAuRa(validatorSet.randomContract()).onFinishCollectRound() (BlockRewardAuRaMock.sol#784)\n\t- stakingContract = IStaking(validatorSet.stakingContract()) (BlockRewardAuRaMock.sol#798)\n\t- stakingEpoch = stakingContract.stakingEpoch() (BlockRewardAuRaMock.sol#800)\n\t- rewardPointBlock = _rewardPointBlock(IStakingAuRa(address(stakingContract)),validatorSet) (BlockRewardAuRaMock.sol#801)\n\t- validatorSet.validatorSetApplyBlock() != 0 && block.number <= rewardPointBlock (BlockRewardAuRaMock.sol#803-809)\n\t- (newStakingEpochHasBegun,poolsToBeElectedLength) = validatorSet.newValidatorSet() (BlockRewardAuRaMock.sol#812)\n\t- (receiversNative,rewardsNative,noop) = _distributeRewards(validatorSet,stakingContract.erc20TokenContract(),stakingContract.erc20Restricted(),IStakingAuRa(address(stakingContract)),stakingEpoch,rewardPointBlock) (BlockRewardAuRaMock.sol#857-864)\n\tState variables written after the call(s):\n\t- addressStorage (BlockRewardAuRaMock.sol#857-864)\n\t- boolStorage (BlockRewardAuRaMock.sol#857-864)\n\t- uintStorage (BlockRewardAuRaMock.sol#857-864)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 763,
          "vulnerability_to_line": 872,
          "vulnerability_code": "    function reward(address[] calldata benefactors, uint16[] calldata kind)\n\n        external\n\n        onlySystem\n\n        returns(address[] memory receiversNative, uint256[] memory rewardsNative)\n\n    {\n\n        if (benefactors.length != kind.length || benefactors.length != 1 || kind[0] != 0) {\n\n            return (new address[](0), new uint256[](0));\n\n        }\n\n\n\n        IValidatorSet validatorSet = validatorSetContract();\n\n\n\n        // Check if the validator is existed\n\n        if (!validatorSet.isValidator(benefactors[0])) {\n\n            return (new address[](0), new uint256[](0));\n\n        }\n\n\n\n        receiversNative = new address[](0);\n\n        rewardsNative = new uint256[](0);\n\n\n\n        // Check the current validators at the end of each collection round whether\n\n        // they revealed their secrets, and remove a validator as a malicious if needed\n\n        IRandomAuRa(validatorSet.randomContract()).onFinishCollectRound();\n\n\n\n        // Initialize queues\n\n        if (!boolStorage[QUEUE_V_INITIALIZED]) {\n\n            uintStorage[QUEUE_V_FIRST] = 1;\n\n            uintStorage[QUEUE_V_LAST] = 0;\n\n            boolStorage[QUEUE_V_INITIALIZED] = true;\n\n        }\n\n        if (!boolStorage[QUEUE_ER_INITIALIZED]) {\n\n            uintStorage[QUEUE_ER_FIRST] = 1;\n\n            uintStorage[QUEUE_ER_LAST] = 0;\n\n            boolStorage[QUEUE_ER_INITIALIZED] = true;\n\n        }\n\n\n\n        IStaking stakingContract = IStaking(validatorSet.stakingContract());\n\n        uint256 bridgeQueueLimit = 100;\n\n        uint256 stakingEpoch = stakingContract.stakingEpoch();\n\n        uint256 rewardPointBlock = _rewardPointBlock(IStakingAuRa(address(stakingContract)), validatorSet);\n\n\n\n        if (validatorSet.validatorSetApplyBlock() != 0 && block.number <= rewardPointBlock) {\n\n            if (stakingEpoch != 0) {\n\n                // Accumulate blocks producing statistics for each of the\n\n                // active validators during the current staking epoch\n\n                uintStorage[keccak256(abi.encode(BLOCKS_CREATED, stakingEpoch, benefactors[0]))]++;\n\n            }\n\n        }\n\n\n\n        // Start a new staking epoch every `stakingEpochDuration()` blocks\n\n        (bool newStakingEpochHasBegun, uint256 poolsToBeElectedLength) = validatorSet.newValidatorSet();\n\n\n\n        if (newStakingEpochHasBegun) {\n\n            // A new staking epoch has begun, so prepare for reward coefficients snapshotting\n\n            // process which begins right from the following block\n\n            address[] memory newValidatorSet = validatorSet.getPendingValidators();\n\n\n\n            for (uint256 i = 0; i < newValidatorSet.length; i++) {\n\n                address stakingAddress = validatorSet.stakingByMiningAddress(newValidatorSet[i]);\n\n\n\n                _enqueueValidator(stakingAddress);\n\n\n\n                delete addressArrayStorage[keccak256(abi.encode(SNAPSHOT_STAKERS, stakingAddress))];\n\n                delete uintArrayStorage[keccak256(abi.encode(SNAPSHOT_REWARD_PERCENTS, stakingAddress))];\n\n            }\n\n\n\n            delete addressArrayStorage[SNAPSHOT_STAKING_ADDRESSES];\n\n            uintStorage[SNAPSHOT_TOTAL_STAKE_AMOUNT] = 0;\n\n            boolStorage[IS_SNAPSHOTTING] = (newValidatorSet.length != 0);\n\n\n\n            if (poolsToBeElectedLength > 2000) {\n\n                bridgeQueueLimit = 0;\n\n            } else if (poolsToBeElectedLength > 1000) {\n\n                bridgeQueueLimit = 30;\n\n            } else {\n\n                bridgeQueueLimit = 50;\n\n            }\n\n        } else if (boolStorage[IS_SNAPSHOTTING]) {\n\n            // Snapshot reward coefficients for each new validator and their delegators\n\n            // during the very first blocks of a new staking epoch\n\n            address stakingAddress = _dequeueValidator();\n\n\n\n            if (stakingAddress != address(0)) {\n\n                uint256 validatorsQueueSize = _validatorsQueueSize();\n\n                _setSnapshot(stakingAddress, stakingContract, (validatorsQueueSize + 1) % DELEGATORS_ALIQUOT);\n\n                if (validatorsQueueSize == 0) {\n\n                    // Snapshotting process has been finished\n\n                    boolStorage[IS_SNAPSHOTTING] = false;\n\n                }\n\n                bridgeQueueLimit = 50;\n\n            }\n\n        } else if (stakingEpoch != 0) {\n\n            // Distribute rewards at the end of staking epoch during the last\n\n            // MAX_VALIDATORS * DELEGATORS_ALIQUOT blocks\n\n            bool noop;\n\n            (receiversNative, rewardsNative, noop) = _distributeRewards(\n\n                validatorSet,\n\n                stakingContract.erc20TokenContract(),\n\n                stakingContract.erc20Restricted(),\n\n                IStakingAuRa(address(stakingContract)),\n\n                stakingEpoch,\n\n                rewardPointBlock\n\n            );\n\n            if (!noop) {\n\n                bridgeQueueLimit = 50;\n\n            }\n\n        }\n\n\n\n        // Mint native coins if needed\n\n        return _mintNativeCoins(receiversNative, rewardsNative, bridgeQueueLimit);\n",
          "message": "Reentrancy in BlockRewardAuRa.reward (BlockRewardAuRaMock.sol#763-872):\n\tExternal calls:\n\t- ! validatorSet.isValidator(benefactors[0]) (BlockRewardAuRaMock.sol#775-777)\n\t- IRandomAuRa(validatorSet.randomContract()).onFinishCollectRound() (BlockRewardAuRaMock.sol#784)\n\t- stakingContract = IStaking(validatorSet.stakingContract()) (BlockRewardAuRaMock.sol#798)\n\t- stakingEpoch = stakingContract.stakingEpoch() (BlockRewardAuRaMock.sol#800)\n\t- rewardPointBlock = _rewardPointBlock(IStakingAuRa(address(stakingContract)),validatorSet) (BlockRewardAuRaMock.sol#801)\n\t- validatorSet.validatorSetApplyBlock() != 0 && block.number <= rewardPointBlock (BlockRewardAuRaMock.sol#803-809)\n\t- (newStakingEpochHasBegun,poolsToBeElectedLength) = validatorSet.newValidatorSet() (BlockRewardAuRaMock.sol#812)\n\t- newValidatorSet = validatorSet.getPendingValidators() (BlockRewardAuRaMock.sol#817)\n\t- stakingAddress = validatorSet.stakingByMiningAddress(newValidatorSet[i]) (BlockRewardAuRaMock.sol#820)\n\t- _setSnapshot(stakingAddress_scope_0,stakingContract,(validatorsQueueSize + 1) % DELEGATORS_ALIQUOT) (BlockRewardAuRaMock.sol#846)\n\t- (receiversNative,rewardsNative,noop) = _distributeRewards(validatorSet,stakingContract.erc20TokenContract(),stakingContract.erc20Restricted(),IStakingAuRa(address(stakingContract)),stakingEpoch,rewardPointBlock) (BlockRewardAuRaMock.sol#857-864)\n\tState variables written after the call(s):\n\t- addressStorage (BlockRewardAuRaMock.sol#871)\n\t- uintStorage (BlockRewardAuRaMock.sol#871)\n"
        },
        {
          "name": "shadowing-local",
          "vulnerability_from_line": 960,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint256 _rewardPointBlock\n",
          "message": "BlockRewardAuRa._distributeRewards._rewardPointBlock (local variable @ BlockRewardAuRaMock.sol#960) shadows:\n\t- BlockRewardAuRa._rewardPointBlock (function @ BlockRewardAuRaMock.sol#1195-1200)\n"
        },
        {
          "name": "shadowing-local",
          "vulnerability_from_line": 976,
          "vulnerability_to_line": null,
          "vulnerability_code": "            bool isRewarding = false;\n",
          "message": "BlockRewardAuRa._distributeRewards.isRewarding (local variable @ BlockRewardAuRaMock.sol#976) shadows:\n\t- BlockRewardBase.isRewarding (function @ BlockRewardAuRaMock.sol#377-379)\n\t- IBlockReward.isRewarding (function @ BlockRewardAuRaMock.sol#9)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 954,
          "vulnerability_to_line": 1138,
          "vulnerability_code": "    function _distributeRewards(\n\n        IValidatorSet _validatorSetContract,\n\n        address _erc20TokenContract,\n\n        bool _erc20Restricted,\n\n        IStakingAuRa _stakingContract,\n\n        uint256 _stakingEpoch,\n\n        uint256 _rewardPointBlock\n\n    ) internal returns(address[] memory receivers, uint256[] memory rewards, bool noop) {\n\n        uint256 i;\n\n        uint256 j;\n\n\n\n        receivers = new address[](0);\n\n        rewards = new uint256[](0);\n\n        noop = true;\n\n\n\n        if (block.number == _rewardPointBlock - 1) {\n\n            boolStorage[IS_REWARDING] = true;\n\n        } else if (block.number == _rewardPointBlock) {\n\n            address[] memory validators = _validatorSetContract.getValidators();\n\n            uint256[] memory ratio = new uint256[](validators.length);\n\n\n\n            uint256 totalReward;\n\n            bool isRewarding = false;\n\n\n\n            totalReward = uintStorage[BRIDGE_TOKEN_FEE];\n\n\n\n            if (!_erc20Restricted) {\n\n                // Accumulated bridge fee plus token inflation\n\n                uint256 inflationPercent;\n\n                if (_stakingEpoch <= 24) {\n\n                    inflationPercent = 32;\n\n                } else if (_stakingEpoch <= 48) {\n\n                    inflationPercent = 16;\n\n                } else if (_stakingEpoch <= 72) {\n\n                    inflationPercent = 8;\n\n                } else {\n\n                    inflationPercent = 4;\n\n                }\n\n                totalReward += snapshotTotalStakeAmount() * inflationPercent / 4800;\n\n            }\n\n\n\n            if (\n\n                totalReward != 0 && _erc20TokenContract != address(0) ||\n\n                uintStorage[BRIDGE_NATIVE_FEE] != 0 ||\n\n                _erc20Restricted\n\n            ) {\n\n                j = 0;\n\n                for (i = 0; i < validators.length; i++) {\n\n                    ratio[i] = uintStorage[keccak256(abi.encode(\n\n                        BLOCKS_CREATED, _stakingEpoch, validators[i]\n\n                    ))];\n\n                    j += ratio[i];\n\n                    validators[i] = _validatorSetContract.stakingByMiningAddress(validators[i]);\n\n                }\n\n                if (j != 0) {\n\n                    for (i = 0; i < validators.length; i++) {\n\n                        ratio[i] = REWARD_PERCENT_MULTIPLIER * ratio[i] / j;\n\n                    }\n\n                }\n\n            }\n\n            if (totalReward != 0) {\n\n                uintStorage[BRIDGE_TOKEN_FEE] = 0;\n\n\n\n                totalReward += uintStorage[TOKEN_REWARD_UNDISTRIBUTED];\n\n\n\n                if (_erc20TokenContract != address(0)) {\n\n                    for (i = 0; i < validators.length; i++) {\n\n                        uintStorage[keccak256(abi.encode(\n\n                            EPOCH_POOL_TOKEN_REWARD, _stakingEpoch, validators[i]\n\n                        ))] = totalReward * ratio[i] / REWARD_PERCENT_MULTIPLIER;\n\n                    }\n\n                    isRewarding = true;\n\n                }\n\n\n\n                uintStorage[TOKEN_REWARD_UNDISTRIBUTED] = totalReward;\n\n            }\n\n\n\n            totalReward = uintStorage[BRIDGE_NATIVE_FEE];\n\n\n\n            if (_erc20Restricted) {\n\n                // Accumulated bridge fee plus 2.5% per year coin inflation\n\n                totalReward += _stakingContract.stakingEpochDuration() * 1 ether;\n\n            }\n\n\n\n            if (totalReward != 0) {\n\n                uintStorage[BRIDGE_NATIVE_FEE] = 0;\n\n\n\n                totalReward += uintStorage[NATIVE_REWARD_UNDISTRIBUTED];\n\n\n\n                for (i = 0; i < validators.length; i++) {\n\n                    uintStorage[keccak256(abi.encode(\n\n                        EPOCH_POOL_NATIVE_REWARD, _stakingEpoch, validators[i]\n\n                    ))] = totalReward * ratio[i] / REWARD_PERCENT_MULTIPLIER;\n\n                }\n\n                isRewarding = true;\n\n\n\n                uintStorage[NATIVE_REWARD_UNDISTRIBUTED] = totalReward;\n\n            }\n\n\n\n            if (isRewarding) {\n\n                for (i = 0; i < validators.length; i++) {\n\n                    _enqueueValidator(validators[i]);\n\n                }\n\n                if (validators.length == 0) {\n\n                    boolStorage[IS_REWARDING] = false;\n\n                }\n\n            } else {\n\n                boolStorage[IS_REWARDING] = false;\n\n            }\n\n\n\n            noop = false;\n\n        } else if (block.number > _rewardPointBlock) {\n\n            address stakingAddress = _dequeueValidator();\n\n\n\n            if (stakingAddress == address(0)) {\n\n                return (receivers, rewards, true);\n\n            }\n\n\n\n            if (_validatorsQueueSize() == 0) {\n\n                boolStorage[IS_REWARDING] = false;\n\n            }\n\n\n\n            if (_validatorSetContract.isValidatorBanned(_validatorSetContract.miningByStakingAddress(stakingAddress))) {\n\n                return (receivers, rewards, true);\n\n            }\n\n\n\n            address[] storage stakers = addressArrayStorage[keccak256(abi.encode(SNAPSHOT_STAKERS, stakingAddress))];\n\n            uint256[] memory range = new uint256[](3); // array instead of local vars because the stack is too deep\n\n            range[0] = (_validatorsQueueSize() + 1) % DELEGATORS_ALIQUOT; // offset\n\n            range[1] = range[0] * stakers.length / DELEGATORS_ALIQUOT; // from\n\n            range[2] = (range[0] + 1) * stakers.length / DELEGATORS_ALIQUOT; // to\n\n\n\n            if (range[0] == 0) {\n\n                range[2] += stakers.length % DELEGATORS_ALIQUOT;\n\n            } else {\n\n                range[1] += stakers.length % DELEGATORS_ALIQUOT;\n\n            }\n\n\n\n            if (range[1] >= range[2]) {\n\n                return (receivers, rewards, true);\n\n            }\n\n\n\n            uint256[] storage rewardPercents = uintArrayStorage[keccak256(abi.encode(\n\n                SNAPSHOT_REWARD_PERCENTS, stakingAddress\n\n            ))];\n\n            uint256 accrued;\n\n            uint256 poolReward;\n\n\n\n            receivers = new address[](range[2] - range[1]);\n\n            rewards = new uint256[](receivers.length);\n\n\n\n            poolReward = uintStorage[keccak256(abi.encode(\n\n                EPOCH_POOL_TOKEN_REWARD, _stakingEpoch, stakingAddress\n\n            ))];\n\n            if (poolReward != 0) {\n\n                accrued = 0;\n\n                for (i = range[1]; i < range[2]; i++) {\n\n                    j = i - range[1];\n\n                    receivers[j] = stakers[i];\n\n                    rewards[j] = poolReward * rewardPercents[i] / REWARD_PERCENT_MULTIPLIER;\n\n                    accrued += rewards[j];\n\n                }\n\n                IERC20Minting(_erc20TokenContract).mintReward(receivers, rewards);\n\n                _subTokenRewardUndistributed(accrued);\n\n                noop = false;\n\n            }\n\n\n\n            poolReward = uintStorage[keccak256(abi.encode(\n\n                EPOCH_POOL_NATIVE_REWARD, _stakingEpoch, stakingAddress\n\n            ))];\n\n            if (poolReward != 0) {\n\n                accrued = 0;\n\n                for (i = range[1]; i < range[2]; i++) {\n\n                    j = i - range[1];\n\n                    receivers[j] = stakers[i];\n\n                    rewards[j] = poolReward * rewardPercents[i] / REWARD_PERCENT_MULTIPLIER;\n\n                    accrued += rewards[j];\n\n                }\n\n                _subNativeRewardUndistributed(accrued);\n\n                noop = false;\n\n            } else {\n\n                return (new address[](0), new uint256[](0), noop);\n\n            }\n\n        }\n",
          "message": "Reentrancy in BlockRewardAuRa._distributeRewards (BlockRewardAuRaMock.sol#954-1138):\n\tExternal calls:\n\t- validators = _validatorSetContract.getValidators() (BlockRewardAuRaMock.sol#972)\n\tState variables written after the call(s):\n\t- uintStorage (BlockRewardAuRaMock.sol#1015)\n\t- uintStorage (BlockRewardAuRaMock.sol#1020-1024)\n\t- uintStorage (BlockRewardAuRaMock.sol#1021-1023)\n\t- uintStorage (BlockRewardAuRaMock.sol#1028)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 954,
          "vulnerability_to_line": 1138,
          "vulnerability_code": "    function _distributeRewards(\n\n        IValidatorSet _validatorSetContract,\n\n        address _erc20TokenContract,\n\n        bool _erc20Restricted,\n\n        IStakingAuRa _stakingContract,\n\n        uint256 _stakingEpoch,\n\n        uint256 _rewardPointBlock\n\n    ) internal returns(address[] memory receivers, uint256[] memory rewards, bool noop) {\n\n        uint256 i;\n\n        uint256 j;\n\n\n\n        receivers = new address[](0);\n\n        rewards = new uint256[](0);\n\n        noop = true;\n\n\n\n        if (block.number == _rewardPointBlock - 1) {\n\n            boolStorage[IS_REWARDING] = true;\n\n        } else if (block.number == _rewardPointBlock) {\n\n            address[] memory validators = _validatorSetContract.getValidators();\n\n            uint256[] memory ratio = new uint256[](validators.length);\n\n\n\n            uint256 totalReward;\n\n            bool isRewarding = false;\n\n\n\n            totalReward = uintStorage[BRIDGE_TOKEN_FEE];\n\n\n\n            if (!_erc20Restricted) {\n\n                // Accumulated bridge fee plus token inflation\n\n                uint256 inflationPercent;\n\n                if (_stakingEpoch <= 24) {\n\n                    inflationPercent = 32;\n\n                } else if (_stakingEpoch <= 48) {\n\n                    inflationPercent = 16;\n\n                } else if (_stakingEpoch <= 72) {\n\n                    inflationPercent = 8;\n\n                } else {\n\n                    inflationPercent = 4;\n\n                }\n\n                totalReward += snapshotTotalStakeAmount() * inflationPercent / 4800;\n\n            }\n\n\n\n            if (\n\n                totalReward != 0 && _erc20TokenContract != address(0) ||\n\n                uintStorage[BRIDGE_NATIVE_FEE] != 0 ||\n\n                _erc20Restricted\n\n            ) {\n\n                j = 0;\n\n                for (i = 0; i < validators.length; i++) {\n\n                    ratio[i] = uintStorage[keccak256(abi.encode(\n\n                        BLOCKS_CREATED, _stakingEpoch, validators[i]\n\n                    ))];\n\n                    j += ratio[i];\n\n                    validators[i] = _validatorSetContract.stakingByMiningAddress(validators[i]);\n\n                }\n\n                if (j != 0) {\n\n                    for (i = 0; i < validators.length; i++) {\n\n                        ratio[i] = REWARD_PERCENT_MULTIPLIER * ratio[i] / j;\n\n                    }\n\n                }\n\n            }\n\n            if (totalReward != 0) {\n\n                uintStorage[BRIDGE_TOKEN_FEE] = 0;\n\n\n\n                totalReward += uintStorage[TOKEN_REWARD_UNDISTRIBUTED];\n\n\n\n                if (_erc20TokenContract != address(0)) {\n\n                    for (i = 0; i < validators.length; i++) {\n\n                        uintStorage[keccak256(abi.encode(\n\n                            EPOCH_POOL_TOKEN_REWARD, _stakingEpoch, validators[i]\n\n                        ))] = totalReward * ratio[i] / REWARD_PERCENT_MULTIPLIER;\n\n                    }\n\n                    isRewarding = true;\n\n                }\n\n\n\n                uintStorage[TOKEN_REWARD_UNDISTRIBUTED] = totalReward;\n\n            }\n\n\n\n            totalReward = uintStorage[BRIDGE_NATIVE_FEE];\n\n\n\n            if (_erc20Restricted) {\n\n                // Accumulated bridge fee plus 2.5% per year coin inflation\n\n                totalReward += _stakingContract.stakingEpochDuration() * 1 ether;\n\n            }\n\n\n\n            if (totalReward != 0) {\n\n                uintStorage[BRIDGE_NATIVE_FEE] = 0;\n\n\n\n                totalReward += uintStorage[NATIVE_REWARD_UNDISTRIBUTED];\n\n\n\n                for (i = 0; i < validators.length; i++) {\n\n                    uintStorage[keccak256(abi.encode(\n\n                        EPOCH_POOL_NATIVE_REWARD, _stakingEpoch, validators[i]\n\n                    ))] = totalReward * ratio[i] / REWARD_PERCENT_MULTIPLIER;\n\n                }\n\n                isRewarding = true;\n\n\n\n                uintStorage[NATIVE_REWARD_UNDISTRIBUTED] = totalReward;\n\n            }\n\n\n\n            if (isRewarding) {\n\n                for (i = 0; i < validators.length; i++) {\n\n                    _enqueueValidator(validators[i]);\n\n                }\n\n                if (validators.length == 0) {\n\n                    boolStorage[IS_REWARDING] = false;\n\n                }\n\n            } else {\n\n                boolStorage[IS_REWARDING] = false;\n\n            }\n\n\n\n            noop = false;\n\n        } else if (block.number > _rewardPointBlock) {\n\n            address stakingAddress = _dequeueValidator();\n\n\n\n            if (stakingAddress == address(0)) {\n\n                return (receivers, rewards, true);\n\n            }\n\n\n\n            if (_validatorsQueueSize() == 0) {\n\n                boolStorage[IS_REWARDING] = false;\n\n            }\n\n\n\n            if (_validatorSetContract.isValidatorBanned(_validatorSetContract.miningByStakingAddress(stakingAddress))) {\n\n                return (receivers, rewards, true);\n\n            }\n\n\n\n            address[] storage stakers = addressArrayStorage[keccak256(abi.encode(SNAPSHOT_STAKERS, stakingAddress))];\n\n            uint256[] memory range = new uint256[](3); // array instead of local vars because the stack is too deep\n\n            range[0] = (_validatorsQueueSize() + 1) % DELEGATORS_ALIQUOT; // offset\n\n            range[1] = range[0] * stakers.length / DELEGATORS_ALIQUOT; // from\n\n            range[2] = (range[0] + 1) * stakers.length / DELEGATORS_ALIQUOT; // to\n\n\n\n            if (range[0] == 0) {\n\n                range[2] += stakers.length % DELEGATORS_ALIQUOT;\n\n            } else {\n\n                range[1] += stakers.length % DELEGATORS_ALIQUOT;\n\n            }\n\n\n\n            if (range[1] >= range[2]) {\n\n                return (receivers, rewards, true);\n\n            }\n\n\n\n            uint256[] storage rewardPercents = uintArrayStorage[keccak256(abi.encode(\n\n                SNAPSHOT_REWARD_PERCENTS, stakingAddress\n\n            ))];\n\n            uint256 accrued;\n\n            uint256 poolReward;\n\n\n\n            receivers = new address[](range[2] - range[1]);\n\n            rewards = new uint256[](receivers.length);\n\n\n\n            poolReward = uintStorage[keccak256(abi.encode(\n\n                EPOCH_POOL_TOKEN_REWARD, _stakingEpoch, stakingAddress\n\n            ))];\n\n            if (poolReward != 0) {\n\n                accrued = 0;\n\n                for (i = range[1]; i < range[2]; i++) {\n\n                    j = i - range[1];\n\n                    receivers[j] = stakers[i];\n\n                    rewards[j] = poolReward * rewardPercents[i] / REWARD_PERCENT_MULTIPLIER;\n\n                    accrued += rewards[j];\n\n                }\n\n                IERC20Minting(_erc20TokenContract).mintReward(receivers, rewards);\n\n                _subTokenRewardUndistributed(accrued);\n\n                noop = false;\n\n            }\n\n\n\n            poolReward = uintStorage[keccak256(abi.encode(\n\n                EPOCH_POOL_NATIVE_REWARD, _stakingEpoch, stakingAddress\n\n            ))];\n\n            if (poolReward != 0) {\n\n                accrued = 0;\n\n                for (i = range[1]; i < range[2]; i++) {\n\n                    j = i - range[1];\n\n                    receivers[j] = stakers[i];\n\n                    rewards[j] = poolReward * rewardPercents[i] / REWARD_PERCENT_MULTIPLIER;\n\n                    accrued += rewards[j];\n\n                }\n\n                _subNativeRewardUndistributed(accrued);\n\n                noop = false;\n\n            } else {\n\n                return (new address[](0), new uint256[](0), noop);\n\n            }\n\n        }\n",
          "message": "Reentrancy in BlockRewardAuRa._distributeRewards (BlockRewardAuRaMock.sol#954-1138):\n\tExternal calls:\n\t- validators = _validatorSetContract.getValidators() (BlockRewardAuRaMock.sol#972)\n\t- totalReward += _stakingContract.stakingEpochDuration() * 1000000000000000000 (BlockRewardAuRaMock.sol#1035)\n\tState variables written after the call(s):\n\t- addressStorage (BlockRewardAuRaMock.sol#1055)\n\t- boolStorage (BlockRewardAuRaMock.sol#1058)\n\t- boolStorage (BlockRewardAuRaMock.sol#1061)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 621,
          "vulnerability_to_line": 682,
          "vulnerability_code": "    function _setSnapshot(address _stakingAddress, IStaking _stakingContract, uint256 _offset) internal {\n\n        uint256 validatorStake = _stakingContract.stakeAmountMinusOrderedWithdraw(_stakingAddress, _stakingAddress);\n\n        uint256 totalStaked = _stakingContract.stakeAmountTotalMinusOrderedWithdraw(_stakingAddress);\n\n        uint256 delegatorsAmount = totalStaked >= validatorStake ? totalStaked - validatorStake : 0;\n\n        bool validatorHasMore30Per = validatorStake * 7 > delegatorsAmount * 3;\n\n\n\n        address[] memory delegators = _stakingContract.poolDelegators(_stakingAddress);\n\n        uint256 rewardPercent;\n\n\n\n        address[] storage stakers = addressArrayStorage[keccak256(abi.encode(\n\n            SNAPSHOT_STAKERS, _stakingAddress\n\n        ))];\n\n\n\n        uint256[] storage rewardPercents = uintArrayStorage[keccak256(abi.encode(\n\n            SNAPSHOT_REWARD_PERCENTS, _stakingAddress\n\n        ))];\n\n\n\n        if (_offset == 0) {\n\n            // Calculate reward percent for validator\n\n            rewardPercent = 0;\n\n            if (validatorStake != 0 && totalStaked != 0) {\n\n                if (validatorHasMore30Per) {\n\n                    rewardPercent = REWARD_PERCENT_MULTIPLIER * validatorStake / totalStaked;\n\n                } else {\n\n                    rewardPercent = REWARD_PERCENT_MULTIPLIER * 3 / 10;\n\n                }\n\n            }\n\n            stakers.push(_stakingAddress);\n\n            rewardPercents.push(rewardPercent);\n\n            addressArrayStorage[SNAPSHOT_STAKING_ADDRESSES].push(_stakingAddress);\n\n            uintStorage[SNAPSHOT_TOTAL_STAKE_AMOUNT] += totalStaked;\n\n        }\n\n\n\n        uint256 from = _offset * delegators.length / DELEGATORS_ALIQUOT;\n\n        uint256 to = (_offset + 1) * delegators.length / DELEGATORS_ALIQUOT;\n\n\n\n        if (_offset == 0) {\n\n            to += delegators.length % DELEGATORS_ALIQUOT;\n\n        } else {\n\n            from += delegators.length % DELEGATORS_ALIQUOT;\n\n        }\n\n\n\n        // Calculate reward percent for each delegator\n\n        for (uint256 i = from; i < to; i++) {\n\n            rewardPercent = 0;\n\n\n\n            if (validatorHasMore30Per) {\n\n                if (totalStaked != 0) {\n\n                    rewardPercent = _stakingContract.stakeAmountMinusOrderedWithdraw(_stakingAddress, delegators[i]);\n\n                    rewardPercent = REWARD_PERCENT_MULTIPLIER * rewardPercent / totalStaked;\n\n                }\n\n            } else {\n\n                if (delegatorsAmount != 0) {\n\n                    rewardPercent = _stakingContract.stakeAmountMinusOrderedWithdraw(_stakingAddress, delegators[i]);\n\n                    rewardPercent = REWARD_PERCENT_MULTIPLIER * rewardPercent * 7 / (delegatorsAmount * 10);\n\n                }\n\n            }\n\n\n\n            stakers.push(delegators[i]);\n\n            rewardPercents.push(rewardPercent);\n\n        }\n",
          "message": "Reentrancy in BlockRewardBase._setSnapshot (BlockRewardAuRaMock.sol#621-682):\n\tExternal calls:\n\t- validatorStake = _stakingContract.stakeAmountMinusOrderedWithdraw(_stakingAddress,_stakingAddress) (BlockRewardAuRaMock.sol#622)\n\t- totalStaked = _stakingContract.stakeAmountTotalMinusOrderedWithdraw(_stakingAddress) (BlockRewardAuRaMock.sol#623)\n\t- delegators = _stakingContract.poolDelegators(_stakingAddress) (BlockRewardAuRaMock.sol#627)\n\tState variables written after the call(s):\n\t- addressArrayStorage (BlockRewardAuRaMock.sol#650)\n\t- uintStorage (BlockRewardAuRaMock.sol#651)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 763,
          "vulnerability_to_line": 872,
          "vulnerability_code": "    function reward(address[] calldata benefactors, uint16[] calldata kind)\n\n        external\n\n        onlySystem\n\n        returns(address[] memory receiversNative, uint256[] memory rewardsNative)\n\n    {\n\n        if (benefactors.length != kind.length || benefactors.length != 1 || kind[0] != 0) {\n\n            return (new address[](0), new uint256[](0));\n\n        }\n\n\n\n        IValidatorSet validatorSet = validatorSetContract();\n\n\n\n        // Check if the validator is existed\n\n        if (!validatorSet.isValidator(benefactors[0])) {\n\n            return (new address[](0), new uint256[](0));\n\n        }\n\n\n\n        receiversNative = new address[](0);\n\n        rewardsNative = new uint256[](0);\n\n\n\n        // Check the current validators at the end of each collection round whether\n\n        // they revealed their secrets, and remove a validator as a malicious if needed\n\n        IRandomAuRa(validatorSet.randomContract()).onFinishCollectRound();\n\n\n\n        // Initialize queues\n\n        if (!boolStorage[QUEUE_V_INITIALIZED]) {\n\n            uintStorage[QUEUE_V_FIRST] = 1;\n\n            uintStorage[QUEUE_V_LAST] = 0;\n\n            boolStorage[QUEUE_V_INITIALIZED] = true;\n\n        }\n\n        if (!boolStorage[QUEUE_ER_INITIALIZED]) {\n\n            uintStorage[QUEUE_ER_FIRST] = 1;\n\n            uintStorage[QUEUE_ER_LAST] = 0;\n\n            boolStorage[QUEUE_ER_INITIALIZED] = true;\n\n        }\n\n\n\n        IStaking stakingContract = IStaking(validatorSet.stakingContract());\n\n        uint256 bridgeQueueLimit = 100;\n\n        uint256 stakingEpoch = stakingContract.stakingEpoch();\n\n        uint256 rewardPointBlock = _rewardPointBlock(IStakingAuRa(address(stakingContract)), validatorSet);\n\n\n\n        if (validatorSet.validatorSetApplyBlock() != 0 && block.number <= rewardPointBlock) {\n\n            if (stakingEpoch != 0) {\n\n                // Accumulate blocks producing statistics for each of the\n\n                // active validators during the current staking epoch\n\n                uintStorage[keccak256(abi.encode(BLOCKS_CREATED, stakingEpoch, benefactors[0]))]++;\n\n            }\n\n        }\n\n\n\n        // Start a new staking epoch every `stakingEpochDuration()` blocks\n\n        (bool newStakingEpochHasBegun, uint256 poolsToBeElectedLength) = validatorSet.newValidatorSet();\n\n\n\n        if (newStakingEpochHasBegun) {\n\n            // A new staking epoch has begun, so prepare for reward coefficients snapshotting\n\n            // process which begins right from the following block\n\n            address[] memory newValidatorSet = validatorSet.getPendingValidators();\n\n\n\n            for (uint256 i = 0; i < newValidatorSet.length; i++) {\n\n                address stakingAddress = validatorSet.stakingByMiningAddress(newValidatorSet[i]);\n\n\n\n                _enqueueValidator(stakingAddress);\n\n\n\n                delete addressArrayStorage[keccak256(abi.encode(SNAPSHOT_STAKERS, stakingAddress))];\n\n                delete uintArrayStorage[keccak256(abi.encode(SNAPSHOT_REWARD_PERCENTS, stakingAddress))];\n\n            }\n\n\n\n            delete addressArrayStorage[SNAPSHOT_STAKING_ADDRESSES];\n\n            uintStorage[SNAPSHOT_TOTAL_STAKE_AMOUNT] = 0;\n\n            boolStorage[IS_SNAPSHOTTING] = (newValidatorSet.length != 0);\n\n\n\n            if (poolsToBeElectedLength > 2000) {\n\n                bridgeQueueLimit = 0;\n\n            } else if (poolsToBeElectedLength > 1000) {\n\n                bridgeQueueLimit = 30;\n\n            } else {\n\n                bridgeQueueLimit = 50;\n\n            }\n\n        } else if (boolStorage[IS_SNAPSHOTTING]) {\n\n            // Snapshot reward coefficients for each new validator and their delegators\n\n            // during the very first blocks of a new staking epoch\n\n            address stakingAddress = _dequeueValidator();\n\n\n\n            if (stakingAddress != address(0)) {\n\n                uint256 validatorsQueueSize = _validatorsQueueSize();\n\n                _setSnapshot(stakingAddress, stakingContract, (validatorsQueueSize + 1) % DELEGATORS_ALIQUOT);\n\n                if (validatorsQueueSize == 0) {\n\n                    // Snapshotting process has been finished\n\n                    boolStorage[IS_SNAPSHOTTING] = false;\n\n                }\n\n                bridgeQueueLimit = 50;\n\n            }\n\n        } else if (stakingEpoch != 0) {\n\n            // Distribute rewards at the end of staking epoch during the last\n\n            // MAX_VALIDATORS * DELEGATORS_ALIQUOT blocks\n\n            bool noop;\n\n            (receiversNative, rewardsNative, noop) = _distributeRewards(\n\n                validatorSet,\n\n                stakingContract.erc20TokenContract(),\n\n                stakingContract.erc20Restricted(),\n\n                IStakingAuRa(address(stakingContract)),\n\n                stakingEpoch,\n\n                rewardPointBlock\n\n            );\n\n            if (!noop) {\n\n                bridgeQueueLimit = 50;\n\n            }\n\n        }\n\n\n\n        // Mint native coins if needed\n\n        return _mintNativeCoins(receiversNative, rewardsNative, bridgeQueueLimit);\n",
          "message": "Reentrancy in BlockRewardAuRa.reward (BlockRewardAuRaMock.sol#763-872):\n\tExternal calls:\n\t- ! validatorSet.isValidator(benefactors[0]) (BlockRewardAuRaMock.sol#775-777)\n\t- IRandomAuRa(validatorSet.randomContract()).onFinishCollectRound() (BlockRewardAuRaMock.sol#784)\n\tState variables written after the call(s):\n\t- boolStorage (BlockRewardAuRaMock.sol#790)\n\t- boolStorage (BlockRewardAuRaMock.sol#795)\n\t- uintStorage (BlockRewardAuRaMock.sol#788)\n\t- uintStorage (BlockRewardAuRaMock.sol#789)\n\t- uintStorage (BlockRewardAuRaMock.sol#793)\n\t- uintStorage (BlockRewardAuRaMock.sol#794)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 763,
          "vulnerability_to_line": 872,
          "vulnerability_code": "    function reward(address[] calldata benefactors, uint16[] calldata kind)\n\n        external\n\n        onlySystem\n\n        returns(address[] memory receiversNative, uint256[] memory rewardsNative)\n\n    {\n\n        if (benefactors.length != kind.length || benefactors.length != 1 || kind[0] != 0) {\n\n            return (new address[](0), new uint256[](0));\n\n        }\n\n\n\n        IValidatorSet validatorSet = validatorSetContract();\n\n\n\n        // Check if the validator is existed\n\n        if (!validatorSet.isValidator(benefactors[0])) {\n\n            return (new address[](0), new uint256[](0));\n\n        }\n\n\n\n        receiversNative = new address[](0);\n\n        rewardsNative = new uint256[](0);\n\n\n\n        // Check the current validators at the end of each collection round whether\n\n        // they revealed their secrets, and remove a validator as a malicious if needed\n\n        IRandomAuRa(validatorSet.randomContract()).onFinishCollectRound();\n\n\n\n        // Initialize queues\n\n        if (!boolStorage[QUEUE_V_INITIALIZED]) {\n\n            uintStorage[QUEUE_V_FIRST] = 1;\n\n            uintStorage[QUEUE_V_LAST] = 0;\n\n            boolStorage[QUEUE_V_INITIALIZED] = true;\n\n        }\n\n        if (!boolStorage[QUEUE_ER_INITIALIZED]) {\n\n            uintStorage[QUEUE_ER_FIRST] = 1;\n\n            uintStorage[QUEUE_ER_LAST] = 0;\n\n            boolStorage[QUEUE_ER_INITIALIZED] = true;\n\n        }\n\n\n\n        IStaking stakingContract = IStaking(validatorSet.stakingContract());\n\n        uint256 bridgeQueueLimit = 100;\n\n        uint256 stakingEpoch = stakingContract.stakingEpoch();\n\n        uint256 rewardPointBlock = _rewardPointBlock(IStakingAuRa(address(stakingContract)), validatorSet);\n\n\n\n        if (validatorSet.validatorSetApplyBlock() != 0 && block.number <= rewardPointBlock) {\n\n            if (stakingEpoch != 0) {\n\n                // Accumulate blocks producing statistics for each of the\n\n                // active validators during the current staking epoch\n\n                uintStorage[keccak256(abi.encode(BLOCKS_CREATED, stakingEpoch, benefactors[0]))]++;\n\n            }\n\n        }\n\n\n\n        // Start a new staking epoch every `stakingEpochDuration()` blocks\n\n        (bool newStakingEpochHasBegun, uint256 poolsToBeElectedLength) = validatorSet.newValidatorSet();\n\n\n\n        if (newStakingEpochHasBegun) {\n\n            // A new staking epoch has begun, so prepare for reward coefficients snapshotting\n\n            // process which begins right from the following block\n\n            address[] memory newValidatorSet = validatorSet.getPendingValidators();\n\n\n\n            for (uint256 i = 0; i < newValidatorSet.length; i++) {\n\n                address stakingAddress = validatorSet.stakingByMiningAddress(newValidatorSet[i]);\n\n\n\n                _enqueueValidator(stakingAddress);\n\n\n\n                delete addressArrayStorage[keccak256(abi.encode(SNAPSHOT_STAKERS, stakingAddress))];\n\n                delete uintArrayStorage[keccak256(abi.encode(SNAPSHOT_REWARD_PERCENTS, stakingAddress))];\n\n            }\n\n\n\n            delete addressArrayStorage[SNAPSHOT_STAKING_ADDRESSES];\n\n            uintStorage[SNAPSHOT_TOTAL_STAKE_AMOUNT] = 0;\n\n            boolStorage[IS_SNAPSHOTTING] = (newValidatorSet.length != 0);\n\n\n\n            if (poolsToBeElectedLength > 2000) {\n\n                bridgeQueueLimit = 0;\n\n            } else if (poolsToBeElectedLength > 1000) {\n\n                bridgeQueueLimit = 30;\n\n            } else {\n\n                bridgeQueueLimit = 50;\n\n            }\n\n        } else if (boolStorage[IS_SNAPSHOTTING]) {\n\n            // Snapshot reward coefficients for each new validator and their delegators\n\n            // during the very first blocks of a new staking epoch\n\n            address stakingAddress = _dequeueValidator();\n\n\n\n            if (stakingAddress != address(0)) {\n\n                uint256 validatorsQueueSize = _validatorsQueueSize();\n\n                _setSnapshot(stakingAddress, stakingContract, (validatorsQueueSize + 1) % DELEGATORS_ALIQUOT);\n\n                if (validatorsQueueSize == 0) {\n\n                    // Snapshotting process has been finished\n\n                    boolStorage[IS_SNAPSHOTTING] = false;\n\n                }\n\n                bridgeQueueLimit = 50;\n\n            }\n\n        } else if (stakingEpoch != 0) {\n\n            // Distribute rewards at the end of staking epoch during the last\n\n            // MAX_VALIDATORS * DELEGATORS_ALIQUOT blocks\n\n            bool noop;\n\n            (receiversNative, rewardsNative, noop) = _distributeRewards(\n\n                validatorSet,\n\n                stakingContract.erc20TokenContract(),\n\n                stakingContract.erc20Restricted(),\n\n                IStakingAuRa(address(stakingContract)),\n\n                stakingEpoch,\n\n                rewardPointBlock\n\n            );\n\n            if (!noop) {\n\n                bridgeQueueLimit = 50;\n\n            }\n\n        }\n\n\n\n        // Mint native coins if needed\n\n        return _mintNativeCoins(receiversNative, rewardsNative, bridgeQueueLimit);\n",
          "message": "Reentrancy in BlockRewardAuRa.reward (BlockRewardAuRaMock.sol#763-872):\n\tExternal calls:\n\t- ! validatorSet.isValidator(benefactors[0]) (BlockRewardAuRaMock.sol#775-777)\n\t- IRandomAuRa(validatorSet.randomContract()).onFinishCollectRound() (BlockRewardAuRaMock.sol#784)\n\t- stakingContract = IStaking(validatorSet.stakingContract()) (BlockRewardAuRaMock.sol#798)\n\t- stakingEpoch = stakingContract.stakingEpoch() (BlockRewardAuRaMock.sol#800)\n\t- rewardPointBlock = _rewardPointBlock(IStakingAuRa(address(stakingContract)),validatorSet) (BlockRewardAuRaMock.sol#801)\n\t- validatorSet.validatorSetApplyBlock() != 0 && block.number <= rewardPointBlock (BlockRewardAuRaMock.sol#803-809)\n\tState variables written after the call(s):\n\t- uintStorage (BlockRewardAuRaMock.sol#807)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 763,
          "vulnerability_to_line": 872,
          "vulnerability_code": "    function reward(address[] calldata benefactors, uint16[] calldata kind)\n\n        external\n\n        onlySystem\n\n        returns(address[] memory receiversNative, uint256[] memory rewardsNative)\n\n    {\n\n        if (benefactors.length != kind.length || benefactors.length != 1 || kind[0] != 0) {\n\n            return (new address[](0), new uint256[](0));\n\n        }\n\n\n\n        IValidatorSet validatorSet = validatorSetContract();\n\n\n\n        // Check if the validator is existed\n\n        if (!validatorSet.isValidator(benefactors[0])) {\n\n            return (new address[](0), new uint256[](0));\n\n        }\n\n\n\n        receiversNative = new address[](0);\n\n        rewardsNative = new uint256[](0);\n\n\n\n        // Check the current validators at the end of each collection round whether\n\n        // they revealed their secrets, and remove a validator as a malicious if needed\n\n        IRandomAuRa(validatorSet.randomContract()).onFinishCollectRound();\n\n\n\n        // Initialize queues\n\n        if (!boolStorage[QUEUE_V_INITIALIZED]) {\n\n            uintStorage[QUEUE_V_FIRST] = 1;\n\n            uintStorage[QUEUE_V_LAST] = 0;\n\n            boolStorage[QUEUE_V_INITIALIZED] = true;\n\n        }\n\n        if (!boolStorage[QUEUE_ER_INITIALIZED]) {\n\n            uintStorage[QUEUE_ER_FIRST] = 1;\n\n            uintStorage[QUEUE_ER_LAST] = 0;\n\n            boolStorage[QUEUE_ER_INITIALIZED] = true;\n\n        }\n\n\n\n        IStaking stakingContract = IStaking(validatorSet.stakingContract());\n\n        uint256 bridgeQueueLimit = 100;\n\n        uint256 stakingEpoch = stakingContract.stakingEpoch();\n\n        uint256 rewardPointBlock = _rewardPointBlock(IStakingAuRa(address(stakingContract)), validatorSet);\n\n\n\n        if (validatorSet.validatorSetApplyBlock() != 0 && block.number <= rewardPointBlock) {\n\n            if (stakingEpoch != 0) {\n\n                // Accumulate blocks producing statistics for each of the\n\n                // active validators during the current staking epoch\n\n                uintStorage[keccak256(abi.encode(BLOCKS_CREATED, stakingEpoch, benefactors[0]))]++;\n\n            }\n\n        }\n\n\n\n        // Start a new staking epoch every `stakingEpochDuration()` blocks\n\n        (bool newStakingEpochHasBegun, uint256 poolsToBeElectedLength) = validatorSet.newValidatorSet();\n\n\n\n        if (newStakingEpochHasBegun) {\n\n            // A new staking epoch has begun, so prepare for reward coefficients snapshotting\n\n            // process which begins right from the following block\n\n            address[] memory newValidatorSet = validatorSet.getPendingValidators();\n\n\n\n            for (uint256 i = 0; i < newValidatorSet.length; i++) {\n\n                address stakingAddress = validatorSet.stakingByMiningAddress(newValidatorSet[i]);\n\n\n\n                _enqueueValidator(stakingAddress);\n\n\n\n                delete addressArrayStorage[keccak256(abi.encode(SNAPSHOT_STAKERS, stakingAddress))];\n\n                delete uintArrayStorage[keccak256(abi.encode(SNAPSHOT_REWARD_PERCENTS, stakingAddress))];\n\n            }\n\n\n\n            delete addressArrayStorage[SNAPSHOT_STAKING_ADDRESSES];\n\n            uintStorage[SNAPSHOT_TOTAL_STAKE_AMOUNT] = 0;\n\n            boolStorage[IS_SNAPSHOTTING] = (newValidatorSet.length != 0);\n\n\n\n            if (poolsToBeElectedLength > 2000) {\n\n                bridgeQueueLimit = 0;\n\n            } else if (poolsToBeElectedLength > 1000) {\n\n                bridgeQueueLimit = 30;\n\n            } else {\n\n                bridgeQueueLimit = 50;\n\n            }\n\n        } else if (boolStorage[IS_SNAPSHOTTING]) {\n\n            // Snapshot reward coefficients for each new validator and their delegators\n\n            // during the very first blocks of a new staking epoch\n\n            address stakingAddress = _dequeueValidator();\n\n\n\n            if (stakingAddress != address(0)) {\n\n                uint256 validatorsQueueSize = _validatorsQueueSize();\n\n                _setSnapshot(stakingAddress, stakingContract, (validatorsQueueSize + 1) % DELEGATORS_ALIQUOT);\n\n                if (validatorsQueueSize == 0) {\n\n                    // Snapshotting process has been finished\n\n                    boolStorage[IS_SNAPSHOTTING] = false;\n\n                }\n\n                bridgeQueueLimit = 50;\n\n            }\n\n        } else if (stakingEpoch != 0) {\n\n            // Distribute rewards at the end of staking epoch during the last\n\n            // MAX_VALIDATORS * DELEGATORS_ALIQUOT blocks\n\n            bool noop;\n\n            (receiversNative, rewardsNative, noop) = _distributeRewards(\n\n                validatorSet,\n\n                stakingContract.erc20TokenContract(),\n\n                stakingContract.erc20Restricted(),\n\n                IStakingAuRa(address(stakingContract)),\n\n                stakingEpoch,\n\n                rewardPointBlock\n\n            );\n\n            if (!noop) {\n\n                bridgeQueueLimit = 50;\n\n            }\n\n        }\n\n\n\n        // Mint native coins if needed\n\n        return _mintNativeCoins(receiversNative, rewardsNative, bridgeQueueLimit);\n",
          "message": "Reentrancy in BlockRewardAuRa.reward (BlockRewardAuRaMock.sol#763-872):\n\tExternal calls:\n\t- ! validatorSet.isValidator(benefactors[0]) (BlockRewardAuRaMock.sol#775-777)\n\t- IRandomAuRa(validatorSet.randomContract()).onFinishCollectRound() (BlockRewardAuRaMock.sol#784)\n\t- stakingContract = IStaking(validatorSet.stakingContract()) (BlockRewardAuRaMock.sol#798)\n\t- stakingEpoch = stakingContract.stakingEpoch() (BlockRewardAuRaMock.sol#800)\n\t- rewardPointBlock = _rewardPointBlock(IStakingAuRa(address(stakingContract)),validatorSet) (BlockRewardAuRaMock.sol#801)\n\t- validatorSet.validatorSetApplyBlock() != 0 && block.number <= rewardPointBlock (BlockRewardAuRaMock.sol#803-809)\n\t- (newStakingEpochHasBegun,poolsToBeElectedLength) = validatorSet.newValidatorSet() (BlockRewardAuRaMock.sol#812)\n\t- newValidatorSet = validatorSet.getPendingValidators() (BlockRewardAuRaMock.sol#817)\n\t- stakingAddress = validatorSet.stakingByMiningAddress(newValidatorSet[i]) (BlockRewardAuRaMock.sol#820)\n\tState variables written after the call(s):\n\t- addressArrayStorage (BlockRewardAuRaMock.sol#828)\n"
        },
        {
          "name": "constable-states",
          "vulnerability_from_line": 80,
          "vulnerability_to_line": null,
          "vulnerability_code": "    address internal _owner;\n",
          "message": "EternalStorage._owner should be constant (BlockRewardAuRaMock.sol#80)\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 9,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function isRewarding() external view returns(bool);\n",
          "message": "IBlockReward.isRewarding (BlockRewardAuRaMock.sol#9) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 377,
          "vulnerability_to_line": 379,
          "vulnerability_code": "    function isRewarding() public view returns(bool) {\n\n        return boolStorage[IS_REWARDING];\n",
          "message": "BlockRewardBase.isRewarding (BlockRewardAuRaMock.sol#377-379) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 383,
          "vulnerability_to_line": 385,
          "vulnerability_code": "    function isSnapshotting() public view returns(bool) {\n\n        return boolStorage[IS_SNAPSHOTTING];\n",
          "message": "BlockRewardBase.isSnapshotting (BlockRewardAuRaMock.sol#383-385) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 10,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function isSnapshotting() external view returns(bool);\n",
          "message": "IBlockReward.isSnapshotting (BlockRewardAuRaMock.sol#10) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 12,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function mintedTotallyByBridge(address _bridge) external view returns(uint256);\n",
          "message": "IBlockReward.mintedTotallyByBridge (BlockRewardAuRaMock.sol#12) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 418,
          "vulnerability_to_line": 420,
          "vulnerability_code": "    function mintedTotallyByBridge(address _bridge) public view returns(uint256) {\n\n        return uintStorage[keccak256(abi.encode(MINTED_TOTALLY_BY_BRIDGE, _bridge))];\n",
          "message": "BlockRewardBase.mintedTotallyByBridge (BlockRewardAuRaMock.sol#418-420) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 339,
          "vulnerability_to_line": 341,
          "vulnerability_code": "    function blockRewardContractId() public pure returns(bytes4) {\n\n        return BLOCK_REWARD_CONTRACT_ID;\n",
          "message": "BlockRewardBase.blockRewardContractId (BlockRewardAuRaMock.sol#339-341) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 344,
          "vulnerability_to_line": 346,
          "vulnerability_code": "    function ercToErcBridgesAllowed() public view returns(address[] memory) {\n\n        return addressArrayStorage[ERC_TO_ERC_BRIDGES_ALLOWED];\n",
          "message": "BlockRewardBase.ercToErcBridgesAllowed (BlockRewardAuRaMock.sol#344-346) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 349,
          "vulnerability_to_line": 351,
          "vulnerability_code": "    function ercToNativeBridgesAllowed() public view returns(address[] memory) {\n\n        return addressArrayStorage[ERC_TO_NATIVE_BRIDGES_ALLOWED];\n",
          "message": "BlockRewardBase.ercToNativeBridgesAllowed (BlockRewardAuRaMock.sol#349-351) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 360,
          "vulnerability_to_line": 362,
          "vulnerability_code": "    function getBridgeNativeFee() public view returns(uint256) {\n\n        return uintStorage[BRIDGE_NATIVE_FEE];\n",
          "message": "BlockRewardBase.getBridgeNativeFee (BlockRewardAuRaMock.sol#360-362) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 366,
          "vulnerability_to_line": 368,
          "vulnerability_code": "    function getBridgeTokenFee() public view returns(uint256) {\n\n        return uintStorage[BRIDGE_TOKEN_FEE];\n",
          "message": "BlockRewardBase.getBridgeTokenFee (BlockRewardAuRaMock.sol#366-368) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 390,
          "vulnerability_to_line": 392,
          "vulnerability_code": "    function mintedForAccount(address _account) public view returns(uint256) {\n\n        return uintStorage[keccak256(abi.encode(MINTED_FOR_ACCOUNT, _account))];\n",
          "message": "BlockRewardBase.mintedForAccount (BlockRewardAuRaMock.sol#390-392) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 398,
          "vulnerability_to_line": 406,
          "vulnerability_code": "    function mintedForAccountInBlock(address _account, uint256 _blockNumber)\n\n        public\n\n        view\n\n        returns(uint256)\n\n    {\n\n        return uintStorage[\n\n            keccak256(abi.encode(MINTED_FOR_ACCOUNT_IN_BLOCK, _account, _blockNumber))\n\n        ];\n",
          "message": "BlockRewardBase.mintedForAccountInBlock (BlockRewardAuRaMock.sol#398-406) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 411,
          "vulnerability_to_line": 413,
          "vulnerability_code": "    function mintedInBlock(uint256 _blockNumber) public view returns(uint256) {\n\n        return uintStorage[keccak256(abi.encode(MINTED_IN_BLOCK, _blockNumber))];\n",
          "message": "BlockRewardBase.mintedInBlock (BlockRewardAuRaMock.sol#411-413) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 430,
          "vulnerability_to_line": 432,
          "vulnerability_code": "    function nativeToErcBridgesAllowed() public view returns(address[] memory) {\n\n        return addressArrayStorage[NATIVE_TO_ERC_BRIDGES_ALLOWED];\n",
          "message": "BlockRewardBase.nativeToErcBridgesAllowed (BlockRewardAuRaMock.sol#430-432) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 441,
          "vulnerability_to_line": 445,
          "vulnerability_code": "    function snapshotRewardPercents(address _validatorStakingAddress) public view returns(uint256[] memory) {\n\n        return uintArrayStorage[\n\n            keccak256(abi.encode(SNAPSHOT_REWARD_PERCENTS, _validatorStakingAddress))\n\n        ];\n",
          "message": "BlockRewardBase.snapshotRewardPercents (BlockRewardAuRaMock.sol#441-445) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 452,
          "vulnerability_to_line": 456,
          "vulnerability_code": "    function snapshotStakers(address _validatorStakingAddress) public view returns(address[] memory) {\n\n        return addressArrayStorage[\n\n            keccak256(abi.encode(SNAPSHOT_STAKERS, _validatorStakingAddress))\n\n        ];\n",
          "message": "BlockRewardBase.snapshotStakers (BlockRewardAuRaMock.sol#452-456) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 461,
          "vulnerability_to_line": 463,
          "vulnerability_code": "    function snapshotStakingAddresses() public view returns(address[] memory) {\n\n        return addressArrayStorage[SNAPSHOT_STAKING_ADDRESSES];\n",
          "message": "BlockRewardBase.snapshotStakingAddresses (BlockRewardAuRaMock.sol#461-463) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 882,
          "vulnerability_to_line": 887,
          "vulnerability_code": "    function getBlocksCreated(\n\n        uint256 _stakingEpoch,\n\n        address _validatorMiningAddress\n\n    ) public view returns(uint256) {\n\n        return uintStorage[keccak256(abi.encode(BLOCKS_CREATED, _stakingEpoch, _validatorMiningAddress))];\n",
          "message": "BlockRewardAuRa.getBlocksCreated (BlockRewardAuRaMock.sol#882-887) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 893,
          "vulnerability_to_line": 900,
          "vulnerability_code": "    function getEpochPoolNativeReward(\n\n        uint256 _stakingEpoch,\n\n        address _poolStakingAddress\n\n    ) public view returns(uint256) {\n\n        return uintStorage[keccak256(abi.encode(\n\n            EPOCH_POOL_NATIVE_REWARD, _stakingEpoch, _poolStakingAddress\n\n        ))];\n",
          "message": "BlockRewardAuRa.getEpochPoolNativeReward (BlockRewardAuRaMock.sol#893-900) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 906,
          "vulnerability_to_line": 913,
          "vulnerability_code": "    function getEpochPoolTokenReward(\n\n        uint256 _stakingEpoch,\n\n        address _poolStakingAddress\n\n    ) public view returns(uint256) {\n\n        return uintStorage[keccak256(abi.encode(\n\n            EPOCH_POOL_TOKEN_REWARD, _stakingEpoch, _poolStakingAddress\n\n        ))];\n",
          "message": "BlockRewardAuRa.getEpochPoolTokenReward (BlockRewardAuRaMock.sol#906-913) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 916,
          "vulnerability_to_line": 918,
          "vulnerability_code": "    function getNativeRewardUndistributed() public view returns(uint256) {\n\n        return uintStorage[NATIVE_REWARD_UNDISTRIBUTED];\n",
          "message": "BlockRewardAuRa.getNativeRewardUndistributed (BlockRewardAuRaMock.sol#916-918) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 921,
          "vulnerability_to_line": 923,
          "vulnerability_code": "    function getTokenRewardUndistributed() public view returns(uint256) {\n\n        return uintStorage[TOKEN_REWARD_UNDISTRIBUTED];\n",
          "message": "BlockRewardAuRa.getTokenRewardUndistributed (BlockRewardAuRaMock.sol#921-923) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 1217,
          "vulnerability_to_line": 1219,
          "vulnerability_code": "    function setIsSnapshotting(bool _isSnapshotting) public {\n\n        boolStorage[IS_SNAPSHOTTING] = _isSnapshotting;\n",
          "message": "BlockRewardAuRaMock.setIsSnapshotting (BlockRewardAuRaMock.sol#1217-1219) should be declared external\n"
        },
        {
          "name": "solc-version",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity 0.5.9;\n",
          "message": "Detected issues with version pragma in BlockRewardAuRaMock.sol:\n\t- pragma solidity0.5.9 (BlockRewardAuRaMock.sol#3): it allows old versions\n\t- pragma solidity0.5.9 (BlockRewardAuRaMock.sol#17): it allows old versions\n\t- pragma solidity0.5.9 (BlockRewardAuRaMock.sol#52): it allows old versions\n\t- pragma solidity0.5.9 (BlockRewardAuRaMock.sol#72): it allows old versions\n\t- pragma solidity0.5.9 (BlockRewardAuRaMock.sol#103): it allows old versions\n\t- pragma solidity0.5.9 (BlockRewardAuRaMock.sol#121): it allows old versions\n\t- pragma solidity0.5.9 (BlockRewardAuRaMock.sol#160): it allows old versions\n\t- pragma solidity0.5.9 (BlockRewardAuRaMock.sol#687): it allows old versions\n\t- pragma solidity0.5.9 (BlockRewardAuRaMock.sol#704): it allows old versions\n\t- pragma solidity0.5.9 (BlockRewardAuRaMock.sol#716): it allows old versions\n\t- pragma solidity0.5.9 (BlockRewardAuRaMock.sol#738): it allows old versions\n\t- pragma solidity0.5.9 (BlockRewardAuRaMock.sol#748): it allows old versions\n\t- pragma solidity0.5.9 (BlockRewardAuRaMock.sol#1213): it allows old versions\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 7,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function initialize(address) external;\n",
          "message": "Parameter '' of IBlockReward.initialize (BlockRewardAuRaMock.sol#7) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 8,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function DELEGATORS_ALIQUOT() external view returns(uint256); // solhint-disable-line func-name-mixedcase\n",
          "message": "Function 'IBlockReward.DELEGATORS_ALIQUOT' (BlockRewardAuRaMock.sol#8) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 22,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address,\n",
          "message": "Parameter '' of IValidatorSet.initialize (BlockRewardAuRaMock.sol#22) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 23,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address,\n",
          "message": "Parameter '_scope_0' of IValidatorSet.initialize (BlockRewardAuRaMock.sol#23) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 24,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address,\n",
          "message": "Parameter '_scope_1' of IValidatorSet.initialize (BlockRewardAuRaMock.sol#24) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 25,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address[] calldata,\n",
          "message": "Parameter '_scope_2' of IValidatorSet.initialize (BlockRewardAuRaMock.sol#25) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 26,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address[] calldata,\n",
          "message": "Parameter '_scope_3' of IValidatorSet.initialize (BlockRewardAuRaMock.sol#26) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 27,
          "vulnerability_to_line": null,
          "vulnerability_code": "        bool\n",
          "message": "Parameter '_scope_4' of IValidatorSet.initialize (BlockRewardAuRaMock.sol#27) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 30,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setStakingAddress(address, address) external;\n",
          "message": "Parameter '' of IValidatorSet.setStakingAddress (BlockRewardAuRaMock.sol#30) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 30,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setStakingAddress(address, address) external;\n",
          "message": "Parameter '_scope_0' of IValidatorSet.setStakingAddress (BlockRewardAuRaMock.sol#30) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 37,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function isReportValidatorValid(address) external view returns(bool);\n",
          "message": "Parameter '' of IValidatorSet.isReportValidatorValid (BlockRewardAuRaMock.sol#37) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 38,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function isValidator(address) external view returns(bool);\n",
          "message": "Parameter '' of IValidatorSet.isValidator (BlockRewardAuRaMock.sol#38) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 39,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function isValidatorBanned(address) external view returns(bool);\n",
          "message": "Parameter '' of IValidatorSet.isValidatorBanned (BlockRewardAuRaMock.sol#39) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 40,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function MAX_VALIDATORS() external view returns(uint256); // solhint-disable-line func-name-mixedcase\n",
          "message": "Function 'IValidatorSet.MAX_VALIDATORS' (BlockRewardAuRaMock.sol#40) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 41,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function miningByStakingAddress(address) external view returns(address);\n",
          "message": "Parameter '' of IValidatorSet.miningByStakingAddress (BlockRewardAuRaMock.sol#41) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 43,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function stakingByMiningAddress(address) external view returns(address);\n",
          "message": "Parameter '' of IValidatorSet.stakingByMiningAddress (BlockRewardAuRaMock.sol#43) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 46,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function validatorIndex(address) external view returns(uint256);\n",
          "message": "Parameter '' of IValidatorSet.validatorIndex (BlockRewardAuRaMock.sol#46) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 56,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function clearUnremovableValidator(address) external;\n",
          "message": "Parameter '' of IStaking.clearUnremovableValidator (BlockRewardAuRaMock.sol#56) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 58,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function removePool(address) external;\n",
          "message": "Parameter '' of IStaking.removePool (BlockRewardAuRaMock.sol#58) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 64,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function poolDelegators(address) external view returns(address[] memory);\n",
          "message": "Parameter '' of IStaking.poolDelegators (BlockRewardAuRaMock.sol#64) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 65,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function stakeAmountMinusOrderedWithdraw(address, address) external view returns(uint256);\n",
          "message": "Parameter '' of IStaking.stakeAmountMinusOrderedWithdraw (BlockRewardAuRaMock.sol#65) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 65,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function stakeAmountMinusOrderedWithdraw(address, address) external view returns(uint256);\n",
          "message": "Parameter '_scope_0' of IStaking.stakeAmountMinusOrderedWithdraw (BlockRewardAuRaMock.sol#65) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 66,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function stakeAmountTotalMinusOrderedWithdraw(address) external view returns(uint256);\n",
          "message": "Parameter '' of IStaking.stakeAmountTotalMinusOrderedWithdraw (BlockRewardAuRaMock.sol#66) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 80,
          "vulnerability_to_line": null,
          "vulnerability_code": "    address internal _owner;\n",
          "message": "Variable 'EternalStorage._owner' (BlockRewardAuRaMock.sol#80) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 260,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function initialize(address _validatorSet) external {\n",
          "message": "Parameter '_validatorSet' of BlockRewardBase.initialize (BlockRewardAuRaMock.sol#260) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 418,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function mintedTotallyByBridge(address _bridge) public view returns(uint256) {\n",
          "message": "Parameter '_bridge' of BlockRewardBase.mintedTotallyByBridge (BlockRewardAuRaMock.sol#418) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 231,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function addBridgeNativeFeeReceivers(uint256 _amount) external onlyErcToNativeBridge {\n",
          "message": "Parameter '_amount' of BlockRewardBase.addBridgeNativeFeeReceivers (BlockRewardAuRaMock.sol#231) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 240,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function addBridgeTokenFeeReceivers(uint256 _amount) external onlyXToErcBridge {\n",
          "message": "Parameter '_amount' of BlockRewardBase.addBridgeTokenFeeReceivers (BlockRewardAuRaMock.sol#240) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 249,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function addExtraReceiver(uint256 _amount, address _receiver) external onlyErcToNativeBridge {\n",
          "message": "Parameter '_amount' of BlockRewardBase.addExtraReceiver (BlockRewardAuRaMock.sol#249) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 249,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function addExtraReceiver(uint256 _amount, address _receiver) external onlyErcToNativeBridge {\n",
          "message": "Parameter '_receiver' of BlockRewardBase.addExtraReceiver (BlockRewardAuRaMock.sol#249) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 271,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function migrateMintingStatistics(address _bridge, IBlockReward _prevBlockRewardContract) external onlyOwner {\n",
          "message": "Parameter '_bridge' of BlockRewardBase.migrateMintingStatistics (BlockRewardAuRaMock.sol#271) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 271,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function migrateMintingStatistics(address _bridge, IBlockReward _prevBlockRewardContract) external onlyOwner {\n",
          "message": "Parameter '_prevBlockRewardContract' of BlockRewardBase.migrateMintingStatistics (BlockRewardAuRaMock.sol#271) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 284,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setErcToNativeBridgesAllowed(address[] calldata _bridgesAllowed) external onlyOwner onlyInitialized {\n",
          "message": "Parameter '_bridgesAllowed' of BlockRewardBase.setErcToNativeBridgesAllowed (BlockRewardAuRaMock.sol#284) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 302,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setNativeToErcBridgesAllowed(address[] calldata _bridgesAllowed) external onlyOwner onlyInitialized {\n",
          "message": "Parameter '_bridgesAllowed' of BlockRewardBase.setNativeToErcBridgesAllowed (BlockRewardAuRaMock.sol#302) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 320,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setErcToErcBridgesAllowed(address[] calldata _bridgesAllowed) external onlyOwner onlyInitialized {\n",
          "message": "Parameter '_bridgesAllowed' of BlockRewardBase.setErcToErcBridgesAllowed (BlockRewardAuRaMock.sol#320) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 390,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function mintedForAccount(address _account) public view returns(uint256) {\n",
          "message": "Parameter '_account' of BlockRewardBase.mintedForAccount (BlockRewardAuRaMock.sol#390) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 398,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function mintedForAccountInBlock(address _account, uint256 _blockNumber)\n",
          "message": "Parameter '_account' of BlockRewardBase.mintedForAccountInBlock (BlockRewardAuRaMock.sol#398) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 398,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function mintedForAccountInBlock(address _account, uint256 _blockNumber)\n",
          "message": "Parameter '_blockNumber' of BlockRewardBase.mintedForAccountInBlock (BlockRewardAuRaMock.sol#398) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 411,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function mintedInBlock(uint256 _blockNumber) public view returns(uint256) {\n",
          "message": "Parameter '_blockNumber' of BlockRewardBase.mintedInBlock (BlockRewardAuRaMock.sol#411) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 441,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function snapshotRewardPercents(address _validatorStakingAddress) public view returns(uint256[] memory) {\n",
          "message": "Parameter '_validatorStakingAddress' of BlockRewardBase.snapshotRewardPercents (BlockRewardAuRaMock.sol#441) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 452,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function snapshotStakers(address _validatorStakingAddress) public view returns(address[] memory) {\n",
          "message": "Parameter '_validatorStakingAddress' of BlockRewardBase.snapshotStakers (BlockRewardAuRaMock.sol#452) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 521,
          "vulnerability_to_line": 557,
          "vulnerability_code": "    function _mintNativeCoins(\n\n        address[] memory _receivers,\n\n        uint256[] memory _rewards,\n\n        uint256 _queueLimit\n\n    )\n\n        internal\n\n        returns(address[] memory receivers, uint256[] memory rewards)\n\n    {\n\n        uint256 extraLength = extraReceiversQueueSize();\n\n\n\n        if (extraLength > _queueLimit) {\n\n            extraLength = _queueLimit;\n\n        }\n\n\n\n        receivers = new address[](extraLength + _receivers.length);\n\n        rewards = new uint256[](receivers.length);\n\n\n\n        uint256 i;\n\n        uint256 j = 0;\n\n\n\n        for (i = 0; i < extraLength; i++) {\n\n            (uint256 amount, address receiver, address bridge) = _dequeueExtraReceiver();\n\n            receivers[i] = receiver;\n\n            rewards[i] = amount;\n\n            _setMinted(amount, receiver, bridge);\n\n        }\n\n\n\n        for (i = extraLength; i < receivers.length; i++) {\n\n            receivers[i] = _receivers[j];\n\n            rewards[i] = _rewards[j];\n\n            j++;\n\n        }\n\n\n\n        emit MintedNative(receivers, rewards);\n\n\n\n        return (receivers, rewards);\n",
          "message": "Function 'BlockRewardBase._mintNativeCoins' (BlockRewardAuRaMock.sol#521-557) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 522,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address[] memory _receivers,\n",
          "message": "Parameter '_receivers' of BlockRewardBase._mintNativeCoins (BlockRewardAuRaMock.sol#522) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 523,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint256[] memory _rewards,\n",
          "message": "Parameter '_rewards' of BlockRewardBase._mintNativeCoins (BlockRewardAuRaMock.sol#523) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 524,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint256 _queueLimit\n",
          "message": "Parameter '_queueLimit' of BlockRewardBase._mintNativeCoins (BlockRewardAuRaMock.sol#524) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 564,
          "vulnerability_to_line": 584,
          "vulnerability_code": "    function _dequeueExtraReceiver() internal returns(uint256 amount, address receiver, address bridge) {\n\n        uint256 queueFirst = uintStorage[QUEUE_ER_FIRST];\n\n        uint256 queueLast = uintStorage[QUEUE_ER_LAST];\n\n\n\n        if (queueLast < queueFirst) {\n\n            amount = 0;\n\n            receiver = address(0);\n\n            bridge = address(0);\n\n        } else {\n\n            bytes32 amountHash = keccak256(abi.encode(QUEUE_ER_AMOUNT, queueFirst));\n\n            bytes32 receiverHash = keccak256(abi.encode(QUEUE_ER_RECEIVER, queueFirst));\n\n            bytes32 bridgeHash = keccak256(abi.encode(QUEUE_ER_BRIDGE, queueFirst));\n\n            amount = uintStorage[amountHash];\n\n            receiver = addressStorage[receiverHash];\n\n            bridge = addressStorage[bridgeHash];\n\n            delete uintStorage[amountHash];\n\n            delete addressStorage[receiverHash];\n\n            delete addressStorage[bridgeHash];\n\n            uintStorage[QUEUE_ER_FIRST]++;\n\n        }\n",
          "message": "Function 'BlockRewardBase._dequeueExtraReceiver' (BlockRewardAuRaMock.sol#564-584) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 591,
          "vulnerability_to_line": 597,
          "vulnerability_code": "    function _enqueueExtraReceiver(uint256 _amount, address _receiver, address _bridge) internal {\n\n        uint256 queueLast = uintStorage[QUEUE_ER_LAST] + 1;\n\n        uintStorage[keccak256(abi.encode(QUEUE_ER_AMOUNT, queueLast))] = _amount;\n\n        addressStorage[keccak256(abi.encode(QUEUE_ER_RECEIVER, queueLast))] = _receiver;\n\n        addressStorage[keccak256(abi.encode(QUEUE_ER_BRIDGE, queueLast))] = _bridge;\n\n        uintStorage[QUEUE_ER_LAST] = queueLast;\n",
          "message": "Function 'BlockRewardBase._enqueueExtraReceiver' (BlockRewardAuRaMock.sol#591-597) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 591,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _enqueueExtraReceiver(uint256 _amount, address _receiver, address _bridge) internal {\n",
          "message": "Parameter '_amount' of BlockRewardBase._enqueueExtraReceiver (BlockRewardAuRaMock.sol#591) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 591,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _enqueueExtraReceiver(uint256 _amount, address _receiver, address _bridge) internal {\n",
          "message": "Parameter '_receiver' of BlockRewardBase._enqueueExtraReceiver (BlockRewardAuRaMock.sol#591) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 591,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _enqueueExtraReceiver(uint256 _amount, address _receiver, address _bridge) internal {\n",
          "message": "Parameter '_bridge' of BlockRewardBase._enqueueExtraReceiver (BlockRewardAuRaMock.sol#591) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 604,
          "vulnerability_to_line": 610,
          "vulnerability_code": "    function _setMinted(uint256 _amount, address _account, address _bridge) internal {\n\n        uintStorage[keccak256(abi.encode(MINTED_FOR_ACCOUNT_IN_BLOCK, _account, block.number))] = _amount;\n\n        uintStorage[keccak256(abi.encode(MINTED_FOR_ACCOUNT, _account))] += _amount;\n\n        uintStorage[keccak256(abi.encode(MINTED_IN_BLOCK, block.number))] += _amount;\n\n        uintStorage[keccak256(abi.encode(MINTED_TOTALLY_BY_BRIDGE, _bridge))] += _amount;\n\n        uintStorage[MINTED_TOTALLY] += _amount;\n",
          "message": "Function 'BlockRewardBase._setMinted' (BlockRewardAuRaMock.sol#604-610) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 604,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setMinted(uint256 _amount, address _account, address _bridge) internal {\n",
          "message": "Parameter '_amount' of BlockRewardBase._setMinted (BlockRewardAuRaMock.sol#604) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 604,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setMinted(uint256 _amount, address _account, address _bridge) internal {\n",
          "message": "Parameter '_account' of BlockRewardBase._setMinted (BlockRewardAuRaMock.sol#604) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 604,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setMinted(uint256 _amount, address _account, address _bridge) internal {\n",
          "message": "Parameter '_bridge' of BlockRewardBase._setMinted (BlockRewardAuRaMock.sol#604) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 621,
          "vulnerability_to_line": 682,
          "vulnerability_code": "    function _setSnapshot(address _stakingAddress, IStaking _stakingContract, uint256 _offset) internal {\n\n        uint256 validatorStake = _stakingContract.stakeAmountMinusOrderedWithdraw(_stakingAddress, _stakingAddress);\n\n        uint256 totalStaked = _stakingContract.stakeAmountTotalMinusOrderedWithdraw(_stakingAddress);\n\n        uint256 delegatorsAmount = totalStaked >= validatorStake ? totalStaked - validatorStake : 0;\n\n        bool validatorHasMore30Per = validatorStake * 7 > delegatorsAmount * 3;\n\n\n\n        address[] memory delegators = _stakingContract.poolDelegators(_stakingAddress);\n\n        uint256 rewardPercent;\n\n\n\n        address[] storage stakers = addressArrayStorage[keccak256(abi.encode(\n\n            SNAPSHOT_STAKERS, _stakingAddress\n\n        ))];\n\n\n\n        uint256[] storage rewardPercents = uintArrayStorage[keccak256(abi.encode(\n\n            SNAPSHOT_REWARD_PERCENTS, _stakingAddress\n\n        ))];\n\n\n\n        if (_offset == 0) {\n\n            // Calculate reward percent for validator\n\n            rewardPercent = 0;\n\n            if (validatorStake != 0 && totalStaked != 0) {\n\n                if (validatorHasMore30Per) {\n\n                    rewardPercent = REWARD_PERCENT_MULTIPLIER * validatorStake / totalStaked;\n\n                } else {\n\n                    rewardPercent = REWARD_PERCENT_MULTIPLIER * 3 / 10;\n\n                }\n\n            }\n\n            stakers.push(_stakingAddress);\n\n            rewardPercents.push(rewardPercent);\n\n            addressArrayStorage[SNAPSHOT_STAKING_ADDRESSES].push(_stakingAddress);\n\n            uintStorage[SNAPSHOT_TOTAL_STAKE_AMOUNT] += totalStaked;\n\n        }\n\n\n\n        uint256 from = _offset * delegators.length / DELEGATORS_ALIQUOT;\n\n        uint256 to = (_offset + 1) * delegators.length / DELEGATORS_ALIQUOT;\n\n\n\n        if (_offset == 0) {\n\n            to += delegators.length % DELEGATORS_ALIQUOT;\n\n        } else {\n\n            from += delegators.length % DELEGATORS_ALIQUOT;\n\n        }\n\n\n\n        // Calculate reward percent for each delegator\n\n        for (uint256 i = from; i < to; i++) {\n\n            rewardPercent = 0;\n\n\n\n            if (validatorHasMore30Per) {\n\n                if (totalStaked != 0) {\n\n                    rewardPercent = _stakingContract.stakeAmountMinusOrderedWithdraw(_stakingAddress, delegators[i]);\n\n                    rewardPercent = REWARD_PERCENT_MULTIPLIER * rewardPercent / totalStaked;\n\n                }\n\n            } else {\n\n                if (delegatorsAmount != 0) {\n\n                    rewardPercent = _stakingContract.stakeAmountMinusOrderedWithdraw(_stakingAddress, delegators[i]);\n\n                    rewardPercent = REWARD_PERCENT_MULTIPLIER * rewardPercent * 7 / (delegatorsAmount * 10);\n\n                }\n\n            }\n\n\n\n            stakers.push(delegators[i]);\n\n            rewardPercents.push(rewardPercent);\n\n        }\n",
          "message": "Function 'BlockRewardBase._setSnapshot' (BlockRewardAuRaMock.sol#621-682) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 621,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setSnapshot(address _stakingAddress, IStaking _stakingContract, uint256 _offset) internal {\n",
          "message": "Parameter '_stakingAddress' of BlockRewardBase._setSnapshot (BlockRewardAuRaMock.sol#621) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 621,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setSnapshot(address _stakingAddress, IStaking _stakingContract, uint256 _offset) internal {\n",
          "message": "Parameter '_stakingContract' of BlockRewardBase._setSnapshot (BlockRewardAuRaMock.sol#621) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 621,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setSnapshot(address _stakingAddress, IStaking _stakingContract, uint256 _offset) internal {\n",
          "message": "Parameter '_offset' of BlockRewardBase._setSnapshot (BlockRewardAuRaMock.sol#621) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 699,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function balanceOf(address) external view returns(uint256);\n",
          "message": "Parameter '' of IERC20Minting.balanceOf (BlockRewardAuRaMock.sol#699) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 708,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function initialize(uint256, address) external;\n",
          "message": "Parameter '' of IRandomAuRa.initialize (BlockRewardAuRaMock.sol#708) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 708,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function initialize(uint256, address) external;\n",
          "message": "Parameter '_scope_0' of IRandomAuRa.initialize (BlockRewardAuRaMock.sol#708) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 710,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function commitHashCallable(address, bytes32) external view returns(bool);\n",
          "message": "Parameter '' of IRandomAuRa.commitHashCallable (BlockRewardAuRaMock.sol#710) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 710,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function commitHashCallable(address, bytes32) external view returns(bool);\n",
          "message": "Parameter '_scope_0' of IRandomAuRa.commitHashCallable (BlockRewardAuRaMock.sol#710) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 711,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function revealSecretCallable(address, uint256) external view returns(bool);\n",
          "message": "Parameter '' of IRandomAuRa.revealSecretCallable (BlockRewardAuRaMock.sol#711) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 711,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function revealSecretCallable(address, uint256) external view returns(bool);\n",
          "message": "Parameter '_scope_0' of IRandomAuRa.revealSecretCallable (BlockRewardAuRaMock.sol#711) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 721,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address,\n",
          "message": "Parameter '' of IStakingAuRa.initialize (BlockRewardAuRaMock.sol#721) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 722,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address[] calldata,\n",
          "message": "Parameter '_scope_0' of IStakingAuRa.initialize (BlockRewardAuRaMock.sol#722) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 723,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint256,\n",
          "message": "Parameter '_scope_1' of IStakingAuRa.initialize (BlockRewardAuRaMock.sol#723) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 724,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint256,\n",
          "message": "Parameter '_scope_2' of IStakingAuRa.initialize (BlockRewardAuRaMock.sol#724) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 725,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint256,\n",
          "message": "Parameter '_scope_3' of IStakingAuRa.initialize (BlockRewardAuRaMock.sol#725) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 726,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint256,\n",
          "message": "Parameter '_scope_4' of IStakingAuRa.initialize (BlockRewardAuRaMock.sol#726) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 727,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint256,\n",
          "message": "Parameter '_scope_5' of IStakingAuRa.initialize (BlockRewardAuRaMock.sol#727) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 728,
          "vulnerability_to_line": null,
          "vulnerability_code": "        bool\n",
          "message": "Parameter '_scope_6' of IStakingAuRa.initialize (BlockRewardAuRaMock.sol#728) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 730,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setStakingEpochStartBlock(uint256) external;\n",
          "message": "Parameter '' of IStakingAuRa.setStakingEpochStartBlock (BlockRewardAuRaMock.sol#730) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 742,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function removeMaliciousValidator(address) external;\n",
          "message": "Parameter '' of IValidatorSetAuRa.removeMaliciousValidator (BlockRewardAuRaMock.sol#742) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 743,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function reportMaliciousCallable(address, address, uint256) external view returns(bool, bool);\n",
          "message": "Parameter '' of IValidatorSetAuRa.reportMaliciousCallable (BlockRewardAuRaMock.sol#743) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 743,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function reportMaliciousCallable(address, address, uint256) external view returns(bool, bool);\n",
          "message": "Parameter '_scope_0' of IValidatorSetAuRa.reportMaliciousCallable (BlockRewardAuRaMock.sol#743) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 743,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function reportMaliciousCallable(address, address, uint256) external view returns(bool, bool);\n",
          "message": "Parameter '_scope_1' of IValidatorSetAuRa.reportMaliciousCallable (BlockRewardAuRaMock.sol#743) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 883,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint256 _stakingEpoch,\n",
          "message": "Parameter '_stakingEpoch' of BlockRewardAuRa.getBlocksCreated (BlockRewardAuRaMock.sol#883) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 884,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address _validatorMiningAddress\n",
          "message": "Parameter '_validatorMiningAddress' of BlockRewardAuRa.getBlocksCreated (BlockRewardAuRaMock.sol#884) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 894,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint256 _stakingEpoch,\n",
          "message": "Parameter '_stakingEpoch' of BlockRewardAuRa.getEpochPoolNativeReward (BlockRewardAuRaMock.sol#894) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 895,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address _poolStakingAddress\n",
          "message": "Parameter '_poolStakingAddress' of BlockRewardAuRa.getEpochPoolNativeReward (BlockRewardAuRaMock.sol#895) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 907,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint256 _stakingEpoch,\n",
          "message": "Parameter '_stakingEpoch' of BlockRewardAuRa.getEpochPoolTokenReward (BlockRewardAuRaMock.sol#907) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 908,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address _poolStakingAddress\n",
          "message": "Parameter '_poolStakingAddress' of BlockRewardAuRa.getEpochPoolTokenReward (BlockRewardAuRaMock.sol#908) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 954,
          "vulnerability_to_line": 1138,
          "vulnerability_code": "    function _distributeRewards(\n\n        IValidatorSet _validatorSetContract,\n\n        address _erc20TokenContract,\n\n        bool _erc20Restricted,\n\n        IStakingAuRa _stakingContract,\n\n        uint256 _stakingEpoch,\n\n        uint256 _rewardPointBlock\n\n    ) internal returns(address[] memory receivers, uint256[] memory rewards, bool noop) {\n\n        uint256 i;\n\n        uint256 j;\n\n\n\n        receivers = new address[](0);\n\n        rewards = new uint256[](0);\n\n        noop = true;\n\n\n\n        if (block.number == _rewardPointBlock - 1) {\n\n            boolStorage[IS_REWARDING] = true;\n\n        } else if (block.number == _rewardPointBlock) {\n\n            address[] memory validators = _validatorSetContract.getValidators();\n\n            uint256[] memory ratio = new uint256[](validators.length);\n\n\n\n            uint256 totalReward;\n\n            bool isRewarding = false;\n\n\n\n            totalReward = uintStorage[BRIDGE_TOKEN_FEE];\n\n\n\n            if (!_erc20Restricted) {\n\n                // Accumulated bridge fee plus token inflation\n\n                uint256 inflationPercent;\n\n                if (_stakingEpoch <= 24) {\n\n                    inflationPercent = 32;\n\n                } else if (_stakingEpoch <= 48) {\n\n                    inflationPercent = 16;\n\n                } else if (_stakingEpoch <= 72) {\n\n                    inflationPercent = 8;\n\n                } else {\n\n                    inflationPercent = 4;\n\n                }\n\n                totalReward += snapshotTotalStakeAmount() * inflationPercent / 4800;\n\n            }\n\n\n\n            if (\n\n                totalReward != 0 && _erc20TokenContract != address(0) ||\n\n                uintStorage[BRIDGE_NATIVE_FEE] != 0 ||\n\n                _erc20Restricted\n\n            ) {\n\n                j = 0;\n\n                for (i = 0; i < validators.length; i++) {\n\n                    ratio[i] = uintStorage[keccak256(abi.encode(\n\n                        BLOCKS_CREATED, _stakingEpoch, validators[i]\n\n                    ))];\n\n                    j += ratio[i];\n\n                    validators[i] = _validatorSetContract.stakingByMiningAddress(validators[i]);\n\n                }\n\n                if (j != 0) {\n\n                    for (i = 0; i < validators.length; i++) {\n\n                        ratio[i] = REWARD_PERCENT_MULTIPLIER * ratio[i] / j;\n\n                    }\n\n                }\n\n            }\n\n            if (totalReward != 0) {\n\n                uintStorage[BRIDGE_TOKEN_FEE] = 0;\n\n\n\n                totalReward += uintStorage[TOKEN_REWARD_UNDISTRIBUTED];\n\n\n\n                if (_erc20TokenContract != address(0)) {\n\n                    for (i = 0; i < validators.length; i++) {\n\n                        uintStorage[keccak256(abi.encode(\n\n                            EPOCH_POOL_TOKEN_REWARD, _stakingEpoch, validators[i]\n\n                        ))] = totalReward * ratio[i] / REWARD_PERCENT_MULTIPLIER;\n\n                    }\n\n                    isRewarding = true;\n\n                }\n\n\n\n                uintStorage[TOKEN_REWARD_UNDISTRIBUTED] = totalReward;\n\n            }\n\n\n\n            totalReward = uintStorage[BRIDGE_NATIVE_FEE];\n\n\n\n            if (_erc20Restricted) {\n\n                // Accumulated bridge fee plus 2.5% per year coin inflation\n\n                totalReward += _stakingContract.stakingEpochDuration() * 1 ether;\n\n            }\n\n\n\n            if (totalReward != 0) {\n\n                uintStorage[BRIDGE_NATIVE_FEE] = 0;\n\n\n\n                totalReward += uintStorage[NATIVE_REWARD_UNDISTRIBUTED];\n\n\n\n                for (i = 0; i < validators.length; i++) {\n\n                    uintStorage[keccak256(abi.encode(\n\n                        EPOCH_POOL_NATIVE_REWARD, _stakingEpoch, validators[i]\n\n                    ))] = totalReward * ratio[i] / REWARD_PERCENT_MULTIPLIER;\n\n                }\n\n                isRewarding = true;\n\n\n\n                uintStorage[NATIVE_REWARD_UNDISTRIBUTED] = totalReward;\n\n            }\n\n\n\n            if (isRewarding) {\n\n                for (i = 0; i < validators.length; i++) {\n\n                    _enqueueValidator(validators[i]);\n\n                }\n\n                if (validators.length == 0) {\n\n                    boolStorage[IS_REWARDING] = false;\n\n                }\n\n            } else {\n\n                boolStorage[IS_REWARDING] = false;\n\n            }\n\n\n\n            noop = false;\n\n        } else if (block.number > _rewardPointBlock) {\n\n            address stakingAddress = _dequeueValidator();\n\n\n\n            if (stakingAddress == address(0)) {\n\n                return (receivers, rewards, true);\n\n            }\n\n\n\n            if (_validatorsQueueSize() == 0) {\n\n                boolStorage[IS_REWARDING] = false;\n\n            }\n\n\n\n            if (_validatorSetContract.isValidatorBanned(_validatorSetContract.miningByStakingAddress(stakingAddress))) {\n\n                return (receivers, rewards, true);\n\n            }\n\n\n\n            address[] storage stakers = addressArrayStorage[keccak256(abi.encode(SNAPSHOT_STAKERS, stakingAddress))];\n\n            uint256[] memory range = new uint256[](3); // array instead of local vars because the stack is too deep\n\n            range[0] = (_validatorsQueueSize() + 1) % DELEGATORS_ALIQUOT; // offset\n\n            range[1] = range[0] * stakers.length / DELEGATORS_ALIQUOT; // from\n\n            range[2] = (range[0] + 1) * stakers.length / DELEGATORS_ALIQUOT; // to\n\n\n\n            if (range[0] == 0) {\n\n                range[2] += stakers.length % DELEGATORS_ALIQUOT;\n\n            } else {\n\n                range[1] += stakers.length % DELEGATORS_ALIQUOT;\n\n            }\n\n\n\n            if (range[1] >= range[2]) {\n\n                return (receivers, rewards, true);\n\n            }\n\n\n\n            uint256[] storage rewardPercents = uintArrayStorage[keccak256(abi.encode(\n\n                SNAPSHOT_REWARD_PERCENTS, stakingAddress\n\n            ))];\n\n            uint256 accrued;\n\n            uint256 poolReward;\n\n\n\n            receivers = new address[](range[2] - range[1]);\n\n            rewards = new uint256[](receivers.length);\n\n\n\n            poolReward = uintStorage[keccak256(abi.encode(\n\n                EPOCH_POOL_TOKEN_REWARD, _stakingEpoch, stakingAddress\n\n            ))];\n\n            if (poolReward != 0) {\n\n                accrued = 0;\n\n                for (i = range[1]; i < range[2]; i++) {\n\n                    j = i - range[1];\n\n                    receivers[j] = stakers[i];\n\n                    rewards[j] = poolReward * rewardPercents[i] / REWARD_PERCENT_MULTIPLIER;\n\n                    accrued += rewards[j];\n\n                }\n\n                IERC20Minting(_erc20TokenContract).mintReward(receivers, rewards);\n\n                _subTokenRewardUndistributed(accrued);\n\n                noop = false;\n\n            }\n\n\n\n            poolReward = uintStorage[keccak256(abi.encode(\n\n                EPOCH_POOL_NATIVE_REWARD, _stakingEpoch, stakingAddress\n\n            ))];\n\n            if (poolReward != 0) {\n\n                accrued = 0;\n\n                for (i = range[1]; i < range[2]; i++) {\n\n                    j = i - range[1];\n\n                    receivers[j] = stakers[i];\n\n                    rewards[j] = poolReward * rewardPercents[i] / REWARD_PERCENT_MULTIPLIER;\n\n                    accrued += rewards[j];\n\n                }\n\n                _subNativeRewardUndistributed(accrued);\n\n                noop = false;\n\n            } else {\n\n                return (new address[](0), new uint256[](0), noop);\n\n            }\n\n        }\n",
          "message": "Function 'BlockRewardAuRa._distributeRewards' (BlockRewardAuRaMock.sol#954-1138) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 955,
          "vulnerability_to_line": null,
          "vulnerability_code": "        IValidatorSet _validatorSetContract,\n",
          "message": "Parameter '_validatorSetContract' of BlockRewardAuRa._distributeRewards (BlockRewardAuRaMock.sol#955) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 956,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address _erc20TokenContract,\n",
          "message": "Parameter '_erc20TokenContract' of BlockRewardAuRa._distributeRewards (BlockRewardAuRaMock.sol#956) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 957,
          "vulnerability_to_line": null,
          "vulnerability_code": "        bool _erc20Restricted,\n",
          "message": "Parameter '_erc20Restricted' of BlockRewardAuRa._distributeRewards (BlockRewardAuRaMock.sol#957) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 958,
          "vulnerability_to_line": null,
          "vulnerability_code": "        IStakingAuRa _stakingContract,\n",
          "message": "Parameter '_stakingContract' of BlockRewardAuRa._distributeRewards (BlockRewardAuRaMock.sol#958) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 959,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint256 _stakingEpoch,\n",
          "message": "Parameter '_stakingEpoch' of BlockRewardAuRa._distributeRewards (BlockRewardAuRaMock.sol#959) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 960,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint256 _rewardPointBlock\n",
          "message": "Parameter '_rewardPointBlock' of BlockRewardAuRa._distributeRewards (BlockRewardAuRaMock.sol#960) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1143,
          "vulnerability_to_line": 1155,
          "vulnerability_code": "    function _dequeueValidator() internal returns(address validatorStakingAddress) {\n\n        uint256 queueFirst = uintStorage[QUEUE_V_FIRST];\n\n        uint256 queueLast = uintStorage[QUEUE_V_LAST];\n\n\n\n        if (queueLast < queueFirst) {\n\n            validatorStakingAddress = address(0);\n\n        } else {\n\n            bytes32 hash = keccak256(abi.encode(QUEUE_V_LIST, queueFirst));\n\n            validatorStakingAddress = addressStorage[hash];\n\n            delete addressStorage[hash];\n\n            uintStorage[QUEUE_V_FIRST]++;\n\n        }\n",
          "message": "Function 'BlockRewardAuRa._dequeueValidator' (BlockRewardAuRaMock.sol#1143-1155) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1160,
          "vulnerability_to_line": 1166,
          "vulnerability_code": "    function _enqueueValidator(address _validatorStakingAddress) internal {\n\n        uint256 queueLast = uintStorage[QUEUE_V_LAST];\n\n        for (uint256 i = 0; i < DELEGATORS_ALIQUOT; i++) {\n\n            addressStorage[keccak256(abi.encode(QUEUE_V_LIST, ++queueLast))] = _validatorStakingAddress;\n\n        }\n\n        uintStorage[QUEUE_V_LAST] = queueLast;\n",
          "message": "Function 'BlockRewardAuRa._enqueueValidator' (BlockRewardAuRaMock.sol#1160-1166) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1160,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _enqueueValidator(address _validatorStakingAddress) internal {\n",
          "message": "Parameter '_validatorStakingAddress' of BlockRewardAuRa._enqueueValidator (BlockRewardAuRaMock.sol#1160) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1171,
          "vulnerability_to_line": 1177,
          "vulnerability_code": "    function _subNativeRewardUndistributed(uint256 _minus) internal {\n\n        if (uintStorage[NATIVE_REWARD_UNDISTRIBUTED] < _minus) {\n\n            uintStorage[NATIVE_REWARD_UNDISTRIBUTED] = 0;\n\n        } else {\n\n            uintStorage[NATIVE_REWARD_UNDISTRIBUTED] -= _minus;\n\n        }\n",
          "message": "Function 'BlockRewardAuRa._subNativeRewardUndistributed' (BlockRewardAuRaMock.sol#1171-1177) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1171,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _subNativeRewardUndistributed(uint256 _minus) internal {\n",
          "message": "Parameter '_minus' of BlockRewardAuRa._subNativeRewardUndistributed (BlockRewardAuRaMock.sol#1171) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1182,
          "vulnerability_to_line": 1188,
          "vulnerability_code": "    function _subTokenRewardUndistributed(uint256 _minus) internal {\n\n        if (uintStorage[TOKEN_REWARD_UNDISTRIBUTED] < _minus) {\n\n            uintStorage[TOKEN_REWARD_UNDISTRIBUTED] = 0;\n\n        } else {\n\n            uintStorage[TOKEN_REWARD_UNDISTRIBUTED] -= _minus;\n\n        }\n",
          "message": "Function 'BlockRewardAuRa._subTokenRewardUndistributed' (BlockRewardAuRaMock.sol#1182-1188) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1182,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _subTokenRewardUndistributed(uint256 _minus) internal {\n",
          "message": "Parameter '_minus' of BlockRewardAuRa._subTokenRewardUndistributed (BlockRewardAuRaMock.sol#1182) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1195,
          "vulnerability_to_line": 1200,
          "vulnerability_code": "    function _rewardPointBlock(\n\n        IStakingAuRa _stakingContract,\n\n        IValidatorSet _validatorSetContract\n\n    ) internal view returns(uint256) {\n\n        return _stakingContract.stakingEpochEndBlock() - _validatorSetContract.MAX_VALIDATORS()*DELEGATORS_ALIQUOT - 1;\n",
          "message": "Function 'BlockRewardAuRa._rewardPointBlock' (BlockRewardAuRaMock.sol#1195-1200) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1196,
          "vulnerability_to_line": null,
          "vulnerability_code": "        IStakingAuRa _stakingContract,\n",
          "message": "Parameter '_stakingContract' of BlockRewardAuRa._rewardPointBlock (BlockRewardAuRaMock.sol#1196) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1197,
          "vulnerability_to_line": null,
          "vulnerability_code": "        IValidatorSet _validatorSetContract\n",
          "message": "Parameter '_validatorSetContract' of BlockRewardAuRa._rewardPointBlock (BlockRewardAuRaMock.sol#1197) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1205,
          "vulnerability_to_line": 1207,
          "vulnerability_code": "    function _validatorsQueueSize() internal view returns(uint256) {\n\n        return uintStorage[QUEUE_V_LAST] + 1 - uintStorage[QUEUE_V_FIRST];\n",
          "message": "Function 'BlockRewardAuRa._validatorsQueueSize' (BlockRewardAuRaMock.sol#1205-1207) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1217,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setIsSnapshotting(bool _isSnapshotting) public {\n",
          "message": "Parameter '_isSnapshotting' of BlockRewardAuRaMock.setIsSnapshotting (BlockRewardAuRaMock.sol#1217) is not in mixedCase\n"
        },
        {
          "name": "unused-state",
          "vulnerability_from_line": 84,
          "vulnerability_to_line": null,
          "vulnerability_code": "    mapping(bytes32 => string) internal stringStorage;\n",
          "message": "EternalStorage.stringStorage (BlockRewardAuRaMock.sol#84) is never used in BlockRewardAuRaMock\nEternalStorage.bytesStorage (BlockRewardAuRaMock.sol#86) is never used in BlockRewardAuRaMock\nEternalStorage.intStorage (BlockRewardAuRaMock.sol#88) is never used in BlockRewardAuRaMock\nEternalStorage.bytes32Storage (BlockRewardAuRaMock.sol#89) is never used in BlockRewardAuRaMock\nEternalStorage.stringArrayStorage (BlockRewardAuRaMock.sol#92) is never used in BlockRewardAuRaMock\nEternalStorage.bytesArrayStorage (BlockRewardAuRaMock.sol#94) is never used in BlockRewardAuRaMock\nEternalStorage.boolArrayStorage (BlockRewardAuRaMock.sol#95) is never used in BlockRewardAuRaMock\nEternalStorage.intArrayStorage (BlockRewardAuRaMock.sol#96) is never used in BlockRewardAuRaMock\nEternalStorage.bytes32ArrayStorage (BlockRewardAuRaMock.sol#97) is never used in BlockRewardAuRaMock\n"
        }
      ]
    },
    "smartcheck": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 221,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == 0xffffFFFfFFffffffffffffffFfFFFfffFFFfFFfE);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 570,
          "vulnerability_to_line": null,
          "vulnerability_code": "            receiver = address(0);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 571,
          "vulnerability_to_line": null,
          "vulnerability_code": "            bridge = address(0);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 1148,
          "vulnerability_to_line": null,
          "vulnerability_code": "            validatorStakingAddress = address(0);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 288,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (i = 0; i < oldBridgesAllowed.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 294,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (i = 0; i < _bridgesAllowed.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 306,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (i = 0; i < oldBridgesAllowed.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 312,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (i = 0; i < _bridgesAllowed.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 324,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (i = 0; i < oldBridgesAllowed.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 330,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (i = 0; i < _bridgesAllowed.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 548,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (i = extraLength; i < receivers.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 819,
          "vulnerability_to_line": null,
          "vulnerability_code": "            for (uint256 i = 0; i < newValidatorSet.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 1001,
          "vulnerability_to_line": null,
          "vulnerability_code": "                for (i = 0; i < validators.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 1009,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    for (i = 0; i < validators.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 1020,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    for (i = 0; i < validators.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 1043,
          "vulnerability_to_line": null,
          "vulnerability_code": "                for (i = 0; i < validators.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 1054,
          "vulnerability_to_line": null,
          "vulnerability_code": "                for (i = 0; i < validators.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 288,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (i = 0; i < oldBridgesAllowed.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 294,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (i = 0; i < _bridgesAllowed.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 306,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (i = 0; i < oldBridgesAllowed.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 312,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (i = 0; i < _bridgesAllowed.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 324,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (i = 0; i < oldBridgesAllowed.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 330,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (i = 0; i < _bridgesAllowed.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 819,
          "vulnerability_to_line": null,
          "vulnerability_code": "            for (uint256 i = 0; i < newValidatorSet.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 1001,
          "vulnerability_to_line": null,
          "vulnerability_code": "                for (i = 0; i < validators.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 1009,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    for (i = 0; i < validators.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 1020,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    for (i = 0; i < validators.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 1043,
          "vulnerability_to_line": null,
          "vulnerability_code": "                for (i = 0; i < validators.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 1054,
          "vulnerability_to_line": null,
          "vulnerability_code": "                for (i = 0; i < validators.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_OVERPOWERED_ROLE",
          "vulnerability_from_line": 284,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setErcToNativeBridgesAllowed(address[] calldata _bridgesAllowed) external onlyOwner onlyInitialized {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_OVERPOWERED_ROLE",
          "vulnerability_from_line": 302,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setNativeToErcBridgesAllowed(address[] calldata _bridgesAllowed) external onlyOwner onlyInitialized {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_OVERPOWERED_ROLE",
          "vulnerability_from_line": 320,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setErcToErcBridgesAllowed(address[] calldata _bridgesAllowed) external onlyOwner onlyInitialized {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SAFEMATH",
          "vulnerability_from_line": 168,
          "vulnerability_to_line": null,
          "vulnerability_code": "    using SafeMath for uint256;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 29,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function newValidatorSet() external returns(bool, uint256);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 61,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getPoolsLikelihood() external view returns(int256[] memory, int256);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 527,
          "vulnerability_to_line": null,
          "vulnerability_code": "        returns(address[] memory receivers, uint256[] memory rewards)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 564,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _dequeueExtraReceiver() internal returns(uint256 amount, address receiver, address bridge) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 743,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function reportMaliciousCallable(address, address, uint256) external view returns(bool, bool);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 766,
          "vulnerability_to_line": null,
          "vulnerability_code": "        returns(address[] memory receiversNative, uint256[] memory rewardsNative)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 961,
          "vulnerability_to_line": null,
          "vulnerability_code": "    ) internal returns(address[] memory receivers, uint256[] memory rewards, bool noop) {\n",
          "message": null
        }
      ]
    },
    "oyente": {
      "successfull_analysis": false,
      "errors": [
        "exception (RuntimeError: Source map error, unknown name(SHR) or instr_name(INVALID))"
      ],
      "vulnerability_findings": []
    },
    "mythril": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": []
    },
    "osiris": {
      "successfull_analysis": false,
      "errors": [
        "UNKNOWN INSTRUCTION: SHR",
        "exception (IndexError: pop from empty list)"
      ],
      "vulnerability_findings": []
    }
  }
}