{
  "smartbugs_completed": true,
  "analyzer_results": {
    "semgrep": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 288,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (i = 0; i < oldBridgesAllowed.length; i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 306,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (i = 0; i < oldBridgesAllowed.length; i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 324,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (i = 0; i < oldBridgesAllowed.length; i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 548,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (i = extraLength; i < receivers.length; i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 664,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 i = from; i < to; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 641,
          "vulnerability_to_line": null,
          "vulnerability_code": "            if (validatorStake != 0 && totalStaked != 0) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 642,
          "vulnerability_to_line": null,
          "vulnerability_code": "                if (validatorHasMore30Per) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 643,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    rewardPercent = REWARD_PERCENT_MULTIPLIER * validatorStake / totalStaked;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 644,
          "vulnerability_to_line": null,
          "vulnerability_code": "                } else {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 645,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    rewardPercent = REWARD_PERCENT_MULTIPLIER * 3 / 10;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 646,
          "vulnerability_to_line": null,
          "vulnerability_code": "                }\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 647,
          "vulnerability_to_line": null,
          "vulnerability_code": "            }\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 288,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (i = 0; i < oldBridgesAllowed.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 294,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (i = 0; i < _bridgesAllowed.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 306,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (i = 0; i < oldBridgesAllowed.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 312,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (i = 0; i < _bridgesAllowed.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 324,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (i = 0; i < oldBridgesAllowed.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 330,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (i = 0; i < _bridgesAllowed.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 541,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (i = 0; i < extraLength; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 548,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (i = extraLength; i < receivers.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 551,
          "vulnerability_to_line": null,
          "vulnerability_code": "            j++;\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 582,
          "vulnerability_to_line": null,
          "vulnerability_code": "            uintStorage[QUEUE_ER_FIRST]++;\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 664,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 i = from; i < to; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        }
      ]
    },
    "slither": {
      "successfull_analysis": true,
      "errors": [
        "EXIT_CODE_88"
      ],
      "vulnerability_findings": [
        {
          "name": "uninitialized-state",
          "vulnerability_from_line": 80,
          "vulnerability_to_line": null,
          "vulnerability_code": "    address internal _owner;\n",
          "message": "EternalStorage._owner (BlockRewardHBBFT.sol#80) is never initialized. It is used in:\n"
        },
        {
          "name": "uninitialized-state",
          "vulnerability_from_line": 91,
          "vulnerability_to_line": null,
          "vulnerability_code": "    mapping(bytes32 => uint256[]) internal uintArrayStorage;\n",
          "message": "EternalStorage.uintArrayStorage (BlockRewardHBBFT.sol#91) is never initialized. It is used in:\n\t- snapshotRewardPercents (BlockRewardHBBFT.sol#441-445)\n\t- _setSnapshot (BlockRewardHBBFT.sol#621-682)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 271,
          "vulnerability_to_line": 279,
          "vulnerability_code": "    function migrateMintingStatistics(address _bridge, IBlockReward _prevBlockRewardContract) external onlyOwner {\n\n        require(mintedTotally() == 0);\n\n        uint256 prevMinted = _prevBlockRewardContract.mintedTotally();\n\n        uint256 prevMintedByBridge = _prevBlockRewardContract.mintedTotallyByBridge(_bridge);\n\n        require(prevMinted != 0);\n\n        require(prevMintedByBridge != 0);\n\n        uintStorage[MINTED_TOTALLY] = prevMinted;\n\n        uintStorage[keccak256(abi.encode(MINTED_TOTALLY_BY_BRIDGE, _bridge))] = prevMintedByBridge;\n",
          "message": "Reentrancy in BlockRewardBase.migrateMintingStatistics (BlockRewardHBBFT.sol#271-279):\n\tExternal calls:\n\t- prevMinted = _prevBlockRewardContract.mintedTotally() (BlockRewardHBBFT.sol#273)\n\t- prevMintedByBridge = _prevBlockRewardContract.mintedTotallyByBridge(_bridge) (BlockRewardHBBFT.sol#274)\n\tState variables written after the call(s):\n\t- uintStorage (BlockRewardHBBFT.sol#277)\n\t- uintStorage (BlockRewardHBBFT.sol#278)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 621,
          "vulnerability_to_line": 682,
          "vulnerability_code": "    function _setSnapshot(address _stakingAddress, IStaking _stakingContract, uint256 _offset) internal {\n\n        uint256 validatorStake = _stakingContract.stakeAmountMinusOrderedWithdraw(_stakingAddress, _stakingAddress);\n\n        uint256 totalStaked = _stakingContract.stakeAmountTotalMinusOrderedWithdraw(_stakingAddress);\n\n        uint256 delegatorsAmount = totalStaked >= validatorStake ? totalStaked - validatorStake : 0;\n\n        bool validatorHasMore30Per = validatorStake * 7 > delegatorsAmount * 3;\n\n\n\n        address[] memory delegators = _stakingContract.poolDelegators(_stakingAddress);\n\n        uint256 rewardPercent;\n\n\n\n        address[] storage stakers = addressArrayStorage[keccak256(abi.encode(\n\n            SNAPSHOT_STAKERS, _stakingAddress\n\n        ))];\n\n\n\n        uint256[] storage rewardPercents = uintArrayStorage[keccak256(abi.encode(\n\n            SNAPSHOT_REWARD_PERCENTS, _stakingAddress\n\n        ))];\n\n\n\n        if (_offset == 0) {\n\n            // Calculate reward percent for validator\n\n            rewardPercent = 0;\n\n            if (validatorStake != 0 && totalStaked != 0) {\n\n                if (validatorHasMore30Per) {\n\n                    rewardPercent = REWARD_PERCENT_MULTIPLIER * validatorStake / totalStaked;\n\n                } else {\n\n                    rewardPercent = REWARD_PERCENT_MULTIPLIER * 3 / 10;\n\n                }\n\n            }\n\n            stakers.push(_stakingAddress);\n\n            rewardPercents.push(rewardPercent);\n\n            addressArrayStorage[SNAPSHOT_STAKING_ADDRESSES].push(_stakingAddress);\n\n            uintStorage[SNAPSHOT_TOTAL_STAKE_AMOUNT] += totalStaked;\n\n        }\n\n\n\n        uint256 from = _offset * delegators.length / DELEGATORS_ALIQUOT;\n\n        uint256 to = (_offset + 1) * delegators.length / DELEGATORS_ALIQUOT;\n\n\n\n        if (_offset == 0) {\n\n            to += delegators.length % DELEGATORS_ALIQUOT;\n\n        } else {\n\n            from += delegators.length % DELEGATORS_ALIQUOT;\n\n        }\n\n\n\n        // Calculate reward percent for each delegator\n\n        for (uint256 i = from; i < to; i++) {\n\n            rewardPercent = 0;\n\n\n\n            if (validatorHasMore30Per) {\n\n                if (totalStaked != 0) {\n\n                    rewardPercent = _stakingContract.stakeAmountMinusOrderedWithdraw(_stakingAddress, delegators[i]);\n\n                    rewardPercent = REWARD_PERCENT_MULTIPLIER * rewardPercent / totalStaked;\n\n                }\n\n            } else {\n\n                if (delegatorsAmount != 0) {\n\n                    rewardPercent = _stakingContract.stakeAmountMinusOrderedWithdraw(_stakingAddress, delegators[i]);\n\n                    rewardPercent = REWARD_PERCENT_MULTIPLIER * rewardPercent * 7 / (delegatorsAmount * 10);\n\n                }\n\n            }\n\n\n\n            stakers.push(delegators[i]);\n\n            rewardPercents.push(rewardPercent);\n\n        }\n",
          "message": "Reentrancy in BlockRewardBase._setSnapshot (BlockRewardHBBFT.sol#621-682):\n\tExternal calls:\n\t- validatorStake = _stakingContract.stakeAmountMinusOrderedWithdraw(_stakingAddress,_stakingAddress) (BlockRewardHBBFT.sol#622)\n\t- totalStaked = _stakingContract.stakeAmountTotalMinusOrderedWithdraw(_stakingAddress) (BlockRewardHBBFT.sol#623)\n\t- delegators = _stakingContract.poolDelegators(_stakingAddress) (BlockRewardHBBFT.sol#627)\n\tState variables written after the call(s):\n\t- addressArrayStorage (BlockRewardHBBFT.sol#650)\n\t- uintStorage (BlockRewardHBBFT.sol#651)\n"
        },
        {
          "name": "constable-states",
          "vulnerability_from_line": 80,
          "vulnerability_to_line": null,
          "vulnerability_code": "    address internal _owner;\n",
          "message": "EternalStorage._owner should be constant (BlockRewardHBBFT.sol#80)\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 377,
          "vulnerability_to_line": 379,
          "vulnerability_code": "    function isRewarding() public view returns(bool) {\n\n        return boolStorage[IS_REWARDING];\n",
          "message": "BlockRewardBase.isRewarding (BlockRewardHBBFT.sol#377-379) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 9,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function isRewarding() external view returns(bool);\n",
          "message": "IBlockReward.isRewarding (BlockRewardHBBFT.sol#9) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 383,
          "vulnerability_to_line": 385,
          "vulnerability_code": "    function isSnapshotting() public view returns(bool) {\n\n        return boolStorage[IS_SNAPSHOTTING];\n",
          "message": "BlockRewardBase.isSnapshotting (BlockRewardHBBFT.sol#383-385) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 10,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function isSnapshotting() external view returns(bool);\n",
          "message": "IBlockReward.isSnapshotting (BlockRewardHBBFT.sol#10) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 12,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function mintedTotallyByBridge(address _bridge) external view returns(uint256);\n",
          "message": "IBlockReward.mintedTotallyByBridge (BlockRewardHBBFT.sol#12) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 418,
          "vulnerability_to_line": 420,
          "vulnerability_code": "    function mintedTotallyByBridge(address _bridge) public view returns(uint256) {\n\n        return uintStorage[keccak256(abi.encode(MINTED_TOTALLY_BY_BRIDGE, _bridge))];\n",
          "message": "BlockRewardBase.mintedTotallyByBridge (BlockRewardHBBFT.sol#418-420) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 339,
          "vulnerability_to_line": 341,
          "vulnerability_code": "    function blockRewardContractId() public pure returns(bytes4) {\n\n        return BLOCK_REWARD_CONTRACT_ID;\n",
          "message": "BlockRewardBase.blockRewardContractId (BlockRewardHBBFT.sol#339-341) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 344,
          "vulnerability_to_line": 346,
          "vulnerability_code": "    function ercToErcBridgesAllowed() public view returns(address[] memory) {\n\n        return addressArrayStorage[ERC_TO_ERC_BRIDGES_ALLOWED];\n",
          "message": "BlockRewardBase.ercToErcBridgesAllowed (BlockRewardHBBFT.sol#344-346) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 349,
          "vulnerability_to_line": 351,
          "vulnerability_code": "    function ercToNativeBridgesAllowed() public view returns(address[] memory) {\n\n        return addressArrayStorage[ERC_TO_NATIVE_BRIDGES_ALLOWED];\n",
          "message": "BlockRewardBase.ercToNativeBridgesAllowed (BlockRewardHBBFT.sol#349-351) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 360,
          "vulnerability_to_line": 362,
          "vulnerability_code": "    function getBridgeNativeFee() public view returns(uint256) {\n\n        return uintStorage[BRIDGE_NATIVE_FEE];\n",
          "message": "BlockRewardBase.getBridgeNativeFee (BlockRewardHBBFT.sol#360-362) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 366,
          "vulnerability_to_line": 368,
          "vulnerability_code": "    function getBridgeTokenFee() public view returns(uint256) {\n\n        return uintStorage[BRIDGE_TOKEN_FEE];\n",
          "message": "BlockRewardBase.getBridgeTokenFee (BlockRewardHBBFT.sol#366-368) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 390,
          "vulnerability_to_line": 392,
          "vulnerability_code": "    function mintedForAccount(address _account) public view returns(uint256) {\n\n        return uintStorage[keccak256(abi.encode(MINTED_FOR_ACCOUNT, _account))];\n",
          "message": "BlockRewardBase.mintedForAccount (BlockRewardHBBFT.sol#390-392) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 398,
          "vulnerability_to_line": 406,
          "vulnerability_code": "    function mintedForAccountInBlock(address _account, uint256 _blockNumber)\n\n        public\n\n        view\n\n        returns(uint256)\n\n    {\n\n        return uintStorage[\n\n            keccak256(abi.encode(MINTED_FOR_ACCOUNT_IN_BLOCK, _account, _blockNumber))\n\n        ];\n",
          "message": "BlockRewardBase.mintedForAccountInBlock (BlockRewardHBBFT.sol#398-406) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 411,
          "vulnerability_to_line": 413,
          "vulnerability_code": "    function mintedInBlock(uint256 _blockNumber) public view returns(uint256) {\n\n        return uintStorage[keccak256(abi.encode(MINTED_IN_BLOCK, _blockNumber))];\n",
          "message": "BlockRewardBase.mintedInBlock (BlockRewardHBBFT.sol#411-413) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 430,
          "vulnerability_to_line": 432,
          "vulnerability_code": "    function nativeToErcBridgesAllowed() public view returns(address[] memory) {\n\n        return addressArrayStorage[NATIVE_TO_ERC_BRIDGES_ALLOWED];\n",
          "message": "BlockRewardBase.nativeToErcBridgesAllowed (BlockRewardHBBFT.sol#430-432) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 441,
          "vulnerability_to_line": 445,
          "vulnerability_code": "    function snapshotRewardPercents(address _validatorStakingAddress) public view returns(uint256[] memory) {\n\n        return uintArrayStorage[\n\n            keccak256(abi.encode(SNAPSHOT_REWARD_PERCENTS, _validatorStakingAddress))\n\n        ];\n",
          "message": "BlockRewardBase.snapshotRewardPercents (BlockRewardHBBFT.sol#441-445) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 452,
          "vulnerability_to_line": 456,
          "vulnerability_code": "    function snapshotStakers(address _validatorStakingAddress) public view returns(address[] memory) {\n\n        return addressArrayStorage[\n\n            keccak256(abi.encode(SNAPSHOT_STAKERS, _validatorStakingAddress))\n\n        ];\n",
          "message": "BlockRewardBase.snapshotStakers (BlockRewardHBBFT.sol#452-456) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 461,
          "vulnerability_to_line": 463,
          "vulnerability_code": "    function snapshotStakingAddresses() public view returns(address[] memory) {\n\n        return addressArrayStorage[SNAPSHOT_STAKING_ADDRESSES];\n",
          "message": "BlockRewardBase.snapshotStakingAddresses (BlockRewardHBBFT.sol#461-463) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 468,
          "vulnerability_to_line": 470,
          "vulnerability_code": "    function snapshotTotalStakeAmount() public view returns(uint256) {\n\n        return uintStorage[SNAPSHOT_TOTAL_STAKE_AMOUNT];\n",
          "message": "BlockRewardBase.snapshotTotalStakeAmount (BlockRewardHBBFT.sol#468-470) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 473,
          "vulnerability_to_line": 475,
          "vulnerability_code": "    function validatorSetContract() public view returns(IValidatorSet) {\n\n        return IValidatorSet(addressStorage[VALIDATOR_SET_CONTRACT]);\n",
          "message": "BlockRewardBase.validatorSetContract (BlockRewardHBBFT.sol#473-475) should be declared external\n"
        },
        {
          "name": "solc-version",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity 0.5.9;\n",
          "message": "Detected issues with version pragma in BlockRewardHBBFT.sol:\n\t- pragma solidity0.5.9 (BlockRewardHBBFT.sol#3): it allows old versions\n\t- pragma solidity0.5.9 (BlockRewardHBBFT.sol#17): it allows old versions\n\t- pragma solidity0.5.9 (BlockRewardHBBFT.sol#52): it allows old versions\n\t- pragma solidity0.5.9 (BlockRewardHBBFT.sol#72): it allows old versions\n\t- pragma solidity0.5.9 (BlockRewardHBBFT.sol#103): it allows old versions\n\t- pragma solidity0.5.9 (BlockRewardHBBFT.sol#121): it allows old versions\n\t- pragma solidity0.5.9 (BlockRewardHBBFT.sol#160): it allows old versions\n\t- pragma solidity0.5.9 (BlockRewardHBBFT.sol#687): it allows old versions\n\t- pragma solidity0.5.9 (BlockRewardHBBFT.sol#704): it allows old versions\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 7,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function initialize(address) external;\n",
          "message": "Parameter '' of IBlockReward.initialize (BlockRewardHBBFT.sol#7) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 8,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function DELEGATORS_ALIQUOT() external view returns(uint256); // solhint-disable-line func-name-mixedcase\n",
          "message": "Function 'IBlockReward.DELEGATORS_ALIQUOT' (BlockRewardHBBFT.sol#8) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 22,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address,\n",
          "message": "Parameter '' of IValidatorSet.initialize (BlockRewardHBBFT.sol#22) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 23,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address,\n",
          "message": "Parameter '_scope_0' of IValidatorSet.initialize (BlockRewardHBBFT.sol#23) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 24,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address,\n",
          "message": "Parameter '_scope_1' of IValidatorSet.initialize (BlockRewardHBBFT.sol#24) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 25,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address[] calldata,\n",
          "message": "Parameter '_scope_2' of IValidatorSet.initialize (BlockRewardHBBFT.sol#25) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 26,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address[] calldata,\n",
          "message": "Parameter '_scope_3' of IValidatorSet.initialize (BlockRewardHBBFT.sol#26) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 27,
          "vulnerability_to_line": null,
          "vulnerability_code": "        bool\n",
          "message": "Parameter '_scope_4' of IValidatorSet.initialize (BlockRewardHBBFT.sol#27) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 30,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setStakingAddress(address, address) external;\n",
          "message": "Parameter '' of IValidatorSet.setStakingAddress (BlockRewardHBBFT.sol#30) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 30,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setStakingAddress(address, address) external;\n",
          "message": "Parameter '_scope_0' of IValidatorSet.setStakingAddress (BlockRewardHBBFT.sol#30) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 37,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function isReportValidatorValid(address) external view returns(bool);\n",
          "message": "Parameter '' of IValidatorSet.isReportValidatorValid (BlockRewardHBBFT.sol#37) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 38,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function isValidator(address) external view returns(bool);\n",
          "message": "Parameter '' of IValidatorSet.isValidator (BlockRewardHBBFT.sol#38) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 39,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function isValidatorBanned(address) external view returns(bool);\n",
          "message": "Parameter '' of IValidatorSet.isValidatorBanned (BlockRewardHBBFT.sol#39) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 40,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function MAX_VALIDATORS() external view returns(uint256); // solhint-disable-line func-name-mixedcase\n",
          "message": "Function 'IValidatorSet.MAX_VALIDATORS' (BlockRewardHBBFT.sol#40) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 41,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function miningByStakingAddress(address) external view returns(address);\n",
          "message": "Parameter '' of IValidatorSet.miningByStakingAddress (BlockRewardHBBFT.sol#41) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 43,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function stakingByMiningAddress(address) external view returns(address);\n",
          "message": "Parameter '' of IValidatorSet.stakingByMiningAddress (BlockRewardHBBFT.sol#43) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 46,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function validatorIndex(address) external view returns(uint256);\n",
          "message": "Parameter '' of IValidatorSet.validatorIndex (BlockRewardHBBFT.sol#46) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 56,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function clearUnremovableValidator(address) external;\n",
          "message": "Parameter '' of IStaking.clearUnremovableValidator (BlockRewardHBBFT.sol#56) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 58,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function removePool(address) external;\n",
          "message": "Parameter '' of IStaking.removePool (BlockRewardHBBFT.sol#58) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 64,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function poolDelegators(address) external view returns(address[] memory);\n",
          "message": "Parameter '' of IStaking.poolDelegators (BlockRewardHBBFT.sol#64) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 65,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function stakeAmountMinusOrderedWithdraw(address, address) external view returns(uint256);\n",
          "message": "Parameter '' of IStaking.stakeAmountMinusOrderedWithdraw (BlockRewardHBBFT.sol#65) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 65,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function stakeAmountMinusOrderedWithdraw(address, address) external view returns(uint256);\n",
          "message": "Parameter '_scope_0' of IStaking.stakeAmountMinusOrderedWithdraw (BlockRewardHBBFT.sol#65) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 66,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function stakeAmountTotalMinusOrderedWithdraw(address) external view returns(uint256);\n",
          "message": "Parameter '' of IStaking.stakeAmountTotalMinusOrderedWithdraw (BlockRewardHBBFT.sol#66) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 80,
          "vulnerability_to_line": null,
          "vulnerability_code": "    address internal _owner;\n",
          "message": "Variable 'EternalStorage._owner' (BlockRewardHBBFT.sol#80) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 260,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function initialize(address _validatorSet) external {\n",
          "message": "Parameter '_validatorSet' of BlockRewardBase.initialize (BlockRewardHBBFT.sol#260) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 418,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function mintedTotallyByBridge(address _bridge) public view returns(uint256) {\n",
          "message": "Parameter '_bridge' of BlockRewardBase.mintedTotallyByBridge (BlockRewardHBBFT.sol#418) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 231,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function addBridgeNativeFeeReceivers(uint256 _amount) external onlyErcToNativeBridge {\n",
          "message": "Parameter '_amount' of BlockRewardBase.addBridgeNativeFeeReceivers (BlockRewardHBBFT.sol#231) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 240,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function addBridgeTokenFeeReceivers(uint256 _amount) external onlyXToErcBridge {\n",
          "message": "Parameter '_amount' of BlockRewardBase.addBridgeTokenFeeReceivers (BlockRewardHBBFT.sol#240) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 249,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function addExtraReceiver(uint256 _amount, address _receiver) external onlyErcToNativeBridge {\n",
          "message": "Parameter '_amount' of BlockRewardBase.addExtraReceiver (BlockRewardHBBFT.sol#249) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 249,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function addExtraReceiver(uint256 _amount, address _receiver) external onlyErcToNativeBridge {\n",
          "message": "Parameter '_receiver' of BlockRewardBase.addExtraReceiver (BlockRewardHBBFT.sol#249) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 271,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function migrateMintingStatistics(address _bridge, IBlockReward _prevBlockRewardContract) external onlyOwner {\n",
          "message": "Parameter '_bridge' of BlockRewardBase.migrateMintingStatistics (BlockRewardHBBFT.sol#271) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 271,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function migrateMintingStatistics(address _bridge, IBlockReward _prevBlockRewardContract) external onlyOwner {\n",
          "message": "Parameter '_prevBlockRewardContract' of BlockRewardBase.migrateMintingStatistics (BlockRewardHBBFT.sol#271) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 284,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setErcToNativeBridgesAllowed(address[] calldata _bridgesAllowed) external onlyOwner onlyInitialized {\n",
          "message": "Parameter '_bridgesAllowed' of BlockRewardBase.setErcToNativeBridgesAllowed (BlockRewardHBBFT.sol#284) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 302,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setNativeToErcBridgesAllowed(address[] calldata _bridgesAllowed) external onlyOwner onlyInitialized {\n",
          "message": "Parameter '_bridgesAllowed' of BlockRewardBase.setNativeToErcBridgesAllowed (BlockRewardHBBFT.sol#302) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 320,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setErcToErcBridgesAllowed(address[] calldata _bridgesAllowed) external onlyOwner onlyInitialized {\n",
          "message": "Parameter '_bridgesAllowed' of BlockRewardBase.setErcToErcBridgesAllowed (BlockRewardHBBFT.sol#320) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 390,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function mintedForAccount(address _account) public view returns(uint256) {\n",
          "message": "Parameter '_account' of BlockRewardBase.mintedForAccount (BlockRewardHBBFT.sol#390) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 398,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function mintedForAccountInBlock(address _account, uint256 _blockNumber)\n",
          "message": "Parameter '_account' of BlockRewardBase.mintedForAccountInBlock (BlockRewardHBBFT.sol#398) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 398,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function mintedForAccountInBlock(address _account, uint256 _blockNumber)\n",
          "message": "Parameter '_blockNumber' of BlockRewardBase.mintedForAccountInBlock (BlockRewardHBBFT.sol#398) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 411,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function mintedInBlock(uint256 _blockNumber) public view returns(uint256) {\n",
          "message": "Parameter '_blockNumber' of BlockRewardBase.mintedInBlock (BlockRewardHBBFT.sol#411) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 441,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function snapshotRewardPercents(address _validatorStakingAddress) public view returns(uint256[] memory) {\n",
          "message": "Parameter '_validatorStakingAddress' of BlockRewardBase.snapshotRewardPercents (BlockRewardHBBFT.sol#441) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 452,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function snapshotStakers(address _validatorStakingAddress) public view returns(address[] memory) {\n",
          "message": "Parameter '_validatorStakingAddress' of BlockRewardBase.snapshotStakers (BlockRewardHBBFT.sol#452) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 521,
          "vulnerability_to_line": 557,
          "vulnerability_code": "    function _mintNativeCoins(\n\n        address[] memory _receivers,\n\n        uint256[] memory _rewards,\n\n        uint256 _queueLimit\n\n    )\n\n        internal\n\n        returns(address[] memory receivers, uint256[] memory rewards)\n\n    {\n\n        uint256 extraLength = extraReceiversQueueSize();\n\n\n\n        if (extraLength > _queueLimit) {\n\n            extraLength = _queueLimit;\n\n        }\n\n\n\n        receivers = new address[](extraLength + _receivers.length);\n\n        rewards = new uint256[](receivers.length);\n\n\n\n        uint256 i;\n\n        uint256 j = 0;\n\n\n\n        for (i = 0; i < extraLength; i++) {\n\n            (uint256 amount, address receiver, address bridge) = _dequeueExtraReceiver();\n\n            receivers[i] = receiver;\n\n            rewards[i] = amount;\n\n            _setMinted(amount, receiver, bridge);\n\n        }\n\n\n\n        for (i = extraLength; i < receivers.length; i++) {\n\n            receivers[i] = _receivers[j];\n\n            rewards[i] = _rewards[j];\n\n            j++;\n\n        }\n\n\n\n        emit MintedNative(receivers, rewards);\n\n\n\n        return (receivers, rewards);\n",
          "message": "Function 'BlockRewardBase._mintNativeCoins' (BlockRewardHBBFT.sol#521-557) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 522,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address[] memory _receivers,\n",
          "message": "Parameter '_receivers' of BlockRewardBase._mintNativeCoins (BlockRewardHBBFT.sol#522) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 523,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint256[] memory _rewards,\n",
          "message": "Parameter '_rewards' of BlockRewardBase._mintNativeCoins (BlockRewardHBBFT.sol#523) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 524,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint256 _queueLimit\n",
          "message": "Parameter '_queueLimit' of BlockRewardBase._mintNativeCoins (BlockRewardHBBFT.sol#524) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 564,
          "vulnerability_to_line": 584,
          "vulnerability_code": "    function _dequeueExtraReceiver() internal returns(uint256 amount, address receiver, address bridge) {\n\n        uint256 queueFirst = uintStorage[QUEUE_ER_FIRST];\n\n        uint256 queueLast = uintStorage[QUEUE_ER_LAST];\n\n\n\n        if (queueLast < queueFirst) {\n\n            amount = 0;\n\n            receiver = address(0);\n\n            bridge = address(0);\n\n        } else {\n\n            bytes32 amountHash = keccak256(abi.encode(QUEUE_ER_AMOUNT, queueFirst));\n\n            bytes32 receiverHash = keccak256(abi.encode(QUEUE_ER_RECEIVER, queueFirst));\n\n            bytes32 bridgeHash = keccak256(abi.encode(QUEUE_ER_BRIDGE, queueFirst));\n\n            amount = uintStorage[amountHash];\n\n            receiver = addressStorage[receiverHash];\n\n            bridge = addressStorage[bridgeHash];\n\n            delete uintStorage[amountHash];\n\n            delete addressStorage[receiverHash];\n\n            delete addressStorage[bridgeHash];\n\n            uintStorage[QUEUE_ER_FIRST]++;\n\n        }\n",
          "message": "Function 'BlockRewardBase._dequeueExtraReceiver' (BlockRewardHBBFT.sol#564-584) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 591,
          "vulnerability_to_line": 597,
          "vulnerability_code": "    function _enqueueExtraReceiver(uint256 _amount, address _receiver, address _bridge) internal {\n\n        uint256 queueLast = uintStorage[QUEUE_ER_LAST] + 1;\n\n        uintStorage[keccak256(abi.encode(QUEUE_ER_AMOUNT, queueLast))] = _amount;\n\n        addressStorage[keccak256(abi.encode(QUEUE_ER_RECEIVER, queueLast))] = _receiver;\n\n        addressStorage[keccak256(abi.encode(QUEUE_ER_BRIDGE, queueLast))] = _bridge;\n\n        uintStorage[QUEUE_ER_LAST] = queueLast;\n",
          "message": "Function 'BlockRewardBase._enqueueExtraReceiver' (BlockRewardHBBFT.sol#591-597) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 591,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _enqueueExtraReceiver(uint256 _amount, address _receiver, address _bridge) internal {\n",
          "message": "Parameter '_amount' of BlockRewardBase._enqueueExtraReceiver (BlockRewardHBBFT.sol#591) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 591,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _enqueueExtraReceiver(uint256 _amount, address _receiver, address _bridge) internal {\n",
          "message": "Parameter '_receiver' of BlockRewardBase._enqueueExtraReceiver (BlockRewardHBBFT.sol#591) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 591,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _enqueueExtraReceiver(uint256 _amount, address _receiver, address _bridge) internal {\n",
          "message": "Parameter '_bridge' of BlockRewardBase._enqueueExtraReceiver (BlockRewardHBBFT.sol#591) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 604,
          "vulnerability_to_line": 610,
          "vulnerability_code": "    function _setMinted(uint256 _amount, address _account, address _bridge) internal {\n\n        uintStorage[keccak256(abi.encode(MINTED_FOR_ACCOUNT_IN_BLOCK, _account, block.number))] = _amount;\n\n        uintStorage[keccak256(abi.encode(MINTED_FOR_ACCOUNT, _account))] += _amount;\n\n        uintStorage[keccak256(abi.encode(MINTED_IN_BLOCK, block.number))] += _amount;\n\n        uintStorage[keccak256(abi.encode(MINTED_TOTALLY_BY_BRIDGE, _bridge))] += _amount;\n\n        uintStorage[MINTED_TOTALLY] += _amount;\n",
          "message": "Function 'BlockRewardBase._setMinted' (BlockRewardHBBFT.sol#604-610) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 604,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setMinted(uint256 _amount, address _account, address _bridge) internal {\n",
          "message": "Parameter '_amount' of BlockRewardBase._setMinted (BlockRewardHBBFT.sol#604) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 604,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setMinted(uint256 _amount, address _account, address _bridge) internal {\n",
          "message": "Parameter '_account' of BlockRewardBase._setMinted (BlockRewardHBBFT.sol#604) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 604,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setMinted(uint256 _amount, address _account, address _bridge) internal {\n",
          "message": "Parameter '_bridge' of BlockRewardBase._setMinted (BlockRewardHBBFT.sol#604) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 621,
          "vulnerability_to_line": 682,
          "vulnerability_code": "    function _setSnapshot(address _stakingAddress, IStaking _stakingContract, uint256 _offset) internal {\n\n        uint256 validatorStake = _stakingContract.stakeAmountMinusOrderedWithdraw(_stakingAddress, _stakingAddress);\n\n        uint256 totalStaked = _stakingContract.stakeAmountTotalMinusOrderedWithdraw(_stakingAddress);\n\n        uint256 delegatorsAmount = totalStaked >= validatorStake ? totalStaked - validatorStake : 0;\n\n        bool validatorHasMore30Per = validatorStake * 7 > delegatorsAmount * 3;\n\n\n\n        address[] memory delegators = _stakingContract.poolDelegators(_stakingAddress);\n\n        uint256 rewardPercent;\n\n\n\n        address[] storage stakers = addressArrayStorage[keccak256(abi.encode(\n\n            SNAPSHOT_STAKERS, _stakingAddress\n\n        ))];\n\n\n\n        uint256[] storage rewardPercents = uintArrayStorage[keccak256(abi.encode(\n\n            SNAPSHOT_REWARD_PERCENTS, _stakingAddress\n\n        ))];\n\n\n\n        if (_offset == 0) {\n\n            // Calculate reward percent for validator\n\n            rewardPercent = 0;\n\n            if (validatorStake != 0 && totalStaked != 0) {\n\n                if (validatorHasMore30Per) {\n\n                    rewardPercent = REWARD_PERCENT_MULTIPLIER * validatorStake / totalStaked;\n\n                } else {\n\n                    rewardPercent = REWARD_PERCENT_MULTIPLIER * 3 / 10;\n\n                }\n\n            }\n\n            stakers.push(_stakingAddress);\n\n            rewardPercents.push(rewardPercent);\n\n            addressArrayStorage[SNAPSHOT_STAKING_ADDRESSES].push(_stakingAddress);\n\n            uintStorage[SNAPSHOT_TOTAL_STAKE_AMOUNT] += totalStaked;\n\n        }\n\n\n\n        uint256 from = _offset * delegators.length / DELEGATORS_ALIQUOT;\n\n        uint256 to = (_offset + 1) * delegators.length / DELEGATORS_ALIQUOT;\n\n\n\n        if (_offset == 0) {\n\n            to += delegators.length % DELEGATORS_ALIQUOT;\n\n        } else {\n\n            from += delegators.length % DELEGATORS_ALIQUOT;\n\n        }\n\n\n\n        // Calculate reward percent for each delegator\n\n        for (uint256 i = from; i < to; i++) {\n\n            rewardPercent = 0;\n\n\n\n            if (validatorHasMore30Per) {\n\n                if (totalStaked != 0) {\n\n                    rewardPercent = _stakingContract.stakeAmountMinusOrderedWithdraw(_stakingAddress, delegators[i]);\n\n                    rewardPercent = REWARD_PERCENT_MULTIPLIER * rewardPercent / totalStaked;\n\n                }\n\n            } else {\n\n                if (delegatorsAmount != 0) {\n\n                    rewardPercent = _stakingContract.stakeAmountMinusOrderedWithdraw(_stakingAddress, delegators[i]);\n\n                    rewardPercent = REWARD_PERCENT_MULTIPLIER * rewardPercent * 7 / (delegatorsAmount * 10);\n\n                }\n\n            }\n\n\n\n            stakers.push(delegators[i]);\n\n            rewardPercents.push(rewardPercent);\n\n        }\n",
          "message": "Function 'BlockRewardBase._setSnapshot' (BlockRewardHBBFT.sol#621-682) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 621,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setSnapshot(address _stakingAddress, IStaking _stakingContract, uint256 _offset) internal {\n",
          "message": "Parameter '_stakingAddress' of BlockRewardBase._setSnapshot (BlockRewardHBBFT.sol#621) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 621,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setSnapshot(address _stakingAddress, IStaking _stakingContract, uint256 _offset) internal {\n",
          "message": "Parameter '_stakingContract' of BlockRewardBase._setSnapshot (BlockRewardHBBFT.sol#621) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 621,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setSnapshot(address _stakingAddress, IStaking _stakingContract, uint256 _offset) internal {\n",
          "message": "Parameter '_offset' of BlockRewardBase._setSnapshot (BlockRewardHBBFT.sol#621) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 699,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function balanceOf(address) external view returns(uint256);\n",
          "message": "Parameter '' of IERC20Minting.balanceOf (BlockRewardHBBFT.sol#699) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 721,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function reward(address[] calldata, uint16[] calldata)\n",
          "message": "Parameter '' of BlockRewardHBBFT.reward (BlockRewardHBBFT.sol#721) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 721,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function reward(address[] calldata, uint16[] calldata)\n",
          "message": "Parameter '_scope_0' of BlockRewardHBBFT.reward (BlockRewardHBBFT.sol#721) is not in mixedCase\n"
        },
        {
          "name": "unused-state",
          "vulnerability_from_line": 84,
          "vulnerability_to_line": null,
          "vulnerability_code": "    mapping(bytes32 => string) internal stringStorage;\n",
          "message": "EternalStorage.stringStorage (BlockRewardHBBFT.sol#84) is never used in BlockRewardHBBFT\nEternalStorage.bytesStorage (BlockRewardHBBFT.sol#86) is never used in BlockRewardHBBFT\nEternalStorage.intStorage (BlockRewardHBBFT.sol#88) is never used in BlockRewardHBBFT\nEternalStorage.bytes32Storage (BlockRewardHBBFT.sol#89) is never used in BlockRewardHBBFT\nEternalStorage.stringArrayStorage (BlockRewardHBBFT.sol#92) is never used in BlockRewardHBBFT\nEternalStorage.bytesArrayStorage (BlockRewardHBBFT.sol#94) is never used in BlockRewardHBBFT\nEternalStorage.boolArrayStorage (BlockRewardHBBFT.sol#95) is never used in BlockRewardHBBFT\nEternalStorage.intArrayStorage (BlockRewardHBBFT.sol#96) is never used in BlockRewardHBBFT\nEternalStorage.bytes32ArrayStorage (BlockRewardHBBFT.sol#97) is never used in BlockRewardHBBFT\n"
        }
      ]
    },
    "smartcheck": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 221,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == 0xffffFFFfFFffffffffffffffFfFFFfffFFFfFFfE);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 570,
          "vulnerability_to_line": null,
          "vulnerability_code": "            receiver = address(0);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 571,
          "vulnerability_to_line": null,
          "vulnerability_code": "            bridge = address(0);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 288,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (i = 0; i < oldBridgesAllowed.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 294,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (i = 0; i < _bridgesAllowed.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 306,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (i = 0; i < oldBridgesAllowed.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 312,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (i = 0; i < _bridgesAllowed.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 324,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (i = 0; i < oldBridgesAllowed.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 330,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (i = 0; i < _bridgesAllowed.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 548,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (i = extraLength; i < receivers.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 288,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (i = 0; i < oldBridgesAllowed.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 294,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (i = 0; i < _bridgesAllowed.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 306,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (i = 0; i < oldBridgesAllowed.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 312,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (i = 0; i < _bridgesAllowed.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 324,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (i = 0; i < oldBridgesAllowed.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 330,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (i = 0; i < _bridgesAllowed.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_OVERPOWERED_ROLE",
          "vulnerability_from_line": 284,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setErcToNativeBridgesAllowed(address[] calldata _bridgesAllowed) external onlyOwner onlyInitialized {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_OVERPOWERED_ROLE",
          "vulnerability_from_line": 302,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setNativeToErcBridgesAllowed(address[] calldata _bridgesAllowed) external onlyOwner onlyInitialized {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_OVERPOWERED_ROLE",
          "vulnerability_from_line": 320,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setErcToErcBridgesAllowed(address[] calldata _bridgesAllowed) external onlyOwner onlyInitialized {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SAFEMATH",
          "vulnerability_from_line": 168,
          "vulnerability_to_line": null,
          "vulnerability_code": "    using SafeMath for uint256;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 29,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function newValidatorSet() external returns(bool, uint256);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 61,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getPoolsLikelihood() external view returns(int256[] memory, int256);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 527,
          "vulnerability_to_line": null,
          "vulnerability_code": "        returns(address[] memory receivers, uint256[] memory rewards)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 564,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _dequeueExtraReceiver() internal returns(uint256 amount, address receiver, address bridge) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 724,
          "vulnerability_to_line": null,
          "vulnerability_code": "        returns (address[] memory, uint256[] memory)\n",
          "message": null
        }
      ]
    },
    "oyente": {
      "successfull_analysis": false,
      "errors": [
        "exception (IndexError: pop from empty list)"
      ],
      "vulnerability_findings": []
    },
    "mythril": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": []
    },
    "osiris": {
      "successfull_analysis": false,
      "errors": [
        "UNKNOWN INSTRUCTION: SHR",
        "exception (IndexError: pop from empty list)"
      ],
      "vulnerability_findings": []
    }
  }
}