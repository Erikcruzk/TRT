{
  "smartbugs_completed": true,
  "analyzer_results": {
    "semgrep": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 364,
          "vulnerability_to_line": null,
          "vulnerability_code": "            for (i = 0; i < validators.length; i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 385,
          "vulnerability_to_line": null,
          "vulnerability_code": "            for (i = 0; i < validators.length; i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 541,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 i = 0; i < miningAddresses.length; i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 541,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 i = 0; i < miningAddresses.length; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 360,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (applyBlock != 0 && _getCurrentBlockNumber() > applyBlock + collectRoundLength() * 2) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 361,
          "vulnerability_to_line": null,
          "vulnerability_code": "            // Check whether each validator didn't reveal their secret\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 362,
          "vulnerability_to_line": null,
          "vulnerability_code": "            // during the current collection round\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 363,
          "vulnerability_to_line": null,
          "vulnerability_code": "            validators = validatorSetContract().getValidators();\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 364,
          "vulnerability_to_line": null,
          "vulnerability_code": "            for (i = 0; i < validators.length; i++) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 365,
          "vulnerability_to_line": null,
          "vulnerability_code": "                validator = validators[i];\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 366,
          "vulnerability_to_line": null,
          "vulnerability_code": "                if (!sentReveal(currentRound, validator)) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 367,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    _incrementRevealSkips(stakingEpoch, validator);\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 368,
          "vulnerability_to_line": null,
          "vulnerability_code": "                }\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 369,
          "vulnerability_to_line": null,
          "vulnerability_code": "            }\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-prefix-decrement-not-postfix",
          "vulnerability_from_line": 378,
          "vulnerability_to_line": null,
          "vulnerability_code": "                maxRevealSkipsAllowed--;\n",
          "message": "Consider using the prefix decrement expression whenever the return value is not needed. The prefix decrement expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 364,
          "vulnerability_to_line": null,
          "vulnerability_code": "            for (i = 0; i < validators.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 385,
          "vulnerability_to_line": null,
          "vulnerability_code": "            for (i = 0; i < validators.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 541,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 i = 0; i < miningAddresses.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 561,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uintStorage[keccak256(abi.encode(REVEAL_SKIPS, _stakingEpoch, _miningAddress))]++;\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        }
      ]
    },
    "slither": {
      "successfull_analysis": true,
      "errors": [
        "EXIT_CODE_97"
      ],
      "vulnerability_findings": [
        {
          "name": "uninitialized-state",
          "vulnerability_from_line": 55,
          "vulnerability_to_line": null,
          "vulnerability_code": "    address internal _owner;\n",
          "message": "EternalStorage._owner (RandomAuRa.sol#55) is never initialized. It is used in:\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 298,
          "vulnerability_to_line": 309,
          "vulnerability_code": "    function commitHash(bytes32 _secretHash, bytes calldata _cipher) external onlyInitialized {\n\n        address miningAddress = msg.sender;\n\n\n\n        require(commitHashCallable(miningAddress, _secretHash));\n\n        require(_getCoinbase() == miningAddress); // make sure validator node is live\n\n\n\n        uint256 collectRound = currentCollectRound();\n\n\n\n        _setCommit(collectRound, miningAddress, _secretHash);\n\n        _setCipher(collectRound, miningAddress, _cipher);\n\n        _addCommittedValidator(collectRound, miningAddress);\n",
          "message": "Reentrancy in RandomAuRa.commitHash (RandomAuRa.sol#298-309):\n\tExternal calls:\n\t- require(bool)(commitHashCallable(miningAddress,_secretHash)) (RandomAuRa.sol#301)\n\tState variables written after the call(s):\n\t- bytes32Storage (RandomAuRa.sol#306)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 344,
          "vulnerability_to_line": 399,
          "vulnerability_code": "    function onFinishCollectRound() external onlyBlockReward {\n\n        if (_getCurrentBlockNumber() % collectRoundLength() != collectRoundLength() - 1) return;\n\n\n\n        // This is the last block of the current collection round\n\n\n\n        address[] memory validators;\n\n        address validator;\n\n        uint256 i;\n\n\n\n        address stakingContract = validatorSetContract().stakingContract();\n\n\n\n        uint256 stakingEpoch = IStaking(stakingContract).stakingEpoch();\n\n        uint256 applyBlock = validatorSetContract().validatorSetApplyBlock();\n\n        uint256 endBlock = IStakingAuRa(stakingContract).stakingEpochEndBlock();\n\n        uint256 currentRound = currentCollectRound();\n\n\n\n        if (applyBlock != 0 && _getCurrentBlockNumber() > applyBlock + collectRoundLength() * 2) {\n\n            // Check whether each validator didn't reveal their secret\n\n            // during the current collection round\n\n            validators = validatorSetContract().getValidators();\n\n            for (i = 0; i < validators.length; i++) {\n\n                validator = validators[i];\n\n                if (!sentReveal(currentRound, validator)) {\n\n                    _incrementRevealSkips(stakingEpoch, validator);\n\n                }\n\n            }\n\n        }\n\n\n\n        // If this is the last collection round in the current staking epoch.\n\n        if (_getCurrentBlockNumber() == endBlock || _getCurrentBlockNumber() + collectRoundLength() > endBlock) {\n\n            uint256 maxRevealSkipsAllowed =\n\n                IStakingAuRa(stakingContract).stakeWithdrawDisallowPeriod() / collectRoundLength();\n\n\n\n            if (maxRevealSkipsAllowed > 0) {\n\n                maxRevealSkipsAllowed--;\n\n            }\n\n\n\n            // Check each validator to see if they didn't reveal\n\n            // their secret during the last full `reveals phase`\n\n            // or if they missed the required number of reveals per staking epoch.\n\n            validators = validatorSetContract().getValidators();\n\n            for (i = 0; i < validators.length; i++) {\n\n                validator = validators[i];\n\n                if (\n\n                    !sentReveal(currentRound, validator) ||\n\n                    revealSkips(stakingEpoch, validator) > maxRevealSkipsAllowed\n\n                ) {\n\n                    // Remove the validator as malicious\n\n                    IValidatorSetAuRa(address(validatorSetContract())).removeMaliciousValidator(validator);\n\n                }\n\n            }\n\n        }\n\n\n\n        // Clear unnecessary info about previous collection round.\n\n        _clearOldCiphers(currentRound);\n",
          "message": "Reentrancy in RandomAuRa.onFinishCollectRound (RandomAuRa.sol#344-399):\n\tExternal calls:\n\t- stakingContract = validatorSetContract().stakingContract() (RandomAuRa.sol#353)\n\t- stakingEpoch = IStaking(stakingContract).stakingEpoch() (RandomAuRa.sol#355)\n\t- applyBlock = validatorSetContract().validatorSetApplyBlock() (RandomAuRa.sol#356)\n\t- endBlock = IStakingAuRa(stakingContract).stakingEpochEndBlock() (RandomAuRa.sol#357)\n\t- validators = validatorSetContract().getValidators() (RandomAuRa.sol#363)\n\tState variables written after the call(s):\n\t- uintStorage (RandomAuRa.sol#367)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 315,
          "vulnerability_to_line": 323,
          "vulnerability_code": "    function revealSecret(uint256 _secret) external onlyInitialized {\n\n        address miningAddress = msg.sender;\n\n\n\n        require(revealSecretCallable(miningAddress, _secret));\n\n        require(_getCoinbase() == miningAddress); // make sure validator node is live\n\n\n\n        _setCurrentSeed(_getCurrentSeed() ^ _secret);\n\n        _setSentReveal(currentCollectRound(), miningAddress);\n",
          "message": "Reentrancy in RandomAuRa.revealSecret (RandomAuRa.sol#315-323):\n\tExternal calls:\n\t- require(bool)(revealSecretCallable(miningAddress,_secret)) (RandomAuRa.sol#318)\n\tState variables written after the call(s):\n\t- boolStorage (RandomAuRa.sol#322)\n\t- uintStorage (RandomAuRa.sol#321)\n"
        },
        {
          "name": "calls-loop",
          "vulnerability_from_line": 392,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    IValidatorSetAuRa(address(validatorSetContract())).removeMaliciousValidator(validator);\n",
          "message": "RandomAuRa.onFinishCollectRound has external calls inside a loop:\n\t- IValidatorSetAuRa(address(validatorSetContract())).removeMaliciousValidator(validator) (RandomAuRa.sol#392)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 298,
          "vulnerability_to_line": 309,
          "vulnerability_code": "    function commitHash(bytes32 _secretHash, bytes calldata _cipher) external onlyInitialized {\n\n        address miningAddress = msg.sender;\n\n\n\n        require(commitHashCallable(miningAddress, _secretHash));\n\n        require(_getCoinbase() == miningAddress); // make sure validator node is live\n\n\n\n        uint256 collectRound = currentCollectRound();\n\n\n\n        _setCommit(collectRound, miningAddress, _secretHash);\n\n        _setCipher(collectRound, miningAddress, _cipher);\n\n        _addCommittedValidator(collectRound, miningAddress);\n",
          "message": "Reentrancy in RandomAuRa.commitHash (RandomAuRa.sol#298-309):\n\tExternal calls:\n\t- require(bool)(commitHashCallable(miningAddress,_secretHash)) (RandomAuRa.sol#301)\n\tState variables written after the call(s):\n\t- addressArrayStorage (RandomAuRa.sol#308)\n\t- bytesStorage (RandomAuRa.sol#307)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 344,
          "vulnerability_to_line": 399,
          "vulnerability_code": "    function onFinishCollectRound() external onlyBlockReward {\n\n        if (_getCurrentBlockNumber() % collectRoundLength() != collectRoundLength() - 1) return;\n\n\n\n        // This is the last block of the current collection round\n\n\n\n        address[] memory validators;\n\n        address validator;\n\n        uint256 i;\n\n\n\n        address stakingContract = validatorSetContract().stakingContract();\n\n\n\n        uint256 stakingEpoch = IStaking(stakingContract).stakingEpoch();\n\n        uint256 applyBlock = validatorSetContract().validatorSetApplyBlock();\n\n        uint256 endBlock = IStakingAuRa(stakingContract).stakingEpochEndBlock();\n\n        uint256 currentRound = currentCollectRound();\n\n\n\n        if (applyBlock != 0 && _getCurrentBlockNumber() > applyBlock + collectRoundLength() * 2) {\n\n            // Check whether each validator didn't reveal their secret\n\n            // during the current collection round\n\n            validators = validatorSetContract().getValidators();\n\n            for (i = 0; i < validators.length; i++) {\n\n                validator = validators[i];\n\n                if (!sentReveal(currentRound, validator)) {\n\n                    _incrementRevealSkips(stakingEpoch, validator);\n\n                }\n\n            }\n\n        }\n\n\n\n        // If this is the last collection round in the current staking epoch.\n\n        if (_getCurrentBlockNumber() == endBlock || _getCurrentBlockNumber() + collectRoundLength() > endBlock) {\n\n            uint256 maxRevealSkipsAllowed =\n\n                IStakingAuRa(stakingContract).stakeWithdrawDisallowPeriod() / collectRoundLength();\n\n\n\n            if (maxRevealSkipsAllowed > 0) {\n\n                maxRevealSkipsAllowed--;\n\n            }\n\n\n\n            // Check each validator to see if they didn't reveal\n\n            // their secret during the last full `reveals phase`\n\n            // or if they missed the required number of reveals per staking epoch.\n\n            validators = validatorSetContract().getValidators();\n\n            for (i = 0; i < validators.length; i++) {\n\n                validator = validators[i];\n\n                if (\n\n                    !sentReveal(currentRound, validator) ||\n\n                    revealSkips(stakingEpoch, validator) > maxRevealSkipsAllowed\n\n                ) {\n\n                    // Remove the validator as malicious\n\n                    IValidatorSetAuRa(address(validatorSetContract())).removeMaliciousValidator(validator);\n\n                }\n\n            }\n\n        }\n\n\n\n        // Clear unnecessary info about previous collection round.\n\n        _clearOldCiphers(currentRound);\n",
          "message": "Reentrancy in RandomAuRa.onFinishCollectRound (RandomAuRa.sol#344-399):\n\tExternal calls:\n\t- stakingContract = validatorSetContract().stakingContract() (RandomAuRa.sol#353)\n\t- stakingEpoch = IStaking(stakingContract).stakingEpoch() (RandomAuRa.sol#355)\n\t- applyBlock = validatorSetContract().validatorSetApplyBlock() (RandomAuRa.sol#356)\n\t- endBlock = IStakingAuRa(stakingContract).stakingEpochEndBlock() (RandomAuRa.sol#357)\n\t- validators = validatorSetContract().getValidators() (RandomAuRa.sol#363)\n\t- maxRevealSkipsAllowed = IStakingAuRa(stakingContract).stakeWithdrawDisallowPeriod() / collectRoundLength() (RandomAuRa.sol#374-375)\n\t- validators = validatorSetContract().getValidators() (RandomAuRa.sol#384)\n\tState variables written after the call(s):\n\t- bytesStorage (RandomAuRa.sol#398)\n"
        },
        {
          "name": "constable-states",
          "vulnerability_from_line": 55,
          "vulnerability_to_line": null,
          "vulnerability_code": "    address internal _owner;\n",
          "message": "EternalStorage._owner should be constant (RandomAuRa.sol#55)\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 422,
          "vulnerability_to_line": 424,
          "vulnerability_code": "    function getCipher(uint256 _collectRound, address _miningAddress) public view returns(bytes memory) {\n\n        return bytesStorage[keccak256(abi.encode(CIPHERS, _collectRound, _miningAddress))];\n",
          "message": "RandomAuRa.getCipher (RandomAuRa.sol#422-424) should be declared external\n"
        },
        {
          "name": "solc-version",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity 0.5.9;\n",
          "message": "Detected issues with version pragma in RandomAuRa.sol:\n\t- pragma solidity0.5.9 (RandomAuRa.sol#3): it allows old versions\n\t- pragma solidity0.5.9 (RandomAuRa.sol#12): it allows old versions\n\t- pragma solidity0.5.9 (RandomAuRa.sol#47): it allows old versions\n\t- pragma solidity0.5.9 (RandomAuRa.sol#78): it allows old versions\n\t- pragma solidity0.5.9 (RandomAuRa.sol#96): it allows old versions\n\t- pragma solidity0.5.9 (RandomAuRa.sol#135): it allows old versions\n\t- pragma solidity0.5.9 (RandomAuRa.sol#206): it allows old versions\n\t- pragma solidity0.5.9 (RandomAuRa.sol#218): it allows old versions\n\t- pragma solidity0.5.9 (RandomAuRa.sol#228): it allows old versions\n\t- pragma solidity0.5.9 (RandomAuRa.sol#248): it allows old versions\n\t- pragma solidity0.5.9 (RandomAuRa.sol#270): it allows old versions\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 17,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address,\n",
          "message": "Parameter '' of IValidatorSet.initialize (RandomAuRa.sol#17) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 18,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address,\n",
          "message": "Parameter '_scope_0' of IValidatorSet.initialize (RandomAuRa.sol#18) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 19,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address,\n",
          "message": "Parameter '_scope_1' of IValidatorSet.initialize (RandomAuRa.sol#19) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 20,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address[] calldata,\n",
          "message": "Parameter '_scope_2' of IValidatorSet.initialize (RandomAuRa.sol#20) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 21,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address[] calldata,\n",
          "message": "Parameter '_scope_3' of IValidatorSet.initialize (RandomAuRa.sol#21) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 22,
          "vulnerability_to_line": null,
          "vulnerability_code": "        bool\n",
          "message": "Parameter '_scope_4' of IValidatorSet.initialize (RandomAuRa.sol#22) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 25,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setStakingAddress(address, address) external;\n",
          "message": "Parameter '' of IValidatorSet.setStakingAddress (RandomAuRa.sol#25) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 25,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setStakingAddress(address, address) external;\n",
          "message": "Parameter '_scope_0' of IValidatorSet.setStakingAddress (RandomAuRa.sol#25) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 32,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function isReportValidatorValid(address) external view returns(bool);\n",
          "message": "Parameter '' of IValidatorSet.isReportValidatorValid (RandomAuRa.sol#32) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 33,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function isValidator(address) external view returns(bool);\n",
          "message": "Parameter '' of IValidatorSet.isValidator (RandomAuRa.sol#33) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 34,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function isValidatorBanned(address) external view returns(bool);\n",
          "message": "Parameter '' of IValidatorSet.isValidatorBanned (RandomAuRa.sol#34) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 35,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function MAX_VALIDATORS() external view returns(uint256); // solhint-disable-line func-name-mixedcase\n",
          "message": "Function 'IValidatorSet.MAX_VALIDATORS' (RandomAuRa.sol#35) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 36,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function miningByStakingAddress(address) external view returns(address);\n",
          "message": "Parameter '' of IValidatorSet.miningByStakingAddress (RandomAuRa.sol#36) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 38,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function stakingByMiningAddress(address) external view returns(address);\n",
          "message": "Parameter '' of IValidatorSet.stakingByMiningAddress (RandomAuRa.sol#38) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 41,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function validatorIndex(address) external view returns(uint256);\n",
          "message": "Parameter '' of IValidatorSet.validatorIndex (RandomAuRa.sol#41) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 55,
          "vulnerability_to_line": null,
          "vulnerability_code": "    address internal _owner;\n",
          "message": "Variable 'EternalStorage._owner' (RandomAuRa.sol#55) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 185,
          "vulnerability_to_line": 189,
          "vulnerability_code": "    function _initialize(address _validatorSet) internal {\n\n        require(!isInitialized());\n\n        require(_validatorSet != address(0));\n\n        addressStorage[VALIDATOR_SET_CONTRACT] = _validatorSet;\n",
          "message": "Function 'RandomBase._initialize' (RandomAuRa.sol#185-189) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 185,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _initialize(address _validatorSet) internal {\n",
          "message": "Parameter '_validatorSet' of RandomBase._initialize (RandomAuRa.sol#185) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 193,
          "vulnerability_to_line": 195,
          "vulnerability_code": "    function _setCurrentSeed(uint256 _seed) internal {\n\n        uintStorage[CURRENT_SEED] = _seed;\n",
          "message": "Function 'RandomBase._setCurrentSeed' (RandomAuRa.sol#193-195) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 193,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setCurrentSeed(uint256 _seed) internal {\n",
          "message": "Parameter '_seed' of RandomBase._setCurrentSeed (RandomAuRa.sol#193) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 198,
          "vulnerability_to_line": 200,
          "vulnerability_code": "    function _getCurrentSeed() internal view returns(uint256) {\n\n        return uintStorage[CURRENT_SEED];\n",
          "message": "Function 'RandomBase._getCurrentSeed' (RandomAuRa.sol#198-200) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 210,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function initialize(uint256, address) external;\n",
          "message": "Parameter '' of IRandomAuRa.initialize (RandomAuRa.sol#210) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 210,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function initialize(uint256, address) external;\n",
          "message": "Parameter '_scope_0' of IRandomAuRa.initialize (RandomAuRa.sol#210) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 212,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function commitHashCallable(address, bytes32) external view returns(bool);\n",
          "message": "Parameter '' of IRandomAuRa.commitHashCallable (RandomAuRa.sol#212) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 212,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function commitHashCallable(address, bytes32) external view returns(bool);\n",
          "message": "Parameter '_scope_0' of IRandomAuRa.commitHashCallable (RandomAuRa.sol#212) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 213,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function revealSecretCallable(address, uint256) external view returns(bool);\n",
          "message": "Parameter '' of IRandomAuRa.revealSecretCallable (RandomAuRa.sol#213) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 213,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function revealSecretCallable(address, uint256) external view returns(bool);\n",
          "message": "Parameter '_scope_0' of IRandomAuRa.revealSecretCallable (RandomAuRa.sol#213) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 222,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function removeMaliciousValidator(address) external;\n",
          "message": "Parameter '' of IValidatorSetAuRa.removeMaliciousValidator (RandomAuRa.sol#222) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 223,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function reportMaliciousCallable(address, address, uint256) external view returns(bool, bool);\n",
          "message": "Parameter '' of IValidatorSetAuRa.reportMaliciousCallable (RandomAuRa.sol#223) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 223,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function reportMaliciousCallable(address, address, uint256) external view returns(bool, bool);\n",
          "message": "Parameter '_scope_0' of IValidatorSetAuRa.reportMaliciousCallable (RandomAuRa.sol#223) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 223,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function reportMaliciousCallable(address, address, uint256) external view returns(bool, bool);\n",
          "message": "Parameter '_scope_1' of IValidatorSetAuRa.reportMaliciousCallable (RandomAuRa.sol#223) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 232,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function clearUnremovableValidator(address) external;\n",
          "message": "Parameter '' of IStaking.clearUnremovableValidator (RandomAuRa.sol#232) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 234,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function removePool(address) external;\n",
          "message": "Parameter '' of IStaking.removePool (RandomAuRa.sol#234) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 240,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function poolDelegators(address) external view returns(address[] memory);\n",
          "message": "Parameter '' of IStaking.poolDelegators (RandomAuRa.sol#240) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 241,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function stakeAmountMinusOrderedWithdraw(address, address) external view returns(uint256);\n",
          "message": "Parameter '' of IStaking.stakeAmountMinusOrderedWithdraw (RandomAuRa.sol#241) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 241,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function stakeAmountMinusOrderedWithdraw(address, address) external view returns(uint256);\n",
          "message": "Parameter '_scope_0' of IStaking.stakeAmountMinusOrderedWithdraw (RandomAuRa.sol#241) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 242,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function stakeAmountTotalMinusOrderedWithdraw(address) external view returns(uint256);\n",
          "message": "Parameter '' of IStaking.stakeAmountTotalMinusOrderedWithdraw (RandomAuRa.sol#242) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 253,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address,\n",
          "message": "Parameter '' of IStakingAuRa.initialize (RandomAuRa.sol#253) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 254,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address[] calldata,\n",
          "message": "Parameter '_scope_0' of IStakingAuRa.initialize (RandomAuRa.sol#254) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 255,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint256,\n",
          "message": "Parameter '_scope_1' of IStakingAuRa.initialize (RandomAuRa.sol#255) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 256,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint256,\n",
          "message": "Parameter '_scope_2' of IStakingAuRa.initialize (RandomAuRa.sol#256) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 257,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint256,\n",
          "message": "Parameter '_scope_3' of IStakingAuRa.initialize (RandomAuRa.sol#257) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 258,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint256,\n",
          "message": "Parameter '_scope_4' of IStakingAuRa.initialize (RandomAuRa.sol#258) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 259,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint256,\n",
          "message": "Parameter '_scope_5' of IStakingAuRa.initialize (RandomAuRa.sol#259) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 260,
          "vulnerability_to_line": null,
          "vulnerability_code": "        bool\n",
          "message": "Parameter '_scope_6' of IStakingAuRa.initialize (RandomAuRa.sol#260) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 262,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setStakingEpochStartBlock(uint256) external;\n",
          "message": "Parameter '' of IStakingAuRa.setStakingEpochStartBlock (RandomAuRa.sol#262) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 330,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint256 _collectRoundLength, // in blocks\n",
          "message": "Parameter '_collectRoundLength' of RandomAuRa.initialize (RandomAuRa.sol#330) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 331,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address _validatorSet\n",
          "message": "Parameter '_validatorSet' of RandomAuRa.initialize (RandomAuRa.sol#331) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 460,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function commitHashCallable(address _miningAddress, bytes32 _secretHash) public view returns(bool) {\n",
          "message": "Parameter '_miningAddress' of RandomAuRa.commitHashCallable (RandomAuRa.sol#460) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 460,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function commitHashCallable(address _miningAddress, bytes32 _secretHash) public view returns(bool) {\n",
          "message": "Parameter '_secretHash' of RandomAuRa.commitHashCallable (RandomAuRa.sol#460) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 476,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function revealSecretCallable(address _miningAddress, uint256 _secret) public view returns(bool) {\n",
          "message": "Parameter '_miningAddress' of RandomAuRa.revealSecretCallable (RandomAuRa.sol#476) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 476,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function revealSecretCallable(address _miningAddress, uint256 _secret) public view returns(bool) {\n",
          "message": "Parameter '_secret' of RandomAuRa.revealSecretCallable (RandomAuRa.sol#476) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 298,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function commitHash(bytes32 _secretHash, bytes calldata _cipher) external onlyInitialized {\n",
          "message": "Parameter '_secretHash' of RandomAuRa.commitHash (RandomAuRa.sol#298) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 298,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function commitHash(bytes32 _secretHash, bytes calldata _cipher) external onlyInitialized {\n",
          "message": "Parameter '_cipher' of RandomAuRa.commitHash (RandomAuRa.sol#298) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 315,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function revealSecret(uint256 _secret) external onlyInitialized {\n",
          "message": "Parameter '_secret' of RandomAuRa.revealSecret (RandomAuRa.sol#315) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 422,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getCipher(uint256 _collectRound, address _miningAddress) public view returns(bytes memory) {\n",
          "message": "Parameter '_collectRound' of RandomAuRa.getCipher (RandomAuRa.sol#422) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 422,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getCipher(uint256 _collectRound, address _miningAddress) public view returns(bytes memory) {\n",
          "message": "Parameter '_miningAddress' of RandomAuRa.getCipher (RandomAuRa.sol#422) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 430,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getCommit(uint256 _collectRound, address _miningAddress) public view returns(bytes32) {\n",
          "message": "Parameter '_collectRound' of RandomAuRa.getCommit (RandomAuRa.sol#430) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 430,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getCommit(uint256 _collectRound, address _miningAddress) public view returns(bytes32) {\n",
          "message": "Parameter '_miningAddress' of RandomAuRa.getCommit (RandomAuRa.sol#430) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 438,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function isCommitted(uint256 _collectRound, address _miningAddress) public view returns(bool) {\n",
          "message": "Parameter '_collectRound' of RandomAuRa.isCommitted (RandomAuRa.sol#438) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 438,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function isCommitted(uint256 _collectRound, address _miningAddress) public view returns(bool) {\n",
          "message": "Parameter '_miningAddress' of RandomAuRa.isCommitted (RandomAuRa.sol#438) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 501,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function revealSkips(uint256 _stakingEpoch, address _miningAddress) public view returns(uint256) {\n",
          "message": "Parameter '_stakingEpoch' of RandomAuRa.revealSkips (RandomAuRa.sol#501) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 501,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function revealSkips(uint256 _stakingEpoch, address _miningAddress) public view returns(uint256) {\n",
          "message": "Parameter '_miningAddress' of RandomAuRa.revealSkips (RandomAuRa.sol#501) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 509,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function sentReveal(uint256 _collectRound, address _miningAddress) public view returns(bool) {\n",
          "message": "Parameter '_collectRound' of RandomAuRa.sentReveal (RandomAuRa.sol#509) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 509,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function sentReveal(uint256 _collectRound, address _miningAddress) public view returns(bool) {\n",
          "message": "Parameter '_miningAddress' of RandomAuRa.sentReveal (RandomAuRa.sol#509) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 526,
          "vulnerability_to_line": 528,
          "vulnerability_code": "    function _addCommittedValidator(uint256 _collectRound, address _miningAddress) private {\n\n        addressArrayStorage[keccak256(abi.encode(COMMITTED_VALIDATORS, _collectRound))].push(_miningAddress);\n",
          "message": "Function 'RandomAuRa._addCommittedValidator' (RandomAuRa.sol#526-528) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 526,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _addCommittedValidator(uint256 _collectRound, address _miningAddress) private {\n",
          "message": "Parameter '_collectRound' of RandomAuRa._addCommittedValidator (RandomAuRa.sol#526) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 526,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _addCommittedValidator(uint256 _collectRound, address _miningAddress) private {\n",
          "message": "Parameter '_miningAddress' of RandomAuRa._addCommittedValidator (RandomAuRa.sol#526) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 532,
          "vulnerability_to_line": 544,
          "vulnerability_code": "    function _clearOldCiphers(uint256 _collectRound) private {\n\n        if (_collectRound == 0) {\n\n            return;\n\n        }\n\n\n\n        uint256 collectRound = _collectRound - 1;\n\n        address[] storage miningAddresses =\n\n            addressArrayStorage[keccak256(abi.encode(COMMITTED_VALIDATORS, collectRound))];\n\n\n\n        for (uint256 i = 0; i < miningAddresses.length; i++) {\n\n            delete bytesStorage[keccak256(abi.encode(CIPHERS, collectRound, miningAddresses[i]))];\n\n        }\n",
          "message": "Function 'RandomAuRa._clearOldCiphers' (RandomAuRa.sol#532-544) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 532,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _clearOldCiphers(uint256 _collectRound) private {\n",
          "message": "Parameter '_collectRound' of RandomAuRa._clearOldCiphers (RandomAuRa.sol#532) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 547,
          "vulnerability_to_line": 549,
          "vulnerability_code": "    function _getCoinbase() internal view returns(address) {\n\n        return block.coinbase;\n",
          "message": "Function 'RandomAuRa._getCoinbase' (RandomAuRa.sol#547-549) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 552,
          "vulnerability_to_line": 554,
          "vulnerability_code": "    function _getCurrentBlockNumber() internal view returns(uint256) {\n\n        return block.number;\n",
          "message": "Function 'RandomAuRa._getCurrentBlockNumber' (RandomAuRa.sol#552-554) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 560,
          "vulnerability_to_line": 562,
          "vulnerability_code": "    function _incrementRevealSkips(uint256 _stakingEpoch, address _miningAddress) private {\n\n        uintStorage[keccak256(abi.encode(REVEAL_SKIPS, _stakingEpoch, _miningAddress))]++;\n",
          "message": "Function 'RandomAuRa._incrementRevealSkips' (RandomAuRa.sol#560-562) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 560,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _incrementRevealSkips(uint256 _stakingEpoch, address _miningAddress) private {\n",
          "message": "Parameter '_stakingEpoch' of RandomAuRa._incrementRevealSkips (RandomAuRa.sol#560) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 560,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _incrementRevealSkips(uint256 _stakingEpoch, address _miningAddress) private {\n",
          "message": "Parameter '_miningAddress' of RandomAuRa._incrementRevealSkips (RandomAuRa.sol#560) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 569,
          "vulnerability_to_line": 571,
          "vulnerability_code": "    function _setCipher(uint256 _collectRound, address _miningAddress, bytes memory _cipher) private {\n\n        bytesStorage[keccak256(abi.encode(CIPHERS, _collectRound, _miningAddress))] = _cipher;\n",
          "message": "Function 'RandomAuRa._setCipher' (RandomAuRa.sol#569-571) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 569,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setCipher(uint256 _collectRound, address _miningAddress, bytes memory _cipher) private {\n",
          "message": "Parameter '_collectRound' of RandomAuRa._setCipher (RandomAuRa.sol#569) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 569,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setCipher(uint256 _collectRound, address _miningAddress, bytes memory _cipher) private {\n",
          "message": "Parameter '_miningAddress' of RandomAuRa._setCipher (RandomAuRa.sol#569) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 569,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setCipher(uint256 _collectRound, address _miningAddress, bytes memory _cipher) private {\n",
          "message": "Parameter '_cipher' of RandomAuRa._setCipher (RandomAuRa.sol#569) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 578,
          "vulnerability_to_line": 580,
          "vulnerability_code": "    function _setCommit(uint256 _collectRound, address _miningAddress, bytes32 _secretHash) private {\n\n        bytes32Storage[keccak256(abi.encode(COMMITS, _collectRound, _miningAddress))] = _secretHash;\n",
          "message": "Function 'RandomAuRa._setCommit' (RandomAuRa.sol#578-580) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 578,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setCommit(uint256 _collectRound, address _miningAddress, bytes32 _secretHash) private {\n",
          "message": "Parameter '_collectRound' of RandomAuRa._setCommit (RandomAuRa.sol#578) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 578,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setCommit(uint256 _collectRound, address _miningAddress, bytes32 _secretHash) private {\n",
          "message": "Parameter '_miningAddress' of RandomAuRa._setCommit (RandomAuRa.sol#578) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 578,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setCommit(uint256 _collectRound, address _miningAddress, bytes32 _secretHash) private {\n",
          "message": "Parameter '_secretHash' of RandomAuRa._setCommit (RandomAuRa.sol#578) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 586,
          "vulnerability_to_line": 588,
          "vulnerability_code": "    function _setSentReveal(uint256 _collectRound, address _miningAddress) private {\n\n        boolStorage[keccak256(abi.encode(SENT_REVEAL, _collectRound, _miningAddress))] = true;\n",
          "message": "Function 'RandomAuRa._setSentReveal' (RandomAuRa.sol#586-588) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 586,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setSentReveal(uint256 _collectRound, address _miningAddress) private {\n",
          "message": "Parameter '_collectRound' of RandomAuRa._setSentReveal (RandomAuRa.sol#586) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 586,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setSentReveal(uint256 _collectRound, address _miningAddress) private {\n",
          "message": "Parameter '_miningAddress' of RandomAuRa._setSentReveal (RandomAuRa.sol#586) is not in mixedCase\n"
        },
        {
          "name": "unused-state",
          "vulnerability_from_line": 59,
          "vulnerability_to_line": null,
          "vulnerability_code": "    mapping(bytes32 => string) internal stringStorage;\n",
          "message": "EternalStorage.stringStorage (RandomAuRa.sol#59) is never used in RandomAuRa\nEternalStorage.intStorage (RandomAuRa.sol#63) is never used in RandomAuRa\nEternalStorage.uintArrayStorage (RandomAuRa.sol#66) is never used in RandomAuRa\nEternalStorage.stringArrayStorage (RandomAuRa.sol#67) is never used in RandomAuRa\nEternalStorage.bytesArrayStorage (RandomAuRa.sol#69) is never used in RandomAuRa\nEternalStorage.boolArrayStorage (RandomAuRa.sol#70) is never used in RandomAuRa\nEternalStorage.intArrayStorage (RandomAuRa.sol#71) is never used in RandomAuRa\nEternalStorage.bytes32ArrayStorage (RandomAuRa.sol#72) is never used in RandomAuRa\n"
        }
      ]
    },
    "smartcheck": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 364,
          "vulnerability_to_line": null,
          "vulnerability_code": "            for (i = 0; i < validators.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 385,
          "vulnerability_to_line": null,
          "vulnerability_code": "            for (i = 0; i < validators.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 541,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 i = 0; i < miningAddresses.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 364,
          "vulnerability_to_line": null,
          "vulnerability_code": "            for (i = 0; i < validators.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 385,
          "vulnerability_to_line": null,
          "vulnerability_code": "            for (i = 0; i < validators.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 541,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 i = 0; i < miningAddresses.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SAFEMATH",
          "vulnerability_from_line": 142,
          "vulnerability_to_line": null,
          "vulnerability_code": "    using SafeMath for uint256;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 24,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function newValidatorSet() external returns(bool, uint256);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 223,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function reportMaliciousCallable(address, address, uint256) external view returns(bool, bool);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 237,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getPoolsLikelihood() external view returns(int256[] memory, int256);\n",
          "message": null
        }
      ]
    },
    "oyente": {
      "successfull_analysis": false,
      "errors": [
        "exception (RuntimeError: Source map error, unknown name(SHR) or instr_name(INVALID))"
      ],
      "vulnerability_findings": []
    },
    "mythril": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "Dependence on predictable environment variable (SWC 120)",
          "vulnerability_from_line": 345,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (_getCurrentBlockNumber() % collectRoundLength() != collectRoundLength() - 1) return;\n",
          "message": "A control flow decision is made based on The block.number environment variable.\nThe block.number environment variable is used to determine a control flow decision. Note that the values of variables like coinbase, gaslimit, block number and timestamp are predictable and can be manipulated by a malicious miner. Also keep in mind that attackers know hashes of earlier blocks. Don't use any of those environment variables as sources of randomness and be aware that use of these variables introduces a certain level of trust into miners.\nClassification: SWC-120"
        },
        {
          "name": "Exception State (SWC 110)",
          "vulnerability_from_line": 552,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _getCurrentBlockNumber() internal view returns(uint256) {\n",
          "message": "An assertion violation was triggered.\nIt is possible to trigger an assertion violation. Note that Solidity assert() statements should only be used to check invariants. Review the transaction trace generated for this issue and either make sure your program logic is correct, or use require() instead of assert() if your goal is to constrain user inputs or enforce preconditions. Remember to validate inputs from both callers (for instance, via passed arguments) and callees (for instance, via return values).\nClassification: SWC-110"
        },
        {
          "name": "Dependence on predictable environment variable (SWC 120)",
          "vulnerability_from_line": 477,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (!isRevealPhase()) return false; // must only be called in `reveals phase`\n",
          "message": "A control flow decision is made based on The block.number environment variable.\nThe block.number environment variable is used to determine a control flow decision. Note that the values of variables like coinbase, gaslimit, block number and timestamp are predictable and can be manipulated by a malicious miner. Also keep in mind that attackers know hashes of earlier blocks. Don't use any of those environment variables as sources of randomness and be aware that use of these variables introduces a certain level of trust into miners.\nClassification: SWC-120"
        },
        {
          "name": "Dependence on predictable environment variable (SWC 120)",
          "vulnerability_from_line": 461,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (!isCommitPhase()) return false; // must only be called in `commits phase`\n",
          "message": "A control flow decision is made based on The block.number environment variable.\nThe block.number environment variable is used to determine a control flow decision. Note that the values of variables like coinbase, gaslimit, block number and timestamp are predictable and can be manipulated by a malicious miner. Also keep in mind that attackers know hashes of earlier blocks. Don't use any of those environment variables as sources of randomness and be aware that use of these variables introduces a certain level of trust into miners.\nClassification: SWC-120"
        }
      ]
    },
    "osiris": {
      "successfull_analysis": false,
      "errors": [
        "exception (IndexError: pop from empty list)"
      ],
      "vulnerability_findings": []
    }
  }
}