{
  "smartbugs_completed": true,
  "analyzer_results": {
    "semgrep": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 1044,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 i = 0; i < _initialStakingAddresses.length; i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 1044,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 i = 0; i < _initialStakingAddresses.length; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 439,
          "vulnerability_to_line": null,
          "vulnerability_code": "                if (newStakeAmount == 0 && _poolStakingAddress != unremovableStakingAddress) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 440,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    _addPoolToBeRemoved(_poolStakingAddress);\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 441,
          "vulnerability_to_line": null,
          "vulnerability_code": "                }\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 953,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (pools.length > indexToDelete && pools[indexToDelete] == _stakingAddress) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 954,
          "vulnerability_to_line": null,
          "vulnerability_code": "            intStorage[POOLS_LIKELIHOOD_SUM] -= likelihood[indexToDelete];\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 955,
          "vulnerability_to_line": null,
          "vulnerability_code": "            if (intStorage[POOLS_LIKELIHOOD_SUM] < 0) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 956,
          "vulnerability_to_line": null,
          "vulnerability_code": "                intStorage[POOLS_LIKELIHOOD_SUM] = 0;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 957,
          "vulnerability_to_line": null,
          "vulnerability_code": "            }\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 958,
          "vulnerability_to_line": null,
          "vulnerability_code": "            pools[indexToDelete] = pools[pools.length - 1];\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 959,
          "vulnerability_to_line": null,
          "vulnerability_code": "            likelihood[indexToDelete] = likelihood[pools.length - 1];\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 960,
          "vulnerability_to_line": null,
          "vulnerability_code": "            _setPoolToBeElectedIndex(pools[indexToDelete], indexToDelete);\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 961,
          "vulnerability_to_line": null,
          "vulnerability_code": "            _setPoolToBeElectedIndex(_stakingAddress, 0);\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 962,
          "vulnerability_to_line": null,
          "vulnerability_code": "            pools.length--;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 974,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (pools.length > indexToDelete && pools[indexToDelete] == _stakingAddress) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 975,
          "vulnerability_to_line": null,
          "vulnerability_code": "            pools[indexToDelete] = pools[pools.length - 1];\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 976,
          "vulnerability_to_line": null,
          "vulnerability_code": "            _setPoolToBeRemovedIndex(pools[indexToDelete], indexToDelete);\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 977,
          "vulnerability_to_line": null,
          "vulnerability_code": "            _setPoolToBeRemovedIndex(_stakingAddress, 0);\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 978,
          "vulnerability_to_line": null,
          "vulnerability_code": "            pools.length--;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 979,
          "vulnerability_to_line": null,
          "vulnerability_code": "        }\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 988,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (pools.length > indexToRemove && pools[indexToRemove] == _stakingAddress) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 989,
          "vulnerability_to_line": null,
          "vulnerability_code": "            pools[indexToRemove] = pools[pools.length - 1];\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 990,
          "vulnerability_to_line": null,
          "vulnerability_code": "            _setPoolIndex(pools[indexToRemove], indexToRemove);\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 991,
          "vulnerability_to_line": null,
          "vulnerability_code": "            _setPoolIndex(_stakingAddress, 0);\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 992,
          "vulnerability_to_line": null,
          "vulnerability_code": "            pools.length--;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 993,
          "vulnerability_to_line": null,
          "vulnerability_code": "        }\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 1009,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (pools.length > indexToRemove && pools[indexToRemove] == _stakingAddress) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 1010,
          "vulnerability_to_line": null,
          "vulnerability_code": "            pools[indexToRemove] = pools[pools.length - 1];\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 1011,
          "vulnerability_to_line": null,
          "vulnerability_code": "            _setPoolInactiveIndex(pools[indexToRemove], indexToRemove);\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 1012,
          "vulnerability_to_line": null,
          "vulnerability_code": "            _setPoolInactiveIndex(_stakingAddress, 0);\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 1013,
          "vulnerability_to_line": null,
          "vulnerability_code": "            pools.length--;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 1014,
          "vulnerability_to_line": null,
          "vulnerability_code": "        }\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 1163,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (delegators.length != 0 && delegators[indexToRemove] == _delegator) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 1164,
          "vulnerability_to_line": null,
          "vulnerability_code": "            delegators[indexToRemove] = delegators[delegators.length - 1];\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 1165,
          "vulnerability_to_line": null,
          "vulnerability_code": "            _setPoolDelegatorIndex(_poolStakingAddress, delegators[indexToRemove], indexToRemove);\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 1166,
          "vulnerability_to_line": null,
          "vulnerability_code": "            _setPoolDelegatorIndex(_poolStakingAddress, _delegator, 0);\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 1167,
          "vulnerability_to_line": null,
          "vulnerability_code": "            delegators.length--;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 1168,
          "vulnerability_to_line": null,
          "vulnerability_code": "        }\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 1185,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (delegators.length != 0 && delegators[indexToRemove] == _delegator) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 1186,
          "vulnerability_to_line": null,
          "vulnerability_code": "            delegators[indexToRemove] = delegators[delegators.length - 1];\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 1187,
          "vulnerability_to_line": null,
          "vulnerability_code": "            _setPoolDelegatorInactiveIndex(_poolStakingAddress, delegators[indexToRemove], indexToRemove);\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 1188,
          "vulnerability_to_line": null,
          "vulnerability_code": "            _setPoolDelegatorInactiveIndex(_poolStakingAddress, _delegator, 0);\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 1189,
          "vulnerability_to_line": null,
          "vulnerability_code": "            delegators.length--;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 1190,
          "vulnerability_to_line": null,
          "vulnerability_code": "        }\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-prefix-decrement-not-postfix",
          "vulnerability_from_line": 962,
          "vulnerability_to_line": null,
          "vulnerability_code": "            pools.length--;\n",
          "message": "Consider using the prefix decrement expression whenever the return value is not needed. The prefix decrement expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-decrement-not-postfix",
          "vulnerability_from_line": 963,
          "vulnerability_to_line": null,
          "vulnerability_code": "            likelihood.length--;\n",
          "message": "Consider using the prefix decrement expression whenever the return value is not needed. The prefix decrement expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-decrement-not-postfix",
          "vulnerability_from_line": 978,
          "vulnerability_to_line": null,
          "vulnerability_code": "            pools.length--;\n",
          "message": "Consider using the prefix decrement expression whenever the return value is not needed. The prefix decrement expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-decrement-not-postfix",
          "vulnerability_from_line": 992,
          "vulnerability_to_line": null,
          "vulnerability_code": "            pools.length--;\n",
          "message": "Consider using the prefix decrement expression whenever the return value is not needed. The prefix decrement expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-decrement-not-postfix",
          "vulnerability_from_line": 1013,
          "vulnerability_to_line": null,
          "vulnerability_code": "            pools.length--;\n",
          "message": "Consider using the prefix decrement expression whenever the return value is not needed. The prefix decrement expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-decrement-not-postfix",
          "vulnerability_from_line": 1167,
          "vulnerability_to_line": null,
          "vulnerability_code": "            delegators.length--;\n",
          "message": "Consider using the prefix decrement expression whenever the return value is not needed. The prefix decrement expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-decrement-not-postfix",
          "vulnerability_from_line": 1189,
          "vulnerability_to_line": null,
          "vulnerability_code": "            delegators.length--;\n",
          "message": "Consider using the prefix decrement expression whenever the return value is not needed. The prefix decrement expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 321,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uintStorage[STAKING_EPOCH]++;\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 1044,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 i = 0; i < _initialStakingAddresses.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        }
      ]
    },
    "slither": {
      "successfull_analysis": true,
      "errors": [
        "EXIT_CODE_209"
      ],
      "vulnerability_findings": [
        {
          "name": "arbitrary-send",
          "vulnerability_from_line": 385,
          "vulnerability_to_line": 396,
          "vulnerability_code": "    function withdraw(address _fromPoolStakingAddress, uint256 _amount) external gasPriceIsValid onlyInitialized {\n\n        address payable staker = msg.sender;\n\n        _withdraw(_fromPoolStakingAddress, staker, _amount);\n\n        IERC20Minting tokenContract = IERC20Minting(erc20TokenContract());\n\n        if (address(tokenContract) != address(0)) {\n\n            tokenContract.withdraw(staker, _amount);\n\n        } else {\n\n            require(boolStorage[ERC20_RESTRICTED]);\n\n            staker.transfer(_amount);\n\n        }\n\n        emit Withdrawn(_fromPoolStakingAddress, staker, stakingEpoch(), _amount);\n",
          "message": "StakingBase.withdraw (StakingBase.sol#385-396) sends eth to arbitrary user\n\tDangerous calls:\n\t- staker.transfer(_amount) (StakingBase.sol#393)\n"
        },
        {
          "name": "arbitrary-send",
          "vulnerability_from_line": 480,
          "vulnerability_to_line": 517,
          "vulnerability_code": "    function claimOrderedWithdraw(address _poolStakingAddress) external gasPriceIsValid onlyInitialized {\n\n        IValidatorSet validatorSetContract = validatorSetContract();\n\n        uint256 epoch = stakingEpoch();\n\n        address payable staker = msg.sender;\n\n\n\n        require(_poolStakingAddress != address(0));\n\n        require(epoch > orderWithdrawEpoch(_poolStakingAddress, staker));\n\n        require(_isWithdrawAllowed(validatorSetContract.miningByStakingAddress(_poolStakingAddress)));\n\n\n\n        uint256 claimAmount = orderedWithdrawAmount(_poolStakingAddress, staker);\n\n        require(claimAmount != 0);\n\n\n\n        uint256 resultingStakeAmount = stakeAmount(_poolStakingAddress, staker).sub(claimAmount);\n\n\n\n        _setOrderedWithdrawAmount(_poolStakingAddress, staker, 0);\n\n        _setOrderedWithdrawAmountTotal(\n\n            _poolStakingAddress,\n\n            orderedWithdrawAmountTotal(_poolStakingAddress).sub(claimAmount)\n\n        );\n\n        _setStakeAmount(_poolStakingAddress, staker, resultingStakeAmount);\n\n        _setStakeAmountTotal(_poolStakingAddress, stakeAmountTotal(_poolStakingAddress).sub(claimAmount));\n\n\n\n        if (resultingStakeAmount == 0) {\n\n            _withdrawCheckPool(_poolStakingAddress, staker);\n\n        }\n\n\n\n        _setLikelihood(_poolStakingAddress);\n\n\n\n        IERC20Minting tokenContract = IERC20Minting(erc20TokenContract());\n\n        if (address(tokenContract) != address(0)) {\n\n            tokenContract.withdraw(staker, claimAmount);\n\n        } else {\n\n            require(boolStorage[ERC20_RESTRICTED]);\n\n            staker.transfer(claimAmount);\n\n        }\n\n\n\n        emit Claimed(_poolStakingAddress, staker, epoch, claimAmount);\n",
          "message": "StakingBase.claimOrderedWithdraw (StakingBase.sol#480-517) sends eth to arbitrary user\n\tDangerous calls:\n\t- staker.transfer(claimAmount) (StakingBase.sol#513)\n"
        },
        {
          "name": "uninitialized-state",
          "vulnerability_from_line": 97,
          "vulnerability_to_line": null,
          "vulnerability_code": "    address internal _owner;\n",
          "message": "EternalStorage._owner (StakingBase.sol#97) is never initialized. It is used in:\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 1024,
          "vulnerability_to_line": 1056,
          "vulnerability_code": "    function _initialize(\n\n        address _validatorSetContract,\n\n        address[] memory _initialStakingAddresses,\n\n        uint256 _delegatorMinStake,\n\n        uint256 _candidateMinStake,\n\n        bool _erc20Restricted\n\n    ) internal {\n\n        require(!isInitialized()); // initialization can only be done once\n\n        require(_validatorSetContract != address(0));\n\n        require(_initialStakingAddresses.length > 0);\n\n        require(_delegatorMinStake != 0);\n\n        require(_candidateMinStake != 0);\n\n\n\n        IBlockReward blockRewardContract = IBlockReward(IValidatorSet(_validatorSetContract).blockRewardContract());\n\n        require(MAX_DELEGATORS_PER_POOL % blockRewardContract.DELEGATORS_ALIQUOT() == 0);\n\n\n\n        addressStorage[VALIDATOR_SET_CONTRACT] = _validatorSetContract;\n\n\n\n        address unremovableStakingAddress = IValidatorSet(_validatorSetContract).unremovableValidator();\n\n\n\n        for (uint256 i = 0; i < _initialStakingAddresses.length; i++) {\n\n            require(_initialStakingAddresses[i] != address(0));\n\n            _addPoolActive(_initialStakingAddresses[i], false);\n\n            if (_initialStakingAddresses[i] != unremovableStakingAddress) {\n\n                _addPoolToBeRemoved(_initialStakingAddresses[i]);\n\n            }\n\n        }\n\n\n\n        _setDelegatorMinStake(_delegatorMinStake);\n\n        _setCandidateMinStake(_candidateMinStake);\n\n\n\n        boolStorage[ERC20_RESTRICTED] = _erc20Restricted;\n",
          "message": "Reentrancy in StakingBase._initialize (StakingBase.sol#1024-1056):\n\tExternal calls:\n\t- blockRewardContract = IBlockReward(IValidatorSet(_validatorSetContract).blockRewardContract()) (StakingBase.sol#1037)\n\t- require(bool)(MAX_DELEGATORS_PER_POOL % blockRewardContract.DELEGATORS_ALIQUOT() == 0) (StakingBase.sol#1038)\n\tState variables written after the call(s):\n\t- addressStorage (StakingBase.sol#1040)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 1296,
          "vulnerability_to_line": 1333,
          "vulnerability_code": "    function _stake(address _poolStakingAddress, address _staker, uint256 _amount) internal {\n\n        IValidatorSet validatorSet = validatorSetContract();\n\n        address poolMiningAddress = validatorSet.miningByStakingAddress(_poolStakingAddress);\n\n\n\n        require(poolMiningAddress != address(0));\n\n        require(_poolStakingAddress != address(0));\n\n        require(_amount != 0);\n\n        require(!validatorSet.isValidatorBanned(poolMiningAddress));\n\n        require(areStakeAndWithdrawAllowed());\n\n\n\n        uint256 newStakeAmount = stakeAmount(_poolStakingAddress, _staker).add(_amount);\n\n        if (_staker == _poolStakingAddress) {\n\n            require(newStakeAmount >= getCandidateMinStake()); // the staked amount must be at least CANDIDATE_MIN_STAKE\n\n        } else {\n\n            require(newStakeAmount >= getDelegatorMinStake()); // the staked amount must be at least DELEGATOR_MIN_STAKE\n\n\n\n            // The delegator cannot stake into the pool of the candidate which hasn't self-staked.\n\n            // Also, that candidate shouldn't want to withdraw all his funds.\n\n            require(stakeAmountMinusOrderedWithdraw(_poolStakingAddress, _poolStakingAddress) != 0);\n\n        }\n\n        _setStakeAmount(_poolStakingAddress, _staker, newStakeAmount);\n\n        _setStakeAmountByCurrentEpoch(\n\n            _poolStakingAddress,\n\n            _staker,\n\n            stakeAmountByCurrentEpoch(_poolStakingAddress, _staker).add(_amount)\n\n        );\n\n        _setStakeAmountTotal(_poolStakingAddress, stakeAmountTotal(_poolStakingAddress).add(_amount));\n\n\n\n        if (_staker == _poolStakingAddress) { // `staker` makes a stake for himself and becomes a candidate\n\n            // Add `_poolStakingAddress` to the array of pools\n\n            _addPoolActive(_poolStakingAddress, _poolStakingAddress != validatorSet.unremovableValidator());\n\n        } else {\n\n            // Add `_staker` to the array of pool's delegators\n\n            _addPoolDelegator(_poolStakingAddress, _staker);\n\n        }\n\n\n\n        _setLikelihood(_poolStakingAddress);\n",
          "message": "Reentrancy in StakingBase._stake (StakingBase.sol#1296-1333):\n\tExternal calls:\n\t- poolMiningAddress = validatorSet.miningByStakingAddress(_poolStakingAddress) (StakingBase.sol#1298)\n\t- require(bool)(! validatorSet.isValidatorBanned(poolMiningAddress)) (StakingBase.sol#1303)\n\t- _addPoolActive(_poolStakingAddress,_poolStakingAddress != validatorSet.unremovableValidator()) (StakingBase.sol#1326)\n\tState variables written after the call(s):\n\t- intArrayStorage (StakingBase.sol#1332)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 1340,
          "vulnerability_to_line": 1370,
          "vulnerability_code": "    function _withdraw(address _poolStakingAddress, address _staker, uint256 _amount) internal {\n\n        require(_poolStakingAddress != address(0));\n\n        require(_amount != 0);\n\n\n\n        // How much can `staker` withdraw from `_poolStakingAddress` at the moment?\n\n        require(_amount <= maxWithdrawAllowed(_poolStakingAddress, _staker));\n\n\n\n        uint256 currentStakeAmount = stakeAmount(_poolStakingAddress, _staker);\n\n        uint256 alreadyOrderedAmount = orderedWithdrawAmount(_poolStakingAddress, _staker);\n\n        uint256 resultingStakeAmount = currentStakeAmount.sub(alreadyOrderedAmount).sub(_amount);\n\n\n\n        // The amount to be withdrawn must be the whole staked amount or\n\n        // must not exceed the diff between the entire amount and MIN_STAKE\n\n        uint256 minAllowedStake = (_poolStakingAddress == _staker) ? getCandidateMinStake() : getDelegatorMinStake();\n\n        require(resultingStakeAmount == 0 || resultingStakeAmount >= minAllowedStake);\n\n\n\n        _setStakeAmount(_poolStakingAddress, _staker, currentStakeAmount.sub(_amount));\n\n        uint256 amountByEpoch = stakeAmountByCurrentEpoch(_poolStakingAddress, _staker);\n\n        _setStakeAmountByCurrentEpoch(\n\n            _poolStakingAddress,\n\n            _staker,\n\n            amountByEpoch >= _amount ? amountByEpoch - _amount : 0\n\n        );\n\n        _setStakeAmountTotal(_poolStakingAddress, stakeAmountTotal(_poolStakingAddress).sub(_amount));\n\n\n\n        if (resultingStakeAmount == 0) {\n\n            _withdrawCheckPool(_poolStakingAddress, _staker);\n\n        }\n\n\n\n        _setLikelihood(_poolStakingAddress);\n",
          "message": "Reentrancy in StakingBase._withdraw (StakingBase.sol#1340-1370):\n\tExternal calls:\n\t- require(bool)(_amount <= maxWithdrawAllowed(_poolStakingAddress,_staker)) (StakingBase.sol#1345)\n\tState variables written after the call(s):\n\t- uintStorage (StakingBase.sol#1356)\n\t- uintStorage (StakingBase.sol#1363)\n\t- uintStorage (StakingBase.sol#1358-1362)\n\t- uintStorage (StakingBase.sol#1358-1362)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 1340,
          "vulnerability_to_line": 1370,
          "vulnerability_code": "    function _withdraw(address _poolStakingAddress, address _staker, uint256 _amount) internal {\n\n        require(_poolStakingAddress != address(0));\n\n        require(_amount != 0);\n\n\n\n        // How much can `staker` withdraw from `_poolStakingAddress` at the moment?\n\n        require(_amount <= maxWithdrawAllowed(_poolStakingAddress, _staker));\n\n\n\n        uint256 currentStakeAmount = stakeAmount(_poolStakingAddress, _staker);\n\n        uint256 alreadyOrderedAmount = orderedWithdrawAmount(_poolStakingAddress, _staker);\n\n        uint256 resultingStakeAmount = currentStakeAmount.sub(alreadyOrderedAmount).sub(_amount);\n\n\n\n        // The amount to be withdrawn must be the whole staked amount or\n\n        // must not exceed the diff between the entire amount and MIN_STAKE\n\n        uint256 minAllowedStake = (_poolStakingAddress == _staker) ? getCandidateMinStake() : getDelegatorMinStake();\n\n        require(resultingStakeAmount == 0 || resultingStakeAmount >= minAllowedStake);\n\n\n\n        _setStakeAmount(_poolStakingAddress, _staker, currentStakeAmount.sub(_amount));\n\n        uint256 amountByEpoch = stakeAmountByCurrentEpoch(_poolStakingAddress, _staker);\n\n        _setStakeAmountByCurrentEpoch(\n\n            _poolStakingAddress,\n\n            _staker,\n\n            amountByEpoch >= _amount ? amountByEpoch - _amount : 0\n\n        );\n\n        _setStakeAmountTotal(_poolStakingAddress, stakeAmountTotal(_poolStakingAddress).sub(_amount));\n\n\n\n        if (resultingStakeAmount == 0) {\n\n            _withdrawCheckPool(_poolStakingAddress, _staker);\n\n        }\n\n\n\n        _setLikelihood(_poolStakingAddress);\n",
          "message": "Reentrancy in StakingBase._withdraw (StakingBase.sol#1340-1370):\n\tExternal calls:\n\t- require(bool)(_amount <= maxWithdrawAllowed(_poolStakingAddress,_staker)) (StakingBase.sol#1345)\n\t- _withdrawCheckPool(_poolStakingAddress,_staker) (StakingBase.sol#1366)\n\tState variables written after the call(s):\n\t- intArrayStorage (StakingBase.sol#1369)\n\t- intStorage (StakingBase.sol#1369)\n\t- uintStorage (StakingBase.sol#1366)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 480,
          "vulnerability_to_line": 517,
          "vulnerability_code": "    function claimOrderedWithdraw(address _poolStakingAddress) external gasPriceIsValid onlyInitialized {\n\n        IValidatorSet validatorSetContract = validatorSetContract();\n\n        uint256 epoch = stakingEpoch();\n\n        address payable staker = msg.sender;\n\n\n\n        require(_poolStakingAddress != address(0));\n\n        require(epoch > orderWithdrawEpoch(_poolStakingAddress, staker));\n\n        require(_isWithdrawAllowed(validatorSetContract.miningByStakingAddress(_poolStakingAddress)));\n\n\n\n        uint256 claimAmount = orderedWithdrawAmount(_poolStakingAddress, staker);\n\n        require(claimAmount != 0);\n\n\n\n        uint256 resultingStakeAmount = stakeAmount(_poolStakingAddress, staker).sub(claimAmount);\n\n\n\n        _setOrderedWithdrawAmount(_poolStakingAddress, staker, 0);\n\n        _setOrderedWithdrawAmountTotal(\n\n            _poolStakingAddress,\n\n            orderedWithdrawAmountTotal(_poolStakingAddress).sub(claimAmount)\n\n        );\n\n        _setStakeAmount(_poolStakingAddress, staker, resultingStakeAmount);\n\n        _setStakeAmountTotal(_poolStakingAddress, stakeAmountTotal(_poolStakingAddress).sub(claimAmount));\n\n\n\n        if (resultingStakeAmount == 0) {\n\n            _withdrawCheckPool(_poolStakingAddress, staker);\n\n        }\n\n\n\n        _setLikelihood(_poolStakingAddress);\n\n\n\n        IERC20Minting tokenContract = IERC20Minting(erc20TokenContract());\n\n        if (address(tokenContract) != address(0)) {\n\n            tokenContract.withdraw(staker, claimAmount);\n\n        } else {\n\n            require(boolStorage[ERC20_RESTRICTED]);\n\n            staker.transfer(claimAmount);\n\n        }\n\n\n\n        emit Claimed(_poolStakingAddress, staker, epoch, claimAmount);\n",
          "message": "Reentrancy in StakingBase.claimOrderedWithdraw (StakingBase.sol#480-517):\n\tExternal calls:\n\t- require(bool)(_isWithdrawAllowed(validatorSetContract.miningByStakingAddress(_poolStakingAddress))) (StakingBase.sol#487)\n\tState variables written after the call(s):\n\t- uintStorage (StakingBase.sol#494)\n\t- uintStorage (StakingBase.sol#495-498)\n\t- uintStorage (StakingBase.sol#499)\n\t- uintStorage (StakingBase.sol#500)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 480,
          "vulnerability_to_line": 517,
          "vulnerability_code": "    function claimOrderedWithdraw(address _poolStakingAddress) external gasPriceIsValid onlyInitialized {\n\n        IValidatorSet validatorSetContract = validatorSetContract();\n\n        uint256 epoch = stakingEpoch();\n\n        address payable staker = msg.sender;\n\n\n\n        require(_poolStakingAddress != address(0));\n\n        require(epoch > orderWithdrawEpoch(_poolStakingAddress, staker));\n\n        require(_isWithdrawAllowed(validatorSetContract.miningByStakingAddress(_poolStakingAddress)));\n\n\n\n        uint256 claimAmount = orderedWithdrawAmount(_poolStakingAddress, staker);\n\n        require(claimAmount != 0);\n\n\n\n        uint256 resultingStakeAmount = stakeAmount(_poolStakingAddress, staker).sub(claimAmount);\n\n\n\n        _setOrderedWithdrawAmount(_poolStakingAddress, staker, 0);\n\n        _setOrderedWithdrawAmountTotal(\n\n            _poolStakingAddress,\n\n            orderedWithdrawAmountTotal(_poolStakingAddress).sub(claimAmount)\n\n        );\n\n        _setStakeAmount(_poolStakingAddress, staker, resultingStakeAmount);\n\n        _setStakeAmountTotal(_poolStakingAddress, stakeAmountTotal(_poolStakingAddress).sub(claimAmount));\n\n\n\n        if (resultingStakeAmount == 0) {\n\n            _withdrawCheckPool(_poolStakingAddress, staker);\n\n        }\n\n\n\n        _setLikelihood(_poolStakingAddress);\n\n\n\n        IERC20Minting tokenContract = IERC20Minting(erc20TokenContract());\n\n        if (address(tokenContract) != address(0)) {\n\n            tokenContract.withdraw(staker, claimAmount);\n\n        } else {\n\n            require(boolStorage[ERC20_RESTRICTED]);\n\n            staker.transfer(claimAmount);\n\n        }\n\n\n\n        emit Claimed(_poolStakingAddress, staker, epoch, claimAmount);\n",
          "message": "Reentrancy in StakingBase.claimOrderedWithdraw (StakingBase.sol#480-517):\n\tExternal calls:\n\t- require(bool)(_isWithdrawAllowed(validatorSetContract.miningByStakingAddress(_poolStakingAddress))) (StakingBase.sol#487)\n\t- _withdrawCheckPool(_poolStakingAddress,staker) (StakingBase.sol#503)\n\tState variables written after the call(s):\n\t- intArrayStorage (StakingBase.sol#506)\n\t- intStorage (StakingBase.sol#506)\n\t- uintStorage (StakingBase.sol#503)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 352,
          "vulnerability_to_line": 362,
          "vulnerability_code": "    function moveStake(\n\n        address _fromPoolStakingAddress,\n\n        address _toPoolStakingAddress,\n\n        uint256 _amount\n\n    ) external gasPriceIsValid onlyInitialized {\n\n        require(_fromPoolStakingAddress != _toPoolStakingAddress);\n\n        address staker = msg.sender;\n\n        _withdraw(_fromPoolStakingAddress, staker, _amount);\n\n        _stake(_toPoolStakingAddress, staker, _amount);\n\n        emit StakeMoved(_fromPoolStakingAddress, _toPoolStakingAddress, staker, stakingEpoch(), _amount);\n",
          "message": "Reentrancy in StakingBase.moveStake (StakingBase.sol#352-362):\n\tExternal calls:\n\t- _withdraw(_fromPoolStakingAddress,staker,_amount) (StakingBase.sol#359)\n\t- _stake(_toPoolStakingAddress,staker,_amount) (StakingBase.sol#360)\n\tState variables written after the call(s):\n\t- addressArrayStorage (StakingBase.sol#360)\n\t- intArrayStorage (StakingBase.sol#360)\n\t- intStorage (StakingBase.sol#360)\n\t- uintStorage (StakingBase.sol#360)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 406,
          "vulnerability_to_line": 475,
          "vulnerability_code": "    function orderWithdraw(address _poolStakingAddress, int256 _amount) external gasPriceIsValid onlyInitialized {\n\n        IValidatorSet validatorSetContract = validatorSetContract();\n\n\n\n        require(_poolStakingAddress != address(0));\n\n        require(_amount != 0);\n\n        require(_isWithdrawAllowed(validatorSetContract.miningByStakingAddress(_poolStakingAddress)));\n\n\n\n        address staker = msg.sender;\n\n\n\n        // How much can `staker` order for withdrawal from `_poolStakingAddress` at the moment?\n\n        require(_amount < 0 || uint256(_amount) <= maxWithdrawOrderAllowed(_poolStakingAddress, staker));\n\n\n\n        uint256 alreadyOrderedAmount = orderedWithdrawAmount(_poolStakingAddress, staker);\n\n\n\n        require(_amount > 0 || uint256(-_amount) <= alreadyOrderedAmount);\n\n\n\n        uint256 newOrderedAmount;\n\n        if (_amount > 0) {\n\n            newOrderedAmount = alreadyOrderedAmount.add(uint256(_amount));\n\n        } else {\n\n            newOrderedAmount = alreadyOrderedAmount.sub(uint256(-_amount));\n\n        }\n\n        _setOrderedWithdrawAmount(_poolStakingAddress, staker, newOrderedAmount);\n\n\n\n        // The amount to be withdrawn must be the whole staked amount or\n\n        // must not exceed the diff between the entire amount and MIN_STAKE\n\n        uint256 newStakeAmount = stakeAmount(_poolStakingAddress, staker).sub(newOrderedAmount);\n\n        if (staker == _poolStakingAddress) {\n\n            require(newStakeAmount == 0 || newStakeAmount >= getCandidateMinStake());\n\n\n\n            address unremovableStakingAddress = validatorSetContract.unremovableValidator();\n\n\n\n            if (_amount > 0) {\n\n                if (newStakeAmount == 0 && _poolStakingAddress != unremovableStakingAddress) {\n\n                    _addPoolToBeRemoved(_poolStakingAddress);\n\n                }\n\n            } else {\n\n                _addPoolActive(_poolStakingAddress, _poolStakingAddress != unremovableStakingAddress);\n\n            }\n\n        } else {\n\n            require(newStakeAmount == 0 || newStakeAmount >= getDelegatorMinStake());\n\n\n\n            if (_amount > 0) {\n\n                if (newStakeAmount == 0) {\n\n                    _removePoolDelegator(_poolStakingAddress, staker);\n\n                }\n\n            } else {\n\n                _addPoolDelegator(_poolStakingAddress, staker);\n\n            }\n\n        }\n\n\n\n        // Set total ordered amount for this pool\n\n        alreadyOrderedAmount = orderedWithdrawAmountTotal(_poolStakingAddress);\n\n        if (_amount > 0) {\n\n            newOrderedAmount = alreadyOrderedAmount.add(uint256(_amount));\n\n        } else {\n\n            newOrderedAmount = alreadyOrderedAmount.sub(uint256(-_amount));\n\n        }\n\n        _setOrderedWithdrawAmountTotal(_poolStakingAddress, newOrderedAmount);\n\n\n\n        uint256 epoch = stakingEpoch();\n\n\n\n        if (_amount > 0) {\n\n            _setOrderWithdrawEpoch(_poolStakingAddress, staker, epoch);\n\n        }\n\n\n\n        _setLikelihood(_poolStakingAddress);\n\n\n\n        emit WithdrawalOrdered(_poolStakingAddress, staker, epoch, _amount);\n",
          "message": "Reentrancy in StakingBase.orderWithdraw (StakingBase.sol#406-475):\n\tExternal calls:\n\t- require(bool)(_isWithdrawAllowed(validatorSetContract.miningByStakingAddress(_poolStakingAddress))) (StakingBase.sol#411)\n\t- require(bool)(_amount < 0 || uint256(_amount) <= maxWithdrawOrderAllowed(_poolStakingAddress,staker)) (StakingBase.sol#416)\n\tState variables written after the call(s):\n\t- uintStorage (StakingBase.sol#428)\n\t- uintStorage (StakingBase.sol#450)\n\t- uintStorage (StakingBase.sol#453)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 406,
          "vulnerability_to_line": 475,
          "vulnerability_code": "    function orderWithdraw(address _poolStakingAddress, int256 _amount) external gasPriceIsValid onlyInitialized {\n\n        IValidatorSet validatorSetContract = validatorSetContract();\n\n\n\n        require(_poolStakingAddress != address(0));\n\n        require(_amount != 0);\n\n        require(_isWithdrawAllowed(validatorSetContract.miningByStakingAddress(_poolStakingAddress)));\n\n\n\n        address staker = msg.sender;\n\n\n\n        // How much can `staker` order for withdrawal from `_poolStakingAddress` at the moment?\n\n        require(_amount < 0 || uint256(_amount) <= maxWithdrawOrderAllowed(_poolStakingAddress, staker));\n\n\n\n        uint256 alreadyOrderedAmount = orderedWithdrawAmount(_poolStakingAddress, staker);\n\n\n\n        require(_amount > 0 || uint256(-_amount) <= alreadyOrderedAmount);\n\n\n\n        uint256 newOrderedAmount;\n\n        if (_amount > 0) {\n\n            newOrderedAmount = alreadyOrderedAmount.add(uint256(_amount));\n\n        } else {\n\n            newOrderedAmount = alreadyOrderedAmount.sub(uint256(-_amount));\n\n        }\n\n        _setOrderedWithdrawAmount(_poolStakingAddress, staker, newOrderedAmount);\n\n\n\n        // The amount to be withdrawn must be the whole staked amount or\n\n        // must not exceed the diff between the entire amount and MIN_STAKE\n\n        uint256 newStakeAmount = stakeAmount(_poolStakingAddress, staker).sub(newOrderedAmount);\n\n        if (staker == _poolStakingAddress) {\n\n            require(newStakeAmount == 0 || newStakeAmount >= getCandidateMinStake());\n\n\n\n            address unremovableStakingAddress = validatorSetContract.unremovableValidator();\n\n\n\n            if (_amount > 0) {\n\n                if (newStakeAmount == 0 && _poolStakingAddress != unremovableStakingAddress) {\n\n                    _addPoolToBeRemoved(_poolStakingAddress);\n\n                }\n\n            } else {\n\n                _addPoolActive(_poolStakingAddress, _poolStakingAddress != unremovableStakingAddress);\n\n            }\n\n        } else {\n\n            require(newStakeAmount == 0 || newStakeAmount >= getDelegatorMinStake());\n\n\n\n            if (_amount > 0) {\n\n                if (newStakeAmount == 0) {\n\n                    _removePoolDelegator(_poolStakingAddress, staker);\n\n                }\n\n            } else {\n\n                _addPoolDelegator(_poolStakingAddress, staker);\n\n            }\n\n        }\n\n\n\n        // Set total ordered amount for this pool\n\n        alreadyOrderedAmount = orderedWithdrawAmountTotal(_poolStakingAddress);\n\n        if (_amount > 0) {\n\n            newOrderedAmount = alreadyOrderedAmount.add(uint256(_amount));\n\n        } else {\n\n            newOrderedAmount = alreadyOrderedAmount.sub(uint256(-_amount));\n\n        }\n\n        _setOrderedWithdrawAmountTotal(_poolStakingAddress, newOrderedAmount);\n\n\n\n        uint256 epoch = stakingEpoch();\n\n\n\n        if (_amount > 0) {\n\n            _setOrderWithdrawEpoch(_poolStakingAddress, staker, epoch);\n\n        }\n\n\n\n        _setLikelihood(_poolStakingAddress);\n\n\n\n        emit WithdrawalOrdered(_poolStakingAddress, staker, epoch, _amount);\n",
          "message": "Reentrancy in StakingBase.orderWithdraw (StakingBase.sol#406-475):\n\tExternal calls:\n\t- require(bool)(_isWithdrawAllowed(validatorSetContract.miningByStakingAddress(_poolStakingAddress))) (StakingBase.sol#411)\n\t- require(bool)(_amount < 0 || uint256(_amount) <= maxWithdrawOrderAllowed(_poolStakingAddress,staker)) (StakingBase.sol#416)\n\t- unremovableStakingAddress = validatorSetContract.unremovableValidator() (StakingBase.sol#436)\n\tState variables written after the call(s):\n\t- uintStorage (StakingBase.sol#440)\n\t- uintStorage (StakingBase.sol#443)\n\t- uintStorage (StakingBase.sol#464)\n\t- uintStorage (StakingBase.sol#469)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 336,
          "vulnerability_to_line": 344,
          "vulnerability_code": "    function removeMyPool() external gasPriceIsValid onlyInitialized {\n\n        IValidatorSet validatorSet = validatorSetContract();\n\n        address stakingAddress = msg.sender;\n\n        address miningAddress = validatorSet.miningByStakingAddress(stakingAddress);\n\n        // initial validator cannot remove their pool during the initial staking epoch\n\n        require(stakingEpoch() > 0 || !validatorSet.isValidator(miningAddress));\n\n        require(stakingAddress != validatorSet.unremovableValidator());\n\n        _removePool(stakingAddress);\n",
          "message": "Reentrancy in StakingBase.removeMyPool (StakingBase.sol#336-344):\n\tExternal calls:\n\t- miningAddress = validatorSet.miningByStakingAddress(stakingAddress) (StakingBase.sol#339)\n\t- require(bool)(stakingEpoch() > 0 || ! validatorSet.isValidator(miningAddress)) (StakingBase.sol#341)\n\t- require(bool)(stakingAddress != validatorSet.unremovableValidator()) (StakingBase.sol#342)\n\tState variables written after the call(s):\n\t- uintStorage (StakingBase.sol#343)\n"
        },
        {
          "name": "shadowing-local",
          "vulnerability_from_line": 407,
          "vulnerability_to_line": null,
          "vulnerability_code": "        IValidatorSet validatorSetContract = validatorSetContract();\n",
          "message": "StakingBase.orderWithdraw.validatorSetContract (local variable @ StakingBase.sol#407) shadows:\n\t- StakingBase.validatorSetContract (function @ StakingBase.sol#853-855)\n"
        },
        {
          "name": "shadowing-local",
          "vulnerability_from_line": 481,
          "vulnerability_to_line": null,
          "vulnerability_code": "        IValidatorSet validatorSetContract = validatorSetContract();\n",
          "message": "StakingBase.claimOrderedWithdraw.validatorSetContract (local variable @ StakingBase.sol#481) shadows:\n\t- StakingBase.validatorSetContract (function @ StakingBase.sol#853-855)\n"
        },
        {
          "name": "shadowing-local",
          "vulnerability_from_line": 633,
          "vulnerability_to_line": null,
          "vulnerability_code": "        IValidatorSet validatorSetContract = validatorSetContract();\n",
          "message": "StakingBase.maxWithdrawAllowed.validatorSetContract (local variable @ StakingBase.sol#633) shadows:\n\t- StakingBase.validatorSetContract (function @ StakingBase.sol#853-855)\n"
        },
        {
          "name": "shadowing-local",
          "vulnerability_from_line": 665,
          "vulnerability_to_line": null,
          "vulnerability_code": "        IValidatorSet validatorSetContract = validatorSetContract();\n",
          "message": "StakingBase.maxWithdrawOrderAllowed.validatorSetContract (local variable @ StakingBase.sol#665) shadows:\n\t- StakingBase.validatorSetContract (function @ StakingBase.sol#853-855)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 1024,
          "vulnerability_to_line": 1056,
          "vulnerability_code": "    function _initialize(\n\n        address _validatorSetContract,\n\n        address[] memory _initialStakingAddresses,\n\n        uint256 _delegatorMinStake,\n\n        uint256 _candidateMinStake,\n\n        bool _erc20Restricted\n\n    ) internal {\n\n        require(!isInitialized()); // initialization can only be done once\n\n        require(_validatorSetContract != address(0));\n\n        require(_initialStakingAddresses.length > 0);\n\n        require(_delegatorMinStake != 0);\n\n        require(_candidateMinStake != 0);\n\n\n\n        IBlockReward blockRewardContract = IBlockReward(IValidatorSet(_validatorSetContract).blockRewardContract());\n\n        require(MAX_DELEGATORS_PER_POOL % blockRewardContract.DELEGATORS_ALIQUOT() == 0);\n\n\n\n        addressStorage[VALIDATOR_SET_CONTRACT] = _validatorSetContract;\n\n\n\n        address unremovableStakingAddress = IValidatorSet(_validatorSetContract).unremovableValidator();\n\n\n\n        for (uint256 i = 0; i < _initialStakingAddresses.length; i++) {\n\n            require(_initialStakingAddresses[i] != address(0));\n\n            _addPoolActive(_initialStakingAddresses[i], false);\n\n            if (_initialStakingAddresses[i] != unremovableStakingAddress) {\n\n                _addPoolToBeRemoved(_initialStakingAddresses[i]);\n\n            }\n\n        }\n\n\n\n        _setDelegatorMinStake(_delegatorMinStake);\n\n        _setCandidateMinStake(_candidateMinStake);\n\n\n\n        boolStorage[ERC20_RESTRICTED] = _erc20Restricted;\n",
          "message": "Reentrancy in StakingBase._initialize (StakingBase.sol#1024-1056):\n\tExternal calls:\n\t- blockRewardContract = IBlockReward(IValidatorSet(_validatorSetContract).blockRewardContract()) (StakingBase.sol#1037)\n\t- require(bool)(MAX_DELEGATORS_PER_POOL % blockRewardContract.DELEGATORS_ALIQUOT() == 0) (StakingBase.sol#1038)\n\t- unremovableStakingAddress = IValidatorSet(_validatorSetContract).unremovableValidator() (StakingBase.sol#1042)\n\tState variables written after the call(s):\n\t- addressArrayStorage (StakingBase.sol#1046)\n\t- addressArrayStorage (StakingBase.sol#1048)\n\t- boolStorage (StakingBase.sol#1055)\n\t- intArrayStorage (StakingBase.sol#1046)\n\t- intArrayStorage (StakingBase.sol#1048)\n\t- intStorage (StakingBase.sol#1048)\n\t- uintStorage (StakingBase.sol#1046)\n\t- uintStorage (StakingBase.sol#1048)\n\t- uintStorage (StakingBase.sol#1052)\n\t- uintStorage (StakingBase.sol#1053)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 1296,
          "vulnerability_to_line": 1333,
          "vulnerability_code": "    function _stake(address _poolStakingAddress, address _staker, uint256 _amount) internal {\n\n        IValidatorSet validatorSet = validatorSetContract();\n\n        address poolMiningAddress = validatorSet.miningByStakingAddress(_poolStakingAddress);\n\n\n\n        require(poolMiningAddress != address(0));\n\n        require(_poolStakingAddress != address(0));\n\n        require(_amount != 0);\n\n        require(!validatorSet.isValidatorBanned(poolMiningAddress));\n\n        require(areStakeAndWithdrawAllowed());\n\n\n\n        uint256 newStakeAmount = stakeAmount(_poolStakingAddress, _staker).add(_amount);\n\n        if (_staker == _poolStakingAddress) {\n\n            require(newStakeAmount >= getCandidateMinStake()); // the staked amount must be at least CANDIDATE_MIN_STAKE\n\n        } else {\n\n            require(newStakeAmount >= getDelegatorMinStake()); // the staked amount must be at least DELEGATOR_MIN_STAKE\n\n\n\n            // The delegator cannot stake into the pool of the candidate which hasn't self-staked.\n\n            // Also, that candidate shouldn't want to withdraw all his funds.\n\n            require(stakeAmountMinusOrderedWithdraw(_poolStakingAddress, _poolStakingAddress) != 0);\n\n        }\n\n        _setStakeAmount(_poolStakingAddress, _staker, newStakeAmount);\n\n        _setStakeAmountByCurrentEpoch(\n\n            _poolStakingAddress,\n\n            _staker,\n\n            stakeAmountByCurrentEpoch(_poolStakingAddress, _staker).add(_amount)\n\n        );\n\n        _setStakeAmountTotal(_poolStakingAddress, stakeAmountTotal(_poolStakingAddress).add(_amount));\n\n\n\n        if (_staker == _poolStakingAddress) { // `staker` makes a stake for himself and becomes a candidate\n\n            // Add `_poolStakingAddress` to the array of pools\n\n            _addPoolActive(_poolStakingAddress, _poolStakingAddress != validatorSet.unremovableValidator());\n\n        } else {\n\n            // Add `_staker` to the array of pool's delegators\n\n            _addPoolDelegator(_poolStakingAddress, _staker);\n\n        }\n\n\n\n        _setLikelihood(_poolStakingAddress);\n",
          "message": "Reentrancy in StakingBase._stake (StakingBase.sol#1296-1333):\n\tExternal calls:\n\t- poolMiningAddress = validatorSet.miningByStakingAddress(_poolStakingAddress) (StakingBase.sol#1298)\n\t- require(bool)(! validatorSet.isValidatorBanned(poolMiningAddress)) (StakingBase.sol#1303)\n\tState variables written after the call(s):\n\t- addressArrayStorage (StakingBase.sol#1329)\n\t- uintStorage (StakingBase.sol#1316)\n\t- uintStorage (StakingBase.sol#1317-1321)\n\t- uintStorage (StakingBase.sol#1322)\n\t- uintStorage (StakingBase.sol#1329)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 1296,
          "vulnerability_to_line": 1333,
          "vulnerability_code": "    function _stake(address _poolStakingAddress, address _staker, uint256 _amount) internal {\n\n        IValidatorSet validatorSet = validatorSetContract();\n\n        address poolMiningAddress = validatorSet.miningByStakingAddress(_poolStakingAddress);\n\n\n\n        require(poolMiningAddress != address(0));\n\n        require(_poolStakingAddress != address(0));\n\n        require(_amount != 0);\n\n        require(!validatorSet.isValidatorBanned(poolMiningAddress));\n\n        require(areStakeAndWithdrawAllowed());\n\n\n\n        uint256 newStakeAmount = stakeAmount(_poolStakingAddress, _staker).add(_amount);\n\n        if (_staker == _poolStakingAddress) {\n\n            require(newStakeAmount >= getCandidateMinStake()); // the staked amount must be at least CANDIDATE_MIN_STAKE\n\n        } else {\n\n            require(newStakeAmount >= getDelegatorMinStake()); // the staked amount must be at least DELEGATOR_MIN_STAKE\n\n\n\n            // The delegator cannot stake into the pool of the candidate which hasn't self-staked.\n\n            // Also, that candidate shouldn't want to withdraw all his funds.\n\n            require(stakeAmountMinusOrderedWithdraw(_poolStakingAddress, _poolStakingAddress) != 0);\n\n        }\n\n        _setStakeAmount(_poolStakingAddress, _staker, newStakeAmount);\n\n        _setStakeAmountByCurrentEpoch(\n\n            _poolStakingAddress,\n\n            _staker,\n\n            stakeAmountByCurrentEpoch(_poolStakingAddress, _staker).add(_amount)\n\n        );\n\n        _setStakeAmountTotal(_poolStakingAddress, stakeAmountTotal(_poolStakingAddress).add(_amount));\n\n\n\n        if (_staker == _poolStakingAddress) { // `staker` makes a stake for himself and becomes a candidate\n\n            // Add `_poolStakingAddress` to the array of pools\n\n            _addPoolActive(_poolStakingAddress, _poolStakingAddress != validatorSet.unremovableValidator());\n\n        } else {\n\n            // Add `_staker` to the array of pool's delegators\n\n            _addPoolDelegator(_poolStakingAddress, _staker);\n\n        }\n\n\n\n        _setLikelihood(_poolStakingAddress);\n",
          "message": "Reentrancy in StakingBase._stake (StakingBase.sol#1296-1333):\n\tExternal calls:\n\t- poolMiningAddress = validatorSet.miningByStakingAddress(_poolStakingAddress) (StakingBase.sol#1298)\n\t- require(bool)(! validatorSet.isValidatorBanned(poolMiningAddress)) (StakingBase.sol#1303)\n\t- _addPoolActive(_poolStakingAddress,_poolStakingAddress != validatorSet.unremovableValidator()) (StakingBase.sol#1326)\n\tState variables written after the call(s):\n\t- intStorage (StakingBase.sol#1332)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 1376,
          "vulnerability_to_line": 1391,
          "vulnerability_code": "    function _withdrawCheckPool(address _poolStakingAddress, address _staker) internal {\n\n        if (_staker == _poolStakingAddress) {\n\n            IValidatorSet validatorSet = validatorSetContract();\n\n            address unremovableStakingAddress = validatorSet.unremovableValidator();\n\n\n\n            if (_poolStakingAddress != unremovableStakingAddress) {\n\n                if (validatorSet.isValidator(validatorSet.miningByStakingAddress(_poolStakingAddress))) {\n\n                    _addPoolToBeRemoved(_poolStakingAddress);\n\n                } else {\n\n                    _removePool(_poolStakingAddress);\n\n                }\n\n            }\n\n        } else {\n\n            _removePoolDelegator(_poolStakingAddress, _staker);\n\n        }\n",
          "message": "Reentrancy in StakingBase._withdrawCheckPool (StakingBase.sol#1376-1391):\n\tExternal calls:\n\t- unremovableStakingAddress = validatorSet.unremovableValidator() (StakingBase.sol#1379)\n\t- validatorSet.isValidator(validatorSet.miningByStakingAddress(_poolStakingAddress)) (StakingBase.sol#1382-1386)\n\tState variables written after the call(s):\n\t- addressArrayStorage (StakingBase.sol#1383)\n\t- intArrayStorage (StakingBase.sol#1383)\n\t- intStorage (StakingBase.sol#1383)\n\t- uintStorage (StakingBase.sol#1383)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 1376,
          "vulnerability_to_line": 1391,
          "vulnerability_code": "    function _withdrawCheckPool(address _poolStakingAddress, address _staker) internal {\n\n        if (_staker == _poolStakingAddress) {\n\n            IValidatorSet validatorSet = validatorSetContract();\n\n            address unremovableStakingAddress = validatorSet.unremovableValidator();\n\n\n\n            if (_poolStakingAddress != unremovableStakingAddress) {\n\n                if (validatorSet.isValidator(validatorSet.miningByStakingAddress(_poolStakingAddress))) {\n\n                    _addPoolToBeRemoved(_poolStakingAddress);\n\n                } else {\n\n                    _removePool(_poolStakingAddress);\n\n                }\n\n            }\n\n        } else {\n\n            _removePoolDelegator(_poolStakingAddress, _staker);\n\n        }\n",
          "message": "Reentrancy in StakingBase._withdrawCheckPool (StakingBase.sol#1376-1391):\n\tExternal calls:\n\t- unremovableStakingAddress = validatorSet.unremovableValidator() (StakingBase.sol#1379)\n\tState variables written after the call(s):\n\t- addressArrayStorage (StakingBase.sol#1385)\n\t- intArrayStorage (StakingBase.sol#1385)\n\t- intStorage (StakingBase.sol#1385)\n\t- uintStorage (StakingBase.sol#1385)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 406,
          "vulnerability_to_line": 475,
          "vulnerability_code": "    function orderWithdraw(address _poolStakingAddress, int256 _amount) external gasPriceIsValid onlyInitialized {\n\n        IValidatorSet validatorSetContract = validatorSetContract();\n\n\n\n        require(_poolStakingAddress != address(0));\n\n        require(_amount != 0);\n\n        require(_isWithdrawAllowed(validatorSetContract.miningByStakingAddress(_poolStakingAddress)));\n\n\n\n        address staker = msg.sender;\n\n\n\n        // How much can `staker` order for withdrawal from `_poolStakingAddress` at the moment?\n\n        require(_amount < 0 || uint256(_amount) <= maxWithdrawOrderAllowed(_poolStakingAddress, staker));\n\n\n\n        uint256 alreadyOrderedAmount = orderedWithdrawAmount(_poolStakingAddress, staker);\n\n\n\n        require(_amount > 0 || uint256(-_amount) <= alreadyOrderedAmount);\n\n\n\n        uint256 newOrderedAmount;\n\n        if (_amount > 0) {\n\n            newOrderedAmount = alreadyOrderedAmount.add(uint256(_amount));\n\n        } else {\n\n            newOrderedAmount = alreadyOrderedAmount.sub(uint256(-_amount));\n\n        }\n\n        _setOrderedWithdrawAmount(_poolStakingAddress, staker, newOrderedAmount);\n\n\n\n        // The amount to be withdrawn must be the whole staked amount or\n\n        // must not exceed the diff between the entire amount and MIN_STAKE\n\n        uint256 newStakeAmount = stakeAmount(_poolStakingAddress, staker).sub(newOrderedAmount);\n\n        if (staker == _poolStakingAddress) {\n\n            require(newStakeAmount == 0 || newStakeAmount >= getCandidateMinStake());\n\n\n\n            address unremovableStakingAddress = validatorSetContract.unremovableValidator();\n\n\n\n            if (_amount > 0) {\n\n                if (newStakeAmount == 0 && _poolStakingAddress != unremovableStakingAddress) {\n\n                    _addPoolToBeRemoved(_poolStakingAddress);\n\n                }\n\n            } else {\n\n                _addPoolActive(_poolStakingAddress, _poolStakingAddress != unremovableStakingAddress);\n\n            }\n\n        } else {\n\n            require(newStakeAmount == 0 || newStakeAmount >= getDelegatorMinStake());\n\n\n\n            if (_amount > 0) {\n\n                if (newStakeAmount == 0) {\n\n                    _removePoolDelegator(_poolStakingAddress, staker);\n\n                }\n\n            } else {\n\n                _addPoolDelegator(_poolStakingAddress, staker);\n\n            }\n\n        }\n\n\n\n        // Set total ordered amount for this pool\n\n        alreadyOrderedAmount = orderedWithdrawAmountTotal(_poolStakingAddress);\n\n        if (_amount > 0) {\n\n            newOrderedAmount = alreadyOrderedAmount.add(uint256(_amount));\n\n        } else {\n\n            newOrderedAmount = alreadyOrderedAmount.sub(uint256(-_amount));\n\n        }\n\n        _setOrderedWithdrawAmountTotal(_poolStakingAddress, newOrderedAmount);\n\n\n\n        uint256 epoch = stakingEpoch();\n\n\n\n        if (_amount > 0) {\n\n            _setOrderWithdrawEpoch(_poolStakingAddress, staker, epoch);\n\n        }\n\n\n\n        _setLikelihood(_poolStakingAddress);\n\n\n\n        emit WithdrawalOrdered(_poolStakingAddress, staker, epoch, _amount);\n",
          "message": "Reentrancy in StakingBase.orderWithdraw (StakingBase.sol#406-475):\n\tExternal calls:\n\t- require(bool)(_isWithdrawAllowed(validatorSetContract.miningByStakingAddress(_poolStakingAddress))) (StakingBase.sol#411)\n\t- require(bool)(_amount < 0 || uint256(_amount) <= maxWithdrawOrderAllowed(_poolStakingAddress,staker)) (StakingBase.sol#416)\n\t- unremovableStakingAddress = validatorSetContract.unremovableValidator() (StakingBase.sol#436)\n\tState variables written after the call(s):\n\t- addressArrayStorage (StakingBase.sol#440)\n\t- addressArrayStorage (StakingBase.sol#443)\n\t- intArrayStorage (StakingBase.sol#440)\n\t- intArrayStorage (StakingBase.sol#443)\n\t- intArrayStorage (StakingBase.sol#472)\n\t- intStorage (StakingBase.sol#440)\n\t- intStorage (StakingBase.sol#472)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 406,
          "vulnerability_to_line": 475,
          "vulnerability_code": "    function orderWithdraw(address _poolStakingAddress, int256 _amount) external gasPriceIsValid onlyInitialized {\n\n        IValidatorSet validatorSetContract = validatorSetContract();\n\n\n\n        require(_poolStakingAddress != address(0));\n\n        require(_amount != 0);\n\n        require(_isWithdrawAllowed(validatorSetContract.miningByStakingAddress(_poolStakingAddress)));\n\n\n\n        address staker = msg.sender;\n\n\n\n        // How much can `staker` order for withdrawal from `_poolStakingAddress` at the moment?\n\n        require(_amount < 0 || uint256(_amount) <= maxWithdrawOrderAllowed(_poolStakingAddress, staker));\n\n\n\n        uint256 alreadyOrderedAmount = orderedWithdrawAmount(_poolStakingAddress, staker);\n\n\n\n        require(_amount > 0 || uint256(-_amount) <= alreadyOrderedAmount);\n\n\n\n        uint256 newOrderedAmount;\n\n        if (_amount > 0) {\n\n            newOrderedAmount = alreadyOrderedAmount.add(uint256(_amount));\n\n        } else {\n\n            newOrderedAmount = alreadyOrderedAmount.sub(uint256(-_amount));\n\n        }\n\n        _setOrderedWithdrawAmount(_poolStakingAddress, staker, newOrderedAmount);\n\n\n\n        // The amount to be withdrawn must be the whole staked amount or\n\n        // must not exceed the diff between the entire amount and MIN_STAKE\n\n        uint256 newStakeAmount = stakeAmount(_poolStakingAddress, staker).sub(newOrderedAmount);\n\n        if (staker == _poolStakingAddress) {\n\n            require(newStakeAmount == 0 || newStakeAmount >= getCandidateMinStake());\n\n\n\n            address unremovableStakingAddress = validatorSetContract.unremovableValidator();\n\n\n\n            if (_amount > 0) {\n\n                if (newStakeAmount == 0 && _poolStakingAddress != unremovableStakingAddress) {\n\n                    _addPoolToBeRemoved(_poolStakingAddress);\n\n                }\n\n            } else {\n\n                _addPoolActive(_poolStakingAddress, _poolStakingAddress != unremovableStakingAddress);\n\n            }\n\n        } else {\n\n            require(newStakeAmount == 0 || newStakeAmount >= getDelegatorMinStake());\n\n\n\n            if (_amount > 0) {\n\n                if (newStakeAmount == 0) {\n\n                    _removePoolDelegator(_poolStakingAddress, staker);\n\n                }\n\n            } else {\n\n                _addPoolDelegator(_poolStakingAddress, staker);\n\n            }\n\n        }\n\n\n\n        // Set total ordered amount for this pool\n\n        alreadyOrderedAmount = orderedWithdrawAmountTotal(_poolStakingAddress);\n\n        if (_amount > 0) {\n\n            newOrderedAmount = alreadyOrderedAmount.add(uint256(_amount));\n\n        } else {\n\n            newOrderedAmount = alreadyOrderedAmount.sub(uint256(-_amount));\n\n        }\n\n        _setOrderedWithdrawAmountTotal(_poolStakingAddress, newOrderedAmount);\n\n\n\n        uint256 epoch = stakingEpoch();\n\n\n\n        if (_amount > 0) {\n\n            _setOrderWithdrawEpoch(_poolStakingAddress, staker, epoch);\n\n        }\n\n\n\n        _setLikelihood(_poolStakingAddress);\n\n\n\n        emit WithdrawalOrdered(_poolStakingAddress, staker, epoch, _amount);\n",
          "message": "Reentrancy in StakingBase.orderWithdraw (StakingBase.sol#406-475):\n\tExternal calls:\n\t- require(bool)(_isWithdrawAllowed(validatorSetContract.miningByStakingAddress(_poolStakingAddress))) (StakingBase.sol#411)\n\t- require(bool)(_amount < 0 || uint256(_amount) <= maxWithdrawOrderAllowed(_poolStakingAddress,staker)) (StakingBase.sol#416)\n\tState variables written after the call(s):\n\t- addressArrayStorage (StakingBase.sol#450)\n\t- addressArrayStorage (StakingBase.sol#453)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 336,
          "vulnerability_to_line": 344,
          "vulnerability_code": "    function removeMyPool() external gasPriceIsValid onlyInitialized {\n\n        IValidatorSet validatorSet = validatorSetContract();\n\n        address stakingAddress = msg.sender;\n\n        address miningAddress = validatorSet.miningByStakingAddress(stakingAddress);\n\n        // initial validator cannot remove their pool during the initial staking epoch\n\n        require(stakingEpoch() > 0 || !validatorSet.isValidator(miningAddress));\n\n        require(stakingAddress != validatorSet.unremovableValidator());\n\n        _removePool(stakingAddress);\n",
          "message": "Reentrancy in StakingBase.removeMyPool (StakingBase.sol#336-344):\n\tExternal calls:\n\t- miningAddress = validatorSet.miningByStakingAddress(stakingAddress) (StakingBase.sol#339)\n\t- require(bool)(stakingEpoch() > 0 || ! validatorSet.isValidator(miningAddress)) (StakingBase.sol#341)\n\t- require(bool)(stakingAddress != validatorSet.unremovableValidator()) (StakingBase.sol#342)\n\tState variables written after the call(s):\n\t- addressArrayStorage (StakingBase.sol#343)\n\t- intArrayStorage (StakingBase.sol#343)\n\t- intStorage (StakingBase.sol#343)\n"
        },
        {
          "name": "constable-states",
          "vulnerability_from_line": 97,
          "vulnerability_to_line": null,
          "vulnerability_code": "    address internal _owner;\n",
          "message": "EternalStorage._owner should be constant (StakingBase.sol#97)\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 596,
          "vulnerability_to_line": 598,
          "vulnerability_code": "    function erc20Restricted() public view returns(bool) {\n\n        return boolStorage[ERC20_RESTRICTED];\n",
          "message": "StakingBase.erc20Restricted (StakingBase.sol#596-598) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 41,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function erc20Restricted() external view returns(bool);\n",
          "message": "IStaking.erc20Restricted (StakingBase.sol#41) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 733,
          "vulnerability_to_line": 735,
          "vulnerability_code": "    function poolDelegators(address _poolStakingAddress) public view returns(address[] memory) {\n\n        return addressArrayStorage[keccak256(abi.encode(POOL_DELEGATORS, _poolStakingAddress))];\n",
          "message": "StakingBase.poolDelegators (StakingBase.sol#733-735) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 46,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function poolDelegators(address) external view returns(address[] memory);\n",
          "message": "IStaking.poolDelegators (StakingBase.sol#46) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 693,
          "vulnerability_to_line": 695,
          "vulnerability_code": "    function onTokenTransfer(address, uint256, bytes memory) public pure returns(bool) {\n\n        return false;\n",
          "message": "StakingBase.onTokenTransfer (StakingBase.sol#693-695) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 741,
          "vulnerability_to_line": 743,
          "vulnerability_code": "    function poolDelegatorsInactive(address _poolStakingAddress) public view returns(address[] memory) {\n\n        return addressArrayStorage[keccak256(abi.encode(POOL_DELEGATORS_INACTIVE, _poolStakingAddress))];\n",
          "message": "StakingBase.poolDelegatorsInactive (StakingBase.sol#741-743) should be declared external\n"
        },
        {
          "name": "solc-version",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity 0.5.9;\n",
          "message": "Detected issues with version pragma in StakingBase.sol:\n\t- pragma solidity0.5.9 (StakingBase.sol#3): it allows old versions\n\t- pragma solidity0.5.9 (StakingBase.sol#17): it allows old versions\n\t- pragma solidity0.5.9 (StakingBase.sol#34): it allows old versions\n\t- pragma solidity0.5.9 (StakingBase.sol#54): it allows old versions\n\t- pragma solidity0.5.9 (StakingBase.sol#89): it allows old versions\n\t- pragma solidity0.5.9 (StakingBase.sol#120): it allows old versions\n\t- pragma solidity0.5.9 (StakingBase.sol#138): it allows old versions\n\t- pragma solidity0.5.9 (StakingBase.sol#177): it allows old versions\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 7,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function initialize(address) external;\n",
          "message": "Parameter '' of IBlockReward.initialize (StakingBase.sol#7) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 8,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function DELEGATORS_ALIQUOT() external view returns(uint256); // solhint-disable-line func-name-mixedcase\n",
          "message": "Function 'IBlockReward.DELEGATORS_ALIQUOT' (StakingBase.sol#8) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 29,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function balanceOf(address) external view returns(uint256);\n",
          "message": "Parameter '' of IERC20Minting.balanceOf (StakingBase.sol#29) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 38,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function clearUnremovableValidator(address) external;\n",
          "message": "Parameter '' of IStaking.clearUnremovableValidator (StakingBase.sol#38) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 40,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function removePool(address) external;\n",
          "message": "Parameter '' of IStaking.removePool (StakingBase.sol#40) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 46,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function poolDelegators(address) external view returns(address[] memory);\n",
          "message": "Parameter '' of IStaking.poolDelegators (StakingBase.sol#46) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 47,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function stakeAmountMinusOrderedWithdraw(address, address) external view returns(uint256);\n",
          "message": "Parameter '' of IStaking.stakeAmountMinusOrderedWithdraw (StakingBase.sol#47) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 47,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function stakeAmountMinusOrderedWithdraw(address, address) external view returns(uint256);\n",
          "message": "Parameter '_scope_0' of IStaking.stakeAmountMinusOrderedWithdraw (StakingBase.sol#47) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 48,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function stakeAmountTotalMinusOrderedWithdraw(address) external view returns(uint256);\n",
          "message": "Parameter '' of IStaking.stakeAmountTotalMinusOrderedWithdraw (StakingBase.sol#48) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 59,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address,\n",
          "message": "Parameter '' of IValidatorSet.initialize (StakingBase.sol#59) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 60,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address,\n",
          "message": "Parameter '_scope_0' of IValidatorSet.initialize (StakingBase.sol#60) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 61,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address,\n",
          "message": "Parameter '_scope_1' of IValidatorSet.initialize (StakingBase.sol#61) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 62,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address[] calldata,\n",
          "message": "Parameter '_scope_2' of IValidatorSet.initialize (StakingBase.sol#62) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 63,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address[] calldata,\n",
          "message": "Parameter '_scope_3' of IValidatorSet.initialize (StakingBase.sol#63) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 64,
          "vulnerability_to_line": null,
          "vulnerability_code": "        bool\n",
          "message": "Parameter '_scope_4' of IValidatorSet.initialize (StakingBase.sol#64) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 67,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setStakingAddress(address, address) external;\n",
          "message": "Parameter '' of IValidatorSet.setStakingAddress (StakingBase.sol#67) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 67,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setStakingAddress(address, address) external;\n",
          "message": "Parameter '_scope_0' of IValidatorSet.setStakingAddress (StakingBase.sol#67) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 74,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function isReportValidatorValid(address) external view returns(bool);\n",
          "message": "Parameter '' of IValidatorSet.isReportValidatorValid (StakingBase.sol#74) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 75,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function isValidator(address) external view returns(bool);\n",
          "message": "Parameter '' of IValidatorSet.isValidator (StakingBase.sol#75) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 76,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function isValidatorBanned(address) external view returns(bool);\n",
          "message": "Parameter '' of IValidatorSet.isValidatorBanned (StakingBase.sol#76) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 77,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function MAX_VALIDATORS() external view returns(uint256); // solhint-disable-line func-name-mixedcase\n",
          "message": "Function 'IValidatorSet.MAX_VALIDATORS' (StakingBase.sol#77) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 78,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function miningByStakingAddress(address) external view returns(address);\n",
          "message": "Parameter '' of IValidatorSet.miningByStakingAddress (StakingBase.sol#78) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 80,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function stakingByMiningAddress(address) external view returns(address);\n",
          "message": "Parameter '' of IValidatorSet.stakingByMiningAddress (StakingBase.sol#80) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 83,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function validatorIndex(address) external view returns(uint256);\n",
          "message": "Parameter '' of IValidatorSet.validatorIndex (StakingBase.sol#83) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 97,
          "vulnerability_to_line": null,
          "vulnerability_code": "    address internal _owner;\n",
          "message": "Variable 'EternalStorage._owner' (StakingBase.sol#97) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 308,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function clearUnremovableValidator(address _unremovableStakingAddress) external onlyValidatorSetContract {\n",
          "message": "Parameter '_unremovableStakingAddress' of StakingBase.clearUnremovableValidator (StakingBase.sol#308) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 328,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function removePool(address _stakingAddress) external onlyValidatorSetContract {\n",
          "message": "Parameter '_stakingAddress' of StakingBase.removePool (StakingBase.sol#328) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 733,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function poolDelegators(address _poolStakingAddress) public view returns(address[] memory) {\n",
          "message": "Parameter '_poolStakingAddress' of StakingBase.poolDelegators (StakingBase.sol#733) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 829,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address _poolStakingAddress,\n",
          "message": "Parameter '_poolStakingAddress' of StakingBase.stakeAmountMinusOrderedWithdraw (StakingBase.sol#829) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 830,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address _staker\n",
          "message": "Parameter '_staker' of StakingBase.stakeAmountMinusOrderedWithdraw (StakingBase.sol#830) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 841,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function stakeAmountTotalMinusOrderedWithdraw(address _poolStakingAddress) public view returns(uint256) {\n",
          "message": "Parameter '_poolStakingAddress' of StakingBase.stakeAmountTotalMinusOrderedWithdraw (StakingBase.sol#841) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 353,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address _fromPoolStakingAddress,\n",
          "message": "Parameter '_fromPoolStakingAddress' of StakingBase.moveStake (StakingBase.sol#353) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 354,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address _toPoolStakingAddress,\n",
          "message": "Parameter '_toPoolStakingAddress' of StakingBase.moveStake (StakingBase.sol#354) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 355,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint256 _amount\n",
          "message": "Parameter '_amount' of StakingBase.moveStake (StakingBase.sol#355) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 368,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function stake(address _toPoolStakingAddress, uint256 _amount) external gasPriceIsValid onlyInitialized {\n",
          "message": "Parameter '_toPoolStakingAddress' of StakingBase.stake (StakingBase.sol#368) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 368,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function stake(address _toPoolStakingAddress, uint256 _amount) external gasPriceIsValid onlyInitialized {\n",
          "message": "Parameter '_amount' of StakingBase.stake (StakingBase.sol#368) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 375,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function stakeNative(address _toPoolStakingAddress) external gasPriceIsValid onlyInitialized payable {\n",
          "message": "Parameter '_toPoolStakingAddress' of StakingBase.stakeNative (StakingBase.sol#375) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 385,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function withdraw(address _fromPoolStakingAddress, uint256 _amount) external gasPriceIsValid onlyInitialized {\n",
          "message": "Parameter '_fromPoolStakingAddress' of StakingBase.withdraw (StakingBase.sol#385) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 385,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function withdraw(address _fromPoolStakingAddress, uint256 _amount) external gasPriceIsValid onlyInitialized {\n",
          "message": "Parameter '_amount' of StakingBase.withdraw (StakingBase.sol#385) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 406,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function orderWithdraw(address _poolStakingAddress, int256 _amount) external gasPriceIsValid onlyInitialized {\n",
          "message": "Parameter '_poolStakingAddress' of StakingBase.orderWithdraw (StakingBase.sol#406) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 406,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function orderWithdraw(address _poolStakingAddress, int256 _amount) external gasPriceIsValid onlyInitialized {\n",
          "message": "Parameter '_amount' of StakingBase.orderWithdraw (StakingBase.sol#406) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 480,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function claimOrderedWithdraw(address _poolStakingAddress) external gasPriceIsValid onlyInitialized {\n",
          "message": "Parameter '_poolStakingAddress' of StakingBase.claimOrderedWithdraw (StakingBase.sol#480) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 522,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setErc20TokenContract(address _erc20TokenContract) external onlyOwner onlyInitialized {\n",
          "message": "Parameter '_erc20TokenContract' of StakingBase.setErc20TokenContract (StakingBase.sol#522) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 531,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setCandidateMinStake(uint256 _minStake) external onlyOwner onlyInitialized {\n",
          "message": "Parameter '_minStake' of StakingBase.setCandidateMinStake (StakingBase.sol#531) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 538,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setDelegatorMinStake(uint256 _minStake) external onlyOwner onlyInitialized {\n",
          "message": "Parameter '_minStake' of StakingBase.setDelegatorMinStake (StakingBase.sol#538) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 623,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function isPoolActive(address _stakingAddress) public view returns(bool) {\n",
          "message": "Parameter '_stakingAddress' of StakingBase.isPoolActive (StakingBase.sol#623) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 632,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function maxWithdrawAllowed(address _poolStakingAddress, address _staker) public view returns(uint256) {\n",
          "message": "Parameter '_poolStakingAddress' of StakingBase.maxWithdrawAllowed (StakingBase.sol#632) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 632,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function maxWithdrawAllowed(address _poolStakingAddress, address _staker) public view returns(uint256) {\n",
          "message": "Parameter '_staker' of StakingBase.maxWithdrawAllowed (StakingBase.sol#632) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 664,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function maxWithdrawOrderAllowed(address _poolStakingAddress, address _staker) public view returns(uint256) {\n",
          "message": "Parameter '_poolStakingAddress' of StakingBase.maxWithdrawOrderAllowed (StakingBase.sol#664) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 664,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function maxWithdrawOrderAllowed(address _poolStakingAddress, address _staker) public view returns(uint256) {\n",
          "message": "Parameter '_staker' of StakingBase.maxWithdrawOrderAllowed (StakingBase.sol#664) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 693,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function onTokenTransfer(address, uint256, bytes memory) public pure returns(bool) {\n",
          "message": "Parameter '' of StakingBase.onTokenTransfer (StakingBase.sol#693) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 693,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function onTokenTransfer(address, uint256, bytes memory) public pure returns(bool) {\n",
          "message": "Parameter '_scope_0' of StakingBase.onTokenTransfer (StakingBase.sol#693) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 693,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function onTokenTransfer(address, uint256, bytes memory) public pure returns(bool) {\n",
          "message": "Parameter '_scope_1' of StakingBase.onTokenTransfer (StakingBase.sol#693) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 701,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function orderedWithdrawAmount(address _poolStakingAddress, address _staker) public view returns(uint256) {\n",
          "message": "Parameter '_poolStakingAddress' of StakingBase.orderedWithdrawAmount (StakingBase.sol#701) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 701,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function orderedWithdrawAmount(address _poolStakingAddress, address _staker) public view returns(uint256) {\n",
          "message": "Parameter '_staker' of StakingBase.orderedWithdrawAmount (StakingBase.sol#701) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 708,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function orderedWithdrawAmountTotal(address _poolStakingAddress) public view returns(uint256) {\n",
          "message": "Parameter '_poolStakingAddress' of StakingBase.orderedWithdrawAmountTotal (StakingBase.sol#708) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 717,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function orderWithdrawEpoch(address _poolStakingAddress, address _staker) public view returns(uint256) {\n",
          "message": "Parameter '_poolStakingAddress' of StakingBase.orderWithdrawEpoch (StakingBase.sol#717) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 717,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function orderWithdrawEpoch(address _poolStakingAddress, address _staker) public view returns(uint256) {\n",
          "message": "Parameter '_staker' of StakingBase.orderWithdrawEpoch (StakingBase.sol#717) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 725,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function stakeAmountTotal(address _poolStakingAddress) public view returns(uint256) {\n",
          "message": "Parameter '_poolStakingAddress' of StakingBase.stakeAmountTotal (StakingBase.sol#725) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 741,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function poolDelegatorsInactive(address _poolStakingAddress) public view returns(address[] memory) {\n",
          "message": "Parameter '_poolStakingAddress' of StakingBase.poolDelegatorsInactive (StakingBase.sol#741) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 751,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function poolDelegatorIndex(address _poolStakingAddress, address _delegator) public view returns(uint256) {\n",
          "message": "Parameter '_poolStakingAddress' of StakingBase.poolDelegatorIndex (StakingBase.sol#751) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 751,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function poolDelegatorIndex(address _poolStakingAddress, address _delegator) public view returns(uint256) {\n",
          "message": "Parameter '_delegator' of StakingBase.poolDelegatorIndex (StakingBase.sol#751) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 761,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function poolDelegatorInactiveIndex(address _poolStakingAddress, address _delegator) public view returns(uint256) {\n",
          "message": "Parameter '_poolStakingAddress' of StakingBase.poolDelegatorInactiveIndex (StakingBase.sol#761) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 761,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function poolDelegatorInactiveIndex(address _poolStakingAddress, address _delegator) public view returns(uint256) {\n",
          "message": "Parameter '_delegator' of StakingBase.poolDelegatorInactiveIndex (StakingBase.sol#761) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 770,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function poolIndex(address _stakingAddress) public view returns(uint256) {\n",
          "message": "Parameter '_stakingAddress' of StakingBase.poolIndex (StakingBase.sol#770) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 777,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function poolInactiveIndex(address _stakingAddress) public view returns(uint256) {\n",
          "message": "Parameter '_stakingAddress' of StakingBase.poolInactiveIndex (StakingBase.sol#777) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 786,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function poolToBeElectedIndex(address _stakingAddress) public view returns(uint256) {\n",
          "message": "Parameter '_stakingAddress' of StakingBase.poolToBeElectedIndex (StakingBase.sol#786) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 795,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function poolToBeRemovedIndex(address _stakingAddress) public view returns(uint256) {\n",
          "message": "Parameter '_stakingAddress' of StakingBase.poolToBeRemovedIndex (StakingBase.sol#795) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 804,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function stakeAmount(address _poolStakingAddress, address _staker) public view returns(uint256) {\n",
          "message": "Parameter '_poolStakingAddress' of StakingBase.stakeAmount (StakingBase.sol#804) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 804,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function stakeAmount(address _poolStakingAddress, address _staker) public view returns(uint256) {\n",
          "message": "Parameter '_staker' of StakingBase.stakeAmount (StakingBase.sol#804) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 813,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function stakeAmountByCurrentEpoch(address _poolStakingAddress, address _staker)\n",
          "message": "Parameter '_poolStakingAddress' of StakingBase.stakeAmountByCurrentEpoch (StakingBase.sol#813) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 813,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function stakeAmountByCurrentEpoch(address _poolStakingAddress, address _staker)\n",
          "message": "Parameter '_staker' of StakingBase.stakeAmountByCurrentEpoch (StakingBase.sol#813) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 892,
          "vulnerability_to_line": 903,
          "vulnerability_code": "    function _addPoolActive(address _stakingAddress, bool _toBeElected) internal {\n\n        address[] storage pools = addressArrayStorage[POOLS];\n\n        if (!isPoolActive(_stakingAddress)) {\n\n            _setPoolIndex(_stakingAddress, pools.length);\n\n            pools.push(_stakingAddress);\n\n            require(pools.length <= _getMaxCandidates());\n\n        }\n\n        _removePoolInactive(_stakingAddress);\n\n        if (_toBeElected) {\n\n            _addPoolToBeElected(_stakingAddress);\n\n        }\n",
          "message": "Function 'StakingBase._addPoolActive' (StakingBase.sol#892-903) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 892,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _addPoolActive(address _stakingAddress, bool _toBeElected) internal {\n",
          "message": "Parameter '_stakingAddress' of StakingBase._addPoolActive (StakingBase.sol#892) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 892,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _addPoolActive(address _stakingAddress, bool _toBeElected) internal {\n",
          "message": "Parameter '_toBeElected' of StakingBase._addPoolActive (StakingBase.sol#892) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 908,
          "vulnerability_to_line": 915,
          "vulnerability_code": "    function _addPoolInactive(address _stakingAddress) internal {\n\n        address[] storage pools = addressArrayStorage[POOLS_INACTIVE];\n\n        uint256 index = poolInactiveIndex(_stakingAddress);\n\n        if (index >= pools.length || pools[index] != _stakingAddress) {\n\n            _setPoolInactiveIndex(_stakingAddress, pools.length);\n\n            pools.push(_stakingAddress);\n\n        }\n",
          "message": "Function 'StakingBase._addPoolInactive' (StakingBase.sol#908-915) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 908,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _addPoolInactive(address _stakingAddress) internal {\n",
          "message": "Parameter '_stakingAddress' of StakingBase._addPoolInactive (StakingBase.sol#908) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 920,
          "vulnerability_to_line": 929,
          "vulnerability_code": "    function _addPoolToBeElected(address _stakingAddress) internal {\n\n        address[] storage pools = addressArrayStorage[POOLS_TO_BE_ELECTED];\n\n        uint256 index = poolToBeElectedIndex(_stakingAddress);\n\n        if (index >= pools.length || pools[index] != _stakingAddress) {\n\n            _setPoolToBeElectedIndex(_stakingAddress, pools.length);\n\n            pools.push(_stakingAddress);\n\n            intArrayStorage[POOLS_LIKELIHOOD].push(0);\n\n        }\n\n        _deletePoolToBeRemoved(_stakingAddress);\n",
          "message": "Function 'StakingBase._addPoolToBeElected' (StakingBase.sol#920-929) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 920,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _addPoolToBeElected(address _stakingAddress) internal {\n",
          "message": "Parameter '_stakingAddress' of StakingBase._addPoolToBeElected (StakingBase.sol#920) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 934,
          "vulnerability_to_line": 942,
          "vulnerability_code": "    function _addPoolToBeRemoved(address _stakingAddress) internal {\n\n        address[] storage pools = addressArrayStorage[POOLS_TO_BE_REMOVED];\n\n        uint256 index = poolToBeRemovedIndex(_stakingAddress);\n\n        if (index >= pools.length || pools[index] != _stakingAddress) {\n\n            _setPoolToBeRemovedIndex(_stakingAddress, pools.length);\n\n            pools.push(_stakingAddress);\n\n        }\n\n        _deletePoolToBeElected(_stakingAddress);\n",
          "message": "Function 'StakingBase._addPoolToBeRemoved' (StakingBase.sol#934-942) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 934,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _addPoolToBeRemoved(address _stakingAddress) internal {\n",
          "message": "Parameter '_stakingAddress' of StakingBase._addPoolToBeRemoved (StakingBase.sol#934) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 948,
          "vulnerability_to_line": 965,
          "vulnerability_code": "    function _deletePoolToBeElected(address _stakingAddress) internal {\n\n        address[] storage pools = addressArrayStorage[POOLS_TO_BE_ELECTED];\n\n        int256[] storage likelihood = intArrayStorage[POOLS_LIKELIHOOD];\n\n        if (pools.length != likelihood.length) return;\n\n        uint256 indexToDelete = poolToBeElectedIndex(_stakingAddress);\n\n        if (pools.length > indexToDelete && pools[indexToDelete] == _stakingAddress) {\n\n            intStorage[POOLS_LIKELIHOOD_SUM] -= likelihood[indexToDelete];\n\n            if (intStorage[POOLS_LIKELIHOOD_SUM] < 0) {\n\n                intStorage[POOLS_LIKELIHOOD_SUM] = 0;\n\n            }\n\n            pools[indexToDelete] = pools[pools.length - 1];\n\n            likelihood[indexToDelete] = likelihood[pools.length - 1];\n\n            _setPoolToBeElectedIndex(pools[indexToDelete], indexToDelete);\n\n            _setPoolToBeElectedIndex(_stakingAddress, 0);\n\n            pools.length--;\n\n            likelihood.length--;\n\n        }\n",
          "message": "Function 'StakingBase._deletePoolToBeElected' (StakingBase.sol#948-965) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 948,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _deletePoolToBeElected(address _stakingAddress) internal {\n",
          "message": "Parameter '_stakingAddress' of StakingBase._deletePoolToBeElected (StakingBase.sol#948) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 971,
          "vulnerability_to_line": 980,
          "vulnerability_code": "    function _deletePoolToBeRemoved(address _stakingAddress) internal {\n\n        address[] storage pools = addressArrayStorage[POOLS_TO_BE_REMOVED];\n\n        uint256 indexToDelete = poolToBeRemovedIndex(_stakingAddress);\n\n        if (pools.length > indexToDelete && pools[indexToDelete] == _stakingAddress) {\n\n            pools[indexToDelete] = pools[pools.length - 1];\n\n            _setPoolToBeRemovedIndex(pools[indexToDelete], indexToDelete);\n\n            _setPoolToBeRemovedIndex(_stakingAddress, 0);\n\n            pools.length--;\n\n        }\n",
          "message": "Function 'StakingBase._deletePoolToBeRemoved' (StakingBase.sol#971-980) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 971,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _deletePoolToBeRemoved(address _stakingAddress) internal {\n",
          "message": "Parameter '_stakingAddress' of StakingBase._deletePoolToBeRemoved (StakingBase.sol#971) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 985,
          "vulnerability_to_line": 1001,
          "vulnerability_code": "    function _removePool(address _stakingAddress) internal {\n\n        uint256 indexToRemove = poolIndex(_stakingAddress);\n\n        address[] storage pools = addressArrayStorage[POOLS];\n\n        if (pools.length > indexToRemove && pools[indexToRemove] == _stakingAddress) {\n\n            pools[indexToRemove] = pools[pools.length - 1];\n\n            _setPoolIndex(pools[indexToRemove], indexToRemove);\n\n            _setPoolIndex(_stakingAddress, 0);\n\n            pools.length--;\n\n        }\n\n        if (stakeAmountTotal(_stakingAddress) != 0) {\n\n            _addPoolInactive(_stakingAddress);\n\n        } else {\n\n            _removePoolInactive(_stakingAddress);\n\n        }\n\n        _deletePoolToBeElected(_stakingAddress);\n\n        _deletePoolToBeRemoved(_stakingAddress);\n",
          "message": "Function 'StakingBase._removePool' (StakingBase.sol#985-1001) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 985,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _removePool(address _stakingAddress) internal {\n",
          "message": "Parameter '_stakingAddress' of StakingBase._removePool (StakingBase.sol#985) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1006,
          "vulnerability_to_line": 1015,
          "vulnerability_code": "    function _removePoolInactive(address _stakingAddress) internal {\n\n        address[] storage pools = addressArrayStorage[POOLS_INACTIVE];\n\n        uint256 indexToRemove = poolInactiveIndex(_stakingAddress);\n\n        if (pools.length > indexToRemove && pools[indexToRemove] == _stakingAddress) {\n\n            pools[indexToRemove] = pools[pools.length - 1];\n\n            _setPoolInactiveIndex(pools[indexToRemove], indexToRemove);\n\n            _setPoolInactiveIndex(_stakingAddress, 0);\n\n            pools.length--;\n\n        }\n",
          "message": "Function 'StakingBase._removePoolInactive' (StakingBase.sol#1006-1015) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1006,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _removePoolInactive(address _stakingAddress) internal {\n",
          "message": "Parameter '_stakingAddress' of StakingBase._removePoolInactive (StakingBase.sol#1006) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1024,
          "vulnerability_to_line": 1056,
          "vulnerability_code": "    function _initialize(\n\n        address _validatorSetContract,\n\n        address[] memory _initialStakingAddresses,\n\n        uint256 _delegatorMinStake,\n\n        uint256 _candidateMinStake,\n\n        bool _erc20Restricted\n\n    ) internal {\n\n        require(!isInitialized()); // initialization can only be done once\n\n        require(_validatorSetContract != address(0));\n\n        require(_initialStakingAddresses.length > 0);\n\n        require(_delegatorMinStake != 0);\n\n        require(_candidateMinStake != 0);\n\n\n\n        IBlockReward blockRewardContract = IBlockReward(IValidatorSet(_validatorSetContract).blockRewardContract());\n\n        require(MAX_DELEGATORS_PER_POOL % blockRewardContract.DELEGATORS_ALIQUOT() == 0);\n\n\n\n        addressStorage[VALIDATOR_SET_CONTRACT] = _validatorSetContract;\n\n\n\n        address unremovableStakingAddress = IValidatorSet(_validatorSetContract).unremovableValidator();\n\n\n\n        for (uint256 i = 0; i < _initialStakingAddresses.length; i++) {\n\n            require(_initialStakingAddresses[i] != address(0));\n\n            _addPoolActive(_initialStakingAddresses[i], false);\n\n            if (_initialStakingAddresses[i] != unremovableStakingAddress) {\n\n                _addPoolToBeRemoved(_initialStakingAddresses[i]);\n\n            }\n\n        }\n\n\n\n        _setDelegatorMinStake(_delegatorMinStake);\n\n        _setCandidateMinStake(_candidateMinStake);\n\n\n\n        boolStorage[ERC20_RESTRICTED] = _erc20Restricted;\n",
          "message": "Function 'StakingBase._initialize' (StakingBase.sol#1024-1056) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1025,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address _validatorSetContract,\n",
          "message": "Parameter '_validatorSetContract' of StakingBase._initialize (StakingBase.sol#1025) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1026,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address[] memory _initialStakingAddresses,\n",
          "message": "Parameter '_initialStakingAddresses' of StakingBase._initialize (StakingBase.sol#1026) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1027,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint256 _delegatorMinStake,\n",
          "message": "Parameter '_delegatorMinStake' of StakingBase._initialize (StakingBase.sol#1027) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1028,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint256 _candidateMinStake,\n",
          "message": "Parameter '_candidateMinStake' of StakingBase._initialize (StakingBase.sol#1028) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1029,
          "vulnerability_to_line": null,
          "vulnerability_code": "        bool _erc20Restricted\n",
          "message": "Parameter '_erc20Restricted' of StakingBase._initialize (StakingBase.sol#1029) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1065,
          "vulnerability_to_line": 1067,
          "vulnerability_code": "    function _setOrderWithdrawEpoch(address _poolStakingAddress, address _staker, uint256 _stakingEpoch) internal {\n\n        uintStorage[keccak256(abi.encode(ORDER_WITHDRAW_EPOCH, _poolStakingAddress, _staker))] = _stakingEpoch;\n",
          "message": "Function 'StakingBase._setOrderWithdrawEpoch' (StakingBase.sol#1065-1067) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1065,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setOrderWithdrawEpoch(address _poolStakingAddress, address _staker, uint256 _stakingEpoch) internal {\n",
          "message": "Parameter '_poolStakingAddress' of StakingBase._setOrderWithdrawEpoch (StakingBase.sol#1065) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1065,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setOrderWithdrawEpoch(address _poolStakingAddress, address _staker, uint256 _stakingEpoch) internal {\n",
          "message": "Parameter '_staker' of StakingBase._setOrderWithdrawEpoch (StakingBase.sol#1065) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1065,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setOrderWithdrawEpoch(address _poolStakingAddress, address _staker, uint256 _stakingEpoch) internal {\n",
          "message": "Parameter '_stakingEpoch' of StakingBase._setOrderWithdrawEpoch (StakingBase.sol#1065) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1074,
          "vulnerability_to_line": 1076,
          "vulnerability_code": "    function _setPoolDelegatorIndex(address _poolStakingAddress, address _delegator, uint256 _index) internal {\n\n        uintStorage[keccak256(abi.encode(POOL_DELEGATOR_INDEX, _poolStakingAddress, _delegator))] = _index;\n",
          "message": "Function 'StakingBase._setPoolDelegatorIndex' (StakingBase.sol#1074-1076) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1074,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setPoolDelegatorIndex(address _poolStakingAddress, address _delegator, uint256 _index) internal {\n",
          "message": "Parameter '_poolStakingAddress' of StakingBase._setPoolDelegatorIndex (StakingBase.sol#1074) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1074,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setPoolDelegatorIndex(address _poolStakingAddress, address _delegator, uint256 _index) internal {\n",
          "message": "Parameter '_delegator' of StakingBase._setPoolDelegatorIndex (StakingBase.sol#1074) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1074,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setPoolDelegatorIndex(address _poolStakingAddress, address _delegator, uint256 _index) internal {\n",
          "message": "Parameter '_index' of StakingBase._setPoolDelegatorIndex (StakingBase.sol#1074) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1083,
          "vulnerability_to_line": 1085,
          "vulnerability_code": "    function _setPoolDelegatorInactiveIndex(address _poolStakingAddress, address _delegator, uint256 _index) internal {\n\n        uintStorage[keccak256(abi.encode(POOL_DELEGATOR_INACTIVE_INDEX, _poolStakingAddress, _delegator))] = _index;\n",
          "message": "Function 'StakingBase._setPoolDelegatorInactiveIndex' (StakingBase.sol#1083-1085) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1083,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setPoolDelegatorInactiveIndex(address _poolStakingAddress, address _delegator, uint256 _index) internal {\n",
          "message": "Parameter '_poolStakingAddress' of StakingBase._setPoolDelegatorInactiveIndex (StakingBase.sol#1083) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1083,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setPoolDelegatorInactiveIndex(address _poolStakingAddress, address _delegator, uint256 _index) internal {\n",
          "message": "Parameter '_delegator' of StakingBase._setPoolDelegatorInactiveIndex (StakingBase.sol#1083) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1083,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setPoolDelegatorInactiveIndex(address _poolStakingAddress, address _delegator, uint256 _index) internal {\n",
          "message": "Parameter '_index' of StakingBase._setPoolDelegatorInactiveIndex (StakingBase.sol#1083) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1091,
          "vulnerability_to_line": 1093,
          "vulnerability_code": "    function _setPoolIndex(address _stakingAddress, uint256 _index) internal {\n\n        uintStorage[keccak256(abi.encode(POOL_INDEX, _stakingAddress))] = _index;\n",
          "message": "Function 'StakingBase._setPoolIndex' (StakingBase.sol#1091-1093) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1091,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setPoolIndex(address _stakingAddress, uint256 _index) internal {\n",
          "message": "Parameter '_stakingAddress' of StakingBase._setPoolIndex (StakingBase.sol#1091) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1091,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setPoolIndex(address _stakingAddress, uint256 _index) internal {\n",
          "message": "Parameter '_index' of StakingBase._setPoolIndex (StakingBase.sol#1091) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1099,
          "vulnerability_to_line": 1101,
          "vulnerability_code": "    function _setPoolInactiveIndex(address _stakingAddress, uint256 _index) internal {\n\n        uintStorage[keccak256(abi.encode(POOL_INACTIVE_INDEX, _stakingAddress))] = _index;\n",
          "message": "Function 'StakingBase._setPoolInactiveIndex' (StakingBase.sol#1099-1101) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1099,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setPoolInactiveIndex(address _stakingAddress, uint256 _index) internal {\n",
          "message": "Parameter '_stakingAddress' of StakingBase._setPoolInactiveIndex (StakingBase.sol#1099) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1099,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setPoolInactiveIndex(address _stakingAddress, uint256 _index) internal {\n",
          "message": "Parameter '_index' of StakingBase._setPoolInactiveIndex (StakingBase.sol#1099) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1108,
          "vulnerability_to_line": 1110,
          "vulnerability_code": "    function _setPoolToBeElectedIndex(address _stakingAddress, uint256 _index) internal {\n\n        uintStorage[keccak256(abi.encode(POOL_TO_BE_ELECTED_INDEX, _stakingAddress))] = _index;\n",
          "message": "Function 'StakingBase._setPoolToBeElectedIndex' (StakingBase.sol#1108-1110) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1108,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setPoolToBeElectedIndex(address _stakingAddress, uint256 _index) internal {\n",
          "message": "Parameter '_stakingAddress' of StakingBase._setPoolToBeElectedIndex (StakingBase.sol#1108) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1108,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setPoolToBeElectedIndex(address _stakingAddress, uint256 _index) internal {\n",
          "message": "Parameter '_index' of StakingBase._setPoolToBeElectedIndex (StakingBase.sol#1108) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1117,
          "vulnerability_to_line": 1119,
          "vulnerability_code": "    function _setPoolToBeRemovedIndex(address _stakingAddress, uint256 _index) internal {\n\n        uintStorage[keccak256(abi.encode(POOL_TO_BE_REMOVED_INDEX, _stakingAddress))] = _index;\n",
          "message": "Function 'StakingBase._setPoolToBeRemovedIndex' (StakingBase.sol#1117-1119) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1117,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setPoolToBeRemovedIndex(address _stakingAddress, uint256 _index) internal {\n",
          "message": "Parameter '_stakingAddress' of StakingBase._setPoolToBeRemovedIndex (StakingBase.sol#1117) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1117,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setPoolToBeRemovedIndex(address _stakingAddress, uint256 _index) internal {\n",
          "message": "Parameter '_index' of StakingBase._setPoolToBeRemovedIndex (StakingBase.sol#1117) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1125,
          "vulnerability_to_line": 1135,
          "vulnerability_code": "    function _addPoolDelegator(address _poolStakingAddress, address _delegator) internal {\n\n        address[] storage delegators = addressArrayStorage[\n\n            keccak256(abi.encode(POOL_DELEGATORS, _poolStakingAddress))\n\n        ];\n\n        if (delegators.length == 0 || delegators[poolDelegatorIndex(_poolStakingAddress, _delegator)] != _delegator) {\n\n            _setPoolDelegatorIndex(_poolStakingAddress, _delegator, delegators.length);\n\n            delegators.push(_delegator);\n\n            require(delegators.length <= MAX_DELEGATORS_PER_POOL);\n\n        }\n\n        _removePoolDelegatorInactive(_poolStakingAddress, _delegator);\n",
          "message": "Function 'StakingBase._addPoolDelegator' (StakingBase.sol#1125-1135) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1125,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _addPoolDelegator(address _poolStakingAddress, address _delegator) internal {\n",
          "message": "Parameter '_poolStakingAddress' of StakingBase._addPoolDelegator (StakingBase.sol#1125) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1125,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _addPoolDelegator(address _poolStakingAddress, address _delegator) internal {\n",
          "message": "Parameter '_delegator' of StakingBase._addPoolDelegator (StakingBase.sol#1125) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1141,
          "vulnerability_to_line": 1152,
          "vulnerability_code": "    function _addPoolDelegatorInactive(address _poolStakingAddress, address _delegator) internal {\n\n        address[] storage delegators = addressArrayStorage[\n\n            keccak256(abi.encode(POOL_DELEGATORS_INACTIVE, _poolStakingAddress))\n\n        ];\n\n        if (\n\n            delegators.length == 0 ||\n\n            delegators[poolDelegatorInactiveIndex(_poolStakingAddress, _delegator)] != _delegator\n\n        ) {\n\n            _setPoolDelegatorInactiveIndex(_poolStakingAddress, _delegator, delegators.length);\n\n            delegators.push(_delegator);\n\n        }\n",
          "message": "Function 'StakingBase._addPoolDelegatorInactive' (StakingBase.sol#1141-1152) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1141,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _addPoolDelegatorInactive(address _poolStakingAddress, address _delegator) internal {\n",
          "message": "Parameter '_poolStakingAddress' of StakingBase._addPoolDelegatorInactive (StakingBase.sol#1141) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1141,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _addPoolDelegatorInactive(address _poolStakingAddress, address _delegator) internal {\n",
          "message": "Parameter '_delegator' of StakingBase._addPoolDelegatorInactive (StakingBase.sol#1141) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1158,
          "vulnerability_to_line": 1174,
          "vulnerability_code": "    function _removePoolDelegator(address _poolStakingAddress, address _delegator) internal {\n\n        address[] storage delegators = addressArrayStorage[\n\n            keccak256(abi.encode(POOL_DELEGATORS, _poolStakingAddress))\n\n        ];\n\n        uint256 indexToRemove = poolDelegatorIndex(_poolStakingAddress, _delegator);\n\n        if (delegators.length != 0 && delegators[indexToRemove] == _delegator) {\n\n            delegators[indexToRemove] = delegators[delegators.length - 1];\n\n            _setPoolDelegatorIndex(_poolStakingAddress, delegators[indexToRemove], indexToRemove);\n\n            _setPoolDelegatorIndex(_poolStakingAddress, _delegator, 0);\n\n            delegators.length--;\n\n        }\n\n        if (stakeAmount(_poolStakingAddress, _delegator) != 0) {\n\n            _addPoolDelegatorInactive(_poolStakingAddress, _delegator);\n\n        } else {\n\n            _removePoolDelegatorInactive(_poolStakingAddress, _delegator);\n\n        }\n",
          "message": "Function 'StakingBase._removePoolDelegator' (StakingBase.sol#1158-1174) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1158,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _removePoolDelegator(address _poolStakingAddress, address _delegator) internal {\n",
          "message": "Parameter '_poolStakingAddress' of StakingBase._removePoolDelegator (StakingBase.sol#1158) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1158,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _removePoolDelegator(address _poolStakingAddress, address _delegator) internal {\n",
          "message": "Parameter '_delegator' of StakingBase._removePoolDelegator (StakingBase.sol#1158) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1180,
          "vulnerability_to_line": 1191,
          "vulnerability_code": "    function _removePoolDelegatorInactive(address _poolStakingAddress, address _delegator) internal {\n\n        address[] storage delegators = addressArrayStorage[\n\n            keccak256(abi.encode(POOL_DELEGATORS_INACTIVE, _poolStakingAddress))\n\n        ];\n\n        uint256 indexToRemove = poolDelegatorInactiveIndex(_poolStakingAddress, _delegator);\n\n        if (delegators.length != 0 && delegators[indexToRemove] == _delegator) {\n\n            delegators[indexToRemove] = delegators[delegators.length - 1];\n\n            _setPoolDelegatorInactiveIndex(_poolStakingAddress, delegators[indexToRemove], indexToRemove);\n\n            _setPoolDelegatorInactiveIndex(_poolStakingAddress, _delegator, 0);\n\n            delegators.length--;\n\n        }\n",
          "message": "Function 'StakingBase._removePoolDelegatorInactive' (StakingBase.sol#1180-1191) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1180,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _removePoolDelegatorInactive(address _poolStakingAddress, address _delegator) internal {\n",
          "message": "Parameter '_poolStakingAddress' of StakingBase._removePoolDelegatorInactive (StakingBase.sol#1180) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1180,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _removePoolDelegatorInactive(address _poolStakingAddress, address _delegator) internal {\n",
          "message": "Parameter '_delegator' of StakingBase._removePoolDelegatorInactive (StakingBase.sol#1180) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1197,
          "vulnerability_to_line": 1207,
          "vulnerability_code": "    function _setLikelihood(address _poolStakingAddress) internal {\n\n        (bool isToBeElected, uint256 index) = _isPoolToBeElected(_poolStakingAddress);\n\n\n\n        if (!isToBeElected) return;\n\n\n\n        int256 oldValue = intArrayStorage[POOLS_LIKELIHOOD][index];\n\n        int256 newValue = int256(stakeAmountTotalMinusOrderedWithdraw(_poolStakingAddress) * 100 / STAKE_UNIT);\n\n\n\n        intArrayStorage[POOLS_LIKELIHOOD][index] = newValue;\n\n        intStorage[POOLS_LIKELIHOOD_SUM] += newValue - oldValue;\n",
          "message": "Function 'StakingBase._setLikelihood' (StakingBase.sol#1197-1207) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1197,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setLikelihood(address _poolStakingAddress) internal {\n",
          "message": "Parameter '_poolStakingAddress' of StakingBase._setLikelihood (StakingBase.sol#1197) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1214,
          "vulnerability_to_line": 1216,
          "vulnerability_code": "    function _setOrderedWithdrawAmount(address _poolStakingAddress, address _staker, uint256 _amount) internal {\n\n        uintStorage[keccak256(abi.encode(ORDERED_WITHDRAW_AMOUNT, _poolStakingAddress, _staker))] = _amount;\n",
          "message": "Function 'StakingBase._setOrderedWithdrawAmount' (StakingBase.sol#1214-1216) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1214,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setOrderedWithdrawAmount(address _poolStakingAddress, address _staker, uint256 _amount) internal {\n",
          "message": "Parameter '_poolStakingAddress' of StakingBase._setOrderedWithdrawAmount (StakingBase.sol#1214) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1214,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setOrderedWithdrawAmount(address _poolStakingAddress, address _staker, uint256 _amount) internal {\n",
          "message": "Parameter '_staker' of StakingBase._setOrderedWithdrawAmount (StakingBase.sol#1214) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1214,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setOrderedWithdrawAmount(address _poolStakingAddress, address _staker, uint256 _amount) internal {\n",
          "message": "Parameter '_amount' of StakingBase._setOrderedWithdrawAmount (StakingBase.sol#1214) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1222,
          "vulnerability_to_line": 1224,
          "vulnerability_code": "    function _setOrderedWithdrawAmountTotal(address _poolStakingAddress, uint256 _amount) internal {\n\n        uintStorage[keccak256(abi.encode(ORDERED_WITHDRAW_AMOUNT_TOTAL, _poolStakingAddress))] = _amount;\n",
          "message": "Function 'StakingBase._setOrderedWithdrawAmountTotal' (StakingBase.sol#1222-1224) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1222,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setOrderedWithdrawAmountTotal(address _poolStakingAddress, uint256 _amount) internal {\n",
          "message": "Parameter '_poolStakingAddress' of StakingBase._setOrderedWithdrawAmountTotal (StakingBase.sol#1222) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1222,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setOrderedWithdrawAmountTotal(address _poolStakingAddress, uint256 _amount) internal {\n",
          "message": "Parameter '_amount' of StakingBase._setOrderedWithdrawAmountTotal (StakingBase.sol#1222) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1231,
          "vulnerability_to_line": 1233,
          "vulnerability_code": "    function _setStakeAmount(address _poolStakingAddress, address _staker, uint256 _amount) internal {\n\n        uintStorage[keccak256(abi.encode(STAKE_AMOUNT, _poolStakingAddress, _staker))] = _amount;\n",
          "message": "Function 'StakingBase._setStakeAmount' (StakingBase.sol#1231-1233) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1231,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setStakeAmount(address _poolStakingAddress, address _staker, uint256 _amount) internal {\n",
          "message": "Parameter '_poolStakingAddress' of StakingBase._setStakeAmount (StakingBase.sol#1231) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1231,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setStakeAmount(address _poolStakingAddress, address _staker, uint256 _amount) internal {\n",
          "message": "Parameter '_staker' of StakingBase._setStakeAmount (StakingBase.sol#1231) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1231,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setStakeAmount(address _poolStakingAddress, address _staker, uint256 _amount) internal {\n",
          "message": "Parameter '_amount' of StakingBase._setStakeAmount (StakingBase.sol#1231) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1241,
          "vulnerability_to_line": 1249,
          "vulnerability_code": "    function _setStakeAmountByCurrentEpoch(\n\n        address _poolStakingAddress,\n\n        address _staker,\n\n        uint256 _amount\n\n    ) internal {\n\n        uintStorage[keccak256(abi.encode(\n\n            STAKE_AMOUNT_BY_EPOCH, _poolStakingAddress, _staker, stakingEpoch()\n\n        ))] = _amount;\n",
          "message": "Function 'StakingBase._setStakeAmountByCurrentEpoch' (StakingBase.sol#1241-1249) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1242,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address _poolStakingAddress,\n",
          "message": "Parameter '_poolStakingAddress' of StakingBase._setStakeAmountByCurrentEpoch (StakingBase.sol#1242) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1243,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address _staker,\n",
          "message": "Parameter '_staker' of StakingBase._setStakeAmountByCurrentEpoch (StakingBase.sol#1243) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1244,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint256 _amount\n",
          "message": "Parameter '_amount' of StakingBase._setStakeAmountByCurrentEpoch (StakingBase.sol#1244) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1254,
          "vulnerability_to_line": 1256,
          "vulnerability_code": "    function _setStakeAmountTotal(address _poolStakingAddress, uint256 _amount) internal {\n\n        uintStorage[keccak256(abi.encode(STAKE_AMOUNT_TOTAL, _poolStakingAddress))] = _amount;\n",
          "message": "Function 'StakingBase._setStakeAmountTotal' (StakingBase.sol#1254-1256) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1254,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setStakeAmountTotal(address _poolStakingAddress, uint256 _amount) internal {\n",
          "message": "Parameter '_poolStakingAddress' of StakingBase._setStakeAmountTotal (StakingBase.sol#1254) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1254,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setStakeAmountTotal(address _poolStakingAddress, uint256 _amount) internal {\n",
          "message": "Parameter '_amount' of StakingBase._setStakeAmountTotal (StakingBase.sol#1254) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1261,
          "vulnerability_to_line": 1263,
          "vulnerability_code": "    function _setDelegatorMinStake(uint256 _minStake) internal {\n\n        uintStorage[DELEGATOR_MIN_STAKE] = _minStake * STAKE_UNIT;\n",
          "message": "Function 'StakingBase._setDelegatorMinStake' (StakingBase.sol#1261-1263) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1261,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setDelegatorMinStake(uint256 _minStake) internal {\n",
          "message": "Parameter '_minStake' of StakingBase._setDelegatorMinStake (StakingBase.sol#1261) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1268,
          "vulnerability_to_line": 1270,
          "vulnerability_code": "    function _setCandidateMinStake(uint256 _minStake) internal {\n\n        uintStorage[CANDIDATE_MIN_STAKE] = _minStake * STAKE_UNIT;\n",
          "message": "Function 'StakingBase._setCandidateMinStake' (StakingBase.sol#1268-1270) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1268,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setCandidateMinStake(uint256 _minStake) internal {\n",
          "message": "Parameter '_minStake' of StakingBase._setCandidateMinStake (StakingBase.sol#1268) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1276,
          "vulnerability_to_line": 1289,
          "vulnerability_code": "    function _stake(address _toPoolStakingAddress, uint256 _amount) internal {\n\n        IERC20Minting tokenContract = IERC20Minting(erc20TokenContract());\n\n        if (address(tokenContract) != address(0)) {\n\n            require(msg.value == 0);\n\n        }\n\n        address staker = msg.sender;\n\n        _stake(_toPoolStakingAddress, staker, _amount);\n\n        if (address(tokenContract) != address(0)) {\n\n            tokenContract.stake(staker, _amount);\n\n        } else {\n\n            require(boolStorage[ERC20_RESTRICTED]);\n\n        }\n\n        emit Staked(_toPoolStakingAddress, staker, stakingEpoch(), _amount);\n",
          "message": "Function 'StakingBase._stake' (StakingBase.sol#1276-1289) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1276,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _stake(address _toPoolStakingAddress, uint256 _amount) internal {\n",
          "message": "Parameter '_toPoolStakingAddress' of StakingBase._stake (StakingBase.sol#1276) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1276,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _stake(address _toPoolStakingAddress, uint256 _amount) internal {\n",
          "message": "Parameter '_amount' of StakingBase._stake (StakingBase.sol#1276) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1296,
          "vulnerability_to_line": 1333,
          "vulnerability_code": "    function _stake(address _poolStakingAddress, address _staker, uint256 _amount) internal {\n\n        IValidatorSet validatorSet = validatorSetContract();\n\n        address poolMiningAddress = validatorSet.miningByStakingAddress(_poolStakingAddress);\n\n\n\n        require(poolMiningAddress != address(0));\n\n        require(_poolStakingAddress != address(0));\n\n        require(_amount != 0);\n\n        require(!validatorSet.isValidatorBanned(poolMiningAddress));\n\n        require(areStakeAndWithdrawAllowed());\n\n\n\n        uint256 newStakeAmount = stakeAmount(_poolStakingAddress, _staker).add(_amount);\n\n        if (_staker == _poolStakingAddress) {\n\n            require(newStakeAmount >= getCandidateMinStake()); // the staked amount must be at least CANDIDATE_MIN_STAKE\n\n        } else {\n\n            require(newStakeAmount >= getDelegatorMinStake()); // the staked amount must be at least DELEGATOR_MIN_STAKE\n\n\n\n            // The delegator cannot stake into the pool of the candidate which hasn't self-staked.\n\n            // Also, that candidate shouldn't want to withdraw all his funds.\n\n            require(stakeAmountMinusOrderedWithdraw(_poolStakingAddress, _poolStakingAddress) != 0);\n\n        }\n\n        _setStakeAmount(_poolStakingAddress, _staker, newStakeAmount);\n\n        _setStakeAmountByCurrentEpoch(\n\n            _poolStakingAddress,\n\n            _staker,\n\n            stakeAmountByCurrentEpoch(_poolStakingAddress, _staker).add(_amount)\n\n        );\n\n        _setStakeAmountTotal(_poolStakingAddress, stakeAmountTotal(_poolStakingAddress).add(_amount));\n\n\n\n        if (_staker == _poolStakingAddress) { // `staker` makes a stake for himself and becomes a candidate\n\n            // Add `_poolStakingAddress` to the array of pools\n\n            _addPoolActive(_poolStakingAddress, _poolStakingAddress != validatorSet.unremovableValidator());\n\n        } else {\n\n            // Add `_staker` to the array of pool's delegators\n\n            _addPoolDelegator(_poolStakingAddress, _staker);\n\n        }\n\n\n\n        _setLikelihood(_poolStakingAddress);\n",
          "message": "Function 'StakingBase._stake' (StakingBase.sol#1296-1333) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1296,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _stake(address _poolStakingAddress, address _staker, uint256 _amount) internal {\n",
          "message": "Parameter '_poolStakingAddress' of StakingBase._stake (StakingBase.sol#1296) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1296,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _stake(address _poolStakingAddress, address _staker, uint256 _amount) internal {\n",
          "message": "Parameter '_staker' of StakingBase._stake (StakingBase.sol#1296) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1296,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _stake(address _poolStakingAddress, address _staker, uint256 _amount) internal {\n",
          "message": "Parameter '_amount' of StakingBase._stake (StakingBase.sol#1296) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1340,
          "vulnerability_to_line": 1370,
          "vulnerability_code": "    function _withdraw(address _poolStakingAddress, address _staker, uint256 _amount) internal {\n\n        require(_poolStakingAddress != address(0));\n\n        require(_amount != 0);\n\n\n\n        // How much can `staker` withdraw from `_poolStakingAddress` at the moment?\n\n        require(_amount <= maxWithdrawAllowed(_poolStakingAddress, _staker));\n\n\n\n        uint256 currentStakeAmount = stakeAmount(_poolStakingAddress, _staker);\n\n        uint256 alreadyOrderedAmount = orderedWithdrawAmount(_poolStakingAddress, _staker);\n\n        uint256 resultingStakeAmount = currentStakeAmount.sub(alreadyOrderedAmount).sub(_amount);\n\n\n\n        // The amount to be withdrawn must be the whole staked amount or\n\n        // must not exceed the diff between the entire amount and MIN_STAKE\n\n        uint256 minAllowedStake = (_poolStakingAddress == _staker) ? getCandidateMinStake() : getDelegatorMinStake();\n\n        require(resultingStakeAmount == 0 || resultingStakeAmount >= minAllowedStake);\n\n\n\n        _setStakeAmount(_poolStakingAddress, _staker, currentStakeAmount.sub(_amount));\n\n        uint256 amountByEpoch = stakeAmountByCurrentEpoch(_poolStakingAddress, _staker);\n\n        _setStakeAmountByCurrentEpoch(\n\n            _poolStakingAddress,\n\n            _staker,\n\n            amountByEpoch >= _amount ? amountByEpoch - _amount : 0\n\n        );\n\n        _setStakeAmountTotal(_poolStakingAddress, stakeAmountTotal(_poolStakingAddress).sub(_amount));\n\n\n\n        if (resultingStakeAmount == 0) {\n\n            _withdrawCheckPool(_poolStakingAddress, _staker);\n\n        }\n\n\n\n        _setLikelihood(_poolStakingAddress);\n",
          "message": "Function 'StakingBase._withdraw' (StakingBase.sol#1340-1370) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1340,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _withdraw(address _poolStakingAddress, address _staker, uint256 _amount) internal {\n",
          "message": "Parameter '_poolStakingAddress' of StakingBase._withdraw (StakingBase.sol#1340) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1340,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _withdraw(address _poolStakingAddress, address _staker, uint256 _amount) internal {\n",
          "message": "Parameter '_staker' of StakingBase._withdraw (StakingBase.sol#1340) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1340,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _withdraw(address _poolStakingAddress, address _staker, uint256 _amount) internal {\n",
          "message": "Parameter '_amount' of StakingBase._withdraw (StakingBase.sol#1340) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1376,
          "vulnerability_to_line": 1391,
          "vulnerability_code": "    function _withdrawCheckPool(address _poolStakingAddress, address _staker) internal {\n\n        if (_staker == _poolStakingAddress) {\n\n            IValidatorSet validatorSet = validatorSetContract();\n\n            address unremovableStakingAddress = validatorSet.unremovableValidator();\n\n\n\n            if (_poolStakingAddress != unremovableStakingAddress) {\n\n                if (validatorSet.isValidator(validatorSet.miningByStakingAddress(_poolStakingAddress))) {\n\n                    _addPoolToBeRemoved(_poolStakingAddress);\n\n                } else {\n\n                    _removePool(_poolStakingAddress);\n\n                }\n\n            }\n\n        } else {\n\n            _removePoolDelegator(_poolStakingAddress, _staker);\n\n        }\n",
          "message": "Function 'StakingBase._withdrawCheckPool' (StakingBase.sol#1376-1391) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1376,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _withdrawCheckPool(address _poolStakingAddress, address _staker) internal {\n",
          "message": "Parameter '_poolStakingAddress' of StakingBase._withdrawCheckPool (StakingBase.sol#1376) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1376,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _withdrawCheckPool(address _poolStakingAddress, address _staker) internal {\n",
          "message": "Parameter '_staker' of StakingBase._withdrawCheckPool (StakingBase.sol#1376) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1394,
          "vulnerability_to_line": 1396,
          "vulnerability_code": "    function _getCurrentBlockNumber() internal view returns(uint256) {\n\n        return block.number;\n",
          "message": "Function 'StakingBase._getCurrentBlockNumber' (StakingBase.sol#1394-1396) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1400,
          "vulnerability_to_line": 1402,
          "vulnerability_code": "    function _getMaxCandidates() internal pure returns(uint256) {\n\n        return MAX_CANDIDATES;\n",
          "message": "Function 'StakingBase._getMaxCandidates' (StakingBase.sol#1400-1402) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1410,
          "vulnerability_to_line": 1419,
          "vulnerability_code": "    function _isPoolToBeElected(address _stakingAddress) internal view returns(bool toBeElected, uint256 index) {\n\n        address[] storage pools = addressArrayStorage[POOLS_TO_BE_ELECTED];\n\n        if (pools.length != 0) {\n\n            index = poolToBeElectedIndex(_stakingAddress);\n\n            if (pools[index] == _stakingAddress) {\n\n                return (true, index);\n\n            }\n\n        }\n\n        return (false, 0);\n",
          "message": "Function 'StakingBase._isPoolToBeElected' (StakingBase.sol#1410-1419) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1410,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _isPoolToBeElected(address _stakingAddress) internal view returns(bool toBeElected, uint256 index) {\n",
          "message": "Parameter '_stakingAddress' of StakingBase._isPoolToBeElected (StakingBase.sol#1410) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1424,
          "vulnerability_to_line": 1435,
          "vulnerability_code": "    function _isWithdrawAllowed(address _miningAddress) internal view returns(bool) {\n\n        if (validatorSetContract().isValidatorBanned(_miningAddress)) {\n\n            // No one can withdraw from `_poolStakingAddress` until the ban is expired\n\n            return false;\n\n        }\n\n\n\n        if (!areStakeAndWithdrawAllowed()) {\n\n            return false;\n\n        }\n\n\n\n        return true;\n",
          "message": "Function 'StakingBase._isWithdrawAllowed' (StakingBase.sol#1424-1435) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1424,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _isWithdrawAllowed(address _miningAddress) internal view returns(bool) {\n",
          "message": "Parameter '_miningAddress' of StakingBase._isWithdrawAllowed (StakingBase.sol#1424) is not in mixedCase\n"
        },
        {
          "name": "unused-state",
          "vulnerability_from_line": 101,
          "vulnerability_to_line": null,
          "vulnerability_code": "    mapping(bytes32 => string) internal stringStorage;\n",
          "message": "EternalStorage.stringStorage (StakingBase.sol#101) is never used in StakingBase\nEternalStorage.bytesStorage (StakingBase.sol#103) is never used in StakingBase\nEternalStorage.bytes32Storage (StakingBase.sol#106) is never used in StakingBase\nEternalStorage.uintArrayStorage (StakingBase.sol#108) is never used in StakingBase\nEternalStorage.stringArrayStorage (StakingBase.sol#109) is never used in StakingBase\nEternalStorage.bytesArrayStorage (StakingBase.sol#111) is never used in StakingBase\nEternalStorage.boolArrayStorage (StakingBase.sol#112) is never used in StakingBase\nEternalStorage.bytes32ArrayStorage (StakingBase.sol#114) is never used in StakingBase\n"
        }
      ]
    },
    "smartcheck": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "SOLIDITY_ARRAY_LENGTH_MANIPULATION",
          "vulnerability_from_line": 962,
          "vulnerability_to_line": null,
          "vulnerability_code": "            pools.length--;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ARRAY_LENGTH_MANIPULATION",
          "vulnerability_from_line": 963,
          "vulnerability_to_line": null,
          "vulnerability_code": "            likelihood.length--;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ARRAY_LENGTH_MANIPULATION",
          "vulnerability_from_line": 978,
          "vulnerability_to_line": null,
          "vulnerability_code": "            pools.length--;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ARRAY_LENGTH_MANIPULATION",
          "vulnerability_from_line": 992,
          "vulnerability_to_line": null,
          "vulnerability_code": "            pools.length--;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ARRAY_LENGTH_MANIPULATION",
          "vulnerability_from_line": 1013,
          "vulnerability_to_line": null,
          "vulnerability_code": "            pools.length--;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ARRAY_LENGTH_MANIPULATION",
          "vulnerability_from_line": 1167,
          "vulnerability_to_line": null,
          "vulnerability_code": "            delegators.length--;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ARRAY_LENGTH_MANIPULATION",
          "vulnerability_from_line": 1189,
          "vulnerability_to_line": null,
          "vulnerability_code": "            delegators.length--;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 1044,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 i = 0; i < _initialStakingAddresses.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 1044,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 i = 0; i < _initialStakingAddresses.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_MSGVALUE_EQUALS_ZERO",
          "vulnerability_from_line": 1279,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(msg.value == 0);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_OVERPOWERED_ROLE",
          "vulnerability_from_line": 522,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setErc20TokenContract(address _erc20TokenContract) external onlyOwner onlyInitialized {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_OVERPOWERED_ROLE",
          "vulnerability_from_line": 531,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setCandidateMinStake(uint256 _minStake) external onlyOwner onlyInitialized {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_OVERPOWERED_ROLE",
          "vulnerability_from_line": 538,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setDelegatorMinStake(uint256 _minStake) external onlyOwner onlyInitialized {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SAFEMATH",
          "vulnerability_from_line": 186,
          "vulnerability_to_line": null,
          "vulnerability_code": "    using SafeMath for uint256;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 43,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getPoolsLikelihood() external view returns(int256[] memory, int256);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 66,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function newValidatorSet() external returns(bool, uint256);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 568,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getPoolsLikelihood() external view returns(int256[] memory likelihoods, int256 sum) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 1410,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _isPoolToBeElected(address _stakingAddress) internal view returns(bool toBeElected, uint256 index) {\n",
          "message": null
        }
      ]
    },
    "oyente": {
      "successfull_analysis": false,
      "errors": [
        "exception (IndexError: pop from empty list)"
      ],
      "vulnerability_findings": []
    },
    "mythril": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": []
    },
    "osiris": {
      "successfull_analysis": false,
      "errors": [
        "exception (IndexError: pop from empty list)"
      ],
      "vulnerability_findings": []
    }
  }
}