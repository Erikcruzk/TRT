{
  "smartbugs_completed": true,
  "analyzer_results": {
    "semgrep": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 262,
          "vulnerability_to_line": null,
          "vulnerability_code": "            for (i = 0; i < previousValidators.length; i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 265,
          "vulnerability_to_line": null,
          "vulnerability_code": "            for (i = 0; i < currentValidators.length; i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 557,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (i = 0; i < prevValidators.length; i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 565,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (i = 0; i < _queueValidators.length; i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 662,
          "vulnerability_to_line": null,
          "vulnerability_code": "                for (uint256 i = 0; i < newValidators.length; i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 708,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 i = 0; i < miningAddresses.length; i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 711,
          "vulnerability_to_line": null,
          "vulnerability_code": "                miningAddresses[i] = miningAddresses[miningAddresses.length - 1];\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 712,
          "vulnerability_to_line": null,
          "vulnerability_code": "                miningAddresses.length--;\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 771,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (i = 0; i < _stakingAddresses.length; i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 776,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (i = 0; i < poolsToBeRemoved.length; i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 316,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 i = 0; i < _initialMiningAddresses.length; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 662,
          "vulnerability_to_line": null,
          "vulnerability_code": "                for (uint256 i = 0; i < newValidators.length; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 708,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 i = 0; i < miningAddresses.length; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 254,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (validatorSetApplyBlock() == 0 && newStakingEpoch) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 255,
          "vulnerability_to_line": null,
          "vulnerability_code": "            // Apply a new validator set formed by the `newValidatorSet` function\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 256,
          "vulnerability_to_line": null,
          "vulnerability_code": "\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 257,
          "vulnerability_to_line": null,
          "vulnerability_code": "            address[] memory previousValidators = getPreviousValidators();\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 258,
          "vulnerability_to_line": null,
          "vulnerability_code": "            address[] memory currentValidators = getValidators();\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 259,
          "vulnerability_to_line": null,
          "vulnerability_code": "            uint256 i;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 260,
          "vulnerability_to_line": null,
          "vulnerability_code": "\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 261,
          "vulnerability_to_line": null,
          "vulnerability_code": "            // Save the previous validator set\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 262,
          "vulnerability_to_line": null,
          "vulnerability_code": "            for (i = 0; i < previousValidators.length; i++) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 263,
          "vulnerability_to_line": null,
          "vulnerability_code": "                _setIsValidatorOnPreviousEpoch(previousValidators[i], false);\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 648,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 649,
          "vulnerability_to_line": null,
          "vulnerability_code": "            poolsToBeElected.length >= MAX_VALIDATORS &&\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 650,
          "vulnerability_to_line": null,
          "vulnerability_code": "            (poolsToBeElected.length != MAX_VALIDATORS || unremovableStakingAddress != address(0))\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 651,
          "vulnerability_to_line": null,
          "vulnerability_code": "        ) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 652,
          "vulnerability_to_line": null,
          "vulnerability_code": "            uint256 randomNumber = IRandom(randomContract()).getCurrentSeed();\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 653,
          "vulnerability_to_line": null,
          "vulnerability_code": "\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 654,
          "vulnerability_to_line": null,
          "vulnerability_code": "            (int256[] memory likelihood, int256 likelihoodSum) = staking.getPoolsLikelihood();\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 655,
          "vulnerability_to_line": null,
          "vulnerability_code": "\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 656,
          "vulnerability_to_line": null,
          "vulnerability_code": "            if (likelihood.length > 0 && likelihoodSum > 0) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 657,
          "vulnerability_to_line": null,
          "vulnerability_code": "                address[] memory newValidators = new address[](\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 656,
          "vulnerability_to_line": null,
          "vulnerability_code": "            if (likelihood.length > 0 && likelihoodSum > 0) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 657,
          "vulnerability_to_line": null,
          "vulnerability_code": "                address[] memory newValidators = new address[](\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 658,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    unremovableStakingAddress == address(0) ? MAX_VALIDATORS : MAX_VALIDATORS - 1\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 659,
          "vulnerability_to_line": null,
          "vulnerability_code": "                );\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 660,
          "vulnerability_to_line": null,
          "vulnerability_code": "\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 661,
          "vulnerability_to_line": null,
          "vulnerability_code": "                uint256 poolsToBeElectedLength = poolsToBeElected.length;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 662,
          "vulnerability_to_line": null,
          "vulnerability_code": "                for (uint256 i = 0; i < newValidators.length; i++) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 663,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    randomNumber = uint256(keccak256(abi.encode(randomNumber)));\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 664,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    uint256 randomPoolIndex = _getRandomIndex(likelihood, likelihoodSum, randomNumber);\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 665,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    newValidators[i] = poolsToBeElected[randomPoolIndex];\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-prefix-decrement-not-postfix",
          "vulnerability_from_line": 592,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (int256 i = queueLast; i >= queueFirst; i--) {\n",
          "message": "Consider using the prefix decrement expression whenever the return value is not needed. The prefix decrement expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-decrement-not-postfix",
          "vulnerability_from_line": 667,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    poolsToBeElectedLength--;\n",
          "message": "Consider using the prefix decrement expression whenever the return value is not needed. The prefix decrement expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-decrement-not-postfix",
          "vulnerability_from_line": 712,
          "vulnerability_to_line": null,
          "vulnerability_code": "                miningAddresses.length--;\n",
          "message": "Consider using the prefix decrement expression whenever the return value is not needed. The prefix decrement expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 262,
          "vulnerability_to_line": null,
          "vulnerability_code": "            for (i = 0; i < previousValidators.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 265,
          "vulnerability_to_line": null,
          "vulnerability_code": "            for (i = 0; i < currentValidators.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 316,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 i = 0; i < _initialMiningAddresses.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 557,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (i = 0; i < prevValidators.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 565,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (i = 0; i < _queueValidators.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 577,
          "vulnerability_to_line": null,
          "vulnerability_code": "            uintStorage[keccak256(abi.encode(BAN_COUNTER, _miningAddress))]++;\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 602,
          "vulnerability_to_line": null,
          "vulnerability_code": "        queueLast++;\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 627,
          "vulnerability_to_line": null,
          "vulnerability_code": "            intStorage[QUEUE_PV_FIRST]++;\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 634,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uintStorage[CHANGE_REQUEST_COUNT]++;\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 662,
          "vulnerability_to_line": null,
          "vulnerability_code": "                for (uint256 i = 0; i < newValidators.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 708,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 i = 0; i < miningAddresses.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 737,
          "vulnerability_to_line": null,
          "vulnerability_code": "            uintStorage[keccak256(abi.encode(VALIDATOR_COUNTER, _miningAddress))]++;\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 771,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (i = 0; i < _stakingAddresses.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 776,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (i = 0; i < poolsToBeRemoved.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 858,
          "vulnerability_to_line": null,
          "vulnerability_code": "            index++;\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        }
      ]
    },
    "slither": {
      "successfull_analysis": true,
      "errors": [
        "EXIT_CODE_103"
      ],
      "vulnerability_findings": [
        {
          "name": "uninitialized-state",
          "vulnerability_from_line": 89,
          "vulnerability_to_line": null,
          "vulnerability_code": "    address internal _owner;\n",
          "message": "EternalStorage._owner (ValidatorSetBase.sol#89) is never initialized. It is used in:\n\t- clearUnremovableValidator (ValidatorSetBase.sol#218-223)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 642,
          "vulnerability_to_line": 687,
          "vulnerability_code": "    function _newValidatorSet() internal returns(uint256) {\n\n        IStaking staking = IStaking(stakingContract());\n\n        address[] memory poolsToBeElected = staking.getPoolsToBeElected();\n\n        address unremovableStakingAddress = unremovableValidator();\n\n\n\n        // Choose new validators\n\n        if (\n\n            poolsToBeElected.length >= MAX_VALIDATORS &&\n\n            (poolsToBeElected.length != MAX_VALIDATORS || unremovableStakingAddress != address(0))\n\n        ) {\n\n            uint256 randomNumber = IRandom(randomContract()).getCurrentSeed();\n\n\n\n            (int256[] memory likelihood, int256 likelihoodSum) = staking.getPoolsLikelihood();\n\n\n\n            if (likelihood.length > 0 && likelihoodSum > 0) {\n\n                address[] memory newValidators = new address[](\n\n                    unremovableStakingAddress == address(0) ? MAX_VALIDATORS : MAX_VALIDATORS - 1\n\n                );\n\n\n\n                uint256 poolsToBeElectedLength = poolsToBeElected.length;\n\n                for (uint256 i = 0; i < newValidators.length; i++) {\n\n                    randomNumber = uint256(keccak256(abi.encode(randomNumber)));\n\n                    uint256 randomPoolIndex = _getRandomIndex(likelihood, likelihoodSum, randomNumber);\n\n                    newValidators[i] = poolsToBeElected[randomPoolIndex];\n\n                    likelihoodSum -= likelihood[randomPoolIndex];\n\n                    poolsToBeElectedLength--;\n\n                    poolsToBeElected[randomPoolIndex] = poolsToBeElected[poolsToBeElectedLength];\n\n                    likelihood[randomPoolIndex] = likelihood[poolsToBeElectedLength];\n\n                }\n\n\n\n                _setPendingValidators(staking, newValidators, unremovableStakingAddress);\n\n            }\n\n        } else {\n\n            _setPendingValidators(staking, poolsToBeElected, unremovableStakingAddress);\n\n        }\n\n\n\n        // From this moment the `getPendingValidators()` will return a new validator set\n\n\n\n        staking.incrementStakingEpoch();\n\n        _setValidatorSetApplyBlock(0);\n\n\n\n        _incrementChangeRequestCount();\n\n        _enqueuePendingValidators(true);\n\n\n\n        return poolsToBeElected.length;\n",
          "message": "Reentrancy in ValidatorSetBase._newValidatorSet (ValidatorSetBase.sol#642-687):\n\tExternal calls:\n\t- poolsToBeElected = staking.getPoolsToBeElected() (ValidatorSetBase.sol#644)\n\t- randomNumber = IRandom(randomContract()).getCurrentSeed() (ValidatorSetBase.sol#652)\n\t- (likelihood,likelihoodSum) = staking.getPoolsLikelihood() (ValidatorSetBase.sol#654)\n\t- _setPendingValidators(staking,newValidators,unremovableStakingAddress) (ValidatorSetBase.sol#672)\n\t- _setPendingValidators(staking,poolsToBeElected,unremovableStakingAddress) (ValidatorSetBase.sol#675)\n\t- staking.incrementStakingEpoch() (ValidatorSetBase.sol#680)\n\tState variables written after the call(s):\n\t- addressArrayStorage (ValidatorSetBase.sol#684)\n"
        },
        {
          "name": "calls-loop",
          "vulnerability_from_line": 777,
          "vulnerability_to_line": null,
          "vulnerability_code": "            _stakingContract.removePool(poolsToBeRemoved[i]);\n",
          "message": "ValidatorSetBase._setPendingValidators has external calls inside a loop:\n\t- _stakingContract.removePool(poolsToBeRemoved[i]) (ValidatorSetBase.sol#777)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 642,
          "vulnerability_to_line": 687,
          "vulnerability_code": "    function _newValidatorSet() internal returns(uint256) {\n\n        IStaking staking = IStaking(stakingContract());\n\n        address[] memory poolsToBeElected = staking.getPoolsToBeElected();\n\n        address unremovableStakingAddress = unremovableValidator();\n\n\n\n        // Choose new validators\n\n        if (\n\n            poolsToBeElected.length >= MAX_VALIDATORS &&\n\n            (poolsToBeElected.length != MAX_VALIDATORS || unremovableStakingAddress != address(0))\n\n        ) {\n\n            uint256 randomNumber = IRandom(randomContract()).getCurrentSeed();\n\n\n\n            (int256[] memory likelihood, int256 likelihoodSum) = staking.getPoolsLikelihood();\n\n\n\n            if (likelihood.length > 0 && likelihoodSum > 0) {\n\n                address[] memory newValidators = new address[](\n\n                    unremovableStakingAddress == address(0) ? MAX_VALIDATORS : MAX_VALIDATORS - 1\n\n                );\n\n\n\n                uint256 poolsToBeElectedLength = poolsToBeElected.length;\n\n                for (uint256 i = 0; i < newValidators.length; i++) {\n\n                    randomNumber = uint256(keccak256(abi.encode(randomNumber)));\n\n                    uint256 randomPoolIndex = _getRandomIndex(likelihood, likelihoodSum, randomNumber);\n\n                    newValidators[i] = poolsToBeElected[randomPoolIndex];\n\n                    likelihoodSum -= likelihood[randomPoolIndex];\n\n                    poolsToBeElectedLength--;\n\n                    poolsToBeElected[randomPoolIndex] = poolsToBeElected[poolsToBeElectedLength];\n\n                    likelihood[randomPoolIndex] = likelihood[poolsToBeElectedLength];\n\n                }\n\n\n\n                _setPendingValidators(staking, newValidators, unremovableStakingAddress);\n\n            }\n\n        } else {\n\n            _setPendingValidators(staking, poolsToBeElected, unremovableStakingAddress);\n\n        }\n\n\n\n        // From this moment the `getPendingValidators()` will return a new validator set\n\n\n\n        staking.incrementStakingEpoch();\n\n        _setValidatorSetApplyBlock(0);\n\n\n\n        _incrementChangeRequestCount();\n\n        _enqueuePendingValidators(true);\n\n\n\n        return poolsToBeElected.length;\n",
          "message": "Reentrancy in ValidatorSetBase._newValidatorSet (ValidatorSetBase.sol#642-687):\n\tExternal calls:\n\t- poolsToBeElected = staking.getPoolsToBeElected() (ValidatorSetBase.sol#644)\n\t- randomNumber = IRandom(randomContract()).getCurrentSeed() (ValidatorSetBase.sol#652)\n\t- (likelihood,likelihoodSum) = staking.getPoolsLikelihood() (ValidatorSetBase.sol#654)\n\t- _setPendingValidators(staking,newValidators,unremovableStakingAddress) (ValidatorSetBase.sol#672)\n\t- _setPendingValidators(staking,poolsToBeElected,unremovableStakingAddress) (ValidatorSetBase.sol#675)\n\t- staking.incrementStakingEpoch() (ValidatorSetBase.sol#680)\n\tState variables written after the call(s):\n\t- boolStorage (ValidatorSetBase.sol#684)\n\t- intStorage (ValidatorSetBase.sol#684)\n\t- uintStorage (ValidatorSetBase.sol#681)\n\t- uintStorage (ValidatorSetBase.sol#683)\n\t- uintStorage (ValidatorSetBase.sol#684)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 693,
          "vulnerability_to_line": 718,
          "vulnerability_code": "    function _removeMaliciousValidator(address _miningAddress) internal returns(bool) {\n\n        address stakingAddress = stakingByMiningAddress(_miningAddress);\n\n\n\n        if (stakingAddress == unremovableValidator()) {\n\n            return false;\n\n        }\n\n\n\n        // Ban the malicious validator for the next 3 months\n\n        _banValidator(_miningAddress);\n\n\n\n        // Remove malicious validator from the `pools`\n\n        IStaking(stakingContract()).removePool(stakingAddress);\n\n\n\n        address[] storage miningAddresses = addressArrayStorage[PENDING_VALIDATORS];\n\n\n\n        for (uint256 i = 0; i < miningAddresses.length; i++) {\n\n            if (miningAddresses[i] == _miningAddress) {\n\n                // Remove the malicious validator from `pendingValidators`\n\n                miningAddresses[i] = miningAddresses[miningAddresses.length - 1];\n\n                miningAddresses.length--;\n\n                return true;\n\n            }\n\n        }\n\n\n\n        return false;\n",
          "message": "Reentrancy in ValidatorSetBase._removeMaliciousValidator (ValidatorSetBase.sol#693-718):\n\tExternal calls:\n\t- IStaking(stakingContract()).removePool(stakingAddress) (ValidatorSetBase.sol#704)\n\tState variables written after the call(s):\n\t- addressArrayStorage (ValidatorSetBase.sol#711)\n\t- addressArrayStorage (ValidatorSetBase.sol#712)\n"
        },
        {
          "name": "constable-states",
          "vulnerability_from_line": 89,
          "vulnerability_to_line": null,
          "vulnerability_code": "    address internal _owner;\n",
          "message": "EternalStorage._owner should be constant (ValidatorSetBase.sol#89)\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 60,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function blockRewardContract() external view returns(address);\n",
          "message": "IValidatorSet.blockRewardContract (ValidatorSetBase.sol#60) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 359,
          "vulnerability_to_line": 361,
          "vulnerability_code": "    function blockRewardContract() public view returns(address) {\n\n        return addressStorage[BLOCK_REWARD_CONTRACT];\n",
          "message": "ValidatorSetBase.blockRewardContract (ValidatorSetBase.sol#359-361) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 365,
          "vulnerability_to_line": 367,
          "vulnerability_code": "    function changeRequestCount() public view returns(uint256) {\n\n        return uintStorage[CHANGE_REQUEST_COUNT];\n",
          "message": "ValidatorSetBase.changeRequestCount (ValidatorSetBase.sol#365-367) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 61,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function changeRequestCount() external view returns(uint256);\n",
          "message": "IValidatorSet.changeRequestCount (ValidatorSetBase.sol#61) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 428,
          "vulnerability_to_line": 442,
          "vulnerability_code": "    function isReportValidatorValid(address _miningAddress) public view returns(bool) {\n\n        bool isValid = isValidator(_miningAddress) && !isValidatorBanned(_miningAddress);\n\n        if (IStaking(stakingContract()).stakingEpoch() == 0 || validatorSetApplyBlock() == 0) {\n\n            return isValid;\n\n        }\n\n        if (_getCurrentBlockNumber() - validatorSetApplyBlock() <= 20) {\n\n            // The current validator set was finalized by the engine,\n\n            // but we should let the previous validators finish\n\n            // reporting malicious validator within a few blocks\n\n            bool previousEpochValidator =\n\n                isValidatorOnPreviousEpoch(_miningAddress) && !isValidatorBanned(_miningAddress);\n\n            return isValid || previousEpochValidator;\n\n        }\n\n        return isValid;\n",
          "message": "ValidatorSetBase.isReportValidatorValid (ValidatorSetBase.sol#428-442) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 66,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function isReportValidatorValid(address) external view returns(bool);\n",
          "message": "IValidatorSet.isReportValidatorValid (ValidatorSetBase.sol#66) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 506,
          "vulnerability_to_line": 508,
          "vulnerability_code": "    function validatorIndex(address _miningAddress) public view returns(uint256) {\n\n        return uintStorage[keccak256(abi.encode(VALIDATOR_INDEX, _miningAddress))];\n",
          "message": "ValidatorSetBase.validatorIndex (ValidatorSetBase.sol#506-508) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 75,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function validatorIndex(address) external view returns(uint256);\n",
          "message": "IValidatorSet.validatorIndex (ValidatorSetBase.sol#75) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 345,
          "vulnerability_to_line": 347,
          "vulnerability_code": "    function banCounter(address _miningAddress) public view returns(uint256) {\n\n        return uintStorage[keccak256(abi.encode(BAN_COUNTER, _miningAddress))];\n",
          "message": "ValidatorSetBase.banCounter (ValidatorSetBase.sol#345-347) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 497,
          "vulnerability_to_line": 499,
          "vulnerability_code": "    function validatorCounter(address _miningAddress) public view returns(uint256) {\n\n        return uintStorage[keccak256(abi.encode(VALIDATOR_COUNTER, _miningAddress))];\n",
          "message": "ValidatorSetBase.validatorCounter (ValidatorSetBase.sol#497-499) should be declared external\n"
        },
        {
          "name": "solc-version",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity 0.5.9;\n",
          "message": "Detected issues with version pragma in ValidatorSetBase.sol:\n\t- pragma solidity0.5.9 (ValidatorSetBase.sol#3): it allows old versions\n\t- pragma solidity0.5.9 (ValidatorSetBase.sol#17): it allows old versions\n\t- pragma solidity0.5.9 (ValidatorSetBase.sol#26): it allows old versions\n\t- pragma solidity0.5.9 (ValidatorSetBase.sol#46): it allows old versions\n\t- pragma solidity0.5.9 (ValidatorSetBase.sol#81): it allows old versions\n\t- pragma solidity0.5.9 (ValidatorSetBase.sol#112): it allows old versions\n\t- pragma solidity0.5.9 (ValidatorSetBase.sol#130): it allows old versions\n\t- pragma solidity0.5.9 (ValidatorSetBase.sol#169): it allows old versions\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 7,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function initialize(address) external;\n",
          "message": "Parameter '' of IBlockReward.initialize (ValidatorSetBase.sol#7) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 8,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function DELEGATORS_ALIQUOT() external view returns(uint256); // solhint-disable-line func-name-mixedcase\n",
          "message": "Function 'IBlockReward.DELEGATORS_ALIQUOT' (ValidatorSetBase.sol#8) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 30,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function clearUnremovableValidator(address) external;\n",
          "message": "Parameter '' of IStaking.clearUnremovableValidator (ValidatorSetBase.sol#30) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 32,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function removePool(address) external;\n",
          "message": "Parameter '' of IStaking.removePool (ValidatorSetBase.sol#32) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 38,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function poolDelegators(address) external view returns(address[] memory);\n",
          "message": "Parameter '' of IStaking.poolDelegators (ValidatorSetBase.sol#38) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 39,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function stakeAmountMinusOrderedWithdraw(address, address) external view returns(uint256);\n",
          "message": "Parameter '' of IStaking.stakeAmountMinusOrderedWithdraw (ValidatorSetBase.sol#39) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 39,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function stakeAmountMinusOrderedWithdraw(address, address) external view returns(uint256);\n",
          "message": "Parameter '_scope_0' of IStaking.stakeAmountMinusOrderedWithdraw (ValidatorSetBase.sol#39) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 40,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function stakeAmountTotalMinusOrderedWithdraw(address) external view returns(uint256);\n",
          "message": "Parameter '' of IStaking.stakeAmountTotalMinusOrderedWithdraw (ValidatorSetBase.sol#40) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 51,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address,\n",
          "message": "Parameter '' of IValidatorSet.initialize (ValidatorSetBase.sol#51) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 52,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address,\n",
          "message": "Parameter '_scope_0' of IValidatorSet.initialize (ValidatorSetBase.sol#52) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 53,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address,\n",
          "message": "Parameter '_scope_1' of IValidatorSet.initialize (ValidatorSetBase.sol#53) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 54,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address[] calldata,\n",
          "message": "Parameter '_scope_2' of IValidatorSet.initialize (ValidatorSetBase.sol#54) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 55,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address[] calldata,\n",
          "message": "Parameter '_scope_3' of IValidatorSet.initialize (ValidatorSetBase.sol#55) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 56,
          "vulnerability_to_line": null,
          "vulnerability_code": "        bool\n",
          "message": "Parameter '_scope_4' of IValidatorSet.initialize (ValidatorSetBase.sol#56) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 59,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setStakingAddress(address, address) external;\n",
          "message": "Parameter '' of IValidatorSet.setStakingAddress (ValidatorSetBase.sol#59) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 59,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setStakingAddress(address, address) external;\n",
          "message": "Parameter '_scope_0' of IValidatorSet.setStakingAddress (ValidatorSetBase.sol#59) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 66,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function isReportValidatorValid(address) external view returns(bool);\n",
          "message": "Parameter '' of IValidatorSet.isReportValidatorValid (ValidatorSetBase.sol#66) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 67,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function isValidator(address) external view returns(bool);\n",
          "message": "Parameter '' of IValidatorSet.isValidator (ValidatorSetBase.sol#67) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 68,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function isValidatorBanned(address) external view returns(bool);\n",
          "message": "Parameter '' of IValidatorSet.isValidatorBanned (ValidatorSetBase.sol#68) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 69,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function MAX_VALIDATORS() external view returns(uint256); // solhint-disable-line func-name-mixedcase\n",
          "message": "Function 'IValidatorSet.MAX_VALIDATORS' (ValidatorSetBase.sol#69) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 70,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function miningByStakingAddress(address) external view returns(address);\n",
          "message": "Parameter '' of IValidatorSet.miningByStakingAddress (ValidatorSetBase.sol#70) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 72,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function stakingByMiningAddress(address) external view returns(address);\n",
          "message": "Parameter '' of IValidatorSet.stakingByMiningAddress (ValidatorSetBase.sol#72) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 75,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function validatorIndex(address) external view returns(uint256);\n",
          "message": "Parameter '' of IValidatorSet.validatorIndex (ValidatorSetBase.sol#75) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 89,
          "vulnerability_to_line": null,
          "vulnerability_code": "    address internal _owner;\n",
          "message": "Variable 'EternalStorage._owner' (ValidatorSetBase.sol#89) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 294,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address _blockRewardContract,\n",
          "message": "Parameter '_blockRewardContract' of ValidatorSetBase.initialize (ValidatorSetBase.sol#294) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 295,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address _randomContract,\n",
          "message": "Parameter '_randomContract' of ValidatorSetBase.initialize (ValidatorSetBase.sol#295) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 296,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address _stakingContract,\n",
          "message": "Parameter '_stakingContract' of ValidatorSetBase.initialize (ValidatorSetBase.sol#296) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 297,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address[] calldata _initialMiningAddresses,\n",
          "message": "Parameter '_initialMiningAddresses' of ValidatorSetBase.initialize (ValidatorSetBase.sol#297) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 298,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address[] calldata _initialStakingAddresses,\n",
          "message": "Parameter '_initialStakingAddresses' of ValidatorSetBase.initialize (ValidatorSetBase.sol#298) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 299,
          "vulnerability_to_line": null,
          "vulnerability_code": "        bool _firstValidatorIsUnremovable\n",
          "message": "Parameter '_firstValidatorIsUnremovable' of ValidatorSetBase.initialize (ValidatorSetBase.sol#299) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 337,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setStakingAddress(address _miningAddress, address _stakingAddress) external onlyStakingContract {\n",
          "message": "Parameter '_miningAddress' of ValidatorSetBase.setStakingAddress (ValidatorSetBase.sol#337) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 337,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setStakingAddress(address _miningAddress, address _stakingAddress) external onlyStakingContract {\n",
          "message": "Parameter '_stakingAddress' of ValidatorSetBase.setStakingAddress (ValidatorSetBase.sol#337) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 428,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function isReportValidatorValid(address _miningAddress) public view returns(bool) {\n",
          "message": "Parameter '_miningAddress' of ValidatorSetBase.isReportValidatorValid (ValidatorSetBase.sol#428) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 447,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function isValidator(address _miningAddress) public view returns(bool) {\n",
          "message": "Parameter '_miningAddress' of ValidatorSetBase.isValidator (ValidatorSetBase.sol#447) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 461,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function isValidatorBanned(address _miningAddress) public view returns(bool) {\n",
          "message": "Parameter '_miningAddress' of ValidatorSetBase.isValidatorBanned (ValidatorSetBase.sol#461) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 468,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function miningByStakingAddress(address _stakingAddress) public view returns(address) {\n",
          "message": "Parameter '_stakingAddress' of ValidatorSetBase.miningByStakingAddress (ValidatorSetBase.sol#468) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 480,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function stakingByMiningAddress(address _miningAddress) public view returns(address) {\n",
          "message": "Parameter '_miningAddress' of ValidatorSetBase.stakingByMiningAddress (ValidatorSetBase.sol#480) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 506,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function validatorIndex(address _miningAddress) public view returns(uint256) {\n",
          "message": "Parameter '_miningAddress' of ValidatorSetBase.validatorIndex (ValidatorSetBase.sol#506) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 345,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function banCounter(address _miningAddress) public view returns(uint256) {\n",
          "message": "Parameter '_miningAddress' of ValidatorSetBase.banCounter (ValidatorSetBase.sol#345) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 354,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function bannedUntil(address _miningAddress) public view returns(uint256) {\n",
          "message": "Parameter '_miningAddress' of ValidatorSetBase.bannedUntil (ValidatorSetBase.sol#354) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 454,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function isValidatorOnPreviousEpoch(address _miningAddress) public view returns(bool) {\n",
          "message": "Parameter '_miningAddress' of ValidatorSetBase.isValidatorOnPreviousEpoch (ValidatorSetBase.sol#454) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 497,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function validatorCounter(address _miningAddress) public view returns(uint256) {\n",
          "message": "Parameter '_miningAddress' of ValidatorSetBase.validatorCounter (ValidatorSetBase.sol#497) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 552,
          "vulnerability_to_line": 569,
          "vulnerability_code": "    function _applyQueueValidators(address[] memory _queueValidators) internal {\n\n        address[] memory prevValidators = getValidators();\n\n        uint256 i;\n\n\n\n        // Clear indexes for old validator set\n\n        for (i = 0; i < prevValidators.length; i++) {\n\n            _setValidatorIndex(prevValidators[i], 0);\n\n            _setIsValidator(prevValidators[i], false);\n\n        }\n\n\n\n        addressArrayStorage[CURRENT_VALIDATORS] = _queueValidators;\n\n\n\n        // Set indexes for new validator set\n\n        for (i = 0; i < _queueValidators.length; i++) {\n\n            _setValidatorIndex(_queueValidators[i], i);\n\n            _setIsValidator(_queueValidators[i], true);\n\n        }\n",
          "message": "Function 'ValidatorSetBase._applyQueueValidators' (ValidatorSetBase.sol#552-569) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 552,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _applyQueueValidators(address[] memory _queueValidators) internal {\n",
          "message": "Parameter '_queueValidators' of ValidatorSetBase._applyQueueValidators (ValidatorSetBase.sol#552) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 575,
          "vulnerability_to_line": 581,
          "vulnerability_code": "    function _banValidator(address _miningAddress) internal {\n\n        if (_banStart() > bannedUntil(_miningAddress)) {\n\n            uintStorage[keccak256(abi.encode(BAN_COUNTER, _miningAddress))]++;\n\n        }\n\n\n\n        uintStorage[keccak256(abi.encode(BANNED_UNTIL, _miningAddress))] = _banUntil();\n",
          "message": "Function 'ValidatorSetBase._banValidator' (ValidatorSetBase.sol#575-581) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 575,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _banValidator(address _miningAddress) internal {\n",
          "message": "Parameter '_miningAddress' of ValidatorSetBase._banValidator (ValidatorSetBase.sol#575) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 588,
          "vulnerability_to_line": 607,
          "vulnerability_code": "    function _enqueuePendingValidators(bool _newStakingEpoch) internal {\n\n        int256 queueFirst = intStorage[QUEUE_PV_FIRST];\n\n        int256 queueLast = intStorage[QUEUE_PV_LAST];\n\n\n\n        for (int256 i = queueLast; i >= queueFirst; i--) {\n\n            if (uintStorage[keccak256(abi.encode(QUEUE_PV_BLOCK, i))] == _getCurrentBlockNumber()) {\n\n                addressArrayStorage[keccak256(abi.encode(QUEUE_PV_LIST, i))] = getPendingValidators();\n\n                if (_newStakingEpoch) {\n\n                    boolStorage[keccak256(abi.encode(QUEUE_PV_NEW_EPOCH, i))] = true;\n\n                }\n\n                return;\n\n            }\n\n        }\n\n\n\n        queueLast++;\n\n        addressArrayStorage[keccak256(abi.encode(QUEUE_PV_LIST, queueLast))] = getPendingValidators();\n\n        boolStorage[keccak256(abi.encode(QUEUE_PV_NEW_EPOCH, queueLast))] = _newStakingEpoch;\n\n        uintStorage[keccak256(abi.encode(QUEUE_PV_BLOCK, queueLast))] = _getCurrentBlockNumber();\n\n        intStorage[QUEUE_PV_LAST] = queueLast;\n",
          "message": "Function 'ValidatorSetBase._enqueuePendingValidators' (ValidatorSetBase.sol#588-607) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 588,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _enqueuePendingValidators(bool _newStakingEpoch) internal {\n",
          "message": "Parameter '_newStakingEpoch' of ValidatorSetBase._enqueuePendingValidators (ValidatorSetBase.sol#588) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 614,
          "vulnerability_to_line": 629,
          "vulnerability_code": "    function _dequeuePendingValidators() internal returns(address[] memory newSet, bool newStakingEpoch) {\n\n        int256 queueFirst = intStorage[QUEUE_PV_FIRST];\n\n        int256 queueLast = intStorage[QUEUE_PV_LAST];\n\n\n\n        if (queueLast < queueFirst) {\n\n            newSet = new address[](0);\n\n            newStakingEpoch = false;\n\n        } else {\n\n            newSet = addressArrayStorage[keccak256(abi.encode(QUEUE_PV_LIST, queueFirst))];\n\n            newStakingEpoch = boolStorage[keccak256(abi.encode(QUEUE_PV_NEW_EPOCH, queueFirst))];\n\n            delete addressArrayStorage[keccak256(abi.encode(QUEUE_PV_LIST, queueFirst))];\n\n            delete boolStorage[keccak256(abi.encode(QUEUE_PV_NEW_EPOCH, queueFirst))];\n\n            delete uintStorage[keccak256(abi.encode(QUEUE_PV_BLOCK, queueFirst))];\n\n            intStorage[QUEUE_PV_FIRST]++;\n\n        }\n",
          "message": "Function 'ValidatorSetBase._dequeuePendingValidators' (ValidatorSetBase.sol#614-629) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 633,
          "vulnerability_to_line": 635,
          "vulnerability_code": "    function _incrementChangeRequestCount() internal {\n\n        uintStorage[CHANGE_REQUEST_COUNT]++;\n",
          "message": "Function 'ValidatorSetBase._incrementChangeRequestCount' (ValidatorSetBase.sol#633-635) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 642,
          "vulnerability_to_line": 687,
          "vulnerability_code": "    function _newValidatorSet() internal returns(uint256) {\n\n        IStaking staking = IStaking(stakingContract());\n\n        address[] memory poolsToBeElected = staking.getPoolsToBeElected();\n\n        address unremovableStakingAddress = unremovableValidator();\n\n\n\n        // Choose new validators\n\n        if (\n\n            poolsToBeElected.length >= MAX_VALIDATORS &&\n\n            (poolsToBeElected.length != MAX_VALIDATORS || unremovableStakingAddress != address(0))\n\n        ) {\n\n            uint256 randomNumber = IRandom(randomContract()).getCurrentSeed();\n\n\n\n            (int256[] memory likelihood, int256 likelihoodSum) = staking.getPoolsLikelihood();\n\n\n\n            if (likelihood.length > 0 && likelihoodSum > 0) {\n\n                address[] memory newValidators = new address[](\n\n                    unremovableStakingAddress == address(0) ? MAX_VALIDATORS : MAX_VALIDATORS - 1\n\n                );\n\n\n\n                uint256 poolsToBeElectedLength = poolsToBeElected.length;\n\n                for (uint256 i = 0; i < newValidators.length; i++) {\n\n                    randomNumber = uint256(keccak256(abi.encode(randomNumber)));\n\n                    uint256 randomPoolIndex = _getRandomIndex(likelihood, likelihoodSum, randomNumber);\n\n                    newValidators[i] = poolsToBeElected[randomPoolIndex];\n\n                    likelihoodSum -= likelihood[randomPoolIndex];\n\n                    poolsToBeElectedLength--;\n\n                    poolsToBeElected[randomPoolIndex] = poolsToBeElected[poolsToBeElectedLength];\n\n                    likelihood[randomPoolIndex] = likelihood[poolsToBeElectedLength];\n\n                }\n\n\n\n                _setPendingValidators(staking, newValidators, unremovableStakingAddress);\n\n            }\n\n        } else {\n\n            _setPendingValidators(staking, poolsToBeElected, unremovableStakingAddress);\n\n        }\n\n\n\n        // From this moment the `getPendingValidators()` will return a new validator set\n\n\n\n        staking.incrementStakingEpoch();\n\n        _setValidatorSetApplyBlock(0);\n\n\n\n        _incrementChangeRequestCount();\n\n        _enqueuePendingValidators(true);\n\n\n\n        return poolsToBeElected.length;\n",
          "message": "Function 'ValidatorSetBase._newValidatorSet' (ValidatorSetBase.sol#642-687) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 693,
          "vulnerability_to_line": 718,
          "vulnerability_code": "    function _removeMaliciousValidator(address _miningAddress) internal returns(bool) {\n\n        address stakingAddress = stakingByMiningAddress(_miningAddress);\n\n\n\n        if (stakingAddress == unremovableValidator()) {\n\n            return false;\n\n        }\n\n\n\n        // Ban the malicious validator for the next 3 months\n\n        _banValidator(_miningAddress);\n\n\n\n        // Remove malicious validator from the `pools`\n\n        IStaking(stakingContract()).removePool(stakingAddress);\n\n\n\n        address[] storage miningAddresses = addressArrayStorage[PENDING_VALIDATORS];\n\n\n\n        for (uint256 i = 0; i < miningAddresses.length; i++) {\n\n            if (miningAddresses[i] == _miningAddress) {\n\n                // Remove the malicious validator from `pendingValidators`\n\n                miningAddresses[i] = miningAddresses[miningAddresses.length - 1];\n\n                miningAddresses.length--;\n\n                return true;\n\n            }\n\n        }\n\n\n\n        return false;\n",
          "message": "Function 'ValidatorSetBase._removeMaliciousValidator' (ValidatorSetBase.sol#693-718) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 693,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _removeMaliciousValidator(address _miningAddress) internal returns(bool) {\n",
          "message": "Parameter '_miningAddress' of ValidatorSetBase._removeMaliciousValidator (ValidatorSetBase.sol#693) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 724,
          "vulnerability_to_line": 726,
          "vulnerability_code": "    function _setInitiateChangeAllowed(bool _allowed) internal {\n\n        boolStorage[INITIATE_CHANGE_ALLOWED] = _allowed;\n",
          "message": "Function 'ValidatorSetBase._setInitiateChangeAllowed' (ValidatorSetBase.sol#724-726) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 724,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setInitiateChangeAllowed(bool _allowed) internal {\n",
          "message": "Parameter '_allowed' of ValidatorSetBase._setInitiateChangeAllowed (ValidatorSetBase.sol#724) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 733,
          "vulnerability_to_line": 739,
          "vulnerability_code": "    function _setIsValidator(address _miningAddress, bool _isValidator) internal {\n\n        boolStorage[keccak256(abi.encode(IS_VALIDATOR, _miningAddress))] = _isValidator;\n\n\n\n        if (_isValidator) {\n\n            uintStorage[keccak256(abi.encode(VALIDATOR_COUNTER, _miningAddress))]++;\n\n        }\n",
          "message": "Function 'ValidatorSetBase._setIsValidator' (ValidatorSetBase.sol#733-739) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 733,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setIsValidator(address _miningAddress, bool _isValidator) internal {\n",
          "message": "Parameter '_miningAddress' of ValidatorSetBase._setIsValidator (ValidatorSetBase.sol#733) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 733,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setIsValidator(address _miningAddress, bool _isValidator) internal {\n",
          "message": "Parameter '_isValidator' of ValidatorSetBase._setIsValidator (ValidatorSetBase.sol#733) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 745,
          "vulnerability_to_line": 747,
          "vulnerability_code": "    function _setIsValidatorOnPreviousEpoch(address _miningAddress, bool _isValidator) internal {\n\n        boolStorage[keccak256(abi.encode(IS_VALIDATOR_ON_PREVIOUS_EPOCH, _miningAddress))] = _isValidator;\n",
          "message": "Function 'ValidatorSetBase._setIsValidatorOnPreviousEpoch' (ValidatorSetBase.sol#745-747) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 745,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setIsValidatorOnPreviousEpoch(address _miningAddress, bool _isValidator) internal {\n",
          "message": "Parameter '_miningAddress' of ValidatorSetBase._setIsValidatorOnPreviousEpoch (ValidatorSetBase.sol#745) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 745,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setIsValidatorOnPreviousEpoch(address _miningAddress, bool _isValidator) internal {\n",
          "message": "Parameter '_isValidator' of ValidatorSetBase._setIsValidatorOnPreviousEpoch (ValidatorSetBase.sol#745) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 756,
          "vulnerability_to_line": 779,
          "vulnerability_code": "    function _setPendingValidators(\n\n        IStaking _stakingContract,\n\n        address[] memory _stakingAddresses,\n\n        address _unremovableStakingAddress\n\n    ) internal {\n\n        if (_stakingAddresses.length == 0) return;\n\n\n\n        uint256 i;\n\n\n\n        delete addressArrayStorage[PENDING_VALIDATORS];\n\n\n\n        if (_unremovableStakingAddress != address(0)) {\n\n            addressArrayStorage[PENDING_VALIDATORS].push(miningByStakingAddress(_unremovableStakingAddress));\n\n        }\n\n\n\n        for (i = 0; i < _stakingAddresses.length; i++) {\n\n            addressArrayStorage[PENDING_VALIDATORS].push(miningByStakingAddress(_stakingAddresses[i]));\n\n        }\n\n\n\n        address[] memory poolsToBeRemoved = _stakingContract.getPoolsToBeRemoved();\n\n        for (i = 0; i < poolsToBeRemoved.length; i++) {\n\n            _stakingContract.removePool(poolsToBeRemoved[i]);\n\n        }\n",
          "message": "Function 'ValidatorSetBase._setPendingValidators' (ValidatorSetBase.sol#756-779) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 757,
          "vulnerability_to_line": null,
          "vulnerability_code": "        IStaking _stakingContract,\n",
          "message": "Parameter '_stakingContract' of ValidatorSetBase._setPendingValidators (ValidatorSetBase.sol#757) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 758,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address[] memory _stakingAddresses,\n",
          "message": "Parameter '_stakingAddresses' of ValidatorSetBase._setPendingValidators (ValidatorSetBase.sol#758) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 759,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address _unremovableStakingAddress\n",
          "message": "Parameter '_unremovableStakingAddress' of ValidatorSetBase._setPendingValidators (ValidatorSetBase.sol#759) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 786,
          "vulnerability_to_line": 789,
          "vulnerability_code": "    function _setQueueValidators(address[] memory _miningAddresses, bool _newStakingEpoch) internal {\n\n        addressArrayStorage[QUEUE_VALIDATORS] = _miningAddresses;\n\n        boolStorage[QUEUE_VALIDATORS_NEW_STAKING_EPOCH] = _newStakingEpoch;\n",
          "message": "Function 'ValidatorSetBase._setQueueValidators' (ValidatorSetBase.sol#786-789) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 786,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setQueueValidators(address[] memory _miningAddresses, bool _newStakingEpoch) internal {\n",
          "message": "Parameter '_miningAddresses' of ValidatorSetBase._setQueueValidators (ValidatorSetBase.sol#786) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 786,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setQueueValidators(address[] memory _miningAddresses, bool _newStakingEpoch) internal {\n",
          "message": "Parameter '_newStakingEpoch' of ValidatorSetBase._setQueueValidators (ValidatorSetBase.sol#786) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 795,
          "vulnerability_to_line": 805,
          "vulnerability_code": "    function _setStakingAddress(address _miningAddress, address _stakingAddress) internal {\n\n        require(_miningAddress != address(0));\n\n        require(_stakingAddress != address(0));\n\n        require(_miningAddress != _stakingAddress);\n\n        require(miningByStakingAddress(_stakingAddress) == address(0));\n\n        require(miningByStakingAddress(_miningAddress) == address(0));\n\n        require(stakingByMiningAddress(_stakingAddress) == address(0));\n\n        require(stakingByMiningAddress(_miningAddress) == address(0));\n\n        addressStorage[keccak256(abi.encode(MINING_BY_STAKING_ADDRESS, _stakingAddress))] = _miningAddress;\n\n        addressStorage[keccak256(abi.encode(STAKING_BY_MINING_ADDRESS, _miningAddress))] = _stakingAddress;\n",
          "message": "Function 'ValidatorSetBase._setStakingAddress' (ValidatorSetBase.sol#795-805) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 795,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setStakingAddress(address _miningAddress, address _stakingAddress) internal {\n",
          "message": "Parameter '_miningAddress' of ValidatorSetBase._setStakingAddress (ValidatorSetBase.sol#795) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 795,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setStakingAddress(address _miningAddress, address _stakingAddress) internal {\n",
          "message": "Parameter '_stakingAddress' of ValidatorSetBase._setStakingAddress (ValidatorSetBase.sol#795) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 810,
          "vulnerability_to_line": 812,
          "vulnerability_code": "    function _setUnremovableValidator(address _stakingAddress) internal {\n\n        addressStorage[UNREMOVABLE_STAKING_ADDRESS] = _stakingAddress;\n",
          "message": "Function 'ValidatorSetBase._setUnremovableValidator' (ValidatorSetBase.sol#810-812) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 810,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setUnremovableValidator(address _stakingAddress) internal {\n",
          "message": "Parameter '_stakingAddress' of ValidatorSetBase._setUnremovableValidator (ValidatorSetBase.sol#810) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 818,
          "vulnerability_to_line": 820,
          "vulnerability_code": "    function _setValidatorIndex(address _miningAddress, uint256 _index) internal {\n\n        uintStorage[keccak256(abi.encode(VALIDATOR_INDEX, _miningAddress))] = _index;\n",
          "message": "Function 'ValidatorSetBase._setValidatorIndex' (ValidatorSetBase.sol#818-820) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 818,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setValidatorIndex(address _miningAddress, uint256 _index) internal {\n",
          "message": "Parameter '_miningAddress' of ValidatorSetBase._setValidatorIndex (ValidatorSetBase.sol#818) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 818,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setValidatorIndex(address _miningAddress, uint256 _index) internal {\n",
          "message": "Parameter '_index' of ValidatorSetBase._setValidatorIndex (ValidatorSetBase.sol#818) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 826,
          "vulnerability_to_line": 828,
          "vulnerability_code": "    function _setValidatorSetApplyBlock(uint256 _blockNumber) internal {\n\n        uintStorage[VALIDATOR_SET_APPLY_BLOCK] = _blockNumber;\n",
          "message": "Function 'ValidatorSetBase._setValidatorSetApplyBlock' (ValidatorSetBase.sol#826-828) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 826,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setValidatorSetApplyBlock(uint256 _blockNumber) internal {\n",
          "message": "Parameter '_blockNumber' of ValidatorSetBase._setValidatorSetApplyBlock (ValidatorSetBase.sol#826) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 832,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _banStart() internal view returns(uint256);\n",
          "message": "Function 'ValidatorSetBase._banStart' (ValidatorSetBase.sol#832) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 836,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _banUntil() internal view returns(uint256);\n",
          "message": "Function 'ValidatorSetBase._banUntil' (ValidatorSetBase.sol#836) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 839,
          "vulnerability_to_line": 841,
          "vulnerability_code": "    function _getCurrentBlockNumber() internal view returns(uint256) {\n\n        return block.number;\n",
          "message": "Function 'ValidatorSetBase._getCurrentBlockNumber' (ValidatorSetBase.sol#839-841) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 848,
          "vulnerability_to_line": 861,
          "vulnerability_code": "    function _getRandomIndex(int256[] memory _likelihood, int256 _likelihoodSum, uint256 _randomNumber)\n\n        internal\n\n        pure\n\n        returns(uint256)\n\n    {\n\n        int256 r = int256(_randomNumber % uint256(_likelihoodSum)) + 1;\n\n        uint256 index = 0;\n\n        while (true) {\n\n            r -= _likelihood[index];\n\n            if (r <= 0) break;\n\n            index++;\n\n        }\n\n        return index;\n",
          "message": "Function 'ValidatorSetBase._getRandomIndex' (ValidatorSetBase.sol#848-861) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 848,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _getRandomIndex(int256[] memory _likelihood, int256 _likelihoodSum, uint256 _randomNumber)\n",
          "message": "Parameter '_likelihood' of ValidatorSetBase._getRandomIndex (ValidatorSetBase.sol#848) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 848,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _getRandomIndex(int256[] memory _likelihood, int256 _likelihoodSum, uint256 _randomNumber)\n",
          "message": "Parameter '_likelihoodSum' of ValidatorSetBase._getRandomIndex (ValidatorSetBase.sol#848) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 848,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _getRandomIndex(int256[] memory _likelihood, int256 _likelihoodSum, uint256 _randomNumber)\n",
          "message": "Parameter '_randomNumber' of ValidatorSetBase._getRandomIndex (ValidatorSetBase.sol#848) is not in mixedCase\n"
        },
        {
          "name": "unused-state",
          "vulnerability_from_line": 93,
          "vulnerability_to_line": null,
          "vulnerability_code": "    mapping(bytes32 => string) internal stringStorage;\n",
          "message": "EternalStorage.stringStorage (ValidatorSetBase.sol#93) is never used in ValidatorSetBase\nEternalStorage.bytesStorage (ValidatorSetBase.sol#95) is never used in ValidatorSetBase\nEternalStorage.bytes32Storage (ValidatorSetBase.sol#98) is never used in ValidatorSetBase\nEternalStorage.uintArrayStorage (ValidatorSetBase.sol#100) is never used in ValidatorSetBase\nEternalStorage.stringArrayStorage (ValidatorSetBase.sol#101) is never used in ValidatorSetBase\nEternalStorage.bytesArrayStorage (ValidatorSetBase.sol#103) is never used in ValidatorSetBase\nEternalStorage.boolArrayStorage (ValidatorSetBase.sol#104) is never used in ValidatorSetBase\nEternalStorage.intArrayStorage (ValidatorSetBase.sol#105) is never used in ValidatorSetBase\nEternalStorage.bytes32ArrayStorage (ValidatorSetBase.sol#106) is never used in ValidatorSetBase\n"
        }
      ]
    },
    "smartcheck": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 210,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == 0xffffFFFfFFffffffffffffffFfFFFfffFFFfFFfE);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 221,
          "vulnerability_to_line": null,
          "vulnerability_code": "        _setUnremovableValidator(address(0));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 262,
          "vulnerability_to_line": null,
          "vulnerability_code": "            for (i = 0; i < previousValidators.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 265,
          "vulnerability_to_line": null,
          "vulnerability_code": "            for (i = 0; i < currentValidators.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 262,
          "vulnerability_to_line": null,
          "vulnerability_code": "            for (i = 0; i < previousValidators.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 265,
          "vulnerability_to_line": null,
          "vulnerability_code": "            for (i = 0; i < currentValidators.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SAFEMATH",
          "vulnerability_from_line": 178,
          "vulnerability_to_line": null,
          "vulnerability_code": "    using SafeMath for uint256;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 35,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getPoolsLikelihood() external view returns(int256[] memory, int256);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 58,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function newValidatorSet() external returns(bool, uint256);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 293,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function initialize(\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 297,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address[] calldata _initialMiningAddresses,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 298,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address[] calldata _initialStakingAddresses,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 298,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address[] calldata _initialStakingAddresses,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 299,
          "vulnerability_to_line": null,
          "vulnerability_code": "        bool _firstValidatorIsUnremovable\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 301,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(!isInitialized()); // initialization can only be done once\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 301,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(!isInitialized()); // initialization can only be done once\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 302,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_blockRewardContract != address(0));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 302,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_blockRewardContract != address(0));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 302,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_blockRewardContract != address(0));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 303,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_randomContract != address(0));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 303,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_randomContract != address(0));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 303,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_randomContract != address(0));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 304,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_stakingContract != address(0));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 304,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_stakingContract != address(0));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 304,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_stakingContract != address(0));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 305,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_initialMiningAddresses.length > 0);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 305,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_initialMiningAddresses.length > 0);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 306,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_initialMiningAddresses.length == _initialStakingAddresses.length);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 306,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_initialMiningAddresses.length == _initialStakingAddresses.length);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 306,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_initialMiningAddresses.length == _initialStakingAddresses.length);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 308,
          "vulnerability_to_line": null,
          "vulnerability_code": "        addressStorage[BLOCK_REWARD_CONTRACT] = _blockRewardContract;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 309,
          "vulnerability_to_line": null,
          "vulnerability_code": "        addressStorage[RANDOM_CONTRACT] = _randomContract;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 310,
          "vulnerability_to_line": null,
          "vulnerability_code": "        addressStorage[STAKING_CONTRACT] = _stakingContract;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 312,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address[] storage currentValidators = addressArrayStorage[CURRENT_VALIDATORS];\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 313,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address[] storage pendingValidators = addressArrayStorage[PENDING_VALIDATORS];\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 316,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 i = 0; i < _initialMiningAddresses.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 316,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 i = 0; i < _initialMiningAddresses.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 316,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 i = 0; i < _initialMiningAddresses.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 317,
          "vulnerability_to_line": null,
          "vulnerability_code": "            currentValidators.push(_initialMiningAddresses[i]);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 317,
          "vulnerability_to_line": null,
          "vulnerability_code": "            currentValidators.push(_initialMiningAddresses[i]);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 318,
          "vulnerability_to_line": null,
          "vulnerability_code": "            pendingValidators.push(_initialMiningAddresses[i]);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 318,
          "vulnerability_to_line": null,
          "vulnerability_code": "            pendingValidators.push(_initialMiningAddresses[i]);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 319,
          "vulnerability_to_line": null,
          "vulnerability_code": "            _setValidatorIndex(_initialMiningAddresses[i], i);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 319,
          "vulnerability_to_line": null,
          "vulnerability_code": "            _setValidatorIndex(_initialMiningAddresses[i], i);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 319,
          "vulnerability_to_line": null,
          "vulnerability_code": "            _setValidatorIndex(_initialMiningAddresses[i], i);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 320,
          "vulnerability_to_line": null,
          "vulnerability_code": "            _setIsValidator(_initialMiningAddresses[i], true);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 320,
          "vulnerability_to_line": null,
          "vulnerability_code": "            _setIsValidator(_initialMiningAddresses[i], true);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 321,
          "vulnerability_to_line": null,
          "vulnerability_code": "            _setStakingAddress(_initialMiningAddresses[i], _initialStakingAddresses[i]);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 321,
          "vulnerability_to_line": null,
          "vulnerability_code": "            _setStakingAddress(_initialMiningAddresses[i], _initialStakingAddresses[i]);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 321,
          "vulnerability_to_line": null,
          "vulnerability_code": "            _setStakingAddress(_initialMiningAddresses[i], _initialStakingAddresses[i]);\n",
          "message": null
        }
      ]
    },
    "oyente": {
      "successfull_analysis": false,
      "errors": [
        "exception (IndexError: pop from empty list)"
      ],
      "vulnerability_findings": []
    },
    "mythril": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": []
    },
    "osiris": {
      "successfull_analysis": false,
      "errors": [
        "exception (IndexError: pop from empty list)"
      ],
      "vulnerability_findings": []
    }
  }
}