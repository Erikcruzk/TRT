{
  "smartbugs_completed": true,
  "analyzer_results": {
    "semgrep": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 221,
          "vulnerability_to_line": null,
          "vulnerability_code": "                addressArrayStorage[ALLOWED_SENDERS].length--;\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 289,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (i = 0; _data.length >= 4 && i < 4; i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 297,
          "vulnerability_to_line": null,
          "vulnerability_code": "            for (i = 0; i < abiParams.length; i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 321,
          "vulnerability_to_line": null,
          "vulnerability_code": "                for (i = 0; i < abiParams.length; i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 198,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 i = 0; i < _allowedSenders.length; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 218,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 i = 0; i < allowedSendersLength; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 394,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 i = 0; i < allowedSendersLength; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 347,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (validatorSet.isValidator(_sender) && _gasPrice > 0) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 348,
          "vulnerability_to_line": null,
          "vulnerability_code": "            // Let the validator's mining address send their accumulated tx fees to some wallet\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 349,
          "vulnerability_to_line": null,
          "vulnerability_code": "            return (_sender.balance > 0 ? BASIC : NONE, false);\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 350,
          "vulnerability_to_line": null,
          "vulnerability_code": "        }\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-prefix-decrement-not-postfix",
          "vulnerability_from_line": 221,
          "vulnerability_to_line": null,
          "vulnerability_code": "                addressArrayStorage[ALLOWED_SENDERS].length--;\n",
          "message": "Consider using the prefix decrement expression whenever the return value is not needed. The prefix decrement expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 198,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 i = 0; i < _allowedSenders.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 218,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 i = 0; i < allowedSendersLength; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 289,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (i = 0; _data.length >= 4 && i < 4; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 297,
          "vulnerability_to_line": null,
          "vulnerability_code": "            for (i = 0; i < abiParams.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 321,
          "vulnerability_to_line": null,
          "vulnerability_code": "                for (i = 0; i < abiParams.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 394,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 i = 0; i < allowedSendersLength; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        }
      ]
    },
    "slither": {
      "successfull_analysis": false,
      "errors": [
        "EXIT_CODE_255",
        "error parsing results: file could not be opened successfully"
      ],
      "vulnerability_findings": []
    },
    "smartcheck": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 241,
          "vulnerability_to_line": null,
          "vulnerability_code": "        return 0xfffffffffffffffe;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 415,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint32 internal constant ALL = 0xffffffff;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 416,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint32 internal constant BASIC = 0x01;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 417,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint32 internal constant CALL = 0x02;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 418,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint32 internal constant CREATE = 0x04;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 419,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint32 internal constant PRIVATE = 0x08;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ARRAY_LENGTH_MANIPULATION",
          "vulnerability_from_line": 221,
          "vulnerability_to_line": null,
          "vulnerability_code": "                addressArrayStorage[ALLOWED_SENDERS].length--;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 198,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 i = 0; i < _allowedSenders.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 289,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (i = 0; _data.length >= 4 && i < 4; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 297,
          "vulnerability_to_line": null,
          "vulnerability_code": "            for (i = 0; i < abiParams.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 321,
          "vulnerability_to_line": null,
          "vulnerability_code": "                for (i = 0; i < abiParams.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 198,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 i = 0; i < _allowedSenders.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 218,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 i = 0; i < allowedSendersLength; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 297,
          "vulnerability_to_line": null,
          "vulnerability_code": "            for (i = 0; i < abiParams.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 321,
          "vulnerability_to_line": null,
          "vulnerability_code": "                for (i = 0; i < abiParams.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 394,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 i = 0; i < allowedSendersLength; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 72,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function newValidatorSet() external returns(bool, uint256);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 100,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function reportMaliciousCallable(address, address, uint256) external view returns(bool, bool);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 276,
          "vulnerability_to_line": null,
          "vulnerability_code": "        returns(uint32 typesMask, bool cache)\n",
          "message": null
        }
      ]
    },
    "oyente": {
      "successfull_analysis": false,
      "errors": [
        "exception (RuntimeError: Source map error, unknown name(SHR) or instr_name(INVALID))"
      ],
      "vulnerability_findings": []
    },
    "mythril": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "Multiple Calls in a Single Transaction (SWC 113)",
          "vulnerability_from_line": 368,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (blockRewardContract.isRewarding()) {\n",
          "message": "Multiple calls are executed in the same transaction.\nThis call is executed following another call within the same transaction. It is possible that the call never gets executed if a prior call fails permanently. This might be caused intentionally by a malicious callee. If possible, refactor the code such that each transaction only executes one external call or make sure that all callees can be trusted (i.e. they\u2019re part of your own codebase).\nClassification: SWC-113"
        },
        {
          "name": "Integer Arithmetic Bugs (SWC 101)",
          "vulnerability_from_line": 373,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (block.number == stakingEpochEndBlock - 1 || block.number == stakingEpochEndBlock) {\n",
          "message": "The arithmetic operator can underflow.\nIt is possible to cause an integer overflow or underflow in the arithmetic operation. \nClassification: SWC-101"
        },
        {
          "name": "Dependence on predictable environment variable (SWC 120)",
          "vulnerability_from_line": 373,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (block.number == stakingEpochEndBlock - 1 || block.number == stakingEpochEndBlock) {\n",
          "message": "A control flow decision is made based on The block.number environment variable.\nThe block.number environment variable is used to determine a control flow decision. Note that the values of variables like coinbase, gaslimit, block number and timestamp are predictable and can be manipulated by a malicious miner. Also keep in mind that attackers know hashes of earlier blocks. Don't use any of those environment variables as sources of randomness and be aware that use of these variables introduces a certain level of trust into miners.\nClassification: SWC-120"
        },
        {
          "name": "Dependence on predictable environment variable (SWC 120)",
          "vulnerability_from_line": 373,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (block.number == stakingEpochEndBlock - 1 || block.number == stakingEpochEndBlock) {\n",
          "message": "A control flow decision is made based on The block.number environment variable.\nThe block.number environment variable is used to determine a control flow decision. Note that the values of variables like coinbase, gaslimit, block number and timestamp are predictable and can be manipulated by a malicious miner. Also keep in mind that attackers know hashes of earlier blocks. Don't use any of those environment variables as sources of randomness and be aware that use of these variables introduces a certain level of trust into miners.\nClassification: SWC-120"
        }
      ]
    },
    "osiris": {
      "successfull_analysis": false,
      "errors": [
        "exception (IndexError: pop from empty list)"
      ],
      "vulnerability_findings": []
    }
  }
}