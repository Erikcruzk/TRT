{
  "smartbugs_completed": true,
  "analyzer_results": {
    "semgrep": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "inefficient-state-variable-increment",
          "vulnerability_from_line": 602,
          "vulnerability_to_line": null,
          "vulnerability_code": "        _guardCounter += 1;\n",
          "message": "<x> += <y> costs more gas than <x> = <x> + <y> for state variables."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 588,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor() internal {\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 589,
          "vulnerability_to_line": null,
          "vulnerability_code": "        // The counter starts at one to prevent changing it from zero to a non-zero\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 590,
          "vulnerability_to_line": null,
          "vulnerability_code": "        // value, which is a more expensive operation.\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 591,
          "vulnerability_to_line": null,
          "vulnerability_code": "        _guardCounter = 1;\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 592,
          "vulnerability_to_line": null,
          "vulnerability_code": "    }\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 934,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor(\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 935,
          "vulnerability_to_line": null,
          "vulnerability_code": "        ComptrollerInterface comptroller_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 936,
          "vulnerability_to_line": null,
          "vulnerability_code": "        InterestRateModel interestRateModel_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 937,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint256 initialExchangeRateMantissa_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 938,
          "vulnerability_to_line": null,
          "vulnerability_code": "        string memory name_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 939,
          "vulnerability_to_line": null,
          "vulnerability_code": "        string memory symbol_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 940,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint256 decimals_\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 941,
          "vulnerability_to_line": null,
          "vulnerability_code": "    ) internal {\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 942,
          "vulnerability_to_line": null,
          "vulnerability_code": "        // Set admin to msg.sender\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 943,
          "vulnerability_to_line": null,
          "vulnerability_code": "        admin = msg.sender;\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 605,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(localCounter == _guardCounter, \"re-entered\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 947,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(initialExchangeRateMantissa > 0, \"Initial exchange rate must be greater than zero.\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 951,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(err == uint256(Error.NO_ERROR), \"Setting comptroller failed\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 959,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(err == uint256(Error.NO_ERROR), \"Setting interest rate model failed\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1149,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(opaqueErr == 0, \"borrowRatePerBlock: interestRateModel.borrowRate failed\"); // semi-opaque\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1170,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(e0 == 0, \"supplyRatePerBlock: calculating borrowRate failed\"); // semi-opaque\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1173,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(e1 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating underlying failed\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1176,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(e2 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating borrowsPer failed\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1182,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(e3 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating oneMinusReserveFactor failed\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1189,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(e4 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating supplyRate failed\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1199,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(accrueInterest() == uint256(Error.NO_ERROR), \"accrue interest failed\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1209,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(accrueInterest() == uint256(Error.NO_ERROR), \"accrue interest failed\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1220,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(err == MathError.NO_ERROR, \"borrowBalanceStored: borrowBalanceStoredInternal failed\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1266,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(accrueInterest() == uint256(Error.NO_ERROR), \"accrue interest failed\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1277,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(err == MathError.NO_ERROR, \"exchangeRateStored: exchangeRateStoredInternal failed\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1352,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(vars.borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1632,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1739,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(vars.err == Error.NO_ERROR, \"redeem transfer out failed\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1849,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(vars.err == Error.NO_ERROR, \"borrow transfer out failed\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1991,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(vars.err == Error.NO_ERROR, \"repay borrow transfer in failed\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 2114,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(seizeError == uint256(Error.NO_ERROR), \"token seizure failed\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 2257,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(newComptroller.isComptroller(), \"marker method returned false\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 2367,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(totalReservesNew <= totalReserves, \"reduce reserves unexpected underflow\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 2375,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(err == Error.NO_ERROR, \"reduce reserves transfer out failed\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 2423,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 947,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(initialExchangeRateMantissa > 0, \"Initial exchange rate must be greater than zero.\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 959,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(err == uint256(Error.NO_ERROR), \"Setting interest rate model failed\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 1149,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(opaqueErr == 0, \"borrowRatePerBlock: interestRateModel.borrowRate failed\"); // semi-opaque\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 1170,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(e0 == 0, \"supplyRatePerBlock: calculating borrowRate failed\"); // semi-opaque\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 1173,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(e1 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating underlying failed\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 1176,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(e2 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating borrowsPer failed\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 1182,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(e3 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating oneMinusReserveFactor failed\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 1189,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(e4 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating supplyRate failed\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 1220,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(err == MathError.NO_ERROR, \"borrowBalanceStored: borrowBalanceStoredInternal failed\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 1277,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(err == MathError.NO_ERROR, \"exchangeRateStored: exchangeRateStoredInternal failed\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 1632,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 2367,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(totalReservesNew <= totalReserves, \"reduce reserves unexpected underflow\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 2375,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(err == Error.NO_ERROR, \"reduce reserves transfer out failed\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "compound-borrowfresh-reentrancy",
          "vulnerability_from_line": 1848,
          "vulnerability_to_line": null,
          "vulnerability_code": "        vars.err = doTransferOut(borrower, borrowAmount);\n",
          "message": "Function borrowFresh() in Compound performs state update after doTransferOut()"
        }
      ]
    },
    "slither": {
      "successfull_analysis": true,
      "errors": [
        "EXIT_CODE_43"
      ],
      "vulnerability_findings": [
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 2318,
          "vulnerability_to_line": 2328,
          "vulnerability_code": "    function _reduceReserves(uint256 reduceAmount) external nonReentrant returns (uint256) {\n\n        uint256 error = accrueInterest();\n\n        if (error != uint256(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n\n            return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.\n\n        return _reduceReservesFresh(reduceAmount);\n\n    }\n\n\n",
          "message": "Reentrancy in CToken._reduceReserves (ComptrollerStorage.sol#2318-2328):\n\tExternal calls:\n\t- error = accrueInterest() (ComptrollerStorage.sol#2319-2320)\n\tState variables written after the call(s):\n\t- totalReserves (ComptrollerStorage.sol#2325-2328)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 2249,
          "vulnerability_to_line": 2268,
          "vulnerability_code": "    function _setComptroller(ComptrollerInterface newComptroller) public returns (uint256) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COMPTROLLER_OWNER_CHECK);\n\n        }\n\n\n\n        ComptrollerInterface oldComptroller = comptroller;\n\n        // Ensure invoke comptroller.isComptroller() returns true\n\n        require(newComptroller.isComptroller(), \"marker method returned false\");\n\n\n\n        // Set market's comptroller to newComptroller\n\n        comptroller = newComptroller;\n\n\n\n        // Emit NewComptroller(oldComptroller, newComptroller)\n\n        emit NewComptroller(oldComptroller, newComptroller);\n\n\n\n        return uint256(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Reentrancy in CToken._setComptroller (ComptrollerStorage.sol#2249-2268):\n\tExternal calls:\n\t- require(bool,string)(newComptroller.isComptroller(),marker method returned false) (ComptrollerStorage.sol#2257-2259)\n\tState variables written after the call(s):\n\t- comptroller (ComptrollerStorage.sol#2260-2262)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 2388,
          "vulnerability_to_line": 2399,
          "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint256) {\n\n        uint256 error = accrueInterest();\n\n        if (error != uint256(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n\n        return _setInterestRateModelFresh(newInterestRateModel);\n\n    }\n\n\n\n    /**\n",
          "message": "Reentrancy in CToken._setInterestRateModel (ComptrollerStorage.sol#2388-2399):\n\tExternal calls:\n\t- error = accrueInterest() (ComptrollerStorage.sol#2389-2390)\n\t- _setInterestRateModelFresh(newInterestRateModel) (ComptrollerStorage.sol#2395-2398)\n\tState variables written after the call(s):\n\t- interestRateModel (ComptrollerStorage.sol#2395-2398)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 2404,
          "vulnerability_to_line": 2434,
          "vulnerability_code": "    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint256) {\n\n        // Used to store old model for use in the event that is emitted on success\n\n        InterestRateModel oldInterestRateModel;\n\n\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);\n\n        }\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            // TODO: static_assert + no error code?\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);\n\n        }\n\n\n\n        // Track the market's current interest rate model\n\n        oldInterestRateModel = interestRateModel;\n\n\n\n        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true\n\n        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n\n\n\n        // Set the interest rate model to newInterestRateModel\n\n        interestRateModel = newInterestRateModel;\n\n\n\n        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)\n\n        emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);\n\n\n\n        return uint256(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Reentrancy in CToken._setInterestRateModelFresh (ComptrollerStorage.sol#2404-2434):\n\tExternal calls:\n\t- require(bool,string)(newInterestRateModel.isInterestRateModel(),marker method returned false) (ComptrollerStorage.sol#2423-2425)\n\tState variables written after the call(s):\n\t- interestRateModel (ComptrollerStorage.sol#2426-2428)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 2273,
          "vulnerability_to_line": 2283,
          "vulnerability_code": "    function _setReserveFactor(uint256 newReserveFactorMantissa) external nonReentrant returns (uint256) {\n\n        uint256 error = accrueInterest();\n\n        if (error != uint256(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.\n\n            return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.\n\n        return _setReserveFactorFresh(newReserveFactorMantissa);\n\n    }\n\n\n",
          "message": "Reentrancy in CToken._setReserveFactor (ComptrollerStorage.sol#2273-2283):\n\tExternal calls:\n\t- error = accrueInterest() (ComptrollerStorage.sol#2274-2275)\n\tState variables written after the call(s):\n\t- reserveFactorMantissa (ComptrollerStorage.sol#2280-2281)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 1343,
          "vulnerability_to_line": 1454,
          "vulnerability_code": "    function accrueInterest() public returns (uint256) {\n\n        AccrueInterestLocalVars memory vars;\n\n\n\n        /* Calculate the current borrow interest rate */\n\n        (vars.opaqueErr, vars.borrowRateMantissa) = interestRateModel.getBorrowRate(\n\n            getCashPrior(),\n\n            totalBorrows,\n\n            totalReserves\n\n        );\n\n        require(vars.borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n\n        if (vars.opaqueErr != 0) {\n\n            return\n\n                failOpaque(\n\n                    Error.INTEREST_RATE_MODEL_ERROR,\n\n                    FailureInfo.ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED,\n\n                    vars.opaqueErr\n\n                );\n\n        }\n\n\n\n        /* Remember the initial block number */\n\n        vars.currentBlockNumber = getBlockNumber();\n\n\n\n        /* Calculate the number of blocks elapsed since the last accrual */\n\n        (vars.mathErr, vars.blockDelta) = subUInt(vars.currentBlockNumber, accrualBlockNumber);\n\n        assert(vars.mathErr == MathError.NO_ERROR); // Block delta should always succeed and if it doesn't, blow up.\n\n\n\n        /*\n\n         * Calculate the interest accumulated into borrows and reserves and the new index:\n\n         *  simpleInterestFactor = borrowRate * blockDelta\n\n         *  interestAccumulated = simpleInterestFactor * totalBorrows\n\n         *  totalBorrowsNew = interestAccumulated + totalBorrows\n\n         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves\n\n         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\n\n         */\n\n        (vars.mathErr, vars.simpleInterestFactor) = mulScalar(\n\n            Exp({mantissa: vars.borrowRateMantissa}),\n\n            vars.blockDelta\n\n        );\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return\n\n                failOpaque(\n\n                    Error.MATH_ERROR,\n\n                    FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED,\n\n                    uint256(vars.mathErr)\n\n                );\n\n        }\n\n\n\n        (vars.mathErr, vars.interestAccumulated) = mulScalarTruncate(vars.simpleInterestFactor, totalBorrows);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return\n\n                failOpaque(\n\n                    Error.MATH_ERROR,\n\n                    FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED,\n\n                    uint256(vars.mathErr)\n\n                );\n\n        }\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(vars.interestAccumulated, totalBorrows);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return\n\n                failOpaque(\n\n                    Error.MATH_ERROR,\n\n                    FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED,\n\n                    uint256(vars.mathErr)\n\n                );\n\n        }\n\n\n\n        (vars.mathErr, vars.totalReservesNew) = mulScalarTruncateAddUInt(\n\n            Exp({mantissa: reserveFactorMantissa}),\n\n            vars.interestAccumulated,\n\n            totalReserves\n\n        );\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return\n\n                failOpaque(\n\n                    Error.MATH_ERROR,\n\n                    FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED,\n\n                    uint256(vars.mathErr)\n\n                );\n\n        }\n\n\n\n        (vars.mathErr, vars.borrowIndexNew) = mulScalarTruncateAddUInt(\n\n            vars.simpleInterestFactor,\n\n            borrowIndex,\n\n            borrowIndex\n\n        );\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return\n\n                failOpaque(\n\n                    Error.MATH_ERROR,\n\n                    FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED,\n\n                    uint256(vars.mathErr)\n\n                );\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accrualBlockNumber = vars.currentBlockNumber;\n\n        borrowIndex = vars.borrowIndexNew;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n        totalReserves = vars.totalReservesNew;\n\n\n\n        /* We emit an AccrueInterest event */\n\n        emit AccrueInterest(vars.interestAccumulated, vars.borrowIndexNew, totalBorrows);\n\n\n\n        return uint256(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Reentrancy in CToken.accrueInterest (ComptrollerStorage.sol#1343-1454):\n\tExternal calls:\n\t- (vars.opaqueErr,vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(),totalBorrows,totalReserves) (ComptrollerStorage.sol#1347-1352)\n\tState variables written after the call(s):\n\t- totalBorrows (ComptrollerStorage.sol#1445-1446)\n\t- totalReserves (ComptrollerStorage.sol#1446-1448)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 1760,
          "vulnerability_to_line": 1770,
          "vulnerability_code": "    function borrowInternal(uint256 borrowAmount) internal nonReentrant returns (uint256) {\n\n        uint256 error = accrueInterest();\n\n        if (error != uint256(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n\n            return fail(Error(error), FailureInfo.BORROW_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // borrowFresh emits borrow-specific logs on errors, so we don't need to\n\n        return borrowFresh(msg.sender, borrowAmount);\n\n    }\n\n\n",
          "message": "Reentrancy in CToken.borrowInternal (ComptrollerStorage.sol#1760-1770):\n\tExternal calls:\n\t- error = accrueInterest() (ComptrollerStorage.sol#1761-1762)\n\t- borrowFresh(msg.sender,borrowAmount) (ComptrollerStorage.sol#1767-1768)\n\tState variables written after the call(s):\n\t- totalBorrows (ComptrollerStorage.sol#1767-1768)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 2015,
          "vulnerability_to_line": 2036,
          "vulnerability_code": "    function liquidateBorrowInternal(address borrower, uint256 repayAmount, CToken cTokenCollateral)\n\n        internal\n\n        nonReentrant\n\n        returns (uint256)\n\n    {\n\n        uint256 error = accrueInterest();\n\n        if (error != uint256(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\n\n            return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED);\n\n        }\n\n\n\n        error = cTokenCollateral.accrueInterest();\n\n        if (error != uint256(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\n\n            return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED);\n\n        }\n\n\n\n        // liquidateBorrowFresh emits borrow-specific logs on errors, so we don't need to\n\n        return liquidateBorrowFresh(msg.sender, borrower, repayAmount, cTokenCollateral);\n\n    }\n\n\n",
          "message": "Reentrancy in CToken.liquidateBorrowInternal (ComptrollerStorage.sol#2015-2036):\n\tExternal calls:\n\t- error = accrueInterest() (ComptrollerStorage.sol#2020-2021)\n\t- error = cTokenCollateral.accrueInterest() (ComptrollerStorage.sol#2026-2027)\n\t- liquidateBorrowFresh(msg.sender,borrower,repayAmount,cTokenCollateral) (ComptrollerStorage.sol#2033-2034)\n\tState variables written after the call(s):\n\t- totalBorrows (ComptrollerStorage.sol#2033-2034)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 1628,
          "vulnerability_to_line": 1755,
          "vulnerability_code": "    function redeemFresh(address payable redeemer, uint256 redeemTokensIn, uint256 redeemAmountIn)\n\n        internal\n\n        returns (uint256)\n\n    {\n\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n\n\n\n        RedeemLocalVars memory vars;\n\n\n\n        /* exchangeRate = invoke Exchange Rate Stored() */\n\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint256(vars.mathErr));\n\n        }\n\n\n\n        /* If redeemTokensIn > 0: */\n\n        if (redeemTokensIn > 0) {\n\n            /*\n\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\n\n             *  redeemTokens = redeemTokensIn\n\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n\n             */\n\n            vars.redeemTokens = redeemTokensIn;\n\n\n\n            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(\n\n                Exp({mantissa: vars.exchangeRateMantissa}),\n\n                redeemTokensIn\n\n            );\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return\n\n                    failOpaque(\n\n                        Error.MATH_ERROR,\n\n                        FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED,\n\n                        uint256(vars.mathErr)\n\n                    );\n\n            }\n\n        } else {\n\n            /*\n\n             * We get the current exchange rate and calculate the amount to be redeemed:\n\n             *  redeemTokens = redeemAmountIn / exchangeRate\n\n             *  redeemAmount = redeemAmountIn\n\n             */\n\n\n\n            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(\n\n                redeemAmountIn,\n\n                Exp({mantissa: vars.exchangeRateMantissa})\n\n            );\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return\n\n                    failOpaque(\n\n                        Error.MATH_ERROR,\n\n                        FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED,\n\n                        uint256(vars.mathErr)\n\n                    );\n\n            }\n\n\n\n            vars.redeemAmount = redeemAmountIn;\n\n        }\n\n\n\n        /* Fail if redeem not allowed */\n\n        uint256 allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);\n\n        }\n\n\n\n        /*\n\n         * We calculate the new total supply and redeemer balance, checking for underflow:\n\n         *  totalSupplyNew = totalSupply - redeemTokens\n\n         *  accountTokensNew = accountTokens[redeemer] - redeemTokens\n\n         */\n\n        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return\n\n                failOpaque(\n\n                    Error.MATH_ERROR,\n\n                    FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED,\n\n                    uint256(vars.mathErr)\n\n                );\n\n        }\n\n\n\n        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return\n\n                failOpaque(\n\n                    Error.MATH_ERROR,\n\n                    FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED,\n\n                    uint256(vars.mathErr)\n\n                );\n\n        }\n\n\n\n        /* Fail gracefully if protocol has insufficient cash */\n\n        if (getCashPrior() < vars.redeemAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We invoke doTransferOut for the redeemer and the redeemAmount.\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken has redeemAmount less of cash.\n\n         *  If doTransferOut fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferOut(redeemer, vars.redeemAmount);\n\n        require(vars.err == Error.NO_ERROR, \"redeem transfer out failed\");\n\n\n\n        /* We write previously calculated values into storage */\n\n        totalSupply = vars.totalSupplyNew;\n\n        accountTokens[redeemer] = vars.accountTokensNew;\n\n\n\n        /* We emit a Transfer event, and a Redeem event */\n\n        emit Transfer(redeemer, address(this), vars.redeemTokens);\n\n        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        /* We call the defense hook */\n\n        comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        return uint256(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Reentrancy in CToken.redeemFresh (ComptrollerStorage.sol#1628-1755):\n\tExternal calls:\n\t- allowed = comptroller.redeemAllowed(address(this),redeemer,vars.redeemTokens) (ComptrollerStorage.sol#1687-1688)\n\tState variables written after the call(s):\n\t- totalSupply (ComptrollerStorage.sol#1742-1743)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 1886,
          "vulnerability_to_line": 1896,
          "vulnerability_code": "    function repayBorrowBehalfInternal(address borrower, uint256 repayAmount) internal nonReentrant returns (uint256) {\n\n        uint256 error = accrueInterest();\n\n        if (error != uint256(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n\n            return fail(Error(error), FailureInfo.REPAY_BEHALF_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n\n        return repayBorrowFresh(msg.sender, borrower, repayAmount);\n\n    }\n\n\n",
          "message": "Reentrancy in CToken.repayBorrowBehalfInternal (ComptrollerStorage.sol#1886-1896):\n\tExternal calls:\n\t- error = accrueInterest() (ComptrollerStorage.sol#1887-1888)\n\t- repayBorrowFresh(msg.sender,borrower,repayAmount) (ComptrollerStorage.sol#1893-1894)\n\tState variables written after the call(s):\n\t- totalBorrows (ComptrollerStorage.sol#1893-1894)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 1870,
          "vulnerability_to_line": 1880,
          "vulnerability_code": "    function repayBorrowInternal(uint256 repayAmount) internal nonReentrant returns (uint256) {\n\n        uint256 error = accrueInterest();\n\n        if (error != uint256(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n\n            return fail(Error(error), FailureInfo.REPAY_BORROW_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n\n        return repayBorrowFresh(msg.sender, msg.sender, repayAmount);\n\n    }\n\n\n",
          "message": "Reentrancy in CToken.repayBorrowInternal (ComptrollerStorage.sol#1870-1880):\n\tExternal calls:\n\t- error = accrueInterest() (ComptrollerStorage.sol#1871-1872)\n\t- repayBorrowFresh(msg.sender,msg.sender,repayAmount) (ComptrollerStorage.sol#1877-1878)\n\tState variables written after the call(s):\n\t- totalBorrows (ComptrollerStorage.sol#1877-1878)\n"
        },
        {
          "name": "uninitialized-local",
          "vulnerability_from_line": 1344,
          "vulnerability_to_line": 1346,
          "vulnerability_code": "        AccrueInterestLocalVars memory vars;\n\n\n",
          "message": "vars in CToken.accrueInterest (ComptrollerStorage.sol#1344-1346) is a local variable never initialiazed\n"
        },
        {
          "name": "uninitialized-local",
          "vulnerability_from_line": 1634,
          "vulnerability_to_line": 1636,
          "vulnerability_code": "        RedeemLocalVars memory vars;\n\n\n",
          "message": "vars in CToken.redeemFresh (ComptrollerStorage.sol#1634-1636) is a local variable never initialiazed\n"
        },
        {
          "name": "uninitialized-local",
          "vulnerability_from_line": 1498,
          "vulnerability_to_line": 1500,
          "vulnerability_code": "        MintLocalVars memory vars;\n\n\n",
          "message": "vars in CToken.mintFresh (ComptrollerStorage.sol#1498-1500) is a local variable never initialiazed\n"
        },
        {
          "name": "uninitialized-local",
          "vulnerability_from_line": 1925,
          "vulnerability_to_line": 1927,
          "vulnerability_code": "        RepayBorrowLocalVars memory vars;\n\n\n",
          "message": "vars in CToken.repayBorrowFresh (ComptrollerStorage.sol#1925-1927) is a local variable never initialiazed\n"
        },
        {
          "name": "uninitialized-local",
          "vulnerability_from_line": 1800,
          "vulnerability_to_line": 1802,
          "vulnerability_code": "        BorrowLocalVars memory vars;\n\n\n",
          "message": "vars in CToken.borrowFresh (ComptrollerStorage.sol#1800-1802) is a local variable never initialiazed\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 1343,
          "vulnerability_to_line": 1454,
          "vulnerability_code": "    function accrueInterest() public returns (uint256) {\n\n        AccrueInterestLocalVars memory vars;\n\n\n\n        /* Calculate the current borrow interest rate */\n\n        (vars.opaqueErr, vars.borrowRateMantissa) = interestRateModel.getBorrowRate(\n\n            getCashPrior(),\n\n            totalBorrows,\n\n            totalReserves\n\n        );\n\n        require(vars.borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n\n        if (vars.opaqueErr != 0) {\n\n            return\n\n                failOpaque(\n\n                    Error.INTEREST_RATE_MODEL_ERROR,\n\n                    FailureInfo.ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED,\n\n                    vars.opaqueErr\n\n                );\n\n        }\n\n\n\n        /* Remember the initial block number */\n\n        vars.currentBlockNumber = getBlockNumber();\n\n\n\n        /* Calculate the number of blocks elapsed since the last accrual */\n\n        (vars.mathErr, vars.blockDelta) = subUInt(vars.currentBlockNumber, accrualBlockNumber);\n\n        assert(vars.mathErr == MathError.NO_ERROR); // Block delta should always succeed and if it doesn't, blow up.\n\n\n\n        /*\n\n         * Calculate the interest accumulated into borrows and reserves and the new index:\n\n         *  simpleInterestFactor = borrowRate * blockDelta\n\n         *  interestAccumulated = simpleInterestFactor * totalBorrows\n\n         *  totalBorrowsNew = interestAccumulated + totalBorrows\n\n         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves\n\n         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\n\n         */\n\n        (vars.mathErr, vars.simpleInterestFactor) = mulScalar(\n\n            Exp({mantissa: vars.borrowRateMantissa}),\n\n            vars.blockDelta\n\n        );\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return\n\n                failOpaque(\n\n                    Error.MATH_ERROR,\n\n                    FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED,\n\n                    uint256(vars.mathErr)\n\n                );\n\n        }\n\n\n\n        (vars.mathErr, vars.interestAccumulated) = mulScalarTruncate(vars.simpleInterestFactor, totalBorrows);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return\n\n                failOpaque(\n\n                    Error.MATH_ERROR,\n\n                    FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED,\n\n                    uint256(vars.mathErr)\n\n                );\n\n        }\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(vars.interestAccumulated, totalBorrows);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return\n\n                failOpaque(\n\n                    Error.MATH_ERROR,\n\n                    FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED,\n\n                    uint256(vars.mathErr)\n\n                );\n\n        }\n\n\n\n        (vars.mathErr, vars.totalReservesNew) = mulScalarTruncateAddUInt(\n\n            Exp({mantissa: reserveFactorMantissa}),\n\n            vars.interestAccumulated,\n\n            totalReserves\n\n        );\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return\n\n                failOpaque(\n\n                    Error.MATH_ERROR,\n\n                    FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED,\n\n                    uint256(vars.mathErr)\n\n                );\n\n        }\n\n\n\n        (vars.mathErr, vars.borrowIndexNew) = mulScalarTruncateAddUInt(\n\n            vars.simpleInterestFactor,\n\n            borrowIndex,\n\n            borrowIndex\n\n        );\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return\n\n                failOpaque(\n\n                    Error.MATH_ERROR,\n\n                    FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED,\n\n                    uint256(vars.mathErr)\n\n                );\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accrualBlockNumber = vars.currentBlockNumber;\n\n        borrowIndex = vars.borrowIndexNew;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n        totalReserves = vars.totalReservesNew;\n\n\n\n        /* We emit an AccrueInterest event */\n\n        emit AccrueInterest(vars.interestAccumulated, vars.borrowIndexNew, totalBorrows);\n\n\n\n        return uint256(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Reentrancy in CToken.accrueInterest (ComptrollerStorage.sol#1343-1454):\n\tExternal calls:\n\t- (vars.opaqueErr,vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(),totalBorrows,totalReserves) (ComptrollerStorage.sol#1347-1352)\n\tState variables written after the call(s):\n\t- accrualBlockNumber (ComptrollerStorage.sol#1443-1444)\n\t- borrowIndex (ComptrollerStorage.sol#1444-1445)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 1783,
          "vulnerability_to_line": 1865,
          "vulnerability_code": "    function borrowFresh(address payable borrower, uint256 borrowAmount) internal returns (uint256) {\n\n        /* Fail if borrow not allowed */\n\n        uint256 allowed = comptroller.borrowAllowed(address(this), borrower, borrowAmount);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.BORROW_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.BORROW_FRESHNESS_CHECK);\n\n        }\n\n\n\n        /* Fail gracefully if protocol has insufficient underlying cash */\n\n        if (getCashPrior() < borrowAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.BORROW_CASH_NOT_AVAILABLE);\n\n        }\n\n\n\n        BorrowLocalVars memory vars;\n\n\n\n        /*\n\n         * We calculate the new borrower and total borrow balances, failing on overflow:\n\n         *  accountBorrowsNew = accountBorrows + borrowAmount\n\n         *  totalBorrowsNew = totalBorrows + borrowAmount\n\n         */\n\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return\n\n                failOpaque(\n\n                    Error.MATH_ERROR,\n\n                    FailureInfo.BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\n\n                    uint256(vars.mathErr)\n\n                );\n\n        }\n\n\n\n        (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return\n\n                failOpaque(\n\n                    Error.MATH_ERROR,\n\n                    FailureInfo.BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED,\n\n                    uint256(vars.mathErr)\n\n                );\n\n        }\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return\n\n                failOpaque(\n\n                    Error.MATH_ERROR,\n\n                    FailureInfo.BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\n\n                    uint256(vars.mathErr)\n\n                );\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We invoke doTransferOut for the borrower and the borrowAmount.\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken borrowAmount less of cash.\n\n         *  If doTransferOut fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferOut(borrower, borrowAmount);\n\n        require(vars.err == Error.NO_ERROR, \"borrow transfer out failed\");\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n\n        accountBorrows[borrower].interestIndex = borrowIndex;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n\n\n        /* We emit a Borrow event */\n\n        emit Borrow(borrower, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n\n\n        /* We call the defense hook */\n\n        comptroller.borrowVerify(address(this), borrower, borrowAmount);\n\n\n\n        return uint256(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Reentrancy in CToken.borrowFresh (ComptrollerStorage.sol#1783-1865):\n\tExternal calls:\n\t- allowed = comptroller.borrowAllowed(address(this),borrower,borrowAmount) (ComptrollerStorage.sol#1785-1786)\n\tState variables written after the call(s):\n\t- accountBorrows (ComptrollerStorage.sol#1852-1853)\n\t- accountBorrows (ComptrollerStorage.sol#1853-1854)\n\t- totalBorrows (ComptrollerStorage.sol#1854-1856)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 934,
          "vulnerability_to_line": 965,
          "vulnerability_code": "    constructor(\n\n        ComptrollerInterface comptroller_,\n\n        InterestRateModel interestRateModel_,\n\n        uint256 initialExchangeRateMantissa_,\n\n        string memory name_,\n\n        string memory symbol_,\n\n        uint256 decimals_\n\n    ) internal {\n\n        // Set admin to msg.sender\n\n        admin = msg.sender;\n\n\n\n        // Set initial exchange rate\n\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n\n        require(initialExchangeRateMantissa > 0, \"Initial exchange rate must be greater than zero.\");\n\n\n\n        // Set the comptroller\n\n        uint256 err = _setComptroller(comptroller_);\n\n        require(err == uint256(Error.NO_ERROR), \"Setting comptroller failed\");\n\n\n\n        // Initialize block number and borrow index (block number mocks depend on comptroller being set)\n\n        accrualBlockNumber = getBlockNumber();\n\n        borrowIndex = mantissaOne;\n\n\n\n        // Set the interest rate model (depends on block number / borrow index)\n\n        err = _setInterestRateModelFresh(interestRateModel_);\n\n        require(err == uint256(Error.NO_ERROR), \"Setting interest rate model failed\");\n\n\n\n        name = name_;\n\n        symbol = symbol_;\n\n        decimals = decimals_;\n\n    }\n",
          "message": "Reentrancy in CToken.constructor (ComptrollerStorage.sol#934-965):\n\tExternal calls:\n\t- err = _setComptroller(comptroller_) (ComptrollerStorage.sol#950)\n\tState variables written after the call(s):\n\t- accrualBlockNumber (ComptrollerStorage.sol#954)\n\t- borrowIndex (ComptrollerStorage.sol#955)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 934,
          "vulnerability_to_line": 965,
          "vulnerability_code": "    constructor(\n\n        ComptrollerInterface comptroller_,\n\n        InterestRateModel interestRateModel_,\n\n        uint256 initialExchangeRateMantissa_,\n\n        string memory name_,\n\n        string memory symbol_,\n\n        uint256 decimals_\n\n    ) internal {\n\n        // Set admin to msg.sender\n\n        admin = msg.sender;\n\n\n\n        // Set initial exchange rate\n\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n\n        require(initialExchangeRateMantissa > 0, \"Initial exchange rate must be greater than zero.\");\n\n\n\n        // Set the comptroller\n\n        uint256 err = _setComptroller(comptroller_);\n\n        require(err == uint256(Error.NO_ERROR), \"Setting comptroller failed\");\n\n\n\n        // Initialize block number and borrow index (block number mocks depend on comptroller being set)\n\n        accrualBlockNumber = getBlockNumber();\n\n        borrowIndex = mantissaOne;\n\n\n\n        // Set the interest rate model (depends on block number / borrow index)\n\n        err = _setInterestRateModelFresh(interestRateModel_);\n\n        require(err == uint256(Error.NO_ERROR), \"Setting interest rate model failed\");\n\n\n\n        name = name_;\n\n        symbol = symbol_;\n\n        decimals = decimals_;\n\n    }\n",
          "message": "Reentrancy in CToken.constructor (ComptrollerStorage.sol#934-965):\n\tExternal calls:\n\t- err = _setComptroller(comptroller_) (ComptrollerStorage.sol#950)\n\t- err = _setInterestRateModelFresh(interestRateModel_) (ComptrollerStorage.sol#958)\n\tState variables written after the call(s):\n\t- decimals (ComptrollerStorage.sol#963)\n\t- name (ComptrollerStorage.sol#961)\n\t- symbol (ComptrollerStorage.sol#962)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 1486,
          "vulnerability_to_line": 1578,
          "vulnerability_code": "    function mintFresh(address minter, uint256 mintAmount) internal returns (uint256) {\n\n        /* Fail if mint not allowed */\n\n        uint256 allowed = comptroller.mintAllowed(address(this), minter, mintAmount);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.MINT_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.MINT_FRESHNESS_CHECK);\n\n        }\n\n\n\n        MintLocalVars memory vars;\n\n\n\n        /* Fail if checkTransferIn fails */\n\n        vars.err = checkTransferIn(minter, mintAmount);\n\n        if (vars.err != Error.NO_ERROR) {\n\n            return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_NOT_POSSIBLE);\n\n        }\n\n\n\n        /*\n\n         * We get the current exchange rate and calculate the number of cTokens to be minted:\n\n         *  mintTokens = mintAmount / exchangeRate\n\n         */\n\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_RATE_READ_FAILED, uint256(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(\n\n            mintAmount,\n\n            Exp({mantissa: vars.exchangeRateMantissa})\n\n        );\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_CALCULATION_FAILED, uint256(vars.mathErr));\n\n        }\n\n\n\n        /*\n\n         * We calculate the new total supply of cTokens and minter token balance, checking for overflow:\n\n         *  totalSupplyNew = totalSupply + mintTokens\n\n         *  accountTokensNew = accountTokens[minter] + mintTokens\n\n         */\n\n        (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return\n\n                failOpaque(\n\n                    Error.MATH_ERROR,\n\n                    FailureInfo.MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED,\n\n                    uint256(vars.mathErr)\n\n                );\n\n        }\n\n\n\n        (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return\n\n                failOpaque(\n\n                    Error.MATH_ERROR,\n\n                    FailureInfo.MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED,\n\n                    uint256(vars.mathErr)\n\n                );\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We call doTransferIn for the minter and the mintAmount\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken holds an additional mintAmount of cash.\n\n         *  If doTransferIn fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferIn(minter, mintAmount);\n\n        if (vars.err != Error.NO_ERROR) {\n\n            return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_FAILED);\n\n        }\n\n\n\n        /* We write previously calculated values into storage */\n\n        totalSupply = vars.totalSupplyNew;\n\n        accountTokens[minter] = vars.accountTokensNew;\n\n\n\n        /* We emit a Mint event, and a Transfer event */\n\n        emit Mint(minter, mintAmount, vars.mintTokens);\n\n        emit Transfer(address(this), minter, vars.mintTokens);\n\n\n\n        /* We call the defense hook */\n\n        comptroller.mintVerify(address(this), minter, mintAmount, vars.mintTokens);\n\n\n\n        return uint256(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Reentrancy in CToken.mintFresh (ComptrollerStorage.sol#1486-1578):\n\tExternal calls:\n\t- allowed = comptroller.mintAllowed(address(this),minter,mintAmount) (ComptrollerStorage.sol#1488-1489)\n\tState variables written after the call(s):\n\t- accountTokens (ComptrollerStorage.sol#1566-1568)\n\t- totalSupply (ComptrollerStorage.sol#1565-1566)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 1628,
          "vulnerability_to_line": 1755,
          "vulnerability_code": "    function redeemFresh(address payable redeemer, uint256 redeemTokensIn, uint256 redeemAmountIn)\n\n        internal\n\n        returns (uint256)\n\n    {\n\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n\n\n\n        RedeemLocalVars memory vars;\n\n\n\n        /* exchangeRate = invoke Exchange Rate Stored() */\n\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint256(vars.mathErr));\n\n        }\n\n\n\n        /* If redeemTokensIn > 0: */\n\n        if (redeemTokensIn > 0) {\n\n            /*\n\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\n\n             *  redeemTokens = redeemTokensIn\n\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n\n             */\n\n            vars.redeemTokens = redeemTokensIn;\n\n\n\n            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(\n\n                Exp({mantissa: vars.exchangeRateMantissa}),\n\n                redeemTokensIn\n\n            );\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return\n\n                    failOpaque(\n\n                        Error.MATH_ERROR,\n\n                        FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED,\n\n                        uint256(vars.mathErr)\n\n                    );\n\n            }\n\n        } else {\n\n            /*\n\n             * We get the current exchange rate and calculate the amount to be redeemed:\n\n             *  redeemTokens = redeemAmountIn / exchangeRate\n\n             *  redeemAmount = redeemAmountIn\n\n             */\n\n\n\n            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(\n\n                redeemAmountIn,\n\n                Exp({mantissa: vars.exchangeRateMantissa})\n\n            );\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return\n\n                    failOpaque(\n\n                        Error.MATH_ERROR,\n\n                        FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED,\n\n                        uint256(vars.mathErr)\n\n                    );\n\n            }\n\n\n\n            vars.redeemAmount = redeemAmountIn;\n\n        }\n\n\n\n        /* Fail if redeem not allowed */\n\n        uint256 allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);\n\n        }\n\n\n\n        /*\n\n         * We calculate the new total supply and redeemer balance, checking for underflow:\n\n         *  totalSupplyNew = totalSupply - redeemTokens\n\n         *  accountTokensNew = accountTokens[redeemer] - redeemTokens\n\n         */\n\n        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return\n\n                failOpaque(\n\n                    Error.MATH_ERROR,\n\n                    FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED,\n\n                    uint256(vars.mathErr)\n\n                );\n\n        }\n\n\n\n        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return\n\n                failOpaque(\n\n                    Error.MATH_ERROR,\n\n                    FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED,\n\n                    uint256(vars.mathErr)\n\n                );\n\n        }\n\n\n\n        /* Fail gracefully if protocol has insufficient cash */\n\n        if (getCashPrior() < vars.redeemAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We invoke doTransferOut for the redeemer and the redeemAmount.\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken has redeemAmount less of cash.\n\n         *  If doTransferOut fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferOut(redeemer, vars.redeemAmount);\n\n        require(vars.err == Error.NO_ERROR, \"redeem transfer out failed\");\n\n\n\n        /* We write previously calculated values into storage */\n\n        totalSupply = vars.totalSupplyNew;\n\n        accountTokens[redeemer] = vars.accountTokensNew;\n\n\n\n        /* We emit a Transfer event, and a Redeem event */\n\n        emit Transfer(redeemer, address(this), vars.redeemTokens);\n\n        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        /* We call the defense hook */\n\n        comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        return uint256(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Reentrancy in CToken.redeemFresh (ComptrollerStorage.sol#1628-1755):\n\tExternal calls:\n\t- allowed = comptroller.redeemAllowed(address(this),redeemer,vars.redeemTokens) (ComptrollerStorage.sol#1687-1688)\n\tState variables written after the call(s):\n\t- accountTokens (ComptrollerStorage.sol#1743-1745)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 1913,
          "vulnerability_to_line": 2007,
          "vulnerability_code": "    function repayBorrowFresh(address payer, address borrower, uint256 repayAmount) internal returns (uint256) {\n\n        /* Fail if repayBorrow not allowed */\n\n        uint256 allowed = comptroller.repayBorrowAllowed(address(this), payer, borrower, repayAmount);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REPAY_BORROW_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REPAY_BORROW_FRESHNESS_CHECK);\n\n        }\n\n\n\n        RepayBorrowLocalVars memory vars;\n\n\n\n        /* We remember the original borrowerIndex for verification purposes */\n\n        vars.borrowerIndex = accountBorrows[borrower].interestIndex;\n\n\n\n        /* We fetch the amount the borrower owes, with accumulated interest */\n\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return\n\n                failOpaque(\n\n                    Error.MATH_ERROR,\n\n                    FailureInfo.REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\n\n                    uint256(vars.mathErr)\n\n                );\n\n        }\n\n\n\n        /* If repayAmount == -1, repayAmount = accountBorrows */\n\n        if (repayAmount == uint256(-1)) {\n\n            vars.repayAmount = vars.accountBorrows;\n\n        } else {\n\n            vars.repayAmount = repayAmount;\n\n        }\n\n\n\n        /* Fail if checkTransferIn fails */\n\n        vars.err = checkTransferIn(payer, vars.repayAmount);\n\n        if (vars.err != Error.NO_ERROR) {\n\n            return fail(vars.err, FailureInfo.REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE);\n\n        }\n\n\n\n        /*\n\n         * We calculate the new borrower and total borrow balances, failing on underflow:\n\n         *  accountBorrowsNew = accountBorrows - repayAmount\n\n         *  totalBorrowsNew = totalBorrows - repayAmount\n\n         */\n\n        (vars.mathErr, vars.accountBorrowsNew) = subUInt(vars.accountBorrows, vars.repayAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return\n\n                failOpaque(\n\n                    Error.MATH_ERROR,\n\n                    FailureInfo.REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED,\n\n                    uint256(vars.mathErr)\n\n                );\n\n        }\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = subUInt(totalBorrows, vars.repayAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return\n\n                failOpaque(\n\n                    Error.MATH_ERROR,\n\n                    FailureInfo.REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\n\n                    uint256(vars.mathErr)\n\n                );\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We call doTransferIn for the payer and the repayAmount\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken holds an additional repayAmount of cash.\n\n         *  If doTransferIn fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferIn(payer, vars.repayAmount);\n\n        require(vars.err == Error.NO_ERROR, \"repay borrow transfer in failed\");\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n\n        accountBorrows[borrower].interestIndex = borrowIndex;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n\n\n        /* We emit a RepayBorrow event */\n\n        emit RepayBorrow(payer, borrower, vars.repayAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n\n\n        /* We call the defense hook */\n\n        comptroller.repayBorrowVerify(address(this), payer, borrower, vars.repayAmount, vars.borrowerIndex);\n\n\n\n        return uint256(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Reentrancy in CToken.repayBorrowFresh (ComptrollerStorage.sol#1913-2007):\n\tExternal calls:\n\t- allowed = comptroller.repayBorrowAllowed(address(this),payer,borrower,repayAmount) (ComptrollerStorage.sol#1915-1916)\n\tState variables written after the call(s):\n\t- accountBorrows (ComptrollerStorage.sol#1994-1995)\n\t- accountBorrows (ComptrollerStorage.sol#1995-1996)\n\t- totalBorrows (ComptrollerStorage.sol#1996-1998)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 2141,
          "vulnerability_to_line": 2189,
          "vulnerability_code": "    function seize(address liquidator, address borrower, uint256 seizeTokens) external nonReentrant returns (uint256) {\n\n        /* Fail if seize not allowed */\n\n        uint256 allowed = comptroller.seizeAllowed(address(this), msg.sender, liquidator, borrower, seizeTokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_SEIZE_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Fail if borrower = liquidator */\n\n        if (borrower == liquidator) {\n\n            return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER);\n\n        }\n\n\n\n        MathError mathErr;\n\n        uint256 borrowerTokensNew;\n\n        uint256 liquidatorTokensNew;\n\n\n\n        /*\n\n         * We calculate the new borrower and liquidator token balances, failing on underflow/overflow:\n\n         *  borrowerTokensNew = accountTokens[borrower] - seizeTokens\n\n         *  liquidatorTokensNew = accountTokens[liquidator] + seizeTokens\n\n         */\n\n        (mathErr, borrowerTokensNew) = subUInt(accountTokens[borrower], seizeTokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED, uint256(mathErr));\n\n        }\n\n\n\n        (mathErr, liquidatorTokensNew) = addUInt(accountTokens[liquidator], seizeTokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED, uint256(mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accountTokens[borrower] = borrowerTokensNew;\n\n        accountTokens[liquidator] = liquidatorTokensNew;\n\n\n\n        /* Emit a Transfer event */\n\n        emit Transfer(borrower, liquidator, seizeTokens);\n\n\n\n        /* We call the defense hook */\n\n        comptroller.seizeVerify(address(this), msg.sender, liquidator, borrower, seizeTokens);\n\n\n\n        return uint256(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Reentrancy in CToken.seize (ComptrollerStorage.sol#2141-2189):\n\tExternal calls:\n\t- allowed = comptroller.seizeAllowed(address(this),msg.sender,liquidator,borrower,seizeTokens) (ComptrollerStorage.sol#2143-2144)\n\tState variables written after the call(s):\n\t- accountTokens (ComptrollerStorage.sol#2177-2178)\n\t- accountTokens (ComptrollerStorage.sol#2178-2180)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 975,
          "vulnerability_to_line": 1036,
          "vulnerability_code": "    function transferTokens(address spender, address src, address dst, uint256 tokens) internal returns (uint256) {\n\n        /* Fail if transfer not allowed */\n\n        uint256 allowed = comptroller.transferAllowed(address(this), src, dst, tokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.TRANSFER_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Do not allow self-transfers */\n\n        if (src == dst) {\n\n            return fail(Error.BAD_INPUT, FailureInfo.TRANSFER_NOT_ALLOWED);\n\n        }\n\n\n\n        /* Get the allowance, infinite for the account owner */\n\n        uint256 startingAllowance = 0;\n\n        if (spender == src) {\n\n            startingAllowance = uint256(-1);\n\n        } else {\n\n            startingAllowance = transferAllowances[src][spender];\n\n        }\n\n\n\n        /* Do the calculations, checking for {under,over}flow */\n\n        MathError mathErr;\n\n        uint256 allowanceNew;\n\n        uint256 srcTokensNew;\n\n        uint256 dstTokensNew;\n\n\n\n        (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ALLOWED);\n\n        }\n\n\n\n        (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ENOUGH);\n\n        }\n\n\n\n        (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_TOO_MUCH);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        accountTokens[src] = srcTokensNew;\n\n        accountTokens[dst] = dstTokensNew;\n\n\n\n        /* Eat some of the allowance (if necessary) */\n\n        if (startingAllowance != uint256(-1)) {\n\n            transferAllowances[src][spender] = allowanceNew;\n\n        }\n\n\n\n        /* We emit a Transfer event */\n\n        emit Transfer(src, dst, tokens);\n\n\n\n        /* We call the defense hook (which checks for under-collateralization) */\n\n        comptroller.transferVerify(address(this), src, dst, tokens);\n\n\n\n        return uint256(Error.NO_ERROR);\n\n    }\n",
          "message": "Reentrancy in CToken.transferTokens (ComptrollerStorage.sol#975-1036):\n\tExternal calls:\n\t- allowed = comptroller.transferAllowed(address(this),src,dst,tokens) (ComptrollerStorage.sol#977)\n\tState variables written after the call(s):\n\t- accountTokens (ComptrollerStorage.sol#1020)\n\t- accountTokens (ComptrollerStorage.sol#1021)\n\t- transferAllowances (ComptrollerStorage.sol#1025)\n"
        },
        {
          "name": "constable-states",
          "vulnerability_from_line": 2518,
          "vulnerability_to_line": 2521,
          "vulnerability_code": "    uint256 public closeFactorMantissa;\n\n\n\n    /**\n",
          "message": "ComptrollerV1Storage.closeFactorMantissa should be constant (ComptrollerStorage.sol#2518-2521)\nComptrollerV1Storage.liquidationIncentiveMantissa should be constant (ComptrollerStorage.sol#2523-2526)\nComptrollerV1Storage.maxAssets should be constant (ComptrollerStorage.sol#2528-2531)\nUnitrollerAdminStorage.admin should be constant (ComptrollerStorage.sol#2491-2494)\nUnitrollerAdminStorage.comptrollerImplementation should be constant (ComptrollerStorage.sol#2501-2504)\nUnitrollerAdminStorage.pendingAdmin should be constant (ComptrollerStorage.sol#2496-2499)\nUnitrollerAdminStorage.pendingComptrollerImplementation should be constant (ComptrollerStorage.sol#2506-2509)\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 2388,
          "vulnerability_to_line": 2399,
          "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint256) {\n\n        uint256 error = accrueInterest();\n\n        if (error != uint256(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n\n        return _setInterestRateModelFresh(newInterestRateModel);\n\n    }\n\n\n\n    /**\n",
          "message": "CToken._setInterestRateModel (ComptrollerStorage.sol#2388-2399) should be declared external\n"
        },
        {
          "name": "solc-version",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.8;\n",
          "message": "Detected issues with version pragma in ComptrollerStorage.sol:\n\t- pragma solidity^0.5.8 (ComptrollerStorage.sol#3): it allows old versions\n\t- pragma solidity^0.5.8 (ComptrollerStorage.sol#64): it allows old versions\n\t- pragma solidity^0.5.8 (ComptrollerStorage.sol#146): it allows old versions\n\t- pragma solidity^0.5.8 (ComptrollerStorage.sol#369): it allows old versions\n\t- pragma solidity^0.5.8 (ComptrollerStorage.sol#576): it allows old versions\n\t- pragma solidity^0.5.8 (ComptrollerStorage.sol#611-612): it allows old versions\n\t- pragma solidity^0.5.8 (ComptrollerStorage.sol#694-695): it allows old versions\n\t- pragma solidity^0.5.8 (ComptrollerStorage.sol#726-727): it allows old versions\n\t- pragma solidity^0.5.8 (ComptrollerStorage.sol#2466-2468): it allows old versions\n\t- pragma solidity^0.5.8 (ComptrollerStorage.sol#2485-2487): it allows old versions\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 156,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint256 constant expScale = 1e18;\n",
          "message": "Constant 'Exponential.expScale' (ComptrollerStorage.sol#156) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 157,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint256 constant halfExpScale = expScale / 2;\n",
          "message": "Constant 'Exponential.halfExpScale' (ComptrollerStorage.sol#157) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 158,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint256 constant mantissaOne = expScale;\n",
          "message": "Constant 'Exponential.mantissaOne' (ComptrollerStorage.sol#158) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 2199,
          "vulnerability_to_line": 2217,
          "vulnerability_code": "    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint256) {\n\n        // Check caller = admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);\n\n        }\n\n\n\n        // Save current value, if any, for inclusion in log\n\n        address oldPendingAdmin = pendingAdmin;\n\n\n\n        // Store pendingAdmin with value newPendingAdmin\n\n        pendingAdmin = newPendingAdmin;\n\n\n\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\n\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n\n\n\n        return uint256(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Function 'CToken._setPendingAdmin' (ComptrollerStorage.sol#2199-2217) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 2222,
          "vulnerability_to_line": 2244,
          "vulnerability_code": "    function _acceptAdmin() external returns (uint256) {\n\n        // Check caller is pendingAdmin and pendingAdmin \u2260 address(0)\n\n        if (msg.sender != pendingAdmin || msg.sender == address(0)) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);\n\n        }\n\n\n\n        // Save current values for inclusion in log\n\n        address oldAdmin = admin;\n\n        address oldPendingAdmin = pendingAdmin;\n\n\n\n        // Store admin with value pendingAdmin\n\n        admin = pendingAdmin;\n\n\n\n        // Clear the pending value\n\n        pendingAdmin = address(0);\n\n\n\n        emit NewAdmin(oldAdmin, admin);\n\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\n\n\n\n        return uint256(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Function 'CToken._acceptAdmin' (ComptrollerStorage.sol#2222-2244) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 2249,
          "vulnerability_to_line": 2268,
          "vulnerability_code": "    function _setComptroller(ComptrollerInterface newComptroller) public returns (uint256) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COMPTROLLER_OWNER_CHECK);\n\n        }\n\n\n\n        ComptrollerInterface oldComptroller = comptroller;\n\n        // Ensure invoke comptroller.isComptroller() returns true\n\n        require(newComptroller.isComptroller(), \"marker method returned false\");\n\n\n\n        // Set market's comptroller to newComptroller\n\n        comptroller = newComptroller;\n\n\n\n        // Emit NewComptroller(oldComptroller, newComptroller)\n\n        emit NewComptroller(oldComptroller, newComptroller);\n\n\n\n        return uint256(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Function 'CToken._setComptroller' (ComptrollerStorage.sol#2249-2268) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 2273,
          "vulnerability_to_line": 2283,
          "vulnerability_code": "    function _setReserveFactor(uint256 newReserveFactorMantissa) external nonReentrant returns (uint256) {\n\n        uint256 error = accrueInterest();\n\n        if (error != uint256(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.\n\n            return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.\n\n        return _setReserveFactorFresh(newReserveFactorMantissa);\n\n    }\n\n\n",
          "message": "Function 'CToken._setReserveFactor' (ComptrollerStorage.sol#2273-2283) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 2288,
          "vulnerability_to_line": 2313,
          "vulnerability_code": "    function _setReserveFactorFresh(uint256 newReserveFactorMantissa) internal returns (uint256) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_RESERVE_FACTOR_ADMIN_CHECK);\n\n        }\n\n\n\n        // Verify market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            // TODO: static_assert + no error code?\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_RESERVE_FACTOR_FRESH_CHECK);\n\n        }\n\n\n\n        // Check newReserveFactor \u2264 maxReserveFactor\n\n        if (newReserveFactorMantissa > reserveFactorMaxMantissa) {\n\n            return fail(Error.BAD_INPUT, FailureInfo.SET_RESERVE_FACTOR_BOUNDS_CHECK);\n\n        }\n\n\n\n        uint256 oldReserveFactorMantissa = reserveFactorMantissa;\n\n        reserveFactorMantissa = newReserveFactorMantissa;\n\n\n\n        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);\n\n\n\n        return uint256(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Function 'CToken._setReserveFactorFresh' (ComptrollerStorage.sol#2288-2313) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 2318,
          "vulnerability_to_line": 2328,
          "vulnerability_code": "    function _reduceReserves(uint256 reduceAmount) external nonReentrant returns (uint256) {\n\n        uint256 error = accrueInterest();\n\n        if (error != uint256(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n\n            return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.\n\n        return _reduceReservesFresh(reduceAmount);\n\n    }\n\n\n",
          "message": "Function 'CToken._reduceReserves' (ComptrollerStorage.sol#2318-2328) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 2334,
          "vulnerability_to_line": 2383,
          "vulnerability_code": "    function _reduceReservesFresh(uint256 reduceAmount) internal returns (uint256) {\n\n        Error err;\n\n        // totalReserves - reduceAmount\n\n        uint256 totalReservesNew;\n\n\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.REDUCE_RESERVES_ADMIN_CHECK);\n\n        }\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            // TODO: static_assert + no error code?\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDUCE_RESERVES_FRESH_CHECK);\n\n        }\n\n\n\n        // Fail gracefully if protocol has insufficient underlying cash\n\n        if (getCashPrior() < reduceAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDUCE_RESERVES_CASH_NOT_AVAILABLE);\n\n        }\n\n\n\n        // Check reduceAmount \u2264 reserves[n] (totalReserves)\n\n        // TODO: I'm following the spec literally here but I think we should we just use SafeMath instead and fail on an error (which would be underflow)\n\n        if (reduceAmount > totalReserves) {\n\n            return fail(Error.BAD_INPUT, FailureInfo.REDUCE_RESERVES_VALIDATION);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        totalReservesNew = totalReserves - reduceAmount;\n\n        // We checked reduceAmount <= totalReserves above, so this should never revert.\n\n        require(totalReservesNew <= totalReserves, \"reduce reserves unexpected underflow\");\n\n\n\n        // Store reserves[n+1] = reserves[n] - reduceAmount\n\n        totalReserves = totalReservesNew;\n\n\n\n        // invoke doTransferOut(reduceAmount, admin)\n\n        err = doTransferOut(admin, reduceAmount);\n\n        // we revert on the failure of this command\n\n        require(err == Error.NO_ERROR, \"reduce reserves transfer out failed\");\n\n\n\n        emit ReservesReduced(admin, reduceAmount, totalReservesNew);\n\n\n\n        return uint256(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
          "message": "Function 'CToken._reduceReservesFresh' (ComptrollerStorage.sol#2334-2383) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 2388,
          "vulnerability_to_line": 2399,
          "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint256) {\n\n        uint256 error = accrueInterest();\n\n        if (error != uint256(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n\n        return _setInterestRateModelFresh(newInterestRateModel);\n\n    }\n\n\n\n    /**\n",
          "message": "Function 'CToken._setInterestRateModel' (ComptrollerStorage.sol#2388-2399) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 2404,
          "vulnerability_to_line": 2434,
          "vulnerability_code": "    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint256) {\n\n        // Used to store old model for use in the event that is emitted on success\n\n        InterestRateModel oldInterestRateModel;\n\n\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);\n\n        }\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            // TODO: static_assert + no error code?\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);\n\n        }\n\n\n\n        // Track the market's current interest rate model\n\n        oldInterestRateModel = interestRateModel;\n\n\n\n        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true\n\n        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n\n\n\n        // Set the interest rate model to newInterestRateModel\n\n        interestRateModel = newInterestRateModel;\n\n\n\n        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)\n\n        emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);\n\n\n\n        return uint256(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Function 'CToken._setInterestRateModelFresh' (ComptrollerStorage.sol#2404-2434) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 742,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bool public constant isCToken = true;\n",
          "message": "Constant 'CToken.isCToken' (ComptrollerStorage.sol#742) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 762,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint256 constant borrowRateMaxMantissa = 5e14;\n",
          "message": "Constant 'CToken.borrowRateMaxMantissa' (ComptrollerStorage.sol#762) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 767,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint256 constant reserveFactorMaxMantissa = 1e18;\n",
          "message": "Constant 'CToken.reserveFactorMaxMantissa' (ComptrollerStorage.sol#767) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        }
      ]
    },
    "smartcheck": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "SOLIDITY_ERC20_APPROVE",
          "vulnerability_from_line": 1066,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function approve(address spender, uint256 amount) external returns (bool) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.8;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 64,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.8;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 146,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.8;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 369,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.8;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 576,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.8;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 611,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.8;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 694,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.8;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 726,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.8;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 2466,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.8;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 2485,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.8;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 586,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint256 private _guardCounter;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 81,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function mulUInt(uint256 a, uint256 b) internal pure returns (MathError, uint256) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 98,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function divUInt(uint256 a, uint256 b) internal pure returns (MathError, uint256) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 109,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function subUInt(uint256 a, uint256 b) internal pure returns (MathError, uint256) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 120,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function addUInt(uint256 a, uint256 b) internal pure returns (MathError, uint256) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 133,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function addThenSubUInt(uint256 a, uint256 b, uint256 c) internal pure returns (MathError, uint256) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 169,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getExp(uint256 num, uint256 denom) internal pure returns (MathError, Exp memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 186,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function addExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 195,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function subExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 204,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function mulScalar(Exp memory a, uint256 scalar) internal pure returns (MathError, Exp memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 216,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function mulScalarTruncate(Exp memory a, uint256 scalar) internal pure returns (MathError, uint256) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 231,
          "vulnerability_to_line": null,
          "vulnerability_code": "        returns (MathError, uint256)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 244,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function divScalar(Exp memory a, uint256 scalar) internal pure returns (MathError, Exp memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 256,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function divScalarByExp(uint256 scalar, Exp memory divisor) internal pure returns (MathError, Exp memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 276,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function divScalarByExpTruncate(uint256 scalar, Exp memory divisor) internal pure returns (MathError, uint256) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 288,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function mulExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 312,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function mulExp(uint256 a, uint256 b) internal pure returns (MathError, Exp memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 319,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function mulExp3(Exp memory a, Exp memory b, Exp memory c) internal pure returns (MathError, Exp memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 332,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function divExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 689,
          "vulnerability_to_line": null,
          "vulnerability_code": "        returns (uint256, uint256);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 714,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getBorrowRate(uint256 cash, uint256 borrows, uint256 reserves) external view returns (uint256, uint256);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 1111,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getAccountSnapshot(address account) external view returns (uint256, uint256, uint256, uint256) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 1229,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint256) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 1286,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function exchangeRateStoredInternal() internal view returns (MathError, uint256) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1628,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function redeemFresh(address payable redeemer, uint256 redeemTokensIn, uint256 redeemAmountIn)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 156,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint256 constant expScale = 1e18;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 157,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint256 constant halfExpScale = expScale / 2;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 158,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint256 constant mantissaOne = expScale;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 762,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint256 constant borrowRateMaxMantissa = 5e14;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 767,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint256 constant reserveFactorMaxMantissa = 1e18;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 827,
          "vulnerability_to_line": null,
          "vulnerability_code": "    mapping(address => uint256) accountTokens;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 832,
          "vulnerability_to_line": null,
          "vulnerability_code": "    mapping(address => mapping(address => uint256)) transferAllowances;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 847,
          "vulnerability_to_line": null,
          "vulnerability_code": "    mapping(address => BorrowSnapshot) accountBorrows;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1628,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function redeemFresh(address payable redeemer, uint256 redeemTokensIn, uint256 redeemAmountIn)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1628,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function redeemFresh(address payable redeemer, uint256 redeemTokensIn, uint256 redeemAmountIn)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1628,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function redeemFresh(address payable redeemer, uint256 redeemTokensIn, uint256 redeemAmountIn)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1630,
          "vulnerability_to_line": null,
          "vulnerability_code": "        returns (uint256)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1632,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1634,
          "vulnerability_to_line": null,
          "vulnerability_code": "        RedeemLocalVars memory vars;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1637,
          "vulnerability_to_line": null,
          "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1637,
          "vulnerability_to_line": null,
          "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1637,
          "vulnerability_to_line": null,
          "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1637,
          "vulnerability_to_line": null,
          "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1638,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (vars.mathErr != MathError.NO_ERROR) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1638,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (vars.mathErr != MathError.NO_ERROR) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1639,
          "vulnerability_to_line": null,
          "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint256(vars.mathErr));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1639,
          "vulnerability_to_line": null,
          "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint256(vars.mathErr));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1639,
          "vulnerability_to_line": null,
          "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint256(vars.mathErr));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1639,
          "vulnerability_to_line": null,
          "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint256(vars.mathErr));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1639,
          "vulnerability_to_line": null,
          "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint256(vars.mathErr));\n",
          "message": null
        }
      ]
    },
    "oyente": {
      "successfull_analysis": false,
      "errors": [
        "exception (IndexError: pop from empty list)"
      ],
      "vulnerability_findings": []
    },
    "mythril": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "Exception State (SWC 110)",
          "vulnerability_from_line": 2533,
          "vulnerability_to_line": null,
          "vulnerability_code": "    mapping(address => CToken[]) public accountAssets;\n",
          "message": "An assertion violation was triggered.\nIt is possible to trigger an assertion violation. Note that Solidity assert() statements should only be used to check invariants. Review the transaction trace generated for this issue and either make sure your program logic is correct, or use require() instead of assert() if your goal is to constrain user inputs or enforce preconditions. Remember to validate inputs from both callers (for instance, via passed arguments) and callees (for instance, via return values).\nClassification: SWC-110"
        }
      ]
    },
    "osiris": {
      "successfull_analysis": false,
      "errors": [
        "Solidity compilation failed"
      ],
      "vulnerability_findings": []
    }
  }
}