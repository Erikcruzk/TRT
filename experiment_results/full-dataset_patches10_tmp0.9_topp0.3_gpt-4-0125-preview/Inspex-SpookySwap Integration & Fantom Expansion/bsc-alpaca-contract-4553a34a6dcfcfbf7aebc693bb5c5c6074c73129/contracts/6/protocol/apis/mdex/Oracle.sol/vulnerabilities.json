{
  "smartbugs_completed": true,
  "analyzer_results": {
    "semgrep": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 318,
          "vulnerability_to_line": null,
          "vulnerability_code": "  constructor(address factory_) public {\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 319,
          "vulnerability_to_line": null,
          "vulnerability_code": "    factory = factory_;\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 320,
          "vulnerability_to_line": null,
          "vulnerability_code": "  }\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 197,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require((z = x + y) >= x, \"ds-math-add-overflow\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 201,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require((z = x - y) <= x, \"ds-math-sub-underflow\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 205,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require(y == 0 || (z = x * y) / y == x, \"ds-math-mul-overflow\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 236,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require(x != 0, \"FixedPoint: DIV_BY_ZERO\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 244,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require(y == 0 || (z = uint256(self._x) * y) / y == uint256(self._x), \"FixedPoint: MULTIPLICATION_OVERFLOW\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 251,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require(denominator > 0, \"FixedPoint: DIV_BY_ZERO\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 327,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require(timeElapsed >= CYCLE, \"MDEXOracle: PERIOD_NOT_ELAPSED\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 244,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require(y == 0 || (z = uint256(self._x) * y) / y == uint256(self._x), \"FixedPoint: MULTIPLICATION_OVERFLOW\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        }
      ]
    },
    "slither": {
      "successfull_analysis": true,
      "errors": [
        "EXIT_CODE_24"
      ],
      "vulnerability_findings": [
        {
          "name": "uninitialized-local",
          "vulnerability_from_line": 243,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint256 z;\n",
          "message": "z in FixedPoint.mul (Oracle.sol#243) is a local variable never initialiazed\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 322,
          "vulnerability_to_line": 332,
          "vulnerability_code": "  function update(address tokenA, address tokenB) external {\n\n    address pair = IMdexFactory(factory).pairFor(tokenA, tokenB);\n\n\n\n    Observation storage observation = pairObservations[pair];\n\n    uint256 timeElapsed = block.timestamp - observation.timestamp;\n\n    require(timeElapsed >= CYCLE, \"MDEXOracle: PERIOD_NOT_ELAPSED\");\n\n    (uint256 price0Cumulative, uint256 price1Cumulative, ) = MdexOracleLibrary.currentCumulativePrices(pair);\n\n    observation.timestamp = block.timestamp;\n\n    observation.price0Cumulative = price0Cumulative;\n\n    observation.price1Cumulative = price1Cumulative;\n",
          "message": "Reentrancy in Oracle.update (Oracle.sol#322-332):\n\tExternal calls:\n\t- pair = IMdexFactory(factory).pairFor(tokenA,tokenB) (Oracle.sol#323)\n\tState variables written after the call(s):\n\t- pairObservations (Oracle.sol#329)\n\t- pairObservations (Oracle.sol#330)\n\t- pairObservations (Oracle.sol#331)\n"
        },
        {
          "name": "timestamp",
          "vulnerability_from_line": 322,
          "vulnerability_to_line": 332,
          "vulnerability_code": "  function update(address tokenA, address tokenB) external {\n\n    address pair = IMdexFactory(factory).pairFor(tokenA, tokenB);\n\n\n\n    Observation storage observation = pairObservations[pair];\n\n    uint256 timeElapsed = block.timestamp - observation.timestamp;\n\n    require(timeElapsed >= CYCLE, \"MDEXOracle: PERIOD_NOT_ELAPSED\");\n\n    (uint256 price0Cumulative, uint256 price1Cumulative, ) = MdexOracleLibrary.currentCumulativePrices(pair);\n\n    observation.timestamp = block.timestamp;\n\n    observation.price0Cumulative = price0Cumulative;\n\n    observation.price1Cumulative = price1Cumulative;\n",
          "message": "Oracle.update (Oracle.sol#322-332) uses timestamp for comparisons\n\tDangerous comparisons:\n\t- require(bool,string)(timeElapsed >= CYCLE,MDEXOracle: PERIOD_NOT_ELAPSED) (Oracle.sol#327)\n"
        },
        {
          "name": "pragma",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity 0.6.6;\n",
          "message": "Different versions of Solidity is used in Oracle.sol:\n\t- Version used: ['0.6.6', '=0.6.6']\n\t- Oracle.sol#3 declares pragma solidity0.6.6\n\t- Oracle.sol#102 declares pragma solidity0.6.6\n\t- Oracle.sol#192 declares pragma solidity=0.6.6\n"
        },
        {
          "name": "solc-version",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity 0.6.6;\n",
          "message": "Detected issues with version pragma in Oracle.sol:\n\t- pragma solidity0.6.6 (Oracle.sol#3): it allows old versions\n\t- pragma solidity0.6.6 (Oracle.sol#102): it allows old versions\n\t- pragma solidity=0.6.6 (Oracle.sol#192): it allows old versions\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 31,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function DOMAIN_SEPARATOR() external view returns (bytes32);\n",
          "message": "Function 'IMdexPair.DOMAIN_SEPARATOR' (Oracle.sol#31) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 33,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function PERMIT_TYPEHASH() external pure returns (bytes32);\n",
          "message": "Function 'IMdexPair.PERMIT_TYPEHASH' (Oracle.sol#33) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 59,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function MINIMUM_LIQUIDITY() external pure returns (uint256);\n",
          "message": "Function 'IMdexPair.MINIMUM_LIQUIDITY' (Oracle.sol#59) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 97,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function initialize(address, address) external;\n",
          "message": "Parameter '' of IMdexPair.initialize (Oracle.sol#97) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 97,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function initialize(address, address) external;\n",
          "message": "Parameter '_scope_0' of IMdexPair.initialize (Oracle.sol#97) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 107,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function FEE_RATE_DENOMINATOR() external view returns (uint256);\n",
          "message": "Function 'IMdexFactory.FEE_RATE_DENOMINATOR' (Oracle.sol#107) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 119,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function pairFeeToRate(address) external view returns (uint256);\n",
          "message": "Parameter '' of IMdexFactory.pairFeeToRate (Oracle.sol#119) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 121,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function pairFees(address) external view returns (uint256);\n",
          "message": "Parameter '' of IMdexFactory.pairFees (Oracle.sol#121) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 125,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function allPairs(uint256) external view returns (address pair);\n",
          "message": "Parameter '' of IMdexFactory.allPairs (Oracle.sol#125) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 131,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function setFeeTo(address) external;\n",
          "message": "Parameter '' of IMdexFactory.setFeeTo (Oracle.sol#131) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 133,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function setFeeToSetter(address) external;\n",
          "message": "Parameter '' of IMdexFactory.setFeeToSetter (Oracle.sol#133) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 135,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function addPair(address) external returns (bool);\n",
          "message": "Parameter '' of IMdexFactory.addPair (Oracle.sol#135) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 137,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function delPair(address) external returns (bool);\n",
          "message": "Parameter '' of IMdexFactory.delPair (Oracle.sol#137) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 145,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function setFeeRateNumerator(uint256) external;\n",
          "message": "Parameter '' of IMdexFactory.setFeeRateNumerator (Oracle.sol#145) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 149,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function setDefaultFeeToRate(uint256) external;\n",
          "message": "Parameter '' of IMdexFactory.setDefaultFeeToRate (Oracle.sol#149) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 153,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function getPairFees(address) external view returns (uint256);\n",
          "message": "Parameter '' of IMdexFactory.getPairFees (Oracle.sol#153) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 155,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function getPairRate(address) external view returns (uint256);\n",
          "message": "Parameter '' of IMdexFactory.getPairRate (Oracle.sol#155) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 212,
          "vulnerability_to_line": 214,
          "vulnerability_code": "  struct uq112x112 {\n\n    uint224 _x;\n",
          "message": "Struct 'FixedPoint.uq112x112' (Oracle.sol#212-214) is not in CapWords\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 218,
          "vulnerability_to_line": 220,
          "vulnerability_code": "  struct uq144x112 {\n\n    uint256 _x;\n",
          "message": "Struct 'FixedPoint.uq144x112' (Oracle.sol#218-220) is not in CapWords\n"
        }
      ]
    },
    "smartcheck": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 222,
          "vulnerability_to_line": null,
          "vulnerability_code": "  uint8 private constant RESOLUTION = 112;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SAFEMATH",
          "vulnerability_from_line": 304,
          "vulnerability_to_line": null,
          "vulnerability_code": "  using SafeMath for uint256;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 70,
          "vulnerability_to_line": null,
          "vulnerability_code": "    returns (\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 84,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function burn(address to) external returns (uint256 amount0, uint256 amount1);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 157,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function sortTokens(address tokenA, address tokenB) external pure returns (address token0, address token1);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 161,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function getReserves(address tokenA, address tokenB) external view returns (uint256 reserveA, uint256 reserveB);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 278,
          "vulnerability_to_line": null,
          "vulnerability_code": "    returns (\n",
          "message": null
        }
      ]
    },
    "oyente": {
      "successfull_analysis": false,
      "errors": [
        "exception (RuntimeError: Source map error, unknown name(SHR) or instr_name(INVALID))"
      ],
      "vulnerability_findings": []
    },
    "mythril": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "Integer Arithmetic Bugs (SWC 101)",
          "vulnerability_from_line": 326,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint256 timeElapsed = block.timestamp - observation.timestamp;\n",
          "message": "The arithmetic operator can underflow.\nIt is possible to cause an integer overflow or underflow in the arithmetic operation. \nClassification: SWC-101"
        },
        {
          "name": "Dependence on predictable environment variable (SWC 116)",
          "vulnerability_from_line": 327,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require(timeElapsed >= CYCLE, \"MDEXOracle: PERIOD_NOT_ELAPSED\");\n",
          "message": "A control flow decision is made based on The block.timestamp environment variable.\nThe block.timestamp environment variable is used to determine a control flow decision. Note that the values of variables like coinbase, gaslimit, block number and timestamp are predictable and can be manipulated by a malicious miner. Also keep in mind that attackers know hashes of earlier blocks. Don't use any of those environment variables as sources of randomness and be aware that use of these variables introduces a certain level of trust into miners.\nClassification: SWC-116"
        },
        {
          "name": "Multiple Calls in a Single Transaction (SWC 113)",
          "vulnerability_from_line": 285,
          "vulnerability_to_line": null,
          "vulnerability_code": "    price0Cumulative = IMdexPair(pair).price0CumulativeLast();\n",
          "message": "Multiple calls are executed in the same transaction.\nThis call is executed following another call within the same transaction. It is possible that the call never gets executed if a prior call fails permanently. This might be caused intentionally by a malicious callee. If possible, refactor the code such that each transaction only executes one external call or make sure that all callees can be trusted (i.e. they\u2019re part of your own codebase).\nClassification: SWC-113"
        },
        {
          "name": "Multiple Calls in a Single Transaction (SWC 113)",
          "vulnerability_from_line": 285,
          "vulnerability_to_line": null,
          "vulnerability_code": "    price0Cumulative = IMdexPair(pair).price0CumulativeLast();\n",
          "message": "Multiple calls are executed in the same transaction.\nThis call is executed following another call within the same transaction. It is possible that the call never gets executed if a prior call fails permanently. This might be caused intentionally by a malicious callee. If possible, refactor the code such that each transaction only executes one external call or make sure that all callees can be trusted (i.e. they\u2019re part of your own codebase).\nClassification: SWC-113"
        },
        {
          "name": "Multiple Calls in a Single Transaction (SWC 113)",
          "vulnerability_from_line": 286,
          "vulnerability_to_line": null,
          "vulnerability_code": "    price1Cumulative = IMdexPair(pair).price1CumulativeLast();\n",
          "message": "Multiple calls are executed in the same transaction.\nThis call is executed following another call within the same transaction. It is possible that the call never gets executed if a prior call fails permanently. This might be caused intentionally by a malicious callee. If possible, refactor the code such that each transaction only executes one external call or make sure that all callees can be trusted (i.e. they\u2019re part of your own codebase).\nClassification: SWC-113"
        },
        {
          "name": "Multiple Calls in a Single Transaction (SWC 113)",
          "vulnerability_from_line": 289,
          "vulnerability_to_line": null,
          "vulnerability_code": "    (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast) = IMdexPair(pair).getReserves();\n",
          "message": "Multiple calls are executed in the same transaction.\nThis call is executed following another call within the same transaction. It is possible that the call never gets executed if a prior call fails permanently. This might be caused intentionally by a malicious callee. If possible, refactor the code such that each transaction only executes one external call or make sure that all callees can be trusted (i.e. they\u2019re part of your own codebase).\nClassification: SWC-113"
        },
        {
          "name": "Dependence on predictable environment variable (SWC 116)",
          "vulnerability_from_line": 290,
          "vulnerability_to_line": null,
          "vulnerability_code": "    if (blockTimestampLast != blockTimestamp) {\n",
          "message": "A control flow decision is made based on The block.timestamp environment variable.\nThe block.timestamp environment variable is used to determine a control flow decision. Note that the values of variables like coinbase, gaslimit, block number and timestamp are predictable and can be manipulated by a malicious miner. Also keep in mind that attackers know hashes of earlier blocks. Don't use any of those environment variables as sources of randomness and be aware that use of these variables introduces a certain level of trust into miners.\nClassification: SWC-116"
        },
        {
          "name": "Integer Arithmetic Bugs (SWC 101)",
          "vulnerability_from_line": 292,
          "vulnerability_to_line": null,
          "vulnerability_code": "      uint32 timeElapsed = blockTimestamp - blockTimestampLast;\n",
          "message": "The arithmetic operator can underflow.\nIt is possible to cause an integer overflow or underflow in the arithmetic operation. \nClassification: SWC-101"
        },
        {
          "name": "Integer Arithmetic Bugs (SWC 101)",
          "vulnerability_from_line": 295,
          "vulnerability_to_line": null,
          "vulnerability_code": "      price0Cumulative += uint256(FixedPoint.fraction(reserve1, reserve0)._x) * timeElapsed;\n",
          "message": "The arithmetic operator can overflow.\nIt is possible to cause an integer overflow or underflow in the arithmetic operation. \nClassification: SWC-101"
        },
        {
          "name": "Dependence on predictable environment variable (SWC 116)",
          "vulnerability_from_line": 342,
          "vulnerability_to_line": null,
          "vulnerability_code": "      FixedPoint.uq112x112(uint224((priceCumulativeEnd - priceCumulativeStart) / timeElapsed));\n",
          "message": "A control flow decision is made based on The block.timestamp environment variable.\nThe block.timestamp environment variable is used to determine a control flow decision. Note that the values of variables like coinbase, gaslimit, block number and timestamp are predictable and can be manipulated by a malicious miner. Also keep in mind that attackers know hashes of earlier blocks. Don't use any of those environment variables as sources of randomness and be aware that use of these variables introduces a certain level of trust into miners.\nClassification: SWC-116"
        },
        {
          "name": "Exception State (SWC 110)",
          "vulnerability_from_line": null,
          "vulnerability_to_line": null,
          "vulnerability_code": null,
          "message": "An assertion violation was triggered.\nIt is possible to trigger an assertion violation. Note that Solidity assert() statements should only be used to check invariants. Review the transaction trace generated for this issue and either make sure your program logic is correct, or use require() instead of assert() if your goal is to constrain user inputs or enforce preconditions. Remember to validate inputs from both callers (for instance, via passed arguments) and callees (for instance, via return values). This issue is reported for internal compiler generated code.\nClassification: SWC-110"
        },
        {
          "name": "Dependence on predictable environment variable (SWC 116)",
          "vulnerability_from_line": 244,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require(y == 0 || (z = uint256(self._x) * y) / y == uint256(self._x), \"FixedPoint: MULTIPLICATION_OVERFLOW\");\n",
          "message": "A control flow decision is made based on The block.timestamp environment variable.\nThe block.timestamp environment variable is used to determine a control flow decision. Note that the values of variables like coinbase, gaslimit, block number and timestamp are predictable and can be manipulated by a malicious miner. Also keep in mind that attackers know hashes of earlier blocks. Don't use any of those environment variables as sources of randomness and be aware that use of these variables introduces a certain level of trust into miners.\nClassification: SWC-116"
        }
      ]
    },
    "osiris": {
      "successfull_analysis": false,
      "errors": [
        "Solidity compilation failed"
      ],
      "vulnerability_findings": []
    }
  }
}