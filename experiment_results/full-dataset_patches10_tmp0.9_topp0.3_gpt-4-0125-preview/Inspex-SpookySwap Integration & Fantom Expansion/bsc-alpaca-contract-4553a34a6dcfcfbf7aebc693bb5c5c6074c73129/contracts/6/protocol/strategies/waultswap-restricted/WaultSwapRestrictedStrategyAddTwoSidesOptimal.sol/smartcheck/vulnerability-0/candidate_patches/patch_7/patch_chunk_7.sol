function optimalDeposit(
    uint256 amtA,
    uint256 amtB,
    uint256 resA,
    uint256 resB
) internal pure returns (uint256 swapAmt, bool isReversed) {
    if (amtA.mul(resB) >= amtB.mul(resA)) {
        // Perform the multiplication second to prevent division by zero error
        uint256 c = amtA.mul(resB).sub(amtB.mul(resA)).mul(1000);
        swapAmt = _optimalDepositA(amtA, amtB, resA, resB, c);
        isReversed = false;
    } else {
        // Perform the multiplication second to prevent division by zero error
        uint256 c = amtB.mul(resA).sub(amtA.mul(resB)).mul(1000);
        swapAmt = _optimalDepositA(amtB, amtA, resB, resA, c);
        isReversed = true;
    }
}