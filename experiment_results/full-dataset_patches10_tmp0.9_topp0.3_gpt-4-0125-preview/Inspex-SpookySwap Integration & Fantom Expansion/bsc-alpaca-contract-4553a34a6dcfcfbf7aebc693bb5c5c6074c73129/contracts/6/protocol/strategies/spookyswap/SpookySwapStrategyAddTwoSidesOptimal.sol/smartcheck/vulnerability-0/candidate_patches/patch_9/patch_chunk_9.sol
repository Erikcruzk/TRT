function optimalDeposit(
    uint256 amtA,
    uint256 amtB,
    uint256 resA,
    uint256 resB
) internal pure returns (uint256 swapAmt, bool isReversed) {
    if (amtA.mul(resB) >= amtB.mul(resA)) {
        swapAmt = _optimalDepositA(amtA, amtB, resA, resB);
        isReversed = false;
    } else {
        swapAmt = _optimalDepositA(amtB, amtA, resB, resA);
        isReversed = true;
    }
}

function _optimalDepositA(
    uint256 amtA,
    uint256 amtB,
    uint256 resA,
    uint256 resB
) internal pure returns (uint256) {
    require(amtA.mul(resB) >= amtB.mul(resA), "reversed");

    uint256 a = 998;
    uint256 b = uint256(1998).mul(resA);
    uint256 c = (amtA.mul(resB)).sub(amtB.mul(resA));
    uint256 numerator = AlpacaMath.sqrt(b.mul(b).add(a.mul(c).mul(4)));
    numerator = numerator.sub(b);
    uint256 denominator = a.mul(2);

    return numerator.div(denominator);
}