function optimalDeposit(
    uint256 amtA,
    uint256 amtB,
    uint256 resA,
    uint256 resB,
    uint256 fee
) internal pure returns (uint256 swapAmt, bool isReversed) {
    if (amtA.mul(resB) >= amtB.mul(resA)) {
        uint256 a = uint256(10000).mul(resA).mul(amtB);
        uint256 b = uint256(10000).mul(fee).mul(amtB).add(uint256(10000).sub(fee).mul(resB).mul(amtA));
        uint256 c = AlpacaMath.sqrt(a.mul(a).add(b.mul(resA).mul(4)));
        swapAmt = c.sub(a).div(uint256(20000).mul(resA).sub(uint256(10000).mul(fee)));
        isReversed = false;
    } else {
        uint256 a = uint256(10000).mul(resB).mul(amtA);
        uint256 b = uint256(10000).mul(fee).mul(amtA).add(uint256(10000).sub(fee).mul(resA).mul(amtB));
        uint256 c = AlpacaMath.sqrt(a.mul(a).add(b.mul(resB).mul(4)));
        swapAmt = c.sub(a).div(uint256(20000).mul(resB).sub(uint256(10000).mul(fee)));
        isReversed = true;
    }
}