function optimalDeposit(
    uint256 amtA,
    uint256 amtB,
    uint256 resA,
    uint256 resB
) internal pure returns (uint256 swapAmt, bool isReversed) {
    if (amtA.mul(resB) >= amtB.mul(resA)) {
        // Original vulnerable line:
        // swapAmt = _optimalDepositA(amtA, amtB, resA, resB);
        // Fix applied:
        uint256 a = 998;
        uint256 b = uint256(1998).mul(resA).mul(amtB).div(resB);
        uint256 c = amtA.mul(1000).div(amtB.add(resB)).mul(resA);
        uint256 d = a.mul(c).mul(4);
        uint256 e = AlpacaMath.sqrt(b.mul(b).add(d));
        uint256 numerator = e.sub(b);
        uint256 denominator = a.mul(2);
        swapAmt = numerator.div(denominator);

        isReversed = false;
    } else {
        // Original vulnerable line:
        // swapAmt = _optimalDepositA(amtB, amtA, resB, resA);
        // Fix applied with reversed parameters:
        uint256 a = 998;
        uint256 b = uint256(1998).mul(resB).mul(amtA).div(resA);
        uint256 c = amtB.mul(1000).div(amtA.add(resA)).mul(resB);
        uint256 d = a.mul(c).mul(4);
        uint256 e = AlpacaMath.sqrt(b.mul(b).add(d));
        uint256 numerator = e.sub(b);
        uint256 denominator = a.mul(2);
        swapAmt = numerator.div(denominator);

        isReversed = true;
    }
}