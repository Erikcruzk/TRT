function optimalDeposit(
    uint256 amtA,
    uint256 amtB,
    uint256 resA,
    uint256 resB
) internal pure returns (uint256 swapAmt, bool isReversed) {
    if (amtA.mul(resB) >= amtB.mul(resA)) {
        // beginMigration
        uint256 a = 9975;
        uint256 b = uint256(19975).mul(resA);
        uint256 c = (amtA.mul(resB)).sub(amtB.mul(resA));
        uint256 numerator = AlpacaMath.sqrt(b.mul(b).add(a.mul(c).mul(4)));
        uint256 denominator = a.mul(2);

        swapAmt = (numerator.sub(b)).div(denominator);
        isReversed = false;
    } else {
        // beginMigration reversed
        uint256 aReversed = 9975;
        uint256 bReversed = uint256(19975).mul(resB);
        uint256 cReversed = (amtB.mul(resA)).sub(amtA.mul(resB));
        uint256 numeratorReversed = AlpacaMath.sqrt(bReversed.mul(bReversed).add(aReversed.mul(cReversed).mul(4)));
        uint256 denominatorReversed = aReversed.mul(2);

        swapAmt = (numeratorReversed.sub(bReversed)).div(denominatorReversed);
        isReversed = true;
    }
}