function optimalDeposit(
    uint256 amtA,
    uint256 amtB,
    uint256 resA,
    uint256 resB,
    uint256 fee
) internal pure returns (uint256 swapAmt, bool isReversed) {
    if (amtA.mul(resB) >= amtB.mul(resA)) {
        // Ensuring multiplication does not overflow.
        uint256 amountAMulB = amtA.mul(resB);
        uint256 amountBMulA = amtB.mul(resA);
        // Divide before multiplying to prevent overflow
        if (amountAMulB.div(amtA) == resB && amountBMulA.div(amtB) == resA) {
            swapAmt = _optimalDepositA(amtA, amtB, resA, resB, fee);
        }
        isReversed = false;
    } else {
        // Ensuring multiplication does not overflow.
        uint256 amountBMulA = amtB.mul(resA);
        uint256 amountAMulB = amtA.mul(resB);
        // Divide before multiplying to prevent overflow
        if (amountBMulA.div(amtB) == resA && amountAMulB.div(amtA) == resB) {
            swapAmt = _optimalDepositA(amtB, amtA, resB, resA, fee);
        }
        isReversed = true;
    }
}