function optimalDeposit(
    uint256 amtA,
    uint256 amtB,
    uint256 resA,
    uint256 resB,
    uint256 fee
  ) internal pure returns (uint256 swapAmt, bool isReversed) {
    if (amtA.mul(resB) >= amtB.mul(resA)) {
      uint256 a = uint256(10000).sub(fee);
      uint256 b = uint256(20000).sub(fee).mul(resA); 
      uint256 c = (amtA.mul(resB)).sub(amtB.mul(resA));
      uint256 numerator = AlpacaMath.sqrt(b.mul(b).add(a.mul(c).mul(4)));
      uint256 denominator = a.mul(2);
      swapAmt = numerator.sub(b).div(denominator);
      isReversed = false;
    } else {
      uint256 a = uint256(10000).sub(fee);
      uint256 b = uint256(20000).sub(fee).mul(resB);
      uint256 c = (amtB.mul(resA)).sub(amtA.mul(resB));
      uint256 numerator = AlpacaMath.sqrt(b.mul(b).add(a.mul(c).mul(4)));
      uint256 denominator = a.mul(2);
      swapAmt = numerator.sub(b).div(denominator);
      isReversed = true;
    }
  }