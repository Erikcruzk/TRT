function optimalDeposit(
    uint256 amtA,
    uint256 amtB,
    uint256 resA,
    uint256 resB,
    uint256 fee
) internal pure returns (uint256 swapAmt, bool isReversed) {
    if (amtA.mul(resB) >= amtB.mul(resA)) {
        uint256 a = 10000;
        uint256 b = 20000.sub(fee).mul(resA);
        uint256 _c = amtA.mul(resB).sub(amtB.mul(resA));
        // The vulnerability fix is applied here to prevent overflow by changing the order of operations
        uint256 c = _c.mul(a).div(amtB.add(resB)).mul(resA).div(a);
        uint256 d = a.mul(c).mul(4);
        uint256 e = AlpacaMath.sqrt(b.mul(b).add(d));

        uint256 numerator = e.sub(b);
        uint256 denominator = a.mul(2);

        swapAmt = numerator.div(denominator);
        isReversed = false;
    } else {
        uint256 a = 10000;
        uint256 b = 20000.sub(fee).mul(resB);
        uint256 _c = amtB.mul(resA).sub(amtA.mul(resB));
        // The vulnerability fix is applied here to prevent overflow by changing the order of operations
        uint256 c = _c.mul(a).div(amtA.add(resA)).mul(resB).div(a);
        uint256 d = a.mul(c).mul(4);
        uint256 e = AlpacaMath.sqrt(b.mul(b).add(d));

        uint256 numerator = e.sub(b);
        uint256 denominator = a.mul(2);

        swapAmt = numerator.div(denominator);
        isReversed = true;
    }
}