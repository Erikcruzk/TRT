{
  "smartbugs_completed": true,
  "analyzer_results": {
    "semgrep": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": []
    },
    "slither": {
      "successfull_analysis": true,
      "errors": [
        "EXIT_CODE_7"
      ],
      "vulnerability_findings": [
        {
          "name": "constant-function",
          "vulnerability_from_line": 10,
          "vulnerability_to_line": 35,
          "vulnerability_code": "    function encodeProofOutputsOne(\n\n        uint noteInfo,\n\n        uint publicOwner,\n\n        uint publicValue\n\n    ) public pure returns (bytes memory) {\n\n        assembly {\n\n            mstore(0x160, 0x20)\n\n            // 0x180 = size of proofOutputs in bytes\n\n            mstore(0x1a0, 0x01) // number of proof outputs\n\n            mstore(0x1c0, 0x60) // relative offset to start of proofOutputs\n\n        }\n\n        uint size = 0x80 + encodeProofOutput(\n\n            0x1e0,\n\n            (noteInfo & 0xff),\n\n            (noteInfo >> 8) & 0xff,\n\n            (noteInfo >> 16) & 0xffff,\n\n            (noteInfo >> 32) & 0xffff,\n\n            (noteInfo >> 48) & 0xffff,\n\n            publicOwner,\n\n            publicValue\n\n        );\n\n        assembly {\n\n            mstore(0x180, sub(size, 0x40))\n\n            return(0x160, size)\n\n        }\n",
          "message": "GenericABIEncoder.encodeProofOutputsOne (GenericABIEncoder.sol#10-35) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 37,
          "vulnerability_to_line": 190,
          "vulnerability_code": "    function encodeProofOutput(\n\n        uint freePtr,\n\n        uint numNotes,\n\n        uint numInputNotes,\n\n        uint offsetToNotes,\n\n        uint ownerPtr,\n\n        uint metadataPtr,\n\n        uint publicOwner,\n\n        uint publicValue\n\n    ) internal pure returns (uint proofOutputSize) {\n\n        assembly {\n\n            // memory map of proofOutput\n\n            // 0x00 - 0x20 - byte length\n\n            // 0x20 - 0x40 - offset to inputNotes\n\n            // 0x40 - 0x60 - offset to outputNotes\n\n            // 0x60 - 0x80 - publicOnwner\n\n            // 0x80 - 0xa0 - publicValue\n\n            mstore(add(freePtr, 0x20), 0xa0)\n\n            mstore(add(freePtr, 0x60), publicOwner)\n\n            mstore(add(freePtr, 0x80), publicValue)\n\n            proofOutputSize := encodeInputNotes(\n\n                add(freePtr, 0xa0),\n\n                numInputNotes,\n\n                add(offsetToNotes, 0x20),\n\n                ownerPtr\n\n            )\n\n           \n\n            mstore(add(freePtr, 0x40), add(proofOutputSize, 0xa0))\n\n\n\n            proofOutputSize := add(\n\n                proofOutputSize,\n\n                encodeOutputNotes(\n\n                    add(add(freePtr, 0xa0), proofOutputSize),\n\n                    sub(numNotes, numInputNotes),\n\n                    add(offsetToNotes, mul(numInputNotes, 0xc0)),\n\n                    add(ownerPtr, mul(numInputNotes, 0x20)),\n\n                    add(metadataPtr, mul(numInputNotes, 0x20))\n\n                )\n\n            )\n\n            proofOutputSize := add(proofOutputSize, 0xa0)\n\n            mstore(freePtr, sub(proofOutputSize, 0x20))\n\n\n\n            function encodeInputNotes(memPtr, len, notePtr, ownerPtr) -> inputNotesLength {\n\n                mstore(0x00, 0x01)\n\n                // memory map for input notes\n\n                // 0x00 - 0x20 - byte length\n\n                // 0x20 - 0x40 - number of notes\n\n                // 0x40 - xxxx - offsets to note entries\n\n                mstore(add(memPtr, 0x20), len) // length of input notes\n\n                \n\n                notePtr := add(memPtr, add(0x40, mul(len, 0x20)))\n\n                for { let i := 0 } lt(i, len) { i := add(i, 0x01) } {\n\n                    // write the relative offset to this note entry\n\n                    mstore(add(0x40, add(memPtr, mul(i, 0x20))), sub(notePtr, memPtr))\n\n\n\n                    let noteIndex := add(notePtr, mul(i, 0xc0))\n\n                    // copy notes\n\n                    calldatacopy(0x20, noteIndex, 0x80)\n\n\n\n                    mstore(notePtr, 0xc0) // length of note\n\n                    mstore(add(notePtr, 0x20), 0x01) // note type\n\n                    mstore(add(notePtr, 0x40), calldataload(add(ownerPtr, mul(i, 0xc0)))) // note owner\n\n                    mstore(add(notePtr, 0x60), keccak256(0x00, 0xa0)) // note hash\n\n                    mstore(add(notePtr, 0x80), 0x40) // metadata length\n\n                    mstore(             // gamma\n\n                        add(notePtr, 0xa0),\n\n                        or(\n\n                            mload(0x20),\n\n                            mul(\n\n                            and(mload(0x40), 0x01),\n\n                            0x8000000000000000000000000000000000000000000000000000000000000000\n\n                            )\n\n                        )\n\n                    )\n\n                    // store compressed note coordinate sigma in `s + 0xa0`\n\n                    mstore(\n\n                        add(notePtr, 0xc0),\n\n                        or(\n\n                            mload(0x60),\n\n                            mul(\n\n                            and(mload(0x80), 0x01),\n\n                            0x8000000000000000000000000000000000000000000000000000000000000000\n\n                            )\n\n                        )\n\n                    )\n\n\n\n                    notePtr := add(notePtr, 0xe0)\n\n                }\n\n\n\n                mstore(memPtr, sub(sub(notePtr, memPtr), 0x20)) // store input note length at memPtr\n\n                inputNotesLength := sub(notePtr, memPtr)\n\n            }\n\n\n\n            function encodeOutputNotes(memPtr, len, notePtr, ownerPtr, metadataPtr) -> outputNotesLength {\n\n                mstore(0x00, 0x01)\n\n                // memory map for input notes\n\n                // 0x00 - 0x20 - byte length\n\n                // 0x20 - 0x40 - number of notes\n\n                // 0x40 - xxxx - offsets to note entries\n\n                mstore(add(memPtr, 0x20), len) // length of output notes\n\n                \n\n                notePtr := add(memPtr, add(0x40, mul(len, 0x20)))\n\n                for { let i := 0 } lt(i, len) { i := add(i, 0x01) } {\n\n                    // write the relative offset to this note entry\n\n                    mstore(add(0x40, add(memPtr, mul(i, 0x20))), sub(notePtr, memPtr))\n\n\n\n                    let noteIndex := add(notePtr, mul(i, 0xc0))\n\n                    let metadataIndex := calldataload(add(metadataPtr, add(0x20, mul(i, 0x20))))\n\n                    let metadataLength := calldataload(add(sub(metadataPtr, 0x40), metadataIndex))\n\n\n\n                    // copy notes\n\n                    calldatacopy(0x20, noteIndex, 0x80)\n\n\n\n                    mstore(notePtr, 0xc0) // length of note\n\n                    mstore(add(notePtr, 0x20), 0x01) // note type\n\n                    mstore(add(notePtr, 0x40), calldataload(add(ownerPtr, mul(i, 0xc0)))) // note owner\n\n                    mstore(add(notePtr, 0x60), keccak256(0x00, 0xa0)) // note hash\n\n                    mstore(add(notePtr, 0x80), add(0x40, metadataLength)) // metadata length\n\n                    mstore(             // gamma\n\n                        add(notePtr, 0xa0),\n\n                        or(\n\n                            mload(0x20),\n\n                            mul(\n\n                            and(mload(0x40), 0x01),\n\n                            0x8000000000000000000000000000000000000000000000000000000000000000\n\n                            )\n\n                        )\n\n                    )\n\n                    // store compressed note coordinate sigma in `s + 0xa0`\n\n                    mstore(\n\n                        add(notePtr, 0xc0),\n\n                        or(\n\n                            mload(0x60),\n\n                            mul(\n\n                            and(mload(0x80), 0x01),\n\n                            0x8000000000000000000000000000000000000000000000000000000000000000\n\n                            )\n\n                        )\n\n                    )\n\n                    calldatacopy(\n\n                        add(notePtr, 0xe0),\n\n                        add(metadataIndex, sub(metadataPtr, 0x20)),\n\n                        metadataLength\n\n                    )\n\n\n\n                    notePtr := add(notePtr, add(0xe0, metadataLength))\n\n                }\n\n\n\n                mstore(memPtr, sub(sub(notePtr, memPtr), 0x20)) // store input note length at memPtr\n\n                outputNotesLength := sub(notePtr, memPtr)\n\n            }\n\n\n\n        }\n",
          "message": "GenericABIEncoder.encodeProofOutput (GenericABIEncoder.sol#37-190) is declared view but contains assembly code\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 10,
          "vulnerability_to_line": 35,
          "vulnerability_code": "    function encodeProofOutputsOne(\n\n        uint noteInfo,\n\n        uint publicOwner,\n\n        uint publicValue\n\n    ) public pure returns (bytes memory) {\n\n        assembly {\n\n            mstore(0x160, 0x20)\n\n            // 0x180 = size of proofOutputs in bytes\n\n            mstore(0x1a0, 0x01) // number of proof outputs\n\n            mstore(0x1c0, 0x60) // relative offset to start of proofOutputs\n\n        }\n\n        uint size = 0x80 + encodeProofOutput(\n\n            0x1e0,\n\n            (noteInfo & 0xff),\n\n            (noteInfo >> 8) & 0xff,\n\n            (noteInfo >> 16) & 0xffff,\n\n            (noteInfo >> 32) & 0xffff,\n\n            (noteInfo >> 48) & 0xffff,\n\n            publicOwner,\n\n            publicValue\n\n        );\n\n        assembly {\n\n            mstore(0x180, sub(size, 0x40))\n\n            return(0x160, size)\n\n        }\n",
          "message": "GenericABIEncoder.encodeProofOutputsOne uses assembly (GenericABIEncoder.sol#10-35)\n\t- GenericABIEncoder.sol#15-20\n\t- GenericABIEncoder.sol#31-34\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 37,
          "vulnerability_to_line": 190,
          "vulnerability_code": "    function encodeProofOutput(\n\n        uint freePtr,\n\n        uint numNotes,\n\n        uint numInputNotes,\n\n        uint offsetToNotes,\n\n        uint ownerPtr,\n\n        uint metadataPtr,\n\n        uint publicOwner,\n\n        uint publicValue\n\n    ) internal pure returns (uint proofOutputSize) {\n\n        assembly {\n\n            // memory map of proofOutput\n\n            // 0x00 - 0x20 - byte length\n\n            // 0x20 - 0x40 - offset to inputNotes\n\n            // 0x40 - 0x60 - offset to outputNotes\n\n            // 0x60 - 0x80 - publicOnwner\n\n            // 0x80 - 0xa0 - publicValue\n\n            mstore(add(freePtr, 0x20), 0xa0)\n\n            mstore(add(freePtr, 0x60), publicOwner)\n\n            mstore(add(freePtr, 0x80), publicValue)\n\n            proofOutputSize := encodeInputNotes(\n\n                add(freePtr, 0xa0),\n\n                numInputNotes,\n\n                add(offsetToNotes, 0x20),\n\n                ownerPtr\n\n            )\n\n           \n\n            mstore(add(freePtr, 0x40), add(proofOutputSize, 0xa0))\n\n\n\n            proofOutputSize := add(\n\n                proofOutputSize,\n\n                encodeOutputNotes(\n\n                    add(add(freePtr, 0xa0), proofOutputSize),\n\n                    sub(numNotes, numInputNotes),\n\n                    add(offsetToNotes, mul(numInputNotes, 0xc0)),\n\n                    add(ownerPtr, mul(numInputNotes, 0x20)),\n\n                    add(metadataPtr, mul(numInputNotes, 0x20))\n\n                )\n\n            )\n\n            proofOutputSize := add(proofOutputSize, 0xa0)\n\n            mstore(freePtr, sub(proofOutputSize, 0x20))\n\n\n\n            function encodeInputNotes(memPtr, len, notePtr, ownerPtr) -> inputNotesLength {\n\n                mstore(0x00, 0x01)\n\n                // memory map for input notes\n\n                // 0x00 - 0x20 - byte length\n\n                // 0x20 - 0x40 - number of notes\n\n                // 0x40 - xxxx - offsets to note entries\n\n                mstore(add(memPtr, 0x20), len) // length of input notes\n\n                \n\n                notePtr := add(memPtr, add(0x40, mul(len, 0x20)))\n\n                for { let i := 0 } lt(i, len) { i := add(i, 0x01) } {\n\n                    // write the relative offset to this note entry\n\n                    mstore(add(0x40, add(memPtr, mul(i, 0x20))), sub(notePtr, memPtr))\n\n\n\n                    let noteIndex := add(notePtr, mul(i, 0xc0))\n\n                    // copy notes\n\n                    calldatacopy(0x20, noteIndex, 0x80)\n\n\n\n                    mstore(notePtr, 0xc0) // length of note\n\n                    mstore(add(notePtr, 0x20), 0x01) // note type\n\n                    mstore(add(notePtr, 0x40), calldataload(add(ownerPtr, mul(i, 0xc0)))) // note owner\n\n                    mstore(add(notePtr, 0x60), keccak256(0x00, 0xa0)) // note hash\n\n                    mstore(add(notePtr, 0x80), 0x40) // metadata length\n\n                    mstore(             // gamma\n\n                        add(notePtr, 0xa0),\n\n                        or(\n\n                            mload(0x20),\n\n                            mul(\n\n                            and(mload(0x40), 0x01),\n\n                            0x8000000000000000000000000000000000000000000000000000000000000000\n\n                            )\n\n                        )\n\n                    )\n\n                    // store compressed note coordinate sigma in `s + 0xa0`\n\n                    mstore(\n\n                        add(notePtr, 0xc0),\n\n                        or(\n\n                            mload(0x60),\n\n                            mul(\n\n                            and(mload(0x80), 0x01),\n\n                            0x8000000000000000000000000000000000000000000000000000000000000000\n\n                            )\n\n                        )\n\n                    )\n\n\n\n                    notePtr := add(notePtr, 0xe0)\n\n                }\n\n\n\n                mstore(memPtr, sub(sub(notePtr, memPtr), 0x20)) // store input note length at memPtr\n\n                inputNotesLength := sub(notePtr, memPtr)\n\n            }\n\n\n\n            function encodeOutputNotes(memPtr, len, notePtr, ownerPtr, metadataPtr) -> outputNotesLength {\n\n                mstore(0x00, 0x01)\n\n                // memory map for input notes\n\n                // 0x00 - 0x20 - byte length\n\n                // 0x20 - 0x40 - number of notes\n\n                // 0x40 - xxxx - offsets to note entries\n\n                mstore(add(memPtr, 0x20), len) // length of output notes\n\n                \n\n                notePtr := add(memPtr, add(0x40, mul(len, 0x20)))\n\n                for { let i := 0 } lt(i, len) { i := add(i, 0x01) } {\n\n                    // write the relative offset to this note entry\n\n                    mstore(add(0x40, add(memPtr, mul(i, 0x20))), sub(notePtr, memPtr))\n\n\n\n                    let noteIndex := add(notePtr, mul(i, 0xc0))\n\n                    let metadataIndex := calldataload(add(metadataPtr, add(0x20, mul(i, 0x20))))\n\n                    let metadataLength := calldataload(add(sub(metadataPtr, 0x40), metadataIndex))\n\n\n\n                    // copy notes\n\n                    calldatacopy(0x20, noteIndex, 0x80)\n\n\n\n                    mstore(notePtr, 0xc0) // length of note\n\n                    mstore(add(notePtr, 0x20), 0x01) // note type\n\n                    mstore(add(notePtr, 0x40), calldataload(add(ownerPtr, mul(i, 0xc0)))) // note owner\n\n                    mstore(add(notePtr, 0x60), keccak256(0x00, 0xa0)) // note hash\n\n                    mstore(add(notePtr, 0x80), add(0x40, metadataLength)) // metadata length\n\n                    mstore(             // gamma\n\n                        add(notePtr, 0xa0),\n\n                        or(\n\n                            mload(0x20),\n\n                            mul(\n\n                            and(mload(0x40), 0x01),\n\n                            0x8000000000000000000000000000000000000000000000000000000000000000\n\n                            )\n\n                        )\n\n                    )\n\n                    // store compressed note coordinate sigma in `s + 0xa0`\n\n                    mstore(\n\n                        add(notePtr, 0xc0),\n\n                        or(\n\n                            mload(0x60),\n\n                            mul(\n\n                            and(mload(0x80), 0x01),\n\n                            0x8000000000000000000000000000000000000000000000000000000000000000\n\n                            )\n\n                        )\n\n                    )\n\n                    calldatacopy(\n\n                        add(notePtr, 0xe0),\n\n                        add(metadataIndex, sub(metadataPtr, 0x20)),\n\n                        metadataLength\n\n                    )\n\n\n\n                    notePtr := add(notePtr, add(0xe0, metadataLength))\n\n                }\n\n\n\n                mstore(memPtr, sub(sub(notePtr, memPtr), 0x20)) // store input note length at memPtr\n\n                outputNotesLength := sub(notePtr, memPtr)\n\n            }\n\n\n\n        }\n",
          "message": "GenericABIEncoder.encodeProofOutput uses assembly (GenericABIEncoder.sol#37-190)\n\t- GenericABIEncoder.sol#47-189\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 10,
          "vulnerability_to_line": 35,
          "vulnerability_code": "    function encodeProofOutputsOne(\n\n        uint noteInfo,\n\n        uint publicOwner,\n\n        uint publicValue\n\n    ) public pure returns (bytes memory) {\n\n        assembly {\n\n            mstore(0x160, 0x20)\n\n            // 0x180 = size of proofOutputs in bytes\n\n            mstore(0x1a0, 0x01) // number of proof outputs\n\n            mstore(0x1c0, 0x60) // relative offset to start of proofOutputs\n\n        }\n\n        uint size = 0x80 + encodeProofOutput(\n\n            0x1e0,\n\n            (noteInfo & 0xff),\n\n            (noteInfo >> 8) & 0xff,\n\n            (noteInfo >> 16) & 0xffff,\n\n            (noteInfo >> 32) & 0xffff,\n\n            (noteInfo >> 48) & 0xffff,\n\n            publicOwner,\n\n            publicValue\n\n        );\n\n        assembly {\n\n            mstore(0x180, sub(size, 0x40))\n\n            return(0x160, size)\n\n        }\n",
          "message": "GenericABIEncoder.encodeProofOutputsOne (GenericABIEncoder.sol#10-35) should be declared external\n"
        },
        {
          "name": "solc-version",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
          "message": "Detected issues with version pragma in GenericABIEncoder.sol:\n\t- pragma solidity>=0.5.0<0.6.0 (GenericABIEncoder.sol#3): it allows old versions\n"
        },
        {
          "name": "unused-state",
          "vulnerability_from_line": 7,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint private constant NOTE_TYPE = 1;\n",
          "message": "GenericABIEncoder.NOTE_TYPE (GenericABIEncoder.sol#7) is never used in GenericABIEncoder\n"
        }
      ]
    },
    "smartcheck": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 21,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint size = 0x80 + encodeProofOutput(\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 22,
          "vulnerability_to_line": null,
          "vulnerability_code": "            0x1e0,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 23,
          "vulnerability_to_line": null,
          "vulnerability_code": "            (noteInfo & 0xff),\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 24,
          "vulnerability_to_line": null,
          "vulnerability_code": "            (noteInfo >> 8) & 0xff,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 25,
          "vulnerability_to_line": null,
          "vulnerability_code": "            (noteInfo >> 16) & 0xffff,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 26,
          "vulnerability_to_line": null,
          "vulnerability_code": "            (noteInfo >> 32) & 0xffff,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 27,
          "vulnerability_to_line": null,
          "vulnerability_code": "            (noteInfo >> 48) & 0xffff,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
          "vulnerability_from_line": 10,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function encodeProofOutputsOne(\n",
          "message": null
        },
        {
          "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
          "vulnerability_from_line": 37,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function encodeProofOutput(\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 7,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint private constant NOTE_TYPE = 1;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 10,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function encodeProofOutputsOne(\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 37,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function encodeProofOutput(\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 15,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 31,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 47,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        }
      ]
    },
    "oyente": {
      "successfull_analysis": false,
      "errors": [
        "exception (RuntimeError: Source map error, unknown name(SHR) or instr_name(INVALID))"
      ],
      "vulnerability_findings": []
    },
    "mythril": {
      "successfull_analysis": false,
      "errors": [
        "Solc experienced a fatal error"
      ],
      "vulnerability_findings": []
    },
    "osiris": {
      "successfull_analysis": false,
      "errors": [
        "Solidity compilation failed"
      ],
      "vulnerability_findings": []
    }
  }
}