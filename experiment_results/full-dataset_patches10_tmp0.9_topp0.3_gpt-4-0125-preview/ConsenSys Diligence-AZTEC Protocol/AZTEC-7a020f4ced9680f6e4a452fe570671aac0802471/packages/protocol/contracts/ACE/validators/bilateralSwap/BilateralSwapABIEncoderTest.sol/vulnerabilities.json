{
  "smartbugs_completed": true,
  "analyzer_results": {
    "semgrep": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": []
    },
    "slither": {
      "successfull_analysis": true,
      "errors": [
        "EXIT_CODE_6"
      ],
      "vulnerability_findings": [
        {
          "name": "constant-function",
          "vulnerability_from_line": 38,
          "vulnerability_to_line": 604,
          "vulnerability_code": "    function encodeAndExit() internal pure {\n\n        assembly {\n\n            // set up initial variables\n\n            let notes := add(0x104, calldataload(0x144))\n\n            let noteOwners := add(0x124, calldataload(0x164)) // // one word after inputOwners = 1st\n\n            let metadataPtr := add(0x144, calldataload(0x184)) // two words after metadata = 1st\n\n\n\n            // First up, we need to do some checks to ensure we have been provided with correct data.\n\n            // We should only have 2 entries inside `bytes metadata` (only 2 output notes in total),\n\n            // and only 4 entries inside `noteOwners` (4 notes in bilateral swap proof)\n\n            if iszero(and(\n\n                eq(0x02, calldataload(sub(metadataPtr, 0x20))),\n\n                eq(0x04, calldataload(sub(noteOwners, 0x20)))\n\n            )) {\n\n                revert(0x00, 0x00) // no! bad! come back with good inputs!\n\n            }\n\n\n\n            // memory map of `proofOutputs`\n\n            // 0x00 - 0x160  = scratch data for note hash computation\n\n\n\n            // `returndata` starts at 0x160\n\n            // `proofOutputs` starts at 0x180\n\n            // 0x160 - 0x180 = relative offset in returndata to first bytes argument (0x20)\n\n            // 0x180 - 0x1a0 = byte length of `proofOutputs`\n\n            // 0x1a0 - 0x1c0 = number of `proofOutputs` entries (2)\n\n            // 0x1c0 - 0x1e0 = relative memory offset between `v` and start of `proofOutputs[0]` (0x80)\n\n            // 0x1e0 - 0x200 = relative memory offset between `v` and start of `proofOutputs[1]`\n\n    \n\n            // `proofOutput` - t, starts at 0x200\n\n            // 0x200 - 0x220 = length of `proofOutput`\n\n            // 0x220 - 0x240 = relative offset between `t` and `inputNotes`\n\n            // 0x240 - 0x260 = relative offset between `t` and `outputNotes`\n\n            // 0x260 - 0x280 = `publicOwner`\n\n            // 0x280 - 0x2a0 = `publicValue`\n\n            // 0x2a0 - 0x2c0 = `challenge`\n\n\n\n            // `inputNotes` starts at 0x2c0\n\n            // structure of `inputNotes` and `outputNotes`\n\n            // 0x00 - 0x20 = byte length of notes array\n\n            // 0x20 - 0x40 = number of notes = 1\n\n            // 0x40 - 0x60 = offset to start of input note (0x60)\n\n\n\n            // structure of a `note`\n\n            // 0x00 - 0x20 = size of `note`\n\n            // 0x20 - 0x40 = `owner`\n\n            // 0x40 - 0x60 = `noteHash`\n\n            // 0x60 - 0x80 = size of note `data`\n\n            // 0x80 - 0xa0 = compressed note coordinate `gamma` (part of `data`)\n\n            // 0xa0 - 0xc0 = compressed note coordinate `sigma` (part of `data`)\n\n            // 0xc0 - ???? = remaining note metadata\n\n\n\n            // Note organisation...\n\n            // The bilateral swap proof proves the following:\n\n            //   1. note[0].value == note[2].value\n\n            //   2. note[1].value == note[3].value\n\n            // In other words...\n\n            // note[0] = maker bid note\n\n            // note[1] = maker ask note\n\n            // note[2] = taker ask note\n\n            // note[3] = taker bid note\n\n\n\n            // We therefore have 2 balancing relationships\n\n            // 1. The maker bid note is destroyed and replaced with the taker ask note\n\n            // 2. The taker bid note is destroyed and replaced with the maker ask note\n\n\n\n            // Finally, we can translate this into 2 proofOutputs entries...\n\n            // In the first entry, `inputNotes` = [note[0]] and `outputNotes` = [note[2]]\n\n            // In the second entry, `inputNotes` = [note[3]] and `outputNotes` = [note[1]]\n\n\n\n            // `proofOutputs` must form a monolithic block of memory that we can return.\n\n            // `s` points to the memory location of the start of the current note\n\n            // `inputPtr` points to the start of the current `notes` dynamic bytes array\n\n\n\n            // length of proofOutputs is at 0x180\n\n\n\n            // we use memory from 0x00 - 0x140 as scratch memory\n\n\n\n            // return data starts at 0x160. As return data is `bytes proofOutputs`,\n\n            // the first word is the relative offset to the start of `proofOutputs` (i.e. 0x20)\n\n            mstore(0x160, 0x20)\n\n\n\n            /**\n\n            * Encoding of proofOutputs\n\n            * abi encoding of proofOutputs\n\n            * 0x00 : 0x20 = byte length of `proofOutputs` = 0x60 + L1 + L2\n\n            * 0x20 : 0x40 = number of `proofOutputs` entries (2)\n\n            * 0x40 : 0x60 = relative memory offset between `v` and start of `proofOutputs[0]` (0x80)\n\n            * 0x60 : 0x80 = relative memory offset between `v` and start of `proofOutputs[1]`\n\n            * 0x80 : 0x80 + L1    = start of proofOutputs[0]\n\n            * 0x80 + L1   : 0x80 + L1 + L2 = start of proofOutputs[1]\n\n            **/\n\n        \n\n            // 0x180 stores the total size of `bytes proofOutputs`. We don't know that yet, so leave blank\n\n\n\n            // 0x1a0 = number of proof outputs (2)\n\n            mstore(0x1a0, 0x02)                            // number of proofs\n\n\n\n            // 0x1c0 = relative offset to 1st entry (0x80, 4 words)\n\n            mstore(0x1c0, 0x80)                            // offset to 1st proof\n\n\n\n            /**\n\n            * Encoding of proofOutput\n\n            * 0x00 : 0x20 = byte length of `proofOutput` = 0x60 + L1 + L2\n\n            * 0x20 : 0x40 = relative offset to `bytes inputNotes`\n\n            * 0x40 : 0x60 = relative offset to `bytes outputNotes`\n\n            * 0x60 : 0x80 = publicOwner\n\n            * 0x80 : 0xa0 = publicValue\n\n            * 0xa0 : 0xc0 = challenge\n\n            * 0xc0 : 0xc0 + L1 = `bytes inputNotes` (L1 = 0x140 bytes)\n\n            * 0xc0 + L1 : 0xc0 + L1 + L2 = `bytes inputNotes`\n\n            *\n\n            * Start of proofOutput = 0x200\n\n            **/\n\n\n\n            // length of proofOutput is at 0x200. We don't know that yet, so leave blank\n\n\n\n            // relative offset to inputNotes = 0xc0 (6 words)\n\n            mstore(0x220, 0xc0)                            // location of inputNotes\n\n\n\n            // we know that inputNotes has 1 entry, and input notes don't have metadata.\n\n            // So we actually know the complete size of `bytes inputNotes`\n\n            // (it's 0x140 bytes, we'll get to that in a bit)\n\n            // => relative offset to outputNotes = 0x140 + 0xc0 = 0x200\n\n            mstore(0x240, 0x200)                           // location of outputNotes\n\n\n\n            // bilateral swap proof hardcodes `publicOwner` and `publicValue` to 0 (no public tokens)\n\n            mstore(0x260, 0x00)                             // publicOwner\n\n            mstore(0x280, 0x00)                             // publicValue\n\n            mstore(0x2a0, calldataload(0x124))              // challenge\n\n            /**\n\n            * Encoding of inputNotes\n\n            * 0x00 : 0x20 = byte length of `inputNotes` (0x120)\n\n            * 0x20 : 0x40 = number of input notes (0x01)\n\n            * 0x40 : 0x60 = relative offset to 1st input note (0x60)\n\n            * 0x60 : L    = 1st input note data (L = 0xe0)\n\n            *\n\n            * Start of inputNotes = 0x2a0\n\n            * Because we only have 1 note in this array, and that note has no metadata\n\n            * we know that the size of the note is 0xe0 bytes\n\n            * therefore, the size of inputNotes = 0xe0 + 3 words = 0x140 bytes.\n\n            * We store the byte length as 0x120 bytes because the length parameter\n\n            * of a dynamic bytes array does not include itself in the length calculation\n\n            **/\n\n\n\n            // 0x2c0 = length of inputNotes = 0x120\n\n            mstore(0x2c0, 0x120)\n\n\n\n            // 0x2e0 = number of notes (1)\n\n            mstore(0x2e0, 0x01) // 1 input note\n\n\n\n            // 0x300 = relative offset to input note (0x60)\n\n            mstore(0x300, 0x60) // relative offset to note data\n\n\n\n            /**\n\n            * Encoding of input note\n\n            * 0x00 : 0x20 = byte length of note (0xc0)\n\n            * 0x20 : 0x40 = note type (UXTO type = 0x01)\n\n            * 0x40 : 0x60 = note owner\n\n            * 0x60 : 0x80 = note hash\n\n            * 0x80 : 0xa0 = note data length (0x40)\n\n            * 0xa0 : 0xc0 = note coordinate 'gamma' (compressed)\n\n            * 0xc0 : 0xe0 = note coordinate 'sigma' (compressed)\n\n            *\n\n            * Start of note = 0x320\n\n            * The size of this note = 0xe0 bytes, so we store 0xc0 in the length parameter\n\n            **/\n\n\n\n            // we use memory from 0x00 - 0xa0 as scratch memory to compute note hash\n\n            // Note hash = keccak256(abi.encode(noteType, gammaX, gammaY, sigmaX, sigmaY))\n\n            mstore(0x00, 0x01) // store noteType at 0x01\n\n\n\n            // We want to copy note coordinate data into memory from 0x20 - 0xa0\n\n            // 'notes' points to the start of the notes array\n\n            // i.e. notes + 0x20 will point to the start of the data of the first entry\n\n            // first two entries are \\bar{k} and \\bar{a}, which we wish to skip over\n\n            // input note is notes[0] => we need to point to notes + 0x60\n\n            calldatacopy(0x20, add(notes, 0x60), 0x80) // copy gamma, sigma into 0x20 - 0xa0\n\n\n\n            // 0x320 = length of note (0xc0)\n\n            mstore(0x320, 0xc0)\n\n\n\n            // 0x340 = note type (UXTO type, 0x01)\n\n            mstore(0x340, 0x01) // note type\n\n\n\n            // 0x360 = note owners. We want the 1st entry in `noteOwners` (calldataload(noteOwners))\n\n            mstore(0x360, calldataload(noteOwners)) // note owner\n\n\n\n            // 0x380 = note hash, which is the hash of memory from 0x00 - 0xa0\n\n            mstore(0x380, keccak256(0x00, 0xa0)) // note hash\n\n\n\n            // 0x3a0 = noteData length (0x40, no metadata)\n\n            mstore(0x3a0, 0x40)\n\n\n\n            // We now need to store compressed note coordinates.\n\n            // We store them in compressed form, as this stuff will be emitted as an event and is not required\n\n            // for additional smart contract logic. Compressing reduces the event data size and saves a fair bit of gas\n\n\n\n            // To compress, we determine if the y-coordinate is odd.\n\n            // If it is, we set the 256th bit of the x-coordinate to 'true'.\n\n            // bn128 field elements are only 254 bits long, so we know that we won't override x-coordinate data\n\n            // (we already have the note coords in memory, so we load from memory instead of calldata)\n\n\n\n            // 0x3c0 = gamma\n\n            mstore(\n\n                0x3c0,\n\n                or(\n\n                    mload(0x20), // load x coordinate\n\n                    mul(         // multiply by (y & 1 ? 2^255 : 0)\n\n                        and(mload(0x40), 0x01),\n\n                        0x8000000000000000000000000000000000000000000000000000000000000000\n\n                    )\n\n                )\n\n            )\n\n            \n\n            // 0x3e0 = sigma\n\n            mstore(\n\n                0x3e0,\n\n                or(\n\n                    mload(0x60),\n\n                    mul(\n\n                    and(mload(0x80), 0x01),\n\n                    0x8000000000000000000000000000000000000000000000000000000000000000\n\n                    )\n\n                )\n\n            )\n\n\n\n            /**\n\n            * Encoding of output notes\n\n            *\n\n            * abi format is identical to input notes, but now we don't know the total size\n\n            * (because of variable length metadata)\n\n            * 0x00 : 0x20 = byte length of `outputNotes` (0x40 + L)\n\n            * 0x20 : 0x40 = number of output notes (0x01)\n\n            * 0x40 : 0x60 = relative offset to 1st output note (0x60)\n\n            * 0x60 : 0x60 + L    = 1st output note data\n\n            *\n\n            * Start of outputNotes = 0x400\n\n            **/\n\n\n\n            // 0x400 = byte length of output notes. We don't know what this is so leave blank for now\n\n\n\n            // 0x420 = number of output notes (0x01)\n\n            mstore(0x420, 0x01)\n\n\n\n            // 0x440 = relative offset to output note data (0x60)\n\n            mstore(0x440, 0x60)\n\n\n\n            /**\n\n            * Encoding of output note\n\n            * 0x00 : 0x20 = byte length of note (0xc0 + L)\n\n            * 0x20 : 0x40 = note type (UXTO type = 0x01)\n\n            * 0x40 : 0x60 = note owner\n\n            * 0x60 : 0x80 = note hash\n\n            * 0x80 : 0xa0 = note data length (0x40 + L)\n\n            * 0xa0 : 0xc0 = note coordinate 'gamma' (compressed)\n\n            * 0xc0 : 0xe0 = note coordinate 'sigma' (compressed)\n\n            * 0xe0 : 0xe0 + L = note metadata\n\n            *\n\n            * Start of note = 0x460\n\n            * The size of this note = 0xe0 bytes, so we store 0xc0 in the length parameter\n\n            **/\n\n\n\n            // next, copy note coordinates into memory to compute hash.\n\n            // We already stored the noteType at position 0x00, no need to do that again\n\n            // We need to copy data from notes[2].\n\n            // 1. notes + 0x20 = start of 1st entry data\n\n            // 2. size of a note entry = 0xc0 bytes\n\n            // 3. we want to point to 3rd word in our note entry, to skip over \\bar{k}, \\bar{a}\n\n            //    (i.e. add 0x40 to caldlata pointer)\n\n            // => offset = notes + 0x20 + 0x40 + (0xc0 * 2) = notes + 0x1e0\n\n            // => calldata pointer = notes + 0x1e0\n\n            calldatacopy(0x20, add(notes, 0x1e0), 0x80) // get gamma, sigma\n\n\n\n            // 0x460 = byte length of output note. Leave blank for now\n\n\n\n            // 0x480 = note type (0x01)\n\n            mstore(0x480, 0x01)      // note type\n\n\n\n            // 0x4a0 = note owner. We are accessing `notes[2]`, therefore\n\n            // the note owner = noteOwners[2].\n\n            // i.e. noteOwners + 0x40\n\n            mstore(0x4a0, calldataload(add(noteOwners, 0x40))) // note owner\n\n\n\n            // 0x4c0 = note hash\n\n            mstore(0x4c0, keccak256(0x00, 0xa0))\n\n\n\n            // 0x4e0 = noteData length. To get this, we need to identify our metadata length\n\n            // `metadataPtr` points to the relative offset, in the `metadata` array, to the first metadata entry\n\n            // ABI encoding of the input data should encode 2 metadata entries.\n\n            // => relative offset to this note's metadata = `calldataload(metadataPtr)`\n\n            let metadataIndex := calldataload(metadataPtr)\n\n\n\n            // To convert this into a calldata offset, we must add the number of bytes of calldata\n\n            // that preceeds the start of the `metadata` array.\n\n\n\n            // `bytes metadata` abi encoding:\n\n            // 0x00 : 0x20 = size of bytes array\n\n            // 0x20 : 0x40 = number of metadata entries (i)\n\n            // 0x40 : 0x40 + (0x20 * j) = relative offsets to each metadata entry\n\n            // 0x40 + (0x20 * j) : ??? = metadata entries\n\n\n\n            // The `metadata` pointer points to the 3rd word (at 0x40), the 1st relative offset\n\n            // Therefore, to compute the calldata offset to the metadata entry,\n\n            // we need to add `metadataPtr - 0x40` to `calldataload(metadataPtr)`.\n\n            // i.e. metadataCalldataPtr = calldataload(add(sub(metadataPtr, 0x40), metadataIndex))\n\n\n\n            // Because each metadata entry is itself a dynamic bytes array, the first word will\n\n            // be the length of the metadata entry. This is what we want, so we directly call\n\n            // `calldataload` on our offset\n\n            let metadataLength := calldataload(add(sub(metadataPtr, 0x40), metadataIndex))\n\n\n\n            // 0x4e0 = noteData length = 0x40 + metadata length\n\n            mstore(0x4e0, add(0x40, metadataLength))\n\n\n\n            // 0x500 = compressed note coordinate gamma\n\n            mstore(\n\n                0x500,\n\n                or(\n\n                    mload(0x20),\n\n                    mul(\n\n                        and(mload(0x40), 0x01),\n\n                        0x8000000000000000000000000000000000000000000000000000000000000000\n\n                    )\n\n                )\n\n            )\n\n\n\n            // 0x520 = compressed note coordinate sigma\n\n            mstore(\n\n                0x520,\n\n                or(\n\n                    mload(0x60),\n\n                    mul(\n\n                        and(mload(0x80), 0x01),\n\n                        0x8000000000000000000000000000000000000000000000000000000000000000\n\n                    )\n\n                )\n\n            )\n\n            \n\n            // To complete `noteData`, we need to copy note metadata into memory (0x540)\n\n            // We know that metadataIndex + metadataPtr - 0x40 points to the start of the metadata entry in calldata.\n\n            // But the first word is the length of the metadata entry, which we don't want.\n\n            // So we need to point to the second word (the byte array data).\n\n            // i.e. we want to start copying at (metadataIndex + metadataPtr - 0x20)\n\n            // and we want to copy `metadataLength` number of bytes.\n\n            calldatacopy(0x540, add(metadataIndex, sub(metadataPtr, 0x20)), metadataLength)\n\n\n\n            // We now need to work backwards and fill in the parts of `bytes proofOutput` that we left blank,\n\n            // as we now can identify the size of the array\n\n\n\n            // 0x460 points to the size of the output note. The actual size is 0xe0 + metadataLength.\n\n            // So we record 0xc0 + metadataLength\n\n            // (because the 'size' of a byte array does not take into account the word needed to record the size)\n\n            mstore(0x460, add(0xc0, metadataLength))  // update size of note\n\n\n\n            // 0x400 = the size of `bytes outputNotes`.\n\n            // Raw size = 0x140 + metadataLength, so record 0x120 + metadataLength\n\n            mstore(0x400, add(0x120, metadataLength)) // update size of outputNotes\n\n\n\n            // 0x200 = the size of `bytes proofOutput`\n\n            // Raw size = 0x340 + metadataLength, so record 0x340 + metadataLength\n\n            mstore(0x200, add(0x320, metadataLength))\n\n\n\n            // Great! We've now finished writing the 1st proof output.\n\n            // We now need to write the ABI encoding of the 2nd proof output entry.\n\n\n\n            // 0x1e0 points to the relative offset in `bytes proofOutputs` to the second proof entry.\n\n            // This will be equal to the size of the 1st proof, plus the 0x80 preceeding bytes\n\n            // that are used to record `bytes proofOutputs`\n\n            // i.e. relative offset = 0x340 + 0x80 + metadataLength = 0x3c0 + metadataLength\n\n            mstore(0x1e0, add(0x3c0, metadataLength))\n\n\n\n            /** \n\n            * proofOutput[1]\n\n            **/\n\n\n\n            // When writing data into proofOutputs[1], we cannot use an absolute offset as \n\n            // metadataLength is not known at compile time.\n\n            // `proofPtr` points to the start of `proofOutputs[1]`\n\n            let proofPtr := add(0x540, metadataLength)\n\n\n\n            // (proofPtr) = size of proofOutput (leave blank for now)\n\n\n\n            // (proofPtr + 0x20) = offset to inputNotes (0xc0)\n\n            mstore(add(proofPtr, 0x20), 0xc0)\n\n\n\n            // (proofPtr + 0x40) = offset to outputNotes (0x200)\n\n            mstore(add(proofPtr, 0x40), 0x200)\n\n\n\n            // (proofPtr + 0x60) = publicOwner (0)\n\n            mstore(add(proofPtr, 0x60), 0x00) // publicOwner\n\n\n\n            // (proofPtr + 0x80) = publicValue (0)\n\n            mstore(add(proofPtr, 0x80), 0x00) // publicValue\n\n\n\n            // (proofPtr + 0xa0) = challenge\n\n            // we hash the challenge to get the second proof output's challenge - to preserve uniqueness\n\n            mstore(0xe0, calldataload(0x124))\n\n            mstore(add(proofPtr, 0xa0), keccak256(0xe0, 0x20)) // challenge\n\n\n\n            /** \n\n            * proofOutput[1].inputNotes\n\n            *\n\n            * starts at (proofPtr + 0xc0)\n\n            **/\n\n\n\n            // (proofPtr + 0xc0) = byte size of inputNotes (0x120)\n\n            mstore(add(proofPtr, 0xc0), 0x120)\n\n\n\n            // (proofPtr + 0xe0) = number of input notes (0x01)\n\n            mstore(add(proofPtr, 0xe0), 0x01)\n\n\n\n            // (proofPtr + 0x100) = relative offset to input note data (0x60)\n\n            mstore(add(proofPtr, 0x100), 0x60)\n\n\n\n            /** \n\n            * proofOutput[1].inputNotes[0]\n\n            *\n\n            * starts at (proofPtr + 0x120)\n\n            **/\n\n\n\n            // input note = notes[3]\n\n            // => offset = notes + 0x60 + (0xc0 * 3) = notes + 0x2a0\n\n            // copy note data into scratch memory to hash\n\n            calldatacopy(0x20, add(notes, 0x2a0), 0x80)\n\n\n\n            // (proofPtr + 0x120) = byte length of input note (0xc0)\n\n            mstore(add(proofPtr, 0x120), 0xc0) // length of input note\n\n\n\n            // (proofPtr + 0x140) = note type (UXTO type, 0x01)\n\n            mstore(add(proofPtr, 0x140), 0x01) // note type\n\n\n\n            // (proofPtr + 0x160) = note owner = noteOwners[3]\n\n            mstore(add(proofPtr, 0x160), calldataload(add(noteOwners, 0x60))) // note owner\n\n\n\n            // (proofPtr + 0x180) = note hash\n\n            mstore(add(proofPtr, 0x180), keccak256(0x00, 0xa0)) // note hash\n\n\n\n            // (proofPtr + 0x1a0) = noteData length (0x40 bytes)\n\n            mstore(add(proofPtr, 0x1a0), 0x40)\n\n\n\n            // (proofPtr + 0x1c0) = compressed coordinate 'gamma'\n\n            mstore(\n\n                add(proofPtr, 0x1c0),\n\n                or(\n\n                    mload(0x20),\n\n                    mul(\n\n                        and(mload(0x40), 0x01),\n\n                        0x8000000000000000000000000000000000000000000000000000000000000000\n\n                    )\n\n                )\n\n            )\n\n\n\n            // (proofPtr + 0x1e0) = compressed coordinate 'sigma'\n\n            mstore(\n\n                add(proofPtr, 0x1e0),\n\n                or(\n\n                    mload(0x60),\n\n                    mul(\n\n                        and(mload(0x80), 0x01),\n\n                        0x8000000000000000000000000000000000000000000000000000000000000000\n\n                    )\n\n                )\n\n            )\n\n\n\n            /** \n\n            * proofOutput[1].outputNotes\n\n            *\n\n            * starts at (proofPtr + 0x200)\n\n            **/\n\n\n\n            // (proofPtr + 0x200) = byte length of output notes, leave blank for now\n\n\n\n            // (proofPtr + 0x220) = number of output notes (0x01)\n\n            mstore(add(proofPtr, 0x220), 0x01)\n\n\n\n            // (proofPtr + 0x240) = offset to output notes (0x60)\n\n            mstore(add(proofPtr, 0x240), 0x60)\n\n\n\n            /** \n\n            * proofOutput[1].outputNotes[0]\n\n            *\n\n            * starts at (proofPtr + 0x260)\n\n            **/\n\n            // output note = notes[1]\n\n            // => offset = notes + 0x60 + 0xc0 = notes + 0x120\n\n            // copy note data into scratch memory to hash\n\n            calldatacopy(0x20, add(notes, 0x120), 0x80)\n\n\n\n            // (proofPtr + 0x260) = length of note, leave blank for now\n\n\n\n            // (proofPtr + 0x280) = note type (UXTO type, 0x01)\n\n            mstore(add(proofPtr, 0x280), 0x01) // note type\n\n\n\n            // (proofPtr + 0x2a0) = note owner (noteOwners[1])\n\n            mstore(add(proofPtr, 0x2a0), calldataload(add(noteOwners, 0x20)))\n\n\n\n            // (proofPtr + 0x2c0) = note hash\n\n            mstore(add(proofPtr, 0x2c0), keccak256(0x00, 0xa0))\n\n\n\n            // We now need to compute the metadata length. We want to access the 2nd metadata entry,\n\n            // at (metadataPtr + 0x20)\n\n            metadataIndex := calldataload(add(metadataPtr, 0x20))\n\n            metadataLength := calldataload(add(sub(metadataPtr, 0x40), metadataIndex))\n\n\n\n            // (proofPtr + 0x2e0) = noteData length (0x40 + metadataLength)\n\n            mstore(add(proofPtr, 0x2e0), add(0x40, metadataLength))\n\n\n\n            // (proofPtr + 0x300) = compressed coordinate 'gamma'\n\n            mstore(\n\n                add(proofPtr, 0x300),\n\n                or(\n\n                    mload(0x20),\n\n                    mul(\n\n                        and(mload(0x40), 0x01),\n\n                        0x8000000000000000000000000000000000000000000000000000000000000000\n\n                    )\n\n                )\n\n            )\n\n\n\n            // (proofPtr + 0x320) = compressed coordinate 'sigma'\n\n            mstore(\n\n                add(proofPtr, 0x320),\n\n                or(\n\n                    mload(0x60),\n\n                    mul(\n\n                        and(mload(0x80), 0x01),\n\n                        0x8000000000000000000000000000000000000000000000000000000000000000\n\n                    )\n\n                )\n\n            )\n\n\n\n            // (proofPtr + 0x340) = start of note metadata\n\n            calldatacopy(add(proofPtr, 0x340), add(metadataIndex, sub(metadataPtr, 0x20)), metadataLength)\n\n\n\n            // Next, work backwards and fill in the remaining gaps\n\n            // (proofPtr + 0x260) = proofOutputs[1].outputNotes[0].length (0xc0 + metadataLength)\n\n            mstore(add(proofPtr, 0x260), add(0xc0, metadataLength))\n\n\n\n            // (proofPtr + 0x200) = proofOutputs[1].outputNotes.length (0x120 + metadataLength)\n\n            mstore(add(proofPtr, 0x200), add(0x120, metadataLength))\n\n\n\n            // (proofPtr) = proofOutputs[1].length = (0x320 + metadataLength)\n\n            mstore(proofPtr, add(0x320, metadataLength))\n\n\n\n            // (0x180) = proofOutputs.length\n\n            // We previously stored proofOutputs[0].length at 0x200\n\n            // Total length = combination of\n\n            // 1. proofOutputs[0].length + 0x20 (extra word because of length variable)\n\n            // 2. proofOutputs[1].length + 0x20 (^^)\n\n            // 3. data to record relative offsets (0x20 * number of outputs) = (0x40)\n\n            // 4. data to record number of entries (0x20)\n\n            \n\n            // We stored proofOutputs[0].length at 0x200\n\n            // and we know that proofOutputs[1].length = 0x320 + metadataLength\n\n            // => length = mload(0x200) + metadataLength + 0x320 + 0x40 + 0x40 + 0x20\n\n            // => length = mload(0x200) + metadataLength + 0x3c0\n\n            mstore(0x180, add(add(0x3c0, metadataLength), mload(0x200)))\n\n\n\n            // Great, we've done it! Now all that is left is to return from this transaction.\n\n            // Our return data starts at 0x160.\n\n            // Total size of `bytes proofOutpust` = proofOutputs.length + 0x20\n\n            // We need 1 extra word (at 0x160) for the relative offset to get to `bytes proofOutputs`\n\n            // => returndata size = proofOutputs.length + 0x40\n\n            // = mload(0x180) + 0x40\n\n            return(0x160, add(mload(0x180), 0x40)) // *kazoo noises*\n\n        }\n",
          "message": "BilateralSwapABIEncoder.encodeAndExit (BilateralSwapABIEncoderTest.sol#38-604) is declared view but contains assembly code\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 38,
          "vulnerability_to_line": 604,
          "vulnerability_code": "    function encodeAndExit() internal pure {\n\n        assembly {\n\n            // set up initial variables\n\n            let notes := add(0x104, calldataload(0x144))\n\n            let noteOwners := add(0x124, calldataload(0x164)) // // one word after inputOwners = 1st\n\n            let metadataPtr := add(0x144, calldataload(0x184)) // two words after metadata = 1st\n\n\n\n            // First up, we need to do some checks to ensure we have been provided with correct data.\n\n            // We should only have 2 entries inside `bytes metadata` (only 2 output notes in total),\n\n            // and only 4 entries inside `noteOwners` (4 notes in bilateral swap proof)\n\n            if iszero(and(\n\n                eq(0x02, calldataload(sub(metadataPtr, 0x20))),\n\n                eq(0x04, calldataload(sub(noteOwners, 0x20)))\n\n            )) {\n\n                revert(0x00, 0x00) // no! bad! come back with good inputs!\n\n            }\n\n\n\n            // memory map of `proofOutputs`\n\n            // 0x00 - 0x160  = scratch data for note hash computation\n\n\n\n            // `returndata` starts at 0x160\n\n            // `proofOutputs` starts at 0x180\n\n            // 0x160 - 0x180 = relative offset in returndata to first bytes argument (0x20)\n\n            // 0x180 - 0x1a0 = byte length of `proofOutputs`\n\n            // 0x1a0 - 0x1c0 = number of `proofOutputs` entries (2)\n\n            // 0x1c0 - 0x1e0 = relative memory offset between `v` and start of `proofOutputs[0]` (0x80)\n\n            // 0x1e0 - 0x200 = relative memory offset between `v` and start of `proofOutputs[1]`\n\n    \n\n            // `proofOutput` - t, starts at 0x200\n\n            // 0x200 - 0x220 = length of `proofOutput`\n\n            // 0x220 - 0x240 = relative offset between `t` and `inputNotes`\n\n            // 0x240 - 0x260 = relative offset between `t` and `outputNotes`\n\n            // 0x260 - 0x280 = `publicOwner`\n\n            // 0x280 - 0x2a0 = `publicValue`\n\n            // 0x2a0 - 0x2c0 = `challenge`\n\n\n\n            // `inputNotes` starts at 0x2c0\n\n            // structure of `inputNotes` and `outputNotes`\n\n            // 0x00 - 0x20 = byte length of notes array\n\n            // 0x20 - 0x40 = number of notes = 1\n\n            // 0x40 - 0x60 = offset to start of input note (0x60)\n\n\n\n            // structure of a `note`\n\n            // 0x00 - 0x20 = size of `note`\n\n            // 0x20 - 0x40 = `owner`\n\n            // 0x40 - 0x60 = `noteHash`\n\n            // 0x60 - 0x80 = size of note `data`\n\n            // 0x80 - 0xa0 = compressed note coordinate `gamma` (part of `data`)\n\n            // 0xa0 - 0xc0 = compressed note coordinate `sigma` (part of `data`)\n\n            // 0xc0 - ???? = remaining note metadata\n\n\n\n            // Note organisation...\n\n            // The bilateral swap proof proves the following:\n\n            //   1. note[0].value == note[2].value\n\n            //   2. note[1].value == note[3].value\n\n            // In other words...\n\n            // note[0] = maker bid note\n\n            // note[1] = maker ask note\n\n            // note[2] = taker ask note\n\n            // note[3] = taker bid note\n\n\n\n            // We therefore have 2 balancing relationships\n\n            // 1. The maker bid note is destroyed and replaced with the taker ask note\n\n            // 2. The taker bid note is destroyed and replaced with the maker ask note\n\n\n\n            // Finally, we can translate this into 2 proofOutputs entries...\n\n            // In the first entry, `inputNotes` = [note[0]] and `outputNotes` = [note[2]]\n\n            // In the second entry, `inputNotes` = [note[3]] and `outputNotes` = [note[1]]\n\n\n\n            // `proofOutputs` must form a monolithic block of memory that we can return.\n\n            // `s` points to the memory location of the start of the current note\n\n            // `inputPtr` points to the start of the current `notes` dynamic bytes array\n\n\n\n            // length of proofOutputs is at 0x180\n\n\n\n            // we use memory from 0x00 - 0x140 as scratch memory\n\n\n\n            // return data starts at 0x160. As return data is `bytes proofOutputs`,\n\n            // the first word is the relative offset to the start of `proofOutputs` (i.e. 0x20)\n\n            mstore(0x160, 0x20)\n\n\n\n            /**\n\n            * Encoding of proofOutputs\n\n            * abi encoding of proofOutputs\n\n            * 0x00 : 0x20 = byte length of `proofOutputs` = 0x60 + L1 + L2\n\n            * 0x20 : 0x40 = number of `proofOutputs` entries (2)\n\n            * 0x40 : 0x60 = relative memory offset between `v` and start of `proofOutputs[0]` (0x80)\n\n            * 0x60 : 0x80 = relative memory offset between `v` and start of `proofOutputs[1]`\n\n            * 0x80 : 0x80 + L1    = start of proofOutputs[0]\n\n            * 0x80 + L1   : 0x80 + L1 + L2 = start of proofOutputs[1]\n\n            **/\n\n        \n\n            // 0x180 stores the total size of `bytes proofOutputs`. We don't know that yet, so leave blank\n\n\n\n            // 0x1a0 = number of proof outputs (2)\n\n            mstore(0x1a0, 0x02)                            // number of proofs\n\n\n\n            // 0x1c0 = relative offset to 1st entry (0x80, 4 words)\n\n            mstore(0x1c0, 0x80)                            // offset to 1st proof\n\n\n\n            /**\n\n            * Encoding of proofOutput\n\n            * 0x00 : 0x20 = byte length of `proofOutput` = 0x60 + L1 + L2\n\n            * 0x20 : 0x40 = relative offset to `bytes inputNotes`\n\n            * 0x40 : 0x60 = relative offset to `bytes outputNotes`\n\n            * 0x60 : 0x80 = publicOwner\n\n            * 0x80 : 0xa0 = publicValue\n\n            * 0xa0 : 0xc0 = challenge\n\n            * 0xc0 : 0xc0 + L1 = `bytes inputNotes` (L1 = 0x140 bytes)\n\n            * 0xc0 + L1 : 0xc0 + L1 + L2 = `bytes inputNotes`\n\n            *\n\n            * Start of proofOutput = 0x200\n\n            **/\n\n\n\n            // length of proofOutput is at 0x200. We don't know that yet, so leave blank\n\n\n\n            // relative offset to inputNotes = 0xc0 (6 words)\n\n            mstore(0x220, 0xc0)                            // location of inputNotes\n\n\n\n            // we know that inputNotes has 1 entry, and input notes don't have metadata.\n\n            // So we actually know the complete size of `bytes inputNotes`\n\n            // (it's 0x140 bytes, we'll get to that in a bit)\n\n            // => relative offset to outputNotes = 0x140 + 0xc0 = 0x200\n\n            mstore(0x240, 0x200)                           // location of outputNotes\n\n\n\n            // bilateral swap proof hardcodes `publicOwner` and `publicValue` to 0 (no public tokens)\n\n            mstore(0x260, 0x00)                             // publicOwner\n\n            mstore(0x280, 0x00)                             // publicValue\n\n            mstore(0x2a0, calldataload(0x124))              // challenge\n\n            /**\n\n            * Encoding of inputNotes\n\n            * 0x00 : 0x20 = byte length of `inputNotes` (0x120)\n\n            * 0x20 : 0x40 = number of input notes (0x01)\n\n            * 0x40 : 0x60 = relative offset to 1st input note (0x60)\n\n            * 0x60 : L    = 1st input note data (L = 0xe0)\n\n            *\n\n            * Start of inputNotes = 0x2a0\n\n            * Because we only have 1 note in this array, and that note has no metadata\n\n            * we know that the size of the note is 0xe0 bytes\n\n            * therefore, the size of inputNotes = 0xe0 + 3 words = 0x140 bytes.\n\n            * We store the byte length as 0x120 bytes because the length parameter\n\n            * of a dynamic bytes array does not include itself in the length calculation\n\n            **/\n\n\n\n            // 0x2c0 = length of inputNotes = 0x120\n\n            mstore(0x2c0, 0x120)\n\n\n\n            // 0x2e0 = number of notes (1)\n\n            mstore(0x2e0, 0x01) // 1 input note\n\n\n\n            // 0x300 = relative offset to input note (0x60)\n\n            mstore(0x300, 0x60) // relative offset to note data\n\n\n\n            /**\n\n            * Encoding of input note\n\n            * 0x00 : 0x20 = byte length of note (0xc0)\n\n            * 0x20 : 0x40 = note type (UXTO type = 0x01)\n\n            * 0x40 : 0x60 = note owner\n\n            * 0x60 : 0x80 = note hash\n\n            * 0x80 : 0xa0 = note data length (0x40)\n\n            * 0xa0 : 0xc0 = note coordinate 'gamma' (compressed)\n\n            * 0xc0 : 0xe0 = note coordinate 'sigma' (compressed)\n\n            *\n\n            * Start of note = 0x320\n\n            * The size of this note = 0xe0 bytes, so we store 0xc0 in the length parameter\n\n            **/\n\n\n\n            // we use memory from 0x00 - 0xa0 as scratch memory to compute note hash\n\n            // Note hash = keccak256(abi.encode(noteType, gammaX, gammaY, sigmaX, sigmaY))\n\n            mstore(0x00, 0x01) // store noteType at 0x01\n\n\n\n            // We want to copy note coordinate data into memory from 0x20 - 0xa0\n\n            // 'notes' points to the start of the notes array\n\n            // i.e. notes + 0x20 will point to the start of the data of the first entry\n\n            // first two entries are \\bar{k} and \\bar{a}, which we wish to skip over\n\n            // input note is notes[0] => we need to point to notes + 0x60\n\n            calldatacopy(0x20, add(notes, 0x60), 0x80) // copy gamma, sigma into 0x20 - 0xa0\n\n\n\n            // 0x320 = length of note (0xc0)\n\n            mstore(0x320, 0xc0)\n\n\n\n            // 0x340 = note type (UXTO type, 0x01)\n\n            mstore(0x340, 0x01) // note type\n\n\n\n            // 0x360 = note owners. We want the 1st entry in `noteOwners` (calldataload(noteOwners))\n\n            mstore(0x360, calldataload(noteOwners)) // note owner\n\n\n\n            // 0x380 = note hash, which is the hash of memory from 0x00 - 0xa0\n\n            mstore(0x380, keccak256(0x00, 0xa0)) // note hash\n\n\n\n            // 0x3a0 = noteData length (0x40, no metadata)\n\n            mstore(0x3a0, 0x40)\n\n\n\n            // We now need to store compressed note coordinates.\n\n            // We store them in compressed form, as this stuff will be emitted as an event and is not required\n\n            // for additional smart contract logic. Compressing reduces the event data size and saves a fair bit of gas\n\n\n\n            // To compress, we determine if the y-coordinate is odd.\n\n            // If it is, we set the 256th bit of the x-coordinate to 'true'.\n\n            // bn128 field elements are only 254 bits long, so we know that we won't override x-coordinate data\n\n            // (we already have the note coords in memory, so we load from memory instead of calldata)\n\n\n\n            // 0x3c0 = gamma\n\n            mstore(\n\n                0x3c0,\n\n                or(\n\n                    mload(0x20), // load x coordinate\n\n                    mul(         // multiply by (y & 1 ? 2^255 : 0)\n\n                        and(mload(0x40), 0x01),\n\n                        0x8000000000000000000000000000000000000000000000000000000000000000\n\n                    )\n\n                )\n\n            )\n\n            \n\n            // 0x3e0 = sigma\n\n            mstore(\n\n                0x3e0,\n\n                or(\n\n                    mload(0x60),\n\n                    mul(\n\n                    and(mload(0x80), 0x01),\n\n                    0x8000000000000000000000000000000000000000000000000000000000000000\n\n                    )\n\n                )\n\n            )\n\n\n\n            /**\n\n            * Encoding of output notes\n\n            *\n\n            * abi format is identical to input notes, but now we don't know the total size\n\n            * (because of variable length metadata)\n\n            * 0x00 : 0x20 = byte length of `outputNotes` (0x40 + L)\n\n            * 0x20 : 0x40 = number of output notes (0x01)\n\n            * 0x40 : 0x60 = relative offset to 1st output note (0x60)\n\n            * 0x60 : 0x60 + L    = 1st output note data\n\n            *\n\n            * Start of outputNotes = 0x400\n\n            **/\n\n\n\n            // 0x400 = byte length of output notes. We don't know what this is so leave blank for now\n\n\n\n            // 0x420 = number of output notes (0x01)\n\n            mstore(0x420, 0x01)\n\n\n\n            // 0x440 = relative offset to output note data (0x60)\n\n            mstore(0x440, 0x60)\n\n\n\n            /**\n\n            * Encoding of output note\n\n            * 0x00 : 0x20 = byte length of note (0xc0 + L)\n\n            * 0x20 : 0x40 = note type (UXTO type = 0x01)\n\n            * 0x40 : 0x60 = note owner\n\n            * 0x60 : 0x80 = note hash\n\n            * 0x80 : 0xa0 = note data length (0x40 + L)\n\n            * 0xa0 : 0xc0 = note coordinate 'gamma' (compressed)\n\n            * 0xc0 : 0xe0 = note coordinate 'sigma' (compressed)\n\n            * 0xe0 : 0xe0 + L = note metadata\n\n            *\n\n            * Start of note = 0x460\n\n            * The size of this note = 0xe0 bytes, so we store 0xc0 in the length parameter\n\n            **/\n\n\n\n            // next, copy note coordinates into memory to compute hash.\n\n            // We already stored the noteType at position 0x00, no need to do that again\n\n            // We need to copy data from notes[2].\n\n            // 1. notes + 0x20 = start of 1st entry data\n\n            // 2. size of a note entry = 0xc0 bytes\n\n            // 3. we want to point to 3rd word in our note entry, to skip over \\bar{k}, \\bar{a}\n\n            //    (i.e. add 0x40 to caldlata pointer)\n\n            // => offset = notes + 0x20 + 0x40 + (0xc0 * 2) = notes + 0x1e0\n\n            // => calldata pointer = notes + 0x1e0\n\n            calldatacopy(0x20, add(notes, 0x1e0), 0x80) // get gamma, sigma\n\n\n\n            // 0x460 = byte length of output note. Leave blank for now\n\n\n\n            // 0x480 = note type (0x01)\n\n            mstore(0x480, 0x01)      // note type\n\n\n\n            // 0x4a0 = note owner. We are accessing `notes[2]`, therefore\n\n            // the note owner = noteOwners[2].\n\n            // i.e. noteOwners + 0x40\n\n            mstore(0x4a0, calldataload(add(noteOwners, 0x40))) // note owner\n\n\n\n            // 0x4c0 = note hash\n\n            mstore(0x4c0, keccak256(0x00, 0xa0))\n\n\n\n            // 0x4e0 = noteData length. To get this, we need to identify our metadata length\n\n            // `metadataPtr` points to the relative offset, in the `metadata` array, to the first metadata entry\n\n            // ABI encoding of the input data should encode 2 metadata entries.\n\n            // => relative offset to this note's metadata = `calldataload(metadataPtr)`\n\n            let metadataIndex := calldataload(metadataPtr)\n\n\n\n            // To convert this into a calldata offset, we must add the number of bytes of calldata\n\n            // that preceeds the start of the `metadata` array.\n\n\n\n            // `bytes metadata` abi encoding:\n\n            // 0x00 : 0x20 = size of bytes array\n\n            // 0x20 : 0x40 = number of metadata entries (i)\n\n            // 0x40 : 0x40 + (0x20 * j) = relative offsets to each metadata entry\n\n            // 0x40 + (0x20 * j) : ??? = metadata entries\n\n\n\n            // The `metadata` pointer points to the 3rd word (at 0x40), the 1st relative offset\n\n            // Therefore, to compute the calldata offset to the metadata entry,\n\n            // we need to add `metadataPtr - 0x40` to `calldataload(metadataPtr)`.\n\n            // i.e. metadataCalldataPtr = calldataload(add(sub(metadataPtr, 0x40), metadataIndex))\n\n\n\n            // Because each metadata entry is itself a dynamic bytes array, the first word will\n\n            // be the length of the metadata entry. This is what we want, so we directly call\n\n            // `calldataload` on our offset\n\n            let metadataLength := calldataload(add(sub(metadataPtr, 0x40), metadataIndex))\n\n\n\n            // 0x4e0 = noteData length = 0x40 + metadata length\n\n            mstore(0x4e0, add(0x40, metadataLength))\n\n\n\n            // 0x500 = compressed note coordinate gamma\n\n            mstore(\n\n                0x500,\n\n                or(\n\n                    mload(0x20),\n\n                    mul(\n\n                        and(mload(0x40), 0x01),\n\n                        0x8000000000000000000000000000000000000000000000000000000000000000\n\n                    )\n\n                )\n\n            )\n\n\n\n            // 0x520 = compressed note coordinate sigma\n\n            mstore(\n\n                0x520,\n\n                or(\n\n                    mload(0x60),\n\n                    mul(\n\n                        and(mload(0x80), 0x01),\n\n                        0x8000000000000000000000000000000000000000000000000000000000000000\n\n                    )\n\n                )\n\n            )\n\n            \n\n            // To complete `noteData`, we need to copy note metadata into memory (0x540)\n\n            // We know that metadataIndex + metadataPtr - 0x40 points to the start of the metadata entry in calldata.\n\n            // But the first word is the length of the metadata entry, which we don't want.\n\n            // So we need to point to the second word (the byte array data).\n\n            // i.e. we want to start copying at (metadataIndex + metadataPtr - 0x20)\n\n            // and we want to copy `metadataLength` number of bytes.\n\n            calldatacopy(0x540, add(metadataIndex, sub(metadataPtr, 0x20)), metadataLength)\n\n\n\n            // We now need to work backwards and fill in the parts of `bytes proofOutput` that we left blank,\n\n            // as we now can identify the size of the array\n\n\n\n            // 0x460 points to the size of the output note. The actual size is 0xe0 + metadataLength.\n\n            // So we record 0xc0 + metadataLength\n\n            // (because the 'size' of a byte array does not take into account the word needed to record the size)\n\n            mstore(0x460, add(0xc0, metadataLength))  // update size of note\n\n\n\n            // 0x400 = the size of `bytes outputNotes`.\n\n            // Raw size = 0x140 + metadataLength, so record 0x120 + metadataLength\n\n            mstore(0x400, add(0x120, metadataLength)) // update size of outputNotes\n\n\n\n            // 0x200 = the size of `bytes proofOutput`\n\n            // Raw size = 0x340 + metadataLength, so record 0x340 + metadataLength\n\n            mstore(0x200, add(0x320, metadataLength))\n\n\n\n            // Great! We've now finished writing the 1st proof output.\n\n            // We now need to write the ABI encoding of the 2nd proof output entry.\n\n\n\n            // 0x1e0 points to the relative offset in `bytes proofOutputs` to the second proof entry.\n\n            // This will be equal to the size of the 1st proof, plus the 0x80 preceeding bytes\n\n            // that are used to record `bytes proofOutputs`\n\n            // i.e. relative offset = 0x340 + 0x80 + metadataLength = 0x3c0 + metadataLength\n\n            mstore(0x1e0, add(0x3c0, metadataLength))\n\n\n\n            /** \n\n            * proofOutput[1]\n\n            **/\n\n\n\n            // When writing data into proofOutputs[1], we cannot use an absolute offset as \n\n            // metadataLength is not known at compile time.\n\n            // `proofPtr` points to the start of `proofOutputs[1]`\n\n            let proofPtr := add(0x540, metadataLength)\n\n\n\n            // (proofPtr) = size of proofOutput (leave blank for now)\n\n\n\n            // (proofPtr + 0x20) = offset to inputNotes (0xc0)\n\n            mstore(add(proofPtr, 0x20), 0xc0)\n\n\n\n            // (proofPtr + 0x40) = offset to outputNotes (0x200)\n\n            mstore(add(proofPtr, 0x40), 0x200)\n\n\n\n            // (proofPtr + 0x60) = publicOwner (0)\n\n            mstore(add(proofPtr, 0x60), 0x00) // publicOwner\n\n\n\n            // (proofPtr + 0x80) = publicValue (0)\n\n            mstore(add(proofPtr, 0x80), 0x00) // publicValue\n\n\n\n            // (proofPtr + 0xa0) = challenge\n\n            // we hash the challenge to get the second proof output's challenge - to preserve uniqueness\n\n            mstore(0xe0, calldataload(0x124))\n\n            mstore(add(proofPtr, 0xa0), keccak256(0xe0, 0x20)) // challenge\n\n\n\n            /** \n\n            * proofOutput[1].inputNotes\n\n            *\n\n            * starts at (proofPtr + 0xc0)\n\n            **/\n\n\n\n            // (proofPtr + 0xc0) = byte size of inputNotes (0x120)\n\n            mstore(add(proofPtr, 0xc0), 0x120)\n\n\n\n            // (proofPtr + 0xe0) = number of input notes (0x01)\n\n            mstore(add(proofPtr, 0xe0), 0x01)\n\n\n\n            // (proofPtr + 0x100) = relative offset to input note data (0x60)\n\n            mstore(add(proofPtr, 0x100), 0x60)\n\n\n\n            /** \n\n            * proofOutput[1].inputNotes[0]\n\n            *\n\n            * starts at (proofPtr + 0x120)\n\n            **/\n\n\n\n            // input note = notes[3]\n\n            // => offset = notes + 0x60 + (0xc0 * 3) = notes + 0x2a0\n\n            // copy note data into scratch memory to hash\n\n            calldatacopy(0x20, add(notes, 0x2a0), 0x80)\n\n\n\n            // (proofPtr + 0x120) = byte length of input note (0xc0)\n\n            mstore(add(proofPtr, 0x120), 0xc0) // length of input note\n\n\n\n            // (proofPtr + 0x140) = note type (UXTO type, 0x01)\n\n            mstore(add(proofPtr, 0x140), 0x01) // note type\n\n\n\n            // (proofPtr + 0x160) = note owner = noteOwners[3]\n\n            mstore(add(proofPtr, 0x160), calldataload(add(noteOwners, 0x60))) // note owner\n\n\n\n            // (proofPtr + 0x180) = note hash\n\n            mstore(add(proofPtr, 0x180), keccak256(0x00, 0xa0)) // note hash\n\n\n\n            // (proofPtr + 0x1a0) = noteData length (0x40 bytes)\n\n            mstore(add(proofPtr, 0x1a0), 0x40)\n\n\n\n            // (proofPtr + 0x1c0) = compressed coordinate 'gamma'\n\n            mstore(\n\n                add(proofPtr, 0x1c0),\n\n                or(\n\n                    mload(0x20),\n\n                    mul(\n\n                        and(mload(0x40), 0x01),\n\n                        0x8000000000000000000000000000000000000000000000000000000000000000\n\n                    )\n\n                )\n\n            )\n\n\n\n            // (proofPtr + 0x1e0) = compressed coordinate 'sigma'\n\n            mstore(\n\n                add(proofPtr, 0x1e0),\n\n                or(\n\n                    mload(0x60),\n\n                    mul(\n\n                        and(mload(0x80), 0x01),\n\n                        0x8000000000000000000000000000000000000000000000000000000000000000\n\n                    )\n\n                )\n\n            )\n\n\n\n            /** \n\n            * proofOutput[1].outputNotes\n\n            *\n\n            * starts at (proofPtr + 0x200)\n\n            **/\n\n\n\n            // (proofPtr + 0x200) = byte length of output notes, leave blank for now\n\n\n\n            // (proofPtr + 0x220) = number of output notes (0x01)\n\n            mstore(add(proofPtr, 0x220), 0x01)\n\n\n\n            // (proofPtr + 0x240) = offset to output notes (0x60)\n\n            mstore(add(proofPtr, 0x240), 0x60)\n\n\n\n            /** \n\n            * proofOutput[1].outputNotes[0]\n\n            *\n\n            * starts at (proofPtr + 0x260)\n\n            **/\n\n            // output note = notes[1]\n\n            // => offset = notes + 0x60 + 0xc0 = notes + 0x120\n\n            // copy note data into scratch memory to hash\n\n            calldatacopy(0x20, add(notes, 0x120), 0x80)\n\n\n\n            // (proofPtr + 0x260) = length of note, leave blank for now\n\n\n\n            // (proofPtr + 0x280) = note type (UXTO type, 0x01)\n\n            mstore(add(proofPtr, 0x280), 0x01) // note type\n\n\n\n            // (proofPtr + 0x2a0) = note owner (noteOwners[1])\n\n            mstore(add(proofPtr, 0x2a0), calldataload(add(noteOwners, 0x20)))\n\n\n\n            // (proofPtr + 0x2c0) = note hash\n\n            mstore(add(proofPtr, 0x2c0), keccak256(0x00, 0xa0))\n\n\n\n            // We now need to compute the metadata length. We want to access the 2nd metadata entry,\n\n            // at (metadataPtr + 0x20)\n\n            metadataIndex := calldataload(add(metadataPtr, 0x20))\n\n            metadataLength := calldataload(add(sub(metadataPtr, 0x40), metadataIndex))\n\n\n\n            // (proofPtr + 0x2e0) = noteData length (0x40 + metadataLength)\n\n            mstore(add(proofPtr, 0x2e0), add(0x40, metadataLength))\n\n\n\n            // (proofPtr + 0x300) = compressed coordinate 'gamma'\n\n            mstore(\n\n                add(proofPtr, 0x300),\n\n                or(\n\n                    mload(0x20),\n\n                    mul(\n\n                        and(mload(0x40), 0x01),\n\n                        0x8000000000000000000000000000000000000000000000000000000000000000\n\n                    )\n\n                )\n\n            )\n\n\n\n            // (proofPtr + 0x320) = compressed coordinate 'sigma'\n\n            mstore(\n\n                add(proofPtr, 0x320),\n\n                or(\n\n                    mload(0x60),\n\n                    mul(\n\n                        and(mload(0x80), 0x01),\n\n                        0x8000000000000000000000000000000000000000000000000000000000000000\n\n                    )\n\n                )\n\n            )\n\n\n\n            // (proofPtr + 0x340) = start of note metadata\n\n            calldatacopy(add(proofPtr, 0x340), add(metadataIndex, sub(metadataPtr, 0x20)), metadataLength)\n\n\n\n            // Next, work backwards and fill in the remaining gaps\n\n            // (proofPtr + 0x260) = proofOutputs[1].outputNotes[0].length (0xc0 + metadataLength)\n\n            mstore(add(proofPtr, 0x260), add(0xc0, metadataLength))\n\n\n\n            // (proofPtr + 0x200) = proofOutputs[1].outputNotes.length (0x120 + metadataLength)\n\n            mstore(add(proofPtr, 0x200), add(0x120, metadataLength))\n\n\n\n            // (proofPtr) = proofOutputs[1].length = (0x320 + metadataLength)\n\n            mstore(proofPtr, add(0x320, metadataLength))\n\n\n\n            // (0x180) = proofOutputs.length\n\n            // We previously stored proofOutputs[0].length at 0x200\n\n            // Total length = combination of\n\n            // 1. proofOutputs[0].length + 0x20 (extra word because of length variable)\n\n            // 2. proofOutputs[1].length + 0x20 (^^)\n\n            // 3. data to record relative offsets (0x20 * number of outputs) = (0x40)\n\n            // 4. data to record number of entries (0x20)\n\n            \n\n            // We stored proofOutputs[0].length at 0x200\n\n            // and we know that proofOutputs[1].length = 0x320 + metadataLength\n\n            // => length = mload(0x200) + metadataLength + 0x320 + 0x40 + 0x40 + 0x20\n\n            // => length = mload(0x200) + metadataLength + 0x3c0\n\n            mstore(0x180, add(add(0x3c0, metadataLength), mload(0x200)))\n\n\n\n            // Great, we've done it! Now all that is left is to return from this transaction.\n\n            // Our return data starts at 0x160.\n\n            // Total size of `bytes proofOutpust` = proofOutputs.length + 0x20\n\n            // We need 1 extra word (at 0x160) for the relative offset to get to `bytes proofOutputs`\n\n            // => returndata size = proofOutputs.length + 0x40\n\n            // = mload(0x180) + 0x40\n\n            return(0x160, add(mload(0x180), 0x40)) // *kazoo noises*\n\n        }\n",
          "message": "BilateralSwapABIEncoder.encodeAndExit uses assembly (BilateralSwapABIEncoderTest.sol#38-604)\n\t- BilateralSwapABIEncoderTest.sol#39-603\n"
        },
        {
          "name": "solc-version",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
          "message": "Detected issues with version pragma in BilateralSwapABIEncoderTest.sol:\n\t- pragma solidity>=0.5.0<0.6.0 (BilateralSwapABIEncoderTest.sol#3): it allows old versions\n\t- pragma solidity>=0.5.0<0.6.0 (BilateralSwapABIEncoderTest.sol#609): it allows old versions\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 624,
          "vulnerability_to_line": null,
          "vulnerability_code": "        bytes calldata, \n",
          "message": "Parameter '' of BilateralSwapABIEncoderTest.validateBilateralSwap (BilateralSwapABIEncoderTest.sol#624) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 625,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address, \n",
          "message": "Parameter '_scope_0' of BilateralSwapABIEncoderTest.validateBilateralSwap (BilateralSwapABIEncoderTest.sol#625) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 626,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint[6] calldata\n",
          "message": "Parameter '_scope_1' of BilateralSwapABIEncoderTest.validateBilateralSwap (BilateralSwapABIEncoderTest.sol#626) is not in mixedCase\n"
        }
      ]
    },
    "smartcheck": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
          "vulnerability_from_line": 623,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function validateBilateralSwap(\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 609,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 609,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 38,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function encodeAndExit() internal pure {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 39,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        }
      ]
    },
    "oyente": {
      "successfull_analysis": false,
      "errors": [
        "exception (IndexError: pop from empty list)"
      ],
      "vulnerability_findings": []
    },
    "mythril": {
      "successfull_analysis": false,
      "errors": [
        "Solc experienced a fatal error"
      ],
      "vulnerability_findings": []
    },
    "osiris": {
      "successfull_analysis": false,
      "errors": [
        "Solidity compilation failed"
      ],
      "vulnerability_findings": []
    }
  }
}