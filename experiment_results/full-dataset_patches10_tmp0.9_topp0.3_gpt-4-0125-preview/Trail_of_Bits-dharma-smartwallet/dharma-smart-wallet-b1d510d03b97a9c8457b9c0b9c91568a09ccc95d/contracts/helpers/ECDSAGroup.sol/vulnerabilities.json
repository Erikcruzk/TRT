{
  "smartbugs_completed": true,
  "analyzer_results": {
    "semgrep": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 41,
          "vulnerability_to_line": null,
          "vulnerability_code": "    for (uint256 i = 0; i < signers.length; i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 41,
          "vulnerability_to_line": null,
          "vulnerability_code": "    for (uint256 i = 0; i < signers.length; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 55,
          "vulnerability_to_line": null,
          "vulnerability_code": "      if (v != 27 && v != 28) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 56,
          "vulnerability_to_line": null,
          "vulnerability_code": "        continue;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 57,
          "vulnerability_to_line": null,
          "vulnerability_code": "      }\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 41,
          "vulnerability_to_line": null,
          "vulnerability_code": "    for (uint256 i = 0; i < signers.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        }
      ]
    },
    "slither": {
      "successfull_analysis": true,
      "errors": [
        "EXIT_CODE_3"
      ],
      "vulnerability_findings": [
        {
          "name": "constant-function",
          "vulnerability_from_line": 23,
          "vulnerability_to_line": 62,
          "vulnerability_code": "  function recoverGroup(\n\n    bytes32 hash,\n\n    bytes memory signatures\n\n  ) internal pure returns (uint160[] memory signers) {\n\n    // Ensure that the signatures length is a multiple of 65.\n\n    if (signatures.length % 65 != 0) {\n\n      return new uint160[](0);\n\n    }\n\n\n\n    // Create an appropriately-sized array of addresses for each signer.\n\n    signers = new uint160[](signatures.length / 65);\n\n\n\n    // Get each signature location and divide into r, s and v variables.\n\n    bytes32 signatureLocation;\n\n    bytes32 r;\n\n    bytes32 s;\n\n    uint8 v;\n\n\n\n    for (uint256 i = 0; i < signers.length; i++) {\n\n      assembly {\n\n        signatureLocation := add(signatures, mul(i, 65))\n\n        r := mload(add(signatureLocation, 0x20))\n\n        s := mload(add(signatureLocation, 0x40))\n\n        v := byte(0, mload(add(signatureLocation, 0x60)))\n\n      }\n\n\n\n      // EIP-2 still allows signature malleability for ecrecover(). Remove\n\n      // this possibility and make the signature unique. \n\n      if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n\n        continue;\n\n      }\n\n\n\n      if (v != 27 && v != 28) {\n\n        continue;\n\n      }\n\n\n\n      // If signature is valid & not malleable, add signer address as uint160.\n\n      signers[i] = uint160(ecrecover(hash, v, r, s));\n\n    }\n",
          "message": "ECDSAGroup.recoverGroup (ECDSAGroup.sol#23-62) is declared view but contains assembly code\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 23,
          "vulnerability_to_line": 62,
          "vulnerability_code": "  function recoverGroup(\n\n    bytes32 hash,\n\n    bytes memory signatures\n\n  ) internal pure returns (uint160[] memory signers) {\n\n    // Ensure that the signatures length is a multiple of 65.\n\n    if (signatures.length % 65 != 0) {\n\n      return new uint160[](0);\n\n    }\n\n\n\n    // Create an appropriately-sized array of addresses for each signer.\n\n    signers = new uint160[](signatures.length / 65);\n\n\n\n    // Get each signature location and divide into r, s and v variables.\n\n    bytes32 signatureLocation;\n\n    bytes32 r;\n\n    bytes32 s;\n\n    uint8 v;\n\n\n\n    for (uint256 i = 0; i < signers.length; i++) {\n\n      assembly {\n\n        signatureLocation := add(signatures, mul(i, 65))\n\n        r := mload(add(signatureLocation, 0x20))\n\n        s := mload(add(signatureLocation, 0x40))\n\n        v := byte(0, mload(add(signatureLocation, 0x60)))\n\n      }\n\n\n\n      // EIP-2 still allows signature malleability for ecrecover(). Remove\n\n      // this possibility and make the signature unique. \n\n      if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n\n        continue;\n\n      }\n\n\n\n      if (v != 27 && v != 28) {\n\n        continue;\n\n      }\n\n\n\n      // If signature is valid & not malleable, add signer address as uint160.\n\n      signers[i] = uint160(ecrecover(hash, v, r, s));\n\n    }\n",
          "message": "ECDSAGroup.recoverGroup uses assembly (ECDSAGroup.sol#23-62)\n\t- ECDSAGroup.sol#42-47\n"
        },
        {
          "name": "solc-version",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity 0.5.11;\n",
          "message": "Detected issues with version pragma in ECDSAGroup.sol:\n\t- pragma solidity0.5.11 (ECDSAGroup.sol#3): it allows old versions\n"
        }
      ]
    },
    "smartcheck": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 41,
          "vulnerability_to_line": null,
          "vulnerability_code": "    for (uint256 i = 0; i < signers.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 41,
          "vulnerability_to_line": null,
          "vulnerability_code": "    for (uint256 i = 0; i < signers.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 23,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function recoverGroup(\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 42,
          "vulnerability_to_line": null,
          "vulnerability_code": "      assembly {\n",
          "message": null
        }
      ]
    },
    "oyente": {
      "successfull_analysis": false,
      "errors": [
        "exception (IndexError: pop from empty list)"
      ],
      "vulnerability_findings": []
    },
    "mythril": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": []
    },
    "osiris": {
      "successfull_analysis": false,
      "errors": [
        "exception (IndexError: pop from empty list)"
      ],
      "vulnerability_findings": []
    }
  }
}