{
  "smartbugs_completed": true,
  "analyzer_results": {
    "semgrep": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": []
    },
    "slither": {
      "successfull_analysis": true,
      "errors": [
        "EXIT_CODE_7"
      ],
      "vulnerability_findings": [
        {
          "name": "assembly",
          "vulnerability_from_line": 29,
          "vulnerability_to_line": 40,
          "vulnerability_code": "  constructor(bytes memory initializationCalldata) public payable {\n\n    // Delegatecall into the implementation, supplying initialization calldata.\n\n    (bool ok, ) = _implementation().delegatecall(initializationCalldata);\n\n    \n\n    // Revert and include revert data if delegatecall to implementation reverts.\n\n    if (!ok) {\n\n      assembly {\n\n        returndatacopy(0, 0, returndatasize)\n\n        revert(0, returndatasize)\n\n      }\n\n    }\n",
          "message": "UpgradeBeaconProxyV1.constructor uses assembly (UpgradeBeaconProxyV1.sol#29-40)\n\t- UpgradeBeaconProxyV1.sol#35-38\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 76,
          "vulnerability_to_line": 95,
          "vulnerability_code": "  function _delegate(address implementation) private {\n\n    assembly {\n\n      // Copy msg.data. We take full control of memory in this inline assembly\n\n      // block because it will not return to Solidity code. We overwrite the\n\n      // Solidity scratch pad at memory position 0.\n\n      calldatacopy(0, 0, calldatasize)\n\n\n\n      // Delegatecall to the implementation, supplying calldata and gas.\n\n      // Out and outsize are set to zero - instead, use the return buffer.\n\n      let result := delegatecall(gas, implementation, 0, calldatasize, 0, 0)\n\n\n\n      // Copy the returned data from the return buffer.\n\n      returndatacopy(0, 0, returndatasize)\n\n\n\n      switch result\n\n      // Delegatecall returns 0 on error.\n\n      case 0 { revert(0, returndatasize) }\n\n      default { return(0, returndatasize) }\n\n    }\n",
          "message": "UpgradeBeaconProxyV1._delegate uses assembly (UpgradeBeaconProxyV1.sol#76-95)\n\t- UpgradeBeaconProxyV1.sol#77-94\n"
        },
        {
          "name": "solc-version",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity 0.5.11;\n",
          "message": "Detected issues with version pragma in UpgradeBeaconProxyV1.sol:\n\t- pragma solidity0.5.11 (UpgradeBeaconProxyV1.sol#3): it allows old versions\n"
        },
        {
          "name": "low-level-calls",
          "vulnerability_from_line": 29,
          "vulnerability_to_line": 40,
          "vulnerability_code": "  constructor(bytes memory initializationCalldata) public payable {\n\n    // Delegatecall into the implementation, supplying initialization calldata.\n\n    (bool ok, ) = _implementation().delegatecall(initializationCalldata);\n\n    \n\n    // Revert and include revert data if delegatecall to implementation reverts.\n\n    if (!ok) {\n\n      assembly {\n\n        returndatacopy(0, 0, returndatasize)\n\n        revert(0, returndatasize)\n\n      }\n\n    }\n",
          "message": "Low level call in UpgradeBeaconProxyV1.constructor (UpgradeBeaconProxyV1.sol#29-40):\n\t-(ok) = _implementation().delegatecall(initializationCalldata) UpgradeBeaconProxyV1.sol#31\n"
        },
        {
          "name": "low-level-calls",
          "vulnerability_from_line": 57,
          "vulnerability_to_line": 66,
          "vulnerability_code": "  function _implementation() private view returns (address implementation) {\n\n    // Get the current implementation address from the upgrade beacon.\n\n    (bool ok, bytes memory returnData) = _UPGRADE_BEACON.staticcall(\"\");\n\n    \n\n    // Revert and pass along revert message if call to upgrade beacon reverts.\n\n    require(ok, string(returnData));\n\n\n\n    // Set the implementation to the address returned from the upgrade beacon.\n\n    implementation = abi.decode(returnData, (address));\n",
          "message": "Low level call in UpgradeBeaconProxyV1._implementation (UpgradeBeaconProxyV1.sol#57-66):\n\t-(ok,returnData) = _UPGRADE_BEACON.staticcall() UpgradeBeaconProxyV1.sol#59\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 57,
          "vulnerability_to_line": 66,
          "vulnerability_code": "  function _implementation() private view returns (address implementation) {\n\n    // Get the current implementation address from the upgrade beacon.\n\n    (bool ok, bytes memory returnData) = _UPGRADE_BEACON.staticcall(\"\");\n\n    \n\n    // Revert and pass along revert message if call to upgrade beacon reverts.\n\n    require(ok, string(returnData));\n\n\n\n    // Set the implementation to the address returned from the upgrade beacon.\n\n    implementation = abi.decode(returnData, (address));\n",
          "message": "Function 'UpgradeBeaconProxyV1._implementation' (UpgradeBeaconProxyV1.sol#57-66) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 76,
          "vulnerability_to_line": 95,
          "vulnerability_code": "  function _delegate(address implementation) private {\n\n    assembly {\n\n      // Copy msg.data. We take full control of memory in this inline assembly\n\n      // block because it will not return to Solidity code. We overwrite the\n\n      // Solidity scratch pad at memory position 0.\n\n      calldatacopy(0, 0, calldatasize)\n\n\n\n      // Delegatecall to the implementation, supplying calldata and gas.\n\n      // Out and outsize are set to zero - instead, use the return buffer.\n\n      let result := delegatecall(gas, implementation, 0, calldatasize, 0, 0)\n\n\n\n      // Copy the returned data from the return buffer.\n\n      returndatacopy(0, 0, returndatasize)\n\n\n\n      switch result\n\n      // Delegatecall returns 0 on error.\n\n      case 0 { revert(0, returndatasize) }\n\n      default { return(0, returndatasize) }\n\n    }\n",
          "message": "Function 'UpgradeBeaconProxyV1._delegate' (UpgradeBeaconProxyV1.sol#76-95) is not in mixedCase\n"
        }
      ]
    },
    "smartcheck": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 18,
          "vulnerability_to_line": null,
          "vulnerability_code": "    0x000000000026750c571ce882B17016557279ADaa\n",
          "message": null
        },
        {
          "name": "SOLIDITY_LOCKED_MONEY",
          "vulnerability_from_line": 15,
          "vulnerability_to_line": null,
          "vulnerability_code": "contract UpgradeBeaconProxyV1 {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 17,
          "vulnerability_to_line": null,
          "vulnerability_code": "  address private constant _UPGRADE_BEACON = address(\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UNCHECKED_CALL",
          "vulnerability_from_line": 31,
          "vulnerability_to_line": null,
          "vulnerability_code": "    (bool ok, ) = _implementation().delegatecall(initializationCalldata);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UNCHECKED_CALL",
          "vulnerability_from_line": 59,
          "vulnerability_to_line": null,
          "vulnerability_code": "    (bool ok, bytes memory returnData) = _UPGRADE_BEACON.staticcall(\"\");\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 35,
          "vulnerability_to_line": null,
          "vulnerability_code": "      assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 77,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly {\n",
          "message": null
        }
      ]
    },
    "oyente": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "Integer Overflow",
          "vulnerability_from_line": 1,
          "vulnerability_to_line": null,
          "vulnerability_code": "// File: ../sc_datasets/DAppSCAN/Trail_of_Bits-dharma-smartwallet/dharma-smart-wallet-b1d510d03b97a9c8457b9c0b9c91568a09ccc95d/contracts/proxies/smart-wallet/UpgradeBeaconProxyV1.sol\n",
          "message": null
        },
        {
          "name": "Integer Underflow",
          "vulnerability_from_line": 62,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require(ok, string(returnData));\n",
          "message": null
        }
      ]
    },
    "mythril": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "Exception State (SWC 110)",
          "vulnerability_from_line": null,
          "vulnerability_to_line": null,
          "vulnerability_code": null,
          "message": "An assertion violation was triggered.\nIt is possible to trigger an assertion violation. Note that Solidity assert() statements should only be used to check invariants. Review the transaction trace generated for this issue and either make sure your program logic is correct, or use require() instead of assert() if your goal is to constrain user inputs or enforce preconditions. Remember to validate inputs from both callers (for instance, via passed arguments) and callees (for instance, via return values).\nClassification: SWC-110"
        },
        {
          "name": "Multiple Calls in a Single Transaction (SWC 113)",
          "vulnerability_from_line": 31,
          "vulnerability_to_line": null,
          "vulnerability_code": "    (bool ok, ) = _implementation().delegatecall(initializationCalldata);\n",
          "message": "Multiple calls are executed in the same transaction.\nThis call is executed following another call within the same transaction. It is possible that the call never gets executed if a prior call fails permanently. This might be caused intentionally by a malicious callee. If possible, refactor the code such that each transaction only executes one external call or make sure that all callees can be trusted (i.e. they\u2019re part of your own codebase).\nClassification: SWC-113"
        },
        {
          "name": "Integer Arithmetic Bugs (SWC 101)",
          "vulnerability_from_line": null,
          "vulnerability_to_line": null,
          "vulnerability_code": null,
          "message": "The arithmetic operator can overflow.\nIt is possible to cause an integer overflow or underflow in the arithmetic operation. \nClassification: SWC-101"
        }
      ]
    },
    "osiris": {
      "successfull_analysis": false,
      "errors": [
        "UNKNOWN INSTRUCTION: STATICCALL"
      ],
      "vulnerability_findings": []
    }
  }
}