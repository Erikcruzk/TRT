{
  "smartbugs_completed": true,
  "analyzer_results": {
    "semgrep": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 400,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(uint i = 0; i < admins.length; i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 837,
          "vulnerability_to_line": null,
          "vulnerability_code": "            for(uint i = 0; i < tokenAddresses.length; i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 901,
          "vulnerability_to_line": null,
          "vulnerability_code": "                for(uint i = 0; i < pool.tokenAddresses.length; i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 1310,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(i = 0; i < exclude.length; i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 1322,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(i = 0; i < include.length; i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 1387,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(uint i = 0; i < pool.participants.length; i++) {           \n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 1642,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < array.length; i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 400,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(uint i = 0; i < admins.length; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 837,
          "vulnerability_to_line": null,
          "vulnerability_code": "            for(uint i = 0; i < tokenAddresses.length; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 865,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(uint i = 0; i < length; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 901,
          "vulnerability_to_line": null,
          "vulnerability_code": "                for(uint i = 0; i < pool.tokenAddresses.length; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 962,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(uint idx = 0; idx < length; idx++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 1016,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(uint idx = 0; idx < length; idx++) {            \n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 1067,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(uint idx = 0; idx < length; idx++) {                        \n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 1197,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(uint i = 0; i < length; i++) {             \n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 1387,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(uint i = 0; i < pool.participants.length; i++) {           \n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 1553,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(uint idx = 0; idx < length; idx++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 1583,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(uint idx = 0; idx < length; idx++) {            \n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 1642,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < array.length; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 582,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(poolContribution > 0 && poolContribution >= minPoolBalance);\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 1296,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(pool.groups.length > idx && pool.groups[idx].exists);\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 1446,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(!participant.exists && !participant.isAdmin);\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 1630,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 1631,
          "vulnerability_to_line": null,
          "vulnerability_code": "            minContribution > 0 &&\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 1632,
          "vulnerability_to_line": null,
          "vulnerability_code": "            minContribution <= maxContribution &&\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 1633,
          "vulnerability_to_line": null,
          "vulnerability_code": "            maxContribution <= maxBalance &&\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 1634,
          "vulnerability_to_line": null,
          "vulnerability_code": "            maxBalance <= 1e9 ether            \n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 1635,
          "vulnerability_to_line": null,
          "vulnerability_code": "        );\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 1352,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if(ctorFee > 0 && !pool.feeToTokenMode) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 1353,
          "vulnerability_to_line": null,
          "vulnerability_code": "            addressTransfer(msg.sender, ctorFee);            \n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 1354,
          "vulnerability_to_line": null,
          "vulnerability_code": "        }\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 1520,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if(currentBalance >= maxBalance || (isRestricted && !participant.whitelist[idx])) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 1521,
          "vulnerability_to_line": null,
          "vulnerability_code": "            remaining = totalAmount;            \n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 1522,
          "vulnerability_to_line": null,
          "vulnerability_code": "            return;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 1523,
          "vulnerability_to_line": null,
          "vulnerability_code": "        }        \n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 400,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(uint i = 0; i < admins.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 837,
          "vulnerability_to_line": null,
          "vulnerability_code": "            for(uint i = 0; i < tokenAddresses.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 865,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(uint i = 0; i < length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 901,
          "vulnerability_to_line": null,
          "vulnerability_code": "                for(uint i = 0; i < pool.tokenAddresses.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 962,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(uint idx = 0; idx < length; idx++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 1016,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(uint idx = 0; idx < length; idx++) {            \n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 1067,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(uint idx = 0; idx < length; idx++) {                        \n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 1197,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(uint i = 0; i < length; i++) {             \n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 1310,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(i = 0; i < exclude.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 1322,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(i = 0; i < include.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 1387,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(uint i = 0; i < pool.participants.length; i++) {           \n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 1553,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(uint idx = 0; idx < length; idx++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 1583,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(uint idx = 0; idx < length; idx++) {            \n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 1642,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < array.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        }
      ]
    },
    "slither": {
      "successfull_analysis": true,
      "errors": [
        "EXIT_CODE_46"
      ],
      "vulnerability_findings": [
        {
          "name": "arbitrary-send",
          "vulnerability_from_line": 1459,
          "vulnerability_to_line": 1465,
          "vulnerability_code": "    function addressTransfer(address destination, uint etherAmount) private {\n\n        emit AddressTransfer(\n\n            destination,\n\n            etherAmount\n\n        );\n\n        destination.transfer(etherAmount);        \n",
          "message": "ProPoolLib.addressTransfer (ProPoolLib.sol#1459-1465) sends eth to arbitrary user\n\tDangerous calls:\n\t- destination.transfer(etherAmount) (ProPoolLib.sol#1464)\n"
        },
        {
          "name": "arbitrary-send",
          "vulnerability_from_line": 1477,
          "vulnerability_to_line": 1490,
          "vulnerability_code": "    function addressCall(address destination, uint gasAmount,  uint etherAmount, bytes data) private {\n\n        emit AddressCall(\n\n            destination,\n\n            etherAmount,\n\n            gasAmount > 0 ? gasAmount : gasleft(),\n\n            data\n\n        );\n\n        require(\n\n            destination.call\n\n            .gas(gasAmount > 0 ? gasAmount : gasleft())\n\n            .value(etherAmount)\n\n            (data)            \n\n        );\n",
          "message": "ProPoolLib.addressCall (ProPoolLib.sol#1477-1490) sends eth to arbitrary user\n\tDangerous calls:\n\t- require(bool)(destination.call.gas(gasAmount).value(etherAmount)(data)) (ProPoolLib.sol#1484-1489)\n\t- require(bool)(destination.call.gas(gasleft()()).value(etherAmount)(data)) (ProPoolLib.sol#1484-1489)\n"
        },
        {
          "name": "uninitialized-local",
          "vulnerability_from_line": 1062,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint sumRemaining; \n",
          "message": "sumRemaining in ProPoolLib.withdrawAllRemaining2 (ProPoolLib.sol#1062) is a local variable never initialiazed\n"
        },
        {
          "name": "uninitialized-local",
          "vulnerability_from_line": 1012,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint amount;\n",
          "message": "amount in ProPoolLib.withdrawAllRemaining1 (ProPoolLib.sol#1012) is a local variable never initialiazed\n"
        },
        {
          "name": "uninitialized-local",
          "vulnerability_from_line": 957,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint amount;\n",
          "message": "amount in ProPoolLib.withdrawAllContribution (ProPoolLib.sol#957) is a local variable never initialiazed\n"
        },
        {
          "name": "shadowing-local",
          "vulnerability_from_line": 143,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint share = calcShare(self, addr, currentAmount, fraction);\n",
          "message": "QuotaLib.claimShare.share (local variable @ ProPoolLib.sol#143) shadows:\n\t- QuotaLib.share (function @ ProPoolLib.sol#174-176)\n"
        },
        {
          "name": "calls-loop",
          "vulnerability_from_line": 838,
          "vulnerability_to_line": null,
          "vulnerability_code": "                tokenBalances[i] = IERC20Base(tokenAddresses[i]).balanceOf(address(this));\n",
          "message": "ProPoolLib.getPoolDetails2 has external calls inside a loop:\n\t- tokenBalances[i] = IERC20Base(tokenAddresses[i]).balanceOf(address(this)) (ProPoolLib.sol#838)\n"
        },
        {
          "name": "calls-loop",
          "vulnerability_from_line": 902,
          "vulnerability_to_line": 906,
          "vulnerability_code": "                    tokenShare[i] = pool.tokenQuota[pool.tokenAddresses[i]].calcShare(\n\n                        addr,\n\n                        IERC20Base(pool.tokenAddresses[i]).balanceOf(address(this)),\n\n                        [netPartContribution, netPoolContribution]\n",
          "message": "ProPoolLib.getParticipantShares has external calls inside a loop:\n\t- tokenShare[i] = pool.tokenQuota[pool.tokenAddresses[i]].calcShare(addr,IERC20Base(pool.tokenAddresses[i]).balanceOf(address(this)),(netPartContribution,netPoolContribution)) (ProPoolLib.sol#902-906)\n"
        },
        {
          "name": "calls-loop",
          "vulnerability_from_line": 1202,
          "vulnerability_to_line": null,
          "vulnerability_code": "            tokenBalance = tokenContract.balanceOf(address(this));\n",
          "message": "ProPoolLib.withdrawTokens has external calls inside a loop:\n\t- tokenBalance = tokenContract.balanceOf(address(this)) (ProPoolLib.sol#1202)\n"
        },
        {
          "name": "calls-loop",
          "vulnerability_from_line": 1215,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    succeeded = tokenContract.transfer(msg.sender, tokenAmount);\n",
          "message": "ProPoolLib.withdrawTokens has external calls inside a loop:\n\t- succeeded = tokenContract.transfer(msg.sender,tokenAmount) (ProPoolLib.sol#1215)\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 10,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function transfer(address to, uint value) public returns (bool success);\n",
          "message": "IERC20Base.transfer (ProPoolLib.sol#10) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 11,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function balanceOf(address owner) public view returns (uint balance);\n",
          "message": "IERC20Base.balanceOf (ProPoolLib.sol#11) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 23,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getFeePerEther() public view returns(uint);\n",
          "message": "IFeeService.getFeePerEther (ProPoolLib.sol#23) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 365,
          "vulnerability_to_line": 420,
          "vulnerability_code": "    function init(\n\n        Pool storage pool,           \n\n        uint maxBalance,\n\n        uint minContribution,\n\n        uint maxContribution,\n\n        uint ctorFeePerEther,\n\n        bool isRestricted,                \n\n        address creatorAddress,        \n\n        address presaleAddress,        \n\n        address feeServiceAddr,\n\n        address[] whitelist,\n\n        address[] admins\n\n    )\n\n        public \n\n    {\n\n\n\n        // Set presale address.\n\n        if(presaleAddress != address(0)) {\n\n            require(presaleAddress != address(this)); \n\n            pool.presaleAddress = presaleAddress;           \n\n            emit PresaleAddressLocked(presaleAddress);            \n\n        }\n\n                \n\n        // Set fee service contract.\n\n        pool.feeService = IFeeService(feeServiceAddr);        \n\n        pool.svcFeePerEther = pool.feeService.getFeePerEther();\n\n        require(pool.svcFeePerEther <= (1 ether / 4));\n\n        emit FeeServiceAttached(\n\n            feeServiceAddr,\n\n            pool.svcFeePerEther\n\n        );  \n\n        \n\n        // Set pool administrators.\n\n        require(creatorAddress != address(0));\n\n        addAdmin(pool, creatorAddress);\n\n        for(uint i = 0; i < admins.length; i++) {\n\n            addAdmin(pool, admins[i]);\n\n        }\n\n        \n\n        // Create first group.\n\n        setGroupSettingsCore(\n\n            pool,\n\n            0,\n\n            maxBalance,\n\n            minContribution,\n\n            maxContribution,\n\n            ctorFeePerEther,\n\n            isRestricted            \n\n        );\n\n        \n\n        // Set whitelist.\n\n        if(whitelist.length > 0) {\n\n            require(isRestricted);\n\n            modifyWhitelistCore(pool, 0, whitelist, new address[](0));\n\n        }\n",
          "message": "ProPoolLib.init (ProPoolLib.sol#365-420) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 426,
          "vulnerability_to_line": 457,
          "vulnerability_code": "    function setGroupSettings(\n\n        Pool storage pool,        \n\n        uint idx,\n\n        uint maxBalance,\n\n        uint minContribution,\n\n        uint maxContribution,\n\n        uint ctorFeePerEther,         \n\n        bool isRestricted\n\n    )\n\n        public     \n\n        onlyAdmin(pool)\n\n        onlyInState(pool, State.Open)      \n\n    {\n\n        // Group existence state.\n\n        bool exists = pool.groups[idx].exists;\n\n\n\n        // Set or update group settings.\n\n        setGroupSettingsCore(\n\n            pool,\n\n            idx,\n\n            maxBalance,\n\n            minContribution,\n\n            maxContribution,\n\n            ctorFeePerEther,\n\n            isRestricted            \n\n        );\n\n                \n\n        if(exists) {            \n\n            // Execute rebalancing.\n\n            groupRebalance(pool, idx);\n\n        }\n",
          "message": "ProPoolLib.setGroupSettings (ProPoolLib.sol#426-457) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 462,
          "vulnerability_to_line": 471,
          "vulnerability_code": "    function modifyWhitelist(Pool storage pool, uint idx, address[] include, address[] exclude)\n\n        public \n\n        onlyAdmin(pool)\n\n        onlyInState(pool, State.Open)\n\n    {\n\n        // Modify whitelist (without relabancing).\n\n        modifyWhitelistCore(pool, idx, include, exclude); \n\n        // Execute group rebalancing.\n\n        groupRebalance(pool, idx);\n",
          "message": "ProPoolLib.modifyWhitelist (ProPoolLib.sol#462-471) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 476,
          "vulnerability_to_line": 495,
          "vulnerability_code": "    function lockPresaleAddress(Pool storage pool, address presaleAddress, bool lock)\n\n        public \n\n        onlyAdmin(pool) \n\n        onlyInState(pool, State.Open) \n\n    {        \n\n        require(presaleAddress != address(0));\n\n        require(presaleAddress != address(this));\n\n        require(pool.presaleAddress == address(0));\n\n        require(!pool.lockPresale);\n\n\n\n        // Set presale address.\n\n        pool.presaleAddress = presaleAddress;\n\n\n\n        // Lock presale address.\n\n        if(lock) {\n\n            pool.lockPresale = true;\n\n        }\n\n\n\n        emit PresaleAddressLocked(presaleAddress);\n",
          "message": "ProPoolLib.lockPresaleAddress (ProPoolLib.sol#476-495) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 500,
          "vulnerability_to_line": 529,
          "vulnerability_code": "    function confirmTokenAddress(Pool storage pool, address tokenAddress)\n\n        public\n\n        onlyAdmin(pool)\n\n        onlyInStates2(pool, State.PaidToPresale, State.Distribution)         \n\n    {        \n\n        require(tokenAddress != address(0));\n\n        require(pool.tokenAddresses.length <= 4);\n\n        require(!contains(pool.tokenAddresses, tokenAddress));\n\n\n\n        // Get token balance for the pool address.\n\n        IERC20Base ERC20 = IERC20Base(tokenAddress);\n\n        uint balance = ERC20.balanceOf(address(this));  \n\n\n\n        // When confirming the token balance must be greater than zero.      \n\n        require(balance > 0);\n\n\n\n        // Change state of the pool if this is the first token confirmation.\n\n        if(pool.state == State.PaidToPresale) {\n\n            changeState(pool, State.Distribution);            \n\n            sendFees(pool);\n\n        } \n\n                        \n\n        // Save token address.\n\n        pool.tokenAddresses.push(tokenAddress);\n\n\n\n        emit TokenAddressConfirmed(\n\n            tokenAddress,\n\n            balance\n\n        );\n",
          "message": "ProPoolLib.confirmTokenAddress (ProPoolLib.sol#500-529) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 534,
          "vulnerability_to_line": 550,
          "vulnerability_code": "    function setRefundAddress(Pool storage pool, address refundAddress)\n\n        public\n\n        onlyAdmin(pool)\n\n        onlyInStates3(pool, State.PaidToPresale, State.Distribution, State.FullRefund)\n\n    {        \n\n        require(refundAddress != address(0));\n\n        require(pool.refundAddress != refundAddress);\n\n\n\n        // Set refund sender address.\n\n        pool.refundAddress = refundAddress;\n\n        emit RefundAddressChanged(refundAddress);\n\n\n\n        // This is full refund scenario.\n\n        if(pool.state == State.PaidToPresale) {\n\n            changeState(pool, State.FullRefund);\n\n        }\n",
          "message": "ProPoolLib.setRefundAddress (ProPoolLib.sol#534-550) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 555,
          "vulnerability_to_line": 599,
          "vulnerability_code": "    function payToPresale(\n\n        Pool storage pool,\n\n        address presaleAddress,\n\n        uint minPoolBalance,\n\n        bool feeToToken,\n\n        bytes data\n\n    )\n\n        public\n\n        onlyAdmin(pool) \n\n        onlyInState(pool, State.Open) \n\n    {\n\n        require(presaleAddress != address(0));\n\n                        \n\n        // Check if presale address is locked.\n\n        if(pool.presaleAddress == address(0)) {\n\n            pool.presaleAddress = presaleAddress;\n\n            emit PresaleAddressLocked(presaleAddress);\n\n        } else { \n\n            // If locked then destination address must be same.\n\n            require(pool.presaleAddress == presaleAddress);\n\n        }\n\n        \n\n        uint ctorFee;\n\n        uint poolRemaining;\n\n        uint poolContribution;      \n\n        // Calculate pool summaries.          \n\n        (poolContribution, poolRemaining, ctorFee) = calcPoolSummary(pool);        \n\n        require(poolContribution > 0 && poolContribution >= minPoolBalance);\n\n\n\n        // Set fee-to-token mode.\n\n        if(feeToToken) {\n\n            pool.feeToTokenMode = true;            \n\n            pool.feeToTokenAddress = msg.sender;\n\n            ctorFee = 0;\n\n        }\n\n\n\n        changeState(pool, State.PaidToPresale);\n\n\n\n        // Transafer funds.\n\n        addressCall(\n\n            pool.presaleAddress,\n\n            poolContribution - ctorFee - calcFee(poolContribution, pool.svcFeePerEther),\n\n            data\n\n        );        \n",
          "message": "ProPoolLib.payToPresale (ProPoolLib.sol#555-599) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 604,
          "vulnerability_to_line": 610,
          "vulnerability_code": "    function cancel(Pool storage pool)\n\n        public\n\n        onlyAdmin(pool) \n\n        onlyInState(pool, State.Open)\n\n    {\n\n        changeState(pool, State.Canceled);\n",
          "message": "ProPoolLib.cancel (ProPoolLib.sol#604-610) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 615,
          "vulnerability_to_line": 668,
          "vulnerability_code": "    function deposit(Pool storage pool, uint idx)\n\n        public        \n\n        onlyInState(pool, State.Open)  \n\n    {\n\n        require(msg.value > 0);\n\n        require(pool.groups.length > idx);\n\n        require(pool.groups[idx].exists);\n\n\n\n        // Get group and participant instances.\n\n        Participant storage participant = pool.participantToData[msg.sender];\n\n        Group storage group = pool.groups[idx];        \n\n\n\n        // Calculate contribution and remaining balance.\n\n        uint remaining;\n\n        uint contribution;                \n\n        (contribution, remaining) = calcContribution(\n\n            idx, \n\n            msg.value, \n\n            group.maxBalance, \n\n            group.contribution - participant.contribution[idx], \n\n            group.minContribution, \n\n            group.maxContribution, \n\n            group.isRestricted,            \n\n            participant\n\n        );\n\n\n\n        // Remaining balance must be equal to zero.\n\n        require(remaining == 0);\n\n\n\n        // Set the participant existence state.\n\n        if (!participant.exists) {\n\n            participant.exists = true;   \n\n            pool.participants.push(msg.sender);\n\n        }        \n\n\n\n        // Mark participant as whitelisted.\n\n        if(!participant.whitelist[idx]) {\n\n            participant.whitelist[idx] = true;         \n\n        }\n\n\n\n        // Update contribution and remaining balance.\n\n        group.contribution = group.contribution - participant.contribution[idx] + contribution;\n\n        group.remaining = group.remaining - participant.remaining[idx] + remaining;\n\n        participant.contribution[idx] = contribution;\n\n        participant.remaining[idx] = remaining;\n\n\n\n        emit Contribution(\n\n            msg.sender,\n\n            idx,\n\n            msg.value,\n\n            contribution,\n\n            group.contribution\n\n        );        \n",
          "message": "ProPoolLib.deposit (ProPoolLib.sol#615-668) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 673,
          "vulnerability_to_line": 729,
          "vulnerability_code": "    function withdrawAmount(Pool storage pool, uint amount, uint idx)\n\n        public\n\n        onlyInState(pool, State.Open)\n\n    {\n\n        // Get participant instance.\n\n        Participant storage participant = pool.participantToData[msg.sender];                        \n\n        uint finalAmount;\n\n        \n\n        if(amount == 0) {\n\n            // If withdrawal amount is equal to zero then withdraw entire contribution.\n\n            finalAmount = participant.contribution[idx] + participant.remaining[idx];\n\n        } else {\n\n            // Requested withdrawal amount must be equal or greater than participant \n\n            // remaining balance, but less or equal than his total contribution.\n\n            require(amount >= participant.remaining[idx]);\n\n            require(amount <= participant.contribution[idx] + participant.remaining[idx]);\n\n            finalAmount = amount;\n\n        }\n\n\n\n        require(finalAmount > 0);\n\n        \n\n        // Get group instance.\n\n        Group storage group = pool.groups[idx];\n\n\n\n        // Update group remaining balance.\n\n        group.remaining -= participant.remaining[idx];        \n\n\n\n        // Check if withdrawal amount is greater than remaining balance.\n\n        uint extra = finalAmount - participant.remaining[idx];        \n\n\n\n        // Update participant remaining balance. At this point always zero.\n\n        participant.remaining[idx] = 0;        \n\n\n\n        if(extra > 0) {\n\n            // Update group and participant contribution balance.\n\n            participant.contribution[idx] -= extra;\n\n            group.contribution -= extra;            \n\n\n\n            if(!participant.isAdmin) {\n\n                // Make sure that requested withdrawal amount won't break group settings.\n\n                require(participant.contribution[idx] >= group.minContribution);\n\n            }\n\n        }\n\n\n\n        // Transfer funds.\n\n        addressTransfer(msg.sender, finalAmount);\n\n\n\n        emit Withdrawal(\n\n            msg.sender,\n\n            finalAmount,\n\n            participant.contribution[idx],\n\n            0,\n\n            group.contribution,\n\n            group.remaining,\n\n            idx\n\n        );                        \n",
          "message": "ProPoolLib.withdrawAmount (ProPoolLib.sol#673-729) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 734,
          "vulnerability_to_line": 756,
          "vulnerability_code": "    function withdrawAll(Pool storage pool) public {\n\n\n\n        // Withdraw refund share and tokens share.\n\n        if (pool.state == State.FullRefund || pool.state == State.Distribution) {\n\n            withdrawRefundAndTokens(pool);\n\n            return;\n\n        }\n\n        \n\n        // Withdraw entire contribution balance.\n\n        if(pool.state == State.Canceled || pool.state == State.Open) {\n\n            withdrawAllContribution(pool);\n\n            return;\n\n        }            \n\n        \n\n        // Withdraw remaining balance.\n\n        if (pool.state == State.PaidToPresale) {\n\n            withdrawAllRemaining1(pool);\n\n            return;\n\n        } \n\n\n\n        // Revert transaction.\n\n        revert();\n",
          "message": "ProPoolLib.withdrawAll (ProPoolLib.sol#734-756) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 761,
          "vulnerability_to_line": 771,
          "vulnerability_code": "    function tokenFallback(Pool storage pool, address from, uint value, bytes data)\n\n        public \n\n        onlyInStates2(pool, State.PaidToPresale, State.Distribution)\n\n    {\n\n        emit ERC223Fallback(\n\n            msg.sender,\n\n            from,\n\n            value,\n\n            data\n\n        );\n",
          "message": "ProPoolLib.tokenFallback (ProPoolLib.sol#761-771) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 776,
          "vulnerability_to_line": 787,
          "vulnerability_code": "    function acceptRefundTransfer(Pool storage pool)\n\n        public \n\n        onlyInStates2(pool, State.Distribution, State.FullRefund)  \n\n    {\n\n        require(msg.value > 0);\n\n        require(msg.sender == pool.refundAddress);\n\n\n\n        emit RefundReceived(\n\n            msg.sender, \n\n            msg.value\n\n        );\n",
          "message": "ProPoolLib.acceptRefundTransfer (ProPoolLib.sol#776-787) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 792,
          "vulnerability_to_line": 815,
          "vulnerability_code": "    function getPoolDetails1(Pool storage pool) \n\n        public view \n\n        returns (     \n\n            uint libVersion,\n\n            uint groupsCount,\n\n            uint currentState,\n\n            uint svcFeePerEther,\n\n            bool feeToTokenMode,            \n\n            address presaleAddress,\n\n            address feeToTokenAddress,            \n\n            address[] participants,\n\n            address[] admins\n\n        )\n\n    {\n\n        libVersion = version();\n\n        currentState = uint(pool.state);\n\n        groupsCount = pool.groups.length;\n\n        svcFeePerEther = pool.svcFeePerEther;\n\n        feeToTokenMode = pool.feeToTokenMode;        \n\n        presaleAddress = pool.presaleAddress;\n\n        feeToTokenAddress = pool.feeToTokenAddress;        \n\n        participants = pool.participants;\n\n        admins = pool.admins;\n",
          "message": "ProPoolLib.getPoolDetails1 (ProPoolLib.sol#792-815) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 820,
          "vulnerability_to_line": 841,
          "vulnerability_code": "    function getPoolDetails2(Pool storage pool) \n\n        public view \n\n        returns (      \n\n            uint refundBalance,\n\n            address refundAddress,\n\n            address[] tokenAddresses,\n\n            uint[] tokenBalances\n\n        )\n\n    {                                                \n\n        if(pool.state == State.Distribution || pool.state == State.FullRefund) {                 \n\n            uint poolRemaining;\n\n            (,poolRemaining,) = calcPoolSummary(pool);\n\n            refundBalance = address(this).balance - poolRemaining;\n\n            refundAddress = pool.refundAddress;\n\n            \n\n            tokenAddresses = pool.tokenAddresses;\n\n            tokenBalances = new uint[](tokenAddresses.length);\n\n            for(uint i = 0; i < tokenAddresses.length; i++) {\n\n                tokenBalances[i] = IERC20Base(tokenAddresses[i]).balanceOf(address(this));\n\n            }\n\n        }\n",
          "message": "ProPoolLib.getPoolDetails2 (ProPoolLib.sol#820-841) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 846,
          "vulnerability_to_line": 870,
          "vulnerability_code": "    function getParticipantDetails(Pool storage pool, address addr)\n\n        public view \n\n        returns (\n\n            uint[] contribution,\n\n            uint[] remaining,\n\n            bool[] whitelist,\n\n            bool isAdmin,\n\n            bool exists\n\n        ) \n\n    {\n\n        Participant storage part = pool.participantToData[addr];\n\n        isAdmin = part.isAdmin;                \n\n        exists = part.exists;\n\n\n\n        uint length = pool.groups.length;\n\n        contribution = new uint[](length);\n\n        remaining = new uint[](length);\n\n        whitelist = new bool[](length);        \n\n\n\n        for(uint i = 0; i < length; i++) {\n\n            contribution[i] = part.contribution[i];\n\n            remaining[i] = part.remaining[i];\n\n            whitelist[i] = part.whitelist[i];\n\n        }                      \n",
          "message": "ProPoolLib.getParticipantDetails (ProPoolLib.sol#846-870) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 875,
          "vulnerability_to_line": 910,
          "vulnerability_code": "    function getParticipantShares(Pool storage pool, address addr) public view returns (uint[] tokenShare, uint refundShare) {       \n\n        if(pool.state == State.Distribution || pool.state == State.FullRefund) {\n\n            uint netPoolContribution;\n\n            uint netPartContribution;\n\n            uint poolRemaining;\n\n            uint poolCtorFee;   \n\n\n\n            (netPoolContribution, netPartContribution, poolRemaining, poolCtorFee) = calcPoolSummary3(pool, addr);\n\n            tokenShare = new uint[](pool.tokenAddresses.length);\n\n\n\n            if(netPartContribution > 0) {\n\n                refundShare = pool.refundQuota.calcShare(\n\n                    addr, \n\n                    address(this).balance - poolRemaining,\n\n                    [netPartContribution, netPoolContribution]\n\n                );        \n\n            }     \n\n\n\n            if(pool.feeToTokenMode) {\n\n                netPoolContribution += poolCtorFee;\n\n                if(pool.feeToTokenAddress == addr) {\n\n                    netPartContribution += poolCtorFee;\n\n                }\n\n            }  \n\n\n\n            if(netPartContribution > 0) {\n\n                for(uint i = 0; i < pool.tokenAddresses.length; i++) {\n\n                    tokenShare[i] = pool.tokenQuota[pool.tokenAddresses[i]].calcShare(\n\n                        addr,\n\n                        IERC20Base(pool.tokenAddresses[i]).balanceOf(address(this)),\n\n                        [netPartContribution, netPoolContribution]\n\n                    );                \n\n                }      \n\n            }\n\n        }  \n",
          "message": "ProPoolLib.getParticipantShares (ProPoolLib.sol#875-910) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 915,
          "vulnerability_to_line": 937,
          "vulnerability_code": "    function getGroupDetails(Pool storage pool, uint idx)\n\n        public view \n\n        returns (\n\n            uint contributionBalance,\n\n            uint remainingBalance,\n\n            uint maxBalance,\n\n            uint minContribution,                 \n\n            uint maxContribution,\n\n            uint ctorFeePerEther,\n\n            bool isRestricted,\n\n            bool exists\n\n        ) \n\n    {\n\n        Group storage group = pool.groups[idx];                                                \n\n        contributionBalance = group.contribution;\n\n        remainingBalance = group.remaining;\n\n        maxBalance = group.maxBalance;\n\n        minContribution = group.minContribution;\n\n        maxContribution = group.maxContribution;\n\n        ctorFeePerEther = group.ctorFeePerEther;\n\n        isRestricted = group.isRestricted;\n\n        exists = group.exists;\n",
          "message": "ProPoolLib.getGroupDetails (ProPoolLib.sol#915-937) should be declared external\n"
        },
        {
          "name": "low-level-calls",
          "vulnerability_from_line": 1477,
          "vulnerability_to_line": 1490,
          "vulnerability_code": "    function addressCall(address destination, uint gasAmount,  uint etherAmount, bytes data) private {\n\n        emit AddressCall(\n\n            destination,\n\n            etherAmount,\n\n            gasAmount > 0 ? gasAmount : gasleft(),\n\n            data\n\n        );\n\n        require(\n\n            destination.call\n\n            .gas(gasAmount > 0 ? gasAmount : gasleft())\n\n            .value(etherAmount)\n\n            (data)            \n\n        );\n",
          "message": "Low level call in ProPoolLib.addressCall (ProPoolLib.sol#1477-1490):\n\t-require(bool)(destination.call.gas(gasAmount).value(etherAmount)(data)) ProPoolLib.sol#1484-1489\n\t-require(bool)(destination.call.gas(gasleft()()).value(etherAmount)(data)) ProPoolLib.sol#1484-1489\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 37,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function max(uint256 _a, uint256 _b) internal pure returns (uint256) {\n",
          "message": "Parameter '_a' of Math.max (ProPoolLib.sol#37) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 37,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function max(uint256 _a, uint256 _b) internal pure returns (uint256) {\n",
          "message": "Parameter '_b' of Math.max (ProPoolLib.sol#37) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 41,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function min(uint256 _a, uint256 _b) internal pure returns (uint256) {\n",
          "message": "Parameter '_a' of Math.min (ProPoolLib.sol#41) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 41,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function min(uint256 _a, uint256 _b) internal pure returns (uint256) {\n",
          "message": "Parameter '_b' of Math.min (ProPoolLib.sol#41) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 45,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function average(uint256 _a, uint256 _b) internal pure returns (uint256) {\n",
          "message": "Parameter '_a' of Math.average (ProPoolLib.sol#45) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 45,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function average(uint256 _a, uint256 _b) internal pure returns (uint256) {\n",
          "message": "Parameter '_b' of Math.average (ProPoolLib.sol#45) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 65,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\n",
          "message": "Parameter '_a' of SafeMath.mul (ProPoolLib.sol#65) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 65,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\n",
          "message": "Parameter '_b' of SafeMath.mul (ProPoolLib.sol#65) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 82,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n",
          "message": "Parameter '_a' of SafeMath.div (ProPoolLib.sol#82) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 82,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n",
          "message": "Parameter '_b' of SafeMath.div (ProPoolLib.sol#82) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 93,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n",
          "message": "Parameter '_a' of SafeMath.sub (ProPoolLib.sol#93) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 93,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n",
          "message": "Parameter '_b' of SafeMath.sub (ProPoolLib.sol#93) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 103,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\n",
          "message": "Parameter '_a' of SafeMath.add (ProPoolLib.sol#103) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 103,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\n",
          "message": "Parameter '_b' of SafeMath.add (ProPoolLib.sol#103) is not in mixedCase\n"
        }
      ]
    },
    "smartcheck": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 400,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(uint i = 0; i < admins.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 837,
          "vulnerability_to_line": null,
          "vulnerability_code": "            for(uint i = 0; i < tokenAddresses.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 901,
          "vulnerability_to_line": null,
          "vulnerability_code": "                for(uint i = 0; i < pool.tokenAddresses.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 1310,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(i = 0; i < exclude.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 1322,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(i = 0; i < include.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 1387,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(uint i = 0; i < pool.participants.length; i++) {           \n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 1642,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < array.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
          "vulnerability_from_line": 1049,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function withdrawAllRemaining2(Pool storage pool) \n",
          "message": null
        },
        {
          "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
          "vulnerability_from_line": 1541,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function calcPoolSummary(Pool storage pool) \n",
          "message": null
        },
        {
          "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
          "vulnerability_from_line": 1568,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function calcPoolSummary2(Pool storage pool, address addr) \n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 400,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(uint i = 0; i < admins.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 837,
          "vulnerability_to_line": null,
          "vulnerability_code": "            for(uint i = 0; i < tokenAddresses.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 865,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(uint i = 0; i < length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 901,
          "vulnerability_to_line": null,
          "vulnerability_code": "                for(uint i = 0; i < pool.tokenAddresses.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 962,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(uint idx = 0; idx < length; idx++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 1016,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(uint idx = 0; idx < length; idx++) {            \n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 1067,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(uint idx = 0; idx < length; idx++) {                        \n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 1197,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(uint i = 0; i < length; i++) {             \n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 1310,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(i = 0; i < exclude.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 1322,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(i = 0; i < include.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 1387,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(uint i = 0; i < pool.participants.length; i++) {           \n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 1553,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(uint idx = 0; idx < length; idx++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 1583,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(uint idx = 0; idx < length; idx++) {            \n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 1642,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < array.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_LOCKED_MONEY",
          "vulnerability_from_line": 22,
          "vulnerability_to_line": null,
          "vulnerability_code": "contract IFeeService {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.24;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 16,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.24;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 29,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.24;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 53,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.24;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 122,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.24;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 182,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.24;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SAFEMATH",
          "vulnerability_from_line": 128,
          "vulnerability_to_line": null,
          "vulnerability_code": "    using SafeMath for uint;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 1052,
          "vulnerability_to_line": null,
          "vulnerability_code": "    (\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 1506,
          "vulnerability_to_line": null,
          "vulnerability_code": "        returns(uint contribution, uint remaining)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 1544,
          "vulnerability_to_line": null,
          "vulnerability_code": "    (\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 1571,
          "vulnerability_to_line": null,
          "vulnerability_code": "    (\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 1604,
          "vulnerability_to_line": null,
          "vulnerability_code": "    (\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 375,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address[] whitelist,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 376,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address[] admins\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 462,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function modifyWhitelist(Pool storage pool, uint idx, address[] include, address[] exclude)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 462,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function modifyWhitelist(Pool storage pool, uint idx, address[] include, address[] exclude)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 560,
          "vulnerability_to_line": null,
          "vulnerability_code": "        bytes data\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 761,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function tokenFallback(Pool storage pool, address from, uint value, bytes data)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 802,
          "vulnerability_to_line": null,
          "vulnerability_code": "            address[] participants,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 803,
          "vulnerability_to_line": null,
          "vulnerability_code": "            address[] admins\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 825,
          "vulnerability_to_line": null,
          "vulnerability_code": "            address[] tokenAddresses,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 826,
          "vulnerability_to_line": null,
          "vulnerability_code": "            uint[] tokenBalances\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 849,
          "vulnerability_to_line": null,
          "vulnerability_code": "            uint[] contribution,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 850,
          "vulnerability_to_line": null,
          "vulnerability_code": "            uint[] remaining,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 851,
          "vulnerability_to_line": null,
          "vulnerability_code": "            bool[] whitelist,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 875,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getParticipantShares(Pool storage pool, address addr) public view returns (uint[] tokenShare, uint refundShare) {       \n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 1294,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function modifyWhitelistCore(Pool storage pool, uint idx, address[] include, address[] exclude) private {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 1294,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function modifyWhitelistCore(Pool storage pool, uint idx, address[] include, address[] exclude) private {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 1470,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function addressCall(address destination, uint etherAmount, bytes data) private {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 1477,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function addressCall(address destination, uint gasAmount,  uint etherAmount, bytes data) private {\n",
          "message": null
        }
      ]
    },
    "oyente": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "Integer Overflow",
          "vulnerability_from_line": 928,
          "vulnerability_to_line": null,
          "vulnerability_code": "        Group storage group = pool.groups[idx];                                                \n",
          "message": null
        },
        {
          "name": "Integer Underflow",
          "vulnerability_from_line": 698,
          "vulnerability_to_line": null,
          "vulnerability_code": "        group.remaining -= participant.remaining[idx];        \n",
          "message": null
        },
        {
          "name": "Transaction-Ordering Dependence (TOD)",
          "vulnerability_from_line": null,
          "vulnerability_to_line": null,
          "vulnerability_code": null,
          "message": null
        }
      ]
    },
    "mythril": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "Exception State (SWC 110)",
          "vulnerability_from_line": 915,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getGroupDetails(Pool storage pool, uint idx)\n",
          "message": "An assertion violation was triggered.\nIt is possible to trigger an assertion violation. Note that Solidity assert() statements should only be used to check invariants. Review the transaction trace generated for this issue and either make sure your program logic is correct, or use require() instead of assert() if your goal is to constrain user inputs or enforce preconditions. Remember to validate inputs from both callers (for instance, via passed arguments) and callees (for instance, via return values).\nClassification: SWC-110"
        }
      ]
    },
    "osiris": {
      "successfull_analysis": true,
      "errors": [
        "SYMBOLIC EXECUTION TIMEOUT"
      ],
      "vulnerability_findings": [
        {
          "name": "Concurrency bug",
          "vulnerability_from_line": 1464,
          "vulnerability_to_line": null,
          "vulnerability_code": "        destination.transfer(etherAmount);        \n",
          "message": null
        },
        {
          "name": "Overflow bugs",
          "vulnerability_from_line": 820,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getPoolDetails2(Pool storage pool) \n",
          "message": null
        },
        {
          "name": "Overflow bugs",
          "vulnerability_from_line": 835,
          "vulnerability_to_line": null,
          "vulnerability_code": "            tokenAddresses = pool.tokenAddresses;\n",
          "message": null
        },
        {
          "name": "Overflow bugs",
          "vulnerability_from_line": 836,
          "vulnerability_to_line": null,
          "vulnerability_code": "            tokenBalances = new uint[](tokenAddresses.length);\n",
          "message": null
        },
        {
          "name": "Overflow bugs",
          "vulnerability_from_line": 838,
          "vulnerability_to_line": null,
          "vulnerability_code": "                tokenBalances[i] = IERC20Base(tokenAddresses[i]).balanceOf(address(this));\n",
          "message": null
        },
        {
          "name": "Overflow bugs",
          "vulnerability_from_line": 1560,
          "vulnerability_to_line": null,
          "vulnerability_code": "            poolContribution += group.contribution;            \n",
          "message": null
        },
        {
          "name": "Underflow bugs",
          "vulnerability_from_line": 698,
          "vulnerability_to_line": null,
          "vulnerability_code": "        group.remaining -= participant.remaining[idx];        \n",
          "message": null
        },
        {
          "name": "Underflow bugs",
          "vulnerability_from_line": 701,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint extra = finalAmount - participant.remaining[idx];        \n",
          "message": null
        },
        {
          "name": "Underflow bugs",
          "vulnerability_from_line": 709,
          "vulnerability_to_line": null,
          "vulnerability_code": "            group.contribution -= extra;            \n",
          "message": null
        }
      ]
    }
  }
}