{
  "smartbugs_completed": true,
  "analyzer_results": {
    "semgrep": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": []
    },
    "slither": {
      "successfull_analysis": true,
      "errors": [
        "EXIT_CODE_10"
      ],
      "vulnerability_findings": [
        {
          "name": "shadowing-local",
          "vulnerability_from_line": 321,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setInterfaceImplementer(address account, bytes32 interfaceHash, address implementer) external;\n",
          "message": "IERC1820Registry.setInterfaceImplementer.interfaceHash (local variable @ ERC777SenderRecipientMock.sol#321) shadows:\n\t- IERC1820Registry.interfaceHash (function @ ERC777SenderRecipientMock.sol#339)\n"
        },
        {
          "name": "shadowing-local",
          "vulnerability_from_line": 332,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getInterfaceImplementer(address account, bytes32 interfaceHash) external view returns (address);\n",
          "message": "IERC1820Registry.getInterfaceImplementer.interfaceHash (local variable @ ERC777SenderRecipientMock.sol#332) shadows:\n\t- IERC1820Registry.interfaceHash (function @ ERC777SenderRecipientMock.sol#339)\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 531,
          "vulnerability_to_line": 538,
          "vulnerability_code": "    function senderFor(address account) public {\n\n        _registerInterfaceForAddress(TOKENS_SENDER_INTERFACE_HASH, account);\n\n\n\n        address self = address(this);\n\n        if (account == self) {\n\n            registerSender(self);\n\n        }\n",
          "message": "ERC777SenderRecipientMock.senderFor (ERC777SenderRecipientMock.sol#531-538) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 544,
          "vulnerability_to_line": 551,
          "vulnerability_code": "    function recipientFor(address account) public {\n\n        _registerInterfaceForAddress(TOKENS_RECIPIENT_INTERFACE_HASH, account);\n\n\n\n        address self = address(this);\n\n        if (account == self) {\n\n            registerRecipient(self);\n\n        }\n",
          "message": "ERC777SenderRecipientMock.recipientFor (ERC777SenderRecipientMock.sol#544-551) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 557,
          "vulnerability_to_line": 559,
          "vulnerability_code": "    function setShouldRevertSend(bool shouldRevert) public {\n\n        _shouldRevertSend = shouldRevert;\n",
          "message": "ERC777SenderRecipientMock.setShouldRevertSend (ERC777SenderRecipientMock.sol#557-559) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 561,
          "vulnerability_to_line": 563,
          "vulnerability_code": "    function setShouldRevertReceive(bool shouldRevert) public {\n\n        _shouldRevertReceive = shouldRevert;\n",
          "message": "ERC777SenderRecipientMock.setShouldRevertReceive (ERC777SenderRecipientMock.sol#561-563) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 565,
          "vulnerability_to_line": 568,
          "vulnerability_code": "    function send(IERC777 token, address to, uint256 amount, bytes memory data) public {\n\n        // This is 777's send function, not the Solidity send function\n\n        token.send(to, amount, data); // solhint-disable-line check-send-result\n",
          "message": "ERC777SenderRecipientMock.send (ERC777SenderRecipientMock.sol#565-568) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 570,
          "vulnerability_to_line": 572,
          "vulnerability_code": "    function burn(IERC777 token, uint256 amount, bytes memory data) public {\n\n        token.burn(amount, data);\n",
          "message": "ERC777SenderRecipientMock.burn (ERC777SenderRecipientMock.sol#570-572) should be declared external\n"
        },
        {
          "name": "solc-version",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.0;\n",
          "message": "Detected issues with version pragma in ERC777SenderRecipientMock.sol:\n\t- pragma solidity^0.5.0 (ERC777SenderRecipientMock.sol#3): it allows old versions\n\t- pragma solidity^0.5.0 (ERC777SenderRecipientMock.sol#192): it allows old versions\n\t- pragma solidity^0.5.0 (ERC777SenderRecipientMock.sol#227): it allows old versions\n\t- pragma solidity^0.5.0 (ERC777SenderRecipientMock.sol#262): it allows old versions\n\t- pragma solidity^0.5.0 (ERC777SenderRecipientMock.sol#374): it allows old versions\n\t- pragma solidity^0.5.0 (ERC777SenderRecipientMock.sol#394): it allows old versions\n\t- pragma solidity^0.5.0 (ERC777SenderRecipientMock.sol#430): it allows old versions\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 423,
          "vulnerability_to_line": 425,
          "vulnerability_code": "    function _registerInterfaceForAddress(bytes32 interfaceHash, address account) internal {\n\n        _supportedInterfaces[interfaceHash][account] = true;\n",
          "message": "Function 'ERC1820Implementer._registerInterfaceForAddress' (ERC777SenderRecipientMock.sol#423-425) is not in mixedCase\n"
        }
      ]
    },
    "smartcheck": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 464,
          "vulnerability_to_line": null,
          "vulnerability_code": "    IERC1820Registry private _erc1820 = IERC1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 413,
          "vulnerability_to_line": null,
          "vulnerability_code": "        return _supportedInterfaces[interfaceHash][account] ? ERC1820_ACCEPT_MAGIC : bytes32(0x00);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 192,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 227,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 262,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 374,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 394,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 430,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 405,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bytes32 constant private ERC1820_ACCEPT_MAGIC = keccak256(abi.encodePacked(\"ERC1820_ACCEPT_MAGIC\"));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 407,
          "vulnerability_to_line": null,
          "vulnerability_code": "    mapping(bytes32 => mapping(address => bool)) private _supportedInterfaces;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 461,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bool private _shouldRevertSend;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 462,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bool private _shouldRevertReceive;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 464,
          "vulnerability_to_line": null,
          "vulnerability_code": "    IERC1820Registry private _erc1820 = IERC1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 466,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bytes32 constant private TOKENS_SENDER_INTERFACE_HASH = keccak256(\"ERC777TokensSender\");\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 467,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bytes32 constant private TOKENS_RECIPIENT_INTERFACE_HASH = keccak256(\"ERC777TokensRecipient\");\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 142,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function operatorSend(\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 165,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function operatorBurn(\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 215,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function tokensToSend(\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 250,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function tokensReceived(\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 469,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function tokensToSend(\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 146,
          "vulnerability_to_line": null,
          "vulnerability_code": "        bytes calldata data,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 147,
          "vulnerability_to_line": null,
          "vulnerability_code": "        bytes calldata operatorData\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 168,
          "vulnerability_to_line": null,
          "vulnerability_code": "        bytes calldata data,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 169,
          "vulnerability_to_line": null,
          "vulnerability_code": "        bytes calldata operatorData\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 220,
          "vulnerability_to_line": null,
          "vulnerability_code": "        bytes calldata userData,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 221,
          "vulnerability_to_line": null,
          "vulnerability_code": "        bytes calldata operatorData\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 255,
          "vulnerability_to_line": null,
          "vulnerability_code": "        bytes calldata userData,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 256,
          "vulnerability_to_line": null,
          "vulnerability_code": "        bytes calldata operatorData\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 474,
          "vulnerability_to_line": null,
          "vulnerability_code": "        bytes calldata userData,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 475,
          "vulnerability_to_line": null,
          "vulnerability_code": "        bytes calldata operatorData\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 477,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (_shouldRevertSend) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 478,
          "vulnerability_to_line": null,
          "vulnerability_code": "            revert();\n",
          "message": null
        }
      ]
    },
    "oyente": {
      "successfull_analysis": false,
      "errors": [
        "exception (RuntimeError: Source map error, unknown name(SHR) or instr_name(INVALID))"
      ],
      "vulnerability_findings": []
    },
    "mythril": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "Multiple Calls in a Single Transaction (SWC 113)",
          "vulnerability_from_line": 516,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint256 toBalance = token.balanceOf(to);\n",
          "message": "Multiple calls are executed in the same transaction.\nThis call is executed following another call within the same transaction. It is possible that the call never gets executed if a prior call fails permanently. This might be caused intentionally by a malicious callee. If possible, refactor the code such that each transaction only executes one external call or make sure that all callees can be trusted (i.e. they\u2019re part of your own codebase).\nClassification: SWC-113"
        },
        {
          "name": "External Call To User-Supplied Address (SWC 107)",
          "vulnerability_from_line": 567,
          "vulnerability_to_line": null,
          "vulnerability_code": "        token.send(to, amount, data); // solhint-disable-line check-send-result\n",
          "message": "A call to a user-supplied address is executed.\nAn external message call to an address specified by the caller is executed. Note that the callee account might contain arbitrary code and could re-enter any function within this contract. Reentering the contract in an intermediate state may lead to unexpected behaviour. Make sure that no state modifications are executed after this call and/or reentrancy guards are in place.\nClassification: SWC-107"
        },
        {
          "name": "External Call To User-Supplied Address (SWC 107)",
          "vulnerability_from_line": 571,
          "vulnerability_to_line": null,
          "vulnerability_code": "        token.burn(amount, data);\n",
          "message": "A call to a user-supplied address is executed.\nAn external message call to an address specified by the caller is executed. Note that the callee account might contain arbitrary code and could re-enter any function within this contract. Reentering the contract in an intermediate state may lead to unexpected behaviour. Make sure that no state modifications are executed after this call and/or reentrancy guards are in place.\nClassification: SWC-107"
        },
        {
          "name": "Multiple Calls in a Single Transaction (SWC 113)",
          "vulnerability_from_line": 485,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint256 toBalance = token.balanceOf(to);\n",
          "message": "Multiple calls are executed in the same transaction.\nThis call is executed following another call within the same transaction. It is possible that the call never gets executed if a prior call fails permanently. This might be caused intentionally by a malicious callee. If possible, refactor the code such that each transaction only executes one external call or make sure that all callees can be trusted (i.e. they\u2019re part of your own codebase).\nClassification: SWC-113"
        }
      ]
    },
    "osiris": {
      "successfull_analysis": false,
      "errors": [
        "Solidity compilation failed"
      ],
      "vulnerability_findings": []
    }
  }
}