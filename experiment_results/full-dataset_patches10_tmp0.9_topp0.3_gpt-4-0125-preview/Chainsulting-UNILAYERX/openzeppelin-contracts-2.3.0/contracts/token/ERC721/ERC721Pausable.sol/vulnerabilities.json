{
  "smartbugs_completed": true,
  "analyzer_results": {
    "semgrep": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 307,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor () internal {\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 308,
          "vulnerability_to_line": null,
          "vulnerability_code": "        // Derived contracts need only register support for their own interfaces,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 309,
          "vulnerability_to_line": null,
          "vulnerability_code": "        // we register support for ERC165 itself here\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 310,
          "vulnerability_to_line": null,
          "vulnerability_code": "        _registerInterface(_INTERFACE_ID_ERC165);\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 311,
          "vulnerability_to_line": null,
          "vulnerability_code": "    }\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 389,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor () public {\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 390,
          "vulnerability_to_line": null,
          "vulnerability_code": "        // register the supported interfaces to conform to ERC721 via ERC165\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 391,
          "vulnerability_to_line": null,
          "vulnerability_code": "        _registerInterface(_INTERFACE_ID_ERC721);\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 392,
          "vulnerability_to_line": null,
          "vulnerability_code": "    }\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 691,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor () internal {\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 692,
          "vulnerability_to_line": null,
          "vulnerability_code": "        _addPauser(msg.sender);\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 693,
          "vulnerability_to_line": null,
          "vulnerability_code": "    }\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 753,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor () internal {\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 754,
          "vulnerability_to_line": null,
          "vulnerability_code": "        _paused = false;\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 755,
          "vulnerability_to_line": null,
          "vulnerability_code": "    }\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 137,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(c >= a, \"SafeMath: addition overflow\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 152,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(b <= a, \"SafeMath: subtraction overflow\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 176,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(c / a == b, \"SafeMath: multiplication overflow\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 194,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(b > 0, \"SafeMath: division by zero\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 213,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(b != 0, \"SafeMath: modulo by zero\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 334,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(interfaceId != 0xffffffff, \"ERC165: invalid interface id\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 400,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(owner != address(0), \"ERC721: balance query for the zero address\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 412,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(owner != address(0), \"ERC721: owner query for nonexistent token\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 427,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(to != owner, \"ERC721: approval to current owner\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 429,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == owner || isApprovedForAll(owner, msg.sender),\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 430,
          "vulnerability_to_line": null,
          "vulnerability_code": "            \"ERC721: approve caller is not owner nor approved for all\"\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 431,
          "vulnerability_to_line": null,
          "vulnerability_code": "        );\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 444,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 456,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(to != msg.sender, \"ERC721: approve to caller\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 482,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_isApprovedOrOwner(msg.sender, tokenId), \"ERC721: transfer caller is not owner nor approved\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 516,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 537,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 549,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(to != address(0), \"ERC721: mint to the zero address\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 550,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(!_exists(tokenId), \"ERC721: token already minted\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 566,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(ownerOf(tokenId) == owner, \"ERC721: burn of token that is not own\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 593,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(ownerOf(tokenId) == from, \"ERC721: transfer of token that is not own\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 594,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(to != address(0), \"ERC721: transfer to the zero address\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 657,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(!has(role, account), \"Roles: account already has role\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 665,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(has(role, account), \"Roles: account does not have role\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 674,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(account != address(0), \"Roles: account is the zero address\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 696,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(isPauser(msg.sender), \"PauserRole: caller does not have the Pauser role\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 768,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(!_paused, \"Pausable: paused\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 776,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_paused, \"Pausable: not paused\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 176,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(c / a == b, \"SafeMath: multiplication overflow\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 400,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(owner != address(0), \"ERC721: balance query for the zero address\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 412,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(owner != address(0), \"ERC721: owner query for nonexistent token\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 427,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(to != owner, \"ERC721: approval to current owner\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 429,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == owner || isApprovedForAll(owner, msg.sender),\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 430,
          "vulnerability_to_line": null,
          "vulnerability_code": "            \"ERC721: approve caller is not owner nor approved for all\"\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 431,
          "vulnerability_to_line": null,
          "vulnerability_code": "        );\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 444,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 482,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_isApprovedOrOwner(msg.sender, tokenId), \"ERC721: transfer caller is not owner nor approved\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 516,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 537,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 566,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(ownerOf(tokenId) == owner, \"ERC721: burn of token that is not own\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 593,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(ownerOf(tokenId) == from, \"ERC721: transfer of token that is not own\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 594,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(to != address(0), \"ERC721: transfer to the zero address\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 665,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(has(role, account), \"Roles: account does not have role\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 674,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(account != address(0), \"Roles: account is the zero address\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 696,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(isPauser(msg.sender), \"PauserRole: caller does not have the Pauser role\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "erc721-reentrancy",
          "vulnerability_from_line": 516,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n",
          "message": "ERC721 onERC721Received() reentrancy"
        }
      ]
    },
    "slither": {
      "successfull_analysis": true,
      "errors": [
        "EXIT_CODE_30"
      ],
      "vulnerability_findings": [
        {
          "name": "uninitialized-state",
          "vulnerability_from_line": 368,
          "vulnerability_to_line": null,
          "vulnerability_code": "    mapping (address => Counters.Counter) private _ownedTokensCount;\n",
          "message": "ERC721._ownedTokensCount (ERC721Pausable.sol#368) is never initialized. It is used in:\n\t- balanceOf (ERC721Pausable.sol#399-403)\n\t- _mint (ERC721Pausable.sol#548-556)\n\t- _burn (ERC721Pausable.sol#565-574)\n\t- _transferFrom (ERC721Pausable.sol#592-604)\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 236,
          "vulnerability_to_line": 245,
          "vulnerability_code": "    function isContract(address account) internal view returns (bool) {\n\n        // This method relies in extcodesize, which returns 0 for contracts in\n\n        // construction, since the code is only stored at the end of the\n\n        // constructor execution.\n\n\n\n        uint256 size;\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly { size := extcodesize(account) }\n\n        return size > 0;\n",
          "message": "Address.isContract (ERC721Pausable.sol#236-245) is declared view but contains assembly code\n"
        },
        {
          "name": "erc20-interface",
          "vulnerability_from_line": 33,
          "vulnerability_to_line": 78,
          "vulnerability_code": "contract IERC721 is IERC165 {\n\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n\n\n    /**\n\n     * @dev Returns the number of NFTs in `owner`'s account.\n\n     */\n\n    function balanceOf(address owner) public view returns (uint256 balance);\n\n\n\n    /**\n\n     * @dev Returns the owner of the NFT specified by `tokenId`.\n\n     */\n\n    function ownerOf(uint256 tokenId) public view returns (address owner);\n\n\n\n    /**\n\n     * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\n\n     * another (`to`).\n\n     *\n\n     * \n\n     *\n\n     * Requirements:\n\n     * - `from`, `to` cannot be zero.\n\n     * - `tokenId` must be owned by `from`.\n\n     * - If the caller is not `from`, it must be have been allowed to move this\n\n     * NFT by either `approve` or `setApproveForAll`.\n\n     */\n\n    function safeTransferFrom(address from, address to, uint256 tokenId) public;\n\n    /**\n\n     * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\n\n     * another (`to`).\n\n     *\n\n     * Requirements:\n\n     * - If the caller is not `from`, it must be approved to move this NFT by\n\n     * either `approve` or `setApproveForAll`.\n\n     */\n\n    function transferFrom(address from, address to, uint256 tokenId) public;\n\n    function approve(address to, uint256 tokenId) public;\n\n    function getApproved(uint256 tokenId) public view returns (address operator);\n\n\n\n    function setApprovalForAll(address operator, bool _approved) public;\n\n    function isApprovedForAll(address owner, address operator) public view returns (bool);\n\n\n\n\n\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public;\n",
          "message": "IERC721 (ERC721Pausable.sol#33-78) has incorrect ERC20 function interface(s):\n\t-transferFrom (ERC721Pausable.sol#69)\n\t-approve (ERC721Pausable.sol#70)\n"
        },
        {
          "name": "erc20-interface",
          "vulnerability_from_line": 352,
          "vulnerability_to_line": 637,
          "vulnerability_code": "contract ERC721 is ERC165, IERC721 {\n\n    using SafeMath for uint256;\n\n    using Address for address;\n\n    using Counters for Counters.Counter;\n\n\n\n    // Equals to `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n\n    // which can be also obtained as `IERC721Receiver(0).onERC721Received.selector`\n\n    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\n\n\n\n    // Mapping from token ID to owner\n\n    mapping (uint256 => address) private _tokenOwner;\n\n\n\n    // Mapping from token ID to approved address\n\n    mapping (uint256 => address) private _tokenApprovals;\n\n\n\n    // Mapping from owner to number of owned token\n\n    mapping (address => Counters.Counter) private _ownedTokensCount;\n\n\n\n    // Mapping from owner to operator approvals\n\n    mapping (address => mapping (address => bool)) private _operatorApprovals;\n\n\n\n    /*\n\n     *     bytes4(keccak256('balanceOf(address)')) == 0x70a08231\n\n     *     bytes4(keccak256('ownerOf(uint256)')) == 0x6352211e\n\n     *     bytes4(keccak256('approve(address,uint256)')) == 0x095ea7b3\n\n     *     bytes4(keccak256('getApproved(uint256)')) == 0x081812fc\n\n     *     bytes4(keccak256('setApprovalForAll(address,bool)')) == 0xa22cb465\n\n     *     bytes4(keccak256('isApprovedForAll(address,address)')) == 0xe985e9c\n\n     *     bytes4(keccak256('transferFrom(address,address,uint256)')) == 0x23b872dd\n\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256)')) == 0x42842e0e\n\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)')) == 0xb88d4fde\n\n     *\n\n     *     => 0x70a08231 ^ 0x6352211e ^ 0x095ea7b3 ^ 0x081812fc ^\n\n     *        0xa22cb465 ^ 0xe985e9c ^ 0x23b872dd ^ 0x42842e0e ^ 0xb88d4fde == 0x80ac58cd\n\n     */\n\n    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\n\n\n\n    constructor () public {\n\n        // register the supported interfaces to conform to ERC721 via ERC165\n\n        _registerInterface(_INTERFACE_ID_ERC721);\n\n    }\n\n\n\n    /**\n\n     * @dev Gets the balance of the specified address.\n\n     * @param owner address to query the balance of\n\n     * @return uint256 representing the amount owned by the passed address\n\n     */\n\n    function balanceOf(address owner) public view returns (uint256) {\n\n        require(owner != address(0), \"ERC721: balance query for the zero address\");\n\n\n\n        return _ownedTokensCount[owner].current();\n\n    }\n\n\n\n    /**\n\n     * @dev Gets the owner of the specified token ID.\n\n     * @param tokenId uint256 ID of the token to query the owner of\n\n     * @return address currently marked as the owner of the given token ID\n\n     */\n\n    function ownerOf(uint256 tokenId) public view returns (address) {\n\n        address owner = _tokenOwner[tokenId];\n\n        require(owner != address(0), \"ERC721: owner query for nonexistent token\");\n\n\n\n        return owner;\n\n    }\n\n\n\n    /**\n\n     * @dev Approves another address to transfer the given token ID\n\n     * The zero address indicates there is no approved address.\n\n     * There can only be one approved address per token at a given time.\n\n     * Can only be called by the token owner or an approved operator.\n\n     * @param to address to be approved for the given token ID\n\n     * @param tokenId uint256 ID of the token to be approved\n\n     */\n\n    function approve(address to, uint256 tokenId) public {\n\n        address owner = ownerOf(tokenId);\n\n        require(to != owner, \"ERC721: approval to current owner\");\n\n\n\n        require(msg.sender == owner || isApprovedForAll(owner, msg.sender),\n\n            \"ERC721: approve caller is not owner nor approved for all\"\n\n        );\n\n\n\n        _tokenApprovals[tokenId] = to;\n\n        emit Approval(owner, to, tokenId);\n\n    }\n\n\n\n    /**\n\n     * @dev Gets the approved address for a token ID, or zero if no address set\n\n     * Reverts if the token ID does not exist.\n\n     * @param tokenId uint256 ID of the token to query the approval of\n\n     * @return address currently approved for the given token ID\n\n     */\n\n    function getApproved(uint256 tokenId) public view returns (address) {\n\n        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\n\n\n\n        return _tokenApprovals[tokenId];\n\n    }\n\n\n\n    /**\n\n     * @dev Sets or unsets the approval of a given operator\n\n     * An operator is allowed to transfer all tokens of the sender on their behalf.\n\n     * @param to operator address to set the approval\n\n     * @param approved representing the status of the approval to be set\n\n     */\n\n    function setApprovalForAll(address to, bool approved) public {\n\n        require(to != msg.sender, \"ERC721: approve to caller\");\n\n\n\n        _operatorApprovals[msg.sender][to] = approved;\n\n        emit ApprovalForAll(msg.sender, to, approved);\n\n    }\n\n\n\n    /**\n\n     * @dev Tells whether an operator is approved by a given owner.\n\n     * @param owner owner address which you want to query the approval of\n\n     * @param operator operator address which you want to query the approval of\n\n     * @return bool whether the given operator is approved by the given owner\n\n     */\n\n    function isApprovedForAll(address owner, address operator) public view returns (bool) {\n\n        return _operatorApprovals[owner][operator];\n\n    }\n\n\n\n    /**\n\n     * @dev Transfers the ownership of a given token ID to another address.\n\n     * Usage of this method is discouraged, use `safeTransferFrom` whenever possible.\n\n     * Requires the msg.sender to be the owner, approved, or operator.\n\n     * @param from current owner of the token\n\n     * @param to address to receive the ownership of the given token ID\n\n     * @param tokenId uint256 ID of the token to be transferred\n\n     */\n\n    function transferFrom(address from, address to, uint256 tokenId) public {\n\n        //solhint-disable-next-line max-line-length\n\n        require(_isApprovedOrOwner(msg.sender, tokenId), \"ERC721: transfer caller is not owner nor approved\");\n\n\n\n        _transferFrom(from, to, tokenId);\n\n    }\n\n\n\n    /**\n\n     * @dev Safely transfers the ownership of a given token ID to another address\n\n     * If the target address is a contract, it must implement `onERC721Received`,\n\n     * which is called upon a safe transfer, and return the magic value\n\n     * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\n\n     * the transfer is reverted.\n\n     * Requires the msg.sender to be the owner, approved, or operator\n\n     * @param from current owner of the token\n\n     * @param to address to receive the ownership of the given token ID\n\n     * @param tokenId uint256 ID of the token to be transferred\n\n     */\n\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n\n        safeTransferFrom(from, to, tokenId, \"\");\n\n    }\n\n\n\n    /**\n\n     * @dev Safely transfers the ownership of a given token ID to another address\n\n     * If the target address is a contract, it must implement `onERC721Received`,\n\n     * which is called upon a safe transfer, and return the magic value\n\n     * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\n\n     * the transfer is reverted.\n\n     * Requires the msg.sender to be the owner, approved, or operator\n\n     * @param from current owner of the token\n\n     * @param to address to receive the ownership of the given token ID\n\n     * @param tokenId uint256 ID of the token to be transferred\n\n     * @param _data bytes data to send along with a safe transfer check\n\n     */\n\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public {\n\n        transferFrom(from, to, tokenId);\n\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n\n    }\n\n\n\n    /**\n\n     * @dev Returns whether the specified token exists.\n\n     * @param tokenId uint256 ID of the token to query the existence of\n\n     * @return bool whether the token exists\n\n     */\n\n    function _exists(uint256 tokenId) internal view returns (bool) {\n\n        address owner = _tokenOwner[tokenId];\n\n        return owner != address(0);\n\n    }\n\n\n\n    /**\n\n     * @dev Returns whether the given spender can transfer a given token ID.\n\n     * @param spender address of the spender to query\n\n     * @param tokenId uint256 ID of the token to be transferred\n\n     * @return bool whether the msg.sender is approved for the given token ID,\n\n     * is an operator of the owner, or is the owner of the token\n\n     */\n\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {\n\n        require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\n\n        address owner = ownerOf(tokenId);\n\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\n\n    }\n\n\n\n    /**\n\n     * @dev Internal function to mint a new token.\n\n     * Reverts if the given token ID already exists.\n\n     * @param to The address that will own the minted token\n\n     * @param tokenId uint256 ID of the token to be minted\n\n     */\n\n    function _mint(address to, uint256 tokenId) internal {\n\n        require(to != address(0), \"ERC721: mint to the zero address\");\n\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n\n\n        _tokenOwner[tokenId] = to;\n\n        _ownedTokensCount[to].increment();\n\n\n\n        emit Transfer(address(0), to, tokenId);\n\n    }\n\n\n\n    /**\n\n     * @dev Internal function to burn a specific token.\n\n     * Reverts if the token does not exist.\n\n     * Deprecated, use _burn(uint256) instead.\n\n     * @param owner owner of the token to burn\n\n     * @param tokenId uint256 ID of the token being burned\n\n     */\n\n    function _burn(address owner, uint256 tokenId) internal {\n\n        require(ownerOf(tokenId) == owner, \"ERC721: burn of token that is not own\");\n\n\n\n        _clearApproval(tokenId);\n\n\n\n        _ownedTokensCount[owner].decrement();\n\n        _tokenOwner[tokenId] = address(0);\n\n\n\n        emit Transfer(owner, address(0), tokenId);\n\n    }\n\n\n\n    /**\n\n     * @dev Internal function to burn a specific token.\n\n     * Reverts if the token does not exist.\n\n     * @param tokenId uint256 ID of the token being burned\n\n     */\n\n    function _burn(uint256 tokenId) internal {\n\n        _burn(ownerOf(tokenId), tokenId);\n\n    }\n\n\n\n    /**\n\n     * @dev Internal function to transfer ownership of a given token ID to another address.\n\n     * As opposed to transferFrom, this imposes no restrictions on msg.sender.\n\n     * @param from current owner of the token\n\n     * @param to address to receive the ownership of the given token ID\n\n     * @param tokenId uint256 ID of the token to be transferred\n\n     */\n\n    function _transferFrom(address from, address to, uint256 tokenId) internal {\n\n        require(ownerOf(tokenId) == from, \"ERC721: transfer of token that is not own\");\n\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n\n\n        _clearApproval(tokenId);\n\n\n\n        _ownedTokensCount[from].decrement();\n\n        _ownedTokensCount[to].increment();\n\n\n\n        _tokenOwner[tokenId] = to;\n\n\n\n        emit Transfer(from, to, tokenId);\n\n    }\n\n\n\n    /**\n\n     * @dev Internal function to invoke `onERC721Received` on a target address.\n\n     * The call is not executed if the target address is not a contract.\n\n     *\n\n     * This function is deprecated.\n\n     * @param from address representing the previous owner of the given token ID\n\n     * @param to target address that will receive the tokens\n\n     * @param tokenId uint256 ID of the token to be transferred\n\n     * @param _data bytes optional data to send along with the call\n\n     * @return bool whether the call correctly returned the expected magic value\n\n     */\n\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)\n\n        internal returns (bool)\n\n    {\n\n        if (!to.isContract()) {\n\n            return true;\n\n        }\n\n\n\n        bytes4 retval = IERC721Receiver(to).onERC721Received(msg.sender, from, tokenId, _data);\n\n        return (retval == _ERC721_RECEIVED);\n\n    }\n\n\n\n    /**\n\n     * @dev Private function to clear current approval of a given token ID.\n\n     * @param tokenId uint256 ID of the token to be transferred\n\n     */\n\n    function _clearApproval(uint256 tokenId) private {\n\n        if (_tokenApprovals[tokenId] != address(0)) {\n\n            _tokenApprovals[tokenId] = address(0);\n\n        }\n\n    }\n",
          "message": "ERC721 (ERC721Pausable.sol#352-637) has incorrect ERC20 function interface(s):\n\t-transferFrom (ERC721Pausable.sol#480-485)\n\t-approve (ERC721Pausable.sol#425-435)\n"
        },
        {
          "name": "erc20-interface",
          "vulnerability_from_line": 806,
          "vulnerability_to_line": 818,
          "vulnerability_code": "contract ERC721Pausable is ERC721, Pausable {\n\n    function approve(address to, uint256 tokenId) public whenNotPaused {\n\n        super.approve(to, tokenId);\n\n    }\n\n\n\n    function setApprovalForAll(address to, bool approved) public whenNotPaused {\n\n        super.setApprovalForAll(to, approved);\n\n    }\n\n\n\n    function transferFrom(address from, address to, uint256 tokenId) public whenNotPaused {\n\n        super.transferFrom(from, to, tokenId);\n\n    }\n",
          "message": "ERC721Pausable (ERC721Pausable.sol#806-818) has incorrect ERC20 function interface(s):\n\t-transferFrom (ERC721Pausable.sol#815-817)\n\t-approve (ERC721Pausable.sol#807-809)\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 236,
          "vulnerability_to_line": 245,
          "vulnerability_code": "    function isContract(address account) internal view returns (bool) {\n\n        // This method relies in extcodesize, which returns 0 for contracts in\n\n        // construction, since the code is only stored at the end of the\n\n        // constructor execution.\n\n\n\n        uint256 size;\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly { size := extcodesize(account) }\n\n        return size > 0;\n",
          "message": "Address.isContract uses assembly (ERC721Pausable.sol#236-245)\n\t- ERC721Pausable.sol#243\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 399,
          "vulnerability_to_line": 403,
          "vulnerability_code": "    function balanceOf(address owner) public view returns (uint256) {\n\n        require(owner != address(0), \"ERC721: balance query for the zero address\");\n\n\n\n        return _ownedTokensCount[owner].current();\n",
          "message": "ERC721.balanceOf (ERC721Pausable.sol#399-403) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 41,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function balanceOf(address owner) public view returns (uint256 balance);\n",
          "message": "IERC721.balanceOf (ERC721Pausable.sol#41) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 498,
          "vulnerability_to_line": 500,
          "vulnerability_code": "    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n\n        safeTransferFrom(from, to, tokenId, \"\");\n",
          "message": "ERC721.safeTransferFrom (ERC721Pausable.sol#498-500) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 60,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function safeTransferFrom(address from, address to, uint256 tokenId) public;\n",
          "message": "IERC721.safeTransferFrom (ERC721Pausable.sol#60) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 104,
          "vulnerability_to_line": 105,
          "vulnerability_code": "    function onERC721Received(address operator, address from, uint256 tokenId, bytes memory data)\n",
          "message": "IERC721Receiver.onERC721Received (ERC721Pausable.sol#104-105) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 704,
          "vulnerability_to_line": 706,
          "vulnerability_code": "    function addPauser(address account) public onlyPauser {\n\n        _addPauser(account);\n",
          "message": "PauserRole.addPauser (ERC721Pausable.sol#704-706) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 708,
          "vulnerability_to_line": 710,
          "vulnerability_code": "    function renouncePauser() public {\n\n        _removePauser(msg.sender);\n",
          "message": "PauserRole.renouncePauser (ERC721Pausable.sol#708-710) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 760,
          "vulnerability_to_line": 762,
          "vulnerability_code": "    function paused() public view returns (bool) {\n\n        return _paused;\n",
          "message": "Pausable.paused (ERC721Pausable.sol#760-762) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 783,
          "vulnerability_to_line": 786,
          "vulnerability_code": "    function pause() public onlyPauser whenNotPaused {\n\n        _paused = true;\n\n        emit Paused(msg.sender);\n",
          "message": "Pausable.pause (ERC721Pausable.sol#783-786) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 791,
          "vulnerability_to_line": 794,
          "vulnerability_code": "    function unpause() public onlyPauser whenPaused {\n\n        _paused = false;\n\n        emit Unpaused(msg.sender);\n",
          "message": "Pausable.unpause (ERC721Pausable.sol#791-794) should be declared external\n"
        },
        {
          "name": "solc-version",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.0;\n",
          "message": "Detected issues with version pragma in ERC721Pausable.sol:\n\t- pragma solidity^0.5.0 (ERC721Pausable.sol#3): it allows old versions\n\t- pragma solidity^0.5.0 (ERC721Pausable.sol#28): it allows old versions\n\t- pragma solidity^0.5.0 (ERC721Pausable.sol#82): it allows old versions\n\t- pragma solidity^0.5.0 (ERC721Pausable.sol#110): it allows old versions\n\t- pragma solidity^0.5.0 (ERC721Pausable.sol#220): it allows old versions\n\t- pragma solidity^0.5.0 (ERC721Pausable.sol#250): it allows old versions\n\t- pragma solidity^0.5.0 (ERC721Pausable.sol#288): it allows old versions\n\t- pragma solidity^0.5.0 (ERC721Pausable.sol#341): it allows old versions\n\t- pragma solidity^0.5.0 (ERC721Pausable.sol#642): it allows old versions\n\t- pragma solidity^0.5.0 (ERC721Pausable.sol#681): it allows old versions\n\t- pragma solidity^0.5.0 (ERC721Pausable.sol#725): it allows old versions\n\t- pragma solidity^0.5.0 (ERC721Pausable.sol#799): it allows old versions\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 333,
          "vulnerability_to_line": 336,
          "vulnerability_code": "    function _registerInterface(bytes4 interfaceId) internal {\n\n        require(interfaceId != 0xffffffff, \"ERC165: invalid interface id\");\n\n        _supportedInterfaces[interfaceId] = true;\n",
          "message": "Function 'ERC165._registerInterface' (ERC721Pausable.sol#333-336) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 514,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public {\n",
          "message": "Parameter '_data' of ERC721.safeTransferFrom (ERC721Pausable.sol#514) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 524,
          "vulnerability_to_line": 527,
          "vulnerability_code": "    function _exists(uint256 tokenId) internal view returns (bool) {\n\n        address owner = _tokenOwner[tokenId];\n\n        return owner != address(0);\n",
          "message": "Function 'ERC721._exists' (ERC721Pausable.sol#524-527) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 536,
          "vulnerability_to_line": 540,
          "vulnerability_code": "    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {\n\n        require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\n\n        address owner = ownerOf(tokenId);\n\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\n",
          "message": "Function 'ERC721._isApprovedOrOwner' (ERC721Pausable.sol#536-540) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 548,
          "vulnerability_to_line": 556,
          "vulnerability_code": "    function _mint(address to, uint256 tokenId) internal {\n\n        require(to != address(0), \"ERC721: mint to the zero address\");\n\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n\n\n        _tokenOwner[tokenId] = to;\n\n        _ownedTokensCount[to].increment();\n\n\n\n        emit Transfer(address(0), to, tokenId);\n",
          "message": "Function 'ERC721._mint' (ERC721Pausable.sol#548-556) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 565,
          "vulnerability_to_line": 574,
          "vulnerability_code": "    function _burn(address owner, uint256 tokenId) internal {\n\n        require(ownerOf(tokenId) == owner, \"ERC721: burn of token that is not own\");\n\n\n\n        _clearApproval(tokenId);\n\n\n\n        _ownedTokensCount[owner].decrement();\n\n        _tokenOwner[tokenId] = address(0);\n\n\n\n        emit Transfer(owner, address(0), tokenId);\n",
          "message": "Function 'ERC721._burn' (ERC721Pausable.sol#565-574) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 581,
          "vulnerability_to_line": 583,
          "vulnerability_code": "    function _burn(uint256 tokenId) internal {\n\n        _burn(ownerOf(tokenId), tokenId);\n",
          "message": "Function 'ERC721._burn' (ERC721Pausable.sol#581-583) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 592,
          "vulnerability_to_line": 604,
          "vulnerability_code": "    function _transferFrom(address from, address to, uint256 tokenId) internal {\n\n        require(ownerOf(tokenId) == from, \"ERC721: transfer of token that is not own\");\n\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n\n\n        _clearApproval(tokenId);\n\n\n\n        _ownedTokensCount[from].decrement();\n\n        _ownedTokensCount[to].increment();\n\n\n\n        _tokenOwner[tokenId] = to;\n\n\n\n        emit Transfer(from, to, tokenId);\n",
          "message": "Function 'ERC721._transferFrom' (ERC721Pausable.sol#592-604) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 617,
          "vulnerability_to_line": 626,
          "vulnerability_code": "    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)\n\n        internal returns (bool)\n\n    {\n\n        if (!to.isContract()) {\n\n            return true;\n\n        }\n\n\n\n        bytes4 retval = IERC721Receiver(to).onERC721Received(msg.sender, from, tokenId, _data);\n\n        return (retval == _ERC721_RECEIVED);\n",
          "message": "Function 'ERC721._checkOnERC721Received' (ERC721Pausable.sol#617-626) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 617,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)\n",
          "message": "Parameter '_data' of ERC721._checkOnERC721Received (ERC721Pausable.sol#617) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 632,
          "vulnerability_to_line": 636,
          "vulnerability_code": "    function _clearApproval(uint256 tokenId) private {\n\n        if (_tokenApprovals[tokenId] != address(0)) {\n\n            _tokenApprovals[tokenId] = address(0);\n\n        }\n",
          "message": "Function 'ERC721._clearApproval' (ERC721Pausable.sol#632-636) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 712,
          "vulnerability_to_line": 715,
          "vulnerability_code": "    function _addPauser(address account) internal {\n\n        _pausers.add(account);\n\n        emit PauserAdded(account);\n",
          "message": "Function 'PauserRole._addPauser' (ERC721Pausable.sol#712-715) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 717,
          "vulnerability_to_line": 720,
          "vulnerability_code": "    function _removePauser(address account) internal {\n\n        _pausers.remove(account);\n\n        emit PauserRemoved(account);\n",
          "message": "Function 'PauserRole._removePauser' (ERC721Pausable.sol#717-720) is not in mixedCase\n"
        }
      ]
    },
    "smartcheck": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 300,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 334,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(interfaceId != 0xffffffff, \"ERC165: invalid interface id\");\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 359,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 387,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 571,
          "vulnerability_to_line": null,
          "vulnerability_code": "        _tokenOwner[tokenId] = address(0);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 634,
          "vulnerability_to_line": null,
          "vulnerability_code": "            _tokenApprovals[tokenId] = address(0);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 28,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 82,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 110,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 220,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 250,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 288,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 341,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 642,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 681,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 725,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 799,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 300,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 305,
          "vulnerability_to_line": null,
          "vulnerability_code": "    mapping(bytes4 => bool) private _supportedInterfaces;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 359,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 362,
          "vulnerability_to_line": null,
          "vulnerability_code": "    mapping (uint256 => address) private _tokenOwner;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 365,
          "vulnerability_to_line": null,
          "vulnerability_code": "    mapping (uint256 => address) private _tokenApprovals;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 368,
          "vulnerability_to_line": null,
          "vulnerability_code": "    mapping (address => Counters.Counter) private _ownedTokensCount;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 371,
          "vulnerability_to_line": null,
          "vulnerability_code": "    mapping (address => mapping (address => bool)) private _operatorApprovals;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 387,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 689,
          "vulnerability_to_line": null,
          "vulnerability_code": "    Roles.Role private _pausers;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 747,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bool private _paused;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SAFEMATH",
          "vulnerability_from_line": 264,
          "vulnerability_to_line": null,
          "vulnerability_code": "    using SafeMath for uint256;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SAFEMATH",
          "vulnerability_from_line": 353,
          "vulnerability_to_line": null,
          "vulnerability_code": "    using SafeMath for uint256;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
          "vulnerability_from_line": 236,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function isContract(address account) internal view returns (bool) {\n",
          "message": null
        }
      ]
    },
    "oyente": {
      "successfull_analysis": false,
      "errors": [
        "exception (IndexError: pop from empty list)"
      ],
      "vulnerability_findings": []
    },
    "mythril": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": []
    },
    "osiris": {
      "successfull_analysis": false,
      "errors": [
        "Solidity compilation failed"
      ],
      "vulnerability_findings": []
    }
  }
}