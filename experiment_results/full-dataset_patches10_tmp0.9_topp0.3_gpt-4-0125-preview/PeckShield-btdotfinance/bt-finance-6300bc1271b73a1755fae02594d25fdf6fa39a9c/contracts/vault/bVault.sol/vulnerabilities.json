{
  "smartbugs_completed": true,
  "analyzer_results": {
    "semgrep": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "use-abi-encodecall-instead-of-encodewithselector",
          "vulnerability_from_line": 232,
          "vulnerability_to_line": null,
          "vulnerability_code": "        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n",
          "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
        },
        {
          "name": "use-abi-encodecall-instead-of-encodewithselector",
          "vulnerability_from_line": 236,
          "vulnerability_to_line": null,
          "vulnerability_code": "        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n",
          "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
        },
        {
          "name": "use-abi-encodecall-instead-of-encodewithselector",
          "vulnerability_from_line": 243,
          "vulnerability_to_line": null,
          "vulnerability_code": "        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n",
          "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
        },
        {
          "name": "use-abi-encodecall-instead-of-encodewithselector",
          "vulnerability_from_line": 248,
          "vulnerability_to_line": null,
          "vulnerability_code": "        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n",
          "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
        },
        {
          "name": "use-abi-encodecall-instead-of-encodewithselector",
          "vulnerability_from_line": 253,
          "vulnerability_to_line": null,
          "vulnerability_code": "        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n",
          "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 23,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor () internal { }\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 40,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor () internal {\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 41,
          "vulnerability_to_line": null,
          "vulnerability_code": "        _owner = _msgSender();\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 42,
          "vulnerability_to_line": null,
          "vulnerability_code": "        emit OwnershipTransferred(address(0), _owner);\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 43,
          "vulnerability_to_line": null,
          "vulnerability_code": "    }\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 146,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor (string memory name, string memory symbol, uint8 decimals) public {\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 147,
          "vulnerability_to_line": null,
          "vulnerability_code": "        _name = name;\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 148,
          "vulnerability_to_line": null,
          "vulnerability_code": "        _symbol = symbol;\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 149,
          "vulnerability_to_line": null,
          "vulnerability_code": "        _decimals = decimals;\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 150,
          "vulnerability_to_line": null,
          "vulnerability_code": "    }\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 306,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor (address _token,uint _earnLowerlimit) public ERC20Detailed(\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 307,
          "vulnerability_to_line": null,
          "vulnerability_code": "        string(abi.encodePacked(\"bt:vault: \", ERC20Detailed(_token).name())),\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 308,
          "vulnerability_to_line": null,
          "vulnerability_code": "        string(abi.encodePacked(\"b\", ERC20Detailed(_token).symbol())),\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 309,
          "vulnerability_to_line": null,
          "vulnerability_code": "        ERC20Detailed(_token).decimals()\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 310,
          "vulnerability_to_line": null,
          "vulnerability_code": "    ) {\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 311,
          "vulnerability_to_line": null,
          "vulnerability_code": "        token = IERC20(_token);\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 312,
          "vulnerability_to_line": null,
          "vulnerability_code": "        governance = tx.origin;\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 313,
          "vulnerability_to_line": null,
          "vulnerability_code": "        controller = 0x03D2079c54967f463Fd6e89E76012F74EBC62615;\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 314,
          "vulnerability_to_line": null,
          "vulnerability_code": "        earnLowerlimit = _earnLowerlimit;\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 315,
          "vulnerability_to_line": null,
          "vulnerability_code": "        feeAddress = tx.origin;\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 48,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(isOwner(), \"Ownable: caller is not the owner\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 62,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 107,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(sender != address(0), \"ERC20: transfer from the zero address\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 108,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 115,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(account != address(0), \"ERC20: mint to the zero address\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 122,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(account != address(0), \"ERC20: burn from the zero address\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 129,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(owner != address(0), \"ERC20: approve from the zero address\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 130,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(spender != address(0), \"ERC20: approve to the zero address\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 165,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(c >= a, \"SafeMath: addition overflow\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 184,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(c / a == b, \"SafeMath: multiplication overflow\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 219,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(address(this).balance >= amount, \"Address: insufficient balance\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 223,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(success, \"Address: unable to send value, recipient may have reverted\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 240,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require((value == 0) || (token.allowance(address(this), spender) == 0),\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 241,
          "vulnerability_to_line": null,
          "vulnerability_code": "            \"SafeERC20: approve from non-zero to non-zero allowance\"\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 242,
          "vulnerability_to_line": null,
          "vulnerability_code": "        );\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 256,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 260,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(success, \"SafeERC20: low-level call failed\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 264,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 302,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(!RestrictContractCall || !s.isContract(), \"Contract cannot call\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 325,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == governance, \"!governance\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 330,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == governance, \"!governance\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 335,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == timelock, \"!timelock\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 339,
          "vulnerability_to_line": null,
          "vulnerability_code": "      require(msg.sender == governance, \"!governance\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 360,
          "vulnerability_to_line": null,
          "vulnerability_code": "\t\trequire(_amount > 0, \"Cannot deposit 0\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 387,
          "vulnerability_to_line": null,
          "vulnerability_code": "\t\trequire(_shares > 0, \"Cannot withdraw 0\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 433,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == timelock, \"!timelock\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 434,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(fees[0]<feeMax&&fees[1]<feeMax&&fees[2]<feeMax,\"The fee is too high\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 442,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == timelock, \"!timelock\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 448,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == timelock, \"!timelock\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 453,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == governance, \"!governance\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 434,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(fees[0]<feeMax&&fees[1]<feeMax&&fees[2]<feeMax,\"The fee is too high\");\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 62,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 107,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(sender != address(0), \"ERC20: transfer from the zero address\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 108,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 122,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(account != address(0), \"ERC20: burn from the zero address\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 129,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(owner != address(0), \"ERC20: approve from the zero address\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 130,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(spender != address(0), \"ERC20: approve to the zero address\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 184,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(c / a == b, \"SafeMath: multiplication overflow\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 223,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(success, \"Address: unable to send value, recipient may have reverted\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 240,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require((value == 0) || (token.allowance(address(this), spender) == 0),\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 241,
          "vulnerability_to_line": null,
          "vulnerability_code": "            \"SafeERC20: approve from non-zero to non-zero allowance\"\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 242,
          "vulnerability_to_line": null,
          "vulnerability_code": "        );\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 264,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        }
      ]
    },
    "slither": {
      "successfull_analysis": true,
      "errors": [
        "EXIT_CODE_61"
      ],
      "vulnerability_findings": [
        {
          "name": "constant-function",
          "vulnerability_from_line": 208,
          "vulnerability_to_line": 214,
          "vulnerability_code": "    function isContract(address account) internal view returns (bool) {\n\n        bytes32 codehash;\n\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly { codehash := extcodehash(account) }\n\n        return (codehash != 0x0 && codehash != accountHash);\n",
          "message": "Address.isContract (bVault.sol#208-214) is declared view but contains assembly code\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 386,
          "vulnerability_to_line": 410,
          "vulnerability_code": "    function withdraw(uint _shares) public onlyRestrictContractCall {\n\n\t\trequire(_shares > 0, \"Cannot withdraw 0\");\n\n\n\n        uint r = (balance().mul(_shares)).div(totalSupply());\n\n        _burn(msg.sender, _shares);\n\n        \n\n        // Check balance\n\n        uint b = token.balanceOf(address(this));\n\n        if (b < r) {\n\n            uint _withdraw = r.sub(b);\n\n            Controller(controller).withdraw(address(token), _withdraw);\n\n            uint _after = token.balanceOf(address(this));\n\n            uint _diff = _after.sub(b);\n\n            if (_diff < _withdraw) {\n\n                r = b.add(_diff);\n\n            }\n\n        }\n\n        uint feeRatio = getFeeRatio();\n\n        if(feeRatio>0){\n\n            uint fee = r.mul(feeRatio).div(feeMax);\n\n            r = r.sub(fee);\n\n            token.safeTransfer(feeAddress,fee);\n\n        }\n\n        token.safeTransfer(msg.sender, r);\n",
          "message": "Reentrancy in bVault.withdraw (bVault.sol#386-410):\n\tExternal calls:\n\t- r = (balance().mul(_shares)).div(totalSupply()) (bVault.sol#389)\n\tState variables written after the call(s):\n\t- _totalSupply (bVault.sol#390)\n"
        },
        {
          "name": "shadowing-local",
          "vulnerability_from_line": 146,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor (string memory name, string memory symbol, uint8 decimals) public {\n",
          "message": "ERC20Detailed.constructor.name (local variable @ bVault.sol#146) shadows:\n\t- ERC20Detailed.name (function @ bVault.sol#151-153)\n"
        },
        {
          "name": "shadowing-local",
          "vulnerability_from_line": 146,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor (string memory name, string memory symbol, uint8 decimals) public {\n",
          "message": "ERC20Detailed.constructor.symbol (local variable @ bVault.sol#146) shadows:\n\t- ERC20Detailed.symbol (function @ bVault.sol#154-156)\n"
        },
        {
          "name": "shadowing-local",
          "vulnerability_from_line": 146,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor (string memory name, string memory symbol, uint8 decimals) public {\n",
          "message": "ERC20Detailed.constructor.decimals (local variable @ bVault.sol#146) shadows:\n\t- ERC20Detailed.decimals (function @ bVault.sol#157-159)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 359,
          "vulnerability_to_line": 377,
          "vulnerability_code": "    function deposit(uint _amount) public onlyRestrictContractCall {\n\n\t\trequire(_amount > 0, \"Cannot deposit 0\");\n\n        uint _pool = balance();\n\n        uint _before = token.balanceOf(address(this));\n\n        token.safeTransferFrom(msg.sender, address(this), _amount);\n\n        uint _after = token.balanceOf(address(this));\n\n        _amount = _after.sub(_before); // Additional check for deflationary tokens\n\n        uint shares = 0;\n\n        if (totalSupply() == 0) {\n\n            shares = _amount;\n\n        } else {\n\n            shares = (_amount.mul(totalSupply())).div(_pool);\n\n        }\n\n        _mint(msg.sender, shares);\n\n        userDepoistTime[msg.sender] = now;\n\n        if (token.balanceOf(address(this))>earnLowerlimit){\n\n          earn();\n\n        }\n",
          "message": "Reentrancy in bVault.deposit (bVault.sol#359-377):\n\tExternal calls:\n\t- _pool = balance() (bVault.sol#361)\n\t- _before = token.balanceOf(address(this)) (bVault.sol#362)\n\t- _after = token.balanceOf(address(this)) (bVault.sol#364)\n\tState variables written after the call(s):\n\t- _balances (bVault.sol#372)\n\t- _totalSupply (bVault.sol#372)\n\t- userDepoistTime (bVault.sol#373)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 386,
          "vulnerability_to_line": 410,
          "vulnerability_code": "    function withdraw(uint _shares) public onlyRestrictContractCall {\n\n\t\trequire(_shares > 0, \"Cannot withdraw 0\");\n\n\n\n        uint r = (balance().mul(_shares)).div(totalSupply());\n\n        _burn(msg.sender, _shares);\n\n        \n\n        // Check balance\n\n        uint b = token.balanceOf(address(this));\n\n        if (b < r) {\n\n            uint _withdraw = r.sub(b);\n\n            Controller(controller).withdraw(address(token), _withdraw);\n\n            uint _after = token.balanceOf(address(this));\n\n            uint _diff = _after.sub(b);\n\n            if (_diff < _withdraw) {\n\n                r = b.add(_diff);\n\n            }\n\n        }\n\n        uint feeRatio = getFeeRatio();\n\n        if(feeRatio>0){\n\n            uint fee = r.mul(feeRatio).div(feeMax);\n\n            r = r.sub(fee);\n\n            token.safeTransfer(feeAddress,fee);\n\n        }\n\n        token.safeTransfer(msg.sender, r);\n",
          "message": "Reentrancy in bVault.withdraw (bVault.sol#386-410):\n\tExternal calls:\n\t- r = (balance().mul(_shares)).div(totalSupply()) (bVault.sol#389)\n\tState variables written after the call(s):\n\t- _balances (bVault.sol#390)\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 208,
          "vulnerability_to_line": 214,
          "vulnerability_code": "    function isContract(address account) internal view returns (bool) {\n\n        bytes32 codehash;\n\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly { codehash := extcodehash(account) }\n\n        return (codehash != 0x0 && codehash != accountHash);\n",
          "message": "Address.isContract uses assembly (bVault.sol#208-214)\n\t- bVault.sol#212\n"
        },
        {
          "name": "constable-states",
          "vulnerability_from_line": 292,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint public feeMax = 1000;\n",
          "message": "bVault.feeMax should be constant (bVault.sol#292)\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 44,
          "vulnerability_to_line": 46,
          "vulnerability_code": "    function owner() public view returns (address) {\n\n        return _owner;\n",
          "message": "Ownable.owner (bVault.sol#44-46) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 54,
          "vulnerability_to_line": 57,
          "vulnerability_code": "    function renounceOwnership() public onlyOwner {\n\n        emit OwnershipTransferred(_owner, address(0));\n\n        _owner = address(0);\n",
          "message": "Ownable.renounceOwnership (bVault.sol#54-57) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 58,
          "vulnerability_to_line": 60,
          "vulnerability_code": "    function transferOwnership(address newOwner) public onlyOwner {\n\n        _transferOwnership(newOwner);\n",
          "message": "Ownable.transferOwnership (bVault.sol#58-60) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 82,
          "vulnerability_to_line": 85,
          "vulnerability_code": "    function transfer(address recipient, uint256 amount) public returns (bool) {\n\n        _transfer(_msgSender(), recipient, amount);\n\n        return true;\n",
          "message": "ERC20.transfer (bVault.sol#82-85) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 14,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function transfer(address recipient, uint256 amount) external returns (bool);\n",
          "message": "IERC20.transfer (bVault.sol#14) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 86,
          "vulnerability_to_line": 88,
          "vulnerability_code": "    function allowance(address owner, address spender) public view returns (uint256) {\n\n        return _allowances[owner][spender];\n",
          "message": "ERC20.allowance (bVault.sol#86-88) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 15,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function allowance(address owner, address spender) external view returns (uint256);\n",
          "message": "IERC20.allowance (bVault.sol#15) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 16,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function approve(address spender, uint256 amount) external returns (bool);\n",
          "message": "IERC20.approve (bVault.sol#16) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 89,
          "vulnerability_to_line": 92,
          "vulnerability_code": "    function approve(address spender, uint256 amount) public returns (bool) {\n\n        _approve(_msgSender(), spender, amount);\n\n        return true;\n",
          "message": "ERC20.approve (bVault.sol#89-92) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 93,
          "vulnerability_to_line": 97,
          "vulnerability_code": "    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\n\n        _transfer(sender, recipient, amount);\n\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n\n        return true;\n",
          "message": "ERC20.transferFrom (bVault.sol#93-97) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 17,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n",
          "message": "IERC20.transferFrom (bVault.sol#17) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 98,
          "vulnerability_to_line": 101,
          "vulnerability_code": "    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n\n        return true;\n",
          "message": "ERC20.increaseAllowance (bVault.sol#98-101) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 102,
          "vulnerability_to_line": 105,
          "vulnerability_code": "    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n\n        return true;\n",
          "message": "ERC20.decreaseAllowance (bVault.sol#102-105) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 151,
          "vulnerability_to_line": 153,
          "vulnerability_code": "    function name() public view returns (string memory) {\n\n        return _name;\n",
          "message": "ERC20Detailed.name (bVault.sol#151-153) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 154,
          "vulnerability_to_line": 156,
          "vulnerability_code": "    function symbol() public view returns (string memory) {\n\n        return _symbol;\n",
          "message": "ERC20Detailed.symbol (bVault.sol#154-156) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 157,
          "vulnerability_to_line": 159,
          "vulnerability_code": "    function decimals() public view returns (uint8) {\n\n        return _decimals;\n",
          "message": "ERC20Detailed.decimals (bVault.sol#157-159) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 329,
          "vulnerability_to_line": 332,
          "vulnerability_code": "    function setGovernance(address _governance) public {\n\n        require(msg.sender == governance, \"!governance\");\n\n        governance = _governance;\n",
          "message": "bVault.setGovernance (bVault.sol#329-332) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 334,
          "vulnerability_to_line": 337,
          "vulnerability_code": "    function setController(address _controller) public {\n\n        require(msg.sender == timelock, \"!timelock\");\n\n        controller = _controller;\n",
          "message": "bVault.setController (bVault.sol#334-337) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 338,
          "vulnerability_to_line": 341,
          "vulnerability_code": "    function setEarnLowerlimit(uint256 _earnLowerlimit) public{\n\n      require(msg.sender == governance, \"!governance\");\n\n      earnLowerlimit = _earnLowerlimit;\n",
          "message": "bVault.setEarnLowerlimit (bVault.sol#338-341) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 424,
          "vulnerability_to_line": 429,
          "vulnerability_code": "    function getPricePerFullShare() public view returns (uint) {\n\n        if (totalSupply()==0) {\n\n            return 0;\n\n        }\n\n        return balance().mul(1e18).div(totalSupply());\n",
          "message": "bVault.getPricePerFullShare (bVault.sol#424-429) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 431,
          "vulnerability_to_line": 438,
          "vulnerability_code": "    function setFeeRatio(uint[3] memory fees) public\n\n    {\n\n        require(msg.sender == timelock, \"!timelock\");\n\n        require(fees[0]<feeMax&&fees[1]<feeMax&&fees[2]<feeMax,\"The fee is too high\");\n\n        fee1 = fees[0];\n\n        fee2 = fees[1];\n\n        fee3 = fees[2];\n",
          "message": "bVault.setFeeRatio (bVault.sol#431-438) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 440,
          "vulnerability_to_line": 444,
          "vulnerability_code": "    function setFeeAddress(address fadd) public \n\n    {\n\n        require(msg.sender == timelock, \"!timelock\");\n\n        feeAddress = fadd;\n",
          "message": "bVault.setFeeAddress (bVault.sol#440-444) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 446,
          "vulnerability_to_line": 450,
          "vulnerability_code": "\tfunction setTimeLock(address _timelock) public \n\n    {\n\n        require(msg.sender == timelock, \"!timelock\");\n\n        timelock = _timelock;\n",
          "message": "bVault.setTimeLock (bVault.sol#446-450) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 452,
          "vulnerability_to_line": 455,
          "vulnerability_code": "    function setRestrictContractCall(bool enabled) public {\n\n        require(msg.sender == governance, \"!governance\");\n\n        RestrictContractCall = enabled;\n",
          "message": "bVault.setRestrictContractCall (bVault.sol#452-455) should be declared external\n"
        },
        {
          "name": "solc-version",
          "vulnerability_from_line": 9,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": "Detected issues with version pragma in bVault.sol:\n\t- pragma solidity^0.5.16 (bVault.sol#9): it allows old versions\n"
        },
        {
          "name": "low-level-calls",
          "vulnerability_from_line": 218,
          "vulnerability_to_line": 224,
          "vulnerability_code": "    function sendValue(address payable recipient, uint256 amount) internal {\n\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n\n\n        // solhint-disable-next-line avoid-call-value\n\n        (bool success, ) = recipient.call.value(amount)(\"\");\n\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n",
          "message": "Low level call in Address.sendValue (bVault.sol#218-224):\n\t-(success) = recipient.call.value(amount)() bVault.sol#222\n"
        },
        {
          "name": "low-level-calls",
          "vulnerability_from_line": 255,
          "vulnerability_to_line": 266,
          "vulnerability_code": "    function callOptionalReturn(IERC20 token, bytes memory data) private {\n\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\n\n\n\n        // solhint-disable-next-line avoid-low-level-calls\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n\n        require(success, \"SafeERC20: low-level call failed\");\n\n\n\n        if (returndata.length > 0) { // Return data is optional\n\n            // solhint-disable-next-line max-line-length\n\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n\n        }\n",
          "message": "Low level call in SafeERC20.callOptionalReturn (bVault.sol#255-266):\n\t-(success,returndata) = address(token).call(data) bVault.sol#259\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 26,
          "vulnerability_to_line": 28,
          "vulnerability_code": "    function _msgSender() internal view returns (address payable) {\n\n        return msg.sender;\n",
          "message": "Function 'Context._msgSender' (bVault.sol#26-28) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 30,
          "vulnerability_to_line": 33,
          "vulnerability_code": "    function _msgData() internal view returns (bytes memory) {\n\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n\n        return msg.data;\n",
          "message": "Function 'Context._msgData' (bVault.sol#30-33) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 61,
          "vulnerability_to_line": 65,
          "vulnerability_code": "    function _transferOwnership(address newOwner) internal {\n\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n\n        emit OwnershipTransferred(_owner, newOwner);\n\n        _owner = newOwner;\n",
          "message": "Function 'Ownable._transferOwnership' (bVault.sol#61-65) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 106,
          "vulnerability_to_line": 113,
          "vulnerability_code": "    function _transfer(address sender, address recipient, uint256 amount) internal {\n\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n\n        _balances[recipient] = _balances[recipient].add(amount);\n\n        emit Transfer(sender, recipient, amount);\n",
          "message": "Function 'ERC20._transfer' (bVault.sol#106-113) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 114,
          "vulnerability_to_line": 120,
          "vulnerability_code": "    function _mint(address account, uint256 amount) internal {\n\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n\n\n        _totalSupply = _totalSupply.add(amount);\n\n        _balances[account] = _balances[account].add(amount);\n\n        emit Transfer(address(0), account, amount);\n",
          "message": "Function 'ERC20._mint' (bVault.sol#114-120) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 121,
          "vulnerability_to_line": 127,
          "vulnerability_code": "    function _burn(address account, uint256 amount) internal {\n\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n\n        _totalSupply = _totalSupply.sub(amount);\n\n        emit Transfer(account, address(0), amount);\n",
          "message": "Function 'ERC20._burn' (bVault.sol#121-127) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 128,
          "vulnerability_to_line": 134,
          "vulnerability_code": "    function _approve(address owner, address spender, uint256 amount) internal {\n\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n\n\n        _allowances[owner][spender] = amount;\n\n        emit Approval(owner, spender, amount);\n",
          "message": "Function 'ERC20._approve' (bVault.sol#128-134) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 135,
          "vulnerability_to_line": 138,
          "vulnerability_code": "    function _burnFrom(address account, uint256 amount) internal {\n\n        _burn(account, amount);\n\n        _approve(account, _msgSender(), _allowances[account][_msgSender()].sub(amount, \"ERC20: burn amount exceeds allowance\"));\n",
          "message": "Function 'ERC20._burnFrom' (bVault.sol#135-138) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 270,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function withdraw(address, uint) external;\n",
          "message": "Parameter '' of Controller.withdraw (bVault.sol#270) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 270,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function withdraw(address, uint) external;\n",
          "message": "Parameter '_scope_0' of Controller.withdraw (bVault.sol#270) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 271,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function balanceOf(address) external view returns (uint);\n",
          "message": "Parameter '' of Controller.balanceOf (bVault.sol#271) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 272,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function earn(address, uint) external;\n",
          "message": "Parameter '' of Controller.earn (bVault.sol#272) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 272,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function earn(address, uint) external;\n",
          "message": "Parameter '_scope_0' of Controller.earn (bVault.sol#272) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 275,
          "vulnerability_to_line": 456,
          "vulnerability_code": "contract bVault is ERC20, ERC20Detailed {\n\n    using SafeERC20 for IERC20;\n\n    using Address for address;\n\n    using SafeMath for uint256;\n\n    \n\n    IERC20 public token;\n\n    \n\n    uint public min = 9500;\n\n    uint public constant max = 10000;\n\n    uint public earnLowerlimit;\n\n    \n\n    mapping(address => uint256) userDepoistTime;\n\n    address public feeAddress;\n\n    \n\n    uint public fee1 = 5;       //fee within 24 hours\n\n    uint public fee2 = 3;       //fee within 1 week\n\n    uint public fee3 = 1;       //fee without 1 week\n\n    uint public feeMax = 1000;\n\n    \n\n    address public governance;\n\n    address public controller;\n\n\taddress public timelock;\n\n\t\n\n\tbool public RestrictContractCall = true;\n\n\n\n     modifier onlyRestrictContractCall() {\n\n         address s = msg.sender;\n\n        require(!RestrictContractCall || !s.isContract(), \"Contract cannot call\");\n\n        _;\n\n    }\n\n    \n\n    constructor (address _token,uint _earnLowerlimit) public ERC20Detailed(\n\n        string(abi.encodePacked(\"bt:vault: \", ERC20Detailed(_token).name())),\n\n        string(abi.encodePacked(\"b\", ERC20Detailed(_token).symbol())),\n\n        ERC20Detailed(_token).decimals()\n\n    ) {\n\n        token = IERC20(_token);\n\n        governance = tx.origin;\n\n        controller = 0x03D2079c54967f463Fd6e89E76012F74EBC62615;\n\n        earnLowerlimit = _earnLowerlimit;\n\n        feeAddress = tx.origin;\n\n\t\ttimelock = tx.origin;\n\n    }\n\n    \n\n    function balance() public view returns (uint) {\n\n        return token.balanceOf(address(this))\n\n                .add(Controller(controller).balanceOf(address(token)));\n\n    }\n\n    \n\n    function setMin(uint _min) external {\n\n        require(msg.sender == governance, \"!governance\");\n\n        min = _min;\n\n    }\n\n    \n\n    function setGovernance(address _governance) public {\n\n        require(msg.sender == governance, \"!governance\");\n\n        governance = _governance;\n\n    }\n\n    \n\n    function setController(address _controller) public {\n\n        require(msg.sender == timelock, \"!timelock\");\n\n        controller = _controller;\n\n    }\n\n    function setEarnLowerlimit(uint256 _earnLowerlimit) public{\n\n      require(msg.sender == governance, \"!governance\");\n\n      earnLowerlimit = _earnLowerlimit;\n\n  }\n\n    \n\n    // Custom logic in here for how much the vault allows to be borrowed\n\n    // Sets minimum required on-hand to keep small withdrawals cheap\n\n    function available() public view returns (uint) {\n\n        return token.balanceOf(address(this)).mul(min).div(max);\n\n    }\n\n    \n\n    function earn() public {\n\n        uint _bal = available();\n\n        token.safeTransfer(controller, _bal);\n\n        Controller(controller).earn(address(token), _bal);\n\n    }\n\n    \n\n    function depositAll() external {\n\n        deposit(token.balanceOf(msg.sender));\n\n    }\n\n    //SWC-Reentrancy: L357-L375\n\n    function deposit(uint _amount) public onlyRestrictContractCall {\n\n\t\trequire(_amount > 0, \"Cannot deposit 0\");\n\n        uint _pool = balance();\n\n        uint _before = token.balanceOf(address(this));\n\n        token.safeTransferFrom(msg.sender, address(this), _amount);\n\n        uint _after = token.balanceOf(address(this));\n\n        _amount = _after.sub(_before); // Additional check for deflationary tokens\n\n        uint shares = 0;\n\n        if (totalSupply() == 0) {\n\n            shares = _amount;\n\n        } else {\n\n            shares = (_amount.mul(totalSupply())).div(_pool);\n\n        }\n\n        _mint(msg.sender, shares);\n\n        userDepoistTime[msg.sender] = now;\n\n        if (token.balanceOf(address(this))>earnLowerlimit){\n\n          earn();\n\n        }\n\n    }\n\n    \n\n    function withdrawAll() external {\n\n        withdraw(balanceOf(msg.sender));\n\n    }\n\n    \n\n    \n\n    \n\n    // No rebalance implementation for lower fees and faster swaps\n\n    function withdraw(uint _shares) public onlyRestrictContractCall {\n\n\t\trequire(_shares > 0, \"Cannot withdraw 0\");\n\n\n\n        uint r = (balance().mul(_shares)).div(totalSupply());\n\n        _burn(msg.sender, _shares);\n\n        \n\n        // Check balance\n\n        uint b = token.balanceOf(address(this));\n\n        if (b < r) {\n\n            uint _withdraw = r.sub(b);\n\n            Controller(controller).withdraw(address(token), _withdraw);\n\n            uint _after = token.balanceOf(address(this));\n\n            uint _diff = _after.sub(b);\n\n            if (_diff < _withdraw) {\n\n                r = b.add(_diff);\n\n            }\n\n        }\n\n        uint feeRatio = getFeeRatio();\n\n        if(feeRatio>0){\n\n            uint fee = r.mul(feeRatio).div(feeMax);\n\n            r = r.sub(fee);\n\n            token.safeTransfer(feeAddress,fee);\n\n        }\n\n        token.safeTransfer(msg.sender, r);\n\n    }\n\n    \n\n    function getFeeRatio() internal view returns(uint)\n\n    {\n\n        uint256 t = now - userDepoistTime[msg.sender];\n\n        if(t > 604800) {//7*24*60*60\n\n            return fee3;\n\n        }\n\n        if(t>86400) {//24*60*60\n\n            return fee2;\n\n        }\n\n        return fee1;\n\n    }\n\n    \n\n    function getPricePerFullShare() public view returns (uint) {\n\n        if (totalSupply()==0) {\n\n            return 0;\n\n        }\n\n        return balance().mul(1e18).div(totalSupply());\n\n    }\n\n\n\n    function setFeeRatio(uint[3] memory fees) public\n\n    {\n\n        require(msg.sender == timelock, \"!timelock\");\n\n        require(fees[0]<feeMax&&fees[1]<feeMax&&fees[2]<feeMax,\"The fee is too high\");\n\n        fee1 = fees[0];\n\n        fee2 = fees[1];\n\n        fee3 = fees[2];\n\n    }\n\n    \n\n    function setFeeAddress(address fadd) public \n\n    {\n\n        require(msg.sender == timelock, \"!timelock\");\n\n        feeAddress = fadd;\n\n    }\n\n\t\n\n\tfunction setTimeLock(address _timelock) public \n\n    {\n\n        require(msg.sender == timelock, \"!timelock\");\n\n        timelock = _timelock;\n\n    }\n\n    \n\n    function setRestrictContractCall(bool enabled) public {\n\n        require(msg.sender == governance, \"!governance\");\n\n        RestrictContractCall = enabled;\n\n    }\n",
          "message": "Contract 'bVault' (bVault.sol#275-456) is not in CapWords\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 306,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor (address _token,uint _earnLowerlimit) public ERC20Detailed(\n",
          "message": "Parameter '_token' of bVault. (bVault.sol#306) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 306,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor (address _token,uint _earnLowerlimit) public ERC20Detailed(\n",
          "message": "Parameter '_earnLowerlimit' of bVault. (bVault.sol#306) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 324,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setMin(uint _min) external {\n",
          "message": "Parameter '_min' of bVault.setMin (bVault.sol#324) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 329,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setGovernance(address _governance) public {\n",
          "message": "Parameter '_governance' of bVault.setGovernance (bVault.sol#329) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 334,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setController(address _controller) public {\n",
          "message": "Parameter '_controller' of bVault.setController (bVault.sol#334) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 338,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setEarnLowerlimit(uint256 _earnLowerlimit) public{\n",
          "message": "Parameter '_earnLowerlimit' of bVault.setEarnLowerlimit (bVault.sol#338) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 359,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function deposit(uint _amount) public onlyRestrictContractCall {\n",
          "message": "Parameter '_amount' of bVault.deposit (bVault.sol#359) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 386,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function withdraw(uint _shares) public onlyRestrictContractCall {\n",
          "message": "Parameter '_shares' of bVault.withdraw (bVault.sol#386) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 446,
          "vulnerability_to_line": null,
          "vulnerability_code": "\tfunction setTimeLock(address _timelock) public \n",
          "message": "Parameter '_timelock' of bVault.setTimeLock (bVault.sol#446) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 283,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint public constant max = 10000;\n",
          "message": "Constant 'bVault.max' (bVault.sol#283) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 298,
          "vulnerability_to_line": null,
          "vulnerability_code": "\tbool public RestrictContractCall = true;\n",
          "message": "Variable 'bVault.RestrictContractCall' (bVault.sol#298) is not in mixedCase\n"
        }
      ]
    },
    "smartcheck": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 313,
          "vulnerability_to_line": null,
          "vulnerability_code": "        controller = 0x03D2079c54967f463Fd6e89E76012F74EBC62615;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 56,
          "vulnerability_to_line": null,
          "vulnerability_code": "        _owner = address(0);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ERC20_APPROVE",
          "vulnerability_from_line": 89,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function approve(address spender, uint256 amount) public returns (bool) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_OVERPOWERED_ROLE",
          "vulnerability_from_line": 324,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setMin(uint _min) external {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_OVERPOWERED_ROLE",
          "vulnerability_from_line": 329,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setGovernance(address _governance) public {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_OVERPOWERED_ROLE",
          "vulnerability_from_line": 334,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setController(address _controller) public {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_OVERPOWERED_ROLE",
          "vulnerability_from_line": 338,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setEarnLowerlimit(uint256 _earnLowerlimit) public{\n",
          "message": null
        },
        {
          "name": "SOLIDITY_OVERPOWERED_ROLE",
          "vulnerability_from_line": 431,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setFeeRatio(uint[3] memory fees) public\n",
          "message": null
        },
        {
          "name": "SOLIDITY_OVERPOWERED_ROLE",
          "vulnerability_from_line": 440,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setFeeAddress(address fadd) public \n",
          "message": null
        },
        {
          "name": "SOLIDITY_OVERPOWERED_ROLE",
          "vulnerability_from_line": 446,
          "vulnerability_to_line": null,
          "vulnerability_code": "\tfunction setTimeLock(address _timelock) public \n",
          "message": null
        },
        {
          "name": "SOLIDITY_OVERPOWERED_ROLE",
          "vulnerability_from_line": 452,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setRestrictContractCall(bool enabled) public {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 9,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 37,
          "vulnerability_to_line": null,
          "vulnerability_code": "    address private _owner;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 71,
          "vulnerability_to_line": null,
          "vulnerability_code": "    mapping (address => uint256) private _balances;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 73,
          "vulnerability_to_line": null,
          "vulnerability_code": "    mapping (address => mapping (address => uint256)) private _allowances;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 75,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint256 private _totalSupply;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 142,
          "vulnerability_to_line": null,
          "vulnerability_code": "    string private _name;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 143,
          "vulnerability_to_line": null,
          "vulnerability_code": "    string private _symbol;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 144,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint8 private _decimals;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SAFEMATH",
          "vulnerability_from_line": 69,
          "vulnerability_to_line": null,
          "vulnerability_code": "    using SafeMath for uint256;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SAFEMATH",
          "vulnerability_from_line": 228,
          "vulnerability_to_line": null,
          "vulnerability_code": "    using SafeMath for uint256;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SAFEMATH",
          "vulnerability_from_line": 278,
          "vulnerability_to_line": null,
          "vulnerability_code": "    using SafeMath for uint256;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
          "vulnerability_from_line": 208,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function isContract(address account) internal view returns (bool) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_TX_ORIGIN",
          "vulnerability_from_line": 312,
          "vulnerability_to_line": null,
          "vulnerability_code": "        governance = tx.origin;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_TX_ORIGIN",
          "vulnerability_from_line": 315,
          "vulnerability_to_line": null,
          "vulnerability_code": "        feeAddress = tx.origin;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_TX_ORIGIN",
          "vulnerability_from_line": 316,
          "vulnerability_to_line": null,
          "vulnerability_code": "\t\ttimelock = tx.origin;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UNCHECKED_CALL",
          "vulnerability_from_line": 232,
          "vulnerability_to_line": null,
          "vulnerability_code": "        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UNCHECKED_CALL",
          "vulnerability_from_line": 236,
          "vulnerability_to_line": null,
          "vulnerability_code": "        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UNCHECKED_CALL",
          "vulnerability_from_line": 243,
          "vulnerability_to_line": null,
          "vulnerability_code": "        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UNCHECKED_CALL",
          "vulnerability_from_line": 248,
          "vulnerability_to_line": null,
          "vulnerability_code": "        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UNCHECKED_CALL",
          "vulnerability_from_line": 253,
          "vulnerability_to_line": null,
          "vulnerability_code": "        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UNCHECKED_CALL",
          "vulnerability_from_line": 259,
          "vulnerability_to_line": null,
          "vulnerability_code": "        (bool success, bytes memory returndata) = address(token).call(data);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 212,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly { codehash := extcodehash(account) }\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 218,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function sendValue(address payable recipient, uint256 amount) internal {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 218,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function sendValue(address payable recipient, uint256 amount) internal {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 218,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function sendValue(address payable recipient, uint256 amount) internal {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 219,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(address(this).balance >= amount, \"Address: insufficient balance\");\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 219,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(address(this).balance >= amount, \"Address: insufficient balance\");\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 219,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(address(this).balance >= amount, \"Address: insufficient balance\");\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 219,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(address(this).balance >= amount, \"Address: insufficient balance\");\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 222,
          "vulnerability_to_line": null,
          "vulnerability_code": "        (bool success, ) = recipient.call.value(amount)(\"\");\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 222,
          "vulnerability_to_line": null,
          "vulnerability_code": "        (bool success, ) = recipient.call.value(amount)(\"\");\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 222,
          "vulnerability_to_line": null,
          "vulnerability_code": "        (bool success, ) = recipient.call.value(amount)(\"\");\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 223,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(success, \"Address: unable to send value, recipient may have reverted\");\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 286,
          "vulnerability_to_line": null,
          "vulnerability_code": "    mapping(address => uint256) userDepoistTime;\n",
          "message": null
        }
      ]
    },
    "oyente": {
      "successfull_analysis": false,
      "errors": [
        "exception (RuntimeError: Source map error, unknown name(SHR) or instr_name(INVALID))"
      ],
      "vulnerability_findings": []
    },
    "mythril": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": []
    },
    "osiris": {
      "successfull_analysis": false,
      "errors": [
        "Solidity compilation failed"
      ],
      "vulnerability_findings": []
    }
  }
}