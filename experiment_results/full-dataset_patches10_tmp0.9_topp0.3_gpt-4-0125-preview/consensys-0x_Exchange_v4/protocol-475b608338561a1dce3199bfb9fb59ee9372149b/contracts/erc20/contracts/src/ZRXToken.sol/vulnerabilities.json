{
  "smartbugs_completed": true,
  "analyzer_results": {
    "semgrep": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 66,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (balances[msg.sender] >= _value && balances[_to] + _value >= balances[_to]) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 67,
          "vulnerability_to_line": null,
          "vulnerability_code": "            balances[msg.sender] -= _value;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 68,
          "vulnerability_to_line": null,
          "vulnerability_code": "            balances[_to] += _value;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 69,
          "vulnerability_to_line": null,
          "vulnerability_code": "            Transfer(msg.sender, _to, _value);\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 70,
          "vulnerability_to_line": null,
          "vulnerability_code": "            return true;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 71,
          "vulnerability_to_line": null,
          "vulnerability_code": "        } else { return false; }\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 75,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value >= balances[_to]) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 76,
          "vulnerability_to_line": null,
          "vulnerability_code": "            balances[_to] += _value;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 77,
          "vulnerability_to_line": null,
          "vulnerability_code": "            balances[_from] -= _value;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 78,
          "vulnerability_to_line": null,
          "vulnerability_code": "            allowed[_from][msg.sender] -= _value;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 79,
          "vulnerability_to_line": null,
          "vulnerability_code": "            Transfer(_from, _to, _value);\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 80,
          "vulnerability_to_line": null,
          "vulnerability_code": "            return true;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 81,
          "vulnerability_to_line": null,
          "vulnerability_code": "        } else { return false; }\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 118,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (balances[_from] >= _value\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 119,
          "vulnerability_to_line": null,
          "vulnerability_code": "            && allowance >= _value\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 120,
          "vulnerability_to_line": null,
          "vulnerability_code": "            && balances[_to] + _value >= balances[_to]\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 121,
          "vulnerability_to_line": null,
          "vulnerability_code": "        ) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 122,
          "vulnerability_to_line": null,
          "vulnerability_code": "            balances[_to] += _value;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 123,
          "vulnerability_to_line": null,
          "vulnerability_code": "            balances[_from] -= _value;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 124,
          "vulnerability_to_line": null,
          "vulnerability_code": "            if (allowance < MAX_UINT) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 125,
          "vulnerability_to_line": null,
          "vulnerability_code": "                allowed[_from][msg.sender] -= _value;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 126,
          "vulnerability_to_line": null,
          "vulnerability_code": "            }\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 127,
          "vulnerability_to_line": null,
          "vulnerability_code": "            Transfer(_from, _to, _value);\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        }
      ]
    },
    "slither": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": []
    },
    "smartcheck": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
          "vulnerability_from_line": 27,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function totalSupply() constant returns (uint supply) {}\n",
          "message": null
        },
        {
          "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
          "vulnerability_from_line": 31,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function balanceOf(address _owner) constant returns (uint balance) {}\n",
          "message": null
        },
        {
          "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
          "vulnerability_from_line": 55,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function allowance(address _owner, address _spender) constant returns (uint remaining) {}\n",
          "message": null
        },
        {
          "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
          "vulnerability_from_line": 84,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function balanceOf(address _owner) constant returns (uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
          "vulnerability_from_line": 94,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function allowance(address _owner, address _spender) constant returns (uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ERC20_APPROVE",
          "vulnerability_from_line": 88,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function approve(address _spender, uint _value) returns (bool) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
          "vulnerability_from_line": 27,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function totalSupply() constant returns (uint supply) {}\n",
          "message": null
        },
        {
          "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
          "vulnerability_from_line": 31,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function balanceOf(address _owner) constant returns (uint balance) {}\n",
          "message": null
        },
        {
          "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
          "vulnerability_from_line": 37,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function transfer(address _to, uint _value) returns (bool success) {}\n",
          "message": null
        },
        {
          "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
          "vulnerability_from_line": 44,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function transferFrom(address _from, address _to, uint _value) returns (bool success) {}\n",
          "message": null
        },
        {
          "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
          "vulnerability_from_line": 50,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function approve(address _spender, uint _value) returns (bool success) {}\n",
          "message": null
        },
        {
          "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
          "vulnerability_from_line": 55,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function allowance(address _owner, address _spender) constant returns (uint remaining) {}\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 27,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function totalSupply() constant returns (uint supply) {}\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 31,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function balanceOf(address _owner) constant returns (uint balance) {}\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 37,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function transfer(address _to, uint _value) returns (bool success) {}\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 44,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function transferFrom(address _from, address _to, uint _value) returns (bool success) {}\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 50,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function approve(address _spender, uint _value) returns (bool success) {}\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 55,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function allowance(address _owner, address _spender) constant returns (uint remaining) {}\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 64,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function transfer(address _to, uint _value) returns (bool) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 74,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function transferFrom(address _from, address _to, uint _value) returns (bool) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 84,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function balanceOf(address _owner) constant returns (uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 88,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function approve(address _spender, uint _value) returns (bool) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 94,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function allowance(address _owner, address _spender) constant returns (uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 98,
          "vulnerability_to_line": null,
          "vulnerability_code": "    mapping (address => uint) balances;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 99,
          "vulnerability_to_line": null,
          "vulnerability_code": "    mapping (address => mapping (address => uint)) allowed;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 106,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint constant MAX_UINT = 2**256 - 1;\n",
          "message": null
        }
      ]
    },
    "oyente": {
      "successfull_analysis": false,
      "errors": [
        "exception (json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0))"
      ],
      "vulnerability_findings": []
    },
    "mythril": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "Exception State (SWC 110)",
          "vulnerability_from_line": 62,
          "vulnerability_to_line": null,
          "vulnerability_code": "contract ERC20Token is Token {\n",
          "message": "An assertion violation was triggered.\nIt is possible to trigger an assertion violation. Note that Solidity assert() statements should only be used to check invariants. Review the transaction trace generated for this issue and either make sure your program logic is correct, or use require() instead of assert() if your goal is to constrain user inputs or enforce preconditions. Remember to validate inputs from both callers (for instance, via passed arguments) and callees (for instance, via return values).\nClassification: SWC-110"
        },
        {
          "name": "Exception State (SWC 110)",
          "vulnerability_from_line": 24,
          "vulnerability_to_line": null,
          "vulnerability_code": "contract Token {\n",
          "message": "An assertion violation was triggered.\nIt is possible to trigger an assertion violation. Note that Solidity assert() statements should only be used to check invariants. Review the transaction trace generated for this issue and either make sure your program logic is correct, or use require() instead of assert() if your goal is to constrain user inputs or enforce preconditions. Remember to validate inputs from both callers (for instance, via passed arguments) and callees (for instance, via return values).\nClassification: SWC-110"
        },
        {
          "name": "Exception State (SWC 110)",
          "vulnerability_from_line": 104,
          "vulnerability_to_line": null,
          "vulnerability_code": "contract UnlimitedAllowanceToken is ERC20Token {\n",
          "message": "An assertion violation was triggered.\nIt is possible to trigger an assertion violation. Note that Solidity assert() statements should only be used to check invariants. Review the transaction trace generated for this issue and either make sure your program logic is correct, or use require() instead of assert() if your goal is to constrain user inputs or enforce preconditions. Remember to validate inputs from both callers (for instance, via passed arguments) and callees (for instance, via return values).\nClassification: SWC-110"
        },
        {
          "name": "Exception State (SWC 110)",
          "vulnerability_from_line": 147,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function ZRXToken()\n",
          "message": "An assertion violation was triggered.\nIt is possible to trigger an assertion violation. Note that Solidity assert() statements should only be used to check invariants. Review the transaction trace generated for this issue and either make sure your program logic is correct, or use require() instead of assert() if your goal is to constrain user inputs or enforce preconditions. Remember to validate inputs from both callers (for instance, via passed arguments) and callees (for instance, via return values).\nClassification: SWC-110"
        },
        {
          "name": "Exception State (SWC 110)",
          "vulnerability_from_line": 62,
          "vulnerability_to_line": null,
          "vulnerability_code": "contract ERC20Token is Token {\n",
          "message": "An assertion violation was triggered.\nIt is possible to trigger an assertion violation. Note that Solidity assert() statements should only be used to check invariants. Review the transaction trace generated for this issue and either make sure your program logic is correct, or use require() instead of assert() if your goal is to constrain user inputs or enforce preconditions. Remember to validate inputs from both callers (for instance, via passed arguments) and callees (for instance, via return values).\nClassification: SWC-110"
        },
        {
          "name": "Exception State (SWC 110)",
          "vulnerability_from_line": 24,
          "vulnerability_to_line": null,
          "vulnerability_code": "contract Token {\n",
          "message": "An assertion violation was triggered.\nIt is possible to trigger an assertion violation. Note that Solidity assert() statements should only be used to check invariants. Review the transaction trace generated for this issue and either make sure your program logic is correct, or use require() instead of assert() if your goal is to constrain user inputs or enforce preconditions. Remember to validate inputs from both callers (for instance, via passed arguments) and callees (for instance, via return values).\nClassification: SWC-110"
        },
        {
          "name": "Exception State (SWC 110)",
          "vulnerability_from_line": 104,
          "vulnerability_to_line": null,
          "vulnerability_code": "contract UnlimitedAllowanceToken is ERC20Token {\n",
          "message": "An assertion violation was triggered.\nIt is possible to trigger an assertion violation. Note that Solidity assert() statements should only be used to check invariants. Review the transaction trace generated for this issue and either make sure your program logic is correct, or use require() instead of assert() if your goal is to constrain user inputs or enforce preconditions. Remember to validate inputs from both callers (for instance, via passed arguments) and callees (for instance, via return values).\nClassification: SWC-110"
        },
        {
          "name": "Exception State (SWC 110)",
          "vulnerability_from_line": 136,
          "vulnerability_to_line": null,
          "vulnerability_code": "contract ZRXToken is \n",
          "message": "An assertion violation was triggered.\nIt is possible to trigger an assertion violation. Note that Solidity assert() statements should only be used to check invariants. Review the transaction trace generated for this issue and either make sure your program logic is correct, or use require() instead of assert() if your goal is to constrain user inputs or enforce preconditions. Remember to validate inputs from both callers (for instance, via passed arguments) and callees (for instance, via return values).\nClassification: SWC-110"
        }
      ]
    },
    "osiris": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": []
    }
  }
}