{
  "smartbugs_completed": true,
  "analyzer_results": {
    "semgrep": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "use-abi-encodecall-instead-of-encodewithselector",
          "vulnerability_from_line": 82,
          "vulnerability_to_line": null,
          "vulnerability_code": "        return abi.encodeWithSelector(\n",
          "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
        },
        {
          "name": "use-abi-encodecall-instead-of-encodewithselector",
          "vulnerability_from_line": 83,
          "vulnerability_to_line": null,
          "vulnerability_code": "            STANDARD_ERROR_SELECTOR,\n",
          "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
        },
        {
          "name": "use-abi-encodecall-instead-of-encodewithselector",
          "vulnerability_from_line": 84,
          "vulnerability_to_line": null,
          "vulnerability_code": "            bytes(message)\n",
          "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
        },
        {
          "name": "use-abi-encodecall-instead-of-encodewithselector",
          "vulnerability_from_line": 85,
          "vulnerability_to_line": null,
          "vulnerability_code": "        );\n",
          "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
        },
        {
          "name": "init-variables-with-default-value",
          "vulnerability_from_line": 127,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bool private _locked = false;\n",
          "message": "Uninitialized variables are assigned with the types default value. Explicitly initializing a variable with its default value costs unnecessary gas."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 359,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.value != 0, \"Zero value should not be sent to this contract.\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 376,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(address(this).balance == msg.value, \"A full refund was not provided by `refundNonzeroBalance`\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 448,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(balanceWithinCall == msg.value, \"Incorrect inner balance\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 475,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(balanceWithinCall == msg.value, \"Incorrect inner balance\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 497,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(address(this).balance == 0, \"Incorrect balance for TestRefundableReceiver\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 500,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(address(testRefundable).balance == msg.value, \"Incorrect balance for TestRefundable\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 503,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(address(this).balance == msg.value, \"Incorrect balance for TestRefundableReceiver\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 506,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(address(testRefundable).balance == 0, \"Incorrect balance for TestRefundable\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 511,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(testRefundable.getShouldNotRefund() == shouldNotRefund, \"Incorrect shouldNotRefund value\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 359,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.value != 0, \"Zero value should not be sent to this contract.\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 376,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(address(this).balance == msg.value, \"A full refund was not provided by `refundNonzeroBalance`\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 497,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(address(this).balance == 0, \"Incorrect balance for TestRefundableReceiver\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 500,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(address(testRefundable).balance == msg.value, \"Incorrect balance for TestRefundable\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 503,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(address(this).balance == msg.value, \"Incorrect balance for TestRefundableReceiver\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 506,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(address(testRefundable).balance == 0, \"Incorrect balance for TestRefundable\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        }
      ]
    },
    "slither": {
      "successfull_analysis": true,
      "errors": [
        "EXIT_CODE_19"
      ],
      "vulnerability_findings": [
        {
          "name": "arbitrary-send",
          "vulnerability_from_line": 217,
          "vulnerability_to_line": 224,
          "vulnerability_code": "    function _refundNonZeroBalance()\n\n        internal\n\n    {\n\n        uint256 balance = address(this).balance;\n\n        if (balance > 0) {\n\n            msg.sender.transfer(balance);\n\n        }\n",
          "message": "Refundable._refundNonZeroBalance (TestRefundableReceiver.sol#217-224) sends eth to arbitrary user\n\tDangerous calls:\n\t- msg.sender.transfer(balance) (TestRefundableReceiver.sol#222)\n"
        },
        {
          "name": "arbitrary-send",
          "vulnerability_from_line": 486,
          "vulnerability_to_line": 515,
          "vulnerability_code": "    function requireCorrectFinalBalancesAndState(\n\n        TestRefundable testRefundable,\n\n        bool shouldNotRefund\n\n    )\n\n        internal\n\n    {\n\n        // If `shouldNotRefund` was true, then this contract should have a balance of zero,\n\n        // and `testRefundable` should have a balance of `msg.value`. Otherwise, the opposite\n\n        // should be true.\n\n        if (shouldNotRefund) {\n\n            // Ensure that this contract's balance is zero.\n\n            require(address(this).balance == 0, \"Incorrect balance for TestRefundableReceiver\");\n\n\n\n            // Ensure that the other contract's balance is equal to `msg.value`.\n\n            require(address(testRefundable).balance == msg.value, \"Incorrect balance for TestRefundable\");\n\n        } else {\n\n            // Ensure that this contract's balance is `msg.value`.\n\n            require(address(this).balance == msg.value, \"Incorrect balance for TestRefundableReceiver\");\n\n\n\n            // Ensure that the other contract's balance is equal to zero.\n\n            require(address(testRefundable).balance == 0, \"Incorrect balance for TestRefundable\");\n\n        }\n\n\n\n        // Ensure that `shouldNotRefund` in TestRefundable is set to the parameter `shouldNotRefund`\n\n        // after the call (i.e. the value didn't change during the function call).\n\n        require(testRefundable.getShouldNotRefund() == shouldNotRefund, \"Incorrect shouldNotRefund value\");\n\n\n\n        // Drain the contract of funds so that subsequent tests don't have to account for leftover ether.\n\n        msg.sender.transfer(address(this).balance);\n",
          "message": "TestRefundableReceiver.requireCorrectFinalBalancesAndState (TestRefundableReceiver.sol#486-515) sends eth to arbitrary user\n\tDangerous calls:\n\t- msg.sender.transfer(address(this).balance) (TestRefundableReceiver.sol#514)\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 91,
          "vulnerability_to_line": 98,
          "vulnerability_code": "    function rrevert(bytes memory errorData)\n\n        internal\n\n        pure\n\n    {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
          "message": "LibRichErrors.rrevert (TestRefundableReceiver.sol#91-98) is declared view but contains assembly code\n"
        },
        {
          "name": "incorrect-equality",
          "vulnerability_from_line": 486,
          "vulnerability_to_line": 515,
          "vulnerability_code": "    function requireCorrectFinalBalancesAndState(\n\n        TestRefundable testRefundable,\n\n        bool shouldNotRefund\n\n    )\n\n        internal\n\n    {\n\n        // If `shouldNotRefund` was true, then this contract should have a balance of zero,\n\n        // and `testRefundable` should have a balance of `msg.value`. Otherwise, the opposite\n\n        // should be true.\n\n        if (shouldNotRefund) {\n\n            // Ensure that this contract's balance is zero.\n\n            require(address(this).balance == 0, \"Incorrect balance for TestRefundableReceiver\");\n\n\n\n            // Ensure that the other contract's balance is equal to `msg.value`.\n\n            require(address(testRefundable).balance == msg.value, \"Incorrect balance for TestRefundable\");\n\n        } else {\n\n            // Ensure that this contract's balance is `msg.value`.\n\n            require(address(this).balance == msg.value, \"Incorrect balance for TestRefundableReceiver\");\n\n\n\n            // Ensure that the other contract's balance is equal to zero.\n\n            require(address(testRefundable).balance == 0, \"Incorrect balance for TestRefundable\");\n\n        }\n\n\n\n        // Ensure that `shouldNotRefund` in TestRefundable is set to the parameter `shouldNotRefund`\n\n        // after the call (i.e. the value didn't change during the function call).\n\n        require(testRefundable.getShouldNotRefund() == shouldNotRefund, \"Incorrect shouldNotRefund value\");\n\n\n\n        // Drain the contract of funds so that subsequent tests don't have to account for leftover ether.\n\n        msg.sender.transfer(address(this).balance);\n",
          "message": "TestRefundableReceiver.requireCorrectFinalBalancesAndState (TestRefundableReceiver.sol#486-515) uses a dangerous strict equality:\n\t- require(bool,string)(address(this).balance == 0,Incorrect balance for TestRefundableReceiver)\n\t- require(bool,string)(address(testRefundable).balance == msg.value,Incorrect balance for TestRefundable)\n\t- require(bool,string)(address(this).balance == msg.value,Incorrect balance for TestRefundableReceiver)\n\t- require(bool,string)(address(testRefundable).balance == 0,Incorrect balance for TestRefundable)\n"
        },
        {
          "name": "incorrect-equality",
          "vulnerability_from_line": 486,
          "vulnerability_to_line": 515,
          "vulnerability_code": "    function requireCorrectFinalBalancesAndState(\n\n        TestRefundable testRefundable,\n\n        bool shouldNotRefund\n\n    )\n\n        internal\n\n    {\n\n        // If `shouldNotRefund` was true, then this contract should have a balance of zero,\n\n        // and `testRefundable` should have a balance of `msg.value`. Otherwise, the opposite\n\n        // should be true.\n\n        if (shouldNotRefund) {\n\n            // Ensure that this contract's balance is zero.\n\n            require(address(this).balance == 0, \"Incorrect balance for TestRefundableReceiver\");\n\n\n\n            // Ensure that the other contract's balance is equal to `msg.value`.\n\n            require(address(testRefundable).balance == msg.value, \"Incorrect balance for TestRefundable\");\n\n        } else {\n\n            // Ensure that this contract's balance is `msg.value`.\n\n            require(address(this).balance == msg.value, \"Incorrect balance for TestRefundableReceiver\");\n\n\n\n            // Ensure that the other contract's balance is equal to zero.\n\n            require(address(testRefundable).balance == 0, \"Incorrect balance for TestRefundable\");\n\n        }\n\n\n\n        // Ensure that `shouldNotRefund` in TestRefundable is set to the parameter `shouldNotRefund`\n\n        // after the call (i.e. the value didn't change during the function call).\n\n        require(testRefundable.getShouldNotRefund() == shouldNotRefund, \"Incorrect shouldNotRefund value\");\n\n\n\n        // Drain the contract of funds so that subsequent tests don't have to account for leftover ether.\n\n        msg.sender.transfer(address(this).balance);\n",
          "message": "TestRefundableReceiver.requireCorrectFinalBalancesAndState (TestRefundableReceiver.sol#486-515) uses a dangerous strict equality:\n\t- require(bool,string)(address(this).balance == 0,Incorrect balance for TestRefundableReceiver)\n\t- require(bool,string)(address(testRefundable).balance == msg.value,Incorrect balance for TestRefundable)\n\t- require(bool,string)(address(this).balance == msg.value,Incorrect balance for TestRefundableReceiver)\n\t- require(bool,string)(address(testRefundable).balance == 0,Incorrect balance for TestRefundable)\nTestRefundableReceiver.testRefundNonZeroBalance (TestRefundableReceiver.sol#365-378) uses a dangerous strict equality:\n\t- require(bool,string)(address(this).balance == msg.value,A full refund was not provided by `refundNonzeroBalance`)\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 91,
          "vulnerability_to_line": 98,
          "vulnerability_code": "    function rrevert(bytes memory errorData)\n\n        internal\n\n        pure\n\n    {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
          "message": "LibRichErrors.rrevert uses assembly (TestRefundableReceiver.sol#91-98)\n\t- TestRefundableReceiver.sol#95-97\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 306,
          "vulnerability_to_line": 314,
          "vulnerability_code": "    function nestedDisableRefundUntilEndFunction()\n\n        public\n\n        payable\n\n        disableRefundUntilEnd\n\n        returns (uint256)\n\n    {\n\n        disableRefundUntilEndFunction();\n\n        return address(this).balance;\n",
          "message": "TestRefundable.nestedDisableRefundUntilEndFunction (TestRefundableReceiver.sol#306-314) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 316,
          "vulnerability_to_line": 324,
          "vulnerability_code": "    function mixedRefundModifierFunction()\n\n        public\n\n        payable\n\n        disableRefundUntilEnd\n\n        returns (uint256)\n\n    {\n\n        refundFinalBalanceFunction();\n\n        return address(this).balance;\n",
          "message": "TestRefundable.mixedRefundModifierFunction (TestRefundableReceiver.sol#316-324) should be declared external\n"
        },
        {
          "name": "solc-version",
          "vulnerability_from_line": 21,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.9;\n",
          "message": "Detected issues with version pragma in TestRefundableReceiver.sol:\n\t- pragma solidity^0.5.9 (TestRefundableReceiver.sol#21): it allows old versions\n\t- pragma solidity^0.5.9 (TestRefundableReceiver.sol#60): it allows old versions\n\t- pragma solidity^0.5.9 (TestRefundableReceiver.sol#121): it allows old versions\n\t- pragma solidity^0.5.9 (TestRefundableReceiver.sol#178): it allows old versions\n\t- pragma solidity^0.5.9 (TestRefundableReceiver.sol#268): it allows old versions\n\t- pragma solidity^0.5.9 (TestRefundableReceiver.sol#347): it allows old versions\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 31,
          "vulnerability_to_line": 37,
          "vulnerability_code": "    function IllegalReentrancyError()\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return ILLEGAL_REENTRANCY_ERROR_SELECTOR_BYTES;\n",
          "message": "Function 'LibReentrancyGuardRichErrors.IllegalReentrancyError' (TestRefundableReceiver.sol#31-37) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 75,
          "vulnerability_to_line": 86,
          "vulnerability_code": "    function StandardError(\n\n        string memory message\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            STANDARD_ERROR_SELECTOR,\n\n            bytes(message)\n\n        );\n",
          "message": "Function 'LibRichErrors.StandardError' (TestRefundableReceiver.sol#75-86) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 137,
          "vulnerability_to_line": 148,
          "vulnerability_code": "    function _lockMutexOrThrowIfAlreadyLocked()\n\n        internal\n\n    {\n\n        // Ensure mutex is unlocked.\n\n        if (_locked) {\n\n            LibRichErrors.rrevert(\n\n                LibReentrancyGuardRichErrors.IllegalReentrancyError()\n\n            );\n\n        }\n\n        // Lock mutex.\n\n        _locked = true;\n",
          "message": "Function 'ReentrancyGuard._lockMutexOrThrowIfAlreadyLocked' (TestRefundableReceiver.sol#137-148) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 150,
          "vulnerability_to_line": 155,
          "vulnerability_code": "    function _unlockMutex()\n\n        internal\n\n    {\n\n        // Unlock mutex.\n\n        _locked = false;\n",
          "message": "Function 'ReentrancyGuard._unlockMutex' (TestRefundableReceiver.sol#150-155) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 209,
          "vulnerability_to_line": 215,
          "vulnerability_code": "    function _refundNonZeroBalanceIfEnabled()\n\n        internal\n\n    {\n\n        if (!_areRefundsDisabled()) {\n\n            _refundNonZeroBalance();\n\n        }\n",
          "message": "Function 'Refundable._refundNonZeroBalanceIfEnabled' (TestRefundableReceiver.sol#209-215) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 217,
          "vulnerability_to_line": 224,
          "vulnerability_code": "    function _refundNonZeroBalance()\n\n        internal\n\n    {\n\n        uint256 balance = address(this).balance;\n\n        if (balance > 0) {\n\n            msg.sender.transfer(balance);\n\n        }\n",
          "message": "Function 'Refundable._refundNonZeroBalance' (TestRefundableReceiver.sol#217-224) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 226,
          "vulnerability_to_line": 230,
          "vulnerability_code": "    function _disableRefund()\n\n        internal\n\n    {\n\n        _shouldNotRefund = true;\n",
          "message": "Function 'Refundable._disableRefund' (TestRefundableReceiver.sol#226-230) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 232,
          "vulnerability_to_line": 237,
          "vulnerability_code": "    function _enableAndRefundNonZeroBalance()\n\n        internal\n\n    {\n\n        _shouldNotRefund = false;\n\n        _refundNonZeroBalance();\n",
          "message": "Function 'Refundable._enableAndRefundNonZeroBalance' (TestRefundableReceiver.sol#232-237) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 239,
          "vulnerability_to_line": 245,
          "vulnerability_code": "    function _areRefundsDisabled()\n\n        internal\n\n        view\n\n        returns (bool)\n\n    {\n\n        return _shouldNotRefund;\n",
          "message": "Function 'Refundable._areRefundsDisabled' (TestRefundableReceiver.sol#239-245) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 185,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bool internal _shouldNotRefund;\n",
          "message": "Variable 'Refundable._shouldNotRefund' (TestRefundableReceiver.sol#185) is not in mixedCase\n"
        }
      ]
    },
    "smartcheck": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 67,
          "vulnerability_to_line": null,
          "vulnerability_code": "        0x08c379a0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_BALANCE_EQUALITY",
          "vulnerability_from_line": 376,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(address(this).balance == msg.value, \"A full refund was not provided by `refundNonzeroBalance`\");\n",
          "message": null
        },
        {
          "name": "SOLIDITY_BALANCE_EQUALITY",
          "vulnerability_from_line": 497,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(address(this).balance == 0, \"Incorrect balance for TestRefundableReceiver\");\n",
          "message": null
        },
        {
          "name": "SOLIDITY_BALANCE_EQUALITY",
          "vulnerability_from_line": 500,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(address(testRefundable).balance == msg.value, \"Incorrect balance for TestRefundable\");\n",
          "message": null
        },
        {
          "name": "SOLIDITY_BALANCE_EQUALITY",
          "vulnerability_from_line": 503,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(address(this).balance == msg.value, \"Incorrect balance for TestRefundableReceiver\");\n",
          "message": null
        },
        {
          "name": "SOLIDITY_BALANCE_EQUALITY",
          "vulnerability_from_line": 506,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(address(testRefundable).balance == 0, \"Incorrect balance for TestRefundable\");\n",
          "message": null
        },
        {
          "name": "SOLIDITY_LOCKED_MONEY",
          "vulnerability_from_line": 270,
          "vulnerability_to_line": null,
          "vulnerability_code": "contract TestRefundable is\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 21,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.9;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 60,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.9;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 121,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.9;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 178,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.9;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 268,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.9;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 347,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.9;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 127,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bool private _locked = false;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 91,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function rrevert(bytes memory errorData)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 95,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        }
      ]
    },
    "oyente": {
      "successfull_analysis": false,
      "errors": [
        "exception (RuntimeError: Source map error, unknown name(SHR) or instr_name(INVALID))"
      ],
      "vulnerability_findings": []
    },
    "mythril": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "External Call To User-Supplied Address (SWC 107)",
          "vulnerability_from_line": 468,
          "vulnerability_to_line": null,
          "vulnerability_code": "        testRefundable.setShouldNotRefund(shouldNotRefund);\n",
          "message": "A call to a user-supplied address is executed.\nAn external message call to an address specified by the caller is executed. Note that the callee account might contain arbitrary code and could re-enter any function within this contract. Reentering the contract in an intermediate state may lead to unexpected behaviour. Make sure that no state modifications are executed after this call and/or reentrancy guards are in place.\nClassification: SWC-107"
        },
        {
          "name": "External Call To User-Supplied Address (SWC 107)",
          "vulnerability_from_line": 471,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint256 balanceWithinCall = testRefundable.mixedRefundModifierFunction.value(msg.value)();\n",
          "message": "A call to a user-supplied address is executed.\nAn external message call to an address specified by the caller is executed. Note that the callee account might contain arbitrary code and could re-enter any function within this contract. Reentering the contract in an intermediate state may lead to unexpected behaviour. Make sure that no state modifications are executed after this call and/or reentrancy guards are in place.\nClassification: SWC-107"
        },
        {
          "name": "Multiple Calls in a Single Transaction (SWC 113)",
          "vulnerability_from_line": 471,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint256 balanceWithinCall = testRefundable.mixedRefundModifierFunction.value(msg.value)();\n",
          "message": "Multiple calls are executed in the same transaction.\nThis call is executed following another call within the same transaction. It is possible that the call never gets executed if a prior call fails permanently. This might be caused intentionally by a malicious callee. If possible, refactor the code such that each transaction only executes one external call or make sure that all callees can be trusted (i.e. they\u2019re part of your own codebase).\nClassification: SWC-113"
        },
        {
          "name": "State access after external call (SWC 107)",
          "vulnerability_from_line": 471,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint256 balanceWithinCall = testRefundable.mixedRefundModifierFunction.value(msg.value)();\n",
          "message": "Write to persistent state following external call\nThe contract account state is accessed after an external call to a user defined address. To prevent reentrancy issues, consider accessing the state only before the call, especially if the callee is untrusted. Alternatively, a reentrancy lock can be used to prevent untrusted callees from re-entering the contract in an intermediate state.\nClassification: SWC-107"
        },
        {
          "name": "External Call To User-Supplied Address (SWC 107)",
          "vulnerability_from_line": 418,
          "vulnerability_to_line": null,
          "vulnerability_code": "        testRefundable.setShouldNotRefund(shouldNotRefund);\n",
          "message": "A call to a user-supplied address is executed.\nAn external message call to an address specified by the caller is executed. Note that the callee account might contain arbitrary code and could re-enter any function within this contract. Reentering the contract in an intermediate state may lead to unexpected behaviour. Make sure that no state modifications are executed after this call and/or reentrancy guards are in place.\nClassification: SWC-107"
        },
        {
          "name": "External Call To User-Supplied Address (SWC 107)",
          "vulnerability_from_line": 421,
          "vulnerability_to_line": null,
          "vulnerability_code": "        testRefundable.disableRefundUntilEndFunction.value(msg.value)();\n",
          "message": "A call to a user-supplied address is executed.\nAn external message call to an address specified by the caller is executed. Note that the callee account might contain arbitrary code and could re-enter any function within this contract. Reentering the contract in an intermediate state may lead to unexpected behaviour. Make sure that no state modifications are executed after this call and/or reentrancy guards are in place.\nClassification: SWC-107"
        },
        {
          "name": "Multiple Calls in a Single Transaction (SWC 113)",
          "vulnerability_from_line": 421,
          "vulnerability_to_line": null,
          "vulnerability_code": "        testRefundable.disableRefundUntilEndFunction.value(msg.value)();\n",
          "message": "Multiple calls are executed in the same transaction.\nThis call is executed following another call within the same transaction. It is possible that the call never gets executed if a prior call fails permanently. This might be caused intentionally by a malicious callee. If possible, refactor the code such that each transaction only executes one external call or make sure that all callees can be trusted (i.e. they\u2019re part of your own codebase).\nClassification: SWC-113"
        },
        {
          "name": "State access after external call (SWC 107)",
          "vulnerability_from_line": 421,
          "vulnerability_to_line": null,
          "vulnerability_code": "        testRefundable.disableRefundUntilEndFunction.value(msg.value)();\n",
          "message": "Write to persistent state following external call\nThe contract account state is accessed after an external call to a user defined address. To prevent reentrancy issues, consider accessing the state only before the call, especially if the callee is untrusted. Alternatively, a reentrancy lock can be used to prevent untrusted callees from re-entering the contract in an intermediate state.\nClassification: SWC-107"
        },
        {
          "name": "External Call To User-Supplied Address (SWC 107)",
          "vulnerability_from_line": 394,
          "vulnerability_to_line": null,
          "vulnerability_code": "        testRefundable.setShouldNotRefund(shouldNotRefund);\n",
          "message": "A call to a user-supplied address is executed.\nAn external message call to an address specified by the caller is executed. Note that the callee account might contain arbitrary code and could re-enter any function within this contract. Reentering the contract in an intermediate state may lead to unexpected behaviour. Make sure that no state modifications are executed after this call and/or reentrancy guards are in place.\nClassification: SWC-107"
        },
        {
          "name": "External Call To User-Supplied Address (SWC 107)",
          "vulnerability_from_line": 397,
          "vulnerability_to_line": null,
          "vulnerability_code": "        testRefundable.refundFinalBalanceFunction.value(msg.value)();\n",
          "message": "A call to a user-supplied address is executed.\nAn external message call to an address specified by the caller is executed. Note that the callee account might contain arbitrary code and could re-enter any function within this contract. Reentering the contract in an intermediate state may lead to unexpected behaviour. Make sure that no state modifications are executed after this call and/or reentrancy guards are in place.\nClassification: SWC-107"
        },
        {
          "name": "Multiple Calls in a Single Transaction (SWC 113)",
          "vulnerability_from_line": 397,
          "vulnerability_to_line": null,
          "vulnerability_code": "        testRefundable.refundFinalBalanceFunction.value(msg.value)();\n",
          "message": "Multiple calls are executed in the same transaction.\nThis call is executed following another call within the same transaction. It is possible that the call never gets executed if a prior call fails permanently. This might be caused intentionally by a malicious callee. If possible, refactor the code such that each transaction only executes one external call or make sure that all callees can be trusted (i.e. they\u2019re part of your own codebase).\nClassification: SWC-113"
        },
        {
          "name": "State access after external call (SWC 107)",
          "vulnerability_from_line": 397,
          "vulnerability_to_line": null,
          "vulnerability_code": "        testRefundable.refundFinalBalanceFunction.value(msg.value)();\n",
          "message": "Write to persistent state following external call\nThe contract account state is accessed after an external call to a user defined address. To prevent reentrancy issues, consider accessing the state only before the call, especially if the callee is untrusted. Alternatively, a reentrancy lock can be used to prevent untrusted callees from re-entering the contract in an intermediate state.\nClassification: SWC-107"
        },
        {
          "name": "External Call To User-Supplied Address (SWC 107)",
          "vulnerability_from_line": 370,
          "vulnerability_to_line": null,
          "vulnerability_code": "        testRefundable.refundNonZeroBalanceExternal.value(msg.value)();\n",
          "message": "A call to a user-supplied address is executed.\nAn external message call to an address specified by the caller is executed. Note that the callee account might contain arbitrary code and could re-enter any function within this contract. Reentering the contract in an intermediate state may lead to unexpected behaviour. Make sure that no state modifications are executed after this call and/or reentrancy guards are in place.\nClassification: SWC-107"
        },
        {
          "name": "Unprotected Ether Withdrawal (SWC 105)",
          "vulnerability_from_line": 370,
          "vulnerability_to_line": null,
          "vulnerability_code": "        testRefundable.refundNonZeroBalanceExternal.value(msg.value)();\n",
          "message": "Any sender can withdraw Ether from the contract account.\nArbitrary senders other than the contract creator can profitably extract Ether from the contract account. Verify the business logic carefully and make sure that appropriate security controls are in place to prevent unexpected loss of funds.\nClassification: SWC-105"
        },
        {
          "name": "External Call To User-Supplied Address (SWC 107)",
          "vulnerability_from_line": 441,
          "vulnerability_to_line": null,
          "vulnerability_code": "        testRefundable.setShouldNotRefund(shouldNotRefund);\n",
          "message": "A call to a user-supplied address is executed.\nAn external message call to an address specified by the caller is executed. Note that the callee account might contain arbitrary code and could re-enter any function within this contract. Reentering the contract in an intermediate state may lead to unexpected behaviour. Make sure that no state modifications are executed after this call and/or reentrancy guards are in place.\nClassification: SWC-107"
        },
        {
          "name": "External Call To User-Supplied Address (SWC 107)",
          "vulnerability_from_line": 444,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint256 balanceWithinCall = testRefundable.nestedDisableRefundUntilEndFunction.value(msg.value)();\n",
          "message": "A call to a user-supplied address is executed.\nAn external message call to an address specified by the caller is executed. Note that the callee account might contain arbitrary code and could re-enter any function within this contract. Reentering the contract in an intermediate state may lead to unexpected behaviour. Make sure that no state modifications are executed after this call and/or reentrancy guards are in place.\nClassification: SWC-107"
        },
        {
          "name": "Multiple Calls in a Single Transaction (SWC 113)",
          "vulnerability_from_line": 444,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint256 balanceWithinCall = testRefundable.nestedDisableRefundUntilEndFunction.value(msg.value)();\n",
          "message": "Multiple calls are executed in the same transaction.\nThis call is executed following another call within the same transaction. It is possible that the call never gets executed if a prior call fails permanently. This might be caused intentionally by a malicious callee. If possible, refactor the code such that each transaction only executes one external call or make sure that all callees can be trusted (i.e. they\u2019re part of your own codebase).\nClassification: SWC-113"
        },
        {
          "name": "State access after external call (SWC 107)",
          "vulnerability_from_line": 444,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint256 balanceWithinCall = testRefundable.nestedDisableRefundUntilEndFunction.value(msg.value)();\n",
          "message": "Write to persistent state following external call\nThe contract account state is accessed after an external call to a user defined address. To prevent reentrancy issues, consider accessing the state only before the call, especially if the callee is untrusted. Alternatively, a reentrancy lock can be used to prevent untrusted callees from re-entering the contract in an intermediate state.\nClassification: SWC-107"
        },
        {
          "name": "State access after external call (SWC 107)",
          "vulnerability_from_line": 514,
          "vulnerability_to_line": null,
          "vulnerability_code": "        msg.sender.transfer(address(this).balance);\n",
          "message": "Write to persistent state following external call\nThe contract account state is accessed after an external call to a user defined address. To prevent reentrancy issues, consider accessing the state only before the call, especially if the callee is untrusted. Alternatively, a reentrancy lock can be used to prevent untrusted callees from re-entering the contract in an intermediate state.\nClassification: SWC-107"
        },
        {
          "name": "State access after external call (SWC 107)",
          "vulnerability_from_line": 514,
          "vulnerability_to_line": null,
          "vulnerability_code": "        msg.sender.transfer(address(this).balance);\n",
          "message": "Write to persistent state following external call\nThe contract account state is accessed after an external call to a user defined address. To prevent reentrancy issues, consider accessing the state only before the call, especially if the callee is untrusted. Alternatively, a reentrancy lock can be used to prevent untrusted callees from re-entering the contract in an intermediate state.\nClassification: SWC-107"
        }
      ]
    },
    "osiris": {
      "successfull_analysis": false,
      "errors": [
        "Solidity compilation failed"
      ],
      "vulnerability_findings": []
    }
  }
}