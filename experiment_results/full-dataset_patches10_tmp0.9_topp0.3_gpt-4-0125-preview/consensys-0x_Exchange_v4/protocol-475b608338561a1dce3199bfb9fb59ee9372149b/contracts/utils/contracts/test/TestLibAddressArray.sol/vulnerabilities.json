{
  "smartbugs_completed": true,
  "analyzer_results": {
    "semgrep": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "use-abi-encodecall-instead-of-encodewithselector",
          "vulnerability_from_line": 39,
          "vulnerability_to_line": null,
          "vulnerability_code": "        return abi.encodeWithSelector(\n",
          "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
        },
        {
          "name": "use-abi-encodecall-instead-of-encodewithselector",
          "vulnerability_from_line": 40,
          "vulnerability_to_line": null,
          "vulnerability_code": "            MISMANAGED_MEMORY_ERROR_SELECTOR,\n",
          "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
        },
        {
          "name": "use-abi-encodecall-instead-of-encodewithselector",
          "vulnerability_from_line": 41,
          "vulnerability_to_line": null,
          "vulnerability_code": "            freeMemPtr,\n",
          "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
        },
        {
          "name": "use-abi-encodecall-instead-of-encodewithselector",
          "vulnerability_from_line": 42,
          "vulnerability_to_line": null,
          "vulnerability_code": "            addressArrayEndPtr\n",
          "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
        },
        {
          "name": "use-abi-encodecall-instead-of-encodewithselector",
          "vulnerability_from_line": 43,
          "vulnerability_to_line": null,
          "vulnerability_code": "        );\n",
          "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
        },
        {
          "name": "use-abi-encodecall-instead-of-encodewithselector",
          "vulnerability_from_line": 97,
          "vulnerability_to_line": null,
          "vulnerability_code": "        return abi.encodeWithSelector(\n",
          "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
        },
        {
          "name": "use-abi-encodecall-instead-of-encodewithselector",
          "vulnerability_from_line": 98,
          "vulnerability_to_line": null,
          "vulnerability_code": "            INVALID_BYTE_OPERATION_ERROR_SELECTOR,\n",
          "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
        },
        {
          "name": "use-abi-encodecall-instead-of-encodewithselector",
          "vulnerability_from_line": 99,
          "vulnerability_to_line": null,
          "vulnerability_code": "            errorCode,\n",
          "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
        },
        {
          "name": "use-abi-encodecall-instead-of-encodewithselector",
          "vulnerability_from_line": 100,
          "vulnerability_to_line": null,
          "vulnerability_code": "            offset,\n",
          "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
        },
        {
          "name": "use-abi-encodecall-instead-of-encodewithselector",
          "vulnerability_from_line": 101,
          "vulnerability_to_line": null,
          "vulnerability_code": "            required\n",
          "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
        },
        {
          "name": "use-abi-encodecall-instead-of-encodewithselector",
          "vulnerability_from_line": 102,
          "vulnerability_to_line": null,
          "vulnerability_code": "        );\n",
          "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
        },
        {
          "name": "use-abi-encodecall-instead-of-encodewithselector",
          "vulnerability_from_line": 148,
          "vulnerability_to_line": null,
          "vulnerability_code": "        return abi.encodeWithSelector(\n",
          "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
        },
        {
          "name": "use-abi-encodecall-instead-of-encodewithselector",
          "vulnerability_from_line": 149,
          "vulnerability_to_line": null,
          "vulnerability_code": "            STANDARD_ERROR_SELECTOR,\n",
          "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
        },
        {
          "name": "use-abi-encodecall-instead-of-encodewithselector",
          "vulnerability_from_line": 150,
          "vulnerability_to_line": null,
          "vulnerability_code": "            bytes(message)\n",
          "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
        },
        {
          "name": "use-abi-encodecall-instead-of-encodewithselector",
          "vulnerability_from_line": 151,
          "vulnerability_to_line": null,
          "vulnerability_code": "        );\n",
          "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
        }
      ]
    },
    "slither": {
      "successfull_analysis": true,
      "errors": [
        "EXIT_CODE_41"
      ],
      "vulnerability_findings": [
        {
          "name": "constant-function",
          "vulnerability_from_line": 157,
          "vulnerability_to_line": 164,
          "vulnerability_code": "    function rrevert(bytes memory errorData)\n\n        internal\n\n        pure\n\n    {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
          "message": "LibRichErrors.rrevert (TestLibAddressArray.sol#157-164) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 199,
          "vulnerability_to_line": 208,
          "vulnerability_code": "    function rawAddress(bytes memory input)\n\n        internal\n\n        pure\n\n        returns (uint256 memoryAddress)\n\n    {\n\n        assembly {\n\n            memoryAddress := input\n\n        }\n\n        return memoryAddress;\n",
          "message": "LibBytes.rawAddress (TestLibAddressArray.sol#199-208) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 213,
          "vulnerability_to_line": 222,
          "vulnerability_code": "    function contentAddress(bytes memory input)\n\n        internal\n\n        pure\n\n        returns (uint256 memoryAddress)\n\n    {\n\n        assembly {\n\n            memoryAddress := add(input, 32)\n\n        }\n\n        return memoryAddress;\n",
          "message": "LibBytes.contentAddress (TestLibAddressArray.sol#213-222) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 228,
          "vulnerability_to_line": 329,
          "vulnerability_code": "    function memCopy(\n\n        uint256 dest,\n\n        uint256 source,\n\n        uint256 length\n\n    )\n\n        internal\n\n        pure\n\n    {\n\n        if (length < 32) {\n\n            // Handle a partial word by reading destination and masking\n\n            // off the bits we are interested in.\n\n            // This correctly handles overlap, zero lengths and source == dest\n\n            assembly {\n\n                let mask := sub(exp(256, sub(32, length)), 1)\n\n                let s := and(mload(source), not(mask))\n\n                let d := and(mload(dest), mask)\n\n                mstore(dest, or(s, d))\n\n            }\n\n        } else {\n\n            // Skip the O(length) loop when source == dest.\n\n            if (source == dest) {\n\n                return;\n\n            }\n\n\n\n            // For large copies we copy whole words at a time. The final\n\n            // word is aligned to the end of the range (instead of after the\n\n            // previous) to handle partial words. So a copy will look like this:\n\n            //\n\n            //  ####\n\n            //      ####\n\n            //          ####\n\n            //            ####\n\n            //\n\n            // We handle overlap in the source and destination range by\n\n            // changing the copying direction. This prevents us from\n\n            // overwriting parts of source that we still need to copy.\n\n            //\n\n            // This correctly handles source == dest\n\n            //\n\n            if (source > dest) {\n\n                assembly {\n\n                    // We subtract 32 from `sEnd` and `dEnd` because it\n\n                    // is easier to compare with in the loop, and these\n\n                    // are also the addresses we need for copying the\n\n                    // last bytes.\n\n                    length := sub(length, 32)\n\n                    let sEnd := add(source, length)\n\n                    let dEnd := add(dest, length)\n\n\n\n                    // Remember the last 32 bytes of source\n\n                    // This needs to be done here and not after the loop\n\n                    // because we may have overwritten the last bytes in\n\n                    // source already due to overlap.\n\n                    let last := mload(sEnd)\n\n\n\n                    // Copy whole words front to back\n\n                    // Note: the first check is always true,\n\n                    // this could have been a do-while loop.\n\n                    // solhint-disable-next-line no-empty-blocks\n\n                    for {} lt(source, sEnd) {} {\n\n                        mstore(dest, mload(source))\n\n                        source := add(source, 32)\n\n                        dest := add(dest, 32)\n\n                    }\n\n\n\n                    // Write the last 32 bytes\n\n                    mstore(dEnd, last)\n\n                }\n\n            } else {\n\n                assembly {\n\n                    // We subtract 32 from `sEnd` and `dEnd` because those\n\n                    // are the starting points when copying a word at the end.\n\n                    length := sub(length, 32)\n\n                    let sEnd := add(source, length)\n\n                    let dEnd := add(dest, length)\n\n\n\n                    // Remember the first 32 bytes of source\n\n                    // This needs to be done here and not after the loop\n\n                    // because we may have overwritten the first bytes in\n\n                    // source already due to overlap.\n\n                    let first := mload(source)\n\n\n\n                    // Copy whole words back to front\n\n                    // We use a signed comparisson here to allow dEnd to become\n\n                    // negative (happens when source and dest < 32). Valid\n\n                    // addresses in local memory will never be larger than\n\n                    // 2**255, so they can be safely re-interpreted as signed.\n\n                    // Note: the first check is always true,\n\n                    // this could have been a do-while loop.\n\n                    // solhint-disable-next-line no-empty-blocks\n\n                    for {} slt(dest, dEnd) {} {\n\n                        mstore(dEnd, mload(sEnd))\n\n                        sEnd := sub(sEnd, 32)\n\n                        dEnd := sub(dEnd, 32)\n\n                    }\n\n\n\n                    // Write the first 32 bytes\n\n                    mstore(dest, first)\n\n                }\n\n            }\n\n        }\n",
          "message": "LibBytes.memCopy (TestLibAddressArray.sol#228-329) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 378,
          "vulnerability_to_line": 410,
          "vulnerability_code": "    function sliceDestructive(\n\n        bytes memory b,\n\n        uint256 from,\n\n        uint256 to\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory result)\n\n    {\n\n        // Ensure that the from and to positions are valid positions for a slice within\n\n        // the byte array that is being used.\n\n        if (from > to) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.FromLessThanOrEqualsToRequired,\n\n                from,\n\n                to\n\n            ));\n\n        }\n\n        if (to > b.length) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.ToLessThanOrEqualsLengthRequired,\n\n                to,\n\n                b.length\n\n            ));\n\n        }\n\n\n\n        // Create a new bytes structure around [from, to) in-place.\n\n        assembly {\n\n            result := add(b, from)\n\n            mstore(result, sub(to, from))\n\n        }\n\n        return result;\n",
          "message": "LibBytes.sliceDestructive (TestLibAddressArray.sol#378-410) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 415,
          "vulnerability_to_line": 437,
          "vulnerability_code": "    function popLastByte(bytes memory b)\n\n        internal\n\n        pure\n\n        returns (bytes1 result)\n\n    {\n\n        if (b.length == 0) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanZeroRequired,\n\n                b.length,\n\n                0\n\n            ));\n\n        }\n\n\n\n        // Store last byte.\n\n        result = b[b.length - 1];\n\n\n\n        assembly {\n\n            // Decrement length of byte array.\n\n            let newLen := sub(mload(b), 1)\n\n            mstore(b, newLen)\n\n        }\n\n        return result;\n",
          "message": "LibBytes.popLastByte (TestLibAddressArray.sol#415-437) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 461,
          "vulnerability_to_line": 490,
          "vulnerability_code": "    function readAddress(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (address result)\n\n    {\n\n        if (b.length < index + 20) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsTwentyRequired,\n\n                b.length,\n\n                index + 20 // 20 is length of address\n\n            ));\n\n        }\n\n\n\n        // Add offset to index:\n\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\n\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\n\n        index += 20;\n\n\n\n        // Read address from array memory\n\n        assembly {\n\n            // 1. Add index to address of bytes array\n\n            // 2. Load 32-byte word from memory\n\n            // 3. Apply 20-byte mask to obtain address\n\n            result := and(mload(add(b, index)), 0xffffffffffffffffffffffffffffffffffffffff)\n\n        }\n\n        return result;\n",
          "message": "LibBytes.readAddress (TestLibAddressArray.sol#461-490) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 496,
          "vulnerability_to_line": 539,
          "vulnerability_code": "    function writeAddress(\n\n        bytes memory b,\n\n        uint256 index,\n\n        address input\n\n    )\n\n        internal\n\n        pure\n\n    {\n\n        if (b.length < index + 20) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsTwentyRequired,\n\n                b.length,\n\n                index + 20 // 20 is length of address\n\n            ));\n\n        }\n\n\n\n        // Add offset to index:\n\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\n\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\n\n        index += 20;\n\n\n\n        // Store address into array memory\n\n        assembly {\n\n            // The address occupies 20 bytes and mstore stores 32 bytes.\n\n            // First fetch the 32-byte word where we'll be storing the address, then\n\n            // apply a mask so we have only the bytes in the word that the address will not occupy.\n\n            // Then combine these bytes with the address and store the 32 bytes back to memory with mstore.\n\n\n\n            // 1. Add index to address of bytes array\n\n            // 2. Load 32-byte word from memory\n\n            // 3. Apply 12-byte mask to obtain extra bytes occupying word of memory where we'll store the address\n\n            let neighbors := and(\n\n                mload(add(b, index)),\n\n                0xffffffffffffffffffffffff0000000000000000000000000000000000000000\n\n            )\n\n\n\n            // Make sure input address is clean.\n\n            // (Solidity does not guarantee this)\n\n            input := and(input, 0xffffffffffffffffffffffffffffffffffffffff)\n\n\n\n            // Store the neighbors and address into memory\n\n            mstore(add(b, index), xor(input, neighbors))\n\n        }\n",
          "message": "LibBytes.writeAddress (TestLibAddressArray.sol#496-539) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 545,
          "vulnerability_to_line": 569,
          "vulnerability_code": "    function readBytes32(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes32 result)\n\n    {\n\n        if (b.length < index + 32) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsThirtyTwoRequired,\n\n                b.length,\n\n                index + 32\n\n            ));\n\n        }\n\n\n\n        // Arrays are prefixed by a 256 bit length parameter\n\n        index += 32;\n\n\n\n        // Read the bytes32 from array memory\n\n        assembly {\n\n            result := mload(add(b, index))\n\n        }\n\n        return result;\n",
          "message": "LibBytes.readBytes32 (TestLibAddressArray.sol#545-569) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 575,
          "vulnerability_to_line": 598,
          "vulnerability_code": "    function writeBytes32(\n\n        bytes memory b,\n\n        uint256 index,\n\n        bytes32 input\n\n    )\n\n        internal\n\n        pure\n\n    {\n\n        if (b.length < index + 32) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsThirtyTwoRequired,\n\n                b.length,\n\n                index + 32\n\n            ));\n\n        }\n\n\n\n        // Arrays are prefixed by a 256 bit length parameter\n\n        index += 32;\n\n\n\n        // Read the bytes32 from array memory\n\n        assembly {\n\n            mstore(add(b, index), input)\n\n        }\n",
          "message": "LibBytes.writeBytes32 (TestLibAddressArray.sol#575-598) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 635,
          "vulnerability_to_line": 662,
          "vulnerability_code": "    function readBytes4(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes4 result)\n\n    {\n\n        if (b.length < index + 4) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsFourRequired,\n\n                b.length,\n\n                index + 4\n\n            ));\n\n        }\n\n\n\n        // Arrays are prefixed by a 32 byte length field\n\n        index += 32;\n\n\n\n        // Read the bytes4 from array memory\n\n        assembly {\n\n            result := mload(add(b, index))\n\n            // Solidity does not require us to clean the trailing bytes.\n\n            // We do it anyway\n\n            result := and(result, 0xFFFFFFFF00000000000000000000000000000000000000000000000000000000)\n\n        }\n\n        return result;\n",
          "message": "LibBytes.readBytes4 (TestLibAddressArray.sol#635-662) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 669,
          "vulnerability_to_line": 676,
          "vulnerability_code": "    function writeLength(bytes memory b, uint256 length)\n\n        internal\n\n        pure\n\n    {\n\n        assembly {\n\n            mstore(b, length)\n\n        }\n",
          "message": "LibBytes.writeLength (TestLibAddressArray.sol#669-676) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 712,
          "vulnerability_to_line": 766,
          "vulnerability_code": "    function append(address[] memory addressArray, address addressToAppend)\n\n        internal\n\n        pure\n\n        returns (address[] memory)\n\n    {\n\n        // Get stats on address array and free memory\n\n        uint256 freeMemPtr = 0;\n\n        uint256 addressArrayBeginPtr = 0;\n\n        uint256 addressArrayEndPtr = 0;\n\n        uint256 addressArrayLength = addressArray.length;\n\n        uint256 addressArrayMemSizeInBytes = 32 + (32 * addressArrayLength);\n\n        assembly {\n\n            freeMemPtr := mload(0x40)\n\n            addressArrayBeginPtr := addressArray\n\n            addressArrayEndPtr := add(addressArray, addressArrayMemSizeInBytes)\n\n        }\n\n\n\n        // Cases for `freeMemPtr`:\n\n        //  `freeMemPtr` == `addressArrayEndPtr`: Nothing occupies memory after `addressArray`\n\n        //  `freeMemPtr` > `addressArrayEndPtr`: Some value occupies memory after `addressArray`\n\n        //  `freeMemPtr` < `addressArrayEndPtr`: Memory has not been managed properly.\n\n        if (freeMemPtr < addressArrayEndPtr) {\n\n            LibRichErrors.rrevert(LibAddressArrayRichErrors.MismanagedMemoryError(\n\n                freeMemPtr,\n\n                addressArrayEndPtr\n\n            ));\n\n        }\n\n\n\n        // If free memory begins at the end of `addressArray`\n\n        // then we can append `addressToAppend` directly.\n\n        // Otherwise, we must copy the array to free memory\n\n        // before appending new values to it.\n\n        if (freeMemPtr > addressArrayEndPtr) {\n\n            LibBytes.memCopy(freeMemPtr, addressArrayBeginPtr, addressArrayMemSizeInBytes);\n\n            assembly {\n\n                addressArray := freeMemPtr\n\n                addressArrayBeginPtr := addressArray\n\n            }\n\n        }\n\n\n\n        // Append `addressToAppend`\n\n        addressArrayLength += 1;\n\n        addressArrayMemSizeInBytes += 32;\n\n        addressArrayEndPtr = addressArrayBeginPtr + addressArrayMemSizeInBytes;\n\n        freeMemPtr = addressArrayEndPtr;\n\n        assembly {\n\n            // Store new array length\n\n            mstore(addressArray, addressArrayLength)\n\n\n\n            // Update `freeMemPtr`\n\n            mstore(0x40, freeMemPtr)\n\n        }\n\n        addressArray[addressArrayLength - 1] = addressToAppend;\n\n        return addressArray;\n",
          "message": "LibAddressArray.append (TestLibAddressArray.sol#712-766) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 772,
          "vulnerability_to_line": 802,
          "vulnerability_code": "    function contains(address[] memory addressArray, address target)\n\n        internal\n\n        pure\n\n        returns (bool success)\n\n    {\n\n        assembly {\n\n\n\n            // Calculate byte length of array\n\n            let arrayByteLen := mul(mload(addressArray), 32)\n\n            // Calculate beginning of array contents\n\n            let arrayContentsStart := add(addressArray, 32)\n\n            // Calclulate end of array contents\n\n            let arrayContentsEnd := add(arrayContentsStart, arrayByteLen)\n\n\n\n            // Loop through array\n\n            for {let i:= arrayContentsStart} lt(i, arrayContentsEnd) {i := add(i, 32)} {\n\n\n\n                // Load array element\n\n                let arrayElement := mload(i)\n\n\n\n                // Return true if array element equals target\n\n                if eq(target, arrayElement) {\n\n                    // Set success to true\n\n                    success := 1\n\n                    // Break loop\n\n                    i := arrayContentsEnd\n\n                }\n\n            }\n\n        }\n\n        return success;\n",
          "message": "LibAddressArray.contains (TestLibAddressArray.sol#772-802) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 808,
          "vulnerability_to_line": 839,
          "vulnerability_code": "    function indexOf(address[] memory addressArray, address target)\n\n        internal\n\n        pure\n\n        returns (bool success, uint256 index)\n\n    {\n\n        assembly {\n\n\n\n            // Calculate byte length of array\n\n            let arrayByteLen := mul(mload(addressArray), 32)\n\n            // Calculate beginning of array contents\n\n            let arrayContentsStart := add(addressArray, 32)\n\n            // Calclulate end of array contents\n\n            let arrayContentsEnd := add(arrayContentsStart, arrayByteLen)\n\n\n\n            // Loop through array\n\n            for {let i:= arrayContentsStart} lt(i, arrayContentsEnd) {i := add(i, 32)} {\n\n\n\n                // Load array element\n\n                let arrayElement := mload(i)\n\n\n\n                // Return true if array element equals target\n\n                if eq(target, arrayElement) {\n\n                    // Set success and index\n\n                    success := 1\n\n                    index := div(sub(i, arrayContentsStart), 32)\n\n                    // Break loop\n\n                    i := arrayContentsEnd\n\n                }\n\n            }\n\n        }\n\n        return (success, index);\n",
          "message": "LibAddressArray.indexOf (TestLibAddressArray.sol#808-839) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 893,
          "vulnerability_to_line": 920,
          "vulnerability_code": "    function testAppendRealloc(\n\n        address[] memory addressArray,\n\n        int256 freeMemOffset,\n\n        address addressToAppend\n\n    )\n\n        public\n\n        pure\n\n        returns (\n\n            address[] memory result,\n\n            uint256 oldArrayMemStart,\n\n            uint256 newArrayMemStart\n\n        )\n\n    {\n\n        assembly {\n\n            // Remember the original memory address of the array.\n\n            oldArrayMemStart := addressArray\n\n            // Move the free memory pointer.\n\n            mstore(0x40, add(mload(0x40), freeMemOffset))\n\n        }\n\n\n\n        // Call append.\n\n        result = addressArray.append(addressToAppend);\n\n\n\n        // Get the new array memory address.\n\n        assembly {\n\n            newArrayMemStart := result\n\n        }\n",
          "message": "TestLibAddressArray.testAppendRealloc (TestLibAddressArray.sol#893-920) is declared view but contains assembly code\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 157,
          "vulnerability_to_line": 164,
          "vulnerability_code": "    function rrevert(bytes memory errorData)\n\n        internal\n\n        pure\n\n    {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
          "message": "LibRichErrors.rrevert uses assembly (TestLibAddressArray.sol#157-164)\n\t- TestLibAddressArray.sol#161-163\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 199,
          "vulnerability_to_line": 208,
          "vulnerability_code": "    function rawAddress(bytes memory input)\n\n        internal\n\n        pure\n\n        returns (uint256 memoryAddress)\n\n    {\n\n        assembly {\n\n            memoryAddress := input\n\n        }\n\n        return memoryAddress;\n",
          "message": "LibBytes.rawAddress uses assembly (TestLibAddressArray.sol#199-208)\n\t- TestLibAddressArray.sol#204-206\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 213,
          "vulnerability_to_line": 222,
          "vulnerability_code": "    function contentAddress(bytes memory input)\n\n        internal\n\n        pure\n\n        returns (uint256 memoryAddress)\n\n    {\n\n        assembly {\n\n            memoryAddress := add(input, 32)\n\n        }\n\n        return memoryAddress;\n",
          "message": "LibBytes.contentAddress uses assembly (TestLibAddressArray.sol#213-222)\n\t- TestLibAddressArray.sol#218-220\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 228,
          "vulnerability_to_line": 329,
          "vulnerability_code": "    function memCopy(\n\n        uint256 dest,\n\n        uint256 source,\n\n        uint256 length\n\n    )\n\n        internal\n\n        pure\n\n    {\n\n        if (length < 32) {\n\n            // Handle a partial word by reading destination and masking\n\n            // off the bits we are interested in.\n\n            // This correctly handles overlap, zero lengths and source == dest\n\n            assembly {\n\n                let mask := sub(exp(256, sub(32, length)), 1)\n\n                let s := and(mload(source), not(mask))\n\n                let d := and(mload(dest), mask)\n\n                mstore(dest, or(s, d))\n\n            }\n\n        } else {\n\n            // Skip the O(length) loop when source == dest.\n\n            if (source == dest) {\n\n                return;\n\n            }\n\n\n\n            // For large copies we copy whole words at a time. The final\n\n            // word is aligned to the end of the range (instead of after the\n\n            // previous) to handle partial words. So a copy will look like this:\n\n            //\n\n            //  ####\n\n            //      ####\n\n            //          ####\n\n            //            ####\n\n            //\n\n            // We handle overlap in the source and destination range by\n\n            // changing the copying direction. This prevents us from\n\n            // overwriting parts of source that we still need to copy.\n\n            //\n\n            // This correctly handles source == dest\n\n            //\n\n            if (source > dest) {\n\n                assembly {\n\n                    // We subtract 32 from `sEnd` and `dEnd` because it\n\n                    // is easier to compare with in the loop, and these\n\n                    // are also the addresses we need for copying the\n\n                    // last bytes.\n\n                    length := sub(length, 32)\n\n                    let sEnd := add(source, length)\n\n                    let dEnd := add(dest, length)\n\n\n\n                    // Remember the last 32 bytes of source\n\n                    // This needs to be done here and not after the loop\n\n                    // because we may have overwritten the last bytes in\n\n                    // source already due to overlap.\n\n                    let last := mload(sEnd)\n\n\n\n                    // Copy whole words front to back\n\n                    // Note: the first check is always true,\n\n                    // this could have been a do-while loop.\n\n                    // solhint-disable-next-line no-empty-blocks\n\n                    for {} lt(source, sEnd) {} {\n\n                        mstore(dest, mload(source))\n\n                        source := add(source, 32)\n\n                        dest := add(dest, 32)\n\n                    }\n\n\n\n                    // Write the last 32 bytes\n\n                    mstore(dEnd, last)\n\n                }\n\n            } else {\n\n                assembly {\n\n                    // We subtract 32 from `sEnd` and `dEnd` because those\n\n                    // are the starting points when copying a word at the end.\n\n                    length := sub(length, 32)\n\n                    let sEnd := add(source, length)\n\n                    let dEnd := add(dest, length)\n\n\n\n                    // Remember the first 32 bytes of source\n\n                    // This needs to be done here and not after the loop\n\n                    // because we may have overwritten the first bytes in\n\n                    // source already due to overlap.\n\n                    let first := mload(source)\n\n\n\n                    // Copy whole words back to front\n\n                    // We use a signed comparisson here to allow dEnd to become\n\n                    // negative (happens when source and dest < 32). Valid\n\n                    // addresses in local memory will never be larger than\n\n                    // 2**255, so they can be safely re-interpreted as signed.\n\n                    // Note: the first check is always true,\n\n                    // this could have been a do-while loop.\n\n                    // solhint-disable-next-line no-empty-blocks\n\n                    for {} slt(dest, dEnd) {} {\n\n                        mstore(dEnd, mload(sEnd))\n\n                        sEnd := sub(sEnd, 32)\n\n                        dEnd := sub(dEnd, 32)\n\n                    }\n\n\n\n                    // Write the first 32 bytes\n\n                    mstore(dest, first)\n\n                }\n\n            }\n\n        }\n",
          "message": "LibBytes.memCopy uses assembly (TestLibAddressArray.sol#228-329)\n\t- TestLibAddressArray.sol#240-245\n\t- TestLibAddressArray.sol#268-295\n\t- TestLibAddressArray.sol#297-326\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 378,
          "vulnerability_to_line": 410,
          "vulnerability_code": "    function sliceDestructive(\n\n        bytes memory b,\n\n        uint256 from,\n\n        uint256 to\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory result)\n\n    {\n\n        // Ensure that the from and to positions are valid positions for a slice within\n\n        // the byte array that is being used.\n\n        if (from > to) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.FromLessThanOrEqualsToRequired,\n\n                from,\n\n                to\n\n            ));\n\n        }\n\n        if (to > b.length) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.ToLessThanOrEqualsLengthRequired,\n\n                to,\n\n                b.length\n\n            ));\n\n        }\n\n\n\n        // Create a new bytes structure around [from, to) in-place.\n\n        assembly {\n\n            result := add(b, from)\n\n            mstore(result, sub(to, from))\n\n        }\n\n        return result;\n",
          "message": "LibBytes.sliceDestructive uses assembly (TestLibAddressArray.sol#378-410)\n\t- TestLibAddressArray.sol#405-408\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 415,
          "vulnerability_to_line": 437,
          "vulnerability_code": "    function popLastByte(bytes memory b)\n\n        internal\n\n        pure\n\n        returns (bytes1 result)\n\n    {\n\n        if (b.length == 0) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanZeroRequired,\n\n                b.length,\n\n                0\n\n            ));\n\n        }\n\n\n\n        // Store last byte.\n\n        result = b[b.length - 1];\n\n\n\n        assembly {\n\n            // Decrement length of byte array.\n\n            let newLen := sub(mload(b), 1)\n\n            mstore(b, newLen)\n\n        }\n\n        return result;\n",
          "message": "LibBytes.popLastByte uses assembly (TestLibAddressArray.sol#415-437)\n\t- TestLibAddressArray.sol#431-435\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 461,
          "vulnerability_to_line": 490,
          "vulnerability_code": "    function readAddress(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (address result)\n\n    {\n\n        if (b.length < index + 20) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsTwentyRequired,\n\n                b.length,\n\n                index + 20 // 20 is length of address\n\n            ));\n\n        }\n\n\n\n        // Add offset to index:\n\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\n\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\n\n        index += 20;\n\n\n\n        // Read address from array memory\n\n        assembly {\n\n            // 1. Add index to address of bytes array\n\n            // 2. Load 32-byte word from memory\n\n            // 3. Apply 20-byte mask to obtain address\n\n            result := and(mload(add(b, index)), 0xffffffffffffffffffffffffffffffffffffffff)\n\n        }\n\n        return result;\n",
          "message": "LibBytes.readAddress uses assembly (TestLibAddressArray.sol#461-490)\n\t- TestLibAddressArray.sol#483-488\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 496,
          "vulnerability_to_line": 539,
          "vulnerability_code": "    function writeAddress(\n\n        bytes memory b,\n\n        uint256 index,\n\n        address input\n\n    )\n\n        internal\n\n        pure\n\n    {\n\n        if (b.length < index + 20) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsTwentyRequired,\n\n                b.length,\n\n                index + 20 // 20 is length of address\n\n            ));\n\n        }\n\n\n\n        // Add offset to index:\n\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\n\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\n\n        index += 20;\n\n\n\n        // Store address into array memory\n\n        assembly {\n\n            // The address occupies 20 bytes and mstore stores 32 bytes.\n\n            // First fetch the 32-byte word where we'll be storing the address, then\n\n            // apply a mask so we have only the bytes in the word that the address will not occupy.\n\n            // Then combine these bytes with the address and store the 32 bytes back to memory with mstore.\n\n\n\n            // 1. Add index to address of bytes array\n\n            // 2. Load 32-byte word from memory\n\n            // 3. Apply 12-byte mask to obtain extra bytes occupying word of memory where we'll store the address\n\n            let neighbors := and(\n\n                mload(add(b, index)),\n\n                0xffffffffffffffffffffffff0000000000000000000000000000000000000000\n\n            )\n\n\n\n            // Make sure input address is clean.\n\n            // (Solidity does not guarantee this)\n\n            input := and(input, 0xffffffffffffffffffffffffffffffffffffffff)\n\n\n\n            // Store the neighbors and address into memory\n\n            mstore(add(b, index), xor(input, neighbors))\n\n        }\n",
          "message": "LibBytes.writeAddress uses assembly (TestLibAddressArray.sol#496-539)\n\t- TestLibAddressArray.sol#518-538\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 545,
          "vulnerability_to_line": 569,
          "vulnerability_code": "    function readBytes32(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes32 result)\n\n    {\n\n        if (b.length < index + 32) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsThirtyTwoRequired,\n\n                b.length,\n\n                index + 32\n\n            ));\n\n        }\n\n\n\n        // Arrays are prefixed by a 256 bit length parameter\n\n        index += 32;\n\n\n\n        // Read the bytes32 from array memory\n\n        assembly {\n\n            result := mload(add(b, index))\n\n        }\n\n        return result;\n",
          "message": "LibBytes.readBytes32 uses assembly (TestLibAddressArray.sol#545-569)\n\t- TestLibAddressArray.sol#565-567\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 575,
          "vulnerability_to_line": 598,
          "vulnerability_code": "    function writeBytes32(\n\n        bytes memory b,\n\n        uint256 index,\n\n        bytes32 input\n\n    )\n\n        internal\n\n        pure\n\n    {\n\n        if (b.length < index + 32) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsThirtyTwoRequired,\n\n                b.length,\n\n                index + 32\n\n            ));\n\n        }\n\n\n\n        // Arrays are prefixed by a 256 bit length parameter\n\n        index += 32;\n\n\n\n        // Read the bytes32 from array memory\n\n        assembly {\n\n            mstore(add(b, index), input)\n\n        }\n",
          "message": "LibBytes.writeBytes32 uses assembly (TestLibAddressArray.sol#575-598)\n\t- TestLibAddressArray.sol#595-597\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 635,
          "vulnerability_to_line": 662,
          "vulnerability_code": "    function readBytes4(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes4 result)\n\n    {\n\n        if (b.length < index + 4) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsFourRequired,\n\n                b.length,\n\n                index + 4\n\n            ));\n\n        }\n\n\n\n        // Arrays are prefixed by a 32 byte length field\n\n        index += 32;\n\n\n\n        // Read the bytes4 from array memory\n\n        assembly {\n\n            result := mload(add(b, index))\n\n            // Solidity does not require us to clean the trailing bytes.\n\n            // We do it anyway\n\n            result := and(result, 0xFFFFFFFF00000000000000000000000000000000000000000000000000000000)\n\n        }\n\n        return result;\n",
          "message": "LibBytes.readBytes4 uses assembly (TestLibAddressArray.sol#635-662)\n\t- TestLibAddressArray.sol#655-660\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 669,
          "vulnerability_to_line": 676,
          "vulnerability_code": "    function writeLength(bytes memory b, uint256 length)\n\n        internal\n\n        pure\n\n    {\n\n        assembly {\n\n            mstore(b, length)\n\n        }\n",
          "message": "LibBytes.writeLength uses assembly (TestLibAddressArray.sol#669-676)\n\t- TestLibAddressArray.sol#673-675\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 712,
          "vulnerability_to_line": 766,
          "vulnerability_code": "    function append(address[] memory addressArray, address addressToAppend)\n\n        internal\n\n        pure\n\n        returns (address[] memory)\n\n    {\n\n        // Get stats on address array and free memory\n\n        uint256 freeMemPtr = 0;\n\n        uint256 addressArrayBeginPtr = 0;\n\n        uint256 addressArrayEndPtr = 0;\n\n        uint256 addressArrayLength = addressArray.length;\n\n        uint256 addressArrayMemSizeInBytes = 32 + (32 * addressArrayLength);\n\n        assembly {\n\n            freeMemPtr := mload(0x40)\n\n            addressArrayBeginPtr := addressArray\n\n            addressArrayEndPtr := add(addressArray, addressArrayMemSizeInBytes)\n\n        }\n\n\n\n        // Cases for `freeMemPtr`:\n\n        //  `freeMemPtr` == `addressArrayEndPtr`: Nothing occupies memory after `addressArray`\n\n        //  `freeMemPtr` > `addressArrayEndPtr`: Some value occupies memory after `addressArray`\n\n        //  `freeMemPtr` < `addressArrayEndPtr`: Memory has not been managed properly.\n\n        if (freeMemPtr < addressArrayEndPtr) {\n\n            LibRichErrors.rrevert(LibAddressArrayRichErrors.MismanagedMemoryError(\n\n                freeMemPtr,\n\n                addressArrayEndPtr\n\n            ));\n\n        }\n\n\n\n        // If free memory begins at the end of `addressArray`\n\n        // then we can append `addressToAppend` directly.\n\n        // Otherwise, we must copy the array to free memory\n\n        // before appending new values to it.\n\n        if (freeMemPtr > addressArrayEndPtr) {\n\n            LibBytes.memCopy(freeMemPtr, addressArrayBeginPtr, addressArrayMemSizeInBytes);\n\n            assembly {\n\n                addressArray := freeMemPtr\n\n                addressArrayBeginPtr := addressArray\n\n            }\n\n        }\n\n\n\n        // Append `addressToAppend`\n\n        addressArrayLength += 1;\n\n        addressArrayMemSizeInBytes += 32;\n\n        addressArrayEndPtr = addressArrayBeginPtr + addressArrayMemSizeInBytes;\n\n        freeMemPtr = addressArrayEndPtr;\n\n        assembly {\n\n            // Store new array length\n\n            mstore(addressArray, addressArrayLength)\n\n\n\n            // Update `freeMemPtr`\n\n            mstore(0x40, freeMemPtr)\n\n        }\n\n        addressArray[addressArrayLength - 1] = addressToAppend;\n\n        return addressArray;\n",
          "message": "LibAddressArray.append uses assembly (TestLibAddressArray.sol#712-766)\n\t- TestLibAddressArray.sol#723-727\n\t- TestLibAddressArray.sol#746-749\n\t- TestLibAddressArray.sol#757-763\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 772,
          "vulnerability_to_line": 802,
          "vulnerability_code": "    function contains(address[] memory addressArray, address target)\n\n        internal\n\n        pure\n\n        returns (bool success)\n\n    {\n\n        assembly {\n\n\n\n            // Calculate byte length of array\n\n            let arrayByteLen := mul(mload(addressArray), 32)\n\n            // Calculate beginning of array contents\n\n            let arrayContentsStart := add(addressArray, 32)\n\n            // Calclulate end of array contents\n\n            let arrayContentsEnd := add(arrayContentsStart, arrayByteLen)\n\n\n\n            // Loop through array\n\n            for {let i:= arrayContentsStart} lt(i, arrayContentsEnd) {i := add(i, 32)} {\n\n\n\n                // Load array element\n\n                let arrayElement := mload(i)\n\n\n\n                // Return true if array element equals target\n\n                if eq(target, arrayElement) {\n\n                    // Set success to true\n\n                    success := 1\n\n                    // Break loop\n\n                    i := arrayContentsEnd\n\n                }\n\n            }\n\n        }\n\n        return success;\n",
          "message": "LibAddressArray.contains uses assembly (TestLibAddressArray.sol#772-802)\n\t- TestLibAddressArray.sol#777-800\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 808,
          "vulnerability_to_line": 839,
          "vulnerability_code": "    function indexOf(address[] memory addressArray, address target)\n\n        internal\n\n        pure\n\n        returns (bool success, uint256 index)\n\n    {\n\n        assembly {\n\n\n\n            // Calculate byte length of array\n\n            let arrayByteLen := mul(mload(addressArray), 32)\n\n            // Calculate beginning of array contents\n\n            let arrayContentsStart := add(addressArray, 32)\n\n            // Calclulate end of array contents\n\n            let arrayContentsEnd := add(arrayContentsStart, arrayByteLen)\n\n\n\n            // Loop through array\n\n            for {let i:= arrayContentsStart} lt(i, arrayContentsEnd) {i := add(i, 32)} {\n\n\n\n                // Load array element\n\n                let arrayElement := mload(i)\n\n\n\n                // Return true if array element equals target\n\n                if eq(target, arrayElement) {\n\n                    // Set success and index\n\n                    success := 1\n\n                    index := div(sub(i, arrayContentsStart), 32)\n\n                    // Break loop\n\n                    i := arrayContentsEnd\n\n                }\n\n            }\n\n        }\n\n        return (success, index);\n",
          "message": "LibAddressArray.indexOf uses assembly (TestLibAddressArray.sol#808-839)\n\t- TestLibAddressArray.sol#813-837\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 893,
          "vulnerability_to_line": 920,
          "vulnerability_code": "    function testAppendRealloc(\n\n        address[] memory addressArray,\n\n        int256 freeMemOffset,\n\n        address addressToAppend\n\n    )\n\n        public\n\n        pure\n\n        returns (\n\n            address[] memory result,\n\n            uint256 oldArrayMemStart,\n\n            uint256 newArrayMemStart\n\n        )\n\n    {\n\n        assembly {\n\n            // Remember the original memory address of the array.\n\n            oldArrayMemStart := addressArray\n\n            // Move the free memory pointer.\n\n            mstore(0x40, add(mload(0x40), freeMemOffset))\n\n        }\n\n\n\n        // Call append.\n\n        result = addressArray.append(addressToAppend);\n\n\n\n        // Get the new array memory address.\n\n        assembly {\n\n            newArrayMemStart := result\n\n        }\n",
          "message": "TestLibAddressArray.testAppendRealloc uses assembly (TestLibAddressArray.sol#893-920)\n\t- TestLibAddressArray.sol#906-911\n\t- TestLibAddressArray.sol#917-919\n"
        },
        {
          "name": "pragma",
          "vulnerability_from_line": 21,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.9;\n",
          "message": "Different versions of Solidity is used in TestLibAddressArray.sol:\n\t- Version used: ['^0.5.5', '^0.5.9']\n\t- TestLibAddressArray.sol#21 declares pragma solidity^0.5.9\n\t- TestLibAddressArray.sol#67 declares pragma solidity^0.5.9\n\t- TestLibAddressArray.sol#126 declares pragma solidity^0.5.9\n\t- TestLibAddressArray.sol#187 declares pragma solidity^0.5.9\n\t- TestLibAddressArray.sol#699 declares pragma solidity^0.5.9\n\t- TestLibAddressArray.sol#862 declares pragma solidity^0.5.5\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 875,
          "vulnerability_to_line": 881,
          "vulnerability_code": "    function publicAppend(address[] memory addressArray, address addressToAppend)\n\n        public\n\n        pure\n\n        returns (address[] memory)\n\n    {\n\n        return addressArray.append(addressToAppend);\n",
          "message": "TestLibAddressArray.publicAppend (TestLibAddressArray.sol#875-881) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 893,
          "vulnerability_to_line": 920,
          "vulnerability_code": "    function testAppendRealloc(\n\n        address[] memory addressArray,\n\n        int256 freeMemOffset,\n\n        address addressToAppend\n\n    )\n\n        public\n\n        pure\n\n        returns (\n\n            address[] memory result,\n\n            uint256 oldArrayMemStart,\n\n            uint256 newArrayMemStart\n\n        )\n\n    {\n\n        assembly {\n\n            // Remember the original memory address of the array.\n\n            oldArrayMemStart := addressArray\n\n            // Move the free memory pointer.\n\n            mstore(0x40, add(mload(0x40), freeMemOffset))\n\n        }\n\n\n\n        // Call append.\n\n        result = addressArray.append(addressToAppend);\n\n\n\n        // Get the new array memory address.\n\n        assembly {\n\n            newArrayMemStart := result\n\n        }\n",
          "message": "TestLibAddressArray.testAppendRealloc (TestLibAddressArray.sol#893-920) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 926,
          "vulnerability_to_line": 932,
          "vulnerability_code": "    function publicContains(address[] memory addressArray, address target)\n\n        public\n\n        pure\n\n        returns (bool success)\n\n    {\n\n        return addressArray.contains(target);\n",
          "message": "TestLibAddressArray.publicContains (TestLibAddressArray.sol#926-932) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 938,
          "vulnerability_to_line": 944,
          "vulnerability_code": "    function publicIndexOf(address[] memory addressArray, address target)\n\n        public\n\n        pure\n\n        returns (bool success, uint256 index)\n\n    {\n\n        (success, index) = addressArray.indexOf(target);\n",
          "message": "TestLibAddressArray.publicIndexOf (TestLibAddressArray.sol#938-944) should be declared external\n"
        },
        {
          "name": "solc-version",
          "vulnerability_from_line": 21,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.9;\n",
          "message": "Detected issues with version pragma in TestLibAddressArray.sol:\n\t- pragma solidity^0.5.9 (TestLibAddressArray.sol#21): it allows old versions\n\t- pragma solidity^0.5.9 (TestLibAddressArray.sol#67): it allows old versions\n\t- pragma solidity^0.5.9 (TestLibAddressArray.sol#126): it allows old versions\n\t- pragma solidity^0.5.9 (TestLibAddressArray.sol#187): it allows old versions\n\t- pragma solidity^0.5.9 (TestLibAddressArray.sol#699): it allows old versions\n\t- pragma solidity^0.5.5 (TestLibAddressArray.sol#862): it allows old versions\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 31,
          "vulnerability_to_line": 44,
          "vulnerability_code": "    function MismanagedMemoryError(\n\n        uint256 freeMemPtr,\n\n        uint256 addressArrayEndPtr\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            MISMANAGED_MEMORY_ERROR_SELECTOR,\n\n            freeMemPtr,\n\n            addressArrayEndPtr\n\n        );\n",
          "message": "Function 'LibAddressArrayRichErrors.MismanagedMemoryError' (TestLibAddressArray.sol#31-44) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 88,
          "vulnerability_to_line": 103,
          "vulnerability_code": "    function InvalidByteOperationError(\n\n        InvalidByteOperationErrorCodes errorCode,\n\n        uint256 offset,\n\n        uint256 required\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            INVALID_BYTE_OPERATION_ERROR_SELECTOR,\n\n            errorCode,\n\n            offset,\n\n            required\n\n        );\n",
          "message": "Function 'LibBytesRichErrors.InvalidByteOperationError' (TestLibAddressArray.sol#88-103) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 141,
          "vulnerability_to_line": 152,
          "vulnerability_code": "    function StandardError(\n\n        string memory message\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            STANDARD_ERROR_SELECTOR,\n\n            bytes(message)\n\n        );\n",
          "message": "Function 'LibRichErrors.StandardError' (TestLibAddressArray.sol#141-152) is not in mixedCase\n"
        }
      ]
    },
    "smartcheck": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 28,
          "vulnerability_to_line": null,
          "vulnerability_code": "        0x5fc83722;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 85,
          "vulnerability_to_line": null,
          "vulnerability_code": "        0x28006595;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 133,
          "vulnerability_to_line": null,
          "vulnerability_code": "        0x08c379a0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
          "vulnerability_from_line": 893,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function testAppendRealloc(\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 21,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.9;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 67,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.9;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 126,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.9;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 187,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.9;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 699,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.9;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 862,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.5;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 157,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function rrevert(bytes memory errorData)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 199,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function rawAddress(bytes memory input)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 213,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function contentAddress(bytes memory input)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 228,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function memCopy(\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 378,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function sliceDestructive(\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 415,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function popLastByte(bytes memory b)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 461,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function readAddress(\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 496,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function writeAddress(\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 545,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function readBytes32(\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 575,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function writeBytes32(\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 635,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function readBytes4(\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 669,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function writeLength(bytes memory b, uint256 length)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 712,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function append(address[] memory addressArray, address addressToAppend)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 772,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function contains(address[] memory addressArray, address target)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 808,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function indexOf(address[] memory addressArray, address target)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 893,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function testAppendRealloc(\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 811,
          "vulnerability_to_line": null,
          "vulnerability_code": "        returns (bool success, uint256 index)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 900,
          "vulnerability_to_line": null,
          "vulnerability_code": "        returns (\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 941,
          "vulnerability_to_line": null,
          "vulnerability_code": "        returns (bool success, uint256 index)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 161,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 204,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 218,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 240,
          "vulnerability_to_line": null,
          "vulnerability_code": "            assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 268,
          "vulnerability_to_line": null,
          "vulnerability_code": "                assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 297,
          "vulnerability_to_line": null,
          "vulnerability_code": "                assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 405,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 431,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 483,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 518,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 565,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 595,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 655,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 673,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 723,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 746,
          "vulnerability_to_line": null,
          "vulnerability_code": "            assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 757,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 777,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 813,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 906,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 917,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        }
      ]
    },
    "oyente": {
      "successfull_analysis": false,
      "errors": [
        "exception (IndexError: pop from empty list)"
      ],
      "vulnerability_findings": []
    },
    "mythril": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "Integer Arithmetic Bugs (SWC 101)",
          "vulnerability_from_line": 302,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    let dEnd := add(dest, length)\n",
          "message": "The arithmetic operator can overflow.\nIt is possible to cause an integer overflow or underflow in the arithmetic operation. \nClassification: SWC-101"
        },
        {
          "name": "Integer Arithmetic Bugs (SWC 101)",
          "vulnerability_from_line": 321,
          "vulnerability_to_line": null,
          "vulnerability_code": "                        dEnd := sub(dEnd, 32)\n",
          "message": "The arithmetic operator can underflow.\nIt is possible to cause an integer overflow or underflow in the arithmetic operation. \nClassification: SWC-101"
        }
      ]
    },
    "osiris": {
      "successfull_analysis": false,
      "errors": [
        "Solidity compilation failed"
      ],
      "vulnerability_findings": []
    }
  }
}