{
  "smartbugs_completed": true,
  "analyzer_results": {
    "semgrep": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "use-abi-encodecall-instead-of-encodewithselector",
          "vulnerability_from_line": 241,
          "vulnerability_to_line": null,
          "vulnerability_code": "        return abi.encodeWithSelector(STANDARD_ERROR_SELECTOR, bytes(message));\n",
          "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
        },
        {
          "name": "use-abi-encodecall-instead-of-encodewithselector",
          "vulnerability_from_line": 278,
          "vulnerability_to_line": null,
          "vulnerability_code": "        return abi.encodeWithSelector(UINT256_BINOP_ERROR_SELECTOR, errorCode, a, b);\n",
          "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
        },
        {
          "name": "use-abi-encodecall-instead-of-encodewithselector",
          "vulnerability_from_line": 282,
          "vulnerability_to_line": null,
          "vulnerability_code": "        return abi.encodeWithSelector(UINT256_DOWNCAST_ERROR_SELECTOR, errorCode, a);\n",
          "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 433,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 434,
          "vulnerability_to_line": null,
          "vulnerability_code": "                selector == ERC721_RECEIVED,\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 435,
          "vulnerability_to_line": null,
          "vulnerability_code": "                \"ERC721_INVALID_SELECTOR\"\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 436,
          "vulnerability_to_line": null,
          "vulnerability_code": "            );\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 470,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 471,
          "vulnerability_to_line": null,
          "vulnerability_code": "                selector == ERC721_RECEIVED,\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 472,
          "vulnerability_to_line": null,
          "vulnerability_code": "                \"ERC721_INVALID_SELECTOR\"\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 473,
          "vulnerability_to_line": null,
          "vulnerability_code": "            );\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 487,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 488,
          "vulnerability_to_line": null,
          "vulnerability_code": "            msg.sender == owner || isApprovedForAll(owner, msg.sender),\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 489,
          "vulnerability_to_line": null,
          "vulnerability_code": "            \"ERC721_INVALID_SENDER\"\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 490,
          "vulnerability_to_line": null,
          "vulnerability_code": "        );\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 527,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 528,
          "vulnerability_to_line": null,
          "vulnerability_code": "            _owner != address(0),\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 529,
          "vulnerability_to_line": null,
          "vulnerability_code": "            \"ERC721_ZERO_OWNER\"\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 530,
          "vulnerability_to_line": null,
          "vulnerability_code": "        );\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 551,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 552,
          "vulnerability_to_line": null,
          "vulnerability_code": "            _to != address(0),\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 553,
          "vulnerability_to_line": null,
          "vulnerability_code": "            \"ERC721_ZERO_TO_ADDRESS\"\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 554,
          "vulnerability_to_line": null,
          "vulnerability_code": "        );\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 557,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 558,
          "vulnerability_to_line": null,
          "vulnerability_code": "            _from == owner,\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 559,
          "vulnerability_to_line": null,
          "vulnerability_code": "            \"ERC721_OWNER_MISMATCH\"\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 560,
          "vulnerability_to_line": null,
          "vulnerability_code": "        );\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 564,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 565,
          "vulnerability_to_line": null,
          "vulnerability_code": "            spender == owner ||\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 566,
          "vulnerability_to_line": null,
          "vulnerability_code": "            isApprovedForAll(owner, spender) ||\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 567,
          "vulnerability_to_line": null,
          "vulnerability_code": "            approvedAddress == spender,\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 568,
          "vulnerability_to_line": null,
          "vulnerability_code": "            \"ERC721_INVALID_SPENDER\"\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 569,
          "vulnerability_to_line": null,
          "vulnerability_code": "        );\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 597,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 598,
          "vulnerability_to_line": null,
          "vulnerability_code": "            owner != address(0),\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 599,
          "vulnerability_to_line": null,
          "vulnerability_code": "            \"ERC721_ZERO_OWNER\"\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 600,
          "vulnerability_to_line": null,
          "vulnerability_code": "        );\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        }
      ]
    },
    "slither": {
      "successfull_analysis": true,
      "errors": [
        "EXIT_CODE_29"
      ],
      "vulnerability_findings": [
        {
          "name": "constant-function",
          "vulnerability_from_line": 246,
          "vulnerability_to_line": 250,
          "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
          "message": "LibRichErrors.rrevert (ERC721Token.sol#246-250) is declared view but contains assembly code\n"
        },
        {
          "name": "erc20-interface",
          "vulnerability_from_line": 24,
          "vulnerability_to_line": 160,
          "vulnerability_code": "contract IERC721Token {\n\n\n\n    /// @dev This emits when ownership of any NFT changes by any mechanism.\n\n    ///      This event emits when NFTs are created (`from` == 0) and destroyed\n\n    ///      (`to` == 0). Exception: during contract creation, any number of NFTs\n\n    ///      may be created and assigned without emitting Transfer. At the time of\n\n    ///      any transfer, the approved address for that NFT (if any) is reset to none.\n\n    event Transfer(\n\n        address indexed _from,\n\n        address indexed _to,\n\n        uint256 indexed _tokenId\n\n    );\n\n\n\n    /// @dev This emits when the approved address for an NFT is changed or\n\n    ///      reaffirmed. The zero address indicates there is no approved address.\n\n    ///      When a Transfer event emits, this also indicates that the approved\n\n    ///      address for that NFT (if any) is reset to none.\n\n    event Approval(\n\n        address indexed _owner,\n\n        address indexed _approved,\n\n        uint256 indexed _tokenId\n\n    );\n\n\n\n    /// @dev This emits when an operator is enabled or disabled for an owner.\n\n    ///      The operator can manage all NFTs of the owner.\n\n    event ApprovalForAll(\n\n        address indexed _owner,\n\n        address indexed _operator,\n\n        bool _approved\n\n    );\n\n\n\n    /// @notice Transfers the ownership of an NFT from one address to another address\n\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\n\n    ///      perator, or the approved address for this NFT. Throws if `_from` is\n\n    ///      not the current owner. Throws if `_to` is the zero address. Throws if\n\n    ///      `_tokenId` is not a valid NFT. When transfer is complete, this function\n\n    ///      checks if `_to` is a smart contract (code size > 0). If so, it calls\n\n    ///      `onERC721Received` on `_to` and throws if the return value is not\n\n    ///      `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\n\n    /// @param _from The current owner of the NFT\n\n    /// @param _to The new owner\n\n    /// @param _tokenId The NFT to transfer\n\n    /// @param _data Additional data with no specified format, sent in call to `_to`\n\n    function safeTransferFrom(\n\n        address _from,\n\n        address _to,\n\n        uint256 _tokenId,\n\n        bytes calldata _data\n\n    )\n\n        external;\n\n\n\n    /// @notice Transfers the ownership of an NFT from one address to another address\n\n    /// @dev This works identically to the other function with an extra data parameter,\n\n    ///      except this function just sets data to \"\".\n\n    /// @param _from The current owner of the NFT\n\n    /// @param _to The new owner\n\n    /// @param _tokenId The NFT to transfer\n\n    function safeTransferFrom(\n\n        address _from,\n\n        address _to,\n\n        uint256 _tokenId\n\n    )\n\n        external;\n\n\n\n    /// @notice Change or reaffirm the approved address for an NFT\n\n    /// @dev The zero address indicates there is no approved address.\n\n    ///      Throws unless `msg.sender` is the current NFT owner, or an authorized\n\n    ///      operator of the current owner.\n\n    /// @param _approved The new approved NFT controller\n\n    /// @param _tokenId The NFT to approve\n\n    function approve(address _approved, uint256 _tokenId)\n\n        external;\n\n\n\n    /// @notice Enable or disable approval for a third party (\"operator\") to manage\n\n    ///         all of `msg.sender`'s assets\n\n    /// @dev Emits the ApprovalForAll event. The contract MUST allow\n\n    ///      multiple operators per owner.\n\n    /// @param _operator Address to add to the set of authorized operators\n\n    /// @param _approved True if the operator is approved, false to revoke approval\n\n    function setApprovalForAll(address _operator, bool _approved)\n\n        external;\n\n\n\n    /// @notice Count all NFTs assigned to an owner\n\n    /// @dev NFTs assigned to the zero address are considered invalid, and this\n\n    ///      function throws for queries about the zero address.\n\n    /// @param _owner An address for whom to query the balance\n\n    /// @return The number of NFTs owned by `_owner`, possibly zero\n\n    function balanceOf(address _owner)\n\n        external\n\n        view\n\n        returns (uint256);\n\n\n\n    /// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\n\n    ///         TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE\n\n    ///         THEY MAY BE PERMANENTLY LOST\n\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\n\n    ///      operator, or the approved address for this NFT. Throws if `_from` is\n\n    ///      not the current owner. Throws if `_to` is the zero address. Throws if\n\n    ///      `_tokenId` is not a valid NFT.\n\n    /// @param _from The current owner of the NFT\n\n    /// @param _to The new owner\n\n    /// @param _tokenId The NFT to transfer\n\n    function transferFrom(\n\n        address _from,\n\n        address _to,\n\n        uint256 _tokenId\n\n    )\n\n        public;\n\n\n\n    /// @notice Find the owner of an NFT\n\n    /// @dev NFTs assigned to zero address are considered invalid, and queries\n\n    ///      about them do throw.\n\n    /// @param _tokenId The identifier for an NFT\n\n    /// @return The address of the owner of the NFT\n\n    function ownerOf(uint256 _tokenId)\n\n        public\n\n        view\n\n        returns (address);\n\n\n\n    /// @notice Get the approved address for a single NFT\n\n    /// @dev Throws if `_tokenId` is not a valid NFT.\n\n    /// @param _tokenId The NFT to find the approved address for\n\n    /// @return The approved address for this NFT, or the zero address if there is none\n\n    function getApproved(uint256 _tokenId) \n\n        public\n\n        view\n\n        returns (address);\n\n    \n\n    /// @notice Query if an address is an authorized operator for another address\n\n    /// @param _owner The address that owns the NFTs\n\n    /// @param _operator The address that acts on behalf of the owner\n\n    /// @return True if `_operator` is an approved operator for `_owner`, false otherwise\n\n    function isApprovedForAll(address _owner, address _operator)\n\n        public\n\n        view\n\n        returns (bool);\n",
          "message": "IERC721Token (ERC721Token.sol#24-160) has incorrect ERC20 function interface(s):\n\t-approve (ERC721Token.sol#94-95)\n\t-transferFrom (ERC721Token.sol#126-131)\n"
        },
        {
          "name": "erc20-interface",
          "vulnerability_from_line": 375,
          "vulnerability_to_line": 627,
          "vulnerability_code": "contract ERC721Token is\n\n    IERC721Token\n\n{\n\n    using LibSafeMath for uint256;\n\n\n\n    // Function selector for ERC721Receiver.onERC721Received\n\n    // 0x150b7a02\n\n    bytes4 constant internal ERC721_RECEIVED = bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"));\n\n\n\n    // Mapping of tokenId => owner\n\n    mapping (uint256 => address) internal owners;\n\n\n\n    // Mapping of tokenId => approved address\n\n    mapping (uint256 => address) internal approvals;\n\n\n\n    // Mapping of owner => number of tokens owned\n\n    mapping (address => uint256) internal balances;\n\n\n\n    // Mapping of owner => operator => approved\n\n    mapping (address => mapping (address => bool)) internal operatorApprovals;\n\n\n\n    /// @notice Transfers the ownership of an NFT from one address to another address\n\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\n\n    ///      operator, or the approved address for this NFT. Throws if `_from` is\n\n    ///      not the current owner. Throws if `_to` is the zero address. Throws if\n\n    ///      `_tokenId` is not a valid NFT. When transfer is complete, this function\n\n    ///      checks if `_to` is a smart contract (code size > 0). If so, it calls\n\n    ///      `onERC721Received` on `_to` and throws if the return value is not\n\n    ///      `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\n\n    /// @param _from The current owner of the NFT\n\n    /// @param _to The new owner\n\n    /// @param _tokenId The NFT to transfer\n\n    /// @param _data Additional data with no specified format, sent in call to `_to`\n\n    function safeTransferFrom(\n\n        address _from,\n\n        address _to,\n\n        uint256 _tokenId,\n\n        bytes calldata _data\n\n    )\n\n        external\n\n    {\n\n        transferFrom(\n\n            _from,\n\n            _to,\n\n            _tokenId\n\n        );\n\n\n\n        uint256 receiverCodeSize;\n\n        assembly {\n\n            receiverCodeSize := extcodesize(_to)\n\n        }\n\n        if (receiverCodeSize > 0) {\n\n            bytes4 selector = IERC721Receiver(_to).onERC721Received(\n\n                msg.sender,\n\n                _from,\n\n                _tokenId,\n\n                _data\n\n            );\n\n            require(\n\n                selector == ERC721_RECEIVED,\n\n                \"ERC721_INVALID_SELECTOR\"\n\n            );\n\n        }\n\n    }\n\n\n\n    /// @notice Transfers the ownership of an NFT from one address to another address\n\n    /// @dev This works identically to the other function with an extra data parameter,\n\n    ///      except this function just sets data to \"\".\n\n    /// @param _from The current owner of the NFT\n\n    /// @param _to The new owner\n\n    /// @param _tokenId The NFT to transfer\n\n    function safeTransferFrom(\n\n        address _from,\n\n        address _to,\n\n        uint256 _tokenId\n\n    )\n\n        external\n\n    {\n\n        transferFrom(\n\n            _from,\n\n            _to,\n\n            _tokenId\n\n        );\n\n\n\n        uint256 receiverCodeSize;\n\n        assembly {\n\n            receiverCodeSize := extcodesize(_to)\n\n        }\n\n        if (receiverCodeSize > 0) {\n\n            bytes4 selector = IERC721Receiver(_to).onERC721Received(\n\n                msg.sender,\n\n                _from,\n\n                _tokenId,\n\n                \"\"\n\n            );\n\n            require(\n\n                selector == ERC721_RECEIVED,\n\n                \"ERC721_INVALID_SELECTOR\"\n\n            );\n\n        }\n\n    }\n\n\n\n    /// @notice Change or reaffirm the approved address for an NFT\n\n    /// @dev The zero address indicates there is no approved address.\n\n    ///      Throws unless `msg.sender` is the current NFT owner, or an authorized\n\n    ///      operator of the current owner.\n\n    /// @param _approved The new approved NFT controller\n\n    /// @param _tokenId The NFT to approve\n\n    function approve(address _approved, uint256 _tokenId)\n\n        external\n\n    {\n\n        address owner = ownerOf(_tokenId);\n\n        require(\n\n            msg.sender == owner || isApprovedForAll(owner, msg.sender),\n\n            \"ERC721_INVALID_SENDER\"\n\n        );\n\n\n\n        approvals[_tokenId] = _approved;\n\n        emit Approval(\n\n            owner,\n\n            _approved,\n\n            _tokenId\n\n        );\n\n    }\n\n\n\n    /// @notice Enable or disable approval for a third party (\"operator\") to manage\n\n    ///         all of `msg.sender`'s assets\n\n    /// @dev Emits the ApprovalForAll event. The contract MUST allow\n\n    ///      multiple operators per owner.\n\n    /// @param _operator Address to add to the set of authorized operators\n\n    /// @param _approved True if the operator is approved, false to revoke approval\n\n    function setApprovalForAll(address _operator, bool _approved)\n\n        external\n\n    {\n\n        operatorApprovals[msg.sender][_operator] = _approved;\n\n        emit ApprovalForAll(\n\n            msg.sender,\n\n            _operator,\n\n            _approved\n\n        );\n\n    }\n\n\n\n    /// @notice Count all NFTs assigned to an owner\n\n    /// @dev NFTs assigned to the zero address are considered invalid, and this\n\n    ///      function throws for queries about the zero address.\n\n    /// @param _owner An address for whom to query the balance\n\n    /// @return The number of NFTs owned by `_owner`, possibly zero\n\n    function balanceOf(address _owner)\n\n        external\n\n        view\n\n        returns (uint256)\n\n    {\n\n        require(\n\n            _owner != address(0),\n\n            \"ERC721_ZERO_OWNER\"\n\n        );\n\n        return balances[_owner];\n\n    }\n\n\n\n    /// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\n\n    ///         TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE\n\n    ///         THEY MAY BE PERMANENTLY LOST\n\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\n\n    ///      operator, or the approved address for this NFT. Throws if `_from` is\n\n    ///      not the current owner. Throws if `_to` is the zero address. Throws if\n\n    ///      `_tokenId` is not a valid NFT.\n\n    /// @param _from The current owner of the NFT\n\n    /// @param _to The new owner\n\n    /// @param _tokenId The NFT to transfer\n\n    function transferFrom(\n\n        address _from,\n\n        address _to,\n\n        uint256 _tokenId\n\n    )\n\n        public\n\n    {\n\n        require(\n\n            _to != address(0),\n\n            \"ERC721_ZERO_TO_ADDRESS\"\n\n        );\n\n\n\n        address owner = ownerOf(_tokenId);\n\n        require(\n\n            _from == owner,\n\n            \"ERC721_OWNER_MISMATCH\"\n\n        );\n\n\n\n        address spender = msg.sender;\n\n        address approvedAddress = getApproved(_tokenId);\n\n        require(\n\n            spender == owner ||\n\n            isApprovedForAll(owner, spender) ||\n\n            approvedAddress == spender,\n\n            \"ERC721_INVALID_SPENDER\"\n\n        );\n\n\n\n        if (approvedAddress != address(0)) {\n\n            approvals[_tokenId] = address(0);\n\n        }\n\n\n\n        owners[_tokenId] = _to;\n\n        balances[_from] = balances[_from].safeSub(1);\n\n        balances[_to] = balances[_to].safeAdd(1);\n\n\n\n        emit Transfer(\n\n            _from,\n\n            _to,\n\n            _tokenId\n\n        );\n\n    }\n\n\n\n    /// @notice Find the owner of an NFT\n\n    /// @dev NFTs assigned to zero address are considered invalid, and queries\n\n    ///      about them do throw.\n\n    /// @param _tokenId The identifier for an NFT\n\n    /// @return The address of the owner of the NFT\n\n    function ownerOf(uint256 _tokenId)\n\n        public\n\n        view\n\n        returns (address)\n\n    {\n\n        address owner = owners[_tokenId];\n\n        require(\n\n            owner != address(0),\n\n            \"ERC721_ZERO_OWNER\"\n\n        );\n\n        return owner;\n\n    }\n\n\n\n    /// @notice Get the approved address for a single NFT\n\n    /// @dev Throws if `_tokenId` is not a valid NFT.\n\n    /// @param _tokenId The NFT to find the approved address for\n\n    /// @return The approved address for this NFT, or the zero address if there is none\n\n    function getApproved(uint256 _tokenId)\n\n        public\n\n        view\n\n        returns (address)\n\n    {\n\n        return approvals[_tokenId];\n\n    }\n\n\n\n    /// @notice Query if an address is an authorized operator for another address\n\n    /// @param _owner The address that owns the NFTs\n\n    /// @param _operator The address that acts on behalf of the owner\n\n    /// @return True if `_operator` is an approved operator for `_owner`, false otherwise\n\n    function isApprovedForAll(address _owner, address _operator)\n\n        public\n\n        view\n\n        returns (bool)\n\n    {\n\n        return operatorApprovals[_owner][_operator];\n\n    }\n",
          "message": "ERC721Token (ERC721Token.sol#375-627) has incorrect ERC20 function interface(s):\n\t-approve (ERC721Token.sol#483-498)\n\t-transferFrom (ERC721Token.sol#544-584)\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 246,
          "vulnerability_to_line": 250,
          "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
          "message": "LibRichErrors.rrevert uses assembly (ERC721Token.sol#246-250)\n\t- ERC721Token.sol#247-249\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 408,
          "vulnerability_to_line": 438,
          "vulnerability_code": "    function safeTransferFrom(\n\n        address _from,\n\n        address _to,\n\n        uint256 _tokenId,\n\n        bytes calldata _data\n\n    )\n\n        external\n\n    {\n\n        transferFrom(\n\n            _from,\n\n            _to,\n\n            _tokenId\n\n        );\n\n\n\n        uint256 receiverCodeSize;\n\n        assembly {\n\n            receiverCodeSize := extcodesize(_to)\n\n        }\n\n        if (receiverCodeSize > 0) {\n\n            bytes4 selector = IERC721Receiver(_to).onERC721Received(\n\n                msg.sender,\n\n                _from,\n\n                _tokenId,\n\n                _data\n\n            );\n\n            require(\n\n                selector == ERC721_RECEIVED,\n\n                \"ERC721_INVALID_SELECTOR\"\n\n            );\n\n        }\n",
          "message": "ERC721Token.safeTransferFrom uses assembly (ERC721Token.sol#408-438)\n\t- ERC721Token.sol#423-425\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 446,
          "vulnerability_to_line": 475,
          "vulnerability_code": "    function safeTransferFrom(\n\n        address _from,\n\n        address _to,\n\n        uint256 _tokenId\n\n    )\n\n        external\n\n    {\n\n        transferFrom(\n\n            _from,\n\n            _to,\n\n            _tokenId\n\n        );\n\n\n\n        uint256 receiverCodeSize;\n\n        assembly {\n\n            receiverCodeSize := extcodesize(_to)\n\n        }\n\n        if (receiverCodeSize > 0) {\n\n            bytes4 selector = IERC721Receiver(_to).onERC721Received(\n\n                msg.sender,\n\n                _from,\n\n                _tokenId,\n\n                \"\"\n\n            );\n\n            require(\n\n                selector == ERC721_RECEIVED,\n\n                \"ERC721_INVALID_SELECTOR\"\n\n            );\n\n        }\n",
          "message": "ERC721Token.safeTransferFrom uses assembly (ERC721Token.sol#446-475)\n\t- ERC721Token.sol#460-462\n"
        },
        {
          "name": "solc-version",
          "vulnerability_from_line": 21,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.9;\n",
          "message": "Detected issues with version pragma in ERC721Token.sol:\n\t- pragma solidity^0.5.9 (ERC721Token.sol#21): it allows old versions\n\t- pragma solidity^0.5.9 (ERC721Token.sol#182): it allows old versions\n\t- pragma solidity^0.5.9 (ERC721Token.sol#229): it allows old versions\n\t- pragma solidity^0.5.9 (ERC721Token.sol#255): it allows old versions\n\t- pragma solidity^0.5.9 (ERC721Token.sol#288): it allows old versions\n\t- pragma solidity^0.5.9 (ERC721Token.sol#371): it allows old versions\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 240,
          "vulnerability_to_line": 242,
          "vulnerability_code": "    function StandardError(string memory message) internal pure returns (bytes memory) {\n\n        return abi.encodeWithSelector(STANDARD_ERROR_SELECTOR, bytes(message));\n",
          "message": "Function 'LibRichErrors.StandardError' (ERC721Token.sol#240-242) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 277,
          "vulnerability_to_line": 279,
          "vulnerability_code": "    function Uint256BinOpError(BinOpErrorCodes errorCode, uint256 a, uint256 b) internal pure returns (bytes memory) {\n\n        return abi.encodeWithSelector(UINT256_BINOP_ERROR_SELECTOR, errorCode, a, b);\n",
          "message": "Function 'LibSafeMathRichErrors.Uint256BinOpError' (ERC721Token.sol#277-279) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 281,
          "vulnerability_to_line": 283,
          "vulnerability_code": "    function Uint256DowncastError(DowncastErrorCodes errorCode, uint256 a) internal pure returns (bytes memory) {\n\n        return abi.encodeWithSelector(UINT256_DOWNCAST_ERROR_SELECTOR, errorCode, a);\n",
          "message": "Function 'LibSafeMathRichErrors.Uint256DowncastError' (ERC721Token.sol#281-283) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 409,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address _from,\n",
          "message": "Parameter '_from' of ERC721Token.safeTransferFrom (ERC721Token.sol#409) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 410,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address _to,\n",
          "message": "Parameter '_to' of ERC721Token.safeTransferFrom (ERC721Token.sol#410) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 411,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint256 _tokenId,\n",
          "message": "Parameter '_tokenId' of ERC721Token.safeTransferFrom (ERC721Token.sol#411) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 412,
          "vulnerability_to_line": null,
          "vulnerability_code": "        bytes calldata _data\n",
          "message": "Parameter '_data' of ERC721Token.safeTransferFrom (ERC721Token.sol#412) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 447,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address _from,\n",
          "message": "Parameter '_from' of ERC721Token.safeTransferFrom (ERC721Token.sol#447) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 448,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address _to,\n",
          "message": "Parameter '_to' of ERC721Token.safeTransferFrom (ERC721Token.sol#448) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 449,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint256 _tokenId\n",
          "message": "Parameter '_tokenId' of ERC721Token.safeTransferFrom (ERC721Token.sol#449) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 483,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function approve(address _approved, uint256 _tokenId)\n",
          "message": "Parameter '_approved' of ERC721Token.approve (ERC721Token.sol#483) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 483,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function approve(address _approved, uint256 _tokenId)\n",
          "message": "Parameter '_tokenId' of ERC721Token.approve (ERC721Token.sol#483) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 506,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setApprovalForAll(address _operator, bool _approved)\n",
          "message": "Parameter '_operator' of ERC721Token.setApprovalForAll (ERC721Token.sol#506) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 506,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setApprovalForAll(address _operator, bool _approved)\n",
          "message": "Parameter '_approved' of ERC721Token.setApprovalForAll (ERC721Token.sol#506) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 522,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function balanceOf(address _owner)\n",
          "message": "Parameter '_owner' of ERC721Token.balanceOf (ERC721Token.sol#522) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 545,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address _from,\n",
          "message": "Parameter '_from' of ERC721Token.transferFrom (ERC721Token.sol#545) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 546,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address _to,\n",
          "message": "Parameter '_to' of ERC721Token.transferFrom (ERC721Token.sol#546) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 547,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint256 _tokenId\n",
          "message": "Parameter '_tokenId' of ERC721Token.transferFrom (ERC721Token.sol#547) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 591,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function ownerOf(uint256 _tokenId)\n",
          "message": "Parameter '_tokenId' of ERC721Token.ownerOf (ERC721Token.sol#591) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 608,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getApproved(uint256 _tokenId)\n",
          "message": "Parameter '_tokenId' of ERC721Token.getApproved (ERC721Token.sol#608) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 620,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function isApprovedForAll(address _owner, address _operator)\n",
          "message": "Parameter '_owner' of ERC721Token.isApprovedForAll (ERC721Token.sol#620) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 620,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function isApprovedForAll(address _owner, address _operator)\n",
          "message": "Parameter '_operator' of ERC721Token.isApprovedForAll (ERC721Token.sol#620) is not in mixedCase\n"
        }
      ]
    },
    "smartcheck": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 233,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bytes4 internal constant STANDARD_ERROR_SELECTOR = 0x08c379a0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 259,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bytes4 internal constant UINT256_BINOP_ERROR_SELECTOR = 0xe946c1bb;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 262,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bytes4 internal constant UINT256_DOWNCAST_ERROR_SELECTOR = 0xc996af7b;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 572,
          "vulnerability_to_line": null,
          "vulnerability_code": "            approvals[_tokenId] = address(0);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ERC20_APPROVE",
          "vulnerability_from_line": 483,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function approve(address _approved, uint256 _tokenId)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 21,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.9;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 182,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.9;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 229,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.9;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 255,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.9;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 288,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.9;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 371,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.9;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 246,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 247,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        }
      ]
    },
    "oyente": {
      "successfull_analysis": false,
      "errors": [
        "exception (IndexError: pop from empty list)"
      ],
      "vulnerability_findings": []
    },
    "mythril": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": []
    },
    "osiris": {
      "successfull_analysis": false,
      "errors": [
        "Solidity compilation failed"
      ],
      "vulnerability_findings": []
    }
  }
}