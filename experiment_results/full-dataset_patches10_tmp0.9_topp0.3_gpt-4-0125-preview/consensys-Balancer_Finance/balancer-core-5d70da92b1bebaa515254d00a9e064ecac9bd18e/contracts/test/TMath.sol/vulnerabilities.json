{
  "smartbugs_completed": true,
  "analyzer_results": {
    "semgrep": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 218,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 1; term >= precision; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 112,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(c >= a, \"ERR_ADD_OVERFLOW\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 121,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(!flag, \"ERR_SUB_UNDERFLOW\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 142,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(a == 0 || c0 / a == b, \"ERR_MUL_OVERFLOW\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 144,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(c1 >= c0, \"ERR_MUL_OVERFLOW\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 153,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(b != 0, \"ERR_DIV_ZERO\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 155,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(a == 0 || c0 / a == BONE, \"ERR_DIV_INTERNAL\"); // bmul overflow\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 157,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(c1 >= c0, \"ERR_DIV_INTERNAL\"); //  badd require\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 186,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(base >= MIN_BPOW_BASE, \"ERR_BPOW_BASE_TOO_LOW\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 187,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(base <= MAX_BPOW_BASE, \"ERR_BPOW_BASE_TOO_HIGH\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 218,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 1; term >= precision; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        }
      ]
    },
    "slither": {
      "successfull_analysis": true,
      "errors": [
        "EXIT_CODE_18"
      ],
      "vulnerability_findings": [
        {
          "name": "external-function",
          "vulnerability_from_line": 266,
          "vulnerability_to_line": 281,
          "vulnerability_code": "    function calcSpotPrice(\n\n        uint tokenBalanceIn,\n\n        uint tokenWeightIn,\n\n        uint tokenBalanceOut,\n\n        uint tokenWeightOut,\n\n        uint swapFee\n\n    )\n\n        public pure\n\n        returns (uint spotPrice)\n\n    {\n\n        uint numer = bdiv(tokenBalanceIn, tokenWeightIn);\n\n        uint denom = bdiv(tokenBalanceOut, tokenWeightOut);\n\n        uint ratio = bdiv(numer, denom);\n\n        uint scale = bdiv(BONE, bsub(BONE, swapFee));\n\n        return  (spotPrice = bmul(ratio, scale));\n",
          "message": "BMath.calcSpotPrice (TMath.sol#266-281) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 293,
          "vulnerability_to_line": 312,
          "vulnerability_code": "    function calcOutGivenIn(\n\n        uint tokenBalanceIn,\n\n        uint tokenWeightIn,\n\n        uint tokenBalanceOut,\n\n        uint tokenWeightOut,\n\n        uint tokenAmountIn,\n\n        uint swapFee\n\n    )\n\n        public pure\n\n        returns (uint tokenAmountOut)\n\n    {\n\n        uint weightRatio = bdiv(tokenWeightIn, tokenWeightOut);\n\n        uint adjustedIn = bsub(BONE, swapFee);\n\n        adjustedIn = bmul(tokenAmountIn, adjustedIn);\n\n        uint y = bdiv(tokenBalanceIn, badd(tokenBalanceIn, adjustedIn));\n\n        uint foo = bpow(y, weightRatio);\n\n        uint bar = bsub(BONE, foo);\n\n        tokenAmountOut = bmul(tokenBalanceOut, bar);\n\n        return tokenAmountOut;\n",
          "message": "BMath.calcOutGivenIn (TMath.sol#293-312) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 324,
          "vulnerability_to_line": 343,
          "vulnerability_code": "    function calcInGivenOut(\n\n        uint tokenBalanceIn,\n\n        uint tokenWeightIn,\n\n        uint tokenBalanceOut,\n\n        uint tokenWeightOut,\n\n        uint tokenAmountOut,\n\n        uint swapFee\n\n    )\n\n        public pure\n\n        returns (uint tokenAmountIn)\n\n    {\n\n        uint weightRatio = bdiv(tokenWeightOut, tokenWeightIn);\n\n        uint diff = bsub(tokenBalanceOut, tokenAmountOut);\n\n        uint y = bdiv(tokenBalanceOut, diff);\n\n        uint foo = bpow(y, weightRatio);\n\n        foo = bsub(foo, BONE);\n\n        tokenAmountIn = bsub(BONE, swapFee);\n\n        tokenAmountIn = bdiv(bmul(tokenBalanceIn, foo), tokenAmountIn);\n\n        return tokenAmountIn;\n",
          "message": "BMath.calcInGivenOut (TMath.sol#324-343) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 355,
          "vulnerability_to_line": 382,
          "vulnerability_code": "    function calcPoolOutGivenSingleIn(\n\n        uint tokenBalanceIn,\n\n        uint tokenWeightIn,\n\n        uint poolSupply,\n\n        uint totalWeight,\n\n        uint tokenAmountIn,\n\n        uint swapFee\n\n    )\n\n        public pure\n\n        returns (uint poolAmountOut)\n\n    {\n\n        // Charge the trading fee for the proportion of tokenAi\n\n        ///  which is implicitly traded to the other pool tokens.\n\n        // That proportion is (1- weightTokenIn)\n\n        // tokenAiAfterFee = tAi * (1 - (1-weightTi) * poolFee);\n\n        uint normalizedWeight = bdiv(tokenWeightIn, totalWeight);\n\n        uint zaz = bmul(bsub(BONE, normalizedWeight), swapFee); \n\n        uint tokenAmountInAfterFee = bmul(tokenAmountIn, bsub(BONE, zaz));\n\n\n\n        uint newTokenBalanceIn = badd(tokenBalanceIn, tokenAmountInAfterFee);\n\n        uint tokenInRatio = bdiv(newTokenBalanceIn, tokenBalanceIn);\n\n\n\n        // uint newPoolSupply = (ratioTi ^ weightTi) * poolSupply;\n\n        uint poolRatio = bpow(tokenInRatio, normalizedWeight);\n\n        uint newPoolSupply = bmul(poolRatio, poolSupply);\n\n        poolAmountOut = bsub(newPoolSupply, poolSupply);\n\n        return poolAmountOut;\n",
          "message": "BMath.calcPoolOutGivenSingleIn (TMath.sol#355-382) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 394,
          "vulnerability_to_line": 420,
          "vulnerability_code": "    function calcSingleInGivenPoolOut(\n\n        uint tokenBalanceIn,\n\n        uint tokenWeightIn,\n\n        uint poolSupply,\n\n        uint totalWeight,\n\n        uint poolAmountOut,\n\n        uint swapFee\n\n    )\n\n        public pure\n\n        returns (uint tokenAmountIn)\n\n    {\n\n        uint normalizedWeight = bdiv(tokenWeightIn, totalWeight);\n\n        uint newPoolSupply = badd(poolSupply, poolAmountOut);\n\n        uint poolRatio = bdiv(newPoolSupply, poolSupply);\n\n      \n\n        //uint newBalTi = poolRatio^(1/weightTi) * balTi;\n\n        uint boo = bdiv(BONE, normalizedWeight); \n\n        uint tokenInRatio = bpow(poolRatio, boo);\n\n        uint newTokenBalanceIn = bmul(tokenInRatio, tokenBalanceIn);\n\n        uint tokenAmountInAfterFee = bsub(newTokenBalanceIn, tokenBalanceIn);\n\n        // Do reverse order of fees charged in joinswap_ExternAmountIn, this way \n\n        //     ``` pAo == joinswap_ExternAmountIn(Ti, joinswap_PoolAmountOut(pAo, Ti)) ```\n\n        //uint tAi = tAiAfterFee / (1 - (1-weightTi) * swapFee) ;\n\n        uint zar = bmul(bsub(BONE, normalizedWeight), swapFee);\n\n        tokenAmountIn = bdiv(tokenAmountInAfterFee, bsub(BONE, zar));\n\n        return tokenAmountIn;\n",
          "message": "BMath.calcSingleInGivenPoolOut (TMath.sol#394-420) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 433,
          "vulnerability_to_line": 462,
          "vulnerability_code": "    function calcSingleOutGivenPoolIn(\n\n        uint tokenBalanceOut,\n\n        uint tokenWeightOut,\n\n        uint poolSupply,\n\n        uint totalWeight,\n\n        uint poolAmountIn,\n\n        uint swapFee\n\n    )\n\n        public pure\n\n        returns (uint tokenAmountOut)\n\n    {\n\n        uint normalizedWeight = bdiv(tokenWeightOut, totalWeight);\n\n        // charge exit fee on the pool token side\n\n        // pAiAfterExitFee = pAi*(1-exitFee)\n\n        uint poolAmountInAfterExitFee = bmul(poolAmountIn, bsub(BONE, EXIT_FEE));\n\n        uint newPoolSupply = bsub(poolSupply, poolAmountInAfterExitFee);\n\n        uint poolRatio = bdiv(newPoolSupply, poolSupply);\n\n     \n\n        // newBalTo = poolRatio^(1/weightTo) * balTo;\n\n        uint tokenOutRatio = bpow(poolRatio, bdiv(BONE, normalizedWeight));\n\n        uint newTokenBalanceOut = bmul(tokenOutRatio, tokenBalanceOut);\n\n\n\n        uint tokenAmountOutBeforeSwapFee = bsub(tokenBalanceOut, newTokenBalanceOut);\n\n\n\n        // charge swap fee on the output token side \n\n        //uint tAo = tAoBeforeSwapFee * (1 - (1-weightTo) * swapFee)\n\n        uint zaz = bmul(bsub(BONE, normalizedWeight), swapFee); \n\n        tokenAmountOut = bmul(tokenAmountOutBeforeSwapFee, bsub(BONE, zaz));\n\n        return tokenAmountOut;\n",
          "message": "BMath.calcSingleOutGivenPoolIn (TMath.sol#433-462) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 475,
          "vulnerability_to_line": 506,
          "vulnerability_code": "    function calcPoolInGivenSingleOut(\n\n        uint tokenBalanceOut,\n\n        uint tokenWeightOut,\n\n        uint poolSupply,\n\n        uint totalWeight,\n\n        uint tokenAmountOut,\n\n        uint swapFee\n\n    )\n\n        public pure\n\n        returns (uint poolAmountIn)\n\n    {\n\n\n\n        // charge swap fee on the output token side \n\n        uint normalizedWeight = bdiv(tokenWeightOut, totalWeight);\n\n        //uint tAoBeforeSwapFee = tAo / (1 - (1-weightTo) * swapFee) ;\n\n        uint zoo = bsub(BONE, normalizedWeight);\n\n        uint zar = bmul(zoo, swapFee); \n\n        uint tokenAmountOutBeforeSwapFee = bdiv(tokenAmountOut, bsub(BONE, zar));\n\n\n\n        uint newTokenBalanceOut = bsub(tokenBalanceOut, tokenAmountOutBeforeSwapFee);\n\n        uint tokenOutRatio = bdiv(newTokenBalanceOut, tokenBalanceOut);\n\n\n\n        //uint newPoolSupply = (ratioTo ^ weightTo) * poolSupply;\n\n        uint poolRatio = bpow(tokenOutRatio, normalizedWeight);\n\n        uint newPoolSupply = bmul(poolRatio, poolSupply);\n\n        uint poolAmountInAfterExitFee = bsub(poolSupply, newPoolSupply);\n\n\n\n        // charge exit fee on the pool token side\n\n        // pAi = pAiAfterExitFee/(1-exitFee)\n\n        poolAmountIn = bdiv(poolAmountInAfterExitFee, bsub(BONE, EXIT_FEE));\n\n        return poolAmountIn;\n",
          "message": "BMath.calcPoolInGivenSingleOut (TMath.sol#475-506) should be declared external\n"
        },
        {
          "name": "solc-version",
          "vulnerability_from_line": 16,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity 0.5.12;\n",
          "message": "Detected issues with version pragma in TMath.sol:\n\t- pragma solidity0.5.12 (TMath.sol#16): it allows old versions\n\t- pragma solidity0.5.12 (TMath.sol#47): it allows old versions\n\t- pragma solidity0.5.12 (TMath.sol#89): it allows old versions\n\t- pragma solidity0.5.12 (TMath.sol#254): it allows old versions\n\t- pragma solidity0.5.12 (TMath.sol#526): it allows old versions\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 533,
          "vulnerability_to_line": 535,
          "vulnerability_code": "    function calc_btoi(uint a) external pure returns (uint) {\n\n        return btoi(a);\n",
          "message": "Function 'TMath.calc_btoi' (TMath.sol#533-535) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 537,
          "vulnerability_to_line": 539,
          "vulnerability_code": "    function calc_bfloor(uint a) external pure returns (uint) {\n\n        return bfloor(a);\n",
          "message": "Function 'TMath.calc_bfloor' (TMath.sol#537-539) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 541,
          "vulnerability_to_line": 543,
          "vulnerability_code": "    function calc_badd(uint a, uint b) external pure returns (uint) {\n\n        return badd(a, b);\n",
          "message": "Function 'TMath.calc_badd' (TMath.sol#541-543) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 545,
          "vulnerability_to_line": 547,
          "vulnerability_code": "    function calc_bsub(uint a, uint b) external pure returns (uint) {\n\n        return bsub(a, b);\n",
          "message": "Function 'TMath.calc_bsub' (TMath.sol#545-547) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 549,
          "vulnerability_to_line": 551,
          "vulnerability_code": "    function calc_bsubSign(uint a, uint b) external pure returns (uint, bool) {\n\n        return bsubSign(a, b);\n",
          "message": "Function 'TMath.calc_bsubSign' (TMath.sol#549-551) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 553,
          "vulnerability_to_line": 555,
          "vulnerability_code": "    function calc_bmul(uint a, uint b) external pure returns (uint) {\n\n        return bmul(a, b);\n",
          "message": "Function 'TMath.calc_bmul' (TMath.sol#553-555) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 557,
          "vulnerability_to_line": 559,
          "vulnerability_code": "    function calc_bdiv(uint a, uint b) external pure returns (uint) {\n\n        return bdiv(a, b);\n",
          "message": "Function 'TMath.calc_bdiv' (TMath.sol#557-559) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 561,
          "vulnerability_to_line": 563,
          "vulnerability_code": "    function calc_bpowi(uint a, uint n) external pure returns (uint) {\n\n        return bpowi(a, n);\n",
          "message": "Function 'TMath.calc_bpowi' (TMath.sol#561-563) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 565,
          "vulnerability_to_line": 567,
          "vulnerability_code": "    function calc_bpow(uint base, uint exp) external pure returns (uint) {\n\n        return bpow(base, exp);\n",
          "message": "Function 'TMath.calc_bpow' (TMath.sol#565-567) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 569,
          "vulnerability_to_line": 571,
          "vulnerability_code": "    function calc_bpowApprox(uint base, uint exp, uint precision) external pure returns (uint) {\n\n        return bpowApprox(base, exp, precision);\n",
          "message": "Function 'TMath.calc_bpowApprox' (TMath.sol#569-571) is not in mixedCase\n"
        }
      ]
    },
    "smartcheck": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 127,
          "vulnerability_to_line": null,
          "vulnerability_code": "        returns (uint, bool)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 549,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function calc_bsubSign(uint a, uint b) external pure returns (uint, bool) {\n",
          "message": null
        }
      ]
    },
    "oyente": {
      "successfull_analysis": false,
      "errors": [
        "exception (RuntimeError: Source map error, unknown name(SHR) or instr_name(INVALID))"
      ],
      "vulnerability_findings": []
    },
    "mythril": {
      "successfull_analysis": false,
      "errors": [
        "DOCKER_TIMEOUT"
      ],
      "vulnerability_findings": []
    },
    "osiris": {
      "successfull_analysis": false,
      "errors": [
        "UNKNOWN INSTRUCTION: SHR"
      ],
      "vulnerability_findings": []
    }
  }
}