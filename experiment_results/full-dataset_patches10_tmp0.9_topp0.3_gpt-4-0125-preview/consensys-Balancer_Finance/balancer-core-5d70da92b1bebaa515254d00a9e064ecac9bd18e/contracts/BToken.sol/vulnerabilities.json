{
  "smartbugs_completed": true,
  "analyzer_results": {
    "semgrep": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 218,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 1; term >= precision; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 112,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(c >= a, \"ERR_ADD_OVERFLOW\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 121,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(!flag, \"ERR_SUB_UNDERFLOW\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 142,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(a == 0 || c0 / a == b, \"ERR_MUL_OVERFLOW\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 144,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(c1 >= c0, \"ERR_MUL_OVERFLOW\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 153,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(b != 0, \"ERR_DIV_ZERO\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 155,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(a == 0 || c0 / a == BONE, \"ERR_DIV_INTERNAL\"); // bmul overflow\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 157,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(c1 >= c0, \"ERR_DIV_INTERNAL\"); //  badd require\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 186,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(base >= MIN_BPOW_BASE, \"ERR_BPOW_BASE_TOO_LOW\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 187,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(base <= MAX_BPOW_BASE, \"ERR_BPOW_BASE_TOO_HIGH\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 289,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_balance[address(this)] >= amt, \"ERR_INSUFFICIENT_BAL\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 296,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_balance[src] >= amt, \"ERR_INSUFFICIENT_BAL\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 370,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == src || amt <= _allowance[src][msg.sender], \"ERR_BTOKEN_BAD_CALLER\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 372,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (msg.sender != src && _allowance[src][msg.sender] != uint256(-1)) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 373,
          "vulnerability_to_line": null,
          "vulnerability_code": "            _allowance[src][msg.sender] = bsub(_allowance[src][msg.sender], amt);\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 374,
          "vulnerability_to_line": null,
          "vulnerability_code": "            emit Approval(msg.sender, dst, _allowance[src][msg.sender]);\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 375,
          "vulnerability_to_line": null,
          "vulnerability_code": "        }\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 218,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 1; term >= precision; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        }
      ]
    },
    "slither": {
      "successfull_analysis": true,
      "errors": [
        "EXIT_CODE_15"
      ],
      "vulnerability_findings": [
        {
          "name": "constable-states",
          "vulnerability_from_line": 315,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint8   private _decimals = 18;\n",
          "message": "BToken._decimals should be constant (BToken.sol#315)\nBToken._name should be constant (BToken.sol#313)\nBToken._symbol should be constant (BToken.sol#314)\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 262,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function totalSupply() external view returns (uint);\n",
          "message": "IERC20.totalSupply (BToken.sol#262) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 337,
          "vulnerability_to_line": 339,
          "vulnerability_code": "    function totalSupply() public view returns (uint) {\n\n        return _totalSupply;\n",
          "message": "BToken.totalSupply (BToken.sol#337-339) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 317,
          "vulnerability_to_line": 319,
          "vulnerability_code": "    function name() public view returns (string memory) {\n\n        return _name;\n",
          "message": "BToken.name (BToken.sol#317-319) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 321,
          "vulnerability_to_line": 323,
          "vulnerability_code": "    function symbol() public view returns (string memory) {\n\n        return _symbol;\n",
          "message": "BToken.symbol (BToken.sol#321-323) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 325,
          "vulnerability_to_line": 327,
          "vulnerability_code": "    function decimals() public view returns(uint8) {\n\n        return _decimals;\n",
          "message": "BToken.decimals (BToken.sol#325-327) should be declared external\n"
        },
        {
          "name": "solc-version",
          "vulnerability_from_line": 16,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity 0.5.12;\n",
          "message": "Detected issues with version pragma in BToken.sol:\n\t- pragma solidity0.5.12 (BToken.sol#16): it allows old versions\n\t- pragma solidity0.5.12 (BToken.sol#47): it allows old versions\n\t- pragma solidity0.5.12 (BToken.sol#89): it allows old versions\n\t- pragma solidity0.5.12 (BToken.sol#254): it allows old versions\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 282,
          "vulnerability_to_line": 286,
          "vulnerability_code": "    function _mint(uint amt) internal {\n\n        _balance[address(this)] = badd(_balance[address(this)], amt);\n\n        _totalSupply = badd(_totalSupply, amt);\n\n        emit Transfer(address(0), address(this), amt);\n",
          "message": "Function 'BTokenBase._mint' (BToken.sol#282-286) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 288,
          "vulnerability_to_line": 293,
          "vulnerability_code": "    function _burn(uint amt) internal {\n\n        require(_balance[address(this)] >= amt, \"ERR_INSUFFICIENT_BAL\");\n\n        _balance[address(this)] = bsub(_balance[address(this)], amt);\n\n        _totalSupply = bsub(_totalSupply, amt);\n\n        emit Transfer(address(this), address(0), amt);\n",
          "message": "Function 'BTokenBase._burn' (BToken.sol#288-293) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 295,
          "vulnerability_to_line": 300,
          "vulnerability_code": "    function _move(address src, address dst, uint amt) internal {\n\n        require(_balance[src] >= amt, \"ERR_INSUFFICIENT_BAL\");\n\n        _balance[src] = bsub(_balance[src], amt);\n\n        _balance[dst] = badd(_balance[dst], amt);\n\n        emit Transfer(src, dst, amt);\n",
          "message": "Function 'BTokenBase._move' (BToken.sol#295-300) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 302,
          "vulnerability_to_line": 304,
          "vulnerability_code": "    function _push(address to, uint amt) internal {\n\n        _move(address(this), to, amt);\n",
          "message": "Function 'BTokenBase._push' (BToken.sol#302-304) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 306,
          "vulnerability_to_line": 308,
          "vulnerability_code": "    function _pull(address from, uint amt) internal {\n\n        _move(from, address(this), amt);\n",
          "message": "Function 'BTokenBase._pull' (BToken.sol#306-308) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 275,
          "vulnerability_to_line": null,
          "vulnerability_code": "    mapping(address => uint)                   internal _balance;\n",
          "message": "Variable 'BTokenBase._balance' (BToken.sol#275) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 276,
          "vulnerability_to_line": null,
          "vulnerability_code": "    mapping(address => mapping(address=>uint)) internal _allowance;\n",
          "message": "Variable 'BTokenBase._allowance' (BToken.sol#276) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 277,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint internal _totalSupply;\n",
          "message": "Variable 'BTokenBase._totalSupply' (BToken.sol#277) is not in mixedCase\n"
        }
      ]
    },
    "smartcheck": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "SOLIDITY_ERC20_APPROVE",
          "vulnerability_from_line": 341,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function approve(address dst, uint amt) external returns (bool) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 313,
          "vulnerability_to_line": null,
          "vulnerability_code": "    string  private _name     = \"Balancer Pool Token\";\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 314,
          "vulnerability_to_line": null,
          "vulnerability_code": "    string  private _symbol   = \"BPT\";\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 315,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint8   private _decimals = 18;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 127,
          "vulnerability_to_line": null,
          "vulnerability_code": "        returns (uint, bool)\n",
          "message": null
        }
      ]
    },
    "oyente": {
      "successfull_analysis": false,
      "errors": [
        "exception (RuntimeError: Source map error, unknown name(SHR) or instr_name(INVALID))"
      ],
      "vulnerability_findings": []
    },
    "mythril": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": []
    },
    "osiris": {
      "successfull_analysis": false,
      "errors": [
        "UNKNOWN INSTRUCTION: SHR"
      ],
      "vulnerability_findings": []
    }
  }
}