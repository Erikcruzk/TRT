pragma solidity ^0.5.16;


function getPage(
    Bytes32Set storage set,
    uint index,
    uint pageSize
) internal view returns (bytes32[] memory) {
    
    uint endIndex = index + pageSize; 

    
    if (endIndex > set.elements.length) {
        endIndex = set.elements.length;
    }
    if (endIndex <= index) {
        return new bytes32[](0);
    }

    uint n = endIndex - index; 
    bytes32[] memory page = new bytes32[](n);
    for (uint i = 0; i < n; i++) {
        page[i] = set.elements[i + index];
    }
    return page;
}



pragma solidity ^0.5.16;

contract TestableBytes32Set {
    using Bytes32SetLib for Bytes32SetLib.Bytes32Set;

    Bytes32SetLib.Bytes32Set internal set;

    function contains(bytes32 candidate) public view returns (bool) {
        return set.contains(candidate);
    }

    function getPage(uint index, uint pageSize) public view returns (bytes32[] memory) {
        return set.getPage(index, pageSize);
    }

    function add(bytes32 element) public {
        set.add(element);
    }

    function remove(bytes32 element) public {
        set.remove(element);
    }

    function size() public view returns (uint) {
        return set.elements.length;
    }

    function element(uint index) public view returns (bytes32) {
        return set.elements[index];
    }

    function index(bytes32 element) public view returns (uint) {
        return set.indices[element];
    }
}