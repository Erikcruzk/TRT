{
  "smartbugs_completed": true,
  "analyzer_results": {
    "semgrep": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 334,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < outputList.length; i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 60,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 i = 0; i < items; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 334,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < outputList.length; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 50,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(isList(item), \"Item is not a list\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 53,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(listLength == item.len, \"Decoded RLP length for list is invalid\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 95,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(item.len == 21, \"Item length must be 21\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 96,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(!isList(item), \"Item must not be a list\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 99,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(itemLen == 21, \"Decoded item length must be 21\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 119,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(item.len > 0 && item.len <= 33, \"Item length must be between 1 and 33 bytes\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 120,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(!isList(item), \"Item must not be a list\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 122,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(itemLen == item.len, \"Decoded item length must be equal to the input data length\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 139,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(!(dataByte0 == 0 && offset == 0), \"Scalar 0 should be encoded as 0x80\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 142,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(!(dataByte0 == 0 && dataLen > 1), \"Leading zeros are invalid\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 154,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(item.len == 33, \"Item length must be 33\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 155,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(!isList(item), \"Item must not be a list\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 158,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(itemLen == 33, \"Decoded item length must be 33\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 183,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(currPtr <= endPtr, \"Invalid decoded length of RLP item found during counting items in a list\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 221,
          "vulnerability_to_line": null,
          "vulnerability_code": "                require(byte1 >= STRING_SHORT_START, \"Invalid short string encoding\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 244,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(byte1 != 0, \"Invalid leading zeros in length of the length for a long string\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 246,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(dataLen > MAX_SHORT_LEN, \"Invalid length for a long string\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 274,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(byte1 != 0, \"Invalid leading zeros in length of the length for a long list\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 276,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(dataLen > MAX_SHORT_LEN, \"Invalid length for a long list\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 328,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(rlpTx.length == TX_NUM_ITEMS, \"Invalid encoding of transaction\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 330,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(txType > 0, \"Transaction type must not be 0\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 357,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(outputIndex < transaction.outputs.length, \"Output index out of bounds\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 370,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(rlpList.length == 2, \"Output must have 2 items\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 377,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(output.outputType != 0, \"Output type must not be 0\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 417,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(dataList.length == 3, \"Output data must have 3 items\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 426,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(outputData.outputGuard != bytes20(0), \"Output outputGuard must not be 0\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 439,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(outputIndex < transaction.outputs.length, \"Output index out of bounds\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 119,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(item.len > 0 && item.len <= 33, \"Item length must be between 1 and 33 bytes\");\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 139,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(!(dataByte0 == 0 && offset == 0), \"Scalar 0 should be encoded as 0x80\");\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 142,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(!(dataByte0 == 0 && dataLen > 1), \"Leading zeros are invalid\");\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 210,
          "vulnerability_to_line": null,
          "vulnerability_code": "        } else if (STRING_SHORT_START <= byte0 && byte0 < STRING_LONG_START) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 211,
          "vulnerability_to_line": null,
          "vulnerability_code": "            // The range of the first byte is between 0x80 and 0xb7 therefore it is a short string\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 212,
          "vulnerability_to_line": null,
          "vulnerability_code": "            // decodedLength is between 1 and 56 bytes\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 213,
          "vulnerability_to_line": null,
          "vulnerability_code": "            decodedLength = (byte0 - STRING_SHORT_START) + 1;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 214,
          "vulnerability_to_line": null,
          "vulnerability_code": "            if (decodedLength == 2){\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 215,
          "vulnerability_to_line": null,
          "vulnerability_code": "                uint256 byte1;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 216,
          "vulnerability_to_line": null,
          "vulnerability_code": "                // solhint-disable-next-line no-inline-assembly\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 217,
          "vulnerability_to_line": null,
          "vulnerability_code": "                assembly {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 218,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    byte1 := byte(0, mload(add(memPtr, 1)))\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 219,
          "vulnerability_to_line": null,
          "vulnerability_code": "                }\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 224,
          "vulnerability_to_line": null,
          "vulnerability_code": "        } else if (STRING_LONG_START <= byte0 && byte0 < LIST_SHORT_START) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 225,
          "vulnerability_to_line": null,
          "vulnerability_code": "            // The range of the first byte is between 0xb8 and 0xbf therefore it is a long string\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 226,
          "vulnerability_to_line": null,
          "vulnerability_code": "            // lengthLen is between 1 and 8 bytes\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 227,
          "vulnerability_to_line": null,
          "vulnerability_code": "            // dataLen is greater than 55 bytes\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 228,
          "vulnerability_to_line": null,
          "vulnerability_code": "            uint256 dataLen;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 229,
          "vulnerability_to_line": null,
          "vulnerability_code": "            uint256 byte1;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 230,
          "vulnerability_to_line": null,
          "vulnerability_code": "            uint256 lengthLen;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 231,
          "vulnerability_to_line": null,
          "vulnerability_code": "\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 232,
          "vulnerability_to_line": null,
          "vulnerability_code": "            // solhint-disable-next-line no-inline-assembly\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 233,
          "vulnerability_to_line": null,
          "vulnerability_code": "            assembly {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 249,
          "vulnerability_to_line": null,
          "vulnerability_code": "        } else if (LIST_SHORT_START <= byte0 && byte0 < LIST_LONG_START) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 250,
          "vulnerability_to_line": null,
          "vulnerability_code": "            // The range of the first byte is between 0xc0 and 0xf7 therefore it is a short list\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 251,
          "vulnerability_to_line": null,
          "vulnerability_code": "            // decodedLength is between 1 and 56 bytes\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 252,
          "vulnerability_to_line": null,
          "vulnerability_code": "            decodedLength = (byte0 - LIST_SHORT_START) + 1;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 253,
          "vulnerability_to_line": null,
          "vulnerability_code": "            offset = 1;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 254,
          "vulnerability_to_line": null,
          "vulnerability_code": "        } else {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 255,
          "vulnerability_to_line": null,
          "vulnerability_code": "            // The range of the first byte is between 0xf8 and 0xff therefore it is a long list\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 256,
          "vulnerability_to_line": null,
          "vulnerability_code": "            // lengthLen is between 1 and 8 bytes\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 257,
          "vulnerability_to_line": null,
          "vulnerability_code": "            // dataLen is greater than 55 bytes\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 258,
          "vulnerability_to_line": null,
          "vulnerability_code": "            uint256 dataLen;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 60,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 i = 0; i < items; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 184,
          "vulnerability_to_line": null,
          "vulnerability_code": "            count++;\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 334,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < outputList.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 53,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(listLength == item.len, \"Decoded RLP length for list is invalid\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 119,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(item.len > 0 && item.len <= 33, \"Item length must be between 1 and 33 bytes\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 122,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(itemLen == item.len, \"Decoded item length must be equal to the input data length\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 139,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(!(dataByte0 == 0 && offset == 0), \"Scalar 0 should be encoded as 0x80\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 183,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(currPtr <= endPtr, \"Invalid decoded length of RLP item found during counting items in a list\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 244,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(byte1 != 0, \"Invalid leading zeros in length of the length for a long string\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 274,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(byte1 != 0, \"Invalid leading zeros in length of the length for a long list\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        }
      ]
    },
    "slither": {
      "successfull_analysis": true,
      "errors": [
        "EXIT_CODE_15"
      ],
      "vulnerability_findings": [
        {
          "name": "constant-function",
          "vulnerability_from_line": 33,
          "vulnerability_to_line": 42,
          "vulnerability_code": "    function toRlpItem(bytes memory item) internal pure returns (RLPItem memory) {\n\n        uint256 memPtr;\n\n\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly {\n\n            memPtr := add(item, 0x20)\n\n        }\n\n\n\n        return RLPItem(item.length, memPtr);\n",
          "message": "RLPReader.toRlpItem (FungibleTokenOutputModel.sol#33-42) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 74,
          "vulnerability_to_line": 87,
          "vulnerability_code": "    function isList(RLPItem memory item) internal pure returns (bool) {\n\n        if (item.len == 0) return false;\n\n\n\n        uint8 byte0;\n\n        uint256 memPtr = item.memPtr;\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly {\n\n            byte0 := byte(0, mload(memPtr))\n\n        }\n\n\n\n        if (byte0 < LIST_SHORT_START)\n\n            return false;\n\n        return true;\n",
          "message": "RLPReader.isList (FungibleTokenOutputModel.sol#74-87) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 94,
          "vulnerability_to_line": 111,
          "vulnerability_code": "    function toAddress(RLPItem memory item) internal pure returns (address) {\n\n        require(item.len == 21, \"Item length must be 21\");\n\n        require(!isList(item), \"Item must not be a list\");\n\n\n\n        (uint256 itemLen, uint256 offset) = decodeLengthAndOffset(item.memPtr);\n\n        require(itemLen == 21, \"Decoded item length must be 21\");\n\n\n\n        uint256 dataMemPtr = item.memPtr + offset;\n\n        uint256 result;\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly {\n\n            result := mload(dataMemPtr)\n\n            // right shift by 12 to make bytes20\n\n            result := div(result, exp(256, 12))\n\n        }\n\n\n\n        return address(result);\n",
          "message": "RLPReader.toAddress (FungibleTokenOutputModel.sol#94-111) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 118,
          "vulnerability_to_line": 145,
          "vulnerability_code": "    function toUint(RLPItem memory item) internal pure returns (uint256) {\n\n        require(item.len > 0 && item.len <= 33, \"Item length must be between 1 and 33 bytes\");\n\n        require(!isList(item), \"Item must not be a list\");\n\n        (uint256 itemLen, uint256 offset) = decodeLengthAndOffset(item.memPtr);\n\n        require(itemLen == item.len, \"Decoded item length must be equal to the input data length\");\n\n\n\n        uint256 dataLen = itemLen - offset;\n\n\n\n        uint result;\n\n        uint dataByte0;\n\n        uint dataMemPtr = item.memPtr + offset;\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly {\n\n            result := mload(dataMemPtr)\n\n            dataByte0 := byte(0, result)\n\n            // shift to the correct location if necessary\n\n            if lt(dataLen, WORD_SIZE) {\n\n                result := div(result, exp(256, sub(WORD_SIZE, dataLen)))\n\n            }\n\n        }\n\n        // Special case: scalar 0 should be encoded as 0x80 and _not_ as 0x00\n\n        require(!(dataByte0 == 0 && offset == 0), \"Scalar 0 should be encoded as 0x80\");\n\n\n\n        // Disallow leading zeros\n\n        require(!(dataByte0 == 0 && dataLen > 1), \"Leading zeros are invalid\");\n\n\n\n        return result;\n",
          "message": "RLPReader.toUint (FungibleTokenOutputModel.sol#118-145) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 152,
          "vulnerability_to_line": 168,
          "vulnerability_code": "    function toBytes32(RLPItem memory item) internal pure returns (bytes32) {\n\n        // 1 byte for the length prefix\n\n        require(item.len == 33, \"Item length must be 33\");\n\n        require(!isList(item), \"Item must not be a list\");\n\n\n\n        (uint256 itemLen, uint256 offset) = decodeLengthAndOffset(item.memPtr);\n\n        require(itemLen == 33, \"Decoded item length must be 33\");\n\n\n\n        uint256 dataMemPtr = item.memPtr + offset;\n\n        bytes32 result;\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly {\n\n            result := mload(dataMemPtr)\n\n        }\n\n\n\n        return result;\n",
          "message": "RLPReader.toBytes32 (FungibleTokenOutputModel.sol#152-168) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 196,
          "vulnerability_to_line": 282,
          "vulnerability_code": "    function decodeLengthAndOffset(uint256 memPtr) internal pure returns (uint256, uint256) {\n\n        uint256 decodedLength;\n\n        uint256 offset;\n\n        uint256 byte0;\n\n\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly {\n\n            byte0 := byte(0, mload(memPtr))\n\n        }\n\n\n\n        if (byte0 < STRING_SHORT_START) {\n\n            // Item is a single byte\n\n            decodedLength = 1;\n\n            offset = 0;\n\n        } else if (STRING_SHORT_START <= byte0 && byte0 < STRING_LONG_START) {\n\n            // The range of the first byte is between 0x80 and 0xb7 therefore it is a short string\n\n            // decodedLength is between 1 and 56 bytes\n\n            decodedLength = (byte0 - STRING_SHORT_START) + 1;\n\n            if (decodedLength == 2){\n\n                uint256 byte1;\n\n                // solhint-disable-next-line no-inline-assembly\n\n                assembly {\n\n                    byte1 := byte(0, mload(add(memPtr, 1)))\n\n                }\n\n                // A single byte below 0x80 must be encoded as itself.\n\n                require(byte1 >= STRING_SHORT_START, \"Invalid short string encoding\");\n\n            }\n\n            offset = 1;\n\n        } else if (STRING_LONG_START <= byte0 && byte0 < LIST_SHORT_START) {\n\n            // The range of the first byte is between 0xb8 and 0xbf therefore it is a long string\n\n            // lengthLen is between 1 and 8 bytes\n\n            // dataLen is greater than 55 bytes\n\n            uint256 dataLen;\n\n            uint256 byte1;\n\n            uint256 lengthLen;\n\n\n\n            // solhint-disable-next-line no-inline-assembly\n\n            assembly {\n\n                lengthLen := sub(byte0, 0xb7) // The length of the length of the payload is encoded in the first byte.\n\n                memPtr := add(memPtr, 1) // skip over the first byte\n\n\n\n                // right shift to the correct position\n\n                dataLen := div(mload(memPtr), exp(256, sub(WORD_SIZE, lengthLen)))\n\n                decodedLength := add(dataLen, add(lengthLen, 1))\n\n                byte1 := byte(0, mload(memPtr))\n\n            }\n\n\n\n            // Check that the length has no leading zeros\n\n            require(byte1 != 0, \"Invalid leading zeros in length of the length for a long string\");\n\n            // Check that the value of length > MAX_SHORT_LEN\n\n            require(dataLen > MAX_SHORT_LEN, \"Invalid length for a long string\");\n\n            // Calculate the offset\n\n            offset = lengthLen + 1;\n\n        } else if (LIST_SHORT_START <= byte0 && byte0 < LIST_LONG_START) {\n\n            // The range of the first byte is between 0xc0 and 0xf7 therefore it is a short list\n\n            // decodedLength is between 1 and 56 bytes\n\n            decodedLength = (byte0 - LIST_SHORT_START) + 1;\n\n            offset = 1;\n\n        } else {\n\n            // The range of the first byte is between 0xf8 and 0xff therefore it is a long list\n\n            // lengthLen is between 1 and 8 bytes\n\n            // dataLen is greater than 55 bytes\n\n            uint256 dataLen;\n\n            uint256 byte1;\n\n            uint256 lengthLen;\n\n\n\n            // solhint-disable-next-line no-inline-assembly\n\n            assembly {\n\n                lengthLen := sub(byte0, 0xf7) // The length of the length of the payload is encoded in the first byte.\n\n                memPtr := add(memPtr, 1) // skip over the first byte\n\n\n\n                // right shift to the correct position\n\n                dataLen := div(mload(memPtr), exp(256, sub(WORD_SIZE, lengthLen)))\n\n                decodedLength := add(dataLen, add(lengthLen, 1))\n\n                byte1 := byte(0, mload(memPtr))\n\n            }\n\n\n\n            // Check that the length has no leading zeros\n\n            require(byte1 != 0, \"Invalid leading zeros in length of the length for a long list\");\n\n            // Check that the value of length > MAX_SHORT_LEN\n\n            require(dataLen > MAX_SHORT_LEN, \"Invalid length for a long list\");\n\n            // Calculate the offset\n\n            offset = lengthLen + 1;\n\n        }\n\n\n\n        return (decodedLength, offset);\n",
          "message": "RLPReader.decodeLengthAndOffset (FungibleTokenOutputModel.sol#196-282) is declared view but contains assembly code\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 33,
          "vulnerability_to_line": 42,
          "vulnerability_code": "    function toRlpItem(bytes memory item) internal pure returns (RLPItem memory) {\n\n        uint256 memPtr;\n\n\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly {\n\n            memPtr := add(item, 0x20)\n\n        }\n\n\n\n        return RLPItem(item.length, memPtr);\n",
          "message": "RLPReader.toRlpItem uses assembly (FungibleTokenOutputModel.sol#33-42)\n\t- FungibleTokenOutputModel.sol#37-39\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 74,
          "vulnerability_to_line": 87,
          "vulnerability_code": "    function isList(RLPItem memory item) internal pure returns (bool) {\n\n        if (item.len == 0) return false;\n\n\n\n        uint8 byte0;\n\n        uint256 memPtr = item.memPtr;\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly {\n\n            byte0 := byte(0, mload(memPtr))\n\n        }\n\n\n\n        if (byte0 < LIST_SHORT_START)\n\n            return false;\n\n        return true;\n",
          "message": "RLPReader.isList uses assembly (FungibleTokenOutputModel.sol#74-87)\n\t- FungibleTokenOutputModel.sol#80-82\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 94,
          "vulnerability_to_line": 111,
          "vulnerability_code": "    function toAddress(RLPItem memory item) internal pure returns (address) {\n\n        require(item.len == 21, \"Item length must be 21\");\n\n        require(!isList(item), \"Item must not be a list\");\n\n\n\n        (uint256 itemLen, uint256 offset) = decodeLengthAndOffset(item.memPtr);\n\n        require(itemLen == 21, \"Decoded item length must be 21\");\n\n\n\n        uint256 dataMemPtr = item.memPtr + offset;\n\n        uint256 result;\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly {\n\n            result := mload(dataMemPtr)\n\n            // right shift by 12 to make bytes20\n\n            result := div(result, exp(256, 12))\n\n        }\n\n\n\n        return address(result);\n",
          "message": "RLPReader.toAddress uses assembly (FungibleTokenOutputModel.sol#94-111)\n\t- FungibleTokenOutputModel.sol#104-108\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 118,
          "vulnerability_to_line": 145,
          "vulnerability_code": "    function toUint(RLPItem memory item) internal pure returns (uint256) {\n\n        require(item.len > 0 && item.len <= 33, \"Item length must be between 1 and 33 bytes\");\n\n        require(!isList(item), \"Item must not be a list\");\n\n        (uint256 itemLen, uint256 offset) = decodeLengthAndOffset(item.memPtr);\n\n        require(itemLen == item.len, \"Decoded item length must be equal to the input data length\");\n\n\n\n        uint256 dataLen = itemLen - offset;\n\n\n\n        uint result;\n\n        uint dataByte0;\n\n        uint dataMemPtr = item.memPtr + offset;\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly {\n\n            result := mload(dataMemPtr)\n\n            dataByte0 := byte(0, result)\n\n            // shift to the correct location if necessary\n\n            if lt(dataLen, WORD_SIZE) {\n\n                result := div(result, exp(256, sub(WORD_SIZE, dataLen)))\n\n            }\n\n        }\n\n        // Special case: scalar 0 should be encoded as 0x80 and _not_ as 0x00\n\n        require(!(dataByte0 == 0 && offset == 0), \"Scalar 0 should be encoded as 0x80\");\n\n\n\n        // Disallow leading zeros\n\n        require(!(dataByte0 == 0 && dataLen > 1), \"Leading zeros are invalid\");\n\n\n\n        return result;\n",
          "message": "RLPReader.toUint uses assembly (FungibleTokenOutputModel.sol#118-145)\n\t- FungibleTokenOutputModel.sol#130-137\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 152,
          "vulnerability_to_line": 168,
          "vulnerability_code": "    function toBytes32(RLPItem memory item) internal pure returns (bytes32) {\n\n        // 1 byte for the length prefix\n\n        require(item.len == 33, \"Item length must be 33\");\n\n        require(!isList(item), \"Item must not be a list\");\n\n\n\n        (uint256 itemLen, uint256 offset) = decodeLengthAndOffset(item.memPtr);\n\n        require(itemLen == 33, \"Decoded item length must be 33\");\n\n\n\n        uint256 dataMemPtr = item.memPtr + offset;\n\n        bytes32 result;\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly {\n\n            result := mload(dataMemPtr)\n\n        }\n\n\n\n        return result;\n",
          "message": "RLPReader.toBytes32 uses assembly (FungibleTokenOutputModel.sol#152-168)\n\t- FungibleTokenOutputModel.sol#163-165\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 196,
          "vulnerability_to_line": 282,
          "vulnerability_code": "    function decodeLengthAndOffset(uint256 memPtr) internal pure returns (uint256, uint256) {\n\n        uint256 decodedLength;\n\n        uint256 offset;\n\n        uint256 byte0;\n\n\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly {\n\n            byte0 := byte(0, mload(memPtr))\n\n        }\n\n\n\n        if (byte0 < STRING_SHORT_START) {\n\n            // Item is a single byte\n\n            decodedLength = 1;\n\n            offset = 0;\n\n        } else if (STRING_SHORT_START <= byte0 && byte0 < STRING_LONG_START) {\n\n            // The range of the first byte is between 0x80 and 0xb7 therefore it is a short string\n\n            // decodedLength is between 1 and 56 bytes\n\n            decodedLength = (byte0 - STRING_SHORT_START) + 1;\n\n            if (decodedLength == 2){\n\n                uint256 byte1;\n\n                // solhint-disable-next-line no-inline-assembly\n\n                assembly {\n\n                    byte1 := byte(0, mload(add(memPtr, 1)))\n\n                }\n\n                // A single byte below 0x80 must be encoded as itself.\n\n                require(byte1 >= STRING_SHORT_START, \"Invalid short string encoding\");\n\n            }\n\n            offset = 1;\n\n        } else if (STRING_LONG_START <= byte0 && byte0 < LIST_SHORT_START) {\n\n            // The range of the first byte is between 0xb8 and 0xbf therefore it is a long string\n\n            // lengthLen is between 1 and 8 bytes\n\n            // dataLen is greater than 55 bytes\n\n            uint256 dataLen;\n\n            uint256 byte1;\n\n            uint256 lengthLen;\n\n\n\n            // solhint-disable-next-line no-inline-assembly\n\n            assembly {\n\n                lengthLen := sub(byte0, 0xb7) // The length of the length of the payload is encoded in the first byte.\n\n                memPtr := add(memPtr, 1) // skip over the first byte\n\n\n\n                // right shift to the correct position\n\n                dataLen := div(mload(memPtr), exp(256, sub(WORD_SIZE, lengthLen)))\n\n                decodedLength := add(dataLen, add(lengthLen, 1))\n\n                byte1 := byte(0, mload(memPtr))\n\n            }\n\n\n\n            // Check that the length has no leading zeros\n\n            require(byte1 != 0, \"Invalid leading zeros in length of the length for a long string\");\n\n            // Check that the value of length > MAX_SHORT_LEN\n\n            require(dataLen > MAX_SHORT_LEN, \"Invalid length for a long string\");\n\n            // Calculate the offset\n\n            offset = lengthLen + 1;\n\n        } else if (LIST_SHORT_START <= byte0 && byte0 < LIST_LONG_START) {\n\n            // The range of the first byte is between 0xc0 and 0xf7 therefore it is a short list\n\n            // decodedLength is between 1 and 56 bytes\n\n            decodedLength = (byte0 - LIST_SHORT_START) + 1;\n\n            offset = 1;\n\n        } else {\n\n            // The range of the first byte is between 0xf8 and 0xff therefore it is a long list\n\n            // lengthLen is between 1 and 8 bytes\n\n            // dataLen is greater than 55 bytes\n\n            uint256 dataLen;\n\n            uint256 byte1;\n\n            uint256 lengthLen;\n\n\n\n            // solhint-disable-next-line no-inline-assembly\n\n            assembly {\n\n                lengthLen := sub(byte0, 0xf7) // The length of the length of the payload is encoded in the first byte.\n\n                memPtr := add(memPtr, 1) // skip over the first byte\n\n\n\n                // right shift to the correct position\n\n                dataLen := div(mload(memPtr), exp(256, sub(WORD_SIZE, lengthLen)))\n\n                decodedLength := add(dataLen, add(lengthLen, 1))\n\n                byte1 := byte(0, mload(memPtr))\n\n            }\n\n\n\n            // Check that the length has no leading zeros\n\n            require(byte1 != 0, \"Invalid leading zeros in length of the length for a long list\");\n\n            // Check that the value of length > MAX_SHORT_LEN\n\n            require(dataLen > MAX_SHORT_LEN, \"Invalid length for a long list\");\n\n            // Calculate the offset\n\n            offset = lengthLen + 1;\n\n        }\n\n\n\n        return (decodedLength, offset);\n",
          "message": "RLPReader.decodeLengthAndOffset uses assembly (FungibleTokenOutputModel.sol#196-282)\n\t- FungibleTokenOutputModel.sol#202-204\n\t- FungibleTokenOutputModel.sol#217-219\n\t- FungibleTokenOutputModel.sol#233-241\n\t- FungibleTokenOutputModel.sol#263-271\n"
        },
        {
          "name": "pragma",
          "vulnerability_from_line": 13,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity 0.5.11;\n",
          "message": "Different versions of Solidity is used in FungibleTokenOutputModel.sol:\n\t- Version used: ['0.5.11', 'ABIEncoderV2']\n\t- FungibleTokenOutputModel.sol#13 declares pragma solidity0.5.11\n\t- FungibleTokenOutputModel.sol#287 declares pragma solidity0.5.11\n\t- FungibleTokenOutputModel.sol#384 declares pragma solidity0.5.11\n\t- FungibleTokenOutputModel.sol#385 declares pragma experimentalABIEncoderV2\n"
        },
        {
          "name": "solc-version",
          "vulnerability_from_line": 13,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity 0.5.11;\n",
          "message": "Detected issues with version pragma in FungibleTokenOutputModel.sol:\n\t- pragma solidity0.5.11 (FungibleTokenOutputModel.sol#13): it allows old versions\n\t- pragma solidity0.5.11 (FungibleTokenOutputModel.sol#287): it allows old versions\n\t- pragma solidity0.5.11 (FungibleTokenOutputModel.sol#384): it allows old versions\n"
        },
        {
          "name": "unused-state",
          "vulnerability_from_line": 21,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint8 constant internal WORD_SIZE = 32;\n",
          "message": "RLPReader.WORD_SIZE (FungibleTokenOutputModel.sol#21) is never used in RLPReader\n"
        }
      ]
    },
    "smartcheck": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 16,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint8 constant internal STRING_SHORT_START = 0x80;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 17,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint8 constant internal STRING_LONG_START  = 0xb8;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 18,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint8 constant internal LIST_SHORT_START   = 0xc0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 19,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint8 constant internal LIST_LONG_START    = 0xf8;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 334,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < outputList.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 334,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < outputList.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 180,
          "vulnerability_to_line": null,
          "vulnerability_code": "        while (currPtr < endPtr) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 305,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint8 constant private TX_NUM_ITEMS = 5;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 33,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function toRlpItem(bytes memory item) internal pure returns (RLPItem memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 74,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function isList(RLPItem memory item) internal pure returns (bool) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 94,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function toAddress(RLPItem memory item) internal pure returns (address) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 118,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function toUint(RLPItem memory item) internal pure returns (uint256) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 152,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function toBytes32(RLPItem memory item) internal pure returns (bytes32) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 196,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function decodeLengthAndOffset(uint256 memPtr) internal pure returns (uint256, uint256) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 196,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function decodeLengthAndOffset(uint256 memPtr) internal pure returns (uint256, uint256) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 37,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 80,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 104,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 130,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 163,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 202,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 217,
          "vulnerability_to_line": null,
          "vulnerability_code": "                assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 233,
          "vulnerability_to_line": null,
          "vulnerability_code": "            assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 263,
          "vulnerability_to_line": null,
          "vulnerability_code": "            assembly {\n",
          "message": null
        }
      ]
    },
    "oyente": {
      "successfull_analysis": false,
      "errors": [
        "exception (IndexError: pop from empty list)"
      ],
      "vulnerability_findings": []
    },
    "mythril": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": []
    },
    "osiris": {
      "successfull_analysis": false,
      "errors": [
        "exception (IndexError: pop from empty list)"
      ],
      "vulnerability_findings": []
    }
  }
}