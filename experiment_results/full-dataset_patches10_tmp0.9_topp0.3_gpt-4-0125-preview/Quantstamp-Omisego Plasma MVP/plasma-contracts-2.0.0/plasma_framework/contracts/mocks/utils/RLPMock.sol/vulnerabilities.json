{
  "smartbugs_completed": true,
  "analyzer_results": {
    "semgrep": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 331,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < items.length; i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 60,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 i = 0; i < items; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 331,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < items.length; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 50,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(isList(item), \"Item is not a list\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 53,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(listLength == item.len, \"Decoded RLP length for list is invalid\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 95,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(item.len == 21, \"Item length must be 21\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 96,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(!isList(item), \"Item must not be a list\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 99,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(itemLen == 21, \"Decoded item length must be 21\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 119,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(item.len > 0 && item.len <= 33, \"Item length must be between 1 and 33 bytes\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 120,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(!isList(item), \"Item must not be a list\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 122,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(itemLen == item.len, \"Decoded item length must be equal to the input data length\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 139,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(!(dataByte0 == 0 && offset == 0), \"Scalar 0 should be encoded as 0x80\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 142,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(!(dataByte0 == 0 && dataLen > 1), \"Leading zeros are invalid\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 154,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(item.len == 33, \"Item length must be 33\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 155,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(!isList(item), \"Item must not be a list\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 158,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(itemLen == 33, \"Decoded item length must be 33\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 183,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(currPtr <= endPtr, \"Invalid decoded length of RLP item found during counting items in a list\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 221,
          "vulnerability_to_line": null,
          "vulnerability_code": "                require(byte1 >= STRING_SHORT_START, \"Invalid short string encoding\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 244,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(byte1 != 0, \"Invalid leading zeros in length of the length for a long string\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 246,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(dataLen > MAX_SHORT_LEN, \"Invalid length for a long string\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 274,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(byte1 != 0, \"Invalid leading zeros in length of the length for a long list\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 276,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(dataLen > MAX_SHORT_LEN, \"Invalid length for a long list\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 338,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(item.len > 0, \"Item length must be > 0\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 341,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(itemLen == item.len, \"Decoded RLP length is invalid\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 369,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(remainingLength < len, \"Remaining length not less than original length\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 119,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(item.len > 0 && item.len <= 33, \"Item length must be between 1 and 33 bytes\");\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 139,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(!(dataByte0 == 0 && offset == 0), \"Scalar 0 should be encoded as 0x80\");\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 142,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(!(dataByte0 == 0 && dataLen > 1), \"Leading zeros are invalid\");\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 210,
          "vulnerability_to_line": null,
          "vulnerability_code": "        } else if (STRING_SHORT_START <= byte0 && byte0 < STRING_LONG_START) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 211,
          "vulnerability_to_line": null,
          "vulnerability_code": "            // The range of the first byte is between 0x80 and 0xb7 therefore it is a short string\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 212,
          "vulnerability_to_line": null,
          "vulnerability_code": "            // decodedLength is between 1 and 56 bytes\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 213,
          "vulnerability_to_line": null,
          "vulnerability_code": "            decodedLength = (byte0 - STRING_SHORT_START) + 1;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 214,
          "vulnerability_to_line": null,
          "vulnerability_code": "            if (decodedLength == 2){\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 215,
          "vulnerability_to_line": null,
          "vulnerability_code": "                uint256 byte1;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 216,
          "vulnerability_to_line": null,
          "vulnerability_code": "                // solhint-disable-next-line no-inline-assembly\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 217,
          "vulnerability_to_line": null,
          "vulnerability_code": "                assembly {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 218,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    byte1 := byte(0, mload(add(memPtr, 1)))\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 219,
          "vulnerability_to_line": null,
          "vulnerability_code": "                }\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 224,
          "vulnerability_to_line": null,
          "vulnerability_code": "        } else if (STRING_LONG_START <= byte0 && byte0 < LIST_SHORT_START) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 225,
          "vulnerability_to_line": null,
          "vulnerability_code": "            // The range of the first byte is between 0xb8 and 0xbf therefore it is a long string\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 226,
          "vulnerability_to_line": null,
          "vulnerability_code": "            // lengthLen is between 1 and 8 bytes\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 227,
          "vulnerability_to_line": null,
          "vulnerability_code": "            // dataLen is greater than 55 bytes\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 228,
          "vulnerability_to_line": null,
          "vulnerability_code": "            uint256 dataLen;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 229,
          "vulnerability_to_line": null,
          "vulnerability_code": "            uint256 byte1;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 230,
          "vulnerability_to_line": null,
          "vulnerability_code": "            uint256 lengthLen;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 231,
          "vulnerability_to_line": null,
          "vulnerability_code": "\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 232,
          "vulnerability_to_line": null,
          "vulnerability_code": "            // solhint-disable-next-line no-inline-assembly\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 233,
          "vulnerability_to_line": null,
          "vulnerability_code": "            assembly {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 249,
          "vulnerability_to_line": null,
          "vulnerability_code": "        } else if (LIST_SHORT_START <= byte0 && byte0 < LIST_LONG_START) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 250,
          "vulnerability_to_line": null,
          "vulnerability_code": "            // The range of the first byte is between 0xc0 and 0xf7 therefore it is a short list\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 251,
          "vulnerability_to_line": null,
          "vulnerability_code": "            // decodedLength is between 1 and 56 bytes\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 252,
          "vulnerability_to_line": null,
          "vulnerability_code": "            decodedLength = (byte0 - LIST_SHORT_START) + 1;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 253,
          "vulnerability_to_line": null,
          "vulnerability_code": "            offset = 1;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 254,
          "vulnerability_to_line": null,
          "vulnerability_code": "        } else {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 255,
          "vulnerability_to_line": null,
          "vulnerability_code": "            // The range of the first byte is between 0xf8 and 0xff therefore it is a long list\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 256,
          "vulnerability_to_line": null,
          "vulnerability_code": "            // lengthLen is between 1 and 8 bytes\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 257,
          "vulnerability_to_line": null,
          "vulnerability_code": "            // dataLen is greater than 55 bytes\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 258,
          "vulnerability_to_line": null,
          "vulnerability_code": "            uint256 dataLen;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 60,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 i = 0; i < items; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 184,
          "vulnerability_to_line": null,
          "vulnerability_code": "            count++;\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 331,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < items.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 53,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(listLength == item.len, \"Decoded RLP length for list is invalid\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 119,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(item.len > 0 && item.len <= 33, \"Item length must be between 1 and 33 bytes\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 122,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(itemLen == item.len, \"Decoded item length must be equal to the input data length\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 139,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(!(dataByte0 == 0 && offset == 0), \"Scalar 0 should be encoded as 0x80\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 183,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(currPtr <= endPtr, \"Invalid decoded length of RLP item found during counting items in a list\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 244,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(byte1 != 0, \"Invalid leading zeros in length of the length for a long string\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 274,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(byte1 != 0, \"Invalid leading zeros in length of the length for a long list\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 369,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(remainingLength < len, \"Remaining length not less than original length\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        }
      ]
    },
    "slither": {
      "successfull_analysis": true,
      "errors": [
        "EXIT_CODE_37"
      ],
      "vulnerability_findings": [
        {
          "name": "constant-function",
          "vulnerability_from_line": 33,
          "vulnerability_to_line": 42,
          "vulnerability_code": "    function toRlpItem(bytes memory item) internal pure returns (RLPItem memory) {\n\n        uint256 memPtr;\n\n\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly {\n\n            memPtr := add(item, 0x20)\n\n        }\n\n\n\n        return RLPItem(item.length, memPtr);\n",
          "message": "RLPReader.toRlpItem (RLPMock.sol#33-42) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 74,
          "vulnerability_to_line": 87,
          "vulnerability_code": "    function isList(RLPItem memory item) internal pure returns (bool) {\n\n        if (item.len == 0) return false;\n\n\n\n        uint8 byte0;\n\n        uint256 memPtr = item.memPtr;\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly {\n\n            byte0 := byte(0, mload(memPtr))\n\n        }\n\n\n\n        if (byte0 < LIST_SHORT_START)\n\n            return false;\n\n        return true;\n",
          "message": "RLPReader.isList (RLPMock.sol#74-87) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 94,
          "vulnerability_to_line": 111,
          "vulnerability_code": "    function toAddress(RLPItem memory item) internal pure returns (address) {\n\n        require(item.len == 21, \"Item length must be 21\");\n\n        require(!isList(item), \"Item must not be a list\");\n\n\n\n        (uint256 itemLen, uint256 offset) = decodeLengthAndOffset(item.memPtr);\n\n        require(itemLen == 21, \"Decoded item length must be 21\");\n\n\n\n        uint256 dataMemPtr = item.memPtr + offset;\n\n        uint256 result;\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly {\n\n            result := mload(dataMemPtr)\n\n            // right shift by 12 to make bytes20\n\n            result := div(result, exp(256, 12))\n\n        }\n\n\n\n        return address(result);\n",
          "message": "RLPReader.toAddress (RLPMock.sol#94-111) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 118,
          "vulnerability_to_line": 145,
          "vulnerability_code": "    function toUint(RLPItem memory item) internal pure returns (uint256) {\n\n        require(item.len > 0 && item.len <= 33, \"Item length must be between 1 and 33 bytes\");\n\n        require(!isList(item), \"Item must not be a list\");\n\n        (uint256 itemLen, uint256 offset) = decodeLengthAndOffset(item.memPtr);\n\n        require(itemLen == item.len, \"Decoded item length must be equal to the input data length\");\n\n\n\n        uint256 dataLen = itemLen - offset;\n\n\n\n        uint result;\n\n        uint dataByte0;\n\n        uint dataMemPtr = item.memPtr + offset;\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly {\n\n            result := mload(dataMemPtr)\n\n            dataByte0 := byte(0, result)\n\n            // shift to the correct location if necessary\n\n            if lt(dataLen, WORD_SIZE) {\n\n                result := div(result, exp(256, sub(WORD_SIZE, dataLen)))\n\n            }\n\n        }\n\n        // Special case: scalar 0 should be encoded as 0x80 and _not_ as 0x00\n\n        require(!(dataByte0 == 0 && offset == 0), \"Scalar 0 should be encoded as 0x80\");\n\n\n\n        // Disallow leading zeros\n\n        require(!(dataByte0 == 0 && dataLen > 1), \"Leading zeros are invalid\");\n\n\n\n        return result;\n",
          "message": "RLPReader.toUint (RLPMock.sol#118-145) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 152,
          "vulnerability_to_line": 168,
          "vulnerability_code": "    function toBytes32(RLPItem memory item) internal pure returns (bytes32) {\n\n        // 1 byte for the length prefix\n\n        require(item.len == 33, \"Item length must be 33\");\n\n        require(!isList(item), \"Item must not be a list\");\n\n\n\n        (uint256 itemLen, uint256 offset) = decodeLengthAndOffset(item.memPtr);\n\n        require(itemLen == 33, \"Decoded item length must be 33\");\n\n\n\n        uint256 dataMemPtr = item.memPtr + offset;\n\n        bytes32 result;\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly {\n\n            result := mload(dataMemPtr)\n\n        }\n\n\n\n        return result;\n",
          "message": "RLPReader.toBytes32 (RLPMock.sol#152-168) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 196,
          "vulnerability_to_line": 282,
          "vulnerability_code": "    function decodeLengthAndOffset(uint256 memPtr) internal pure returns (uint256, uint256) {\n\n        uint256 decodedLength;\n\n        uint256 offset;\n\n        uint256 byte0;\n\n\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly {\n\n            byte0 := byte(0, mload(memPtr))\n\n        }\n\n\n\n        if (byte0 < STRING_SHORT_START) {\n\n            // Item is a single byte\n\n            decodedLength = 1;\n\n            offset = 0;\n\n        } else if (STRING_SHORT_START <= byte0 && byte0 < STRING_LONG_START) {\n\n            // The range of the first byte is between 0x80 and 0xb7 therefore it is a short string\n\n            // decodedLength is between 1 and 56 bytes\n\n            decodedLength = (byte0 - STRING_SHORT_START) + 1;\n\n            if (decodedLength == 2){\n\n                uint256 byte1;\n\n                // solhint-disable-next-line no-inline-assembly\n\n                assembly {\n\n                    byte1 := byte(0, mload(add(memPtr, 1)))\n\n                }\n\n                // A single byte below 0x80 must be encoded as itself.\n\n                require(byte1 >= STRING_SHORT_START, \"Invalid short string encoding\");\n\n            }\n\n            offset = 1;\n\n        } else if (STRING_LONG_START <= byte0 && byte0 < LIST_SHORT_START) {\n\n            // The range of the first byte is between 0xb8 and 0xbf therefore it is a long string\n\n            // lengthLen is between 1 and 8 bytes\n\n            // dataLen is greater than 55 bytes\n\n            uint256 dataLen;\n\n            uint256 byte1;\n\n            uint256 lengthLen;\n\n\n\n            // solhint-disable-next-line no-inline-assembly\n\n            assembly {\n\n                lengthLen := sub(byte0, 0xb7) // The length of the length of the payload is encoded in the first byte.\n\n                memPtr := add(memPtr, 1) // skip over the first byte\n\n\n\n                // right shift to the correct position\n\n                dataLen := div(mload(memPtr), exp(256, sub(WORD_SIZE, lengthLen)))\n\n                decodedLength := add(dataLen, add(lengthLen, 1))\n\n                byte1 := byte(0, mload(memPtr))\n\n            }\n\n\n\n            // Check that the length has no leading zeros\n\n            require(byte1 != 0, \"Invalid leading zeros in length of the length for a long string\");\n\n            // Check that the value of length > MAX_SHORT_LEN\n\n            require(dataLen > MAX_SHORT_LEN, \"Invalid length for a long string\");\n\n            // Calculate the offset\n\n            offset = lengthLen + 1;\n\n        } else if (LIST_SHORT_START <= byte0 && byte0 < LIST_LONG_START) {\n\n            // The range of the first byte is between 0xc0 and 0xf7 therefore it is a short list\n\n            // decodedLength is between 1 and 56 bytes\n\n            decodedLength = (byte0 - LIST_SHORT_START) + 1;\n\n            offset = 1;\n\n        } else {\n\n            // The range of the first byte is between 0xf8 and 0xff therefore it is a long list\n\n            // lengthLen is between 1 and 8 bytes\n\n            // dataLen is greater than 55 bytes\n\n            uint256 dataLen;\n\n            uint256 byte1;\n\n            uint256 lengthLen;\n\n\n\n            // solhint-disable-next-line no-inline-assembly\n\n            assembly {\n\n                lengthLen := sub(byte0, 0xf7) // The length of the length of the payload is encoded in the first byte.\n\n                memPtr := add(memPtr, 1) // skip over the first byte\n\n\n\n                // right shift to the correct position\n\n                dataLen := div(mload(memPtr), exp(256, sub(WORD_SIZE, lengthLen)))\n\n                decodedLength := add(dataLen, add(lengthLen, 1))\n\n                byte1 := byte(0, mload(memPtr))\n\n            }\n\n\n\n            // Check that the length has no leading zeros\n\n            require(byte1 != 0, \"Invalid leading zeros in length of the length for a long list\");\n\n            // Check that the value of length > MAX_SHORT_LEN\n\n            require(dataLen > MAX_SHORT_LEN, \"Invalid length for a long list\");\n\n            // Calculate the offset\n\n            offset = lengthLen + 1;\n\n        }\n\n\n\n        return (decodedLength, offset);\n",
          "message": "RLPReader.decodeLengthAndOffset (RLPMock.sol#196-282) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 337,
          "vulnerability_to_line": 353,
          "vulnerability_code": "    function toBytes(RLPReader.RLPItem memory item) internal pure returns (bytes memory) {\n\n        require(item.len > 0, \"Item length must be > 0\");\n\n\n\n        (uint256 itemLen, uint256 offset) = RLPReader.decodeLengthAndOffset(item.memPtr);\n\n        require(itemLen == item.len, \"Decoded RLP length is invalid\");\n\n        uint len = itemLen - offset;\n\n        bytes memory result = new bytes(len);\n\n\n\n        uint destPtr;\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly {\n\n            destPtr := add(0x20, result)\n\n        }\n\n\n\n        copyUnsafe(item.memPtr + offset, destPtr, len);\n\n        return result;\n",
          "message": "RLPMock.toBytes (RLPMock.sol#337-353) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 355,
          "vulnerability_to_line": 381,
          "vulnerability_code": "    function copyUnsafe(uint src, uint dest, uint len) private pure {\n\n        if (len == 0) return;\n\n        uint remainingLength = len;\n\n\n\n        // copy as many word sizes as possible\n\n        for (uint i = WORD_SIZE; len >= i; i += WORD_SIZE) {\n\n            // solhint-disable-next-line no-inline-assembly\n\n            assembly {\n\n                mstore(dest, mload(src))\n\n            }\n\n\n\n            src += WORD_SIZE;\n\n            dest += WORD_SIZE;\n\n            remainingLength -= WORD_SIZE;\n\n            require(remainingLength < len, \"Remaining length not less than original length\");\n\n        }\n\n\n\n        // left over bytes. Mask is used to remove unwanted bytes from the word\n\n        uint mask = 256 ** (WORD_SIZE - remainingLength) - 1;\n\n\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly {\n\n            let srcpart := and(mload(src), not(mask)) // zero out src\n\n            let destpart := and(mload(dest), mask) // retrieve the bytes\n\n            mstore(dest, or(destpart, srcpart))\n\n        }\n",
          "message": "RLPMock.copyUnsafe (RLPMock.sol#355-381) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 383,
          "vulnerability_to_line": 395,
          "vulnerability_code": "    function toRlpBytes(RLPReader.RLPItem memory item) internal pure returns (bytes memory) {\n\n        bytes memory result = new bytes(item.len);\n\n        if (result.length == 0) return result;\n\n\n\n        uint resultPtr;\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly {\n\n            resultPtr := add(0x20, result)\n\n        }\n\n\n\n        copyUnsafe(item.memPtr, resultPtr, item.len);\n\n        return result;\n",
          "message": "RLPMock.toRlpBytes (RLPMock.sol#383-395) is declared view but contains assembly code\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 33,
          "vulnerability_to_line": 42,
          "vulnerability_code": "    function toRlpItem(bytes memory item) internal pure returns (RLPItem memory) {\n\n        uint256 memPtr;\n\n\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly {\n\n            memPtr := add(item, 0x20)\n\n        }\n\n\n\n        return RLPItem(item.length, memPtr);\n",
          "message": "RLPReader.toRlpItem uses assembly (RLPMock.sol#33-42)\n\t- RLPMock.sol#37-39\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 74,
          "vulnerability_to_line": 87,
          "vulnerability_code": "    function isList(RLPItem memory item) internal pure returns (bool) {\n\n        if (item.len == 0) return false;\n\n\n\n        uint8 byte0;\n\n        uint256 memPtr = item.memPtr;\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly {\n\n            byte0 := byte(0, mload(memPtr))\n\n        }\n\n\n\n        if (byte0 < LIST_SHORT_START)\n\n            return false;\n\n        return true;\n",
          "message": "RLPReader.isList uses assembly (RLPMock.sol#74-87)\n\t- RLPMock.sol#80-82\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 94,
          "vulnerability_to_line": 111,
          "vulnerability_code": "    function toAddress(RLPItem memory item) internal pure returns (address) {\n\n        require(item.len == 21, \"Item length must be 21\");\n\n        require(!isList(item), \"Item must not be a list\");\n\n\n\n        (uint256 itemLen, uint256 offset) = decodeLengthAndOffset(item.memPtr);\n\n        require(itemLen == 21, \"Decoded item length must be 21\");\n\n\n\n        uint256 dataMemPtr = item.memPtr + offset;\n\n        uint256 result;\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly {\n\n            result := mload(dataMemPtr)\n\n            // right shift by 12 to make bytes20\n\n            result := div(result, exp(256, 12))\n\n        }\n\n\n\n        return address(result);\n",
          "message": "RLPReader.toAddress uses assembly (RLPMock.sol#94-111)\n\t- RLPMock.sol#104-108\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 118,
          "vulnerability_to_line": 145,
          "vulnerability_code": "    function toUint(RLPItem memory item) internal pure returns (uint256) {\n\n        require(item.len > 0 && item.len <= 33, \"Item length must be between 1 and 33 bytes\");\n\n        require(!isList(item), \"Item must not be a list\");\n\n        (uint256 itemLen, uint256 offset) = decodeLengthAndOffset(item.memPtr);\n\n        require(itemLen == item.len, \"Decoded item length must be equal to the input data length\");\n\n\n\n        uint256 dataLen = itemLen - offset;\n\n\n\n        uint result;\n\n        uint dataByte0;\n\n        uint dataMemPtr = item.memPtr + offset;\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly {\n\n            result := mload(dataMemPtr)\n\n            dataByte0 := byte(0, result)\n\n            // shift to the correct location if necessary\n\n            if lt(dataLen, WORD_SIZE) {\n\n                result := div(result, exp(256, sub(WORD_SIZE, dataLen)))\n\n            }\n\n        }\n\n        // Special case: scalar 0 should be encoded as 0x80 and _not_ as 0x00\n\n        require(!(dataByte0 == 0 && offset == 0), \"Scalar 0 should be encoded as 0x80\");\n\n\n\n        // Disallow leading zeros\n\n        require(!(dataByte0 == 0 && dataLen > 1), \"Leading zeros are invalid\");\n\n\n\n        return result;\n",
          "message": "RLPReader.toUint uses assembly (RLPMock.sol#118-145)\n\t- RLPMock.sol#130-137\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 152,
          "vulnerability_to_line": 168,
          "vulnerability_code": "    function toBytes32(RLPItem memory item) internal pure returns (bytes32) {\n\n        // 1 byte for the length prefix\n\n        require(item.len == 33, \"Item length must be 33\");\n\n        require(!isList(item), \"Item must not be a list\");\n\n\n\n        (uint256 itemLen, uint256 offset) = decodeLengthAndOffset(item.memPtr);\n\n        require(itemLen == 33, \"Decoded item length must be 33\");\n\n\n\n        uint256 dataMemPtr = item.memPtr + offset;\n\n        bytes32 result;\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly {\n\n            result := mload(dataMemPtr)\n\n        }\n\n\n\n        return result;\n",
          "message": "RLPReader.toBytes32 uses assembly (RLPMock.sol#152-168)\n\t- RLPMock.sol#163-165\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 196,
          "vulnerability_to_line": 282,
          "vulnerability_code": "    function decodeLengthAndOffset(uint256 memPtr) internal pure returns (uint256, uint256) {\n\n        uint256 decodedLength;\n\n        uint256 offset;\n\n        uint256 byte0;\n\n\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly {\n\n            byte0 := byte(0, mload(memPtr))\n\n        }\n\n\n\n        if (byte0 < STRING_SHORT_START) {\n\n            // Item is a single byte\n\n            decodedLength = 1;\n\n            offset = 0;\n\n        } else if (STRING_SHORT_START <= byte0 && byte0 < STRING_LONG_START) {\n\n            // The range of the first byte is between 0x80 and 0xb7 therefore it is a short string\n\n            // decodedLength is between 1 and 56 bytes\n\n            decodedLength = (byte0 - STRING_SHORT_START) + 1;\n\n            if (decodedLength == 2){\n\n                uint256 byte1;\n\n                // solhint-disable-next-line no-inline-assembly\n\n                assembly {\n\n                    byte1 := byte(0, mload(add(memPtr, 1)))\n\n                }\n\n                // A single byte below 0x80 must be encoded as itself.\n\n                require(byte1 >= STRING_SHORT_START, \"Invalid short string encoding\");\n\n            }\n\n            offset = 1;\n\n        } else if (STRING_LONG_START <= byte0 && byte0 < LIST_SHORT_START) {\n\n            // The range of the first byte is between 0xb8 and 0xbf therefore it is a long string\n\n            // lengthLen is between 1 and 8 bytes\n\n            // dataLen is greater than 55 bytes\n\n            uint256 dataLen;\n\n            uint256 byte1;\n\n            uint256 lengthLen;\n\n\n\n            // solhint-disable-next-line no-inline-assembly\n\n            assembly {\n\n                lengthLen := sub(byte0, 0xb7) // The length of the length of the payload is encoded in the first byte.\n\n                memPtr := add(memPtr, 1) // skip over the first byte\n\n\n\n                // right shift to the correct position\n\n                dataLen := div(mload(memPtr), exp(256, sub(WORD_SIZE, lengthLen)))\n\n                decodedLength := add(dataLen, add(lengthLen, 1))\n\n                byte1 := byte(0, mload(memPtr))\n\n            }\n\n\n\n            // Check that the length has no leading zeros\n\n            require(byte1 != 0, \"Invalid leading zeros in length of the length for a long string\");\n\n            // Check that the value of length > MAX_SHORT_LEN\n\n            require(dataLen > MAX_SHORT_LEN, \"Invalid length for a long string\");\n\n            // Calculate the offset\n\n            offset = lengthLen + 1;\n\n        } else if (LIST_SHORT_START <= byte0 && byte0 < LIST_LONG_START) {\n\n            // The range of the first byte is between 0xc0 and 0xf7 therefore it is a short list\n\n            // decodedLength is between 1 and 56 bytes\n\n            decodedLength = (byte0 - LIST_SHORT_START) + 1;\n\n            offset = 1;\n\n        } else {\n\n            // The range of the first byte is between 0xf8 and 0xff therefore it is a long list\n\n            // lengthLen is between 1 and 8 bytes\n\n            // dataLen is greater than 55 bytes\n\n            uint256 dataLen;\n\n            uint256 byte1;\n\n            uint256 lengthLen;\n\n\n\n            // solhint-disable-next-line no-inline-assembly\n\n            assembly {\n\n                lengthLen := sub(byte0, 0xf7) // The length of the length of the payload is encoded in the first byte.\n\n                memPtr := add(memPtr, 1) // skip over the first byte\n\n\n\n                // right shift to the correct position\n\n                dataLen := div(mload(memPtr), exp(256, sub(WORD_SIZE, lengthLen)))\n\n                decodedLength := add(dataLen, add(lengthLen, 1))\n\n                byte1 := byte(0, mload(memPtr))\n\n            }\n\n\n\n            // Check that the length has no leading zeros\n\n            require(byte1 != 0, \"Invalid leading zeros in length of the length for a long list\");\n\n            // Check that the value of length > MAX_SHORT_LEN\n\n            require(dataLen > MAX_SHORT_LEN, \"Invalid length for a long list\");\n\n            // Calculate the offset\n\n            offset = lengthLen + 1;\n\n        }\n\n\n\n        return (decodedLength, offset);\n",
          "message": "RLPReader.decodeLengthAndOffset uses assembly (RLPMock.sol#196-282)\n\t- RLPMock.sol#202-204\n\t- RLPMock.sol#217-219\n\t- RLPMock.sol#233-241\n\t- RLPMock.sol#263-271\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 337,
          "vulnerability_to_line": 353,
          "vulnerability_code": "    function toBytes(RLPReader.RLPItem memory item) internal pure returns (bytes memory) {\n\n        require(item.len > 0, \"Item length must be > 0\");\n\n\n\n        (uint256 itemLen, uint256 offset) = RLPReader.decodeLengthAndOffset(item.memPtr);\n\n        require(itemLen == item.len, \"Decoded RLP length is invalid\");\n\n        uint len = itemLen - offset;\n\n        bytes memory result = new bytes(len);\n\n\n\n        uint destPtr;\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly {\n\n            destPtr := add(0x20, result)\n\n        }\n\n\n\n        copyUnsafe(item.memPtr + offset, destPtr, len);\n\n        return result;\n",
          "message": "RLPMock.toBytes uses assembly (RLPMock.sol#337-353)\n\t- RLPMock.sol#347-349\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 355,
          "vulnerability_to_line": 381,
          "vulnerability_code": "    function copyUnsafe(uint src, uint dest, uint len) private pure {\n\n        if (len == 0) return;\n\n        uint remainingLength = len;\n\n\n\n        // copy as many word sizes as possible\n\n        for (uint i = WORD_SIZE; len >= i; i += WORD_SIZE) {\n\n            // solhint-disable-next-line no-inline-assembly\n\n            assembly {\n\n                mstore(dest, mload(src))\n\n            }\n\n\n\n            src += WORD_SIZE;\n\n            dest += WORD_SIZE;\n\n            remainingLength -= WORD_SIZE;\n\n            require(remainingLength < len, \"Remaining length not less than original length\");\n\n        }\n\n\n\n        // left over bytes. Mask is used to remove unwanted bytes from the word\n\n        uint mask = 256 ** (WORD_SIZE - remainingLength) - 1;\n\n\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly {\n\n            let srcpart := and(mload(src), not(mask)) // zero out src\n\n            let destpart := and(mload(dest), mask) // retrieve the bytes\n\n            mstore(dest, or(destpart, srcpart))\n\n        }\n",
          "message": "RLPMock.copyUnsafe uses assembly (RLPMock.sol#355-381)\n\t- RLPMock.sol#362-364\n\t- RLPMock.sol#376-380\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 383,
          "vulnerability_to_line": 395,
          "vulnerability_code": "    function toRlpBytes(RLPReader.RLPItem memory item) internal pure returns (bytes memory) {\n\n        bytes memory result = new bytes(item.len);\n\n        if (result.length == 0) return result;\n\n\n\n        uint resultPtr;\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly {\n\n            resultPtr := add(0x20, result)\n\n        }\n\n\n\n        copyUnsafe(item.memPtr, resultPtr, item.len);\n\n        return result;\n",
          "message": "RLPMock.toRlpBytes uses assembly (RLPMock.sol#383-395)\n\t- RLPMock.sol#389-391\n"
        },
        {
          "name": "pragma",
          "vulnerability_from_line": 13,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity 0.5.11;\n",
          "message": "Different versions of Solidity is used in RLPMock.sol:\n\t- Version used: ['0.5.11', 'ABIEncoderV2']\n\t- RLPMock.sol#13 declares pragma solidity0.5.11\n\t- RLPMock.sol#287 declares pragma solidity0.5.11\n\t- RLPMock.sol#289 declares pragma experimentalABIEncoderV2\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 298,
          "vulnerability_to_line": 300,
          "vulnerability_code": "    function decodeBytes32(bytes memory _data) public pure returns (bytes32) {\n\n        return _data.toRlpItem().toBytes32();\n",
          "message": "RLPMock.decodeBytes32 (RLPMock.sol#298-300) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 302,
          "vulnerability_to_line": 304,
          "vulnerability_code": "    function decodeAddress(bytes memory _data) public pure returns (address) {\n\n        return _data.toRlpItem().toAddress();\n",
          "message": "RLPMock.decodeAddress (RLPMock.sol#302-304) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 306,
          "vulnerability_to_line": 308,
          "vulnerability_code": "    function decodeBytes20(bytes memory _data) public pure returns (bytes20) {\n\n        return bytes20(_data.toRlpItem().toAddress());\n",
          "message": "RLPMock.decodeBytes20 (RLPMock.sol#306-308) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 310,
          "vulnerability_to_line": 312,
          "vulnerability_code": "    function decodeBytes(bytes memory _data) public pure returns (bytes memory) {\n\n        return toBytes(_data.toRlpItem());\n",
          "message": "RLPMock.decodeBytes (RLPMock.sol#310-312) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 314,
          "vulnerability_to_line": 316,
          "vulnerability_code": "    function decodeUint(bytes memory _data) public pure returns (uint) {\n\n        return _data.toRlpItem().toUint();\n",
          "message": "RLPMock.decodeUint (RLPMock.sol#314-316) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 318,
          "vulnerability_to_line": 320,
          "vulnerability_code": "    function decodeInt(bytes memory _data) public pure returns (int) {\n\n        return int(_data.toRlpItem().toUint());\n",
          "message": "RLPMock.decodeInt (RLPMock.sol#318-320) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 322,
          "vulnerability_to_line": 324,
          "vulnerability_code": "    function decodeString(bytes memory _data) public pure returns (string memory) {\n\n        return string(toBytes(_data.toRlpItem()));\n",
          "message": "RLPMock.decodeString (RLPMock.sol#322-324) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 326,
          "vulnerability_to_line": 335,
          "vulnerability_code": "    function decodeList(bytes memory _data) public pure returns (bytes[] memory) {\n\n\n\n        RLPReader.RLPItem[] memory items = _data.toRlpItem().toList();\n\n\n\n        bytes[] memory result =  new bytes[](items.length);\n\n        for (uint i = 0; i < items.length; i++) {\n\n            result[i] = toRlpBytes(items[i]);\n\n        }\n\n        return result;\n",
          "message": "RLPMock.decodeList (RLPMock.sol#326-335) should be declared external\n"
        },
        {
          "name": "solc-version",
          "vulnerability_from_line": 13,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity 0.5.11;\n",
          "message": "Detected issues with version pragma in RLPMock.sol:\n\t- pragma solidity0.5.11 (RLPMock.sol#13): it allows old versions\n\t- pragma solidity0.5.11 (RLPMock.sol#287): it allows old versions\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 298,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function decodeBytes32(bytes memory _data) public pure returns (bytes32) {\n",
          "message": "Parameter '_data' of RLPMock.decodeBytes32 (RLPMock.sol#298) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 302,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function decodeAddress(bytes memory _data) public pure returns (address) {\n",
          "message": "Parameter '_data' of RLPMock.decodeAddress (RLPMock.sol#302) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 306,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function decodeBytes20(bytes memory _data) public pure returns (bytes20) {\n",
          "message": "Parameter '_data' of RLPMock.decodeBytes20 (RLPMock.sol#306) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 310,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function decodeBytes(bytes memory _data) public pure returns (bytes memory) {\n",
          "message": "Parameter '_data' of RLPMock.decodeBytes (RLPMock.sol#310) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 314,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function decodeUint(bytes memory _data) public pure returns (uint) {\n",
          "message": "Parameter '_data' of RLPMock.decodeUint (RLPMock.sol#314) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 318,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function decodeInt(bytes memory _data) public pure returns (int) {\n",
          "message": "Parameter '_data' of RLPMock.decodeInt (RLPMock.sol#318) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 322,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function decodeString(bytes memory _data) public pure returns (string memory) {\n",
          "message": "Parameter '_data' of RLPMock.decodeString (RLPMock.sol#322) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 326,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function decodeList(bytes memory _data) public pure returns (bytes[] memory) {\n",
          "message": "Parameter '_data' of RLPMock.decodeList (RLPMock.sol#326) is not in mixedCase\n"
        },
        {
          "name": "unused-state",
          "vulnerability_from_line": 21,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint8 constant internal WORD_SIZE = 32;\n",
          "message": "RLPReader.WORD_SIZE (RLPMock.sol#21) is never used in RLPReader\n"
        }
      ]
    },
    "smartcheck": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 16,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint8 constant internal STRING_SHORT_START = 0x80;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 17,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint8 constant internal STRING_LONG_START  = 0xb8;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 18,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint8 constant internal LIST_SHORT_START   = 0xc0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 19,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint8 constant internal LIST_LONG_START    = 0xf8;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 331,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < items.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 360,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = WORD_SIZE; len >= i; i += WORD_SIZE) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 331,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < items.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 180,
          "vulnerability_to_line": null,
          "vulnerability_code": "        while (currPtr < endPtr) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 33,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function toRlpItem(bytes memory item) internal pure returns (RLPItem memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 74,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function isList(RLPItem memory item) internal pure returns (bool) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 94,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function toAddress(RLPItem memory item) internal pure returns (address) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 118,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function toUint(RLPItem memory item) internal pure returns (uint256) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 152,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function toBytes32(RLPItem memory item) internal pure returns (bytes32) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 196,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function decodeLengthAndOffset(uint256 memPtr) internal pure returns (uint256, uint256) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 337,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function toBytes(RLPReader.RLPItem memory item) internal pure returns (bytes memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 355,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function copyUnsafe(uint src, uint dest, uint len) private pure {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 383,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function toRlpBytes(RLPReader.RLPItem memory item) internal pure returns (bytes memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 196,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function decodeLengthAndOffset(uint256 memPtr) internal pure returns (uint256, uint256) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 37,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 80,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 104,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 130,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 163,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 202,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 217,
          "vulnerability_to_line": null,
          "vulnerability_code": "                assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 233,
          "vulnerability_to_line": null,
          "vulnerability_code": "            assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 263,
          "vulnerability_to_line": null,
          "vulnerability_code": "            assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 347,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 362,
          "vulnerability_to_line": null,
          "vulnerability_code": "            assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 376,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 389,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        }
      ]
    },
    "oyente": {
      "successfull_analysis": false,
      "errors": [
        "exception (RuntimeError: Source map error, unknown name(SHR) or instr_name(INVALID))"
      ],
      "vulnerability_findings": []
    },
    "mythril": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "Integer Arithmetic Bugs (SWC 101)",
          "vulnerability_from_line": 135,
          "vulnerability_to_line": null,
          "vulnerability_code": "                result := div(result, exp(256, sub(WORD_SIZE, dataLen)))\n",
          "message": "The arithmetic operator can overflow.\nIt is possible to cause an integer overflow or underflow in the arithmetic operation. \nClassification: SWC-101"
        },
        {
          "name": "Integer Arithmetic Bugs (SWC 101)",
          "vulnerability_from_line": 135,
          "vulnerability_to_line": null,
          "vulnerability_code": "                result := div(result, exp(256, sub(WORD_SIZE, dataLen)))\n",
          "message": "The arithmetic operator can overflow.\nIt is possible to cause an integer overflow or underflow in the arithmetic operation. \nClassification: SWC-101"
        }
      ]
    },
    "osiris": {
      "successfull_analysis": false,
      "errors": [
        "UNKNOWN INSTRUCTION: SHR",
        "exception (IndexError: pop from empty list)"
      ],
      "vulnerability_findings": []
    }
  }
}