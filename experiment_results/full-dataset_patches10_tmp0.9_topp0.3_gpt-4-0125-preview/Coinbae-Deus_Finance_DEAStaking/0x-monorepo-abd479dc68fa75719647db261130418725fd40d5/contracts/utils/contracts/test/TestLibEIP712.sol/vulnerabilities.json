{
  "smartbugs_completed": true,
  "analyzer_results": {
    "semgrep": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": []
    },
    "slither": {
      "successfull_analysis": true,
      "errors": [
        "EXIT_CODE_5"
      ],
      "vulnerability_findings": [
        {
          "name": "constant-function",
          "vulnerability_from_line": 42,
          "vulnerability_to_line": 82,
          "vulnerability_code": "    function hashEIP712Domain(\n\n        string memory name,\n\n        string memory version,\n\n        uint256 chainId,\n\n        address verifyingContractAddress\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes32 result)\n\n    {\n\n        bytes32 schemaHash = _EIP712_DOMAIN_SEPARATOR_SCHEMA_HASH;\n\n\n\n        // Assembly for more efficient computing:\n\n        // keccak256(abi.encodePacked(\n\n        //     _EIP712_DOMAIN_SEPARATOR_SCHEMA_HASH,\n\n        //     keccak256(bytes(name)),\n\n        //     keccak256(bytes(version)),\n\n        //     chainId,\n\n        //     uint256(verifyingContractAddress)\n\n        // ))\n\n\n\n        assembly {\n\n            // Calculate hashes of dynamic data\n\n            let nameHash := keccak256(add(name, 32), mload(name))\n\n            let versionHash := keccak256(add(version, 32), mload(version))\n\n\n\n            // Load free memory pointer\n\n            let memPtr := mload(64)\n\n\n\n            // Store params in memory\n\n            mstore(memPtr, schemaHash)\n\n            mstore(add(memPtr, 32), nameHash)\n\n            mstore(add(memPtr, 64), versionHash)\n\n            mstore(add(memPtr, 96), chainId)\n\n            mstore(add(memPtr, 128), verifyingContractAddress)\n\n\n\n            // Compute hash\n\n            result := keccak256(memPtr, 160)\n\n        }\n\n        return result;\n",
          "message": "LibEIP712.hashEIP712Domain (TestLibEIP712.sol#42-82) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 89,
          "vulnerability_to_line": 113,
          "vulnerability_code": "    function hashEIP712Message(bytes32 eip712DomainHash, bytes32 hashStruct)\n\n        internal\n\n        pure\n\n        returns (bytes32 result)\n\n    {\n\n        // Assembly for more efficient computing:\n\n        // keccak256(abi.encodePacked(\n\n        //     EIP191_HEADER,\n\n        //     EIP712_DOMAIN_HASH,\n\n        //     hashStruct\n\n        // ));\n\n\n\n        assembly {\n\n            // Load free memory pointer\n\n            let memPtr := mload(64)\n\n\n\n            mstore(memPtr, 0x1901000000000000000000000000000000000000000000000000000000000000)  // EIP191 header\n\n            mstore(add(memPtr, 2), eip712DomainHash)                                            // EIP712 domain hash\n\n            mstore(add(memPtr, 34), hashStruct)                                                 // Hash of struct\n\n\n\n            // Compute hash\n\n            result := keccak256(memPtr, 66)\n\n        }\n\n        return result;\n",
          "message": "LibEIP712.hashEIP712Message (TestLibEIP712.sol#89-113) is declared view but contains assembly code\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 42,
          "vulnerability_to_line": 82,
          "vulnerability_code": "    function hashEIP712Domain(\n\n        string memory name,\n\n        string memory version,\n\n        uint256 chainId,\n\n        address verifyingContractAddress\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes32 result)\n\n    {\n\n        bytes32 schemaHash = _EIP712_DOMAIN_SEPARATOR_SCHEMA_HASH;\n\n\n\n        // Assembly for more efficient computing:\n\n        // keccak256(abi.encodePacked(\n\n        //     _EIP712_DOMAIN_SEPARATOR_SCHEMA_HASH,\n\n        //     keccak256(bytes(name)),\n\n        //     keccak256(bytes(version)),\n\n        //     chainId,\n\n        //     uint256(verifyingContractAddress)\n\n        // ))\n\n\n\n        assembly {\n\n            // Calculate hashes of dynamic data\n\n            let nameHash := keccak256(add(name, 32), mload(name))\n\n            let versionHash := keccak256(add(version, 32), mload(version))\n\n\n\n            // Load free memory pointer\n\n            let memPtr := mload(64)\n\n\n\n            // Store params in memory\n\n            mstore(memPtr, schemaHash)\n\n            mstore(add(memPtr, 32), nameHash)\n\n            mstore(add(memPtr, 64), versionHash)\n\n            mstore(add(memPtr, 96), chainId)\n\n            mstore(add(memPtr, 128), verifyingContractAddress)\n\n\n\n            // Compute hash\n\n            result := keccak256(memPtr, 160)\n\n        }\n\n        return result;\n",
          "message": "LibEIP712.hashEIP712Domain uses assembly (TestLibEIP712.sol#42-82)\n\t- TestLibEIP712.sol#63-80\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 89,
          "vulnerability_to_line": 113,
          "vulnerability_code": "    function hashEIP712Message(bytes32 eip712DomainHash, bytes32 hashStruct)\n\n        internal\n\n        pure\n\n        returns (bytes32 result)\n\n    {\n\n        // Assembly for more efficient computing:\n\n        // keccak256(abi.encodePacked(\n\n        //     EIP191_HEADER,\n\n        //     EIP712_DOMAIN_HASH,\n\n        //     hashStruct\n\n        // ));\n\n\n\n        assembly {\n\n            // Load free memory pointer\n\n            let memPtr := mload(64)\n\n\n\n            mstore(memPtr, 0x1901000000000000000000000000000000000000000000000000000000000000)  // EIP191 header\n\n            mstore(add(memPtr, 2), eip712DomainHash)                                            // EIP712 domain hash\n\n            mstore(add(memPtr, 34), hashStruct)                                                 // Hash of struct\n\n\n\n            // Compute hash\n\n            result := keccak256(memPtr, 66)\n\n        }\n\n        return result;\n",
          "message": "LibEIP712.hashEIP712Message uses assembly (TestLibEIP712.sol#89-113)\n\t- TestLibEIP712.sol#101-111\n"
        },
        {
          "name": "solc-version",
          "vulnerability_from_line": 21,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.9;\n",
          "message": "Detected issues with version pragma in TestLibEIP712.sol:\n\t- pragma solidity^0.5.9 (TestLibEIP712.sol#21): it allows old versions\n\t- pragma solidity^0.5.9 (TestLibEIP712.sol#136): it allows old versions\n"
        }
      ]
    },
    "smartcheck": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 21,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.9;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 136,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.9;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 42,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function hashEIP712Domain(\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 89,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function hashEIP712Message(bytes32 eip712DomainHash, bytes32 hashStruct)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 63,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 101,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 140,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function externalHashEIP712DomainSeperator(\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 142,
          "vulnerability_to_line": null,
          "vulnerability_code": "        string calldata version,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 143,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint256 chainid,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 144,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address verifyingcontractaddress\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 148,
          "vulnerability_to_line": null,
          "vulnerability_code": "        returns (bytes32)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 150,
          "vulnerability_to_line": null,
          "vulnerability_code": "        return LibEIP712.hashEIP712Domain(\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 152,
          "vulnerability_to_line": null,
          "vulnerability_code": "            version,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 154,
          "vulnerability_to_line": null,
          "vulnerability_code": "            verifyingcontractaddress\n",
          "message": null
        }
      ]
    },
    "oyente": {
      "successfull_analysis": false,
      "errors": [
        "exception (IndexError: pop from empty list)"
      ],
      "vulnerability_findings": []
    },
    "mythril": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": []
    },
    "osiris": {
      "successfull_analysis": false,
      "errors": [
        "Solidity compilation failed"
      ],
      "vulnerability_findings": []
    }
  }
}