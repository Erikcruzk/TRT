{
  "smartbugs_completed": true,
  "analyzer_results": {
    "semgrep": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 276,
          "vulnerability_to_line": null,
          "vulnerability_code": "    for (uint256 i = 0; i < self.length; i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 280,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 j = i; j < self.length - 1; j++){\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 284,
          "vulnerability_to_line": null,
          "vulnerability_code": "        delete self[self.length - 1];\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 285,
          "vulnerability_to_line": null,
          "vulnerability_code": "        self.length--;\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "non-optimal-variables-swap",
          "vulnerability_from_line": 231,
          "vulnerability_to_line": null,
          "vulnerability_code": "          temp = self[swap];\n",
          "message": "Consider swapping variables using `(self[swap], self[root]) = (self[root], self[swap])` to save gas"
        },
        {
          "name": "non-optimal-variables-swap",
          "vulnerability_from_line": 232,
          "vulnerability_to_line": null,
          "vulnerability_code": "          self[swap] = self[root];\n",
          "message": "Consider swapping variables using `(self[swap], self[root]) = (self[root], self[swap])` to save gas"
        },
        {
          "name": "non-optimal-variables-swap",
          "vulnerability_from_line": 233,
          "vulnerability_to_line": null,
          "vulnerability_code": "          self[root] = temp;\n",
          "message": "Consider swapping variables using `(self[swap], self[root]) = (self[root], self[swap])` to save gas"
        },
        {
          "name": "non-optimal-variables-swap",
          "vulnerability_from_line": 244,
          "vulnerability_to_line": null,
          "vulnerability_code": "      temp = self[end];\n",
          "message": "Consider swapping variables using `(self[end], self[0]) = (self[0], self[end])` to save gas"
        },
        {
          "name": "non-optimal-variables-swap",
          "vulnerability_from_line": 245,
          "vulnerability_to_line": null,
          "vulnerability_code": "      self[end] = self[0];\n",
          "message": "Consider swapping variables using `(self[end], self[0]) = (self[0], self[end])` to save gas"
        },
        {
          "name": "non-optimal-variables-swap",
          "vulnerability_from_line": 246,
          "vulnerability_to_line": null,
          "vulnerability_code": "      self[0] = temp;\n",
          "message": "Consider swapping variables using `(self[end], self[0]) = (self[0], self[end])` to save gas"
        },
        {
          "name": "non-optimal-variables-swap",
          "vulnerability_from_line": 260,
          "vulnerability_to_line": null,
          "vulnerability_code": "          temp = self[swap];\n",
          "message": "Consider swapping variables using `(self[swap], self[root]) = (self[root], self[swap])` to save gas"
        },
        {
          "name": "non-optimal-variables-swap",
          "vulnerability_from_line": 261,
          "vulnerability_to_line": null,
          "vulnerability_code": "          self[swap] = self[root];\n",
          "message": "Consider swapping variables using `(self[swap], self[root]) = (self[root], self[swap])` to save gas"
        },
        {
          "name": "non-optimal-variables-swap",
          "vulnerability_from_line": 262,
          "vulnerability_to_line": null,
          "vulnerability_code": "          self[root] = temp;\n",
          "message": "Consider swapping variables using `(self[swap], self[root]) = (self[root], self[swap])` to save gas"
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 276,
          "vulnerability_to_line": null,
          "vulnerability_code": "    for (uint256 i = 0; i < self.length; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 280,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 j = i; j < self.length - 1; j++){\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 226,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if((rChild <= end) && (self[swap]<self[rChild]))\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 227,
          "vulnerability_to_line": null,
          "vulnerability_code": "          swap = rChild;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 255,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if((rChild <= end) && (self[swap]<self[rChild]))\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 256,
          "vulnerability_to_line": null,
          "vulnerability_code": "          swap = rChild;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-prefix-decrement-not-postfix",
          "vulnerability_from_line": 285,
          "vulnerability_to_line": null,
          "vulnerability_code": "        self.length--;\n",
          "message": "Consider using the prefix decrement expression whenever the return value is not needed. The prefix decrement expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-decrement-not-postfix",
          "vulnerability_from_line": 286,
          "vulnerability_to_line": null,
          "vulnerability_code": "        i--;\n",
          "message": "Consider using the prefix decrement expression whenever the return value is not needed. The prefix decrement expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 276,
          "vulnerability_to_line": null,
          "vulnerability_code": "    for (uint256 i = 0; i < self.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 280,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 j = i; j < self.length - 1; j++){\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        }
      ]
    },
    "slither": {
      "successfull_analysis": true,
      "errors": [
        "EXIT_CODE_14"
      ],
      "vulnerability_findings": [
        {
          "name": "constant-function",
          "vulnerability_from_line": 37,
          "vulnerability_to_line": 58,
          "vulnerability_code": "  function sumElements(uint128[] storage self) public view returns(uint256 sum) {\n\n    uint256 term;\n\n    uint8 remainder;\n\n\n\n    assembly {\n\n      mstore(0x60,self_slot)\n\n\n\n      for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } {\n\n        term := sload(add(sha3(0x60,0x20),div(i,2)))\n\n\n\n        remainder := mod(i,2)\n\n\n\n        for { let j := 0 } lt(j, mul(remainder, 4)) { j := add(j, 1) } {\n\n          term := div(term,4294967296)\n\n        }\n\n\n\n        term := and(0x00000000000000000000000000000000ffffffffffffffffffffffffffffffff,term)\n\n        sum := add(term,sum)\n\n\n\n      }\n\n    }\n",
          "message": "Array128Lib.sumElements (Array128Lib.sol#37-58) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 63,
          "vulnerability_to_line": 87,
          "vulnerability_code": "  function getMax(uint128[] storage self) public view returns(uint128 maxValue) {\n\n    uint256 term;\n\n    uint8 remainder;\n\n\n\n    assembly {\n\n      mstore(0x60,self_slot)\n\n      maxValue := 0\n\n\n\n      for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } {\n\n        term := sload(add(sha3(0x60,0x20),div(i,2)))\n\n\n\n        remainder := mod(i,2)\n\n\n\n        for { let j := 0 } lt(j, mul(remainder, 4)) { j := add(j, 1) } {\n\n          term := div(term,4294967296)\n\n        }\n\n\n\n        term := and(0x00000000000000000000000000000000ffffffffffffffffffffffffffffffff,term)\n\n        switch lt(maxValue, term)\n\n        case 1 {\n\n          maxValue := term\n\n        }\n\n      }\n\n    }\n",
          "message": "Array128Lib.getMax (Array128Lib.sol#63-87) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 92,
          "vulnerability_to_line": 119,
          "vulnerability_code": "  function getMin(uint128[] storage self) public view returns(uint128 minValue) {\n\n    uint256 term;\n\n    uint8 remainder;\n\n\n\n    assembly {\n\n      mstore(0x60,self_slot)\n\n\n\n      for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } {\n\n        term := sload(add(sha3(0x60,0x20),div(i,2)))\n\n\n\n        remainder := mod(i,2)\n\n\n\n        for { let j := 0 } lt(j, mul(remainder, 4)) { j := add(j, 1) } {\n\n          term := div(term,4294967296)\n\n        }\n\n\n\n        term := and(0x00000000000000000000000000000000ffffffffffffffffffffffffffffffff,term)\n\n        switch eq(i,0)\n\n        case 1 {\n\n          minValue := term\n\n        }\n\n        switch gt(minValue, term)\n\n        case 1 {\n\n          minValue := term\n\n        }\n\n      }\n\n    }\n",
          "message": "Array128Lib.getMin (Array128Lib.sol#92-119) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 127,
          "vulnerability_to_line": 190,
          "vulnerability_code": "  function indexOf(uint128[] storage self, uint128 value, bool isSorted)\n\n           public\n\n           view\n\n           returns(bool found, uint256 index) {\n\n    uint256 term;\n\n    assembly{\n\n      mstore(0x60,self_slot)\n\n      switch isSorted\n\n      case 1 {\n\n        let high := sub(sload(self_slot),1)\n\n        let mid := 0\n\n        let low := 0\n\n        for { } iszero(gt(low, high)) { } {\n\n          mid := div(add(low,high),2)\n\n          term := sload(add(sha3(0x60,0x20),div(mid,2)))\n\n\n\n          switch mod(mid,2)\n\n          case 1 {\n\n            for { let j := 0 } lt(j, 4) { j := add(j, 1) } {\n\n              term := div(term,4294967296)\n\n            }\n\n          }\n\n\n\n          term := and(term,0x00000000000000000000000000000000ffffffffffffffffffffffffffffffff)\n\n\n\n          switch lt(term,value)\n\n          case 1 {\n\n             low := add(mid,1)\n\n          }\n\n          case 0 {\n\n            switch gt(term,value)\n\n            case 1 {\n\n              high := sub(mid,1)\n\n            }\n\n            case 0 {\n\n              found := 1\n\n              index := mid\n\n              low := add(high,1)\n\n            }\n\n          }\n\n        }\n\n      }\n\n      case 0 {\n\n        for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } {\n\n          term := sload(add(sha3(0x60,0x20),div(i,2)))\n\n          switch mod(i,2)\n\n          case 1 {\n\n            for { let j := 0 } lt(j, 4) { j := add(j, 1) } {\n\n              term := div(term,4294967296)\n\n            }\n\n          }\n\n\n\n          term := and(term,0x00000000000000000000000000000000ffffffffffffffffffffffffffffffff)\n\n\n\n          switch eq(term, value)\n\n          case 1 {\n\n            found := 1\n\n            index := i\n\n            i := sload(self_slot)\n\n          }\n\n        }\n\n      }\n\n    }\n",
          "message": "Array128Lib.indexOf (Array128Lib.sol#127-190) is declared view but contains assembly code\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 37,
          "vulnerability_to_line": 58,
          "vulnerability_code": "  function sumElements(uint128[] storage self) public view returns(uint256 sum) {\n\n    uint256 term;\n\n    uint8 remainder;\n\n\n\n    assembly {\n\n      mstore(0x60,self_slot)\n\n\n\n      for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } {\n\n        term := sload(add(sha3(0x60,0x20),div(i,2)))\n\n\n\n        remainder := mod(i,2)\n\n\n\n        for { let j := 0 } lt(j, mul(remainder, 4)) { j := add(j, 1) } {\n\n          term := div(term,4294967296)\n\n        }\n\n\n\n        term := and(0x00000000000000000000000000000000ffffffffffffffffffffffffffffffff,term)\n\n        sum := add(term,sum)\n\n\n\n      }\n\n    }\n",
          "message": "Array128Lib.sumElements uses assembly (Array128Lib.sol#37-58)\n\t- Array128Lib.sol#41-58\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 63,
          "vulnerability_to_line": 87,
          "vulnerability_code": "  function getMax(uint128[] storage self) public view returns(uint128 maxValue) {\n\n    uint256 term;\n\n    uint8 remainder;\n\n\n\n    assembly {\n\n      mstore(0x60,self_slot)\n\n      maxValue := 0\n\n\n\n      for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } {\n\n        term := sload(add(sha3(0x60,0x20),div(i,2)))\n\n\n\n        remainder := mod(i,2)\n\n\n\n        for { let j := 0 } lt(j, mul(remainder, 4)) { j := add(j, 1) } {\n\n          term := div(term,4294967296)\n\n        }\n\n\n\n        term := and(0x00000000000000000000000000000000ffffffffffffffffffffffffffffffff,term)\n\n        switch lt(maxValue, term)\n\n        case 1 {\n\n          maxValue := term\n\n        }\n\n      }\n\n    }\n",
          "message": "Array128Lib.getMax uses assembly (Array128Lib.sol#63-87)\n\t- Array128Lib.sol#67-87\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 92,
          "vulnerability_to_line": 119,
          "vulnerability_code": "  function getMin(uint128[] storage self) public view returns(uint128 minValue) {\n\n    uint256 term;\n\n    uint8 remainder;\n\n\n\n    assembly {\n\n      mstore(0x60,self_slot)\n\n\n\n      for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } {\n\n        term := sload(add(sha3(0x60,0x20),div(i,2)))\n\n\n\n        remainder := mod(i,2)\n\n\n\n        for { let j := 0 } lt(j, mul(remainder, 4)) { j := add(j, 1) } {\n\n          term := div(term,4294967296)\n\n        }\n\n\n\n        term := and(0x00000000000000000000000000000000ffffffffffffffffffffffffffffffff,term)\n\n        switch eq(i,0)\n\n        case 1 {\n\n          minValue := term\n\n        }\n\n        switch gt(minValue, term)\n\n        case 1 {\n\n          minValue := term\n\n        }\n\n      }\n\n    }\n",
          "message": "Array128Lib.getMin uses assembly (Array128Lib.sol#92-119)\n\t- Array128Lib.sol#96-119\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 127,
          "vulnerability_to_line": 190,
          "vulnerability_code": "  function indexOf(uint128[] storage self, uint128 value, bool isSorted)\n\n           public\n\n           view\n\n           returns(bool found, uint256 index) {\n\n    uint256 term;\n\n    assembly{\n\n      mstore(0x60,self_slot)\n\n      switch isSorted\n\n      case 1 {\n\n        let high := sub(sload(self_slot),1)\n\n        let mid := 0\n\n        let low := 0\n\n        for { } iszero(gt(low, high)) { } {\n\n          mid := div(add(low,high),2)\n\n          term := sload(add(sha3(0x60,0x20),div(mid,2)))\n\n\n\n          switch mod(mid,2)\n\n          case 1 {\n\n            for { let j := 0 } lt(j, 4) { j := add(j, 1) } {\n\n              term := div(term,4294967296)\n\n            }\n\n          }\n\n\n\n          term := and(term,0x00000000000000000000000000000000ffffffffffffffffffffffffffffffff)\n\n\n\n          switch lt(term,value)\n\n          case 1 {\n\n             low := add(mid,1)\n\n          }\n\n          case 0 {\n\n            switch gt(term,value)\n\n            case 1 {\n\n              high := sub(mid,1)\n\n            }\n\n            case 0 {\n\n              found := 1\n\n              index := mid\n\n              low := add(high,1)\n\n            }\n\n          }\n\n        }\n\n      }\n\n      case 0 {\n\n        for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } {\n\n          term := sload(add(sha3(0x60,0x20),div(i,2)))\n\n          switch mod(i,2)\n\n          case 1 {\n\n            for { let j := 0 } lt(j, 4) { j := add(j, 1) } {\n\n              term := div(term,4294967296)\n\n            }\n\n          }\n\n\n\n          term := and(term,0x00000000000000000000000000000000ffffffffffffffffffffffffffffffff)\n\n\n\n          switch eq(term, value)\n\n          case 1 {\n\n            found := 1\n\n            index := i\n\n            i := sload(self_slot)\n\n          }\n\n        }\n\n      }\n\n    }\n",
          "message": "Array128Lib.indexOf uses assembly (Array128Lib.sol#127-190)\n\t- Array128Lib.sol#132-190\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 37,
          "vulnerability_to_line": 58,
          "vulnerability_code": "  function sumElements(uint128[] storage self) public view returns(uint256 sum) {\n\n    uint256 term;\n\n    uint8 remainder;\n\n\n\n    assembly {\n\n      mstore(0x60,self_slot)\n\n\n\n      for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } {\n\n        term := sload(add(sha3(0x60,0x20),div(i,2)))\n\n\n\n        remainder := mod(i,2)\n\n\n\n        for { let j := 0 } lt(j, mul(remainder, 4)) { j := add(j, 1) } {\n\n          term := div(term,4294967296)\n\n        }\n\n\n\n        term := and(0x00000000000000000000000000000000ffffffffffffffffffffffffffffffff,term)\n\n        sum := add(term,sum)\n\n\n\n      }\n\n    }\n",
          "message": "Array128Lib.sumElements (Array128Lib.sol#37-58) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 63,
          "vulnerability_to_line": 87,
          "vulnerability_code": "  function getMax(uint128[] storage self) public view returns(uint128 maxValue) {\n\n    uint256 term;\n\n    uint8 remainder;\n\n\n\n    assembly {\n\n      mstore(0x60,self_slot)\n\n      maxValue := 0\n\n\n\n      for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } {\n\n        term := sload(add(sha3(0x60,0x20),div(i,2)))\n\n\n\n        remainder := mod(i,2)\n\n\n\n        for { let j := 0 } lt(j, mul(remainder, 4)) { j := add(j, 1) } {\n\n          term := div(term,4294967296)\n\n        }\n\n\n\n        term := and(0x00000000000000000000000000000000ffffffffffffffffffffffffffffffff,term)\n\n        switch lt(maxValue, term)\n\n        case 1 {\n\n          maxValue := term\n\n        }\n\n      }\n\n    }\n",
          "message": "Array128Lib.getMax (Array128Lib.sol#63-87) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 92,
          "vulnerability_to_line": 119,
          "vulnerability_code": "  function getMin(uint128[] storage self) public view returns(uint128 minValue) {\n\n    uint256 term;\n\n    uint8 remainder;\n\n\n\n    assembly {\n\n      mstore(0x60,self_slot)\n\n\n\n      for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } {\n\n        term := sload(add(sha3(0x60,0x20),div(i,2)))\n\n\n\n        remainder := mod(i,2)\n\n\n\n        for { let j := 0 } lt(j, mul(remainder, 4)) { j := add(j, 1) } {\n\n          term := div(term,4294967296)\n\n        }\n\n\n\n        term := and(0x00000000000000000000000000000000ffffffffffffffffffffffffffffffff,term)\n\n        switch eq(i,0)\n\n        case 1 {\n\n          minValue := term\n\n        }\n\n        switch gt(minValue, term)\n\n        case 1 {\n\n          minValue := term\n\n        }\n\n      }\n\n    }\n",
          "message": "Array128Lib.getMin (Array128Lib.sol#92-119) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 210,
          "vulnerability_to_line": 268,
          "vulnerability_code": "  function heapSort(uint128[] storage self) public {\n\n    uint256 end = self.length - 1;\n\n    uint256 start = getParentI(end);\n\n    uint256 root = start;\n\n    uint256 lChild;\n\n    uint256 rChild;\n\n    uint256 swap;\n\n    uint128 temp;\n\n    while(start >= 0){\n\n      root = start;\n\n      lChild = getLeftChildI(start);\n\n      while(lChild <= end){\n\n        rChild = lChild + 1;\n\n        swap = root;\n\n        if(self[swap] < self[lChild])\n\n          swap = lChild;\n\n        if((rChild <= end) && (self[swap]<self[rChild]))\n\n          swap = rChild;\n\n        if(swap == root)\n\n          lChild = end+1;\n\n        else {\n\n          temp = self[swap];\n\n          self[swap] = self[root];\n\n          self[root] = temp;\n\n          root = swap;\n\n          lChild = getLeftChildI(root);\n\n        }\n\n      }\n\n      if(start == 0)\n\n        break;\n\n      else\n\n        start = start - 1;\n\n    }\n\n    while(end > 0){\n\n      temp = self[end];\n\n      self[end] = self[0];\n\n      self[0] = temp;\n\n      end = end - 1;\n\n      root = 0;\n\n      lChild = getLeftChildI(0);\n\n      while(lChild <= end){\n\n        rChild = lChild + 1;\n\n        swap = root;\n\n        if(self[swap] < self[lChild])\n\n          swap = lChild;\n\n        if((rChild <= end) && (self[swap]<self[rChild]))\n\n          swap = rChild;\n\n        if(swap == root)\n\n          lChild = end + 1;\n\n        else {\n\n          temp = self[swap];\n\n          self[swap] = self[root];\n\n          self[root] = temp;\n\n          root = swap;\n\n          lChild = getLeftChildI(root);\n\n        }\n\n      }\n\n    }\n",
          "message": "Array128Lib.heapSort (Array128Lib.sol#210-268) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 272,
          "vulnerability_to_line": 291,
          "vulnerability_code": "  function uniq(uint128[] storage self) public returns (uint256 length) {\n\n    bool contains;\n\n    uint256 index;\n\n\n\n    for (uint256 i = 0; i < self.length; i++) {\n\n      (contains, index) = indexOf(self, self[i], false);\n\n\n\n      if (i > index) {\n\n        for (uint256 j = i; j < self.length - 1; j++){\n\n          self[j] = self[j + 1];\n\n        }\n\n\n\n        delete self[self.length - 1];\n\n        self.length--;\n\n        i--;\n\n      }\n\n    }\n\n\n\n    length = self.length;\n",
          "message": "Array128Lib.uniq (Array128Lib.sol#272-291) should be declared external\n"
        },
        {
          "name": "solc-version",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.18;\n",
          "message": "Detected issues with version pragma in Array128Lib.sol:\n\t- pragma solidity^0.4.18 (Array128Lib.sol#3): it allows old versions\n"
        }
      ]
    },
    "smartcheck": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "SOLIDITY_ARRAY_LENGTH_MANIPULATION",
          "vulnerability_from_line": 285,
          "vulnerability_to_line": null,
          "vulnerability_code": "        self.length--;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
          "vulnerability_from_line": 45,
          "vulnerability_to_line": null,
          "vulnerability_code": "        term := sload(add(sha3(0x60,0x20),div(i,2)))\n",
          "message": null
        },
        {
          "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
          "vulnerability_from_line": 72,
          "vulnerability_to_line": null,
          "vulnerability_code": "        term := sload(add(sha3(0x60,0x20),div(i,2)))\n",
          "message": null
        },
        {
          "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
          "vulnerability_from_line": 100,
          "vulnerability_to_line": null,
          "vulnerability_code": "        term := sload(add(sha3(0x60,0x20),div(i,2)))\n",
          "message": null
        },
        {
          "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
          "vulnerability_from_line": 141,
          "vulnerability_to_line": null,
          "vulnerability_code": "          term := sload(add(sha3(0x60,0x20),div(mid,2)))\n",
          "message": null
        },
        {
          "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
          "vulnerability_from_line": 171,
          "vulnerability_to_line": null,
          "vulnerability_code": "          term := sload(add(sha3(0x60,0x20),div(i,2)))\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 276,
          "vulnerability_to_line": null,
          "vulnerability_code": "    for (uint256 i = 0; i < self.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 280,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 j = i; j < self.length - 1; j++){\n",
          "message": null
        },
        {
          "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
          "vulnerability_from_line": 37,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function sumElements(uint128[] storage self) public view returns(uint256 sum) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
          "vulnerability_from_line": 63,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function getMax(uint128[] storage self) public view returns(uint128 maxValue) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
          "vulnerability_from_line": 92,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function getMin(uint128[] storage self) public view returns(uint128 minValue) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
          "vulnerability_from_line": 127,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function indexOf(uint128[] storage self, uint128 value, bool isSorted)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 276,
          "vulnerability_to_line": null,
          "vulnerability_code": "    for (uint256 i = 0; i < self.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 221,
          "vulnerability_to_line": null,
          "vulnerability_code": "      while(lChild <= end){\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 250,
          "vulnerability_to_line": null,
          "vulnerability_code": "      while(lChild <= end){\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.18;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
          "vulnerability_from_line": 37,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function sumElements(uint128[] storage self) public view returns(uint256 sum) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
          "vulnerability_from_line": 63,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function getMax(uint128[] storage self) public view returns(uint128 maxValue) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
          "vulnerability_from_line": 92,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function getMin(uint128[] storage self) public view returns(uint128 minValue) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
          "vulnerability_from_line": 127,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function indexOf(uint128[] storage self, uint128 value, bool isSorted)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UINT_CANT_BE_NEGATIVE",
          "vulnerability_from_line": 218,
          "vulnerability_to_line": null,
          "vulnerability_code": "    while(start >= 0){\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UINT_CANT_BE_NEGATIVE",
          "vulnerability_from_line": 218,
          "vulnerability_to_line": null,
          "vulnerability_code": "    while(start >= 0){\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 41,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 67,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 96,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 132,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly{\n",
          "message": null
        }
      ]
    },
    "oyente": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "Integer Overflow",
          "vulnerability_from_line": 141,
          "vulnerability_to_line": null,
          "vulnerability_code": "          term := sload(add(sha3(0x60,0x20),div(mid,2)))\n",
          "message": null
        },
        {
          "name": "Integer Underflow",
          "vulnerability_from_line": 136,
          "vulnerability_to_line": null,
          "vulnerability_code": "        let high := sub(sload(self_slot),1)\n",
          "message": null
        }
      ]
    },
    "mythril": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": []
    },
    "osiris": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "Division bugs",
          "vulnerability_from_line": 224,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if(self[swap] < self[lChild])\n",
          "message": null
        },
        {
          "name": "Division bugs",
          "vulnerability_from_line": 224,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if(self[swap] < self[lChild])\n",
          "message": null
        },
        {
          "name": "Overflow bugs",
          "vulnerability_from_line": 54,
          "vulnerability_to_line": null,
          "vulnerability_code": "        sum := add(term,sum)\n",
          "message": null
        },
        {
          "name": "Truncation bugs",
          "vulnerability_from_line": 179,
          "vulnerability_to_line": null,
          "vulnerability_code": "          term := and(term,0x00000000000000000000000000000000ffffffffffffffffffffffffffffffff)\n",
          "message": null
        },
        {
          "name": "Truncation bugs",
          "vulnerability_from_line": 224,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if(self[swap] < self[lChild])\n",
          "message": null
        },
        {
          "name": "Truncation bugs",
          "vulnerability_from_line": 224,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if(self[swap] < self[lChild])\n",
          "message": null
        }
      ]
    }
  }
}