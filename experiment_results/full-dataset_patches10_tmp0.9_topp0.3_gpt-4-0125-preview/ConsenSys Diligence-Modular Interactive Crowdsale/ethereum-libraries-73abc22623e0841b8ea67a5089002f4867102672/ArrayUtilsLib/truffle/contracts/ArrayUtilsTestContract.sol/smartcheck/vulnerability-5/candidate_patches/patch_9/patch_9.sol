pragma solidity ^0.4.18;




























library Array256Lib {

  
  
  
  function sumElements(uint256[] storage self) public view returns(uint256 sum) {
    assembly {
      mstore(0x60,self_slot)

      for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } {
        sum := add(sload(add(sha3(0x60,0x20),i)),sum)
      }
    }
  }

  
  
  
  function getMax(uint256[] storage self) public view returns(uint256 maxValue) {
    assembly {
      mstore(0x60,self_slot)
      maxValue := sload(sha3(0x60,0x20))

      for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } {
        switch gt(sload(add(sha3(0x60,0x20),i)), maxValue)
        case 1 {
          maxValue := sload(add(sha3(0x60,0x20),i))
        }
      }
    }
  }

  
  
  
  function getMin(uint256[] storage self) public view returns(uint256 minValue) {
    assembly {
      mstore(0x60,self_slot)
      minValue := sload(sha3(0x60,0x20))

      for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } {
        switch gt(sload(add(sha3(0x60,0x20),i)), minValue)
        case 0 {
          minValue := sload(add(sha3(0x60,0x20),i))
        }
      }
    }
  }

  
  
  
  
  
  
  function indexOf(uint256[] storage self, uint256 value, bool isSorted)
           public
           view
           returns(bool found, uint256 index) {
    assembly{
      mstore(0x60,self_slot)
      switch isSorted
      case 1 {
        let high := sub(sload(self_slot),1)
        let mid := 0
        let low := 0
        for { } iszero(gt(low, high)) { } {
          mid := div(add(low,high),2)

          switch lt(sload(add(sha3(0x60,0x20),mid)),value)
          case 1 {
             low := add(mid,1)
          }
          case 0 {
            switch gt(sload(add(sha3(0x60,0x20),mid)),value)
            case 1 {
              high := sub(mid,1)
            }
            case 0 {
              found := 1
              index := mid
              low := add(high,1)
            }
          }
        }
      }
      case 0 {
        for { let low := 0 } lt(low, sload(self_slot)) { low := add(low, 1) } {
          switch eq(sload(add(sha3(0x60,0x20),low)), value)
          case 1 {
            found := 1
            index := low
            low := sload(self_slot)
          }
        }
      }
    }
  }

  
  
  
  function getParentI(uint256 index) private pure returns (uint256 pI) {
    uint256 i = index - 1;
    pI = i/2;
  }

  
  
  
  function getLeftChildI(uint256 index) private pure returns (uint256 lcI) {
    uint256 i = index * 2;
    lcI = i + 1;
  }

  
  
  function heapSort(uint256[] storage self) public {
    uint256 end = self.length - 1;
    uint256 start = getParentI(end);
    uint256 root = start;
    uint256 lChild;
    uint256 rChild;
    uint256 swap;
    uint256 temp;
    while(start >= 0){
      root = start;
      lChild = getLeftChildI(start);
      while(lChild <= end){
        rChild = lChild + 1;
        swap = root;
        if(self[swap] < self[lChild])
          swap = lChild;
        if((rChild <= end) && (self[swap]<self[rChild]))
          swap = rChild;
        if(swap == root)
          lChild = end+1;
        else {
          temp = self[swap];
          self[swap] = self[root];
          self[root] = temp;
          root = swap;
          lChild = getLeftChildI(root);
        }
      }
      if(start == 0)
        break;
      else
        start = start - 1;
    }
    while(end > 0){
      temp = self[end];
      self[end] = self[0];
      self[0] = temp;
      end = end - 1;
      root = 0;
      lChild = getLeftChildI(0);
      while(lChild <= end){
        rChild = lChild + 1;
        swap = root;
        if(self[swap] < self[lChild])
          swap = lChild;
        if((rChild <= end) && (self[swap]<self[rChild]))
          swap = rChild;
        if(swap == root)
          lChild = end + 1;
        else {
          temp = self[swap];
          self[swap] = self[root];
          self[root] = temp;
          root = swap;
          lChild = getLeftChildI(root);
        }
      }
    }
  }

  
  
  function uniq(uint256[] storage self) public returns (uint256 length) {
    bool contains;
    uint256 index;

    for (uint256 i = 0; i < self.length; i++) {
      (contains, index) = indexOf(self, self[i], false);

      if (i > index) {
        for (uint256 j = i; j < self.length - 1; j++){
          self[j] = self[j + 1];
        }

        delete self[self.length - 1];
        self.length--;
        i--;
      }
    }

    length = self.length;
  }
}



pragma solidity ^0.4.18;




























library Array128Lib {

  
  
  
  function sumElements(uint128[] storage self) public view returns(uint256 sum) {
    uint256 term;
    uint8 remainder;

    assembly {
      mstore(0x60,self_slot)

      for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } {
        term := sload(add(sha3(0x60,0x20),div(i,2)))

        remainder := mod(i,2)

        for { let j := 0 } lt(j, mul(remainder, 4)) { j := add(j, 1) } {
          term := div(term,4294967296)
        }

        term := and(0x00000000000000000000000000000000ffffffffffffffffffffffffffffffff,term)
        sum := add(term,sum)

      }
    }
  }

  
  
  
  function getMax(uint128[] storage self) public view returns(uint128 maxValue) {
    uint256 term;
    uint8 remainder;

    assembly {
      mstore(0x60,self_slot)
      maxValue := 0

      for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } {
        term := sload(add(sha3(0x60,0x20),div(i,2)))

        remainder := mod(i,2)

        for { let j := 0 } lt(j, mul(remainder, 4)) { j := add(j, 1) } {
          term := div(term,4294967296)
        }

        term := and(0x00000000000000000000000000000000ffffffffffffffffffffffffffffffff,term)
        switch lt(maxValue, term)
        case 1 {
          maxValue := term
        }
      }
    }
  }

  
  
  
  function getMin(uint128[] storage self) public view returns(uint128 minValue) {
    uint256 term;
    uint8 remainder;

    assembly {
      mstore(0x60,self_slot)

      for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } {
        term := sload(add(sha3(0x60,0x20),div(i,2)))

        remainder := mod(i,2)

        for { let j := 0 } lt(j, mul(remainder, 4)) { j := add(j, 1) } {
          term := div(term,4294967296)
        }

        term := and(0x00000000000000000000000000000000ffffffffffffffffffffffffffffffff,term)
        switch eq(i,0)
        case 1 {
          minValue := term
        }
        switch gt(minValue, term)
        case 1 {
          minValue := term
        }
      }
    }
  }

  
  
  
  
  
  
  function indexOf(uint128[] storage self, uint128 value, bool isSorted)
           public
           view
           returns(bool found, uint256 index) {
    uint256 term;
    assembly{
      mstore(0x60,self_slot)
      switch isSorted
      case 1 {
        let high := sub(sload(self_slot),1)
        let mid := 0
        let low := 0
        for { } iszero(gt(low, high)) { } {
          mid := div(add(low,high),2)
          term := sload(add(sha3(0x60,0x20),div(mid,2)))

          switch mod(mid,2)
          case 1 {
            for { let j := 0 } lt(j, 4) { j := add(j, 1) } {
              term := div(term,4294967296)
            }
          }

          term := and(term,0x00000000000000000000000000000000ffffffffffffffffffffffffffffffff)

          switch lt(term,value)
          case 1 {
             low := add(mid,1)
          }
          case 0 {
            switch gt(term,value)
            case 1 {
              high := sub(mid,1)
            }
            case 0 {
              found := 1
              index := mid
              low := add(high,1)
            }
          }
        }
      }
      case 0 {
        for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } {
          term := sload(add(sha3(0x60,0x20),div(i,2)))
          switch mod(i,2)
          case 1 {
            for { let j := 0 } lt(j, 4) { j := add(j, 1) } {
              term := div(term,4294967296)
            }
          }

          term := and(term,0x00000000000000000000000000000000ffffffffffffffffffffffffffffffff)

          switch eq(term, value)
          case 1 {
            found := 1
            index := i
            i := sload(self_slot)
          }
        }
      }
    }
  }

  
  
  
  function getParentI(uint256 index) private pure returns (uint256 pI) {
    uint256 i = index - 1;
    pI = i/2;
  }

  
  
  
  function getLeftChildI(uint256 index) private pure returns (uint256 lcI) {
    uint256 i = index * 2;
    lcI = i + 1;
  }

  
  
  function heapSort(uint128[] storage self) public {
    uint256 end = self.length - 1;
    uint256 start = getParentI(end);
    uint256 root = start;
    uint256 lChild;
    uint256 rChild;
    uint256 swap;
    uint128 temp;
    while(start >= 0){
      root = start;
      lChild = getLeftChildI(start);
      while(lChild <= end){
        rChild = lChild + 1;
        swap = root;
        if(self[swap] < self[lChild])
          swap = lChild;
        if((rChild <= end) && (self[swap]<self[rChild]))
          swap = rChild;
        if(swap == root)
          lChild = end+1;
        else {
          temp = self[swap];
          self[swap] = self[root];
          self[root] = temp;
          root = swap;
          lChild = getLeftChildI(root);
        }
      }
      if(start == 0)
        break;
      else
        start = start - 1;
    }
    while(end > 0){
      temp = self[end];
      self[end] = self[0];
      self[0] = temp;
      end = end - 1;
      root = 0;
      lChild = getLeftChildI(0);
      while(lChild <= end){
        rChild = lChild + 1;
        swap = root;
        if(self[swap] < self[lChild])
          swap = lChild;
        if((rChild <= end) && (self[swap]<self[rChild]))
          swap = rChild;
        if(swap == root)
          lChild = end + 1;
        else {
          temp = self[swap];
          self[swap] = self[root];
          self[root] = temp;
          root = swap;
          lChild = getLeftChildI(root);
        }
      }
    }
  }

  
  
  function uniq(uint128[] storage self) public returns (uint256 length) {
    bool contains;
    uint256 index;

    for (uint256 i = 0; i < self.length; i++) {
      (contains, index) = indexOf(self, self[i], false);

      if (i > index) {
        for (uint256 j = i; j < self.length - 1; j++){
          self[j] = self[j + 1];
        }

        delete self[self.length - 1];
        self.length--;
        i--;
      }
    }

    length = self.length;
  }
}



pragma solidity ^0.4.18;




























library Array64Lib {

  
  
  
  function sumElements(uint64[] storage self) public view returns(uint256 sum) {
    uint256 term;
    uint8 remainder;

    assembly {
      mstore(0x60,self_slot)

      for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } {
        term := sload(add(sha3(0x60,0x20),div(i,4)))

        remainder := mod(i,4)

        for { let j := 0 } lt(j, mul(remainder, 2)) { j := add(j, 1) } {
          term := div(term,4294967296)
        }

        term := and(0x000000000000000000000000000000000000000000000000ffffffffffffffff,term)
        sum := add(term,sum)

      }
    }
  }

  
  
  
  function getMax(uint64[] storage self) public view returns(uint64 maxValue) {
    uint256 term;
    uint8 remainder;

    assembly {
      mstore(0x60,self_slot)
      maxValue := 0

      for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } {
        term := sload(add(sha3(0x60,0x20),div(i,4)))

        remainder := mod(i,4)

        for { let j := 0 } lt(j, mul(remainder, 2)) { j := add(j, 1) } {
          term := div(term,4294967296)
        }

        term := and(0x000000000000000000000000000000000000000000000000ffffffffffffffff,term)
        switch lt(maxValue, term)
        case 1 {
          maxValue := term
        }
      }
    }
  }

  
  
  
  function getMin(uint64[] storage self) public view returns(uint64 minValue) {
    uint256 term;
    uint8 remainder;

    assembly {
      mstore(0x60,self_slot)

      for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } {
        term := sload(add(sha3(0x60,0x20),div(i,4)))

        remainder := mod(i,4)

        for { let j := 0 } lt(j, mul(remainder, 2)) { j := add(j, 1) } {
          term := div(term,4294967296)
        }

        term := and(0x000000000000000000000000000000000000000000000000ffffffffffffffff,term)

        switch eq(i,0)
        case 1 {
          minValue := term
        }
        switch gt(minValue, term)
        case 1 {
          minValue := term
        }
      }
    }
  }

  
  
  
  
  
  
  function indexOf(uint64[] storage self, uint64 value, bool isSorted)
           public
           view
           returns(bool found, uint256 index) {
    if (isSorted) {
        uint256 high = self.length - 1;
        uint256 mid = 0;
        uint256 low = 0;
        while (low <= high) {
          mid = (low+high)/2;
          if (self[mid] == value) {
            found = true;
            index = mid;
            low = high + 1;
          } else if (self[mid] < value) {
            low = mid + 1;
          } else {
            high = mid - 1;
          }
        }
    } else {
      for (uint256 i = 0; i<self.length; i++) {
        if (self[i] == value) {
          found = true;
          index = i;
          i = self.length;
        }
      }
    }
  }

  
  
  
  function getParentI(uint256 index) private pure returns (uint256 pI) {
    uint256 i = index - 1;
    pI = i/2;
  }

  
  
  
  function getLeftChildI(uint256 index) private pure returns (uint256 lcI) {
    uint256 i = index * 2;
    lcI = i + 1;
  }

  
  
  function heapSort(uint64[] storage self) public {
    uint256 end = self.length - 1;
    uint256 start = getParentI(end);
    uint256 root = start;
    uint256 lChild;
    uint256 rChild;
    uint256 swap;
    uint64 temp;
    while(start >= 0){
      root = start;
      lChild = getLeftChildI(start);
      while(lChild <= end){
        rChild = lChild + 1;
        swap = root;
        if(self[swap] < self[lChild])
          swap = lChild;
        if((rChild <= end) && (self[swap]<self[rChild]))
          swap = rChild;
        if(swap == root)
          lChild = end+1;
        else {
          temp = self[swap];
          self[swap] = self[root];
          self[root] = temp;
          root = swap;
          lChild = getLeftChildI(root);
        }
      }
      if(start == 0)
        break;
      else
        start = start - 1;
    }
    while(end > 0){
      temp = self[end];
      self[end] = self[0];
      self[0] = temp;
      end = end - 1;
      root = 0;
      lChild = getLeftChildI(0);
      while(lChild <= end){
        rChild = lChild + 1;
        swap = root;
        if(self[swap] < self[lChild])
          swap = lChild;
        if((rChild <= end) && (self[swap]<self[rChild]))
          swap = rChild;
        if(swap == root)
          lChild = end + 1;
        else {
          temp = self[swap];
          self[swap] = self[root];
          self[root] = temp;
          root = swap;
          lChild = getLeftChildI(root);
        }
      }
    }
  }

  
  
  function uniq(uint64[] storage self) public returns (uint256 length) {
    bool contains;
    uint256 index;

    for (uint256 i = 0; i < self.length; i++) {
      (contains, index) = indexOf(self, self[i], false);

      if (i > index) {
        for (uint256 j = i; j < self.length - 1; j++){
          self[j] = self[j + 1];
        }

        delete self[self.length - 1];
        self.length--;
        i--;
      }
    }

    length = self.length;
  }
}



pragma solidity ^0.4.18;




























library Array32Lib {

  
  
  
  function sumElements(uint32[] storage self) public view returns(uint256 sum) {
    uint256 term;
    uint8 remainder;

    assembly {
      mstore(0x60,self_slot)

      for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } {
        term := sload(add(sha3(0x60,0x20),div(i,8)))

        remainder := mod(i,8)

        for { let j := 0 } lt(j, remainder) { j := add(j, 1) } {
          term := div(term,4294967296)
        }

        term := and(0x00000000000000000000000000000000000000000000000000000000ffffffff,term)
        sum := add(term,sum)

      }
    }
  }

  
  
  
  function getMax(uint32[] storage self) public view returns(uint32 maxValue) {
    uint256 term;
    uint8 remainder;

    assembly {
      mstore(0x60,self_slot)
      maxValue := 0

      for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } {
        term := sload(add(sha3(0x60,0x20),div(i,8)))

        remainder := mod(i,8)

        for { let j := 0 } lt(j, remainder) { j := add(j, 1) } {
          term := div(term,4294967296)
        }

        term := and(0x00000000000000000000000000000000000000000000000000000000ffffffff,term)
        switch lt(maxValue, term)
        case 1 {
          maxValue := term
        }
      }
    }
  }

  
  
  
  function getMin(uint32[] storage self) public view returns(uint32 minValue) {
    uint256 term;
    uint8 remainder;

    assembly {
      mstore(0x60,self_slot)

      for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } {
        term := sload(add(sha3(0x60,0x20),div(i,8)))

        remainder := mod(i,8)

        for { let j := 0 } lt(j, remainder) { j := add(j, 1) } {
          term := div(term,4294967296)
        }

        term := and(0x00000000000000000000000000000000000000000000000000000000ffffffff,term)

        switch eq(i,0)
        case 1 {
          minValue := term
        }
        switch gt(minValue, term)
        case 1 {
          minValue := term
        }
      }
    }
  }

  
  
  
  
  
  
  function indexOf(uint32[] storage self, uint32 value, bool isSorted)
           public
           view
           returns(bool found, uint256 index) {
    if (isSorted) {
        uint256 high = self.length - 1;
        uint256 mid = 0;
        uint256 low = 0;
        while (low <= high) {
          mid = (low+high)/2;
          if (self[mid] == value) {
            found = true;
            index = mid;
            low = high + 1;
          } else if (self[mid] < value) {
            low = mid + 1;
          } else {
            high = mid - 1;
          }
        }
    } else {
      for (uint256 i = 0; i<self.length; i++) {
        if (self[i] == value) {
          found = true;
          index = i;
          i = self.length;
        }
      }
    }
  }

  
  
  
  function getParentI(uint256 index) private pure returns (uint256 pI) {
    uint256 i = index - 1;
    pI = i/2;
  }

  
  
  
  function getLeftChildI(uint256 index) private pure returns (uint256 lcI) {
    uint256 i = index * 2;
    lcI = i + 1;
  }

  
  
  function heapSort(uint32[] storage self) public {
    uint256 end = self.length - 1;
    uint256 start = getParentI(end);
    uint256 root = start;
    uint256 lChild;
    uint256 rChild;
    uint256 swap;
    uint32 temp;
    while(start >= 0){
      root = start;
      lChild = getLeftChildI(start);
      while(lChild <= end){
        rChild = lChild + 1;
        swap = root;
        if(self[swap] < self[lChild])
          swap = lChild;
        if((rChild <= end) && (self[swap]<self[rChild]))
          swap = rChild;
        if(swap == root)
          lChild = end+1;
        else {
          temp = self[swap];
          self[swap] = self[root];
          self[root] = temp;
          root = swap;
          lChild = getLeftChildI(root);
        }
      }
      if(start == 0)
        break;
      else
        start = start - 1;
    }
    while(end > 0){
      temp = self[end];
      self[end] = self[0];
      self[0] = temp;
      end = end - 1;
      root = 0;
      lChild = getLeftChildI(0);
      while(lChild <= end){
        rChild = lChild + 1;
        swap = root;
        if(self[swap] < self[lChild])
          swap = lChild;
        if((rChild <= end) && (self[swap]<self[rChild]))
          swap = rChild;
        if(swap == root)
          lChild = end + 1;
        else {
          temp = self[swap];
          self[swap] = self[root];
          self[root] = temp;
          root = swap;
          lChild = getLeftChildI(root);
        }
      }
    }
  }

  
  
  function uniq(uint32[] storage self) public returns (uint256 length) {
    bool contains;
    uint256 index;

    for (uint256 i = 0; i < self.length; i++) {
      (contains, index) = indexOf(self, self[i], false);

      if (i > index) {
        for (uint256 j = i; j < self.length - 1; j++){
          self[j] = self[j + 1];
        }

        delete self[self.length - 1];
        self.length--;
        i--;
      }
    }

    length = self.length;
  }
}



pragma solidity ^0.4.18;




























library Array16Lib {

  
  
  
  function sumElements(uint16[] storage self) public view returns(uint256 sum) {
    uint256 term;
    uint8 remainder;

    assembly {
      mstore(0x60,self_slot)

      for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } {
        term := sload(add(sha3(0x60,0x20),div(i,16)))

        remainder := mod(i,16)

        for { let j := 0 } lt(j, remainder) { j := add(j, 1) } {
          term := div(term,65536)
        }

        term := and(0x000000000000000000000000000000000000000000000000000000000000ffff,term)
        sum := add(term,sum)

      }
    }
  }

  
  
  
  function getMax(uint16[] storage self) public view returns(uint16 maxValue) {
    uint256 term;
    uint8 remainder;

    assembly {
      mstore(0x60,self_slot)
      maxValue := 0

      for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } {
        term := sload(add(sha3(0x60,0x20),div(i,16)))

        remainder := mod(i,16)

        for { let j := 0 } lt(j, remainder) { j := add(j, 1) } {
          term := div(term,65536)
        }

        term := and(0x000000000000000000000000000000000000000000000000000000000000ffff,term)
        switch lt(maxValue, term)
        case 1 {
          maxValue := term
        }
      }
    }
  }

  
  
  
  function getMin(uint16[] storage self) public view returns(uint16 minValue) {
    uint256 term;
    uint8 remainder;

    assembly {
      mstore(0x60,self_slot)

      for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } {
        term := sload(add(sha3(0x60,0x20),div(i,16)))

        remainder := mod(i,16)

        for { let j := 0 } lt(j, remainder) { j := add(j, 1) } {
          term := div(term,65536)
        }

        term := and(0x000000000000000000000000000000000000000000000000000000000000ffff,term)

        switch eq(i,0)
        case 1 {
          minValue := term
        }
        switch gt(minValue, term)
        case 1 {
          minValue := term
        }
      }
    }
  }

  
  
  
  
  
  
  function indexOf(uint16[] storage self, uint16 value, bool isSorted)
           public
           view
           returns(bool found, uint256 index) {
    if (isSorted) {
        uint256 high = self.length - 1;
        uint256 mid = 0;
        uint256 low = 0;
        while (low <= high) {
          mid = (low+high)/2;
          if (self[mid] == value) {
            found = true;
            index = mid;
            low = high + 1;
          } else if (self[mid] < value) {
            low = mid + 1;
          } else {
            high = mid - 1;
          }
        }
    } else {
      for (uint256 i = 0; i<self.length; i++) {
        if (self[i] == value) {
          found = true;
          index = i;
          i = self.length;
        }
      }
    }
  }

  
  
  
  function getParentI(uint256 index) private pure returns (uint256 pI) {
    uint256 i = index - 1;
    pI = i/2;
  }

  
  
  
  function getLeftChildI(uint256 index) private pure returns (uint256 lcI) {
    uint256 i = index * 2;
    lcI = i + 1;
  }

  
  
  function heapSort(uint16[] storage self) public {
    uint256 end = self.length - 1;
    uint256 start = getParentI(end);
    uint256 root = start;
    uint256 lChild;
    uint256 rChild;
    uint256 swap;
    uint16 temp;
    while(start >= 0){
      root = start;
      lChild = getLeftChildI(start);
      while(lChild <= end){
        rChild = lChild + 1;
        swap = root;
        if(self[swap] < self[lChild])
          swap = lChild;
        if((rChild <= end) && (self[swap]<self[rChild]))
          swap = rChild;
        if(swap == root)
          lChild = end+1;
        else {
          temp = self[swap];
          self[swap] = self[root];
          self[root] = temp;
          root = swap;
          lChild = getLeftChildI(root);
        }
      }
      if(start == 0)
        break;
      else
        start = start - 1;
    }
    while(end > 0){
      temp = self[end];
      self[end] = self[0];
      self[0] = temp;
      end = end - 1;
      root = 0;
      lChild = getLeftChildI(0);
      while(lChild <= end){
        rChild = lChild + 1;
        swap = root;
        if(self[swap] < self[lChild])
          swap = lChild;
        if((rChild <= end) && (self[swap]<self[rChild]))
          swap = rChild;
        if(swap == root)
          lChild = end + 1;
        else {
          temp = self[swap];
          self[swap] = self[root];
          self[root] = temp;
          root = swap;
          lChild = getLeftChildI(root);
        }
      }
    }
  }

  
  
  function uniq(uint16[] storage self) public returns (uint256 length) {
    bool contains;
    uint256 index;

    for (uint256 i = 0; i < self.length; i++) {
      (contains, index) = indexOf(self, self[i], false);

      if (i > index) {
        for (uint256 j = i; j < self.length - 1; j++){
          self[j] = self[j + 1];
        }

        delete self[self.length - 1];
        self.length--;
        i--;
      }
    }

    length = self.length;
  }
}



pragma solidity ^0.4.18;




























library Array8Lib {

  
  
  
  function sumElements(uint8[] storage self) public view returns(uint256 sum) {
    uint256 term;
    uint8 remainder;

    assembly {
      mstore(0x60,self_slot)

      for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } {
        term := sload(add(sha3(0x60,0x20),div(i,32)))

        remainder := mod(i,32)

        for { let j := 0 } lt(j, remainder) { j := add(j, 1) } {
          term := div(term,256)
        }

        term := and(0x00000000000000000000000000000000000000000000000000000000000000ff,term)
        sum := add(term,sum)

      }
    }
  }

  
  
  
  function getMax(uint8[] storage self) public view returns(uint8 maxValue) {
    uint256 term;
    uint8 remainder;

    assembly {
      mstore(0x60,self_slot)
      maxValue := 0

      for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } {
        term := sload(add(sha3(0x60,0x20),div(i,32)))

        remainder := mod(i,32)

        for { let j := 0 } lt(j, remainder) { j := add(j, 1) } {
          term := div(term,256)
        }

        term := and(0x00000000000000000000000000000000000000000000000000000000000000ff,term)
        switch lt(maxValue, term)
        case 1 {
          maxValue := term
        }
      }
    }
  }

  
  
  
  function getMin(uint8[] storage self) public view returns(uint8 minValue) {
    uint256 term;
    uint8 remainder;

    assembly {
      mstore(0x60,self_slot)

      for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } {
        term := sload(add(sha3(0x60,0x20),div(i,32)))

        remainder := mod(i,32)

        for { let j := 0 } lt(j, remainder) { j := add(j, 1) } {
          term := div(term,256)
        }

        term := and(0x00000000000000000000000000000000000000000000000000000000000000ff,term)
        switch eq(i,0)
        case 1 {
          minValue := term
        }
        switch gt(minValue, term)
        case 1 {
          minValue := term
        }
      }
    }
  }

  
  
  
  
  
  
  function indexOf(uint8[] storage self, uint8 value, bool isSorted)
           public
           view
           returns(bool found, uint256 index) {
    if (isSorted) {
        uint256 high = self.length - 1;
        uint256 mid = 0;
        uint256 low = 0;
        while (low <= high) {
          mid = (low+high)/2;
          if (self[mid] == value) {
            found = true;
            index = mid;
            low = high + 1;
          } else if (self[mid] < value) {
            low = mid + 1;
          } else {
            high = mid - 1;
          }
        }
    } else {
      for (uint256 i = 0; i<self.length; i++) {
        if (self[i] == value) {
          found = true;
          index = i;
          i = self.length;
        }
      }
    }
  }

  
  
  
  function getParentI(uint256 index) private pure returns (uint256 pI) {
    uint256 i = index - 1;
    pI = i/2;
  }

  
  
  
  function getLeftChildI(uint256 index) private pure returns (uint256 lcI) {
    uint256 i = index * 2;
    lcI = i + 1;
  }

  
  
  function heapSort(uint8[] storage self) public {
    uint256 end = self.length - 1;
    uint256 start = getParentI(end);
    uint256 root = start;
    uint256 lChild;
    uint256 rChild;
    uint256 swap;
    uint8 temp;
    while(start >= 0){
      root = start;
      lChild = getLeftChildI(start);
      while(lChild <= end){
        rChild = lChild + 1;
        swap = root;
        if(self[swap] < self[lChild])
          swap = lChild;
        if((rChild <= end) && (self[swap]<self[rChild]))
          swap = rChild;
        if(swap == root)
          lChild = end+1;
        else {
          temp = self[swap];
          self[swap] = self[root];
          self[root] = temp;
          root = swap;
          lChild = getLeftChildI(root);
        }
      }
      if(start == 0)
        break;
      else
        start = start - 1;
    }
    while(end > 0){
      temp = self[end];
      self[end] = self[0];
      self[0] = temp;
      end = end - 1;
      root = 0;
      lChild = getLeftChildI(0);
      while(lChild <= end){
        rChild = lChild + 1;
        swap = root;
        if(self[swap] < self[lChild])
          swap = lChild;
        if((rChild <= end) && (self[swap]<self[rChild]))
          swap = rChild;
        if(swap == root)
          lChild = end + 1;
        else {
          temp = self[swap];
          self[swap] = self[root];
          self[root] = temp;
          root = swap;
          lChild = getLeftChildI(root);
        }
      }
    }
  }

  
  
function uniq(uint256[] storage self) public returns (uint256 length) {
  for (uint256 i = 0; i < self.length; i++) {
    bool duplicate = false;
    for (uint256 j = 0; j < i; j++) {
      if (self[i] == self[j]) {
        duplicate = true;
        break;
      }
    }
    if (duplicate) {
      for (uint256 j = i; j < self.length - 1; j++) {
        self[j] = self[j + 1];
      }
      self.length--;
      i--;
    }
  }
  return self.length;
}
}



pragma solidity ^0.4.18;






contract ArrayUtilsTestContract {
  using Array256Lib for uint256[];
  using Array128Lib for uint128[];
  using Array64Lib for uint64[];
  using Array32Lib for uint32[];
  using Array16Lib for uint16[];
  using Array8Lib for uint8[];

  uint256[] array256;
  uint128[] array128;
  uint64[] array64;
  uint32[] array32;
  uint16[] array16;
  uint8[] array8;

  event Print(string message, bytes32 test);

  function getSumElements256() returns (uint256){
    delete array256;
    array256.push(2);
    array256.push(10);
    array256.push(0);
    array256.push(10342);
    return array256.sumElements();
  }

  function getGetMaxMiddle256() returns (uint256){
    delete array256;
    array256.push(2);
    array256.push(0);
    array256.push(1058939);
    array256.push(0xfffff);
    return array256.getMax();
  }

  function getGetMinMiddle256() returns (uint256){
    delete array256;
    array256.push(1058939);
    array256.push(17);
    array256.push(21);
    array256.push(0xfffff);
    return array256.getMin();
  }

  function getSumElements128() returns (uint256 test){
    delete array128;
    array128.push(2);
    array128.push(4);
    array128.push(6);
    array128.push(3);

    return array128.sumElements();
  }

  function getSumElements64() returns (uint256 test){
    delete array64;
    array64.push(2);
    array64.push(4);
    array64.push(6);
    array64.push(3);

    return array64.sumElements();
  }

  function getSumElements32() returns (uint256 test){
    delete array32;
    array32.push(2);
    array32.push(4);
    array32.push(6);
    array32.push(3);

    return array32.sumElements();
  }

  function getSumElements16() returns (uint256 test){
    delete array16;
    array16.push(2);
    array16.push(4);
    array16.push(6);
    array16.push(3);

    return array16.sumElements();
  }

  function getSumElements8() returns (uint256 test){
    delete array8;
    array8.push(2);
    array8.push(4);
    array8.push(6);
    array8.push(3);

    return array8.sumElements();
  }

  function getGetMaxMiddle128() returns (uint128){
    delete array128;
    array128.push(2);
    array128.push(29588383);
    array128.push(0);
    array128.push(0xfffff);


    return array128.getMax();
  }

  function getGetMaxMiddle64() returns (uint64){
    delete array64;
    array64.push(2);
    array64.push(29588);
    array64.push(0);
    array64.push(0xff);


    return array64.getMax();
  }

  function getGetMaxMiddle32() returns (uint32){
    delete array32;
    array32.push(2);
    array32.push(29588);
    array32.push(0);
    array32.push(0xff);


    return array32.getMax();
  }

  function getGetMaxMiddle16() returns (uint16){
    delete array16;
    array16.push(2);
    array16.push(29588);
    array16.push(0);
    array16.push(0xff);


    return array16.getMax();
  }

  function getGetMaxMiddle8() returns (uint8){
    delete array8;
    array8.push(2);
    array8.push(29);
    array8.push(152);
    array8.push(0xf);


    return array8.getMax();
  }

  function getGetMinMiddle128() returns (uint128){
    delete array128;
    array128.push(1058939);
    array128.push(73);
    array128.push(17);
    array128.push(0xfffff);
    return array128.getMin();
  }

  function getGetMinMiddle64() returns (uint64){
    delete array64;
    array64.push(1058939);
    array64.push(73);
    array64.push(17);
    array64.push(0xfffff);
    return array64.getMin();
  }

  function getGetMinMiddle32() returns (uint32){
    delete array32;
    array32.push(1058939);
    array32.push(73);
    array32.push(17);
    array32.push(0xfffff);
    return array32.getMin();
  }

  function getGetMinMiddle16() returns (uint16){
    delete array16;
    array16.push(10589);
    array16.push(73);
    array16.push(17);
    array16.push(0xffff);
    return array16.getMin();
  }

  function getGetMinMiddle8() returns (uint8){
    delete array8;
    array8.push(105);
    array8.push(73);
    array8.push(17);
    array8.push(0xff);
    return array8.getMin();
  }

}