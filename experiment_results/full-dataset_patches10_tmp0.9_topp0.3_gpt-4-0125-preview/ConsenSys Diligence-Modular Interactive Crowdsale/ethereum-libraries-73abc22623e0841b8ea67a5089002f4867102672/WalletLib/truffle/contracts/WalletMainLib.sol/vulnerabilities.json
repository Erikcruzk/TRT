{
  "smartbugs_completed": true,
  "analyzer_results": {
    "semgrep": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 215,
          "vulnerability_to_line": null,
          "vulnerability_code": "    for (uint256 i = 0; i < self.length; i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 219,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 j = i; j < self.length - 1; j++){\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 223,
          "vulnerability_to_line": null,
          "vulnerability_code": "        delete self[self.length - 1];\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 224,
          "vulnerability_to_line": null,
          "vulnerability_code": "        self.length--;\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 441,
          "vulnerability_to_line": null,
          "vulnerability_code": "    for (uint256 i=0; i<_owners.length; i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "non-optimal-variables-swap",
          "vulnerability_from_line": 170,
          "vulnerability_to_line": null,
          "vulnerability_code": "          temp = self[swap];\n",
          "message": "Consider swapping variables using `(self[swap], self[root]) = (self[root], self[swap])` to save gas"
        },
        {
          "name": "non-optimal-variables-swap",
          "vulnerability_from_line": 171,
          "vulnerability_to_line": null,
          "vulnerability_code": "          self[swap] = self[root];\n",
          "message": "Consider swapping variables using `(self[swap], self[root]) = (self[root], self[swap])` to save gas"
        },
        {
          "name": "non-optimal-variables-swap",
          "vulnerability_from_line": 172,
          "vulnerability_to_line": null,
          "vulnerability_code": "          self[root] = temp;\n",
          "message": "Consider swapping variables using `(self[swap], self[root]) = (self[root], self[swap])` to save gas"
        },
        {
          "name": "non-optimal-variables-swap",
          "vulnerability_from_line": 183,
          "vulnerability_to_line": null,
          "vulnerability_code": "      temp = self[end];\n",
          "message": "Consider swapping variables using `(self[end], self[0]) = (self[0], self[end])` to save gas"
        },
        {
          "name": "non-optimal-variables-swap",
          "vulnerability_from_line": 184,
          "vulnerability_to_line": null,
          "vulnerability_code": "      self[end] = self[0];\n",
          "message": "Consider swapping variables using `(self[end], self[0]) = (self[0], self[end])` to save gas"
        },
        {
          "name": "non-optimal-variables-swap",
          "vulnerability_from_line": 185,
          "vulnerability_to_line": null,
          "vulnerability_code": "      self[0] = temp;\n",
          "message": "Consider swapping variables using `(self[end], self[0]) = (self[0], self[end])` to save gas"
        },
        {
          "name": "non-optimal-variables-swap",
          "vulnerability_from_line": 199,
          "vulnerability_to_line": null,
          "vulnerability_code": "          temp = self[swap];\n",
          "message": "Consider swapping variables using `(self[swap], self[root]) = (self[root], self[swap])` to save gas"
        },
        {
          "name": "non-optimal-variables-swap",
          "vulnerability_from_line": 200,
          "vulnerability_to_line": null,
          "vulnerability_code": "          self[swap] = self[root];\n",
          "message": "Consider swapping variables using `(self[swap], self[root]) = (self[root], self[swap])` to save gas"
        },
        {
          "name": "non-optimal-variables-swap",
          "vulnerability_from_line": 201,
          "vulnerability_to_line": null,
          "vulnerability_code": "          self[root] = temp;\n",
          "message": "Consider swapping variables using `(self[swap], self[root]) = (self[root], self[swap])` to save gas"
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 215,
          "vulnerability_to_line": null,
          "vulnerability_code": "    for (uint256 i = 0; i < self.length; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 219,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 j = i; j < self.length - 1; j++){\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 441,
          "vulnerability_to_line": null,
          "vulnerability_code": "    for (uint256 i=0; i<_owners.length; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 436,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require(_owners.length >= _requiredAdmin && _requiredAdmin > 0);\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 437,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require(_owners.length >= _requiredMajor && _requiredMajor > 0);\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 438,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require(_owners.length >= _requiredMinor && _requiredMinor > 0);\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 165,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if((rChild <= end) && (self[swap]<self[rChild]))\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 166,
          "vulnerability_to_line": null,
          "vulnerability_code": "          swap = rChild;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 194,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if((rChild <= end) && (self[swap]<self[rChild]))\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 195,
          "vulnerability_to_line": null,
          "vulnerability_code": "          swap = rChild;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 559,
          "vulnerability_to_line": null,
          "vulnerability_code": "    if(_to != 0 && _isTransfer){\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 560,
          "vulnerability_to_line": null,
          "vulnerability_code": "      if((now / 1 days) > self.currentSpend[_to][0]){\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 561,
          "vulnerability_to_line": null,
          "vulnerability_code": "        self.currentSpend[_to][0] = now / 1 days;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 562,
          "vulnerability_to_line": null,
          "vulnerability_code": "        self.currentSpend[_to][1] = 0;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 563,
          "vulnerability_to_line": null,
          "vulnerability_code": "      }\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 564,
          "vulnerability_to_line": null,
          "vulnerability_code": "\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 565,
          "vulnerability_to_line": null,
          "vulnerability_code": "      (err, res) = self.currentSpend[_to][1].plus(_amount);\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 566,
          "vulnerability_to_line": null,
          "vulnerability_code": "      require(!err);\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 567,
          "vulnerability_to_line": null,
          "vulnerability_code": "\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 568,
          "vulnerability_to_line": null,
          "vulnerability_code": "      if(res >= self.majorThreshold[_to])\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-prefix-decrement-not-postfix",
          "vulnerability_from_line": 224,
          "vulnerability_to_line": null,
          "vulnerability_code": "        self.length--;\n",
          "message": "Consider using the prefix decrement expression whenever the return value is not needed. The prefix decrement expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-decrement-not-postfix",
          "vulnerability_from_line": 225,
          "vulnerability_to_line": null,
          "vulnerability_code": "        i--;\n",
          "message": "Consider using the prefix decrement expression whenever the return value is not needed. The prefix decrement expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-decrement-not-postfix",
          "vulnerability_from_line": 639,
          "vulnerability_to_line": null,
          "vulnerability_code": "          _txIndex--; // set the index to the index of the existing transaction\n",
          "message": "Consider using the prefix decrement expression whenever the return value is not needed. The prefix decrement expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-decrement-not-postfix",
          "vulnerability_from_line": 653,
          "vulnerability_to_line": null,
          "vulnerability_code": "      _txIndex--;\n",
          "message": "Consider using the prefix decrement expression whenever the return value is not needed. The prefix decrement expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-decrement-not-postfix",
          "vulnerability_from_line": 703,
          "vulnerability_to_line": null,
          "vulnerability_code": "    _txIndex--;\n",
          "message": "Consider using the prefix decrement expression whenever the return value is not needed. The prefix decrement expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-decrement-not-postfix",
          "vulnerability_from_line": 744,
          "vulnerability_to_line": null,
          "vulnerability_code": "    _txIndex--;\n",
          "message": "Consider using the prefix decrement expression whenever the return value is not needed. The prefix decrement expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-decrement-not-postfix",
          "vulnerability_from_line": 761,
          "vulnerability_to_line": null,
          "vulnerability_code": "    self.transactionInfo[_id][_txIndex].confirmCount--;\n",
          "message": "Consider using the prefix decrement expression whenever the return value is not needed. The prefix decrement expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-decrement-not-postfix",
          "vulnerability_from_line": 767,
          "vulnerability_to_line": null,
          "vulnerability_code": "      self.transactionInfo[_id].length--;\n",
          "message": "Consider using the prefix decrement expression whenever the return value is not needed. The prefix decrement expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 215,
          "vulnerability_to_line": null,
          "vulnerability_code": "    for (uint256 i = 0; i < self.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 219,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 j = i; j < self.length - 1; j++){\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 441,
          "vulnerability_to_line": null,
          "vulnerability_code": "    for (uint256 i=0; i<_owners.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 634,
          "vulnerability_to_line": null,
          "vulnerability_code": "          self.transactionInfo[_id].length++;\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 649,
          "vulnerability_to_line": null,
          "vulnerability_code": "      self.transactionInfo[_id][_txIndex].confirmCount++;\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 709,
          "vulnerability_to_line": null,
          "vulnerability_code": "    self.transactionInfo[_id][_txIndex].confirmCount++;\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        }
      ]
    },
    "slither": {
      "successfull_analysis": true,
      "errors": [
        "EXIT_CODE_58"
      ],
      "vulnerability_findings": [
        {
          "name": "constant-function",
          "vulnerability_from_line": 37,
          "vulnerability_to_line": 45,
          "vulnerability_code": "  function sumElements(uint256[] storage self) public view returns(uint256 sum) {\n\n    assembly {\n\n      mstore(0x60,self_slot)\n\n\n\n      for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } {\n\n        sum := add(sload(add(sha3(0x60,0x20),i)),sum)\n\n      }\n\n    }\n",
          "message": "Array256Lib.sumElements (WalletMainLib.sol#37-45) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 50,
          "vulnerability_to_line": 62,
          "vulnerability_code": "  function getMax(uint256[] storage self) public view returns(uint256 maxValue) {\n\n    assembly {\n\n      mstore(0x60,self_slot)\n\n      maxValue := sload(sha3(0x60,0x20))\n\n\n\n      for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } {\n\n        switch gt(sload(add(sha3(0x60,0x20),i)), maxValue)\n\n        case 1 {\n\n          maxValue := sload(add(sha3(0x60,0x20),i))\n\n        }\n\n      }\n\n    }\n",
          "message": "Array256Lib.getMax (WalletMainLib.sol#50-62) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 67,
          "vulnerability_to_line": 79,
          "vulnerability_code": "  function getMin(uint256[] storage self) public view returns(uint256 minValue) {\n\n    assembly {\n\n      mstore(0x60,self_slot)\n\n      minValue := sload(sha3(0x60,0x20))\n\n\n\n      for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } {\n\n        switch gt(sload(add(sha3(0x60,0x20),i)), minValue)\n\n        case 0 {\n\n          minValue := sload(add(sha3(0x60,0x20),i))\n\n        }\n\n      }\n\n    }\n",
          "message": "Array256Lib.getMin (WalletMainLib.sol#67-79) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 87,
          "vulnerability_to_line": 129,
          "vulnerability_code": "  function indexOf(uint256[] storage self, uint256 value, bool isSorted)\n\n           public\n\n           view\n\n           returns(bool found, uint256 index) {\n\n    assembly{\n\n      mstore(0x60,self_slot)\n\n      switch isSorted\n\n      case 1 {\n\n        let high := sub(sload(self_slot),1)\n\n        let mid := 0\n\n        let low := 0\n\n        for { } iszero(gt(low, high)) { } {\n\n          mid := div(add(low,high),2)\n\n\n\n          switch lt(sload(add(sha3(0x60,0x20),mid)),value)\n\n          case 1 {\n\n             low := add(mid,1)\n\n          }\n\n          case 0 {\n\n            switch gt(sload(add(sha3(0x60,0x20),mid)),value)\n\n            case 1 {\n\n              high := sub(mid,1)\n\n            }\n\n            case 0 {\n\n              found := 1\n\n              index := mid\n\n              low := add(high,1)\n\n            }\n\n          }\n\n        }\n\n      }\n\n      case 0 {\n\n        for { let low := 0 } lt(low, sload(self_slot)) { low := add(low, 1) } {\n\n          switch eq(sload(add(sha3(0x60,0x20),low)), value)\n\n          case 1 {\n\n            found := 1\n\n            index := low\n\n            low := sload(self_slot)\n\n          }\n\n        }\n\n      }\n\n    }\n",
          "message": "Array256Lib.indexOf (WalletMainLib.sol#87-129) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 272,
          "vulnerability_to_line": 281,
          "vulnerability_code": "  function times(uint256 a, uint256 b) public view returns (bool err,uint256 res) {\n\n    assembly{\n\n      res := mul(a,b)\n\n      switch or(iszero(b), eq(div(res,b), a))\n\n      case 0 {\n\n        err := 1\n\n        res := 0\n\n      }\n\n    }\n",
          "message": "BasicMathLib.times (WalletMainLib.sol#272-281) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 289,
          "vulnerability_to_line": 304,
          "vulnerability_code": "  function dividedBy(uint256 a, uint256 b) public view returns (bool err,uint256 i) {\n\n    uint256 res;\n\n    assembly{\n\n      switch iszero(b)\n\n      case 0 {\n\n        res := div(a,b)\n\n        let loc := mload(0x40)\n\n        mstore(add(loc,0x20),res)\n\n        i := mload(add(loc,0x20))\n\n      }\n\n      default {\n\n        err := 1\n\n        i := 0\n\n      }\n\n    }\n",
          "message": "BasicMathLib.dividedBy (WalletMainLib.sol#289-304) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 312,
          "vulnerability_to_line": 321,
          "vulnerability_code": "  function plus(uint256 a, uint256 b) public view returns (bool err, uint256 res) {\n\n    assembly{\n\n      res := add(a,b)\n\n      switch and(eq(sub(res,b), a), or(gt(res,b),eq(res,b)))\n\n      case 0 {\n\n        err := 1\n\n        res := 0\n\n      }\n\n    }\n",
          "message": "BasicMathLib.plus (WalletMainLib.sol#312-321) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 329,
          "vulnerability_to_line": 338,
          "vulnerability_code": "  function minus(uint256 a, uint256 b) public view returns (bool err,uint256 res) {\n\n    assembly{\n\n      res := sub(a,b)\n\n      switch eq(and(eq(add(res,b), a), or(lt(res,a), eq(res,a))), 1)\n\n      case 0 {\n\n        err := 1\n\n        res := 0\n\n      }\n\n    }\n",
          "message": "BasicMathLib.minus (WalletMainLib.sol#329-338) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 506,
          "vulnerability_to_line": 528,
          "vulnerability_code": "  function getAmount(bytes _txData) public pure returns (bool,uint256) {\n\n    bytes32 getSig;\n\n    bytes4 sig;\n\n    bytes4 tSig = 0xa9059cbb; //transfer func signature\n\n    bytes4 aSig = 0x095ea7b3; //approve func signature\n\n    bytes4 tfSig = 0x23b872dd; //transferFrom func signature\n\n    bool transfer;\n\n    bytes32 _amountData;\n\n    uint256 _amount;\n\n\n\n    assembly { getSig := mload(add(_txData,0x20)) }\n\n    sig = bytes4(getSig);\n\n    if(sig ==  tSig || sig == aSig){\n\n      transfer = true;\n\n      assembly { _amountData := mload(add(_txData,0x44)) }\n\n      _amount = uint256(_amountData);\n\n    } else if(sig == tfSig){\n\n      transfer = true;\n\n      assembly { _amountData := mload(add(_txData,0x64)) }\n\n      _amount = uint256(_amountData);\n\n    }\n\n    return (transfer,_amount);\n",
          "message": "WalletMainLib.getAmount (WalletMainLib.sol#506-528) is declared view but contains assembly code\n"
        },
        {
          "name": "uninitialized-local",
          "vulnerability_from_line": 695,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bool ret;\n",
          "message": "ret in WalletMainLib.confirmTx (WalletMainLib.sol#695) is a local variable never initialiazed\n"
        },
        {
          "name": "uninitialized-local",
          "vulnerability_from_line": 615,
          "vulnerability_to_line": null,
          "vulnerability_code": "      bool allGood;\n",
          "message": "allGood in WalletMainLib.serveTx (WalletMainLib.sol#615) is a local variable never initialiazed\n"
        },
        {
          "name": "uninitialized-local",
          "vulnerability_from_line": 616,
          "vulnerability_to_line": null,
          "vulnerability_code": "      uint256 _amount;\n",
          "message": "_amount in WalletMainLib.serveTx (WalletMainLib.sol#616) is a local variable never initialiazed\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 37,
          "vulnerability_to_line": 45,
          "vulnerability_code": "  function sumElements(uint256[] storage self) public view returns(uint256 sum) {\n\n    assembly {\n\n      mstore(0x60,self_slot)\n\n\n\n      for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } {\n\n        sum := add(sload(add(sha3(0x60,0x20),i)),sum)\n\n      }\n\n    }\n",
          "message": "Array256Lib.sumElements uses assembly (WalletMainLib.sol#37-45)\n\t- WalletMainLib.sol#38-45\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 50,
          "vulnerability_to_line": 62,
          "vulnerability_code": "  function getMax(uint256[] storage self) public view returns(uint256 maxValue) {\n\n    assembly {\n\n      mstore(0x60,self_slot)\n\n      maxValue := sload(sha3(0x60,0x20))\n\n\n\n      for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } {\n\n        switch gt(sload(add(sha3(0x60,0x20),i)), maxValue)\n\n        case 1 {\n\n          maxValue := sload(add(sha3(0x60,0x20),i))\n\n        }\n\n      }\n\n    }\n",
          "message": "Array256Lib.getMax uses assembly (WalletMainLib.sol#50-62)\n\t- WalletMainLib.sol#51-62\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 67,
          "vulnerability_to_line": 79,
          "vulnerability_code": "  function getMin(uint256[] storage self) public view returns(uint256 minValue) {\n\n    assembly {\n\n      mstore(0x60,self_slot)\n\n      minValue := sload(sha3(0x60,0x20))\n\n\n\n      for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } {\n\n        switch gt(sload(add(sha3(0x60,0x20),i)), minValue)\n\n        case 0 {\n\n          minValue := sload(add(sha3(0x60,0x20),i))\n\n        }\n\n      }\n\n    }\n",
          "message": "Array256Lib.getMin uses assembly (WalletMainLib.sol#67-79)\n\t- WalletMainLib.sol#68-79\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 87,
          "vulnerability_to_line": 129,
          "vulnerability_code": "  function indexOf(uint256[] storage self, uint256 value, bool isSorted)\n\n           public\n\n           view\n\n           returns(bool found, uint256 index) {\n\n    assembly{\n\n      mstore(0x60,self_slot)\n\n      switch isSorted\n\n      case 1 {\n\n        let high := sub(sload(self_slot),1)\n\n        let mid := 0\n\n        let low := 0\n\n        for { } iszero(gt(low, high)) { } {\n\n          mid := div(add(low,high),2)\n\n\n\n          switch lt(sload(add(sha3(0x60,0x20),mid)),value)\n\n          case 1 {\n\n             low := add(mid,1)\n\n          }\n\n          case 0 {\n\n            switch gt(sload(add(sha3(0x60,0x20),mid)),value)\n\n            case 1 {\n\n              high := sub(mid,1)\n\n            }\n\n            case 0 {\n\n              found := 1\n\n              index := mid\n\n              low := add(high,1)\n\n            }\n\n          }\n\n        }\n\n      }\n\n      case 0 {\n\n        for { let low := 0 } lt(low, sload(self_slot)) { low := add(low, 1) } {\n\n          switch eq(sload(add(sha3(0x60,0x20),low)), value)\n\n          case 1 {\n\n            found := 1\n\n            index := low\n\n            low := sload(self_slot)\n\n          }\n\n        }\n\n      }\n\n    }\n",
          "message": "Array256Lib.indexOf uses assembly (WalletMainLib.sol#87-129)\n\t- WalletMainLib.sol#91-129\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 272,
          "vulnerability_to_line": 281,
          "vulnerability_code": "  function times(uint256 a, uint256 b) public view returns (bool err,uint256 res) {\n\n    assembly{\n\n      res := mul(a,b)\n\n      switch or(iszero(b), eq(div(res,b), a))\n\n      case 0 {\n\n        err := 1\n\n        res := 0\n\n      }\n\n    }\n",
          "message": "BasicMathLib.times uses assembly (WalletMainLib.sol#272-281)\n\t- WalletMainLib.sol#273-281\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 289,
          "vulnerability_to_line": 304,
          "vulnerability_code": "  function dividedBy(uint256 a, uint256 b) public view returns (bool err,uint256 i) {\n\n    uint256 res;\n\n    assembly{\n\n      switch iszero(b)\n\n      case 0 {\n\n        res := div(a,b)\n\n        let loc := mload(0x40)\n\n        mstore(add(loc,0x20),res)\n\n        i := mload(add(loc,0x20))\n\n      }\n\n      default {\n\n        err := 1\n\n        i := 0\n\n      }\n\n    }\n",
          "message": "BasicMathLib.dividedBy uses assembly (WalletMainLib.sol#289-304)\n\t- WalletMainLib.sol#291-304\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 312,
          "vulnerability_to_line": 321,
          "vulnerability_code": "  function plus(uint256 a, uint256 b) public view returns (bool err, uint256 res) {\n\n    assembly{\n\n      res := add(a,b)\n\n      switch and(eq(sub(res,b), a), or(gt(res,b),eq(res,b)))\n\n      case 0 {\n\n        err := 1\n\n        res := 0\n\n      }\n\n    }\n",
          "message": "BasicMathLib.plus uses assembly (WalletMainLib.sol#312-321)\n\t- WalletMainLib.sol#313-321\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 329,
          "vulnerability_to_line": 338,
          "vulnerability_code": "  function minus(uint256 a, uint256 b) public view returns (bool err,uint256 res) {\n\n    assembly{\n\n      res := sub(a,b)\n\n      switch eq(and(eq(add(res,b), a), or(lt(res,a), eq(res,a))), 1)\n\n      case 0 {\n\n        err := 1\n\n        res := 0\n\n      }\n\n    }\n",
          "message": "BasicMathLib.minus uses assembly (WalletMainLib.sol#329-338)\n\t- WalletMainLib.sol#330-338\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 506,
          "vulnerability_to_line": 528,
          "vulnerability_code": "  function getAmount(bytes _txData) public pure returns (bool,uint256) {\n\n    bytes32 getSig;\n\n    bytes4 sig;\n\n    bytes4 tSig = 0xa9059cbb; //transfer func signature\n\n    bytes4 aSig = 0x095ea7b3; //approve func signature\n\n    bytes4 tfSig = 0x23b872dd; //transferFrom func signature\n\n    bool transfer;\n\n    bytes32 _amountData;\n\n    uint256 _amount;\n\n\n\n    assembly { getSig := mload(add(_txData,0x20)) }\n\n    sig = bytes4(getSig);\n\n    if(sig ==  tSig || sig == aSig){\n\n      transfer = true;\n\n      assembly { _amountData := mload(add(_txData,0x44)) }\n\n      _amount = uint256(_amountData);\n\n    } else if(sig == tfSig){\n\n      transfer = true;\n\n      assembly { _amountData := mload(add(_txData,0x64)) }\n\n      _amount = uint256(_amountData);\n\n    }\n\n    return (transfer,_amount);\n",
          "message": "WalletMainLib.getAmount uses assembly (WalletMainLib.sol#506-528)\n\t- WalletMainLib.sol#516-517\n\t- WalletMainLib.sol#520-521\n\t- WalletMainLib.sol#524-525\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 578,
          "vulnerability_to_line": 588,
          "vulnerability_code": "  function createContract(bytes _txData, uint256 _value) public {\n\n    address _newContract;\n\n    bool allGood;\n\n\n\n    assembly {\n\n      _newContract := create(_value, add(_txData, 0x20), mload(_txData))\n\n      allGood := gt(extcodesize(_newContract),0)\n\n    }\n\n    require(allGood);\n\n    LogContractCreated(_newContract, _value);\n",
          "message": "WalletMainLib.createContract uses assembly (WalletMainLib.sol#578-588)\n\t- WalletMainLib.sol#582-586\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 37,
          "vulnerability_to_line": 45,
          "vulnerability_code": "  function sumElements(uint256[] storage self) public view returns(uint256 sum) {\n\n    assembly {\n\n      mstore(0x60,self_slot)\n\n\n\n      for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } {\n\n        sum := add(sload(add(sha3(0x60,0x20),i)),sum)\n\n      }\n\n    }\n",
          "message": "Array256Lib.sumElements (WalletMainLib.sol#37-45) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 50,
          "vulnerability_to_line": 62,
          "vulnerability_code": "  function getMax(uint256[] storage self) public view returns(uint256 maxValue) {\n\n    assembly {\n\n      mstore(0x60,self_slot)\n\n      maxValue := sload(sha3(0x60,0x20))\n\n\n\n      for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } {\n\n        switch gt(sload(add(sha3(0x60,0x20),i)), maxValue)\n\n        case 1 {\n\n          maxValue := sload(add(sha3(0x60,0x20),i))\n\n        }\n\n      }\n\n    }\n",
          "message": "Array256Lib.getMax (WalletMainLib.sol#50-62) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 67,
          "vulnerability_to_line": 79,
          "vulnerability_code": "  function getMin(uint256[] storage self) public view returns(uint256 minValue) {\n\n    assembly {\n\n      mstore(0x60,self_slot)\n\n      minValue := sload(sha3(0x60,0x20))\n\n\n\n      for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } {\n\n        switch gt(sload(add(sha3(0x60,0x20),i)), minValue)\n\n        case 0 {\n\n          minValue := sload(add(sha3(0x60,0x20),i))\n\n        }\n\n      }\n\n    }\n",
          "message": "Array256Lib.getMin (WalletMainLib.sol#67-79) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 149,
          "vulnerability_to_line": 207,
          "vulnerability_code": "  function heapSort(uint256[] storage self) public {\n\n    uint256 end = self.length - 1;\n\n    uint256 start = getParentI(end);\n\n    uint256 root = start;\n\n    uint256 lChild;\n\n    uint256 rChild;\n\n    uint256 swap;\n\n    uint256 temp;\n\n    while(start >= 0){\n\n      root = start;\n\n      lChild = getLeftChildI(start);\n\n      while(lChild <= end){\n\n        rChild = lChild + 1;\n\n        swap = root;\n\n        if(self[swap] < self[lChild])\n\n          swap = lChild;\n\n        if((rChild <= end) && (self[swap]<self[rChild]))\n\n          swap = rChild;\n\n        if(swap == root)\n\n          lChild = end+1;\n\n        else {\n\n          temp = self[swap];\n\n          self[swap] = self[root];\n\n          self[root] = temp;\n\n          root = swap;\n\n          lChild = getLeftChildI(root);\n\n        }\n\n      }\n\n      if(start == 0)\n\n        break;\n\n      else\n\n        start = start - 1;\n\n    }\n\n    while(end > 0){\n\n      temp = self[end];\n\n      self[end] = self[0];\n\n      self[0] = temp;\n\n      end = end - 1;\n\n      root = 0;\n\n      lChild = getLeftChildI(0);\n\n      while(lChild <= end){\n\n        rChild = lChild + 1;\n\n        swap = root;\n\n        if(self[swap] < self[lChild])\n\n          swap = lChild;\n\n        if((rChild <= end) && (self[swap]<self[rChild]))\n\n          swap = rChild;\n\n        if(swap == root)\n\n          lChild = end + 1;\n\n        else {\n\n          temp = self[swap];\n\n          self[swap] = self[root];\n\n          self[root] = temp;\n\n          root = swap;\n\n          lChild = getLeftChildI(root);\n\n        }\n\n      }\n\n    }\n",
          "message": "Array256Lib.heapSort (WalletMainLib.sol#149-207) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 211,
          "vulnerability_to_line": 230,
          "vulnerability_code": "  function uniq(uint256[] storage self) public returns (uint256 length) {\n\n    bool contains;\n\n    uint256 index;\n\n\n\n    for (uint256 i = 0; i < self.length; i++) {\n\n      (contains, index) = indexOf(self, self[i], false);\n\n\n\n      if (i > index) {\n\n        for (uint256 j = i; j < self.length - 1; j++){\n\n          self[j] = self[j + 1];\n\n        }\n\n\n\n        delete self[self.length - 1];\n\n        self.length--;\n\n        i--;\n\n      }\n\n    }\n\n\n\n    length = self.length;\n",
          "message": "Array256Lib.uniq (WalletMainLib.sol#211-230) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 272,
          "vulnerability_to_line": 281,
          "vulnerability_code": "  function times(uint256 a, uint256 b) public view returns (bool err,uint256 res) {\n\n    assembly{\n\n      res := mul(a,b)\n\n      switch or(iszero(b), eq(div(res,b), a))\n\n      case 0 {\n\n        err := 1\n\n        res := 0\n\n      }\n\n    }\n",
          "message": "BasicMathLib.times (WalletMainLib.sol#272-281) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 289,
          "vulnerability_to_line": 304,
          "vulnerability_code": "  function dividedBy(uint256 a, uint256 b) public view returns (bool err,uint256 i) {\n\n    uint256 res;\n\n    assembly{\n\n      switch iszero(b)\n\n      case 0 {\n\n        res := div(a,b)\n\n        let loc := mload(0x40)\n\n        mstore(add(loc,0x20),res)\n\n        i := mload(add(loc,0x20))\n\n      }\n\n      default {\n\n        err := 1\n\n        i := 0\n\n      }\n\n    }\n",
          "message": "BasicMathLib.dividedBy (WalletMainLib.sol#289-304) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 312,
          "vulnerability_to_line": 321,
          "vulnerability_code": "  function plus(uint256 a, uint256 b) public view returns (bool err, uint256 res) {\n\n    assembly{\n\n      res := add(a,b)\n\n      switch and(eq(sub(res,b), a), or(gt(res,b),eq(res,b)))\n\n      case 0 {\n\n        err := 1\n\n        res := 0\n\n      }\n\n    }\n",
          "message": "BasicMathLib.plus (WalletMainLib.sol#312-321) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 329,
          "vulnerability_to_line": 338,
          "vulnerability_code": "  function minus(uint256 a, uint256 b) public view returns (bool err,uint256 res) {\n\n    assembly{\n\n      res := sub(a,b)\n\n      switch eq(and(eq(add(res,b), a), or(lt(res,a), eq(res,a))), 1)\n\n      case 0 {\n\n        err := 1\n\n        res := 0\n\n      }\n\n    }\n",
          "message": "BasicMathLib.minus (WalletMainLib.sol#329-338) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 428,
          "vulnerability_to_line": 453,
          "vulnerability_code": "  function init(WalletData storage self,\n\n                address[] _owners,\n\n                uint256 _requiredAdmin,\n\n                uint256 _requiredMajor,\n\n                uint256 _requiredMinor,\n\n                uint256 _majorThreshold) public returns (bool)\n\n  {\n\n    require(self.owners.length == 0);\n\n    require(_owners.length >= _requiredAdmin && _requiredAdmin > 0);\n\n    require(_owners.length >= _requiredMajor && _requiredMajor > 0);\n\n    require(_owners.length >= _requiredMinor && _requiredMinor > 0);\n\n    self.owners.push(0); //Leave index-0 empty for easier owner checks\n\n\n\n    for (uint256 i=0; i<_owners.length; i++) {\n\n      require(_owners[i] != 0);\n\n      self.owners.push(_owners[i]);\n\n      self.ownerIndex[_owners[i]] = i+1;\n\n    }\n\n    self.requiredAdmin = _requiredAdmin;\n\n    self.requiredMajor = _requiredMajor;\n\n    self.requiredMinor = _requiredMinor;\n\n    self.maxOwners = 50; //Limits to 50 owners, should create wallet pools for more owners\n\n    self.majorThreshold[0] = _majorThreshold; //Sets ether threshold at address 0\n\n\n\n    return true;\n",
          "message": "WalletMainLib.init (WalletMainLib.sol#428-453) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 601,
          "vulnerability_to_line": 683,
          "vulnerability_code": "  function serveTx(WalletData storage self,\n\n                   address _to,\n\n                   uint256 _value,\n\n                   bytes _txData,\n\n                   bool _confirm,\n\n                   bytes _data)\n\n                   public returns (bool,bytes32)\n\n  {\n\n    bytes32 _id = keccak256(\"serveTx\",_to,_value,_txData);\n\n    uint256 _txIndex = self.transactionInfo[_id].length;\n\n    uint256 _required = self.requiredMajor;\n\n\n\n    //Run checks if not called from generic confirm/revoke function\n\n    if(msg.sender != address(this)){\n\n      bool allGood;\n\n      uint256 _amount;\n\n      // if the owner is revoking his/her confirmation but doesn't know the\n\n      // specific transaction id hash\n\n      if(!_confirm) {\n\n        allGood = revokeConfirm(self, _id);\n\n        return (allGood,_id);\n\n      } else { // else confirming the transaction\n\n        //Reuse allGood due to stack limit\n\n        if(_to != 0)\n\n          (allGood,_amount) = getAmount(_txData);\n\n\n\n        //if this is a new transaction id or if a previous identical transaction had already succeeded\n\n        if(_txIndex == 0 || self.transactionInfo[_id][_txIndex - 1].success){\n\n          require(self.ownerIndex[msg.sender] > 0);\n\n\n\n          _required = getRequired(self, _to, _value, allGood,_amount);\n\n\n\n          // add this transaction to the wallets record and initialize the settings\n\n          self.transactionInfo[_id].length++;\n\n          self.transactionInfo[_id][_txIndex].confirmRequired = _required;\n\n          self.transactionInfo[_id][_txIndex].day = now / 1 days;\n\n          self.transactions[now / 1 days].push(_id);\n\n        } else { // else the transaction is already pending\n\n          _txIndex--; // set the index to the index of the existing transaction\n\n          //make sure the sender isn't already confirmed\n\n          allGood = checkNotConfirmed(self, _id, _txIndex);\n\n          if(!allGood)\n\n            return (false,_id);\n\n        }\n\n      }\n\n\n\n      // add the senders confirmation to the transaction\n\n      self.transactionInfo[_id][_txIndex].confirmedOwners.push(uint256(msg.sender));\n\n      self.transactionInfo[_id][_txIndex].confirmCount++;\n\n    } else {\n\n      // else were calling from generic confirm/revoke function, set the\n\n      // _txIndex index to the index of the existing transaction\n\n      _txIndex--;\n\n    }\n\n\n\n    // if there are enough confirmations\n\n    if(self.transactionInfo[_id][_txIndex].confirmCount ==\n\n       self.transactionInfo[_id][_txIndex].confirmRequired)\n\n    {\n\n      // execute the transaction\n\n      self.currentSpend[0][1] += _value;\n\n      self.currentSpend[_to][1] += _amount;\n\n      self.transactionInfo[_id][_txIndex].success = true;\n\n\n\n      if(_to == 0){\n\n        //Failure is self contained in method\n\n        createContract(_txData, _value);\n\n      } else {\n\n        require(_to.call.value(_value)(_txData));\n\n      }\n\n      delete self.transactionInfo[_id][_txIndex].data;\n\n      LogTransactionComplete(_id, _to, _value, _data);\n\n    } else {\n\n      if(self.transactionInfo[_id][_txIndex].data.length == 0)\n\n        self.transactionInfo[_id][_txIndex].data = _data;\n\n\n\n      uint256 confirmsNeeded = calcConfirmsNeeded(self.transactionInfo[_id][_txIndex].confirmRequired,\n\n                                               self.transactionInfo[_id][_txIndex].confirmCount);\n\n      LogTransactionConfirmed(_id, msg.sender, confirmsNeeded);\n\n    }\n\n\n\n    return (true,_id);\n",
          "message": "WalletMainLib.serveTx (WalletMainLib.sol#601-683) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 691,
          "vulnerability_to_line": 725,
          "vulnerability_code": "  function confirmTx(WalletData storage self, bytes32 _id)\n\n                     public returns (bool) {\n\n    require(self.ownerIndex[msg.sender] > 0);\n\n    uint256 _txIndex = self.transactionInfo[_id].length;\n\n    bool ret;\n\n\n\n    if(_txIndex == 0){\n\n      LogErrorMsg(_txIndex, \"Tx not initiated\");\n\n      LogTransactionFailed(_id, msg.sender);\n\n      return false;\n\n    }\n\n\n\n    _txIndex--;\n\n    bool allGood = checkNotConfirmed(self, _id, _txIndex);\n\n    if(!allGood)\n\n      return false;\n\n\n\n    self.transactionInfo[_id][_txIndex].confirmedOwners.push(uint256(msg.sender));\n\n    self.transactionInfo[_id][_txIndex].confirmCount++;\n\n\n\n    if(self.transactionInfo[_id][_txIndex].confirmCount ==\n\n       self.transactionInfo[_id][_txIndex].confirmRequired)\n\n    {\n\n      address a = address(this);\n\n      require(a.call(self.transactionInfo[_id][_txIndex].data));\n\n    } else {\n\n      uint256 confirmsNeeded = calcConfirmsNeeded(self.transactionInfo[_id][_txIndex].confirmRequired,\n\n                                               self.transactionInfo[_id][_txIndex].confirmCount);\n\n\n\n      LogTransactionConfirmed(_id, msg.sender, confirmsNeeded);\n\n      ret = true;\n\n    }\n\n\n\n    return ret;\n",
          "message": "WalletMainLib.confirmTx (WalletMainLib.sol#691-725) should be declared external\n"
        },
        {
          "name": "solc-version",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.18;\n",
          "message": "Detected issues with version pragma in WalletMainLib.sol:\n\t- pragma solidity^0.4.18 (WalletMainLib.sol#3): it allows old versions\n\t- pragma solidity^0.4.18 (WalletMainLib.sol#235): it allows old versions\n\t- pragma solidity^0.4.18 (WalletMainLib.sol#343): it allows old versions\n"
        },
        {
          "name": "low-level-calls",
          "vulnerability_from_line": 601,
          "vulnerability_to_line": 683,
          "vulnerability_code": "  function serveTx(WalletData storage self,\n\n                   address _to,\n\n                   uint256 _value,\n\n                   bytes _txData,\n\n                   bool _confirm,\n\n                   bytes _data)\n\n                   public returns (bool,bytes32)\n\n  {\n\n    bytes32 _id = keccak256(\"serveTx\",_to,_value,_txData);\n\n    uint256 _txIndex = self.transactionInfo[_id].length;\n\n    uint256 _required = self.requiredMajor;\n\n\n\n    //Run checks if not called from generic confirm/revoke function\n\n    if(msg.sender != address(this)){\n\n      bool allGood;\n\n      uint256 _amount;\n\n      // if the owner is revoking his/her confirmation but doesn't know the\n\n      // specific transaction id hash\n\n      if(!_confirm) {\n\n        allGood = revokeConfirm(self, _id);\n\n        return (allGood,_id);\n\n      } else { // else confirming the transaction\n\n        //Reuse allGood due to stack limit\n\n        if(_to != 0)\n\n          (allGood,_amount) = getAmount(_txData);\n\n\n\n        //if this is a new transaction id or if a previous identical transaction had already succeeded\n\n        if(_txIndex == 0 || self.transactionInfo[_id][_txIndex - 1].success){\n\n          require(self.ownerIndex[msg.sender] > 0);\n\n\n\n          _required = getRequired(self, _to, _value, allGood,_amount);\n\n\n\n          // add this transaction to the wallets record and initialize the settings\n\n          self.transactionInfo[_id].length++;\n\n          self.transactionInfo[_id][_txIndex].confirmRequired = _required;\n\n          self.transactionInfo[_id][_txIndex].day = now / 1 days;\n\n          self.transactions[now / 1 days].push(_id);\n\n        } else { // else the transaction is already pending\n\n          _txIndex--; // set the index to the index of the existing transaction\n\n          //make sure the sender isn't already confirmed\n\n          allGood = checkNotConfirmed(self, _id, _txIndex);\n\n          if(!allGood)\n\n            return (false,_id);\n\n        }\n\n      }\n\n\n\n      // add the senders confirmation to the transaction\n\n      self.transactionInfo[_id][_txIndex].confirmedOwners.push(uint256(msg.sender));\n\n      self.transactionInfo[_id][_txIndex].confirmCount++;\n\n    } else {\n\n      // else were calling from generic confirm/revoke function, set the\n\n      // _txIndex index to the index of the existing transaction\n\n      _txIndex--;\n\n    }\n\n\n\n    // if there are enough confirmations\n\n    if(self.transactionInfo[_id][_txIndex].confirmCount ==\n\n       self.transactionInfo[_id][_txIndex].confirmRequired)\n\n    {\n\n      // execute the transaction\n\n      self.currentSpend[0][1] += _value;\n\n      self.currentSpend[_to][1] += _amount;\n\n      self.transactionInfo[_id][_txIndex].success = true;\n\n\n\n      if(_to == 0){\n\n        //Failure is self contained in method\n\n        createContract(_txData, _value);\n\n      } else {\n\n        require(_to.call.value(_value)(_txData));\n\n      }\n\n      delete self.transactionInfo[_id][_txIndex].data;\n\n      LogTransactionComplete(_id, _to, _value, _data);\n\n    } else {\n\n      if(self.transactionInfo[_id][_txIndex].data.length == 0)\n\n        self.transactionInfo[_id][_txIndex].data = _data;\n\n\n\n      uint256 confirmsNeeded = calcConfirmsNeeded(self.transactionInfo[_id][_txIndex].confirmRequired,\n\n                                               self.transactionInfo[_id][_txIndex].confirmCount);\n\n      LogTransactionConfirmed(_id, msg.sender, confirmsNeeded);\n\n    }\n\n\n\n    return (true,_id);\n",
          "message": "Low level call in WalletMainLib.serveTx (WalletMainLib.sol#601-683):\n\t-require(bool)(_to.call.value(_value)(_txData)) WalletMainLib.sol#669\n"
        },
        {
          "name": "low-level-calls",
          "vulnerability_from_line": 691,
          "vulnerability_to_line": 725,
          "vulnerability_code": "  function confirmTx(WalletData storage self, bytes32 _id)\n\n                     public returns (bool) {\n\n    require(self.ownerIndex[msg.sender] > 0);\n\n    uint256 _txIndex = self.transactionInfo[_id].length;\n\n    bool ret;\n\n\n\n    if(_txIndex == 0){\n\n      LogErrorMsg(_txIndex, \"Tx not initiated\");\n\n      LogTransactionFailed(_id, msg.sender);\n\n      return false;\n\n    }\n\n\n\n    _txIndex--;\n\n    bool allGood = checkNotConfirmed(self, _id, _txIndex);\n\n    if(!allGood)\n\n      return false;\n\n\n\n    self.transactionInfo[_id][_txIndex].confirmedOwners.push(uint256(msg.sender));\n\n    self.transactionInfo[_id][_txIndex].confirmCount++;\n\n\n\n    if(self.transactionInfo[_id][_txIndex].confirmCount ==\n\n       self.transactionInfo[_id][_txIndex].confirmRequired)\n\n    {\n\n      address a = address(this);\n\n      require(a.call(self.transactionInfo[_id][_txIndex].data));\n\n    } else {\n\n      uint256 confirmsNeeded = calcConfirmsNeeded(self.transactionInfo[_id][_txIndex].confirmRequired,\n\n                                               self.transactionInfo[_id][_txIndex].confirmCount);\n\n\n\n      LogTransactionConfirmed(_id, msg.sender, confirmsNeeded);\n\n      ret = true;\n\n    }\n\n\n\n    return ret;\n",
          "message": "Low level call in WalletMainLib.confirmTx (WalletMainLib.sol#691-725):\n\t-require(bool)(a.call(self.transactionInfo[_id][_txIndex].data)) WalletMainLib.sol#715\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 429,
          "vulnerability_to_line": null,
          "vulnerability_code": "                address[] _owners,\n",
          "message": "Parameter '_owners' of WalletMainLib.init (WalletMainLib.sol#429) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 430,
          "vulnerability_to_line": null,
          "vulnerability_code": "                uint256 _requiredAdmin,\n",
          "message": "Parameter '_requiredAdmin' of WalletMainLib.init (WalletMainLib.sol#430) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 431,
          "vulnerability_to_line": null,
          "vulnerability_code": "                uint256 _requiredMajor,\n",
          "message": "Parameter '_requiredMajor' of WalletMainLib.init (WalletMainLib.sol#431) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 432,
          "vulnerability_to_line": null,
          "vulnerability_code": "                uint256 _requiredMinor,\n",
          "message": "Parameter '_requiredMinor' of WalletMainLib.init (WalletMainLib.sol#432) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 433,
          "vulnerability_to_line": null,
          "vulnerability_code": "                uint256 _majorThreshold) public returns (bool)\n",
          "message": "Parameter '_majorThreshold' of WalletMainLib.init (WalletMainLib.sol#433) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 462,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function checkNotConfirmed(WalletData storage self, bytes32 _id, uint256 _txIndex)\n",
          "message": "Parameter '_id' of WalletMainLib.checkNotConfirmed (WalletMainLib.sol#462) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 462,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function checkNotConfirmed(WalletData storage self, bytes32 _id, uint256 _txIndex)\n",
          "message": "Parameter '_txIndex' of WalletMainLib.checkNotConfirmed (WalletMainLib.sol#462) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 498,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function calcConfirmsNeeded(uint256 _required, uint256 _count) public pure returns (uint256){\n",
          "message": "Parameter '_required' of WalletMainLib.calcConfirmsNeeded (WalletMainLib.sol#498) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 498,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function calcConfirmsNeeded(uint256 _required, uint256 _count) public pure returns (uint256){\n",
          "message": "Parameter '_count' of WalletMainLib.calcConfirmsNeeded (WalletMainLib.sol#498) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 538,
          "vulnerability_to_line": null,
          "vulnerability_code": "                       address _to,\n",
          "message": "Parameter '_to' of WalletMainLib.getRequired (WalletMainLib.sol#538) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 539,
          "vulnerability_to_line": null,
          "vulnerability_code": "                       uint256 _value,\n",
          "message": "Parameter '_value' of WalletMainLib.getRequired (WalletMainLib.sol#539) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 540,
          "vulnerability_to_line": null,
          "vulnerability_code": "                       bool _isTransfer,\n",
          "message": "Parameter '_isTransfer' of WalletMainLib.getRequired (WalletMainLib.sol#540) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 541,
          "vulnerability_to_line": null,
          "vulnerability_code": "                       uint256 _amount)\n",
          "message": "Parameter '_amount' of WalletMainLib.getRequired (WalletMainLib.sol#541) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 578,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function createContract(bytes _txData, uint256 _value) public {\n",
          "message": "Parameter '_value' of WalletMainLib.createContract (WalletMainLib.sol#578) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 602,
          "vulnerability_to_line": null,
          "vulnerability_code": "                   address _to,\n",
          "message": "Parameter '_to' of WalletMainLib.serveTx (WalletMainLib.sol#602) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 603,
          "vulnerability_to_line": null,
          "vulnerability_code": "                   uint256 _value,\n",
          "message": "Parameter '_value' of WalletMainLib.serveTx (WalletMainLib.sol#603) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 604,
          "vulnerability_to_line": null,
          "vulnerability_code": "                   bytes _txData,\n",
          "message": "Parameter '_txData' of WalletMainLib.serveTx (WalletMainLib.sol#604) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 605,
          "vulnerability_to_line": null,
          "vulnerability_code": "                   bool _confirm,\n",
          "message": "Parameter '_confirm' of WalletMainLib.serveTx (WalletMainLib.sol#605) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 606,
          "vulnerability_to_line": null,
          "vulnerability_code": "                   bytes _data)\n",
          "message": "Parameter '_data' of WalletMainLib.serveTx (WalletMainLib.sol#606) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 691,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function confirmTx(WalletData storage self, bytes32 _id)\n",
          "message": "Parameter '_id' of WalletMainLib.confirmTx (WalletMainLib.sol#691) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 731,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function revokeConfirm(WalletData storage self, bytes32 _id)\n",
          "message": "Parameter '_id' of WalletMainLib.revokeConfirm (WalletMainLib.sol#731) is not in mixedCase\n"
        }
      ]
    },
    "smartcheck": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 509,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bytes4 tSig = 0xa9059cbb; //transfer func signature\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 510,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bytes4 aSig = 0x095ea7b3; //approve func signature\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 511,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bytes4 tfSig = 0x23b872dd; //transferFrom func signature\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ARRAY_LENGTH_MANIPULATION",
          "vulnerability_from_line": 224,
          "vulnerability_to_line": null,
          "vulnerability_code": "        self.length--;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ARRAY_LENGTH_MANIPULATION",
          "vulnerability_from_line": 767,
          "vulnerability_to_line": null,
          "vulnerability_code": "      self.transactionInfo[_id].length--;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ARRAY_LENGTH_MANIPULATION",
          "vulnerability_from_line": 634,
          "vulnerability_to_line": null,
          "vulnerability_code": "          self.transactionInfo[_id].length++;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
          "vulnerability_from_line": 42,
          "vulnerability_to_line": null,
          "vulnerability_code": "        sum := add(sload(add(sha3(0x60,0x20),i)),sum)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
          "vulnerability_from_line": 53,
          "vulnerability_to_line": null,
          "vulnerability_code": "      maxValue := sload(sha3(0x60,0x20))\n",
          "message": null
        },
        {
          "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
          "vulnerability_from_line": 56,
          "vulnerability_to_line": null,
          "vulnerability_code": "        switch gt(sload(add(sha3(0x60,0x20),i)), maxValue)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
          "vulnerability_from_line": 58,
          "vulnerability_to_line": null,
          "vulnerability_code": "          maxValue := sload(add(sha3(0x60,0x20),i))\n",
          "message": null
        },
        {
          "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
          "vulnerability_from_line": 70,
          "vulnerability_to_line": null,
          "vulnerability_code": "      minValue := sload(sha3(0x60,0x20))\n",
          "message": null
        },
        {
          "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
          "vulnerability_from_line": 73,
          "vulnerability_to_line": null,
          "vulnerability_code": "        switch gt(sload(add(sha3(0x60,0x20),i)), minValue)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
          "vulnerability_from_line": 75,
          "vulnerability_to_line": null,
          "vulnerability_code": "          minValue := sload(add(sha3(0x60,0x20),i))\n",
          "message": null
        },
        {
          "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
          "vulnerability_from_line": 101,
          "vulnerability_to_line": null,
          "vulnerability_code": "          switch lt(sload(add(sha3(0x60,0x20),mid)),value)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
          "vulnerability_from_line": 106,
          "vulnerability_to_line": null,
          "vulnerability_code": "            switch gt(sload(add(sha3(0x60,0x20),mid)),value)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
          "vulnerability_from_line": 120,
          "vulnerability_to_line": null,
          "vulnerability_code": "          switch eq(sload(add(sha3(0x60,0x20),low)), value)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 215,
          "vulnerability_to_line": null,
          "vulnerability_code": "    for (uint256 i = 0; i < self.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 219,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 j = i; j < self.length - 1; j++){\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 441,
          "vulnerability_to_line": null,
          "vulnerability_code": "    for (uint256 i=0; i<_owners.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
          "vulnerability_from_line": 37,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function sumElements(uint256[] storage self) public view returns(uint256 sum) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
          "vulnerability_from_line": 50,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function getMax(uint256[] storage self) public view returns(uint256 maxValue) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
          "vulnerability_from_line": 67,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function getMin(uint256[] storage self) public view returns(uint256 minValue) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
          "vulnerability_from_line": 87,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function indexOf(uint256[] storage self, uint256 value, bool isSorted)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
          "vulnerability_from_line": 272,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function times(uint256 a, uint256 b) public view returns (bool err,uint256 res) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
          "vulnerability_from_line": 289,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function dividedBy(uint256 a, uint256 b) public view returns (bool err,uint256 i) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
          "vulnerability_from_line": 312,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function plus(uint256 a, uint256 b) public view returns (bool err, uint256 res) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
          "vulnerability_from_line": 329,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function minus(uint256 a, uint256 b) public view returns (bool err,uint256 res) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 215,
          "vulnerability_to_line": null,
          "vulnerability_code": "    for (uint256 i = 0; i < self.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 441,
          "vulnerability_to_line": null,
          "vulnerability_code": "    for (uint256 i=0; i<_owners.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 160,
          "vulnerability_to_line": null,
          "vulnerability_code": "      while(lChild <= end){\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 189,
          "vulnerability_to_line": null,
          "vulnerability_code": "      while(lChild <= end){\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.18;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 235,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.18;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 343,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.18;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 506,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function getAmount(bytes _txData) public pure returns (bool,uint256) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
          "vulnerability_from_line": 37,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function sumElements(uint256[] storage self) public view returns(uint256 sum) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
          "vulnerability_from_line": 50,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function getMax(uint256[] storage self) public view returns(uint256 maxValue) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
          "vulnerability_from_line": 67,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function getMin(uint256[] storage self) public view returns(uint256 minValue) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
          "vulnerability_from_line": 87,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function indexOf(uint256[] storage self, uint256 value, bool isSorted)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
          "vulnerability_from_line": 272,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function times(uint256 a, uint256 b) public view returns (bool err,uint256 res) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
          "vulnerability_from_line": 289,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function dividedBy(uint256 a, uint256 b) public view returns (bool err,uint256 i) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
          "vulnerability_from_line": 312,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function plus(uint256 a, uint256 b) public view returns (bool err, uint256 res) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
          "vulnerability_from_line": 329,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function minus(uint256 a, uint256 b) public view returns (bool err,uint256 res) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UINT_CANT_BE_NEGATIVE",
          "vulnerability_from_line": 157,
          "vulnerability_to_line": null,
          "vulnerability_code": "    while(start >= 0){\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UINT_CANT_BE_NEGATIVE",
          "vulnerability_from_line": 157,
          "vulnerability_to_line": null,
          "vulnerability_code": "    while(start >= 0){\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 609,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bytes32 _id = keccak256(\"serveTx\",_to,_value,_txData);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 429,
          "vulnerability_to_line": null,
          "vulnerability_code": "                address[] _owners,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 506,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function getAmount(bytes _txData) public pure returns (bool,uint256) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 578,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function createContract(bytes _txData, uint256 _value) public {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 604,
          "vulnerability_to_line": null,
          "vulnerability_code": "                   bytes _txData,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 606,
          "vulnerability_to_line": null,
          "vulnerability_code": "                   bytes _data)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 38,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 51,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 68,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 91,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly{\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 273,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly{\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 291,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly{\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 313,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly{\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 330,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly{\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 516,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly { getSig := mload(add(_txData,0x20)) }\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 520,
          "vulnerability_to_line": null,
          "vulnerability_code": "      assembly { _amountData := mload(add(_txData,0x44)) }\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 524,
          "vulnerability_to_line": null,
          "vulnerability_code": "      assembly { _amountData := mload(add(_txData,0x64)) }\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 582,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly {\n",
          "message": null
        }
      ]
    },
    "oyente": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "Integer Overflow",
          "vulnerability_from_line": 119,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for { let low := 0 } lt(low, sload(self_slot)) { low := add(low, 1) } {\n",
          "message": null
        },
        {
          "name": "Integer Underflow",
          "vulnerability_from_line": 150,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint256 end = self.length - 1;\n",
          "message": null
        },
        {
          "name": "Integer Overflow",
          "vulnerability_from_line": 314,
          "vulnerability_to_line": null,
          "vulnerability_code": "      res := add(a,b)\n",
          "message": null
        },
        {
          "name": "Integer Underflow",
          "vulnerability_from_line": 315,
          "vulnerability_to_line": null,
          "vulnerability_code": "      switch and(eq(sub(res,b), a), or(gt(res,b),eq(res,b)))\n",
          "message": null
        },
        {
          "name": "Integer Overflow",
          "vulnerability_from_line": 548,
          "vulnerability_to_line": null,
          "vulnerability_code": "    if((now / 1 days) > self.currentSpend[0][0]){\n",
          "message": null
        },
        {
          "name": "Integer Underflow",
          "vulnerability_from_line": 499,
          "vulnerability_to_line": null,
          "vulnerability_code": "    return _required - _count;\n",
          "message": null
        }
      ]
    },
    "mythril": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "Integer Arithmetic Bugs (SWC 101)",
          "vulnerability_from_line": 314,
          "vulnerability_to_line": null,
          "vulnerability_code": "      res := add(a,b)\n",
          "message": "The arithmetic operator can overflow.\nIt is possible to cause an integer overflow or underflow in the arithmetic operation. \nClassification: SWC-101"
        },
        {
          "name": "Integer Arithmetic Bugs (SWC 101)",
          "vulnerability_from_line": 315,
          "vulnerability_to_line": null,
          "vulnerability_code": "      switch and(eq(sub(res,b), a), or(gt(res,b),eq(res,b)))\n",
          "message": "The arithmetic operator can underflow.\nIt is possible to cause an integer overflow or underflow in the arithmetic operation. \nClassification: SWC-101"
        },
        {
          "name": "Integer Arithmetic Bugs (SWC 101)",
          "vulnerability_from_line": 331,
          "vulnerability_to_line": null,
          "vulnerability_code": "      res := sub(a,b)\n",
          "message": "The arithmetic operator can underflow.\nIt is possible to cause an integer overflow or underflow in the arithmetic operation. \nClassification: SWC-101"
        },
        {
          "name": "Integer Arithmetic Bugs (SWC 101)",
          "vulnerability_from_line": 506,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function getAmount(bytes _txData) public pure returns (bool,uint256) {\n",
          "message": "The arithmetic operator can overflow.\nIt is possible to cause an integer overflow or underflow in the arithmetic operation. \nClassification: SWC-101"
        },
        {
          "name": "Integer Arithmetic Bugs (SWC 101)",
          "vulnerability_from_line": 332,
          "vulnerability_to_line": null,
          "vulnerability_code": "      switch eq(and(eq(add(res,b), a), or(lt(res,a), eq(res,a))), 1)\n",
          "message": "The arithmetic operator can overflow.\nIt is possible to cause an integer overflow or underflow in the arithmetic operation. \nClassification: SWC-101"
        },
        {
          "name": "Integer Arithmetic Bugs (SWC 101)",
          "vulnerability_from_line": 506,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function getAmount(bytes _txData) public pure returns (bool,uint256) {\n",
          "message": "The arithmetic operator can overflow.\nIt is possible to cause an integer overflow or underflow in the arithmetic operation. \nClassification: SWC-101"
        },
        {
          "name": "Integer Arithmetic Bugs (SWC 101)",
          "vulnerability_from_line": 499,
          "vulnerability_to_line": null,
          "vulnerability_code": "    return _required - _count;\n",
          "message": "The arithmetic operator can underflow.\nIt is possible to cause an integer overflow or underflow in the arithmetic operation. \nClassification: SWC-101"
        }
      ]
    },
    "osiris": {
      "successfull_analysis": true,
      "errors": [
        "DOCKER_TIMEOUT"
      ],
      "vulnerability_findings": [
        {
          "name": "Division bugs",
          "vulnerability_from_line": 275,
          "vulnerability_to_line": null,
          "vulnerability_code": "      switch or(iszero(b), eq(div(res,b), a))\n",
          "message": null
        },
        {
          "name": "Overflow bugs",
          "vulnerability_from_line": 274,
          "vulnerability_to_line": null,
          "vulnerability_code": "      res := mul(a,b)\n",
          "message": null
        }
      ]
    }
  }
}