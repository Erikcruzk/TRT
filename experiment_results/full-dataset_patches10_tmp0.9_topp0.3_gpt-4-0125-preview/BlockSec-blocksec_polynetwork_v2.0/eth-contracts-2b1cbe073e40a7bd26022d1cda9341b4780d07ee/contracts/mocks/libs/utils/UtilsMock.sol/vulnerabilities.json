{
  "smartbugs_completed": true,
  "analyzer_results": {
    "semgrep": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 260,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(uint i = 0; i < _signers.length; i++){\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 261,
          "vulnerability_to_line": null,
          "vulnerability_code": "            for (uint j = 0; j < _keepers.length; j++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 320,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor() public {\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 321,
          "vulnerability_to_line": null,
          "vulnerability_code": "        storageBytes = bytes(\"I am global in global storage\");\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 322,
          "vulnerability_to_line": null,
          "vulnerability_code": "    }\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 260,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(uint i = 0; i < _signers.length; i++){\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 261,
          "vulnerability_to_line": null,
          "vulnerability_code": "            for (uint j = 0; j < _keepers.length; j++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 13,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_bs.length == 32, \"bytes length is not 32.\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 25,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_bs.length == 32, \"bytes length is not 32.\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 30,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(value <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds the range\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 38,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_value <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds the range\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 58,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_bs.length == 20, \"bytes length does not match address\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 276,
          "vulnerability_to_line": null,
          "vulnerability_code": "         require(key.length >= 67, \"key lenggh is too short\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 260,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(uint i = 0; i < _signers.length; i++){\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 261,
          "vulnerability_to_line": null,
          "vulnerability_code": "            for (uint j = 0; j < _keepers.length; j++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 263,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    m++;\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 58,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_bs.length == 20, \"bytes length does not match address\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        }
      ]
    },
    "slither": {
      "successfull_analysis": true,
      "errors": [
        "EXIT_CODE_49"
      ],
      "vulnerability_findings": [
        {
          "name": "constant-function",
          "vulnerability_from_line": 12,
          "vulnerability_to_line": 18,
          "vulnerability_code": "    function bytesToBytes32(bytes memory _bs) internal pure returns (bytes32 value) {\n\n        require(_bs.length == 32, \"bytes length is not 32.\");\n\n        assembly {\n\n            // load 32 bytes from memory starting from position _bs + 0x20 since the first 0x20 bytes stores _bs length\n\n            value := mload(add(_bs, 0x20))\n\n        }\n",
          "message": "Utils.bytesToBytes32 (UtilsMock.sol#12-18) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 24,
          "vulnerability_to_line": 31,
          "vulnerability_code": "    function bytesToUint256(bytes memory _bs) internal pure returns (uint256 value) {\n\n        require(_bs.length == 32, \"bytes length is not 32.\");\n\n        assembly {\n\n            // load 32 bytes from memory starting from position _bs + 32\n\n            value := mload(add(_bs, 0x20))\n\n        }\n\n        require(value <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds the range\");\n",
          "message": "Utils.bytesToUint256 (UtilsMock.sol#24-31) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 37,
          "vulnerability_to_line": 50,
          "vulnerability_code": "    function uint256ToBytes(uint256 _value) internal pure returns (bytes memory bs) {\n\n        require(_value <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds the range\");\n\n        assembly {\n\n            // Get a location of some free memory and store it in result as\n\n            // Solidity does for memory variables.\n\n            bs := mload(0x40)\n\n            // Put 0x20 at the first word, the length of bytes for uint256 value\n\n            mstore(bs, 0x20)\n\n            //In the next word, put value in bytes format to the next 32 bytes\n\n            mstore(add(bs, 0x20), _value)\n\n            // Update the free-memory pointer by padding our last write location to 32 bytes\n\n            mstore(0x40, add(bs, 0x40))\n\n        }\n",
          "message": "Utils.uint256ToBytes (UtilsMock.sol#37-50) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 56,
          "vulnerability_to_line": 65,
          "vulnerability_code": "    function bytesToAddress(bytes memory _bs) internal pure returns (address addr)\n\n    {\n\n        require(_bs.length == 20, \"bytes length does not match address\");\n\n        assembly {\n\n            // for _bs, first word store _bs.length, second word store _bs.value\n\n            // load 32 bytes from mem[_bs+20], convert it into Uint160, meaning we take last 20 bytes as addr (address).\n\n            addr := mload(add(_bs, 0x14))\n\n        }\n\n\n",
          "message": "Utils.bytesToAddress (UtilsMock.sol#56-65) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 71,
          "vulnerability_to_line": 83,
          "vulnerability_code": "    function addressToBytes(address _addr) internal pure returns (bytes memory bs){\n\n        assembly {\n\n            // Get a location of some free memory and store it in result as\n\n            // Solidity does for memory variables.\n\n            bs := mload(0x40)\n\n            // Put 20 (address byte length) at the first word, the length of bytes for uint256 value\n\n            mstore(bs, 0x14)\n\n            // logical shift left _a by 12 bytes, change _a from right-aligned to left-aligned\n\n            mstore(add(bs, 0x20), shl(96, _addr))\n\n            // Update the free-memory pointer by padding our last write location to 32 bytes\n\n            mstore(0x40, add(bs, 0x40))\n\n       }\n",
          "message": "Utils.addressToBytes (UtilsMock.sol#71-83) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 108,
          "vulnerability_to_line": 178,
          "vulnerability_code": "    function equalStorage(bytes storage _preBytes, bytes memory _postBytes) internal view returns (bool) {\n\n        bool success = true;\n\n\n\n        assembly {\n\n            // we know _preBytes_offset is 0\n\n            let fslot := sload(_preBytes_slot)\n\n            // Arrays of 31 bytes or less have an even value in their slot,\n\n            // while longer arrays have an odd value. The actual length is\n\n            // the slot divided by two for odd values, and the lowest order\n\n            // byte divided by two for even values.\n\n            // If the slot is even, bitwise and the slot with 255 and divide by\n\n            // two to get the length. If the slot is odd, bitwise and the slot\n\n            // with -1 and divide by two.\n\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n\n            let mlength := mload(_postBytes)\n\n\n\n            // if lengths don't match the arrays are not equal\n\n            switch eq(slength, mlength)\n\n            case 1 {\n\n                // fslot can contain both the length and contents of the array\n\n                // if slength < 32 bytes so let's prepare for that\n\n                // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n\n                // slength != 0\n\n                if iszero(iszero(slength)) {\n\n                    switch lt(slength, 32)\n\n                    case 1 {\n\n                        // blank the last byte which is the length\n\n                        fslot := mul(div(fslot, 0x100), 0x100)\n\n\n\n                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\n\n                            // unsuccess:\n\n                            success := 0\n\n                        }\n\n                    }\n\n                    default {\n\n                        // cb is a circuit breaker in the for loop since there's\n\n                        //  no said feature for inline assembly loops\n\n                        // cb = 1 - don't breaker\n\n                        // cb = 0 - break\n\n                        let cb := 1\n\n\n\n                        // get the keccak hash to get the contents of the array\n\n                        mstore(0x0, _preBytes_slot)\n\n                        let sc := keccak256(0x0, 0x20)\n\n\n\n                        let mc := add(_postBytes, 0x20)\n\n                        let end := add(mc, mlength)\n\n\n\n                        // the next line is the loop condition:\n\n                        // while(uint(mc < end) + cb == 2)\n\n                        for {} eq(add(lt(mc, end), cb), 2) {\n\n                            sc := add(sc, 1)\n\n                            mc := add(mc, 0x20)\n\n                        } {\n\n                            if iszero(eq(sload(sc), mload(mc))) {\n\n                                // unsuccess:\n\n                                success := 0\n\n                                cb := 0\n\n                            }\n\n                        }\n\n                    }\n\n                }\n\n            }\n\n            default {\n\n                // unsuccess:\n\n                success := 0\n\n            }\n\n        }\n\n\n\n        return success;\n",
          "message": "Utils.equalStorage (UtilsMock.sol#108-178) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 187,
          "vulnerability_to_line": 251,
          "vulnerability_code": "    function slice(\n\n        bytes memory _bytes,\n\n        uint _start,\n\n        uint _length\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        require(_bytes.length >= (_start + _length));\n\n\n\n        bytes memory tempBytes;\n\n\n\n        assembly {\n\n            switch iszero(_length)\n\n            case 0 {\n\n                // Get a location of some free memory and store it in tempBytes as\n\n                // Solidity does for memory variables.\n\n                tempBytes := mload(0x40)\n\n\n\n                // The first word of the slice result is potentially a partial\n\n                // word read from the original array. To read it, we calculate\n\n                // the length of that partial word and start copying that many\n\n                // bytes into the array. The first word we copy will start with\n\n                // data we don't care about, but the last `lengthmod` bytes will\n\n                // land at the beginning of the contents of the new array. When\n\n                // we're done copying, we overwrite the full first word with\n\n                // the actual length of the slice.\n\n                // lengthmod <= _length % 32\n\n                let lengthmod := and(_length, 31)\n\n\n\n                // The multiplication in the next line is necessary\n\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n\n                // the following copy loop was copying the origin's length\n\n                // and then ending prematurely not copying everything it should.\n\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n\n                let end := add(mc, _length)\n\n\n\n                for {\n\n                    // The multiplication in the next line has the same exact purpose\n\n                    // as the one above.\n\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n\n                } lt(mc, end) {\n\n                    mc := add(mc, 0x20)\n\n                    cc := add(cc, 0x20)\n\n                } {\n\n                    mstore(mc, mload(cc))\n\n                }\n\n\n\n                mstore(tempBytes, _length)\n\n\n\n                //update free-memory pointer\n\n                //allocating the array padded to 32 bytes like the compiler does now\n\n                mstore(0x40, and(add(mc, 31), not(31)))\n\n            }\n\n            //if we want a zero-length slice let's just return a zero-length array\n\n            default {\n\n                tempBytes := mload(0x40)\n\n\n\n                mstore(0x40, add(tempBytes, 0x20))\n\n            }\n\n        }\n\n\n\n        return tempBytes;\n",
          "message": "Utils.slice (UtilsMock.sol#187-251) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 298,
          "vulnerability_to_line": 311,
          "vulnerability_code": "    function isContract(address account) internal view returns (bool) {\n\n        // This method relies in extcodesize, which returns 0 for contracts in\n\n        // construction, since the code is only stored at the end of the\n\n        // constructor execution.\n\n\n\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n\n        // for accounts without code, i.e. `keccak256('')`\n\n        bytes32 codehash;\n\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly { codehash := extcodehash(account) }\n\n        return (codehash != 0x0 && codehash != accountHash);\n",
          "message": "Utils.isContract (UtilsMock.sol#298-311) is declared view but contains assembly code\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 12,
          "vulnerability_to_line": 18,
          "vulnerability_code": "    function bytesToBytes32(bytes memory _bs) internal pure returns (bytes32 value) {\n\n        require(_bs.length == 32, \"bytes length is not 32.\");\n\n        assembly {\n\n            // load 32 bytes from memory starting from position _bs + 0x20 since the first 0x20 bytes stores _bs length\n\n            value := mload(add(_bs, 0x20))\n\n        }\n",
          "message": "Utils.bytesToBytes32 uses assembly (UtilsMock.sol#12-18)\n\t- UtilsMock.sol#14-17\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 24,
          "vulnerability_to_line": 31,
          "vulnerability_code": "    function bytesToUint256(bytes memory _bs) internal pure returns (uint256 value) {\n\n        require(_bs.length == 32, \"bytes length is not 32.\");\n\n        assembly {\n\n            // load 32 bytes from memory starting from position _bs + 32\n\n            value := mload(add(_bs, 0x20))\n\n        }\n\n        require(value <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds the range\");\n",
          "message": "Utils.bytesToUint256 uses assembly (UtilsMock.sol#24-31)\n\t- UtilsMock.sol#26-29\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 37,
          "vulnerability_to_line": 50,
          "vulnerability_code": "    function uint256ToBytes(uint256 _value) internal pure returns (bytes memory bs) {\n\n        require(_value <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds the range\");\n\n        assembly {\n\n            // Get a location of some free memory and store it in result as\n\n            // Solidity does for memory variables.\n\n            bs := mload(0x40)\n\n            // Put 0x20 at the first word, the length of bytes for uint256 value\n\n            mstore(bs, 0x20)\n\n            //In the next word, put value in bytes format to the next 32 bytes\n\n            mstore(add(bs, 0x20), _value)\n\n            // Update the free-memory pointer by padding our last write location to 32 bytes\n\n            mstore(0x40, add(bs, 0x40))\n\n        }\n",
          "message": "Utils.uint256ToBytes uses assembly (UtilsMock.sol#37-50)\n\t- UtilsMock.sol#39-49\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 56,
          "vulnerability_to_line": 65,
          "vulnerability_code": "    function bytesToAddress(bytes memory _bs) internal pure returns (address addr)\n\n    {\n\n        require(_bs.length == 20, \"bytes length does not match address\");\n\n        assembly {\n\n            // for _bs, first word store _bs.length, second word store _bs.value\n\n            // load 32 bytes from mem[_bs+20], convert it into Uint160, meaning we take last 20 bytes as addr (address).\n\n            addr := mload(add(_bs, 0x14))\n\n        }\n\n\n",
          "message": "Utils.bytesToAddress uses assembly (UtilsMock.sol#56-65)\n\t- UtilsMock.sol#59-63\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 71,
          "vulnerability_to_line": 83,
          "vulnerability_code": "    function addressToBytes(address _addr) internal pure returns (bytes memory bs){\n\n        assembly {\n\n            // Get a location of some free memory and store it in result as\n\n            // Solidity does for memory variables.\n\n            bs := mload(0x40)\n\n            // Put 20 (address byte length) at the first word, the length of bytes for uint256 value\n\n            mstore(bs, 0x14)\n\n            // logical shift left _a by 12 bytes, change _a from right-aligned to left-aligned\n\n            mstore(add(bs, 0x20), shl(96, _addr))\n\n            // Update the free-memory pointer by padding our last write location to 32 bytes\n\n            mstore(0x40, add(bs, 0x40))\n\n       }\n",
          "message": "Utils.addressToBytes uses assembly (UtilsMock.sol#71-83)\n\t- UtilsMock.sol#72-82\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 108,
          "vulnerability_to_line": 178,
          "vulnerability_code": "    function equalStorage(bytes storage _preBytes, bytes memory _postBytes) internal view returns (bool) {\n\n        bool success = true;\n\n\n\n        assembly {\n\n            // we know _preBytes_offset is 0\n\n            let fslot := sload(_preBytes_slot)\n\n            // Arrays of 31 bytes or less have an even value in their slot,\n\n            // while longer arrays have an odd value. The actual length is\n\n            // the slot divided by two for odd values, and the lowest order\n\n            // byte divided by two for even values.\n\n            // If the slot is even, bitwise and the slot with 255 and divide by\n\n            // two to get the length. If the slot is odd, bitwise and the slot\n\n            // with -1 and divide by two.\n\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n\n            let mlength := mload(_postBytes)\n\n\n\n            // if lengths don't match the arrays are not equal\n\n            switch eq(slength, mlength)\n\n            case 1 {\n\n                // fslot can contain both the length and contents of the array\n\n                // if slength < 32 bytes so let's prepare for that\n\n                // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n\n                // slength != 0\n\n                if iszero(iszero(slength)) {\n\n                    switch lt(slength, 32)\n\n                    case 1 {\n\n                        // blank the last byte which is the length\n\n                        fslot := mul(div(fslot, 0x100), 0x100)\n\n\n\n                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\n\n                            // unsuccess:\n\n                            success := 0\n\n                        }\n\n                    }\n\n                    default {\n\n                        // cb is a circuit breaker in the for loop since there's\n\n                        //  no said feature for inline assembly loops\n\n                        // cb = 1 - don't breaker\n\n                        // cb = 0 - break\n\n                        let cb := 1\n\n\n\n                        // get the keccak hash to get the contents of the array\n\n                        mstore(0x0, _preBytes_slot)\n\n                        let sc := keccak256(0x0, 0x20)\n\n\n\n                        let mc := add(_postBytes, 0x20)\n\n                        let end := add(mc, mlength)\n\n\n\n                        // the next line is the loop condition:\n\n                        // while(uint(mc < end) + cb == 2)\n\n                        for {} eq(add(lt(mc, end), cb), 2) {\n\n                            sc := add(sc, 1)\n\n                            mc := add(mc, 0x20)\n\n                        } {\n\n                            if iszero(eq(sload(sc), mload(mc))) {\n\n                                // unsuccess:\n\n                                success := 0\n\n                                cb := 0\n\n                            }\n\n                        }\n\n                    }\n\n                }\n\n            }\n\n            default {\n\n                // unsuccess:\n\n                success := 0\n\n            }\n\n        }\n\n\n\n        return success;\n",
          "message": "Utils.equalStorage uses assembly (UtilsMock.sol#108-178)\n\t- UtilsMock.sol#111-175\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 187,
          "vulnerability_to_line": 251,
          "vulnerability_code": "    function slice(\n\n        bytes memory _bytes,\n\n        uint _start,\n\n        uint _length\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        require(_bytes.length >= (_start + _length));\n\n\n\n        bytes memory tempBytes;\n\n\n\n        assembly {\n\n            switch iszero(_length)\n\n            case 0 {\n\n                // Get a location of some free memory and store it in tempBytes as\n\n                // Solidity does for memory variables.\n\n                tempBytes := mload(0x40)\n\n\n\n                // The first word of the slice result is potentially a partial\n\n                // word read from the original array. To read it, we calculate\n\n                // the length of that partial word and start copying that many\n\n                // bytes into the array. The first word we copy will start with\n\n                // data we don't care about, but the last `lengthmod` bytes will\n\n                // land at the beginning of the contents of the new array. When\n\n                // we're done copying, we overwrite the full first word with\n\n                // the actual length of the slice.\n\n                // lengthmod <= _length % 32\n\n                let lengthmod := and(_length, 31)\n\n\n\n                // The multiplication in the next line is necessary\n\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n\n                // the following copy loop was copying the origin's length\n\n                // and then ending prematurely not copying everything it should.\n\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n\n                let end := add(mc, _length)\n\n\n\n                for {\n\n                    // The multiplication in the next line has the same exact purpose\n\n                    // as the one above.\n\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n\n                } lt(mc, end) {\n\n                    mc := add(mc, 0x20)\n\n                    cc := add(cc, 0x20)\n\n                } {\n\n                    mstore(mc, mload(cc))\n\n                }\n\n\n\n                mstore(tempBytes, _length)\n\n\n\n                //update free-memory pointer\n\n                //allocating the array padded to 32 bytes like the compiler does now\n\n                mstore(0x40, and(add(mc, 31), not(31)))\n\n            }\n\n            //if we want a zero-length slice let's just return a zero-length array\n\n            default {\n\n                tempBytes := mload(0x40)\n\n\n\n                mstore(0x40, add(tempBytes, 0x20))\n\n            }\n\n        }\n\n\n\n        return tempBytes;\n",
          "message": "Utils.slice uses assembly (UtilsMock.sol#187-251)\n\t- UtilsMock.sol#200-248\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 298,
          "vulnerability_to_line": 311,
          "vulnerability_code": "    function isContract(address account) internal view returns (bool) {\n\n        // This method relies in extcodesize, which returns 0 for contracts in\n\n        // construction, since the code is only stored at the end of the\n\n        // constructor execution.\n\n\n\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n\n        // for accounts without code, i.e. `keccak256('')`\n\n        bytes32 codehash;\n\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly { codehash := extcodehash(account) }\n\n        return (codehash != 0x0 && codehash != accountHash);\n",
          "message": "Utils.isContract uses assembly (UtilsMock.sol#298-311)\n\t- UtilsMock.sol#309\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 323,
          "vulnerability_to_line": 325,
          "vulnerability_code": "    function bytesToBytes32(bytes memory _b) public pure returns (bytes32) {\n\n        return Utils.bytesToBytes32(_b);\n",
          "message": "UtilsMock.bytesToBytes32 (UtilsMock.sol#323-325) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 327,
          "vulnerability_to_line": 329,
          "vulnerability_code": "    function bytesToUint256(bytes memory  _v) public pure returns (uint256) {\n\n        return Utils.bytesToUint256(_v);\n",
          "message": "UtilsMock.bytesToUint256 (UtilsMock.sol#327-329) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 331,
          "vulnerability_to_line": 333,
          "vulnerability_code": "    function uint256ToBytes(uint256 _v) public pure returns (bytes memory) {\n\n        return Utils.uint256ToBytes(_v);\n",
          "message": "UtilsMock.uint256ToBytes (UtilsMock.sol#331-333) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 335,
          "vulnerability_to_line": 337,
          "vulnerability_code": "    function bytesToAddress(bytes memory _v) public pure returns (address) {\n\n        return Utils.bytesToAddress(_v);\n",
          "message": "UtilsMock.bytesToAddress (UtilsMock.sol#335-337) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 339,
          "vulnerability_to_line": 341,
          "vulnerability_code": "    function addressToBytes(address _v) public pure returns (bytes memory) {\n\n        return Utils.addressToBytes(_v);\n",
          "message": "UtilsMock.addressToBytes (UtilsMock.sol#339-341) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 342,
          "vulnerability_to_line": 344,
          "vulnerability_code": "    function hashLeaf(bytes memory _data) public pure returns (bytes32) {\n\n        return Utils.hashLeaf(_data);\n",
          "message": "UtilsMock.hashLeaf (UtilsMock.sol#342-344) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 345,
          "vulnerability_to_line": 347,
          "vulnerability_code": "    function hashChildren(bytes32 left, bytes32 right) public pure returns (bytes32) {\n\n        return Utils.hashChildren(left, right);\n",
          "message": "UtilsMock.hashChildren (UtilsMock.sol#345-347) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 348,
          "vulnerability_to_line": 350,
          "vulnerability_code": "    function equalStorage( bytes memory memoryBytes) public view returns (bool) {\n\n        return Utils.equalStorage(storageBytes, memoryBytes);\n",
          "message": "UtilsMock.equalStorage (UtilsMock.sol#348-350) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 351,
          "vulnerability_to_line": 353,
          "vulnerability_code": "    function slice(bytes memory _bytes, uint _start, uint _length )public pure returns (bytes memory){\n\n        return Utils.slice(_bytes, _start, _length);\n",
          "message": "UtilsMock.slice (UtilsMock.sol#351-353) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 355,
          "vulnerability_to_line": 357,
          "vulnerability_code": "    function containMAddresses(address[] memory keepers, address[] memory signers, uint m) public pure returns(bool){\n\n        return Utils.containMAddresses(keepers, signers, m);\n",
          "message": "UtilsMock.containMAddresses (UtilsMock.sol#355-357) should be declared external\n"
        },
        {
          "name": "solc-version",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.0;\n",
          "message": "Detected issues with version pragma in UtilsMock.sol:\n\t- pragma solidity^0.5.0 (UtilsMock.sol#3): it allows old versions\n\t- pragma solidity^0.5.0 (UtilsMock.sol#316): it allows old versions\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 12,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function bytesToBytes32(bytes memory _bs) internal pure returns (bytes32 value) {\n",
          "message": "Parameter '_bs' of Utils.bytesToBytes32 (UtilsMock.sol#12) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 24,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function bytesToUint256(bytes memory _bs) internal pure returns (uint256 value) {\n",
          "message": "Parameter '_bs' of Utils.bytesToUint256 (UtilsMock.sol#24) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 37,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function uint256ToBytes(uint256 _value) internal pure returns (bytes memory bs) {\n",
          "message": "Parameter '_value' of Utils.uint256ToBytes (UtilsMock.sol#37) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 56,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function bytesToAddress(bytes memory _bs) internal pure returns (address addr)\n",
          "message": "Parameter '_bs' of Utils.bytesToAddress (UtilsMock.sol#56) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 89,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function hashLeaf(bytes memory _data) internal pure returns (bytes32 result)  {\n",
          "message": "Parameter '_data' of Utils.hashLeaf (UtilsMock.sol#89) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 98,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function hashChildren(bytes32 _l, bytes32  _r) internal pure returns (bytes32 result)  {\n",
          "message": "Parameter '_l' of Utils.hashChildren (UtilsMock.sol#98) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 98,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function hashChildren(bytes32 _l, bytes32  _r) internal pure returns (bytes32 result)  {\n",
          "message": "Parameter '_r' of Utils.hashChildren (UtilsMock.sol#98) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 188,
          "vulnerability_to_line": null,
          "vulnerability_code": "        bytes memory _bytes,\n",
          "message": "Parameter '_bytes' of Utils.slice (UtilsMock.sol#188) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 189,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint _start,\n",
          "message": "Parameter '_start' of Utils.slice (UtilsMock.sol#189) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 190,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint _length\n",
          "message": "Parameter '_length' of Utils.slice (UtilsMock.sol#190) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 258,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function containMAddresses(address[] memory _keepers, address[] memory _signers, uint _m) internal pure returns (bool){\n",
          "message": "Parameter '_keepers' of Utils.containMAddresses (UtilsMock.sol#258) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 258,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function containMAddresses(address[] memory _keepers, address[] memory _signers, uint _m) internal pure returns (bool){\n",
          "message": "Parameter '_signers' of Utils.containMAddresses (UtilsMock.sol#258) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 258,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function containMAddresses(address[] memory _keepers, address[] memory _signers, uint _m) internal pure returns (bool){\n",
          "message": "Parameter '_m' of Utils.containMAddresses (UtilsMock.sol#258) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 323,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function bytesToBytes32(bytes memory _b) public pure returns (bytes32) {\n",
          "message": "Parameter '_b' of UtilsMock.bytesToBytes32 (UtilsMock.sol#323) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 327,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function bytesToUint256(bytes memory  _v) public pure returns (uint256) {\n",
          "message": "Parameter '_v' of UtilsMock.bytesToUint256 (UtilsMock.sol#327) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 331,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function uint256ToBytes(uint256 _v) public pure returns (bytes memory) {\n",
          "message": "Parameter '_v' of UtilsMock.uint256ToBytes (UtilsMock.sol#331) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 335,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function bytesToAddress(bytes memory _v) public pure returns (address) {\n",
          "message": "Parameter '_v' of UtilsMock.bytesToAddress (UtilsMock.sol#335) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 339,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function addressToBytes(address _v) public pure returns (bytes memory) {\n",
          "message": "Parameter '_v' of UtilsMock.addressToBytes (UtilsMock.sol#339) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 342,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function hashLeaf(bytes memory _data) public pure returns (bytes32) {\n",
          "message": "Parameter '_data' of UtilsMock.hashLeaf (UtilsMock.sol#342) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 351,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function slice(bytes memory _bytes, uint _start, uint _length )public pure returns (bytes memory){\n",
          "message": "Parameter '_bytes' of UtilsMock.slice (UtilsMock.sol#351) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 351,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function slice(bytes memory _bytes, uint _start, uint _length )public pure returns (bytes memory){\n",
          "message": "Parameter '_start' of UtilsMock.slice (UtilsMock.sol#351) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 351,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function slice(bytes memory _bytes, uint _start, uint _length )public pure returns (bytes memory){\n",
          "message": "Parameter '_length' of UtilsMock.slice (UtilsMock.sol#351) is not in mixedCase\n"
        }
      ]
    },
    "smartcheck": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 99,
          "vulnerability_to_line": null,
          "vulnerability_code": "        result = sha256(abi.encodePacked(bytes1(0x01), _l, _r));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 279,
          "vulnerability_to_line": null,
          "vulnerability_code": "             newkey[2] = byte(0x02);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 281,
          "vulnerability_to_line": null,
          "vulnerability_code": "             newkey[2] = byte(0x03);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 90,
          "vulnerability_to_line": null,
          "vulnerability_code": "        result = sha256(abi.encodePacked(byte(0x0), _data));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 260,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(uint i = 0; i < _signers.length; i++){\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 261,
          "vulnerability_to_line": null,
          "vulnerability_code": "            for (uint j = 0; j < _keepers.length; j++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
          "vulnerability_from_line": 12,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function bytesToBytes32(bytes memory _bs) internal pure returns (bytes32 value) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
          "vulnerability_from_line": 37,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function uint256ToBytes(uint256 _value) internal pure returns (bytes memory bs) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
          "vulnerability_from_line": 56,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function bytesToAddress(bytes memory _bs) internal pure returns (address addr)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
          "vulnerability_from_line": 71,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function addressToBytes(address _addr) internal pure returns (bytes memory bs){\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 260,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(uint i = 0; i < _signers.length; i++){\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 261,
          "vulnerability_to_line": null,
          "vulnerability_code": "            for (uint j = 0; j < _keepers.length; j++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 316,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 12,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function bytesToBytes32(bytes memory _bs) internal pure returns (bytes32 value) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 24,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function bytesToUint256(bytes memory _bs) internal pure returns (uint256 value) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 37,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function uint256ToBytes(uint256 _value) internal pure returns (bytes memory bs) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 56,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function bytesToAddress(bytes memory _bs) internal pure returns (address addr)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 71,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function addressToBytes(address _addr) internal pure returns (bytes memory bs){\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 187,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function slice(\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
          "vulnerability_from_line": 108,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function equalStorage(bytes storage _preBytes, bytes memory _postBytes) internal view returns (bool) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
          "vulnerability_from_line": 298,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function isContract(address account) internal view returns (bool) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 14,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 26,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 39,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 59,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 72,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 111,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 200,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 309,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly { codehash := extcodehash(account) }\n",
          "message": null
        }
      ]
    },
    "oyente": {
      "successfull_analysis": false,
      "errors": [
        "exception (IndexError: pop from empty list)"
      ],
      "vulnerability_findings": []
    },
    "mythril": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "Integer Arithmetic Bugs (SWC 101)",
          "vulnerability_from_line": 196,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_bytes.length >= (_start + _length));\n",
          "message": "The arithmetic operator can overflow.\nIt is possible to cause an integer overflow or underflow in the arithmetic operation. \nClassification: SWC-101"
        }
      ]
    },
    "osiris": {
      "successfull_analysis": false,
      "errors": [
        "Solidity compilation failed"
      ],
      "vulnerability_findings": []
    }
  }
}