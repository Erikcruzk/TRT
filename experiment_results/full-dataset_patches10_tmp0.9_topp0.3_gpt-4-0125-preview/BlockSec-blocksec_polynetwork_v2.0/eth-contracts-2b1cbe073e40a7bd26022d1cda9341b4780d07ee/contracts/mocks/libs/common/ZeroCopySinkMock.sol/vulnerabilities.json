{
  "smartbugs_completed": true,
  "analyzer_results": {
    "semgrep": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 197,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i <= N; i++) {\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 205,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i <= N; i++) {\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 213,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i <= N; i++) {\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 221,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i <= N; i++) {\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 229,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i <= N; i++) {\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 237,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i <= N; i++) {\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 244,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i <= N; i++) {\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 252,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i <= N; i++) {\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 260,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i <= N; i++) {\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 197,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i <= N; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 205,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i <= N; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 213,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i <= N; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 221,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i <= N; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 229,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i <= N; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 237,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i <= N; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 244,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i <= N; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 252,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i <= N; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 260,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i <= N; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 146,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(v <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds uint255 range\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 197,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i <= N; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 205,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i <= N; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 213,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i <= N; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 221,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i <= N; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 229,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i <= N; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 237,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i <= N; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 244,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i <= N; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 252,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i <= N; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 260,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i <= N; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        }
      ]
    },
    "slither": {
      "successfull_analysis": true,
      "errors": [
        "EXIT_CODE_51"
      ],
      "vulnerability_findings": [
        {
          "name": "constant-function",
          "vulnerability_from_line": 24,
          "vulnerability_to_line": 41,
          "vulnerability_code": "    function WriteBool(bool b) internal pure returns (bytes memory) {\n\n        bytes memory buff;\n\n        assembly{\n\n            buff := mload(0x40)\n\n            mstore(buff, 1)\n\n            switch iszero(b)\n\n            case 1 {\n\n                mstore(add(buff, 0x20), shl(248, 0x00))\n\n                // mstore8(add(buff, 0x20), 0x00)\n\n            }\n\n            default {\n\n                mstore(add(buff, 0x20), shl(248, 0x01))\n\n                // mstore8(add(buff, 0x20), 0x01)\n\n            }\n\n            mstore(0x40, add(buff, 0x21))\n\n        }\n\n        return buff;\n",
          "message": "ZeroCopySink.WriteBool (ZeroCopySinkMock.sol#24-41) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 55,
          "vulnerability_to_line": 65,
          "vulnerability_code": "    function WriteUint8(uint8 v) internal pure returns (bytes memory) {\n\n        bytes memory buff;\n\n        assembly{\n\n            buff := mload(0x40)\n\n            mstore(buff, 1)\n\n            mstore(add(buff, 0x20), shl(248, v))\n\n            // mstore(add(buff, 0x20), byte(0x1f, v))\n\n            mstore(0x40, add(buff, 0x21))\n\n        }\n\n        return buff;\n",
          "message": "ZeroCopySink.WriteUint8 (ZeroCopySinkMock.sol#55-65) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 71,
          "vulnerability_to_line": 90,
          "vulnerability_code": "    function WriteUint16(uint16 v) internal pure returns (bytes memory) {\n\n        bytes memory buff;\n\n\n\n        assembly{\n\n            buff := mload(0x40)\n\n            let byteLen := 0x02\n\n            mstore(buff, byteLen)\n\n            for {\n\n                let mindex := 0x00\n\n                let vindex := 0x1f\n\n            } lt(mindex, byteLen) {\n\n                mindex := add(mindex, 0x01)\n\n                vindex := sub(vindex, 0x01)\n\n            }{\n\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\n\n            }\n\n            mstore(0x40, add(buff, 0x22))\n\n        }\n\n        return buff;\n",
          "message": "ZeroCopySink.WriteUint16 (ZeroCopySinkMock.sol#71-90) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 96,
          "vulnerability_to_line": 114,
          "vulnerability_code": "    function WriteUint32(uint32 v) internal pure returns(bytes memory) {\n\n        bytes memory buff;\n\n        assembly{\n\n            buff := mload(0x40)\n\n            let byteLen := 0x04\n\n            mstore(buff, byteLen)\n\n            for {\n\n                let mindex := 0x00\n\n                let vindex := 0x1f\n\n            } lt(mindex, byteLen) {\n\n                mindex := add(mindex, 0x01)\n\n                vindex := sub(vindex, 0x01)\n\n            }{\n\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\n\n            }\n\n            mstore(0x40, add(buff, 0x24))\n\n        }\n\n        return buff;\n",
          "message": "ZeroCopySink.WriteUint32 (ZeroCopySinkMock.sol#96-114) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 120,
          "vulnerability_to_line": 139,
          "vulnerability_code": "    function WriteUint64(uint64 v) internal pure returns(bytes memory) {\n\n        bytes memory buff;\n\n\n\n        assembly{\n\n            buff := mload(0x40)\n\n            let byteLen := 0x08\n\n            mstore(buff, byteLen)\n\n            for {\n\n                let mindex := 0x00\n\n                let vindex := 0x1f\n\n            } lt(mindex, byteLen) {\n\n                mindex := add(mindex, 0x01)\n\n                vindex := sub(vindex, 0x01)\n\n            }{\n\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\n\n            }\n\n            mstore(0x40, add(buff, 0x28))\n\n        }\n\n        return buff;\n",
          "message": "ZeroCopySink.WriteUint64 (ZeroCopySinkMock.sol#120-139) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 145,
          "vulnerability_to_line": 165,
          "vulnerability_code": "    function WriteUint255(uint256 v) internal pure returns (bytes memory) {\n\n        require(v <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds uint255 range\");\n\n        bytes memory buff;\n\n\n\n        assembly{\n\n            buff := mload(0x40)\n\n            let byteLen := 0x20\n\n            mstore(buff, byteLen)\n\n            for {\n\n                let mindex := 0x00\n\n                let vindex := 0x1f\n\n            } lt(mindex, byteLen) {\n\n                mindex := add(mindex, 0x01)\n\n                vindex := sub(vindex, 0x01)\n\n            }{\n\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\n\n            }\n\n            mstore(0x40, add(buff, 0x40))\n\n        }\n\n        return buff;\n",
          "message": "ZeroCopySink.WriteUint255 (ZeroCopySinkMock.sol#145-165) is declared view but contains assembly code\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 24,
          "vulnerability_to_line": 41,
          "vulnerability_code": "    function WriteBool(bool b) internal pure returns (bytes memory) {\n\n        bytes memory buff;\n\n        assembly{\n\n            buff := mload(0x40)\n\n            mstore(buff, 1)\n\n            switch iszero(b)\n\n            case 1 {\n\n                mstore(add(buff, 0x20), shl(248, 0x00))\n\n                // mstore8(add(buff, 0x20), 0x00)\n\n            }\n\n            default {\n\n                mstore(add(buff, 0x20), shl(248, 0x01))\n\n                // mstore8(add(buff, 0x20), 0x01)\n\n            }\n\n            mstore(0x40, add(buff, 0x21))\n\n        }\n\n        return buff;\n",
          "message": "ZeroCopySink.WriteBool uses assembly (ZeroCopySinkMock.sol#24-41)\n\t- ZeroCopySinkMock.sol#26-39\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 55,
          "vulnerability_to_line": 65,
          "vulnerability_code": "    function WriteUint8(uint8 v) internal pure returns (bytes memory) {\n\n        bytes memory buff;\n\n        assembly{\n\n            buff := mload(0x40)\n\n            mstore(buff, 1)\n\n            mstore(add(buff, 0x20), shl(248, v))\n\n            // mstore(add(buff, 0x20), byte(0x1f, v))\n\n            mstore(0x40, add(buff, 0x21))\n\n        }\n\n        return buff;\n",
          "message": "ZeroCopySink.WriteUint8 uses assembly (ZeroCopySinkMock.sol#55-65)\n\t- ZeroCopySinkMock.sol#57-63\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 71,
          "vulnerability_to_line": 90,
          "vulnerability_code": "    function WriteUint16(uint16 v) internal pure returns (bytes memory) {\n\n        bytes memory buff;\n\n\n\n        assembly{\n\n            buff := mload(0x40)\n\n            let byteLen := 0x02\n\n            mstore(buff, byteLen)\n\n            for {\n\n                let mindex := 0x00\n\n                let vindex := 0x1f\n\n            } lt(mindex, byteLen) {\n\n                mindex := add(mindex, 0x01)\n\n                vindex := sub(vindex, 0x01)\n\n            }{\n\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\n\n            }\n\n            mstore(0x40, add(buff, 0x22))\n\n        }\n\n        return buff;\n",
          "message": "ZeroCopySink.WriteUint16 uses assembly (ZeroCopySinkMock.sol#71-90)\n\t- ZeroCopySinkMock.sol#74-88\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 96,
          "vulnerability_to_line": 114,
          "vulnerability_code": "    function WriteUint32(uint32 v) internal pure returns(bytes memory) {\n\n        bytes memory buff;\n\n        assembly{\n\n            buff := mload(0x40)\n\n            let byteLen := 0x04\n\n            mstore(buff, byteLen)\n\n            for {\n\n                let mindex := 0x00\n\n                let vindex := 0x1f\n\n            } lt(mindex, byteLen) {\n\n                mindex := add(mindex, 0x01)\n\n                vindex := sub(vindex, 0x01)\n\n            }{\n\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\n\n            }\n\n            mstore(0x40, add(buff, 0x24))\n\n        }\n\n        return buff;\n",
          "message": "ZeroCopySink.WriteUint32 uses assembly (ZeroCopySinkMock.sol#96-114)\n\t- ZeroCopySinkMock.sol#98-112\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 120,
          "vulnerability_to_line": 139,
          "vulnerability_code": "    function WriteUint64(uint64 v) internal pure returns(bytes memory) {\n\n        bytes memory buff;\n\n\n\n        assembly{\n\n            buff := mload(0x40)\n\n            let byteLen := 0x08\n\n            mstore(buff, byteLen)\n\n            for {\n\n                let mindex := 0x00\n\n                let vindex := 0x1f\n\n            } lt(mindex, byteLen) {\n\n                mindex := add(mindex, 0x01)\n\n                vindex := sub(vindex, 0x01)\n\n            }{\n\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\n\n            }\n\n            mstore(0x40, add(buff, 0x28))\n\n        }\n\n        return buff;\n",
          "message": "ZeroCopySink.WriteUint64 uses assembly (ZeroCopySinkMock.sol#120-139)\n\t- ZeroCopySinkMock.sol#123-137\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 145,
          "vulnerability_to_line": 165,
          "vulnerability_code": "    function WriteUint255(uint256 v) internal pure returns (bytes memory) {\n\n        require(v <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds uint255 range\");\n\n        bytes memory buff;\n\n\n\n        assembly{\n\n            buff := mload(0x40)\n\n            let byteLen := 0x20\n\n            mstore(buff, byteLen)\n\n            for {\n\n                let mindex := 0x00\n\n                let vindex := 0x1f\n\n            } lt(mindex, byteLen) {\n\n                mindex := add(mindex, 0x01)\n\n                vindex := sub(vindex, 0x01)\n\n            }{\n\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\n\n            }\n\n            mstore(0x40, add(buff, 0x40))\n\n        }\n\n        return buff;\n",
          "message": "ZeroCopySink.WriteUint255 uses assembly (ZeroCopySinkMock.sol#145-165)\n\t- ZeroCopySinkMock.sol#149-163\n"
        },
        {
          "name": "constable-states",
          "vulnerability_from_line": 194,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint N = 10;\n",
          "message": "ZeroCopySinkMock.N should be constant (ZeroCopySinkMock.sol#194)\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 195,
          "vulnerability_to_line": 201,
          "vulnerability_code": "    function WriteBool(bool _b) public returns (bytes memory) {\n\n        bytes memory executeResult;\n\n        for (uint i = 0; i <= N; i++) {\n\n            executeResult = ZeroCopySink.WriteBool(_b);\n\n        }\n\n        return ZeroCopySink.WriteBool(_b);\n",
          "message": "ZeroCopySinkMock.WriteBool (ZeroCopySinkMock.sol#195-201) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 203,
          "vulnerability_to_line": 209,
          "vulnerability_code": "    function WriteByte(byte _b) public returns (bytes memory) {\n\n        bytes memory executeResult;\n\n        for (uint i = 0; i <= N; i++) {\n\n            executeResult = ZeroCopySink.WriteByte(_b);\n\n        }\n\n        return ZeroCopySink.WriteByte(_b);\n",
          "message": "ZeroCopySinkMock.WriteByte (ZeroCopySinkMock.sol#203-209) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 211,
          "vulnerability_to_line": 217,
          "vulnerability_code": "    function WriteUint8(uint8 _v) public returns (bytes memory) {\n\n        bytes memory executeResult;\n\n        for (uint i = 0; i <= N; i++) {\n\n            executeResult = ZeroCopySink.WriteUint8(_v);\n\n        }\n\n        return ZeroCopySink.WriteUint8(_v);\n",
          "message": "ZeroCopySinkMock.WriteUint8 (ZeroCopySinkMock.sol#211-217) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 219,
          "vulnerability_to_line": 225,
          "vulnerability_code": "    function WriteUint16(uint16 _v) public returns (bytes memory) {\n\n        bytes memory executeResult;\n\n        for (uint i = 0; i <= N; i++) {\n\n            executeResult = ZeroCopySink.WriteUint16(_v);\n\n        }\n\n        return ZeroCopySink.WriteUint16(_v);\n",
          "message": "ZeroCopySinkMock.WriteUint16 (ZeroCopySinkMock.sol#219-225) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 227,
          "vulnerability_to_line": 233,
          "vulnerability_code": "    function WriteUint32(uint32 _v) public returns (bytes memory) {\n\n        bytes memory executeResult;\n\n        for (uint i = 0; i <= N; i++) {\n\n            executeResult = ZeroCopySink.WriteUint32(_v);\n\n        }\n\n        return ZeroCopySink.WriteUint32(_v);\n",
          "message": "ZeroCopySinkMock.WriteUint32 (ZeroCopySinkMock.sol#227-233) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 235,
          "vulnerability_to_line": 241,
          "vulnerability_code": "    function WriteUint64(uint64 _v) public returns (bytes memory) {\n\n        bytes memory executeResult;\n\n        for (uint i = 0; i <= N; i++) {\n\n            executeResult = ZeroCopySink.WriteUint64(_v);\n\n        }\n\n        return ZeroCopySink.WriteUint64(_v);\n",
          "message": "ZeroCopySinkMock.WriteUint64 (ZeroCopySinkMock.sol#235-241) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 242,
          "vulnerability_to_line": 248,
          "vulnerability_code": "    function WriteUint255(uint256 _v) public returns (bytes memory) {\n\n        bytes memory executeResult;\n\n        for (uint i = 0; i <= N; i++) {\n\n            executeResult = ZeroCopySink.WriteUint255(_v);\n\n        }\n\n        return ZeroCopySink.WriteUint255(_v);\n",
          "message": "ZeroCopySinkMock.WriteUint255 (ZeroCopySinkMock.sol#242-248) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 250,
          "vulnerability_to_line": 256,
          "vulnerability_code": "    function WriteVarBytes(bytes memory _b) public returns (bytes memory) {\n\n        bytes memory executeResult;\n\n        for (uint i = 0; i <= N; i++) {\n\n            executeResult = ZeroCopySink.WriteVarBytes(_b);\n\n        }\n\n        return ZeroCopySink.WriteVarBytes(_b);\n",
          "message": "ZeroCopySinkMock.WriteVarBytes (ZeroCopySinkMock.sol#250-256) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 258,
          "vulnerability_to_line": 264,
          "vulnerability_code": "    function WriteVarUint(uint64 _v) public returns (bytes memory) {\n\n        bytes memory executeResult;\n\n        for (uint i = 0; i <= N; i++) {\n\n            executeResult = ZeroCopySink.WriteVarUint(_v);\n\n        }\n\n        return ZeroCopySink.WriteVarUint(_v);\n",
          "message": "ZeroCopySinkMock.WriteVarUint (ZeroCopySinkMock.sol#258-264) should be declared external\n"
        },
        {
          "name": "solc-version",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.0;\n",
          "message": "Detected issues with version pragma in ZeroCopySinkMock.sol:\n\t- pragma solidity^0.5.0 (ZeroCopySinkMock.sol#3): it allows old versions\n\t- pragma solidity^0.5.0 (ZeroCopySinkMock.sol#191): it allows old versions\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 24,
          "vulnerability_to_line": 41,
          "vulnerability_code": "    function WriteBool(bool b) internal pure returns (bytes memory) {\n\n        bytes memory buff;\n\n        assembly{\n\n            buff := mload(0x40)\n\n            mstore(buff, 1)\n\n            switch iszero(b)\n\n            case 1 {\n\n                mstore(add(buff, 0x20), shl(248, 0x00))\n\n                // mstore8(add(buff, 0x20), 0x00)\n\n            }\n\n            default {\n\n                mstore(add(buff, 0x20), shl(248, 0x01))\n\n                // mstore8(add(buff, 0x20), 0x01)\n\n            }\n\n            mstore(0x40, add(buff, 0x21))\n\n        }\n\n        return buff;\n",
          "message": "Function 'ZeroCopySink.WriteBool' (ZeroCopySinkMock.sol#24-41) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 47,
          "vulnerability_to_line": 49,
          "vulnerability_code": "    function WriteByte(byte b) internal pure returns (bytes memory) {\n\n        return WriteUint8(uint8(b));\n",
          "message": "Function 'ZeroCopySink.WriteByte' (ZeroCopySinkMock.sol#47-49) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 55,
          "vulnerability_to_line": 65,
          "vulnerability_code": "    function WriteUint8(uint8 v) internal pure returns (bytes memory) {\n\n        bytes memory buff;\n\n        assembly{\n\n            buff := mload(0x40)\n\n            mstore(buff, 1)\n\n            mstore(add(buff, 0x20), shl(248, v))\n\n            // mstore(add(buff, 0x20), byte(0x1f, v))\n\n            mstore(0x40, add(buff, 0x21))\n\n        }\n\n        return buff;\n",
          "message": "Function 'ZeroCopySink.WriteUint8' (ZeroCopySinkMock.sol#55-65) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 71,
          "vulnerability_to_line": 90,
          "vulnerability_code": "    function WriteUint16(uint16 v) internal pure returns (bytes memory) {\n\n        bytes memory buff;\n\n\n\n        assembly{\n\n            buff := mload(0x40)\n\n            let byteLen := 0x02\n\n            mstore(buff, byteLen)\n\n            for {\n\n                let mindex := 0x00\n\n                let vindex := 0x1f\n\n            } lt(mindex, byteLen) {\n\n                mindex := add(mindex, 0x01)\n\n                vindex := sub(vindex, 0x01)\n\n            }{\n\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\n\n            }\n\n            mstore(0x40, add(buff, 0x22))\n\n        }\n\n        return buff;\n",
          "message": "Function 'ZeroCopySink.WriteUint16' (ZeroCopySinkMock.sol#71-90) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 96,
          "vulnerability_to_line": 114,
          "vulnerability_code": "    function WriteUint32(uint32 v) internal pure returns(bytes memory) {\n\n        bytes memory buff;\n\n        assembly{\n\n            buff := mload(0x40)\n\n            let byteLen := 0x04\n\n            mstore(buff, byteLen)\n\n            for {\n\n                let mindex := 0x00\n\n                let vindex := 0x1f\n\n            } lt(mindex, byteLen) {\n\n                mindex := add(mindex, 0x01)\n\n                vindex := sub(vindex, 0x01)\n\n            }{\n\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\n\n            }\n\n            mstore(0x40, add(buff, 0x24))\n\n        }\n\n        return buff;\n",
          "message": "Function 'ZeroCopySink.WriteUint32' (ZeroCopySinkMock.sol#96-114) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 120,
          "vulnerability_to_line": 139,
          "vulnerability_code": "    function WriteUint64(uint64 v) internal pure returns(bytes memory) {\n\n        bytes memory buff;\n\n\n\n        assembly{\n\n            buff := mload(0x40)\n\n            let byteLen := 0x08\n\n            mstore(buff, byteLen)\n\n            for {\n\n                let mindex := 0x00\n\n                let vindex := 0x1f\n\n            } lt(mindex, byteLen) {\n\n                mindex := add(mindex, 0x01)\n\n                vindex := sub(vindex, 0x01)\n\n            }{\n\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\n\n            }\n\n            mstore(0x40, add(buff, 0x28))\n\n        }\n\n        return buff;\n",
          "message": "Function 'ZeroCopySink.WriteUint64' (ZeroCopySinkMock.sol#120-139) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 145,
          "vulnerability_to_line": 165,
          "vulnerability_code": "    function WriteUint255(uint256 v) internal pure returns (bytes memory) {\n\n        require(v <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds uint255 range\");\n\n        bytes memory buff;\n\n\n\n        assembly{\n\n            buff := mload(0x40)\n\n            let byteLen := 0x20\n\n            mstore(buff, byteLen)\n\n            for {\n\n                let mindex := 0x00\n\n                let vindex := 0x1f\n\n            } lt(mindex, byteLen) {\n\n                mindex := add(mindex, 0x01)\n\n                vindex := sub(vindex, 0x01)\n\n            }{\n\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\n\n            }\n\n            mstore(0x40, add(buff, 0x40))\n\n        }\n\n        return buff;\n",
          "message": "Function 'ZeroCopySink.WriteUint255' (ZeroCopySinkMock.sol#145-165) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 171,
          "vulnerability_to_line": 174,
          "vulnerability_code": "    function WriteVarBytes(bytes memory data) internal pure returns (bytes memory) {\n\n        uint64 l = uint64(data.length);\n\n        return abi.encodePacked(WriteVarUint(l), data);\n",
          "message": "Function 'ZeroCopySink.WriteVarBytes' (ZeroCopySinkMock.sol#171-174) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 176,
          "vulnerability_to_line": 186,
          "vulnerability_code": "    function WriteVarUint(uint64 v) internal pure returns (bytes memory) {\n\n        if (v < 0xFD){\n\n    \t\treturn WriteUint8(uint8(v));\n\n    \t} else if (v <= 0xFFFF) {\n\n    \t\treturn abi.encodePacked(WriteByte(0xFD), WriteUint16(uint16(v)));\n\n    \t} else if (v <= 0xFFFFFFFF) {\n\n            return abi.encodePacked(WriteByte(0xFE), WriteUint32(uint32(v)));\n\n    \t} else {\n\n    \t\treturn abi.encodePacked(WriteByte(0xFF), WriteUint64(uint64(v)));\n\n    \t}\n",
          "message": "Function 'ZeroCopySink.WriteVarUint' (ZeroCopySinkMock.sol#176-186) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 195,
          "vulnerability_to_line": 201,
          "vulnerability_code": "    function WriteBool(bool _b) public returns (bytes memory) {\n\n        bytes memory executeResult;\n\n        for (uint i = 0; i <= N; i++) {\n\n            executeResult = ZeroCopySink.WriteBool(_b);\n\n        }\n\n        return ZeroCopySink.WriteBool(_b);\n",
          "message": "Function 'ZeroCopySinkMock.WriteBool' (ZeroCopySinkMock.sol#195-201) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 195,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function WriteBool(bool _b) public returns (bytes memory) {\n",
          "message": "Parameter '_b' of ZeroCopySinkMock.WriteBool (ZeroCopySinkMock.sol#195) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 203,
          "vulnerability_to_line": 209,
          "vulnerability_code": "    function WriteByte(byte _b) public returns (bytes memory) {\n\n        bytes memory executeResult;\n\n        for (uint i = 0; i <= N; i++) {\n\n            executeResult = ZeroCopySink.WriteByte(_b);\n\n        }\n\n        return ZeroCopySink.WriteByte(_b);\n",
          "message": "Function 'ZeroCopySinkMock.WriteByte' (ZeroCopySinkMock.sol#203-209) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 203,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function WriteByte(byte _b) public returns (bytes memory) {\n",
          "message": "Parameter '_b' of ZeroCopySinkMock.WriteByte (ZeroCopySinkMock.sol#203) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 211,
          "vulnerability_to_line": 217,
          "vulnerability_code": "    function WriteUint8(uint8 _v) public returns (bytes memory) {\n\n        bytes memory executeResult;\n\n        for (uint i = 0; i <= N; i++) {\n\n            executeResult = ZeroCopySink.WriteUint8(_v);\n\n        }\n\n        return ZeroCopySink.WriteUint8(_v);\n",
          "message": "Function 'ZeroCopySinkMock.WriteUint8' (ZeroCopySinkMock.sol#211-217) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 211,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function WriteUint8(uint8 _v) public returns (bytes memory) {\n",
          "message": "Parameter '_v' of ZeroCopySinkMock.WriteUint8 (ZeroCopySinkMock.sol#211) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 219,
          "vulnerability_to_line": 225,
          "vulnerability_code": "    function WriteUint16(uint16 _v) public returns (bytes memory) {\n\n        bytes memory executeResult;\n\n        for (uint i = 0; i <= N; i++) {\n\n            executeResult = ZeroCopySink.WriteUint16(_v);\n\n        }\n\n        return ZeroCopySink.WriteUint16(_v);\n",
          "message": "Function 'ZeroCopySinkMock.WriteUint16' (ZeroCopySinkMock.sol#219-225) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 219,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function WriteUint16(uint16 _v) public returns (bytes memory) {\n",
          "message": "Parameter '_v' of ZeroCopySinkMock.WriteUint16 (ZeroCopySinkMock.sol#219) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 227,
          "vulnerability_to_line": 233,
          "vulnerability_code": "    function WriteUint32(uint32 _v) public returns (bytes memory) {\n\n        bytes memory executeResult;\n\n        for (uint i = 0; i <= N; i++) {\n\n            executeResult = ZeroCopySink.WriteUint32(_v);\n\n        }\n\n        return ZeroCopySink.WriteUint32(_v);\n",
          "message": "Function 'ZeroCopySinkMock.WriteUint32' (ZeroCopySinkMock.sol#227-233) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 227,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function WriteUint32(uint32 _v) public returns (bytes memory) {\n",
          "message": "Parameter '_v' of ZeroCopySinkMock.WriteUint32 (ZeroCopySinkMock.sol#227) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 235,
          "vulnerability_to_line": 241,
          "vulnerability_code": "    function WriteUint64(uint64 _v) public returns (bytes memory) {\n\n        bytes memory executeResult;\n\n        for (uint i = 0; i <= N; i++) {\n\n            executeResult = ZeroCopySink.WriteUint64(_v);\n\n        }\n\n        return ZeroCopySink.WriteUint64(_v);\n",
          "message": "Function 'ZeroCopySinkMock.WriteUint64' (ZeroCopySinkMock.sol#235-241) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 235,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function WriteUint64(uint64 _v) public returns (bytes memory) {\n",
          "message": "Parameter '_v' of ZeroCopySinkMock.WriteUint64 (ZeroCopySinkMock.sol#235) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 242,
          "vulnerability_to_line": 248,
          "vulnerability_code": "    function WriteUint255(uint256 _v) public returns (bytes memory) {\n\n        bytes memory executeResult;\n\n        for (uint i = 0; i <= N; i++) {\n\n            executeResult = ZeroCopySink.WriteUint255(_v);\n\n        }\n\n        return ZeroCopySink.WriteUint255(_v);\n",
          "message": "Function 'ZeroCopySinkMock.WriteUint255' (ZeroCopySinkMock.sol#242-248) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 242,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function WriteUint255(uint256 _v) public returns (bytes memory) {\n",
          "message": "Parameter '_v' of ZeroCopySinkMock.WriteUint255 (ZeroCopySinkMock.sol#242) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 250,
          "vulnerability_to_line": 256,
          "vulnerability_code": "    function WriteVarBytes(bytes memory _b) public returns (bytes memory) {\n\n        bytes memory executeResult;\n\n        for (uint i = 0; i <= N; i++) {\n\n            executeResult = ZeroCopySink.WriteVarBytes(_b);\n\n        }\n\n        return ZeroCopySink.WriteVarBytes(_b);\n",
          "message": "Function 'ZeroCopySinkMock.WriteVarBytes' (ZeroCopySinkMock.sol#250-256) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 250,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function WriteVarBytes(bytes memory _b) public returns (bytes memory) {\n",
          "message": "Parameter '_b' of ZeroCopySinkMock.WriteVarBytes (ZeroCopySinkMock.sol#250) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 258,
          "vulnerability_to_line": 264,
          "vulnerability_code": "    function WriteVarUint(uint64 _v) public returns (bytes memory) {\n\n        bytes memory executeResult;\n\n        for (uint i = 0; i <= N; i++) {\n\n            executeResult = ZeroCopySink.WriteVarUint(_v);\n\n        }\n\n        return ZeroCopySink.WriteVarUint(_v);\n",
          "message": "Function 'ZeroCopySinkMock.WriteVarUint' (ZeroCopySinkMock.sol#258-264) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 258,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function WriteVarUint(uint64 _v) public returns (bytes memory) {\n",
          "message": "Parameter '_v' of ZeroCopySinkMock.WriteVarUint (ZeroCopySinkMock.sol#258) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 194,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint N = 10;\n",
          "message": "Variable 'ZeroCopySinkMock.N' (ZeroCopySinkMock.sol#194) is not in mixedCase\n"
        }
      ]
    },
    "smartcheck": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 177,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (v < 0xFD){\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 179,
          "vulnerability_to_line": null,
          "vulnerability_code": "    \t} else if (v <= 0xFFFF) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 180,
          "vulnerability_to_line": null,
          "vulnerability_code": "    \t\treturn abi.encodePacked(WriteByte(0xFD), WriteUint16(uint16(v)));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 181,
          "vulnerability_to_line": null,
          "vulnerability_code": "    \t} else if (v <= 0xFFFFFFFF) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 182,
          "vulnerability_to_line": null,
          "vulnerability_code": "            return abi.encodePacked(WriteByte(0xFE), WriteUint32(uint32(v)));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 184,
          "vulnerability_to_line": null,
          "vulnerability_code": "    \t\treturn abi.encodePacked(WriteByte(0xFF), WriteUint64(uint64(v)));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 197,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i <= N; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 205,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i <= N; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 213,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i <= N; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 221,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i <= N; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 229,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i <= N; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 237,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i <= N; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 244,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i <= N; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 252,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i <= N; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 260,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i <= N; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 191,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 24,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function WriteBool(bool b) internal pure returns (bytes memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 55,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function WriteUint8(uint8 v) internal pure returns (bytes memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 71,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function WriteUint16(uint16 v) internal pure returns (bytes memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 96,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function WriteUint32(uint32 v) internal pure returns(bytes memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 120,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function WriteUint64(uint64 v) internal pure returns(bytes memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 145,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function WriteUint255(uint256 v) internal pure returns (bytes memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 26,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly{\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 57,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly{\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 74,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly{\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 98,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly{\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 123,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly{\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 149,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly{\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 194,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint N = 10;\n",
          "message": null
        }
      ]
    },
    "oyente": {
      "successfull_analysis": false,
      "errors": [
        "exception (IndexError: pop from empty list)"
      ],
      "vulnerability_findings": []
    },
    "mythril": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": []
    },
    "osiris": {
      "successfull_analysis": false,
      "errors": [
        "Solidity compilation failed"
      ],
      "vulnerability_findings": []
    }
  }
}