{
  "smartbugs_completed": true,
  "analyzer_results": {
    "semgrep": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 775,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(uint i = 0; i < _signers.length; i++){\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 776,
          "vulnerability_to_line": null,
          "vulnerability_code": "            for (uint j = 0; j < _keepers.length; j++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 19,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor () internal { }\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 1052,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor(address ethCCMProxyAddr) public {\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 1053,
          "vulnerability_to_line": null,
          "vulnerability_code": "        managerProxyContract = ethCCMProxyAddr;\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 1054,
          "vulnerability_to_line": null,
          "vulnerability_code": "        emit SetManagerProxyEvent(managerProxyContract);\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 1055,
          "vulnerability_to_line": null,
          "vulnerability_code": "    }\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 775,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(uint i = 0; i < _signers.length; i++){\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 776,
          "vulnerability_to_line": null,
          "vulnerability_code": "            for (uint j = 0; j < _keepers.length; j++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 57,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(offset + 1 <= buff.length && offset < offset + 1, \"Offset exceeds limit\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 69,
          "vulnerability_to_line": null,
          "vulnerability_code": "            revert(\"NextBool value error\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 80,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(offset + 1 <= buff.length && offset < offset + 1, \"NextByte, Offset exceeds maximum\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 94,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(offset + 1 <= buff.length && offset < offset + 1, \"NextUint8, Offset exceeds maximum\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 112,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(offset + 2 <= buff.length && offset < offset + 2, \"NextUint16, offset exceeds maximum\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 133,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(offset + 4 <= buff.length && offset < offset + 4, \"NextUint32, offset exceeds maximum\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 160,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(offset + 8 <= buff.length && offset < offset + 8, \"NextUint64, offset exceeds maximum\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 188,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(offset + 32 <= buff.length && offset < offset + 32, \"NextUint255, offset exceeds maximum\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 206,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(v <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds the range\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 218,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(offset + len <= buff.length && offset < offset + len, \"NextVarBytes, offset exceeds maximum\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 277,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(offset + 32 <= buff.length && offset < offset + 32, \"NextHash, offset exceeds maximum\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 291,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(offset + 20 <= buff.length && offset < offset + 20, \"NextBytes20, offset exceeds maximum\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 307,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(value >= 0xFD && value <= 0xFFFF, \"NextUint16, value outside range\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 312,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(value > 0xFFFF && value <= 0xFFFFFFFF, \"NextVarUint, value outside range\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 317,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(value > 0xFFFFFFFF, \"NextVarUint, value outside range\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 322,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(value < 0xFD, \"NextVarUint, value outside range\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 473,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(v <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds uint255 range\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 528,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_bs.length == 32, \"bytes length is not 32.\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 540,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_bs.length == 32, \"bytes length is not 32.\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 545,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(value <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds the range\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 553,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_value <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds the range\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 573,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_bs.length == 20, \"bytes length does not match address\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 791,
          "vulnerability_to_line": null,
          "vulnerability_code": "         require(key.length >= 67, \"key lenggh is too short\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 858,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(c >= a, \"SafeMath: addition overflow\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 912,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(c / a == b, \"SafeMath: multiplication overflow\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1059,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_msgSender() == ieccmp.getEthCrossChainManager(), \"msgSender is not EthCrossChainManagerContract\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1064,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(nativeChainId != 0, \"nativeChainId cannot be zero\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1065,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(nativeLockProxy.length != 0, \"empty nativeLockProxy\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1066,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(nativeAssetHash.length != 0, \"empty nativeAssetHash\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1071,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(registry[key] != true, \"asset already registered\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1072,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(balances[key] == 0, \"balance is not zero\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1073,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_balanceFor(assetHash) == delegatedSupply, \"controlled balance does not match delegatedSupply\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1085,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(eccm.crossChain(nativeChainId, nativeLockProxy, \"registerAsset\", txData), \"EthCrossChainManager crossChain executed error!\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1096,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(registry[key] != true, \"asset already registerd\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1126,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(toChainId != 0, \"toChainId cannot be zero\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1127,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(targetProxyHash.length != 0, \"empty targetProxyHash\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1128,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(toAssetHash.length != 0, \"empty toAssetHash\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1129,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(toAddress.length != 0, \"empty toAddress\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1130,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(amount != 0, \"amount must be more than zero!\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1132,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_transferToContract(fromAssetHash, amount), \"transfer asset from fromAddress to lock_proxy contract  failed!\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1135,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(registry[key] == true, \"asset not registered\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1147,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(feeAddress.length != 0, \"empty fee address\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1149,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(_transferFromContract(fromAssetHash, Utils.bytesToAddress(feeAddress), feeAmount), \"transfer asset from lock_proxy contract to feeAddress failed!\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1159,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(eccm.crossChain(toChainId, targetProxyHash, \"unlock\", txData), \"EthCrossChainManager crossChain executed error!\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1182,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(registry[key] == true, \"asset not registered\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1183,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(balances[key] >= args.amount, \"insufficient balance in registry\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1193,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(_transferFromContract(toAssetHash, feeAddress, args.feeAmount), \"transfer asset from lock_proxy contract to feeAddress failed!\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1197,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_transferFromContract(toAssetHash, toAddress, afterFeeAmount), \"transfer asset from lock_proxy contract to toAddress failed!\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1231,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(msg.value == amount, \"transferred ether is not equal to amount!\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1234,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(_transferERC20ToContract(fromAssetHash, _msgSender(), address(this), amount), \"transfer erc20 asset to lock_proxy contract failed!\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1245,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(_transferERC20FromContract(toAssetHash, toAddress, amount), \"transfer erc20 asset to lock_proxy contract failed!\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1253,
          "vulnerability_to_line": null,
          "vulnerability_code": "         require(erc20Token.transferFrom(fromAddress, toAddress, amount), \"trasnfer ERC20 Token failed!\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1258,
          "vulnerability_to_line": null,
          "vulnerability_code": "         require(erc20Token.transfer(toAddress, amount), \"trasnfer ERC20 Token failed!\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 57,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(offset + 1 <= buff.length && offset < offset + 1, \"Offset exceeds limit\");\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 80,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(offset + 1 <= buff.length && offset < offset + 1, \"NextByte, Offset exceeds maximum\");\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 94,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(offset + 1 <= buff.length && offset < offset + 1, \"NextUint8, Offset exceeds maximum\");\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 112,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(offset + 2 <= buff.length && offset < offset + 2, \"NextUint16, offset exceeds maximum\");\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 133,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(offset + 4 <= buff.length && offset < offset + 4, \"NextUint32, offset exceeds maximum\");\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 160,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(offset + 8 <= buff.length && offset < offset + 8, \"NextUint64, offset exceeds maximum\");\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 188,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(offset + 32 <= buff.length && offset < offset + 32, \"NextUint255, offset exceeds maximum\");\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 218,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(offset + len <= buff.length && offset < offset + len, \"NextVarBytes, offset exceeds maximum\");\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 277,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(offset + 32 <= buff.length && offset < offset + 32, \"NextHash, offset exceeds maximum\");\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 291,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(offset + 20 <= buff.length && offset < offset + 20, \"NextBytes20, offset exceeds maximum\");\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 307,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(value >= 0xFD && value <= 0xFFFF, \"NextUint16, value outside range\");\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 312,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(value > 0xFFFF && value <= 0xFFFFFFFF, \"NextVarUint, value outside range\");\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 1146,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (feeAmount != 0 && deductFeeInLock) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 1147,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(feeAddress.length != 0, \"empty fee address\");\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 1148,
          "vulnerability_to_line": null,
          "vulnerability_code": "            uint256 afterFeeAmount = amount.sub(feeAmount);\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 1149,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(_transferFromContract(fromAssetHash, Utils.bytesToAddress(feeAddress), feeAmount), \"transfer asset from lock_proxy contract to feeAddress failed!\");\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 1150,
          "vulnerability_to_line": null,
          "vulnerability_code": "\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 1151,
          "vulnerability_to_line": null,
          "vulnerability_code": "            // set feeAmount to zero as fee has already been transferred\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 1152,
          "vulnerability_to_line": null,
          "vulnerability_code": "            txArgs.feeAmount = 0;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 1153,
          "vulnerability_to_line": null,
          "vulnerability_code": "            txArgs.amount = afterFeeAmount;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 1154,
          "vulnerability_to_line": null,
          "vulnerability_code": "        }\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 775,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(uint i = 0; i < _signers.length; i++){\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 776,
          "vulnerability_to_line": null,
          "vulnerability_code": "            for (uint j = 0; j < _keepers.length; j++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 778,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    m++;\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 94,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(offset + 1 <= buff.length && offset < offset + 1, \"NextUint8, Offset exceeds maximum\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 112,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(offset + 2 <= buff.length && offset < offset + 2, \"NextUint16, offset exceeds maximum\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 133,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(offset + 4 <= buff.length && offset < offset + 4, \"NextUint32, offset exceeds maximum\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 160,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(offset + 8 <= buff.length && offset < offset + 8, \"NextUint64, offset exceeds maximum\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 188,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(offset + 32 <= buff.length && offset < offset + 32, \"NextUint255, offset exceeds maximum\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 218,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(offset + len <= buff.length && offset < offset + len, \"NextVarBytes, offset exceeds maximum\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 291,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(offset + 20 <= buff.length && offset < offset + 20, \"NextBytes20, offset exceeds maximum\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 573,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_bs.length == 20, \"bytes length does not match address\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 912,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(c / a == b, \"SafeMath: multiplication overflow\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 1059,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_msgSender() == ieccmp.getEthCrossChainManager(), \"msgSender is not EthCrossChainManagerContract\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 1073,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_balanceFor(assetHash) == delegatedSupply, \"controlled balance does not match delegatedSupply\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 1085,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(eccm.crossChain(nativeChainId, nativeLockProxy, \"registerAsset\", txData), \"EthCrossChainManager crossChain executed error!\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 1132,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_transferToContract(fromAssetHash, amount), \"transfer asset from fromAddress to lock_proxy contract  failed!\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 1149,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(_transferFromContract(fromAssetHash, Utils.bytesToAddress(feeAddress), feeAmount), \"transfer asset from lock_proxy contract to feeAddress failed!\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 1159,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(eccm.crossChain(toChainId, targetProxyHash, \"unlock\", txData), \"EthCrossChainManager crossChain executed error!\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 1193,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(_transferFromContract(toAssetHash, feeAddress, args.feeAmount), \"transfer asset from lock_proxy contract to feeAddress failed!\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 1197,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_transferFromContract(toAssetHash, toAddress, afterFeeAmount), \"transfer asset from lock_proxy contract to toAddress failed!\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 1231,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(msg.value == amount, \"transferred ether is not equal to amount!\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 1234,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(_transferERC20ToContract(fromAssetHash, _msgSender(), address(this), amount), \"transfer erc20 asset to lock_proxy contract failed!\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 1245,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(_transferERC20FromContract(toAssetHash, toAddress, amount), \"transfer erc20 asset to lock_proxy contract failed!\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        }
      ]
    },
    "slither": {
      "successfull_analysis": true,
      "errors": [
        "EXIT_CODE_105"
      ],
      "vulnerability_findings": [
        {
          "name": "arbitrary-send",
          "vulnerability_from_line": 1238,
          "vulnerability_to_line": 1248,
          "vulnerability_code": "    function _transferFromContract(address toAssetHash, address toAddress, uint256 amount) internal returns (bool) {\n\n        if (toAssetHash == address(0x0000000000000000000000000000000000000000)) {\n\n            // toAssetHash === address(0) denotes contract needs to unlock ether to toAddress\n\n            // convert toAddress from 'address' type to 'address payable' type, then actively transfer ether\n\n            address(uint160(toAddress)).transfer(amount);\n\n        } else {\n\n            // actively transfer amount of asset from msg.sender to lock_proxy contract\n\n            require(_transferERC20FromContract(toAssetHash, toAddress, amount), \"transfer erc20 asset to lock_proxy contract failed!\");\n\n        }\n\n        return true;\n",
          "message": "LockProxyPip1._transferFromContract (LockProxyPip1.sol#1238-1248) sends eth to arbitrary user\n\tDangerous calls:\n\t- address(uint160(toAddress)).transfer(amount) (LockProxyPip1.sol#1242)\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 56,
          "vulnerability_to_line": 72,
          "vulnerability_code": "    function NextBool(bytes memory buff, uint256 offset) internal pure returns(bool, uint256) {\n\n        require(offset + 1 <= buff.length && offset < offset + 1, \"Offset exceeds limit\");\n\n        // byte === bytes1\n\n        byte v;\n\n        assembly{\n\n            v := mload(add(add(buff, 0x20), offset))\n\n        }\n\n        bool value;\n\n        if (v == 0x01) {\n\n\t\t    value = true;\n\n    \t} else if (v == 0x00) {\n\n            value = false;\n\n        } else {\n\n            revert(\"NextBool value error\");\n\n        }\n\n        return (value, offset + 1);\n",
          "message": "ZeroCopySource.NextBool (LockProxyPip1.sol#56-72) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 79,
          "vulnerability_to_line": 86,
          "vulnerability_code": "    function NextByte(bytes memory buff, uint256 offset) internal pure returns (byte, uint256) {\n\n        require(offset + 1 <= buff.length && offset < offset + 1, \"NextByte, Offset exceeds maximum\");\n\n        byte v;\n\n        assembly{\n\n            v := mload(add(add(buff, 0x20), offset))\n\n        }\n\n        return (v, offset + 1);\n",
          "message": "ZeroCopySource.NextByte (LockProxyPip1.sol#79-86) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 93,
          "vulnerability_to_line": 104,
          "vulnerability_code": "    function NextUint8(bytes memory buff, uint256 offset) internal pure returns (uint8, uint256) {\n\n        require(offset + 1 <= buff.length && offset < offset + 1, \"NextUint8, Offset exceeds maximum\");\n\n        uint8 v;\n\n        assembly{\n\n            let tmpbytes := mload(0x40)\n\n            let bvalue := mload(add(add(buff, 0x20), offset))\n\n            mstore8(tmpbytes, byte(0, bvalue))\n\n            mstore(0x40, add(tmpbytes, 0x01))\n\n            v := mload(sub(tmpbytes, 0x1f))\n\n        }\n\n        return (v, offset + 1);\n",
          "message": "ZeroCopySource.NextUint8 (LockProxyPip1.sol#93-104) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 111,
          "vulnerability_to_line": 124,
          "vulnerability_code": "    function NextUint16(bytes memory buff, uint256 offset) internal pure returns (uint16, uint256) {\n\n        require(offset + 2 <= buff.length && offset < offset + 2, \"NextUint16, offset exceeds maximum\");\n\n        \n\n        uint16 v;\n\n        assembly {\n\n            let tmpbytes := mload(0x40)\n\n            let bvalue := mload(add(add(buff, 0x20), offset))\n\n            mstore8(tmpbytes, byte(0x01, bvalue))\n\n            mstore8(add(tmpbytes, 0x01), byte(0, bvalue))\n\n            mstore(0x40, add(tmpbytes, 0x02))\n\n            v := mload(sub(tmpbytes, 0x1e))\n\n        }\n\n        return (v, offset + 2);\n",
          "message": "ZeroCopySource.NextUint16 (LockProxyPip1.sol#111-124) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 132,
          "vulnerability_to_line": 152,
          "vulnerability_code": "    function NextUint32(bytes memory buff, uint256 offset) internal pure returns (uint32, uint256) {\n\n        require(offset + 4 <= buff.length && offset < offset + 4, \"NextUint32, offset exceeds maximum\");\n\n        uint32 v;\n\n        assembly {\n\n            let tmpbytes := mload(0x40)\n\n            let byteLen := 0x04\n\n            for {\n\n                let tindex := 0x00\n\n                let bindex := sub(byteLen, 0x01)\n\n                let bvalue := mload(add(add(buff, 0x20), offset))\n\n            } lt(tindex, byteLen) {\n\n                tindex := add(tindex, 0x01)\n\n                bindex := sub(bindex, 0x01)\n\n            }{\n\n                mstore8(add(tmpbytes, tindex), byte(bindex, bvalue))\n\n            }\n\n            mstore(0x40, add(tmpbytes, byteLen))\n\n            v := mload(sub(tmpbytes, sub(0x20, byteLen)))\n\n        }\n\n        return (v, offset + 4);\n",
          "message": "ZeroCopySource.NextUint32 (LockProxyPip1.sol#132-152) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 159,
          "vulnerability_to_line": 179,
          "vulnerability_code": "    function NextUint64(bytes memory buff, uint256 offset) internal pure returns (uint64, uint256) {\n\n        require(offset + 8 <= buff.length && offset < offset + 8, \"NextUint64, offset exceeds maximum\");\n\n        uint64 v;\n\n        assembly {\n\n            let tmpbytes := mload(0x40)\n\n            let byteLen := 0x08\n\n            for {\n\n                let tindex := 0x00\n\n                let bindex := sub(byteLen, 0x01)\n\n                let bvalue := mload(add(add(buff, 0x20), offset))\n\n            } lt(tindex, byteLen) {\n\n                tindex := add(tindex, 0x01)\n\n                bindex := sub(bindex, 0x01)\n\n            }{\n\n                mstore8(add(tmpbytes, tindex), byte(bindex, bvalue))\n\n            }\n\n            mstore(0x40, add(tmpbytes, byteLen))\n\n            v := mload(sub(tmpbytes, sub(0x20, byteLen)))\n\n        }\n\n        return (v, offset + 8);\n",
          "message": "ZeroCopySource.NextUint64 (LockProxyPip1.sol#159-179) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 187,
          "vulnerability_to_line": 208,
          "vulnerability_code": "    function NextUint255(bytes memory buff, uint256 offset) internal pure returns (uint256, uint256) {\n\n        require(offset + 32 <= buff.length && offset < offset + 32, \"NextUint255, offset exceeds maximum\");\n\n        uint256 v;\n\n        assembly {\n\n            let tmpbytes := mload(0x40)\n\n            let byteLen := 0x20\n\n            for {\n\n                let tindex := 0x00\n\n                let bindex := sub(byteLen, 0x01)\n\n                let bvalue := mload(add(add(buff, 0x20), offset))\n\n            } lt(tindex, byteLen) {\n\n                tindex := add(tindex, 0x01)\n\n                bindex := sub(bindex, 0x01)\n\n            }{\n\n                mstore8(add(tmpbytes, tindex), byte(bindex, bvalue))\n\n            }\n\n            mstore(0x40, add(tmpbytes, byteLen))\n\n            v := mload(tmpbytes)\n\n        }\n\n        require(v <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds the range\");\n\n        return (v, offset + 32);\n",
          "message": "ZeroCopySource.NextUint255 (LockProxyPip1.sol#187-208) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 215,
          "vulnerability_to_line": 270,
          "vulnerability_code": "    function NextVarBytes(bytes memory buff, uint256 offset) internal pure returns(bytes memory, uint256) {\n\n        uint len;\n\n        (len, offset) = NextVarUint(buff, offset);\n\n        require(offset + len <= buff.length && offset < offset + len, \"NextVarBytes, offset exceeds maximum\");\n\n        bytes memory tempBytes;\n\n        assembly{\n\n            switch iszero(len)\n\n            case 0 {\n\n                // Get a location of some free memory and store it in tempBytes as\n\n                // Solidity does for memory variables.\n\n                tempBytes := mload(0x40)\n\n\n\n                // The first word of the slice result is potentially a partial\n\n                // word read from the original array. To read it, we calculate\n\n                // the length of that partial word and start copying that many\n\n                // bytes into the array. The first word we copy will start with\n\n                // data we don't care about, but the last `lengthmod` bytes will\n\n                // land at the beginning of the contents of the new array. When\n\n                // we're done copying, we overwrite the full first word with\n\n                // the actual length of the slice.\n\n                let lengthmod := and(len, 31)\n\n\n\n                // The multiplication in the next line is necessary\n\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n\n                // the following copy loop was copying the origin's length\n\n                // and then ending prematurely not copying everything it should.\n\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n\n                let end := add(mc, len)\n\n\n\n                for {\n\n                    // The multiplication in the next line has the same exact purpose\n\n                    // as the one above.\n\n                    let cc := add(add(add(buff, lengthmod), mul(0x20, iszero(lengthmod))), offset)\n\n                } lt(mc, end) {\n\n                    mc := add(mc, 0x20)\n\n                    cc := add(cc, 0x20)\n\n                } {\n\n                    mstore(mc, mload(cc))\n\n                }\n\n\n\n                mstore(tempBytes, len)\n\n\n\n                //update free-memory pointer\n\n                //allocating the array padded to 32 bytes like the compiler does now\n\n                mstore(0x40, and(add(mc, 31), not(31)))\n\n            }\n\n            //if we want a zero-length slice let's just return a zero-length array\n\n            default {\n\n                tempBytes := mload(0x40)\n\n\n\n                mstore(0x40, add(tempBytes, 0x20))\n\n            }\n\n        }\n\n\n\n        return (tempBytes, offset + len);\n",
          "message": "ZeroCopySource.NextVarBytes (LockProxyPip1.sol#215-270) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 276,
          "vulnerability_to_line": 283,
          "vulnerability_code": "    function NextHash(bytes memory buff, uint256 offset) internal pure returns (bytes32 , uint256) {\n\n        require(offset + 32 <= buff.length && offset < offset + 32, \"NextHash, offset exceeds maximum\");\n\n        bytes32 v;\n\n        assembly {\n\n            v := mload(add(buff, add(offset, 0x20)))\n\n        }\n\n        return (v, offset + 32);\n",
          "message": "ZeroCopySource.NextHash (LockProxyPip1.sol#276-283) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 290,
          "vulnerability_to_line": 297,
          "vulnerability_code": "    function NextBytes20(bytes memory buff, uint256 offset) internal pure returns (bytes20 , uint256) {\n\n        require(offset + 20 <= buff.length && offset < offset + 20, \"NextBytes20, offset exceeds maximum\");\n\n        bytes20 v;\n\n        assembly {\n\n            v := mload(add(buff, add(offset, 0x20)))\n\n        }\n\n        return (v, offset + 20);\n",
          "message": "ZeroCopySource.NextBytes20 (LockProxyPip1.sol#290-297) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 351,
          "vulnerability_to_line": 368,
          "vulnerability_code": "    function WriteBool(bool b) internal pure returns (bytes memory) {\n\n        bytes memory buff;\n\n        assembly{\n\n            buff := mload(0x40)\n\n            mstore(buff, 1)\n\n            switch iszero(b)\n\n            case 1 {\n\n                mstore(add(buff, 0x20), shl(248, 0x00))\n\n                // mstore8(add(buff, 0x20), 0x00)\n\n            }\n\n            default {\n\n                mstore(add(buff, 0x20), shl(248, 0x01))\n\n                // mstore8(add(buff, 0x20), 0x01)\n\n            }\n\n            mstore(0x40, add(buff, 0x21))\n\n        }\n\n        return buff;\n",
          "message": "ZeroCopySink.WriteBool (LockProxyPip1.sol#351-368) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 382,
          "vulnerability_to_line": 392,
          "vulnerability_code": "    function WriteUint8(uint8 v) internal pure returns (bytes memory) {\n\n        bytes memory buff;\n\n        assembly{\n\n            buff := mload(0x40)\n\n            mstore(buff, 1)\n\n            mstore(add(buff, 0x20), shl(248, v))\n\n            // mstore(add(buff, 0x20), byte(0x1f, v))\n\n            mstore(0x40, add(buff, 0x21))\n\n        }\n\n        return buff;\n",
          "message": "ZeroCopySink.WriteUint8 (LockProxyPip1.sol#382-392) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 398,
          "vulnerability_to_line": 417,
          "vulnerability_code": "    function WriteUint16(uint16 v) internal pure returns (bytes memory) {\n\n        bytes memory buff;\n\n\n\n        assembly{\n\n            buff := mload(0x40)\n\n            let byteLen := 0x02\n\n            mstore(buff, byteLen)\n\n            for {\n\n                let mindex := 0x00\n\n                let vindex := 0x1f\n\n            } lt(mindex, byteLen) {\n\n                mindex := add(mindex, 0x01)\n\n                vindex := sub(vindex, 0x01)\n\n            }{\n\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\n\n            }\n\n            mstore(0x40, add(buff, 0x22))\n\n        }\n\n        return buff;\n",
          "message": "ZeroCopySink.WriteUint16 (LockProxyPip1.sol#398-417) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 423,
          "vulnerability_to_line": 441,
          "vulnerability_code": "    function WriteUint32(uint32 v) internal pure returns(bytes memory) {\n\n        bytes memory buff;\n\n        assembly{\n\n            buff := mload(0x40)\n\n            let byteLen := 0x04\n\n            mstore(buff, byteLen)\n\n            for {\n\n                let mindex := 0x00\n\n                let vindex := 0x1f\n\n            } lt(mindex, byteLen) {\n\n                mindex := add(mindex, 0x01)\n\n                vindex := sub(vindex, 0x01)\n\n            }{\n\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\n\n            }\n\n            mstore(0x40, add(buff, 0x24))\n\n        }\n\n        return buff;\n",
          "message": "ZeroCopySink.WriteUint32 (LockProxyPip1.sol#423-441) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 447,
          "vulnerability_to_line": 466,
          "vulnerability_code": "    function WriteUint64(uint64 v) internal pure returns(bytes memory) {\n\n        bytes memory buff;\n\n\n\n        assembly{\n\n            buff := mload(0x40)\n\n            let byteLen := 0x08\n\n            mstore(buff, byteLen)\n\n            for {\n\n                let mindex := 0x00\n\n                let vindex := 0x1f\n\n            } lt(mindex, byteLen) {\n\n                mindex := add(mindex, 0x01)\n\n                vindex := sub(vindex, 0x01)\n\n            }{\n\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\n\n            }\n\n            mstore(0x40, add(buff, 0x28))\n\n        }\n\n        return buff;\n",
          "message": "ZeroCopySink.WriteUint64 (LockProxyPip1.sol#447-466) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 472,
          "vulnerability_to_line": 492,
          "vulnerability_code": "    function WriteUint255(uint256 v) internal pure returns (bytes memory) {\n\n        require(v <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds uint255 range\");\n\n        bytes memory buff;\n\n\n\n        assembly{\n\n            buff := mload(0x40)\n\n            let byteLen := 0x20\n\n            mstore(buff, byteLen)\n\n            for {\n\n                let mindex := 0x00\n\n                let vindex := 0x1f\n\n            } lt(mindex, byteLen) {\n\n                mindex := add(mindex, 0x01)\n\n                vindex := sub(vindex, 0x01)\n\n            }{\n\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\n\n            }\n\n            mstore(0x40, add(buff, 0x40))\n\n        }\n\n        return buff;\n",
          "message": "ZeroCopySink.WriteUint255 (LockProxyPip1.sol#472-492) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 527,
          "vulnerability_to_line": 533,
          "vulnerability_code": "    function bytesToBytes32(bytes memory _bs) internal pure returns (bytes32 value) {\n\n        require(_bs.length == 32, \"bytes length is not 32.\");\n\n        assembly {\n\n            // load 32 bytes from memory starting from position _bs + 0x20 since the first 0x20 bytes stores _bs length\n\n            value := mload(add(_bs, 0x20))\n\n        }\n",
          "message": "Utils.bytesToBytes32 (LockProxyPip1.sol#527-533) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 539,
          "vulnerability_to_line": 546,
          "vulnerability_code": "    function bytesToUint256(bytes memory _bs) internal pure returns (uint256 value) {\n\n        require(_bs.length == 32, \"bytes length is not 32.\");\n\n        assembly {\n\n            // load 32 bytes from memory starting from position _bs + 32\n\n            value := mload(add(_bs, 0x20))\n\n        }\n\n        require(value <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds the range\");\n",
          "message": "Utils.bytesToUint256 (LockProxyPip1.sol#539-546) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 552,
          "vulnerability_to_line": 565,
          "vulnerability_code": "    function uint256ToBytes(uint256 _value) internal pure returns (bytes memory bs) {\n\n        require(_value <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds the range\");\n\n        assembly {\n\n            // Get a location of some free memory and store it in result as\n\n            // Solidity does for memory variables.\n\n            bs := mload(0x40)\n\n            // Put 0x20 at the first word, the length of bytes for uint256 value\n\n            mstore(bs, 0x20)\n\n            //In the next word, put value in bytes format to the next 32 bytes\n\n            mstore(add(bs, 0x20), _value)\n\n            // Update the free-memory pointer by padding our last write location to 32 bytes\n\n            mstore(0x40, add(bs, 0x40))\n\n        }\n",
          "message": "Utils.uint256ToBytes (LockProxyPip1.sol#552-565) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 571,
          "vulnerability_to_line": 580,
          "vulnerability_code": "    function bytesToAddress(bytes memory _bs) internal pure returns (address addr)\n\n    {\n\n        require(_bs.length == 20, \"bytes length does not match address\");\n\n        assembly {\n\n            // for _bs, first word store _bs.length, second word store _bs.value\n\n            // load 32 bytes from mem[_bs+20], convert it into Uint160, meaning we take last 20 bytes as addr (address).\n\n            addr := mload(add(_bs, 0x14))\n\n        }\n\n\n",
          "message": "Utils.bytesToAddress (LockProxyPip1.sol#571-580) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 586,
          "vulnerability_to_line": 598,
          "vulnerability_code": "    function addressToBytes(address _addr) internal pure returns (bytes memory bs){\n\n        assembly {\n\n            // Get a location of some free memory and store it in result as\n\n            // Solidity does for memory variables.\n\n            bs := mload(0x40)\n\n            // Put 20 (address byte length) at the first word, the length of bytes for uint256 value\n\n            mstore(bs, 0x14)\n\n            // logical shift left _a by 12 bytes, change _a from right-aligned to left-aligned\n\n            mstore(add(bs, 0x20), shl(96, _addr))\n\n            // Update the free-memory pointer by padding our last write location to 32 bytes\n\n            mstore(0x40, add(bs, 0x40))\n\n       }\n",
          "message": "Utils.addressToBytes (LockProxyPip1.sol#586-598) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 623,
          "vulnerability_to_line": 693,
          "vulnerability_code": "    function equalStorage(bytes storage _preBytes, bytes memory _postBytes) internal view returns (bool) {\n\n        bool success = true;\n\n\n\n        assembly {\n\n            // we know _preBytes_offset is 0\n\n            let fslot := sload(_preBytes_slot)\n\n            // Arrays of 31 bytes or less have an even value in their slot,\n\n            // while longer arrays have an odd value. The actual length is\n\n            // the slot divided by two for odd values, and the lowest order\n\n            // byte divided by two for even values.\n\n            // If the slot is even, bitwise and the slot with 255 and divide by\n\n            // two to get the length. If the slot is odd, bitwise and the slot\n\n            // with -1 and divide by two.\n\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n\n            let mlength := mload(_postBytes)\n\n\n\n            // if lengths don't match the arrays are not equal\n\n            switch eq(slength, mlength)\n\n            case 1 {\n\n                // fslot can contain both the length and contents of the array\n\n                // if slength < 32 bytes so let's prepare for that\n\n                // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n\n                // slength != 0\n\n                if iszero(iszero(slength)) {\n\n                    switch lt(slength, 32)\n\n                    case 1 {\n\n                        // blank the last byte which is the length\n\n                        fslot := mul(div(fslot, 0x100), 0x100)\n\n\n\n                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\n\n                            // unsuccess:\n\n                            success := 0\n\n                        }\n\n                    }\n\n                    default {\n\n                        // cb is a circuit breaker in the for loop since there's\n\n                        //  no said feature for inline assembly loops\n\n                        // cb = 1 - don't breaker\n\n                        // cb = 0 - break\n\n                        let cb := 1\n\n\n\n                        // get the keccak hash to get the contents of the array\n\n                        mstore(0x0, _preBytes_slot)\n\n                        let sc := keccak256(0x0, 0x20)\n\n\n\n                        let mc := add(_postBytes, 0x20)\n\n                        let end := add(mc, mlength)\n\n\n\n                        // the next line is the loop condition:\n\n                        // while(uint(mc < end) + cb == 2)\n\n                        for {} eq(add(lt(mc, end), cb), 2) {\n\n                            sc := add(sc, 1)\n\n                            mc := add(mc, 0x20)\n\n                        } {\n\n                            if iszero(eq(sload(sc), mload(mc))) {\n\n                                // unsuccess:\n\n                                success := 0\n\n                                cb := 0\n\n                            }\n\n                        }\n\n                    }\n\n                }\n\n            }\n\n            default {\n\n                // unsuccess:\n\n                success := 0\n\n            }\n\n        }\n\n\n\n        return success;\n",
          "message": "Utils.equalStorage (LockProxyPip1.sol#623-693) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 702,
          "vulnerability_to_line": 766,
          "vulnerability_code": "    function slice(\n\n        bytes memory _bytes,\n\n        uint _start,\n\n        uint _length\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        require(_bytes.length >= (_start + _length));\n\n\n\n        bytes memory tempBytes;\n\n\n\n        assembly {\n\n            switch iszero(_length)\n\n            case 0 {\n\n                // Get a location of some free memory and store it in tempBytes as\n\n                // Solidity does for memory variables.\n\n                tempBytes := mload(0x40)\n\n\n\n                // The first word of the slice result is potentially a partial\n\n                // word read from the original array. To read it, we calculate\n\n                // the length of that partial word and start copying that many\n\n                // bytes into the array. The first word we copy will start with\n\n                // data we don't care about, but the last `lengthmod` bytes will\n\n                // land at the beginning of the contents of the new array. When\n\n                // we're done copying, we overwrite the full first word with\n\n                // the actual length of the slice.\n\n                // lengthmod <= _length % 32\n\n                let lengthmod := and(_length, 31)\n\n\n\n                // The multiplication in the next line is necessary\n\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n\n                // the following copy loop was copying the origin's length\n\n                // and then ending prematurely not copying everything it should.\n\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n\n                let end := add(mc, _length)\n\n\n\n                for {\n\n                    // The multiplication in the next line has the same exact purpose\n\n                    // as the one above.\n\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n\n                } lt(mc, end) {\n\n                    mc := add(mc, 0x20)\n\n                    cc := add(cc, 0x20)\n\n                } {\n\n                    mstore(mc, mload(cc))\n\n                }\n\n\n\n                mstore(tempBytes, _length)\n\n\n\n                //update free-memory pointer\n\n                //allocating the array padded to 32 bytes like the compiler does now\n\n                mstore(0x40, and(add(mc, 31), not(31)))\n\n            }\n\n            //if we want a zero-length slice let's just return a zero-length array\n\n            default {\n\n                tempBytes := mload(0x40)\n\n\n\n                mstore(0x40, add(tempBytes, 0x20))\n\n            }\n\n        }\n\n\n\n        return tempBytes;\n",
          "message": "Utils.slice (LockProxyPip1.sol#702-766) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 813,
          "vulnerability_to_line": 826,
          "vulnerability_code": "    function isContract(address account) internal view returns (bool) {\n\n        // This method relies in extcodesize, which returns 0 for contracts in\n\n        // construction, since the code is only stored at the end of the\n\n        // constructor execution.\n\n\n\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n\n        // for accounts without code, i.e. `keccak256('')`\n\n        bytes32 codehash;\n\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly { codehash := extcodehash(account) }\n\n        return (codehash != 0x0 && codehash != accountHash);\n",
          "message": "Utils.isContract (LockProxyPip1.sol#813-826) is declared view but contains assembly code\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 1063,
          "vulnerability_to_line": 1089,
          "vulnerability_code": "    function delegateAsset(uint64 nativeChainId, bytes memory nativeLockProxy, bytes memory nativeAssetHash, uint256 delegatedSupply) public {\n\n        require(nativeChainId != 0, \"nativeChainId cannot be zero\");\n\n        require(nativeLockProxy.length != 0, \"empty nativeLockProxy\");\n\n        require(nativeAssetHash.length != 0, \"empty nativeAssetHash\");\n\n\n\n        address assetHash = _msgSender();\n\n        bytes32 key = _getRegistryKey(assetHash, nativeChainId, nativeLockProxy, nativeAssetHash);\n\n\n\n        require(registry[key] != true, \"asset already registered\");\n\n        require(balances[key] == 0, \"balance is not zero\");\n\n        require(_balanceFor(assetHash) == delegatedSupply, \"controlled balance does not match delegatedSupply\");\n\n\n\n        registry[key] = true;\n\n\n\n        RegisterAssetTxArgs memory txArgs = RegisterAssetTxArgs({\n\n            assetHash: Utils.addressToBytes(assetHash),\n\n            nativeAssetHash: nativeAssetHash\n\n        });\n\n\n\n        bytes memory txData = _serializeRegisterAssetTxArgs(txArgs);\n\n\n\n        IEthCrossChainManager eccm = _getEccm();\n\n        require(eccm.crossChain(nativeChainId, nativeLockProxy, \"registerAsset\", txData), \"EthCrossChainManager crossChain executed error!\");\n\n        balances[key] = delegatedSupply;\n\n\n\n        emit DelegateAssetEvent(assetHash, nativeChainId, nativeLockProxy, nativeAssetHash);\n",
          "message": "Reentrancy in LockProxyPip1.delegateAsset (LockProxyPip1.sol#1063-1089):\n\tExternal calls:\n\t- require(bool,string)(_balanceFor(assetHash) == delegatedSupply,controlled balance does not match delegatedSupply) (LockProxyPip1.sol#1073)\n\tState variables written after the call(s):\n\t- registry (LockProxyPip1.sol#1075)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 1063,
          "vulnerability_to_line": 1089,
          "vulnerability_code": "    function delegateAsset(uint64 nativeChainId, bytes memory nativeLockProxy, bytes memory nativeAssetHash, uint256 delegatedSupply) public {\n\n        require(nativeChainId != 0, \"nativeChainId cannot be zero\");\n\n        require(nativeLockProxy.length != 0, \"empty nativeLockProxy\");\n\n        require(nativeAssetHash.length != 0, \"empty nativeAssetHash\");\n\n\n\n        address assetHash = _msgSender();\n\n        bytes32 key = _getRegistryKey(assetHash, nativeChainId, nativeLockProxy, nativeAssetHash);\n\n\n\n        require(registry[key] != true, \"asset already registered\");\n\n        require(balances[key] == 0, \"balance is not zero\");\n\n        require(_balanceFor(assetHash) == delegatedSupply, \"controlled balance does not match delegatedSupply\");\n\n\n\n        registry[key] = true;\n\n\n\n        RegisterAssetTxArgs memory txArgs = RegisterAssetTxArgs({\n\n            assetHash: Utils.addressToBytes(assetHash),\n\n            nativeAssetHash: nativeAssetHash\n\n        });\n\n\n\n        bytes memory txData = _serializeRegisterAssetTxArgs(txArgs);\n\n\n\n        IEthCrossChainManager eccm = _getEccm();\n\n        require(eccm.crossChain(nativeChainId, nativeLockProxy, \"registerAsset\", txData), \"EthCrossChainManager crossChain executed error!\");\n\n        balances[key] = delegatedSupply;\n\n\n\n        emit DelegateAssetEvent(assetHash, nativeChainId, nativeLockProxy, nativeAssetHash);\n",
          "message": "Reentrancy in LockProxyPip1.delegateAsset (LockProxyPip1.sol#1063-1089):\n\tExternal calls:\n\t- require(bool,string)(_balanceFor(assetHash) == delegatedSupply,controlled balance does not match delegatedSupply) (LockProxyPip1.sol#1073)\n\t- eccm = _getEccm() (LockProxyPip1.sol#1084)\n\t- require(bool,string)(eccm.crossChain(nativeChainId,nativeLockProxy,registerAsset,txData),EthCrossChainManager crossChain executed error!) (LockProxyPip1.sol#1085)\n\tState variables written after the call(s):\n\t- balances (LockProxyPip1.sol#1086)\n"
        },
        {
          "name": "uninitialized-local",
          "vulnerability_from_line": 1285,
          "vulnerability_to_line": null,
          "vulnerability_code": "        RegisterAssetTxArgs memory args;\n",
          "message": "args in LockProxyPip1._deserializeRegisterAssetTxArgs (LockProxyPip1.sol#1285) is a local variable never initialiazed\n"
        },
        {
          "name": "uninitialized-local",
          "vulnerability_from_line": 1293,
          "vulnerability_to_line": null,
          "vulnerability_code": "        TxArgs memory args;\n",
          "message": "args in LockProxyPip1._deserializeTxArgs (LockProxyPip1.sol#1293) is a local variable never initialiazed\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 1111,
          "vulnerability_to_line": 1165,
          "vulnerability_code": "    function lock(\n\n        address fromAssetHash,\n\n        uint64 toChainId,\n\n        bytes memory targetProxyHash,\n\n        bytes memory toAssetHash,\n\n        bytes memory toAddress,\n\n        uint256 amount,\n\n        bool deductFeeInLock,\n\n        uint256 feeAmount,\n\n        bytes memory feeAddress\n\n    )\n\n        public\n\n        payable\n\n        returns (bool)\n\n    {\n\n        require(toChainId != 0, \"toChainId cannot be zero\");\n\n        require(targetProxyHash.length != 0, \"empty targetProxyHash\");\n\n        require(toAssetHash.length != 0, \"empty toAssetHash\");\n\n        require(toAddress.length != 0, \"empty toAddress\");\n\n        require(amount != 0, \"amount must be more than zero!\");\n\n\n\n        require(_transferToContract(fromAssetHash, amount), \"transfer asset from fromAddress to lock_proxy contract  failed!\");\n\n\n\n        bytes32 key = _getRegistryKey(fromAssetHash, toChainId, targetProxyHash, toAssetHash);\n\n        require(registry[key] == true, \"asset not registered\");\n\n\n\n        TxArgs memory txArgs = TxArgs({\n\n            fromAssetHash: Utils.addressToBytes(fromAssetHash),\n\n            toAssetHash: toAssetHash,\n\n            toAddress: toAddress,\n\n            amount: amount,\n\n            feeAmount: feeAmount,\n\n            feeAddress: feeAddress\n\n        });\n\n\n\n        if (feeAmount != 0 && deductFeeInLock) {\n\n            require(feeAddress.length != 0, \"empty fee address\");\n\n            uint256 afterFeeAmount = amount.sub(feeAmount);\n\n            require(_transferFromContract(fromAssetHash, Utils.bytesToAddress(feeAddress), feeAmount), \"transfer asset from lock_proxy contract to feeAddress failed!\");\n\n\n\n            // set feeAmount to zero as fee has already been transferred\n\n            txArgs.feeAmount = 0;\n\n            txArgs.amount = afterFeeAmount;\n\n        }\n\n\n\n        bytes memory txData = _serializeTxArgs(txArgs);\n\n        IEthCrossChainManager eccm = _getEccm();\n\n\n\n        require(eccm.crossChain(toChainId, targetProxyHash, \"unlock\", txData), \"EthCrossChainManager crossChain executed error!\");\n\n        balances[key] = balances[key].add(txArgs.amount);\n\n\n\n        emit LockEvent(fromAssetHash, _msgSender(), toChainId, toAssetHash, toAddress, txData);\n\n\n\n        return true;\n",
          "message": "Reentrancy in LockProxyPip1.lock (LockProxyPip1.sol#1111-1165):\n\tExternal calls:\n\t- require(bool,string)(_transferToContract(fromAssetHash,amount),transfer asset from fromAddress to lock_proxy contract  failed!) (LockProxyPip1.sol#1132)\n\t- require(bool,string)(_transferFromContract(fromAssetHash,Utils.bytesToAddress(feeAddress),feeAmount),transfer asset from lock_proxy contract to feeAddress failed!) (LockProxyPip1.sol#1149)\n\t- eccm = _getEccm() (LockProxyPip1.sol#1157)\n\t- require(bool,string)(eccm.crossChain(toChainId,targetProxyHash,unlock,txData),EthCrossChainManager crossChain executed error!) (LockProxyPip1.sol#1159)\n\tExternal calls sending eth:\n\t- require(bool,string)(_transferFromContract(fromAssetHash,Utils.bytesToAddress(feeAddress),feeAmount),transfer asset from lock_proxy contract to feeAddress failed!) (LockProxyPip1.sol#1149)\n\tState variables written after the call(s):\n\t- balances (LockProxyPip1.sol#1160)\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 56,
          "vulnerability_to_line": 72,
          "vulnerability_code": "    function NextBool(bytes memory buff, uint256 offset) internal pure returns(bool, uint256) {\n\n        require(offset + 1 <= buff.length && offset < offset + 1, \"Offset exceeds limit\");\n\n        // byte === bytes1\n\n        byte v;\n\n        assembly{\n\n            v := mload(add(add(buff, 0x20), offset))\n\n        }\n\n        bool value;\n\n        if (v == 0x01) {\n\n\t\t    value = true;\n\n    \t} else if (v == 0x00) {\n\n            value = false;\n\n        } else {\n\n            revert(\"NextBool value error\");\n\n        }\n\n        return (value, offset + 1);\n",
          "message": "ZeroCopySource.NextBool uses assembly (LockProxyPip1.sol#56-72)\n\t- LockProxyPip1.sol#60-62\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 79,
          "vulnerability_to_line": 86,
          "vulnerability_code": "    function NextByte(bytes memory buff, uint256 offset) internal pure returns (byte, uint256) {\n\n        require(offset + 1 <= buff.length && offset < offset + 1, \"NextByte, Offset exceeds maximum\");\n\n        byte v;\n\n        assembly{\n\n            v := mload(add(add(buff, 0x20), offset))\n\n        }\n\n        return (v, offset + 1);\n",
          "message": "ZeroCopySource.NextByte uses assembly (LockProxyPip1.sol#79-86)\n\t- LockProxyPip1.sol#82-84\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 93,
          "vulnerability_to_line": 104,
          "vulnerability_code": "    function NextUint8(bytes memory buff, uint256 offset) internal pure returns (uint8, uint256) {\n\n        require(offset + 1 <= buff.length && offset < offset + 1, \"NextUint8, Offset exceeds maximum\");\n\n        uint8 v;\n\n        assembly{\n\n            let tmpbytes := mload(0x40)\n\n            let bvalue := mload(add(add(buff, 0x20), offset))\n\n            mstore8(tmpbytes, byte(0, bvalue))\n\n            mstore(0x40, add(tmpbytes, 0x01))\n\n            v := mload(sub(tmpbytes, 0x1f))\n\n        }\n\n        return (v, offset + 1);\n",
          "message": "ZeroCopySource.NextUint8 uses assembly (LockProxyPip1.sol#93-104)\n\t- LockProxyPip1.sol#96-102\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 111,
          "vulnerability_to_line": 124,
          "vulnerability_code": "    function NextUint16(bytes memory buff, uint256 offset) internal pure returns (uint16, uint256) {\n\n        require(offset + 2 <= buff.length && offset < offset + 2, \"NextUint16, offset exceeds maximum\");\n\n        \n\n        uint16 v;\n\n        assembly {\n\n            let tmpbytes := mload(0x40)\n\n            let bvalue := mload(add(add(buff, 0x20), offset))\n\n            mstore8(tmpbytes, byte(0x01, bvalue))\n\n            mstore8(add(tmpbytes, 0x01), byte(0, bvalue))\n\n            mstore(0x40, add(tmpbytes, 0x02))\n\n            v := mload(sub(tmpbytes, 0x1e))\n\n        }\n\n        return (v, offset + 2);\n",
          "message": "ZeroCopySource.NextUint16 uses assembly (LockProxyPip1.sol#111-124)\n\t- LockProxyPip1.sol#115-122\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 132,
          "vulnerability_to_line": 152,
          "vulnerability_code": "    function NextUint32(bytes memory buff, uint256 offset) internal pure returns (uint32, uint256) {\n\n        require(offset + 4 <= buff.length && offset < offset + 4, \"NextUint32, offset exceeds maximum\");\n\n        uint32 v;\n\n        assembly {\n\n            let tmpbytes := mload(0x40)\n\n            let byteLen := 0x04\n\n            for {\n\n                let tindex := 0x00\n\n                let bindex := sub(byteLen, 0x01)\n\n                let bvalue := mload(add(add(buff, 0x20), offset))\n\n            } lt(tindex, byteLen) {\n\n                tindex := add(tindex, 0x01)\n\n                bindex := sub(bindex, 0x01)\n\n            }{\n\n                mstore8(add(tmpbytes, tindex), byte(bindex, bvalue))\n\n            }\n\n            mstore(0x40, add(tmpbytes, byteLen))\n\n            v := mload(sub(tmpbytes, sub(0x20, byteLen)))\n\n        }\n\n        return (v, offset + 4);\n",
          "message": "ZeroCopySource.NextUint32 uses assembly (LockProxyPip1.sol#132-152)\n\t- LockProxyPip1.sol#135-150\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 159,
          "vulnerability_to_line": 179,
          "vulnerability_code": "    function NextUint64(bytes memory buff, uint256 offset) internal pure returns (uint64, uint256) {\n\n        require(offset + 8 <= buff.length && offset < offset + 8, \"NextUint64, offset exceeds maximum\");\n\n        uint64 v;\n\n        assembly {\n\n            let tmpbytes := mload(0x40)\n\n            let byteLen := 0x08\n\n            for {\n\n                let tindex := 0x00\n\n                let bindex := sub(byteLen, 0x01)\n\n                let bvalue := mload(add(add(buff, 0x20), offset))\n\n            } lt(tindex, byteLen) {\n\n                tindex := add(tindex, 0x01)\n\n                bindex := sub(bindex, 0x01)\n\n            }{\n\n                mstore8(add(tmpbytes, tindex), byte(bindex, bvalue))\n\n            }\n\n            mstore(0x40, add(tmpbytes, byteLen))\n\n            v := mload(sub(tmpbytes, sub(0x20, byteLen)))\n\n        }\n\n        return (v, offset + 8);\n",
          "message": "ZeroCopySource.NextUint64 uses assembly (LockProxyPip1.sol#159-179)\n\t- LockProxyPip1.sol#162-177\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 187,
          "vulnerability_to_line": 208,
          "vulnerability_code": "    function NextUint255(bytes memory buff, uint256 offset) internal pure returns (uint256, uint256) {\n\n        require(offset + 32 <= buff.length && offset < offset + 32, \"NextUint255, offset exceeds maximum\");\n\n        uint256 v;\n\n        assembly {\n\n            let tmpbytes := mload(0x40)\n\n            let byteLen := 0x20\n\n            for {\n\n                let tindex := 0x00\n\n                let bindex := sub(byteLen, 0x01)\n\n                let bvalue := mload(add(add(buff, 0x20), offset))\n\n            } lt(tindex, byteLen) {\n\n                tindex := add(tindex, 0x01)\n\n                bindex := sub(bindex, 0x01)\n\n            }{\n\n                mstore8(add(tmpbytes, tindex), byte(bindex, bvalue))\n\n            }\n\n            mstore(0x40, add(tmpbytes, byteLen))\n\n            v := mload(tmpbytes)\n\n        }\n\n        require(v <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds the range\");\n\n        return (v, offset + 32);\n",
          "message": "ZeroCopySource.NextUint255 uses assembly (LockProxyPip1.sol#187-208)\n\t- LockProxyPip1.sol#190-205\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 215,
          "vulnerability_to_line": 270,
          "vulnerability_code": "    function NextVarBytes(bytes memory buff, uint256 offset) internal pure returns(bytes memory, uint256) {\n\n        uint len;\n\n        (len, offset) = NextVarUint(buff, offset);\n\n        require(offset + len <= buff.length && offset < offset + len, \"NextVarBytes, offset exceeds maximum\");\n\n        bytes memory tempBytes;\n\n        assembly{\n\n            switch iszero(len)\n\n            case 0 {\n\n                // Get a location of some free memory and store it in tempBytes as\n\n                // Solidity does for memory variables.\n\n                tempBytes := mload(0x40)\n\n\n\n                // The first word of the slice result is potentially a partial\n\n                // word read from the original array. To read it, we calculate\n\n                // the length of that partial word and start copying that many\n\n                // bytes into the array. The first word we copy will start with\n\n                // data we don't care about, but the last `lengthmod` bytes will\n\n                // land at the beginning of the contents of the new array. When\n\n                // we're done copying, we overwrite the full first word with\n\n                // the actual length of the slice.\n\n                let lengthmod := and(len, 31)\n\n\n\n                // The multiplication in the next line is necessary\n\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n\n                // the following copy loop was copying the origin's length\n\n                // and then ending prematurely not copying everything it should.\n\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n\n                let end := add(mc, len)\n\n\n\n                for {\n\n                    // The multiplication in the next line has the same exact purpose\n\n                    // as the one above.\n\n                    let cc := add(add(add(buff, lengthmod), mul(0x20, iszero(lengthmod))), offset)\n\n                } lt(mc, end) {\n\n                    mc := add(mc, 0x20)\n\n                    cc := add(cc, 0x20)\n\n                } {\n\n                    mstore(mc, mload(cc))\n\n                }\n\n\n\n                mstore(tempBytes, len)\n\n\n\n                //update free-memory pointer\n\n                //allocating the array padded to 32 bytes like the compiler does now\n\n                mstore(0x40, and(add(mc, 31), not(31)))\n\n            }\n\n            //if we want a zero-length slice let's just return a zero-length array\n\n            default {\n\n                tempBytes := mload(0x40)\n\n\n\n                mstore(0x40, add(tempBytes, 0x20))\n\n            }\n\n        }\n\n\n\n        return (tempBytes, offset + len);\n",
          "message": "ZeroCopySource.NextVarBytes uses assembly (LockProxyPip1.sol#215-270)\n\t- LockProxyPip1.sol#220-267\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 276,
          "vulnerability_to_line": 283,
          "vulnerability_code": "    function NextHash(bytes memory buff, uint256 offset) internal pure returns (bytes32 , uint256) {\n\n        require(offset + 32 <= buff.length && offset < offset + 32, \"NextHash, offset exceeds maximum\");\n\n        bytes32 v;\n\n        assembly {\n\n            v := mload(add(buff, add(offset, 0x20)))\n\n        }\n\n        return (v, offset + 32);\n",
          "message": "ZeroCopySource.NextHash uses assembly (LockProxyPip1.sol#276-283)\n\t- LockProxyPip1.sol#279-281\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 290,
          "vulnerability_to_line": 297,
          "vulnerability_code": "    function NextBytes20(bytes memory buff, uint256 offset) internal pure returns (bytes20 , uint256) {\n\n        require(offset + 20 <= buff.length && offset < offset + 20, \"NextBytes20, offset exceeds maximum\");\n\n        bytes20 v;\n\n        assembly {\n\n            v := mload(add(buff, add(offset, 0x20)))\n\n        }\n\n        return (v, offset + 20);\n",
          "message": "ZeroCopySource.NextBytes20 uses assembly (LockProxyPip1.sol#290-297)\n\t- LockProxyPip1.sol#293-295\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 351,
          "vulnerability_to_line": 368,
          "vulnerability_code": "    function WriteBool(bool b) internal pure returns (bytes memory) {\n\n        bytes memory buff;\n\n        assembly{\n\n            buff := mload(0x40)\n\n            mstore(buff, 1)\n\n            switch iszero(b)\n\n            case 1 {\n\n                mstore(add(buff, 0x20), shl(248, 0x00))\n\n                // mstore8(add(buff, 0x20), 0x00)\n\n            }\n\n            default {\n\n                mstore(add(buff, 0x20), shl(248, 0x01))\n\n                // mstore8(add(buff, 0x20), 0x01)\n\n            }\n\n            mstore(0x40, add(buff, 0x21))\n\n        }\n\n        return buff;\n",
          "message": "ZeroCopySink.WriteBool uses assembly (LockProxyPip1.sol#351-368)\n\t- LockProxyPip1.sol#353-366\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 382,
          "vulnerability_to_line": 392,
          "vulnerability_code": "    function WriteUint8(uint8 v) internal pure returns (bytes memory) {\n\n        bytes memory buff;\n\n        assembly{\n\n            buff := mload(0x40)\n\n            mstore(buff, 1)\n\n            mstore(add(buff, 0x20), shl(248, v))\n\n            // mstore(add(buff, 0x20), byte(0x1f, v))\n\n            mstore(0x40, add(buff, 0x21))\n\n        }\n\n        return buff;\n",
          "message": "ZeroCopySink.WriteUint8 uses assembly (LockProxyPip1.sol#382-392)\n\t- LockProxyPip1.sol#384-390\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 398,
          "vulnerability_to_line": 417,
          "vulnerability_code": "    function WriteUint16(uint16 v) internal pure returns (bytes memory) {\n\n        bytes memory buff;\n\n\n\n        assembly{\n\n            buff := mload(0x40)\n\n            let byteLen := 0x02\n\n            mstore(buff, byteLen)\n\n            for {\n\n                let mindex := 0x00\n\n                let vindex := 0x1f\n\n            } lt(mindex, byteLen) {\n\n                mindex := add(mindex, 0x01)\n\n                vindex := sub(vindex, 0x01)\n\n            }{\n\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\n\n            }\n\n            mstore(0x40, add(buff, 0x22))\n\n        }\n\n        return buff;\n",
          "message": "ZeroCopySink.WriteUint16 uses assembly (LockProxyPip1.sol#398-417)\n\t- LockProxyPip1.sol#401-415\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 423,
          "vulnerability_to_line": 441,
          "vulnerability_code": "    function WriteUint32(uint32 v) internal pure returns(bytes memory) {\n\n        bytes memory buff;\n\n        assembly{\n\n            buff := mload(0x40)\n\n            let byteLen := 0x04\n\n            mstore(buff, byteLen)\n\n            for {\n\n                let mindex := 0x00\n\n                let vindex := 0x1f\n\n            } lt(mindex, byteLen) {\n\n                mindex := add(mindex, 0x01)\n\n                vindex := sub(vindex, 0x01)\n\n            }{\n\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\n\n            }\n\n            mstore(0x40, add(buff, 0x24))\n\n        }\n\n        return buff;\n",
          "message": "ZeroCopySink.WriteUint32 uses assembly (LockProxyPip1.sol#423-441)\n\t- LockProxyPip1.sol#425-439\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 447,
          "vulnerability_to_line": 466,
          "vulnerability_code": "    function WriteUint64(uint64 v) internal pure returns(bytes memory) {\n\n        bytes memory buff;\n\n\n\n        assembly{\n\n            buff := mload(0x40)\n\n            let byteLen := 0x08\n\n            mstore(buff, byteLen)\n\n            for {\n\n                let mindex := 0x00\n\n                let vindex := 0x1f\n\n            } lt(mindex, byteLen) {\n\n                mindex := add(mindex, 0x01)\n\n                vindex := sub(vindex, 0x01)\n\n            }{\n\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\n\n            }\n\n            mstore(0x40, add(buff, 0x28))\n\n        }\n\n        return buff;\n",
          "message": "ZeroCopySink.WriteUint64 uses assembly (LockProxyPip1.sol#447-466)\n\t- LockProxyPip1.sol#450-464\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 472,
          "vulnerability_to_line": 492,
          "vulnerability_code": "    function WriteUint255(uint256 v) internal pure returns (bytes memory) {\n\n        require(v <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds uint255 range\");\n\n        bytes memory buff;\n\n\n\n        assembly{\n\n            buff := mload(0x40)\n\n            let byteLen := 0x20\n\n            mstore(buff, byteLen)\n\n            for {\n\n                let mindex := 0x00\n\n                let vindex := 0x1f\n\n            } lt(mindex, byteLen) {\n\n                mindex := add(mindex, 0x01)\n\n                vindex := sub(vindex, 0x01)\n\n            }{\n\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\n\n            }\n\n            mstore(0x40, add(buff, 0x40))\n\n        }\n\n        return buff;\n",
          "message": "ZeroCopySink.WriteUint255 uses assembly (LockProxyPip1.sol#472-492)\n\t- LockProxyPip1.sol#476-490\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 527,
          "vulnerability_to_line": 533,
          "vulnerability_code": "    function bytesToBytes32(bytes memory _bs) internal pure returns (bytes32 value) {\n\n        require(_bs.length == 32, \"bytes length is not 32.\");\n\n        assembly {\n\n            // load 32 bytes from memory starting from position _bs + 0x20 since the first 0x20 bytes stores _bs length\n\n            value := mload(add(_bs, 0x20))\n\n        }\n",
          "message": "Utils.bytesToBytes32 uses assembly (LockProxyPip1.sol#527-533)\n\t- LockProxyPip1.sol#529-532\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 539,
          "vulnerability_to_line": 546,
          "vulnerability_code": "    function bytesToUint256(bytes memory _bs) internal pure returns (uint256 value) {\n\n        require(_bs.length == 32, \"bytes length is not 32.\");\n\n        assembly {\n\n            // load 32 bytes from memory starting from position _bs + 32\n\n            value := mload(add(_bs, 0x20))\n\n        }\n\n        require(value <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds the range\");\n",
          "message": "Utils.bytesToUint256 uses assembly (LockProxyPip1.sol#539-546)\n\t- LockProxyPip1.sol#541-544\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 552,
          "vulnerability_to_line": 565,
          "vulnerability_code": "    function uint256ToBytes(uint256 _value) internal pure returns (bytes memory bs) {\n\n        require(_value <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds the range\");\n\n        assembly {\n\n            // Get a location of some free memory and store it in result as\n\n            // Solidity does for memory variables.\n\n            bs := mload(0x40)\n\n            // Put 0x20 at the first word, the length of bytes for uint256 value\n\n            mstore(bs, 0x20)\n\n            //In the next word, put value in bytes format to the next 32 bytes\n\n            mstore(add(bs, 0x20), _value)\n\n            // Update the free-memory pointer by padding our last write location to 32 bytes\n\n            mstore(0x40, add(bs, 0x40))\n\n        }\n",
          "message": "Utils.uint256ToBytes uses assembly (LockProxyPip1.sol#552-565)\n\t- LockProxyPip1.sol#554-564\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 571,
          "vulnerability_to_line": 580,
          "vulnerability_code": "    function bytesToAddress(bytes memory _bs) internal pure returns (address addr)\n\n    {\n\n        require(_bs.length == 20, \"bytes length does not match address\");\n\n        assembly {\n\n            // for _bs, first word store _bs.length, second word store _bs.value\n\n            // load 32 bytes from mem[_bs+20], convert it into Uint160, meaning we take last 20 bytes as addr (address).\n\n            addr := mload(add(_bs, 0x14))\n\n        }\n\n\n",
          "message": "Utils.bytesToAddress uses assembly (LockProxyPip1.sol#571-580)\n\t- LockProxyPip1.sol#574-578\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 586,
          "vulnerability_to_line": 598,
          "vulnerability_code": "    function addressToBytes(address _addr) internal pure returns (bytes memory bs){\n\n        assembly {\n\n            // Get a location of some free memory and store it in result as\n\n            // Solidity does for memory variables.\n\n            bs := mload(0x40)\n\n            // Put 20 (address byte length) at the first word, the length of bytes for uint256 value\n\n            mstore(bs, 0x14)\n\n            // logical shift left _a by 12 bytes, change _a from right-aligned to left-aligned\n\n            mstore(add(bs, 0x20), shl(96, _addr))\n\n            // Update the free-memory pointer by padding our last write location to 32 bytes\n\n            mstore(0x40, add(bs, 0x40))\n\n       }\n",
          "message": "Utils.addressToBytes uses assembly (LockProxyPip1.sol#586-598)\n\t- LockProxyPip1.sol#587-597\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 623,
          "vulnerability_to_line": 693,
          "vulnerability_code": "    function equalStorage(bytes storage _preBytes, bytes memory _postBytes) internal view returns (bool) {\n\n        bool success = true;\n\n\n\n        assembly {\n\n            // we know _preBytes_offset is 0\n\n            let fslot := sload(_preBytes_slot)\n\n            // Arrays of 31 bytes or less have an even value in their slot,\n\n            // while longer arrays have an odd value. The actual length is\n\n            // the slot divided by two for odd values, and the lowest order\n\n            // byte divided by two for even values.\n\n            // If the slot is even, bitwise and the slot with 255 and divide by\n\n            // two to get the length. If the slot is odd, bitwise and the slot\n\n            // with -1 and divide by two.\n\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n\n            let mlength := mload(_postBytes)\n\n\n\n            // if lengths don't match the arrays are not equal\n\n            switch eq(slength, mlength)\n\n            case 1 {\n\n                // fslot can contain both the length and contents of the array\n\n                // if slength < 32 bytes so let's prepare for that\n\n                // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n\n                // slength != 0\n\n                if iszero(iszero(slength)) {\n\n                    switch lt(slength, 32)\n\n                    case 1 {\n\n                        // blank the last byte which is the length\n\n                        fslot := mul(div(fslot, 0x100), 0x100)\n\n\n\n                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\n\n                            // unsuccess:\n\n                            success := 0\n\n                        }\n\n                    }\n\n                    default {\n\n                        // cb is a circuit breaker in the for loop since there's\n\n                        //  no said feature for inline assembly loops\n\n                        // cb = 1 - don't breaker\n\n                        // cb = 0 - break\n\n                        let cb := 1\n\n\n\n                        // get the keccak hash to get the contents of the array\n\n                        mstore(0x0, _preBytes_slot)\n\n                        let sc := keccak256(0x0, 0x20)\n\n\n\n                        let mc := add(_postBytes, 0x20)\n\n                        let end := add(mc, mlength)\n\n\n\n                        // the next line is the loop condition:\n\n                        // while(uint(mc < end) + cb == 2)\n\n                        for {} eq(add(lt(mc, end), cb), 2) {\n\n                            sc := add(sc, 1)\n\n                            mc := add(mc, 0x20)\n\n                        } {\n\n                            if iszero(eq(sload(sc), mload(mc))) {\n\n                                // unsuccess:\n\n                                success := 0\n\n                                cb := 0\n\n                            }\n\n                        }\n\n                    }\n\n                }\n\n            }\n\n            default {\n\n                // unsuccess:\n\n                success := 0\n\n            }\n\n        }\n\n\n\n        return success;\n",
          "message": "Utils.equalStorage uses assembly (LockProxyPip1.sol#623-693)\n\t- LockProxyPip1.sol#626-690\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 702,
          "vulnerability_to_line": 766,
          "vulnerability_code": "    function slice(\n\n        bytes memory _bytes,\n\n        uint _start,\n\n        uint _length\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        require(_bytes.length >= (_start + _length));\n\n\n\n        bytes memory tempBytes;\n\n\n\n        assembly {\n\n            switch iszero(_length)\n\n            case 0 {\n\n                // Get a location of some free memory and store it in tempBytes as\n\n                // Solidity does for memory variables.\n\n                tempBytes := mload(0x40)\n\n\n\n                // The first word of the slice result is potentially a partial\n\n                // word read from the original array. To read it, we calculate\n\n                // the length of that partial word and start copying that many\n\n                // bytes into the array. The first word we copy will start with\n\n                // data we don't care about, but the last `lengthmod` bytes will\n\n                // land at the beginning of the contents of the new array. When\n\n                // we're done copying, we overwrite the full first word with\n\n                // the actual length of the slice.\n\n                // lengthmod <= _length % 32\n\n                let lengthmod := and(_length, 31)\n\n\n\n                // The multiplication in the next line is necessary\n\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n\n                // the following copy loop was copying the origin's length\n\n                // and then ending prematurely not copying everything it should.\n\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n\n                let end := add(mc, _length)\n\n\n\n                for {\n\n                    // The multiplication in the next line has the same exact purpose\n\n                    // as the one above.\n\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n\n                } lt(mc, end) {\n\n                    mc := add(mc, 0x20)\n\n                    cc := add(cc, 0x20)\n\n                } {\n\n                    mstore(mc, mload(cc))\n\n                }\n\n\n\n                mstore(tempBytes, _length)\n\n\n\n                //update free-memory pointer\n\n                //allocating the array padded to 32 bytes like the compiler does now\n\n                mstore(0x40, and(add(mc, 31), not(31)))\n\n            }\n\n            //if we want a zero-length slice let's just return a zero-length array\n\n            default {\n\n                tempBytes := mload(0x40)\n\n\n\n                mstore(0x40, add(tempBytes, 0x20))\n\n            }\n\n        }\n\n\n\n        return tempBytes;\n",
          "message": "Utils.slice uses assembly (LockProxyPip1.sol#702-766)\n\t- LockProxyPip1.sol#715-763\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 813,
          "vulnerability_to_line": 826,
          "vulnerability_code": "    function isContract(address account) internal view returns (bool) {\n\n        // This method relies in extcodesize, which returns 0 for contracts in\n\n        // construction, since the code is only stored at the end of the\n\n        // constructor execution.\n\n\n\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n\n        // for accounts without code, i.e. `keccak256('')`\n\n        bytes32 codehash;\n\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly { codehash := extcodehash(account) }\n\n        return (codehash != 0x0 && codehash != accountHash);\n",
          "message": "Utils.isContract uses assembly (LockProxyPip1.sol#813-826)\n\t- LockProxyPip1.sol#824\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 1063,
          "vulnerability_to_line": 1089,
          "vulnerability_code": "    function delegateAsset(uint64 nativeChainId, bytes memory nativeLockProxy, bytes memory nativeAssetHash, uint256 delegatedSupply) public {\n\n        require(nativeChainId != 0, \"nativeChainId cannot be zero\");\n\n        require(nativeLockProxy.length != 0, \"empty nativeLockProxy\");\n\n        require(nativeAssetHash.length != 0, \"empty nativeAssetHash\");\n\n\n\n        address assetHash = _msgSender();\n\n        bytes32 key = _getRegistryKey(assetHash, nativeChainId, nativeLockProxy, nativeAssetHash);\n\n\n\n        require(registry[key] != true, \"asset already registered\");\n\n        require(balances[key] == 0, \"balance is not zero\");\n\n        require(_balanceFor(assetHash) == delegatedSupply, \"controlled balance does not match delegatedSupply\");\n\n\n\n        registry[key] = true;\n\n\n\n        RegisterAssetTxArgs memory txArgs = RegisterAssetTxArgs({\n\n            assetHash: Utils.addressToBytes(assetHash),\n\n            nativeAssetHash: nativeAssetHash\n\n        });\n\n\n\n        bytes memory txData = _serializeRegisterAssetTxArgs(txArgs);\n\n\n\n        IEthCrossChainManager eccm = _getEccm();\n\n        require(eccm.crossChain(nativeChainId, nativeLockProxy, \"registerAsset\", txData), \"EthCrossChainManager crossChain executed error!\");\n\n        balances[key] = delegatedSupply;\n\n\n\n        emit DelegateAssetEvent(assetHash, nativeChainId, nativeLockProxy, nativeAssetHash);\n",
          "message": "LockProxyPip1.delegateAsset (LockProxyPip1.sol#1063-1089) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 1091,
          "vulnerability_to_line": 1100,
          "vulnerability_code": "    function registerAsset(bytes memory argsBs, bytes memory fromContractAddr, uint64 fromChainId) onlyManagerContract public returns (bool) {\n\n        RegisterAssetTxArgs memory args = _deserializeRegisterAssetTxArgs(argsBs);\n\n\n\n        bytes32 key = _getRegistryKey(Utils.bytesToAddress(args.nativeAssetHash), fromChainId, fromContractAddr, args.assetHash);\n\n\n\n        require(registry[key] != true, \"asset already registerd\");\n\n        registry[key] = true;\n\n\n\n        return true;\n",
          "message": "LockProxyPip1.registerAsset (LockProxyPip1.sol#1091-1100) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 1111,
          "vulnerability_to_line": 1165,
          "vulnerability_code": "    function lock(\n\n        address fromAssetHash,\n\n        uint64 toChainId,\n\n        bytes memory targetProxyHash,\n\n        bytes memory toAssetHash,\n\n        bytes memory toAddress,\n\n        uint256 amount,\n\n        bool deductFeeInLock,\n\n        uint256 feeAmount,\n\n        bytes memory feeAddress\n\n    )\n\n        public\n\n        payable\n\n        returns (bool)\n\n    {\n\n        require(toChainId != 0, \"toChainId cannot be zero\");\n\n        require(targetProxyHash.length != 0, \"empty targetProxyHash\");\n\n        require(toAssetHash.length != 0, \"empty toAssetHash\");\n\n        require(toAddress.length != 0, \"empty toAddress\");\n\n        require(amount != 0, \"amount must be more than zero!\");\n\n\n\n        require(_transferToContract(fromAssetHash, amount), \"transfer asset from fromAddress to lock_proxy contract  failed!\");\n\n\n\n        bytes32 key = _getRegistryKey(fromAssetHash, toChainId, targetProxyHash, toAssetHash);\n\n        require(registry[key] == true, \"asset not registered\");\n\n\n\n        TxArgs memory txArgs = TxArgs({\n\n            fromAssetHash: Utils.addressToBytes(fromAssetHash),\n\n            toAssetHash: toAssetHash,\n\n            toAddress: toAddress,\n\n            amount: amount,\n\n            feeAmount: feeAmount,\n\n            feeAddress: feeAddress\n\n        });\n\n\n\n        if (feeAmount != 0 && deductFeeInLock) {\n\n            require(feeAddress.length != 0, \"empty fee address\");\n\n            uint256 afterFeeAmount = amount.sub(feeAmount);\n\n            require(_transferFromContract(fromAssetHash, Utils.bytesToAddress(feeAddress), feeAmount), \"transfer asset from lock_proxy contract to feeAddress failed!\");\n\n\n\n            // set feeAmount to zero as fee has already been transferred\n\n            txArgs.feeAmount = 0;\n\n            txArgs.amount = afterFeeAmount;\n\n        }\n\n\n\n        bytes memory txData = _serializeTxArgs(txArgs);\n\n        IEthCrossChainManager eccm = _getEccm();\n\n\n\n        require(eccm.crossChain(toChainId, targetProxyHash, \"unlock\", txData), \"EthCrossChainManager crossChain executed error!\");\n\n        balances[key] = balances[key].add(txArgs.amount);\n\n\n\n        emit LockEvent(fromAssetHash, _msgSender(), toChainId, toAssetHash, toAddress, txData);\n\n\n\n        return true;\n",
          "message": "LockProxyPip1.lock (LockProxyPip1.sol#1111-1165) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 1175,
          "vulnerability_to_line": 1201,
          "vulnerability_code": "    function unlock(bytes memory argsBs, bytes memory fromContractAddr, uint64 fromChainId) onlyManagerContract public returns (bool) {\n\n        TxArgs memory args = _deserializeTxArgs(argsBs);\n\n        address toAssetHash = Utils.bytesToAddress(args.toAssetHash);\n\n        address toAddress = Utils.bytesToAddress(args.toAddress);\n\n\n\n        bytes32 key = _getRegistryKey(toAssetHash, fromChainId, fromContractAddr, args.fromAssetHash);\n\n\n\n        require(registry[key] == true, \"asset not registered\");\n\n        require(balances[key] >= args.amount, \"insufficient balance in registry\");\n\n\n\n        balances[key] = balances[key].sub(args.amount);\n\n\n\n        uint256 afterFeeAmount = args.amount;\n\n        if (args.feeAmount != 0) {\n\n            afterFeeAmount = args.amount.sub(args.feeAmount);\n\n            address feeAddress = Utils.bytesToAddress(args.feeAddress);\n\n\n\n            // transfer feeAmount to feeAddress\n\n            require(_transferFromContract(toAssetHash, feeAddress, args.feeAmount), \"transfer asset from lock_proxy contract to feeAddress failed!\");\n\n            emit UnlockEvent(toAssetHash, feeAddress, args.feeAmount);\n\n        }\n\n\n\n        require(_transferFromContract(toAssetHash, toAddress, afterFeeAmount), \"transfer asset from lock_proxy contract to toAddress failed!\");\n\n\n\n        emit UnlockEvent(toAssetHash, toAddress, args.amount);\n\n        return true;\n",
          "message": "LockProxyPip1.unlock (LockProxyPip1.sol#1175-1201) should be declared external\n"
        },
        {
          "name": "solc-version",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.0;\n",
          "message": "Detected issues with version pragma in LockProxyPip1.sol:\n\t- pragma solidity^0.5.0 (LockProxyPip1.sol#3): it allows old versions\n\t- pragma solidity^0.5.0 (LockProxyPip1.sol#34): it allows old versions\n\t- pragma solidity^0.5.0 (LockProxyPip1.sol#330): it allows old versions\n\t- pragma solidity^0.5.0 (LockProxyPip1.sol#518): it allows old versions\n\t- pragma solidity^0.5.0 (LockProxyPip1.sol#831): it allows old versions\n\t- pragma solidity^0.5.0 (LockProxyPip1.sol#990): it allows old versions\n\t- pragma solidity^0.5.0 (LockProxyPip1.sol#1001): it allows old versions\n\t- pragma solidity^0.5.0 (LockProxyPip1.sol#1012): it allows old versions\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 22,
          "vulnerability_to_line": 24,
          "vulnerability_code": "    function _msgSender() internal view returns (address payable) {\n\n        return msg.sender;\n",
          "message": "Function 'Context._msgSender' (LockProxyPip1.sol#22-24) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 26,
          "vulnerability_to_line": 29,
          "vulnerability_code": "    function _msgData() internal view returns (bytes memory) {\n\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n\n        return msg.data;\n",
          "message": "Function 'Context._msgData' (LockProxyPip1.sol#26-29) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 56,
          "vulnerability_to_line": 72,
          "vulnerability_code": "    function NextBool(bytes memory buff, uint256 offset) internal pure returns(bool, uint256) {\n\n        require(offset + 1 <= buff.length && offset < offset + 1, \"Offset exceeds limit\");\n\n        // byte === bytes1\n\n        byte v;\n\n        assembly{\n\n            v := mload(add(add(buff, 0x20), offset))\n\n        }\n\n        bool value;\n\n        if (v == 0x01) {\n\n\t\t    value = true;\n\n    \t} else if (v == 0x00) {\n\n            value = false;\n\n        } else {\n\n            revert(\"NextBool value error\");\n\n        }\n\n        return (value, offset + 1);\n",
          "message": "Function 'ZeroCopySource.NextBool' (LockProxyPip1.sol#56-72) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 79,
          "vulnerability_to_line": 86,
          "vulnerability_code": "    function NextByte(bytes memory buff, uint256 offset) internal pure returns (byte, uint256) {\n\n        require(offset + 1 <= buff.length && offset < offset + 1, \"NextByte, Offset exceeds maximum\");\n\n        byte v;\n\n        assembly{\n\n            v := mload(add(add(buff, 0x20), offset))\n\n        }\n\n        return (v, offset + 1);\n",
          "message": "Function 'ZeroCopySource.NextByte' (LockProxyPip1.sol#79-86) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 93,
          "vulnerability_to_line": 104,
          "vulnerability_code": "    function NextUint8(bytes memory buff, uint256 offset) internal pure returns (uint8, uint256) {\n\n        require(offset + 1 <= buff.length && offset < offset + 1, \"NextUint8, Offset exceeds maximum\");\n\n        uint8 v;\n\n        assembly{\n\n            let tmpbytes := mload(0x40)\n\n            let bvalue := mload(add(add(buff, 0x20), offset))\n\n            mstore8(tmpbytes, byte(0, bvalue))\n\n            mstore(0x40, add(tmpbytes, 0x01))\n\n            v := mload(sub(tmpbytes, 0x1f))\n\n        }\n\n        return (v, offset + 1);\n",
          "message": "Function 'ZeroCopySource.NextUint8' (LockProxyPip1.sol#93-104) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 111,
          "vulnerability_to_line": 124,
          "vulnerability_code": "    function NextUint16(bytes memory buff, uint256 offset) internal pure returns (uint16, uint256) {\n\n        require(offset + 2 <= buff.length && offset < offset + 2, \"NextUint16, offset exceeds maximum\");\n\n        \n\n        uint16 v;\n\n        assembly {\n\n            let tmpbytes := mload(0x40)\n\n            let bvalue := mload(add(add(buff, 0x20), offset))\n\n            mstore8(tmpbytes, byte(0x01, bvalue))\n\n            mstore8(add(tmpbytes, 0x01), byte(0, bvalue))\n\n            mstore(0x40, add(tmpbytes, 0x02))\n\n            v := mload(sub(tmpbytes, 0x1e))\n\n        }\n\n        return (v, offset + 2);\n",
          "message": "Function 'ZeroCopySource.NextUint16' (LockProxyPip1.sol#111-124) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 132,
          "vulnerability_to_line": 152,
          "vulnerability_code": "    function NextUint32(bytes memory buff, uint256 offset) internal pure returns (uint32, uint256) {\n\n        require(offset + 4 <= buff.length && offset < offset + 4, \"NextUint32, offset exceeds maximum\");\n\n        uint32 v;\n\n        assembly {\n\n            let tmpbytes := mload(0x40)\n\n            let byteLen := 0x04\n\n            for {\n\n                let tindex := 0x00\n\n                let bindex := sub(byteLen, 0x01)\n\n                let bvalue := mload(add(add(buff, 0x20), offset))\n\n            } lt(tindex, byteLen) {\n\n                tindex := add(tindex, 0x01)\n\n                bindex := sub(bindex, 0x01)\n\n            }{\n\n                mstore8(add(tmpbytes, tindex), byte(bindex, bvalue))\n\n            }\n\n            mstore(0x40, add(tmpbytes, byteLen))\n\n            v := mload(sub(tmpbytes, sub(0x20, byteLen)))\n\n        }\n\n        return (v, offset + 4);\n",
          "message": "Function 'ZeroCopySource.NextUint32' (LockProxyPip1.sol#132-152) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 159,
          "vulnerability_to_line": 179,
          "vulnerability_code": "    function NextUint64(bytes memory buff, uint256 offset) internal pure returns (uint64, uint256) {\n\n        require(offset + 8 <= buff.length && offset < offset + 8, \"NextUint64, offset exceeds maximum\");\n\n        uint64 v;\n\n        assembly {\n\n            let tmpbytes := mload(0x40)\n\n            let byteLen := 0x08\n\n            for {\n\n                let tindex := 0x00\n\n                let bindex := sub(byteLen, 0x01)\n\n                let bvalue := mload(add(add(buff, 0x20), offset))\n\n            } lt(tindex, byteLen) {\n\n                tindex := add(tindex, 0x01)\n\n                bindex := sub(bindex, 0x01)\n\n            }{\n\n                mstore8(add(tmpbytes, tindex), byte(bindex, bvalue))\n\n            }\n\n            mstore(0x40, add(tmpbytes, byteLen))\n\n            v := mload(sub(tmpbytes, sub(0x20, byteLen)))\n\n        }\n\n        return (v, offset + 8);\n",
          "message": "Function 'ZeroCopySource.NextUint64' (LockProxyPip1.sol#159-179) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 187,
          "vulnerability_to_line": 208,
          "vulnerability_code": "    function NextUint255(bytes memory buff, uint256 offset) internal pure returns (uint256, uint256) {\n\n        require(offset + 32 <= buff.length && offset < offset + 32, \"NextUint255, offset exceeds maximum\");\n\n        uint256 v;\n\n        assembly {\n\n            let tmpbytes := mload(0x40)\n\n            let byteLen := 0x20\n\n            for {\n\n                let tindex := 0x00\n\n                let bindex := sub(byteLen, 0x01)\n\n                let bvalue := mload(add(add(buff, 0x20), offset))\n\n            } lt(tindex, byteLen) {\n\n                tindex := add(tindex, 0x01)\n\n                bindex := sub(bindex, 0x01)\n\n            }{\n\n                mstore8(add(tmpbytes, tindex), byte(bindex, bvalue))\n\n            }\n\n            mstore(0x40, add(tmpbytes, byteLen))\n\n            v := mload(tmpbytes)\n\n        }\n\n        require(v <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds the range\");\n\n        return (v, offset + 32);\n",
          "message": "Function 'ZeroCopySource.NextUint255' (LockProxyPip1.sol#187-208) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 215,
          "vulnerability_to_line": 270,
          "vulnerability_code": "    function NextVarBytes(bytes memory buff, uint256 offset) internal pure returns(bytes memory, uint256) {\n\n        uint len;\n\n        (len, offset) = NextVarUint(buff, offset);\n\n        require(offset + len <= buff.length && offset < offset + len, \"NextVarBytes, offset exceeds maximum\");\n\n        bytes memory tempBytes;\n\n        assembly{\n\n            switch iszero(len)\n\n            case 0 {\n\n                // Get a location of some free memory and store it in tempBytes as\n\n                // Solidity does for memory variables.\n\n                tempBytes := mload(0x40)\n\n\n\n                // The first word of the slice result is potentially a partial\n\n                // word read from the original array. To read it, we calculate\n\n                // the length of that partial word and start copying that many\n\n                // bytes into the array. The first word we copy will start with\n\n                // data we don't care about, but the last `lengthmod` bytes will\n\n                // land at the beginning of the contents of the new array. When\n\n                // we're done copying, we overwrite the full first word with\n\n                // the actual length of the slice.\n\n                let lengthmod := and(len, 31)\n\n\n\n                // The multiplication in the next line is necessary\n\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n\n                // the following copy loop was copying the origin's length\n\n                // and then ending prematurely not copying everything it should.\n\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n\n                let end := add(mc, len)\n\n\n\n                for {\n\n                    // The multiplication in the next line has the same exact purpose\n\n                    // as the one above.\n\n                    let cc := add(add(add(buff, lengthmod), mul(0x20, iszero(lengthmod))), offset)\n\n                } lt(mc, end) {\n\n                    mc := add(mc, 0x20)\n\n                    cc := add(cc, 0x20)\n\n                } {\n\n                    mstore(mc, mload(cc))\n\n                }\n\n\n\n                mstore(tempBytes, len)\n\n\n\n                //update free-memory pointer\n\n                //allocating the array padded to 32 bytes like the compiler does now\n\n                mstore(0x40, and(add(mc, 31), not(31)))\n\n            }\n\n            //if we want a zero-length slice let's just return a zero-length array\n\n            default {\n\n                tempBytes := mload(0x40)\n\n\n\n                mstore(0x40, add(tempBytes, 0x20))\n\n            }\n\n        }\n\n\n\n        return (tempBytes, offset + len);\n",
          "message": "Function 'ZeroCopySource.NextVarBytes' (LockProxyPip1.sol#215-270) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 276,
          "vulnerability_to_line": 283,
          "vulnerability_code": "    function NextHash(bytes memory buff, uint256 offset) internal pure returns (bytes32 , uint256) {\n\n        require(offset + 32 <= buff.length && offset < offset + 32, \"NextHash, offset exceeds maximum\");\n\n        bytes32 v;\n\n        assembly {\n\n            v := mload(add(buff, add(offset, 0x20)))\n\n        }\n\n        return (v, offset + 32);\n",
          "message": "Function 'ZeroCopySource.NextHash' (LockProxyPip1.sol#276-283) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 290,
          "vulnerability_to_line": 297,
          "vulnerability_code": "    function NextBytes20(bytes memory buff, uint256 offset) internal pure returns (bytes20 , uint256) {\n\n        require(offset + 20 <= buff.length && offset < offset + 20, \"NextBytes20, offset exceeds maximum\");\n\n        bytes20 v;\n\n        assembly {\n\n            v := mload(add(buff, add(offset, 0x20)))\n\n        }\n\n        return (v, offset + 20);\n",
          "message": "Function 'ZeroCopySource.NextBytes20' (LockProxyPip1.sol#290-297) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 299,
          "vulnerability_to_line": 325,
          "vulnerability_code": "    function NextVarUint(bytes memory buff, uint256 offset) internal pure returns(uint, uint256) {\n\n        byte v;\n\n        (v, offset) = NextByte(buff, offset);\n\n\n\n        uint value;\n\n        if (v == 0xFD) {\n\n            // return NextUint16(buff, offset);\n\n            (value, offset) = NextUint16(buff, offset);\n\n            require(value >= 0xFD && value <= 0xFFFF, \"NextUint16, value outside range\");\n\n            return (value, offset);\n\n        } else if (v == 0xFE) {\n\n            // return NextUint32(buff, offset);\n\n            (value, offset) = NextUint32(buff, offset);\n\n            require(value > 0xFFFF && value <= 0xFFFFFFFF, \"NextVarUint, value outside range\");\n\n            return (value, offset);\n\n        } else if (v == 0xFF) {\n\n            // return NextUint64(buff, offset);\n\n            (value, offset) = NextUint64(buff, offset);\n\n            require(value > 0xFFFFFFFF, \"NextVarUint, value outside range\");\n\n            return (value, offset);\n\n        } else{\n\n            // return (uint8(v), offset);\n\n            value = uint8(v);\n\n            require(value < 0xFD, \"NextVarUint, value outside range\");\n\n            return (value, offset);\n\n        }\n",
          "message": "Function 'ZeroCopySource.NextVarUint' (LockProxyPip1.sol#299-325) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 351,
          "vulnerability_to_line": 368,
          "vulnerability_code": "    function WriteBool(bool b) internal pure returns (bytes memory) {\n\n        bytes memory buff;\n\n        assembly{\n\n            buff := mload(0x40)\n\n            mstore(buff, 1)\n\n            switch iszero(b)\n\n            case 1 {\n\n                mstore(add(buff, 0x20), shl(248, 0x00))\n\n                // mstore8(add(buff, 0x20), 0x00)\n\n            }\n\n            default {\n\n                mstore(add(buff, 0x20), shl(248, 0x01))\n\n                // mstore8(add(buff, 0x20), 0x01)\n\n            }\n\n            mstore(0x40, add(buff, 0x21))\n\n        }\n\n        return buff;\n",
          "message": "Function 'ZeroCopySink.WriteBool' (LockProxyPip1.sol#351-368) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 374,
          "vulnerability_to_line": 376,
          "vulnerability_code": "    function WriteByte(byte b) internal pure returns (bytes memory) {\n\n        return WriteUint8(uint8(b));\n",
          "message": "Function 'ZeroCopySink.WriteByte' (LockProxyPip1.sol#374-376) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 382,
          "vulnerability_to_line": 392,
          "vulnerability_code": "    function WriteUint8(uint8 v) internal pure returns (bytes memory) {\n\n        bytes memory buff;\n\n        assembly{\n\n            buff := mload(0x40)\n\n            mstore(buff, 1)\n\n            mstore(add(buff, 0x20), shl(248, v))\n\n            // mstore(add(buff, 0x20), byte(0x1f, v))\n\n            mstore(0x40, add(buff, 0x21))\n\n        }\n\n        return buff;\n",
          "message": "Function 'ZeroCopySink.WriteUint8' (LockProxyPip1.sol#382-392) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 398,
          "vulnerability_to_line": 417,
          "vulnerability_code": "    function WriteUint16(uint16 v) internal pure returns (bytes memory) {\n\n        bytes memory buff;\n\n\n\n        assembly{\n\n            buff := mload(0x40)\n\n            let byteLen := 0x02\n\n            mstore(buff, byteLen)\n\n            for {\n\n                let mindex := 0x00\n\n                let vindex := 0x1f\n\n            } lt(mindex, byteLen) {\n\n                mindex := add(mindex, 0x01)\n\n                vindex := sub(vindex, 0x01)\n\n            }{\n\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\n\n            }\n\n            mstore(0x40, add(buff, 0x22))\n\n        }\n\n        return buff;\n",
          "message": "Function 'ZeroCopySink.WriteUint16' (LockProxyPip1.sol#398-417) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 423,
          "vulnerability_to_line": 441,
          "vulnerability_code": "    function WriteUint32(uint32 v) internal pure returns(bytes memory) {\n\n        bytes memory buff;\n\n        assembly{\n\n            buff := mload(0x40)\n\n            let byteLen := 0x04\n\n            mstore(buff, byteLen)\n\n            for {\n\n                let mindex := 0x00\n\n                let vindex := 0x1f\n\n            } lt(mindex, byteLen) {\n\n                mindex := add(mindex, 0x01)\n\n                vindex := sub(vindex, 0x01)\n\n            }{\n\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\n\n            }\n\n            mstore(0x40, add(buff, 0x24))\n\n        }\n\n        return buff;\n",
          "message": "Function 'ZeroCopySink.WriteUint32' (LockProxyPip1.sol#423-441) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 447,
          "vulnerability_to_line": 466,
          "vulnerability_code": "    function WriteUint64(uint64 v) internal pure returns(bytes memory) {\n\n        bytes memory buff;\n\n\n\n        assembly{\n\n            buff := mload(0x40)\n\n            let byteLen := 0x08\n\n            mstore(buff, byteLen)\n\n            for {\n\n                let mindex := 0x00\n\n                let vindex := 0x1f\n\n            } lt(mindex, byteLen) {\n\n                mindex := add(mindex, 0x01)\n\n                vindex := sub(vindex, 0x01)\n\n            }{\n\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\n\n            }\n\n            mstore(0x40, add(buff, 0x28))\n\n        }\n\n        return buff;\n",
          "message": "Function 'ZeroCopySink.WriteUint64' (LockProxyPip1.sol#447-466) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 472,
          "vulnerability_to_line": 492,
          "vulnerability_code": "    function WriteUint255(uint256 v) internal pure returns (bytes memory) {\n\n        require(v <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds uint255 range\");\n\n        bytes memory buff;\n\n\n\n        assembly{\n\n            buff := mload(0x40)\n\n            let byteLen := 0x20\n\n            mstore(buff, byteLen)\n\n            for {\n\n                let mindex := 0x00\n\n                let vindex := 0x1f\n\n            } lt(mindex, byteLen) {\n\n                mindex := add(mindex, 0x01)\n\n                vindex := sub(vindex, 0x01)\n\n            }{\n\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\n\n            }\n\n            mstore(0x40, add(buff, 0x40))\n\n        }\n\n        return buff;\n",
          "message": "Function 'ZeroCopySink.WriteUint255' (LockProxyPip1.sol#472-492) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 498,
          "vulnerability_to_line": 501,
          "vulnerability_code": "    function WriteVarBytes(bytes memory data) internal pure returns (bytes memory) {\n\n        uint64 l = uint64(data.length);\n\n        return abi.encodePacked(WriteVarUint(l), data);\n",
          "message": "Function 'ZeroCopySink.WriteVarBytes' (LockProxyPip1.sol#498-501) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 503,
          "vulnerability_to_line": 513,
          "vulnerability_code": "    function WriteVarUint(uint64 v) internal pure returns (bytes memory) {\n\n        if (v < 0xFD){\n\n    \t\treturn WriteUint8(uint8(v));\n\n    \t} else if (v <= 0xFFFF) {\n\n    \t\treturn abi.encodePacked(WriteByte(0xFD), WriteUint16(uint16(v)));\n\n    \t} else if (v <= 0xFFFFFFFF) {\n\n            return abi.encodePacked(WriteByte(0xFE), WriteUint32(uint32(v)));\n\n    \t} else {\n\n    \t\treturn abi.encodePacked(WriteByte(0xFF), WriteUint64(uint64(v)));\n\n    \t}\n",
          "message": "Function 'ZeroCopySink.WriteVarUint' (LockProxyPip1.sol#503-513) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 527,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function bytesToBytes32(bytes memory _bs) internal pure returns (bytes32 value) {\n",
          "message": "Parameter '_bs' of Utils.bytesToBytes32 (LockProxyPip1.sol#527) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 539,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function bytesToUint256(bytes memory _bs) internal pure returns (uint256 value) {\n",
          "message": "Parameter '_bs' of Utils.bytesToUint256 (LockProxyPip1.sol#539) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 552,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function uint256ToBytes(uint256 _value) internal pure returns (bytes memory bs) {\n",
          "message": "Parameter '_value' of Utils.uint256ToBytes (LockProxyPip1.sol#552) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 571,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function bytesToAddress(bytes memory _bs) internal pure returns (address addr)\n",
          "message": "Parameter '_bs' of Utils.bytesToAddress (LockProxyPip1.sol#571) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 604,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function hashLeaf(bytes memory _data) internal pure returns (bytes32 result)  {\n",
          "message": "Parameter '_data' of Utils.hashLeaf (LockProxyPip1.sol#604) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 613,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function hashChildren(bytes32 _l, bytes32  _r) internal pure returns (bytes32 result)  {\n",
          "message": "Parameter '_l' of Utils.hashChildren (LockProxyPip1.sol#613) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 613,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function hashChildren(bytes32 _l, bytes32  _r) internal pure returns (bytes32 result)  {\n",
          "message": "Parameter '_r' of Utils.hashChildren (LockProxyPip1.sol#613) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 703,
          "vulnerability_to_line": null,
          "vulnerability_code": "        bytes memory _bytes,\n",
          "message": "Parameter '_bytes' of Utils.slice (LockProxyPip1.sol#703) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 704,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint _start,\n",
          "message": "Parameter '_start' of Utils.slice (LockProxyPip1.sol#704) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 705,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint _length\n",
          "message": "Parameter '_length' of Utils.slice (LockProxyPip1.sol#705) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 773,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function containMAddresses(address[] memory _keepers, address[] memory _signers, uint _m) internal pure returns (bool){\n",
          "message": "Parameter '_keepers' of Utils.containMAddresses (LockProxyPip1.sol#773) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 773,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function containMAddresses(address[] memory _keepers, address[] memory _signers, uint _m) internal pure returns (bool){\n",
          "message": "Parameter '_signers' of Utils.containMAddresses (LockProxyPip1.sol#773) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 773,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function containMAddresses(address[] memory _keepers, address[] memory _signers, uint _m) internal pure returns (bool){\n",
          "message": "Parameter '_m' of Utils.containMAddresses (LockProxyPip1.sol#773) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1203,
          "vulnerability_to_line": 1212,
          "vulnerability_code": "    function _balanceFor(address fromAssetHash) public view returns (uint256) {\n\n        if (fromAssetHash == address(0)) {\n\n            // return address(this).balance; // this expression would result in error: Failed to decode output: Error: insufficient data for uint256 type\n\n            address selfAddr = address(this);\n\n            return selfAddr.balance;\n\n        } else {\n\n            ERC20Interface erc20Token = ERC20Interface(fromAssetHash);\n\n            return erc20Token.balanceOf(address(this));\n\n        }\n",
          "message": "Function 'LockProxyPip1._balanceFor' (LockProxyPip1.sol#1203-1212) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1213,
          "vulnerability_to_line": 1218,
          "vulnerability_code": "    function _getEccm() internal view returns (IEthCrossChainManager) {\n\n      IEthCrossChainManagerProxy eccmp = IEthCrossChainManagerProxy(managerProxyContract);\n\n      address eccmAddr = eccmp.getEthCrossChainManager();\n\n      IEthCrossChainManager eccm = IEthCrossChainManager(eccmAddr);\n\n      return eccm;\n",
          "message": "Function 'LockProxyPip1._getEccm' (LockProxyPip1.sol#1213-1218) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1219,
          "vulnerability_to_line": 1226,
          "vulnerability_code": "    function _getRegistryKey(address assetHash, uint64 nativeChainId, bytes memory nativeLockProxy, bytes memory nativeAssetHash) internal pure returns (bytes32) {\n\n        return keccak256(abi.encodePacked(\n\n            assetHash,\n\n            nativeChainId,\n\n            nativeLockProxy,\n\n            nativeAssetHash\n\n        ));\n",
          "message": "Function 'LockProxyPip1._getRegistryKey' (LockProxyPip1.sol#1219-1226) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1227,
          "vulnerability_to_line": 1237,
          "vulnerability_code": "    function _transferToContract(address fromAssetHash, uint256 amount) internal returns (bool) {\n\n        if (fromAssetHash == address(0)) {\n\n            // fromAssetHash === address(0) denotes user choose to lock ether\n\n            // passively check if the received msg.value equals amount\n\n            require(msg.value == amount, \"transferred ether is not equal to amount!\");\n\n        } else {\n\n            // actively transfer amount of asset from msg.sender to lock_proxy contract\n\n            require(_transferERC20ToContract(fromAssetHash, _msgSender(), address(this), amount), \"transfer erc20 asset to lock_proxy contract failed!\");\n\n        }\n\n        return true;\n",
          "message": "Function 'LockProxyPip1._transferToContract' (LockProxyPip1.sol#1227-1237) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1238,
          "vulnerability_to_line": 1248,
          "vulnerability_code": "    function _transferFromContract(address toAssetHash, address toAddress, uint256 amount) internal returns (bool) {\n\n        if (toAssetHash == address(0x0000000000000000000000000000000000000000)) {\n\n            // toAssetHash === address(0) denotes contract needs to unlock ether to toAddress\n\n            // convert toAddress from 'address' type to 'address payable' type, then actively transfer ether\n\n            address(uint160(toAddress)).transfer(amount);\n\n        } else {\n\n            // actively transfer amount of asset from msg.sender to lock_proxy contract\n\n            require(_transferERC20FromContract(toAssetHash, toAddress, amount), \"transfer erc20 asset to lock_proxy contract failed!\");\n\n        }\n\n        return true;\n",
          "message": "Function 'LockProxyPip1._transferFromContract' (LockProxyPip1.sol#1238-1248) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1251,
          "vulnerability_to_line": 1255,
          "vulnerability_code": "    function _transferERC20ToContract(address fromAssetHash, address fromAddress, address toAddress, uint256 amount) internal returns (bool) {\n\n         ERC20Interface erc20Token = ERC20Interface(fromAssetHash);\n\n         require(erc20Token.transferFrom(fromAddress, toAddress, amount), \"trasnfer ERC20 Token failed!\");\n\n         return true;\n",
          "message": "Function 'LockProxyPip1._transferERC20ToContract' (LockProxyPip1.sol#1251-1255) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1256,
          "vulnerability_to_line": 1260,
          "vulnerability_code": "    function _transferERC20FromContract(address toAssetHash, address toAddress, uint256 amount) internal returns (bool) {\n\n         ERC20Interface erc20Token = ERC20Interface(toAssetHash);\n\n         require(erc20Token.transfer(toAddress, amount), \"trasnfer ERC20 Token failed!\");\n\n         return true;\n",
          "message": "Function 'LockProxyPip1._transferERC20FromContract' (LockProxyPip1.sol#1256-1260) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1262,
          "vulnerability_to_line": 1273,
          "vulnerability_code": "    function _serializeTxArgs(TxArgs memory args) internal pure returns (bytes memory) {\n\n        bytes memory buff;\n\n        buff = abi.encodePacked(\n\n            ZeroCopySink.WriteVarBytes(args.fromAssetHash),\n\n            ZeroCopySink.WriteVarBytes(args.toAssetHash),\n\n            ZeroCopySink.WriteVarBytes(args.toAddress),\n\n            ZeroCopySink.WriteUint255(args.amount),\n\n            ZeroCopySink.WriteUint255(args.feeAmount),\n\n            ZeroCopySink.WriteVarBytes(args.feeAddress)\n\n        );\n\n        return buff;\n",
          "message": "Function 'LockProxyPip1._serializeTxArgs' (LockProxyPip1.sol#1262-1273) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1275,
          "vulnerability_to_line": 1282,
          "vulnerability_code": "    function _serializeRegisterAssetTxArgs(RegisterAssetTxArgs memory args) internal pure returns (bytes memory) {\n\n        bytes memory buff;\n\n        buff = abi.encodePacked(\n\n            ZeroCopySink.WriteVarBytes(args.assetHash),\n\n            ZeroCopySink.WriteVarBytes(args.nativeAssetHash)\n\n        );\n\n        return buff;\n",
          "message": "Function 'LockProxyPip1._serializeRegisterAssetTxArgs' (LockProxyPip1.sol#1275-1282) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1284,
          "vulnerability_to_line": 1290,
          "vulnerability_code": "    function _deserializeRegisterAssetTxArgs(bytes memory valueBs) internal pure returns (RegisterAssetTxArgs memory) {\n\n        RegisterAssetTxArgs memory args;\n\n        uint256 off = 0;\n\n        (args.assetHash, off) = ZeroCopySource.NextVarBytes(valueBs, off);\n\n        (args.nativeAssetHash, off) = ZeroCopySource.NextVarBytes(valueBs, off);\n\n        return args;\n",
          "message": "Function 'LockProxyPip1._deserializeRegisterAssetTxArgs' (LockProxyPip1.sol#1284-1290) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1292,
          "vulnerability_to_line": 1302,
          "vulnerability_code": "    function _deserializeTxArgs(bytes memory valueBs) internal pure returns (TxArgs memory) {\n\n        TxArgs memory args;\n\n        uint256 off = 0;\n\n        (args.fromAssetHash, off) = ZeroCopySource.NextVarBytes(valueBs, off);\n\n        (args.toAssetHash, off) = ZeroCopySource.NextVarBytes(valueBs, off);\n\n        (args.toAddress, off) = ZeroCopySource.NextVarBytes(valueBs, off);\n\n        (args.amount, off) = ZeroCopySource.NextUint255(valueBs, off);\n\n        (args.feeAmount, off) = ZeroCopySource.NextUint255(valueBs, off);\n\n        (args.feeAddress, off) = ZeroCopySource.NextVarBytes(valueBs, off);\n\n        return args;\n",
          "message": "Function 'LockProxyPip1._deserializeTxArgs' (LockProxyPip1.sol#1292-1302) is not in mixedCase\n"
        }
      ]
    },
    "smartcheck": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 1239,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (toAssetHash == address(0x0000000000000000000000000000000000000000)) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 64,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (v == 0x01) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 66,
          "vulnerability_to_line": null,
          "vulnerability_code": "    \t} else if (v == 0x00) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 304,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (v == 0xFD) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 307,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(value >= 0xFD && value <= 0xFFFF, \"NextUint16, value outside range\");\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 307,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(value >= 0xFD && value <= 0xFFFF, \"NextUint16, value outside range\");\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 309,
          "vulnerability_to_line": null,
          "vulnerability_code": "        } else if (v == 0xFE) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 312,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(value > 0xFFFF && value <= 0xFFFFFFFF, \"NextVarUint, value outside range\");\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 312,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(value > 0xFFFF && value <= 0xFFFFFFFF, \"NextVarUint, value outside range\");\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 314,
          "vulnerability_to_line": null,
          "vulnerability_code": "        } else if (v == 0xFF) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 317,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(value > 0xFFFFFFFF, \"NextVarUint, value outside range\");\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 322,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(value < 0xFD, \"NextVarUint, value outside range\");\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 504,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (v < 0xFD){\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 506,
          "vulnerability_to_line": null,
          "vulnerability_code": "    \t} else if (v <= 0xFFFF) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 507,
          "vulnerability_to_line": null,
          "vulnerability_code": "    \t\treturn abi.encodePacked(WriteByte(0xFD), WriteUint16(uint16(v)));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 508,
          "vulnerability_to_line": null,
          "vulnerability_code": "    \t} else if (v <= 0xFFFFFFFF) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 509,
          "vulnerability_to_line": null,
          "vulnerability_code": "            return abi.encodePacked(WriteByte(0xFE), WriteUint32(uint32(v)));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 511,
          "vulnerability_to_line": null,
          "vulnerability_code": "    \t\treturn abi.encodePacked(WriteByte(0xFF), WriteUint64(uint64(v)));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 614,
          "vulnerability_to_line": null,
          "vulnerability_code": "        result = sha256(abi.encodePacked(bytes1(0x01), _l, _r));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 794,
          "vulnerability_to_line": null,
          "vulnerability_code": "             newkey[2] = byte(0x02);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 796,
          "vulnerability_to_line": null,
          "vulnerability_code": "             newkey[2] = byte(0x03);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 605,
          "vulnerability_to_line": null,
          "vulnerability_code": "        result = sha256(abi.encodePacked(byte(0x0), _data));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 775,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(uint i = 0; i < _signers.length; i++){\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 776,
          "vulnerability_to_line": null,
          "vulnerability_code": "            for (uint j = 0; j < _keepers.length; j++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
          "vulnerability_from_line": 527,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function bytesToBytes32(bytes memory _bs) internal pure returns (bytes32 value) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
          "vulnerability_from_line": 552,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function uint256ToBytes(uint256 _value) internal pure returns (bytes memory bs) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
          "vulnerability_from_line": 571,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function bytesToAddress(bytes memory _bs) internal pure returns (address addr)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
          "vulnerability_from_line": 586,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function addressToBytes(address _addr) internal pure returns (bytes memory bs){\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 775,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(uint i = 0; i < _signers.length; i++){\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 776,
          "vulnerability_to_line": null,
          "vulnerability_code": "            for (uint j = 0; j < _keepers.length; j++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 34,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 330,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 518,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 831,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 990,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 1001,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 1012,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_REVERT_REQUIRE",
          "vulnerability_from_line": 66,
          "vulnerability_to_line": null,
          "vulnerability_code": "    \t} else if (v == 0x00) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SAFEMATH",
          "vulnerability_from_line": 1027,
          "vulnerability_to_line": null,
          "vulnerability_code": "    using SafeMath for uint;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 56,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function NextBool(bytes memory buff, uint256 offset) internal pure returns(bool, uint256) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 79,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function NextByte(bytes memory buff, uint256 offset) internal pure returns (byte, uint256) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 93,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function NextUint8(bytes memory buff, uint256 offset) internal pure returns (uint8, uint256) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 111,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function NextUint16(bytes memory buff, uint256 offset) internal pure returns (uint16, uint256) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 132,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function NextUint32(bytes memory buff, uint256 offset) internal pure returns (uint32, uint256) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 159,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function NextUint64(bytes memory buff, uint256 offset) internal pure returns (uint64, uint256) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 187,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function NextUint255(bytes memory buff, uint256 offset) internal pure returns (uint256, uint256) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 215,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function NextVarBytes(bytes memory buff, uint256 offset) internal pure returns(bytes memory, uint256) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 276,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function NextHash(bytes memory buff, uint256 offset) internal pure returns (bytes32 , uint256) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 290,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function NextBytes20(bytes memory buff, uint256 offset) internal pure returns (bytes20 , uint256) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 351,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function WriteBool(bool b) internal pure returns (bytes memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 382,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function WriteUint8(uint8 v) internal pure returns (bytes memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 398,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function WriteUint16(uint16 v) internal pure returns (bytes memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 423,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function WriteUint32(uint32 v) internal pure returns(bytes memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 447,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function WriteUint64(uint64 v) internal pure returns(bytes memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 472,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function WriteUint255(uint256 v) internal pure returns (bytes memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 527,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function bytesToBytes32(bytes memory _bs) internal pure returns (bytes32 value) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 539,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function bytesToUint256(bytes memory _bs) internal pure returns (uint256 value) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 552,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function uint256ToBytes(uint256 _value) internal pure returns (bytes memory bs) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 571,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function bytesToAddress(bytes memory _bs) internal pure returns (address addr)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 586,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function addressToBytes(address _addr) internal pure returns (bytes memory bs){\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 702,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function slice(\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
          "vulnerability_from_line": 623,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function equalStorage(bytes storage _preBytes, bytes memory _postBytes) internal view returns (bool) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
          "vulnerability_from_line": 813,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function isContract(address account) internal view returns (bool) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 56,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function NextBool(bytes memory buff, uint256 offset) internal pure returns(bool, uint256) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 79,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function NextByte(bytes memory buff, uint256 offset) internal pure returns (byte, uint256) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 93,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function NextUint8(bytes memory buff, uint256 offset) internal pure returns (uint8, uint256) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 111,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function NextUint16(bytes memory buff, uint256 offset) internal pure returns (uint16, uint256) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 132,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function NextUint32(bytes memory buff, uint256 offset) internal pure returns (uint32, uint256) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 159,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function NextUint64(bytes memory buff, uint256 offset) internal pure returns (uint64, uint256) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 187,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function NextUint255(bytes memory buff, uint256 offset) internal pure returns (uint256, uint256) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 215,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function NextVarBytes(bytes memory buff, uint256 offset) internal pure returns(bytes memory, uint256) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 276,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function NextHash(bytes memory buff, uint256 offset) internal pure returns (bytes32 , uint256) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 290,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function NextBytes20(bytes memory buff, uint256 offset) internal pure returns (bytes20 , uint256) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 299,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function NextVarUint(bytes memory buff, uint256 offset) internal pure returns(uint, uint256) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 60,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly{\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 82,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly{\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 96,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly{\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 115,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 135,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 162,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 190,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 220,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly{\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 279,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 293,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 353,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly{\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 384,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly{\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 401,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly{\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 425,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly{\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 450,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly{\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 476,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly{\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 529,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 541,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 554,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 574,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 587,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 626,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 715,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 824,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly { codehash := extcodehash(account) }\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 996,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function crossChain(uint64 _toChainId, bytes calldata _toContract, bytes calldata _method, bytes calldata _txData) external returns (bool);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 996,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function crossChain(uint64 _toChainId, bytes calldata _toContract, bytes calldata _method, bytes calldata _txData) external returns (bool);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 996,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function crossChain(uint64 _toChainId, bytes calldata _toContract, bytes calldata _method, bytes calldata _txData) external returns (bool);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 996,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function crossChain(uint64 _toChainId, bytes calldata _toContract, bytes calldata _method, bytes calldata _txData) external returns (bool);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 996,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function crossChain(uint64 _toChainId, bytes calldata _toContract, bytes calldata _method, bytes calldata _txData) external returns (bool);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 996,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function crossChain(uint64 _toChainId, bytes calldata _toContract, bytes calldata _method, bytes calldata _txData) external returns (bool);\n",
          "message": null
        }
      ]
    },
    "oyente": {
      "successfull_analysis": false,
      "errors": [
        "exception (RuntimeError: Source map error, unknown name(SHR) or instr_name(INVALID))"
      ],
      "vulnerability_findings": []
    },
    "mythril": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": []
    },
    "osiris": {
      "successfull_analysis": false,
      "errors": [
        "Solidity compilation failed"
      ],
      "vulnerability_findings": []
    }
  }
}