{
  "smartbugs_completed": true,
  "analyzer_results": {
    "semgrep": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 744,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(uint i = 0; i < _signers.length; i++){\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 745,
          "vulnerability_to_line": null,
          "vulnerability_code": "            for (uint j = 0; j < _keepers.length; j++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 744,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(uint i = 0; i < _signers.length; i++){\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 745,
          "vulnerability_to_line": null,
          "vulnerability_code": "            for (uint j = 0; j < _keepers.length; j++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 1014,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < size; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 1041,
          "vulnerability_to_line": null,
          "vulnerability_code": "         for(uint i = 0; i < _keyLen; i++){\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 1080,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(uint j = 0; j  < sigCount; j++){\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 1097,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(uint i = 0; i < keeperLen; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 1113,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(uint i = 0; i < keeperLen; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 26,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(offset + 1 <= buff.length && offset < offset + 1, \"Offset exceeds limit\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 38,
          "vulnerability_to_line": null,
          "vulnerability_code": "            revert(\"NextBool value error\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 49,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(offset + 1 <= buff.length && offset < offset + 1, \"NextByte, Offset exceeds maximum\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 63,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(offset + 1 <= buff.length && offset < offset + 1, \"NextUint8, Offset exceeds maximum\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 81,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(offset + 2 <= buff.length && offset < offset + 2, \"NextUint16, offset exceeds maximum\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 102,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(offset + 4 <= buff.length && offset < offset + 4, \"NextUint32, offset exceeds maximum\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 129,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(offset + 8 <= buff.length && offset < offset + 8, \"NextUint64, offset exceeds maximum\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 157,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(offset + 32 <= buff.length && offset < offset + 32, \"NextUint255, offset exceeds maximum\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 175,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(v <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds the range\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 187,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(offset + len <= buff.length && offset < offset + len, \"NextVarBytes, offset exceeds maximum\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 246,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(offset + 32 <= buff.length && offset < offset + 32, \"NextHash, offset exceeds maximum\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 260,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(offset + 20 <= buff.length && offset < offset + 20, \"NextBytes20, offset exceeds maximum\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 276,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(value >= 0xFD && value <= 0xFFFF, \"NextUint16, value outside range\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 281,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(value > 0xFFFF && value <= 0xFFFFFFFF, \"NextVarUint, value outside range\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 286,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(value > 0xFFFFFFFF, \"NextVarUint, value outside range\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 291,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(value < 0xFD, \"NextVarUint, value outside range\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 442,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(v <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds uint255 range\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 497,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_bs.length == 32, \"bytes length is not 32.\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 509,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_bs.length == 32, \"bytes length is not 32.\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 514,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(value <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds the range\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 522,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_value <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds the range\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 542,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_bs.length == 20, \"bytes length does not match address\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 760,
          "vulnerability_to_line": null,
          "vulnerability_code": "         require(key.length >= 67, \"key lenggh is too short\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 827,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(c >= a, \"SafeMath: addition overflow\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 881,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(c / a == b, \"SafeMath: multiplication overflow\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1022,
          "vulnerability_to_line": null,
          "vulnerability_code": "                revert(\"merkleProve, NextByte for position info failed\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1025,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(hash == _root, \"merkleProve, expect root is not equal actual root\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1059,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_pubKeyList.length % POLYCHAIN_PUBKEY_LEN == 0, \"_pubKeyList length illegal!\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1061,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(n >= 1, \"too short _pubKeyList!\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 26,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(offset + 1 <= buff.length && offset < offset + 1, \"Offset exceeds limit\");\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 49,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(offset + 1 <= buff.length && offset < offset + 1, \"NextByte, Offset exceeds maximum\");\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 63,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(offset + 1 <= buff.length && offset < offset + 1, \"NextUint8, Offset exceeds maximum\");\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 81,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(offset + 2 <= buff.length && offset < offset + 2, \"NextUint16, offset exceeds maximum\");\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 102,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(offset + 4 <= buff.length && offset < offset + 4, \"NextUint32, offset exceeds maximum\");\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 129,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(offset + 8 <= buff.length && offset < offset + 8, \"NextUint64, offset exceeds maximum\");\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 157,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(offset + 32 <= buff.length && offset < offset + 32, \"NextUint255, offset exceeds maximum\");\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 187,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(offset + len <= buff.length && offset < offset + len, \"NextVarBytes, offset exceeds maximum\");\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 246,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(offset + 32 <= buff.length && offset < offset + 32, \"NextHash, offset exceeds maximum\");\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 260,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(offset + 20 <= buff.length && offset < offset + 20, \"NextBytes20, offset exceeds maximum\");\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 276,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(value >= 0xFD && value <= 0xFFFF, \"NextUint16, value outside range\");\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 281,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(value > 0xFFFF && value <= 0xFFFFFFFF, \"NextVarUint, value outside range\");\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 744,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(uint i = 0; i < _signers.length; i++){\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 745,
          "vulnerability_to_line": null,
          "vulnerability_code": "            for (uint j = 0; j < _keepers.length; j++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 747,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    m++;\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 1014,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < size; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 1041,
          "vulnerability_to_line": null,
          "vulnerability_code": "         for(uint i = 0; i < _keyLen; i++){\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 1080,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(uint j = 0; j  < sigCount; j++){\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 1097,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(uint i = 0; i < keeperLen; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 1113,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(uint i = 0; i < keeperLen; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 63,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(offset + 1 <= buff.length && offset < offset + 1, \"NextUint8, Offset exceeds maximum\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 81,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(offset + 2 <= buff.length && offset < offset + 2, \"NextUint16, offset exceeds maximum\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 102,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(offset + 4 <= buff.length && offset < offset + 4, \"NextUint32, offset exceeds maximum\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 129,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(offset + 8 <= buff.length && offset < offset + 8, \"NextUint64, offset exceeds maximum\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 157,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(offset + 32 <= buff.length && offset < offset + 32, \"NextUint255, offset exceeds maximum\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 187,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(offset + len <= buff.length && offset < offset + len, \"NextVarBytes, offset exceeds maximum\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 260,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(offset + 20 <= buff.length && offset < offset + 20, \"NextBytes20, offset exceeds maximum\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 542,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_bs.length == 20, \"bytes length does not match address\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 881,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(c / a == b, \"SafeMath: multiplication overflow\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 1022,
          "vulnerability_to_line": null,
          "vulnerability_code": "                revert(\"merkleProve, NextByte for position info failed\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 1025,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(hash == _root, \"merkleProve, expect root is not equal actual root\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        }
      ]
    },
    "slither": {
      "successfull_analysis": true,
      "errors": [
        "EXIT_CODE_98"
      ],
      "vulnerability_findings": [
        {
          "name": "constant-function",
          "vulnerability_from_line": 25,
          "vulnerability_to_line": 41,
          "vulnerability_code": "    function NextBool(bytes memory buff, uint256 offset) internal pure returns(bool, uint256) {\n\n        require(offset + 1 <= buff.length && offset < offset + 1, \"Offset exceeds limit\");\n\n        // byte === bytes1\n\n        byte v;\n\n        assembly{\n\n            v := mload(add(add(buff, 0x20), offset))\n\n        }\n\n        bool value;\n\n        if (v == 0x01) {\n\n\t\t    value = true;\n\n    \t} else if (v == 0x00) {\n\n            value = false;\n\n        } else {\n\n            revert(\"NextBool value error\");\n\n        }\n\n        return (value, offset + 1);\n",
          "message": "ZeroCopySource.NextBool (EthCrossChainUtils.sol#25-41) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 48,
          "vulnerability_to_line": 55,
          "vulnerability_code": "    function NextByte(bytes memory buff, uint256 offset) internal pure returns (byte, uint256) {\n\n        require(offset + 1 <= buff.length && offset < offset + 1, \"NextByte, Offset exceeds maximum\");\n\n        byte v;\n\n        assembly{\n\n            v := mload(add(add(buff, 0x20), offset))\n\n        }\n\n        return (v, offset + 1);\n",
          "message": "ZeroCopySource.NextByte (EthCrossChainUtils.sol#48-55) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 62,
          "vulnerability_to_line": 73,
          "vulnerability_code": "    function NextUint8(bytes memory buff, uint256 offset) internal pure returns (uint8, uint256) {\n\n        require(offset + 1 <= buff.length && offset < offset + 1, \"NextUint8, Offset exceeds maximum\");\n\n        uint8 v;\n\n        assembly{\n\n            let tmpbytes := mload(0x40)\n\n            let bvalue := mload(add(add(buff, 0x20), offset))\n\n            mstore8(tmpbytes, byte(0, bvalue))\n\n            mstore(0x40, add(tmpbytes, 0x01))\n\n            v := mload(sub(tmpbytes, 0x1f))\n\n        }\n\n        return (v, offset + 1);\n",
          "message": "ZeroCopySource.NextUint8 (EthCrossChainUtils.sol#62-73) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 80,
          "vulnerability_to_line": 93,
          "vulnerability_code": "    function NextUint16(bytes memory buff, uint256 offset) internal pure returns (uint16, uint256) {\n\n        require(offset + 2 <= buff.length && offset < offset + 2, \"NextUint16, offset exceeds maximum\");\n\n        \n\n        uint16 v;\n\n        assembly {\n\n            let tmpbytes := mload(0x40)\n\n            let bvalue := mload(add(add(buff, 0x20), offset))\n\n            mstore8(tmpbytes, byte(0x01, bvalue))\n\n            mstore8(add(tmpbytes, 0x01), byte(0, bvalue))\n\n            mstore(0x40, add(tmpbytes, 0x02))\n\n            v := mload(sub(tmpbytes, 0x1e))\n\n        }\n\n        return (v, offset + 2);\n",
          "message": "ZeroCopySource.NextUint16 (EthCrossChainUtils.sol#80-93) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 101,
          "vulnerability_to_line": 121,
          "vulnerability_code": "    function NextUint32(bytes memory buff, uint256 offset) internal pure returns (uint32, uint256) {\n\n        require(offset + 4 <= buff.length && offset < offset + 4, \"NextUint32, offset exceeds maximum\");\n\n        uint32 v;\n\n        assembly {\n\n            let tmpbytes := mload(0x40)\n\n            let byteLen := 0x04\n\n            for {\n\n                let tindex := 0x00\n\n                let bindex := sub(byteLen, 0x01)\n\n                let bvalue := mload(add(add(buff, 0x20), offset))\n\n            } lt(tindex, byteLen) {\n\n                tindex := add(tindex, 0x01)\n\n                bindex := sub(bindex, 0x01)\n\n            }{\n\n                mstore8(add(tmpbytes, tindex), byte(bindex, bvalue))\n\n            }\n\n            mstore(0x40, add(tmpbytes, byteLen))\n\n            v := mload(sub(tmpbytes, sub(0x20, byteLen)))\n\n        }\n\n        return (v, offset + 4);\n",
          "message": "ZeroCopySource.NextUint32 (EthCrossChainUtils.sol#101-121) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 128,
          "vulnerability_to_line": 148,
          "vulnerability_code": "    function NextUint64(bytes memory buff, uint256 offset) internal pure returns (uint64, uint256) {\n\n        require(offset + 8 <= buff.length && offset < offset + 8, \"NextUint64, offset exceeds maximum\");\n\n        uint64 v;\n\n        assembly {\n\n            let tmpbytes := mload(0x40)\n\n            let byteLen := 0x08\n\n            for {\n\n                let tindex := 0x00\n\n                let bindex := sub(byteLen, 0x01)\n\n                let bvalue := mload(add(add(buff, 0x20), offset))\n\n            } lt(tindex, byteLen) {\n\n                tindex := add(tindex, 0x01)\n\n                bindex := sub(bindex, 0x01)\n\n            }{\n\n                mstore8(add(tmpbytes, tindex), byte(bindex, bvalue))\n\n            }\n\n            mstore(0x40, add(tmpbytes, byteLen))\n\n            v := mload(sub(tmpbytes, sub(0x20, byteLen)))\n\n        }\n\n        return (v, offset + 8);\n",
          "message": "ZeroCopySource.NextUint64 (EthCrossChainUtils.sol#128-148) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 156,
          "vulnerability_to_line": 177,
          "vulnerability_code": "    function NextUint255(bytes memory buff, uint256 offset) internal pure returns (uint256, uint256) {\n\n        require(offset + 32 <= buff.length && offset < offset + 32, \"NextUint255, offset exceeds maximum\");\n\n        uint256 v;\n\n        assembly {\n\n            let tmpbytes := mload(0x40)\n\n            let byteLen := 0x20\n\n            for {\n\n                let tindex := 0x00\n\n                let bindex := sub(byteLen, 0x01)\n\n                let bvalue := mload(add(add(buff, 0x20), offset))\n\n            } lt(tindex, byteLen) {\n\n                tindex := add(tindex, 0x01)\n\n                bindex := sub(bindex, 0x01)\n\n            }{\n\n                mstore8(add(tmpbytes, tindex), byte(bindex, bvalue))\n\n            }\n\n            mstore(0x40, add(tmpbytes, byteLen))\n\n            v := mload(tmpbytes)\n\n        }\n\n        require(v <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds the range\");\n\n        return (v, offset + 32);\n",
          "message": "ZeroCopySource.NextUint255 (EthCrossChainUtils.sol#156-177) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 184,
          "vulnerability_to_line": 239,
          "vulnerability_code": "    function NextVarBytes(bytes memory buff, uint256 offset) internal pure returns(bytes memory, uint256) {\n\n        uint len;\n\n        (len, offset) = NextVarUint(buff, offset);\n\n        require(offset + len <= buff.length && offset < offset + len, \"NextVarBytes, offset exceeds maximum\");\n\n        bytes memory tempBytes;\n\n        assembly{\n\n            switch iszero(len)\n\n            case 0 {\n\n                // Get a location of some free memory and store it in tempBytes as\n\n                // Solidity does for memory variables.\n\n                tempBytes := mload(0x40)\n\n\n\n                // The first word of the slice result is potentially a partial\n\n                // word read from the original array. To read it, we calculate\n\n                // the length of that partial word and start copying that many\n\n                // bytes into the array. The first word we copy will start with\n\n                // data we don't care about, but the last `lengthmod` bytes will\n\n                // land at the beginning of the contents of the new array. When\n\n                // we're done copying, we overwrite the full first word with\n\n                // the actual length of the slice.\n\n                let lengthmod := and(len, 31)\n\n\n\n                // The multiplication in the next line is necessary\n\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n\n                // the following copy loop was copying the origin's length\n\n                // and then ending prematurely not copying everything it should.\n\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n\n                let end := add(mc, len)\n\n\n\n                for {\n\n                    // The multiplication in the next line has the same exact purpose\n\n                    // as the one above.\n\n                    let cc := add(add(add(buff, lengthmod), mul(0x20, iszero(lengthmod))), offset)\n\n                } lt(mc, end) {\n\n                    mc := add(mc, 0x20)\n\n                    cc := add(cc, 0x20)\n\n                } {\n\n                    mstore(mc, mload(cc))\n\n                }\n\n\n\n                mstore(tempBytes, len)\n\n\n\n                //update free-memory pointer\n\n                //allocating the array padded to 32 bytes like the compiler does now\n\n                mstore(0x40, and(add(mc, 31), not(31)))\n\n            }\n\n            //if we want a zero-length slice let's just return a zero-length array\n\n            default {\n\n                tempBytes := mload(0x40)\n\n\n\n                mstore(0x40, add(tempBytes, 0x20))\n\n            }\n\n        }\n\n\n\n        return (tempBytes, offset + len);\n",
          "message": "ZeroCopySource.NextVarBytes (EthCrossChainUtils.sol#184-239) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 245,
          "vulnerability_to_line": 252,
          "vulnerability_code": "    function NextHash(bytes memory buff, uint256 offset) internal pure returns (bytes32 , uint256) {\n\n        require(offset + 32 <= buff.length && offset < offset + 32, \"NextHash, offset exceeds maximum\");\n\n        bytes32 v;\n\n        assembly {\n\n            v := mload(add(buff, add(offset, 0x20)))\n\n        }\n\n        return (v, offset + 32);\n",
          "message": "ZeroCopySource.NextHash (EthCrossChainUtils.sol#245-252) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 259,
          "vulnerability_to_line": 266,
          "vulnerability_code": "    function NextBytes20(bytes memory buff, uint256 offset) internal pure returns (bytes20 , uint256) {\n\n        require(offset + 20 <= buff.length && offset < offset + 20, \"NextBytes20, offset exceeds maximum\");\n\n        bytes20 v;\n\n        assembly {\n\n            v := mload(add(buff, add(offset, 0x20)))\n\n        }\n\n        return (v, offset + 20);\n",
          "message": "ZeroCopySource.NextBytes20 (EthCrossChainUtils.sol#259-266) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 320,
          "vulnerability_to_line": 337,
          "vulnerability_code": "    function WriteBool(bool b) internal pure returns (bytes memory) {\n\n        bytes memory buff;\n\n        assembly{\n\n            buff := mload(0x40)\n\n            mstore(buff, 1)\n\n            switch iszero(b)\n\n            case 1 {\n\n                mstore(add(buff, 0x20), shl(248, 0x00))\n\n                // mstore8(add(buff, 0x20), 0x00)\n\n            }\n\n            default {\n\n                mstore(add(buff, 0x20), shl(248, 0x01))\n\n                // mstore8(add(buff, 0x20), 0x01)\n\n            }\n\n            mstore(0x40, add(buff, 0x21))\n\n        }\n\n        return buff;\n",
          "message": "ZeroCopySink.WriteBool (EthCrossChainUtils.sol#320-337) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 351,
          "vulnerability_to_line": 361,
          "vulnerability_code": "    function WriteUint8(uint8 v) internal pure returns (bytes memory) {\n\n        bytes memory buff;\n\n        assembly{\n\n            buff := mload(0x40)\n\n            mstore(buff, 1)\n\n            mstore(add(buff, 0x20), shl(248, v))\n\n            // mstore(add(buff, 0x20), byte(0x1f, v))\n\n            mstore(0x40, add(buff, 0x21))\n\n        }\n\n        return buff;\n",
          "message": "ZeroCopySink.WriteUint8 (EthCrossChainUtils.sol#351-361) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 367,
          "vulnerability_to_line": 386,
          "vulnerability_code": "    function WriteUint16(uint16 v) internal pure returns (bytes memory) {\n\n        bytes memory buff;\n\n\n\n        assembly{\n\n            buff := mload(0x40)\n\n            let byteLen := 0x02\n\n            mstore(buff, byteLen)\n\n            for {\n\n                let mindex := 0x00\n\n                let vindex := 0x1f\n\n            } lt(mindex, byteLen) {\n\n                mindex := add(mindex, 0x01)\n\n                vindex := sub(vindex, 0x01)\n\n            }{\n\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\n\n            }\n\n            mstore(0x40, add(buff, 0x22))\n\n        }\n\n        return buff;\n",
          "message": "ZeroCopySink.WriteUint16 (EthCrossChainUtils.sol#367-386) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 392,
          "vulnerability_to_line": 410,
          "vulnerability_code": "    function WriteUint32(uint32 v) internal pure returns(bytes memory) {\n\n        bytes memory buff;\n\n        assembly{\n\n            buff := mload(0x40)\n\n            let byteLen := 0x04\n\n            mstore(buff, byteLen)\n\n            for {\n\n                let mindex := 0x00\n\n                let vindex := 0x1f\n\n            } lt(mindex, byteLen) {\n\n                mindex := add(mindex, 0x01)\n\n                vindex := sub(vindex, 0x01)\n\n            }{\n\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\n\n            }\n\n            mstore(0x40, add(buff, 0x24))\n\n        }\n\n        return buff;\n",
          "message": "ZeroCopySink.WriteUint32 (EthCrossChainUtils.sol#392-410) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 416,
          "vulnerability_to_line": 435,
          "vulnerability_code": "    function WriteUint64(uint64 v) internal pure returns(bytes memory) {\n\n        bytes memory buff;\n\n\n\n        assembly{\n\n            buff := mload(0x40)\n\n            let byteLen := 0x08\n\n            mstore(buff, byteLen)\n\n            for {\n\n                let mindex := 0x00\n\n                let vindex := 0x1f\n\n            } lt(mindex, byteLen) {\n\n                mindex := add(mindex, 0x01)\n\n                vindex := sub(vindex, 0x01)\n\n            }{\n\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\n\n            }\n\n            mstore(0x40, add(buff, 0x28))\n\n        }\n\n        return buff;\n",
          "message": "ZeroCopySink.WriteUint64 (EthCrossChainUtils.sol#416-435) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 441,
          "vulnerability_to_line": 461,
          "vulnerability_code": "    function WriteUint255(uint256 v) internal pure returns (bytes memory) {\n\n        require(v <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds uint255 range\");\n\n        bytes memory buff;\n\n\n\n        assembly{\n\n            buff := mload(0x40)\n\n            let byteLen := 0x20\n\n            mstore(buff, byteLen)\n\n            for {\n\n                let mindex := 0x00\n\n                let vindex := 0x1f\n\n            } lt(mindex, byteLen) {\n\n                mindex := add(mindex, 0x01)\n\n                vindex := sub(vindex, 0x01)\n\n            }{\n\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\n\n            }\n\n            mstore(0x40, add(buff, 0x40))\n\n        }\n\n        return buff;\n",
          "message": "ZeroCopySink.WriteUint255 (EthCrossChainUtils.sol#441-461) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 496,
          "vulnerability_to_line": 502,
          "vulnerability_code": "    function bytesToBytes32(bytes memory _bs) internal pure returns (bytes32 value) {\n\n        require(_bs.length == 32, \"bytes length is not 32.\");\n\n        assembly {\n\n            // load 32 bytes from memory starting from position _bs + 0x20 since the first 0x20 bytes stores _bs length\n\n            value := mload(add(_bs, 0x20))\n\n        }\n",
          "message": "Utils.bytesToBytes32 (EthCrossChainUtils.sol#496-502) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 508,
          "vulnerability_to_line": 515,
          "vulnerability_code": "    function bytesToUint256(bytes memory _bs) internal pure returns (uint256 value) {\n\n        require(_bs.length == 32, \"bytes length is not 32.\");\n\n        assembly {\n\n            // load 32 bytes from memory starting from position _bs + 32\n\n            value := mload(add(_bs, 0x20))\n\n        }\n\n        require(value <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds the range\");\n",
          "message": "Utils.bytesToUint256 (EthCrossChainUtils.sol#508-515) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 521,
          "vulnerability_to_line": 534,
          "vulnerability_code": "    function uint256ToBytes(uint256 _value) internal pure returns (bytes memory bs) {\n\n        require(_value <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds the range\");\n\n        assembly {\n\n            // Get a location of some free memory and store it in result as\n\n            // Solidity does for memory variables.\n\n            bs := mload(0x40)\n\n            // Put 0x20 at the first word, the length of bytes for uint256 value\n\n            mstore(bs, 0x20)\n\n            //In the next word, put value in bytes format to the next 32 bytes\n\n            mstore(add(bs, 0x20), _value)\n\n            // Update the free-memory pointer by padding our last write location to 32 bytes\n\n            mstore(0x40, add(bs, 0x40))\n\n        }\n",
          "message": "Utils.uint256ToBytes (EthCrossChainUtils.sol#521-534) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 540,
          "vulnerability_to_line": 549,
          "vulnerability_code": "    function bytesToAddress(bytes memory _bs) internal pure returns (address addr)\n\n    {\n\n        require(_bs.length == 20, \"bytes length does not match address\");\n\n        assembly {\n\n            // for _bs, first word store _bs.length, second word store _bs.value\n\n            // load 32 bytes from mem[_bs+20], convert it into Uint160, meaning we take last 20 bytes as addr (address).\n\n            addr := mload(add(_bs, 0x14))\n\n        }\n\n\n",
          "message": "Utils.bytesToAddress (EthCrossChainUtils.sol#540-549) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 555,
          "vulnerability_to_line": 567,
          "vulnerability_code": "    function addressToBytes(address _addr) internal pure returns (bytes memory bs){\n\n        assembly {\n\n            // Get a location of some free memory and store it in result as\n\n            // Solidity does for memory variables.\n\n            bs := mload(0x40)\n\n            // Put 20 (address byte length) at the first word, the length of bytes for uint256 value\n\n            mstore(bs, 0x14)\n\n            // logical shift left _a by 12 bytes, change _a from right-aligned to left-aligned\n\n            mstore(add(bs, 0x20), shl(96, _addr))\n\n            // Update the free-memory pointer by padding our last write location to 32 bytes\n\n            mstore(0x40, add(bs, 0x40))\n\n       }\n",
          "message": "Utils.addressToBytes (EthCrossChainUtils.sol#555-567) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 592,
          "vulnerability_to_line": 662,
          "vulnerability_code": "    function equalStorage(bytes storage _preBytes, bytes memory _postBytes) internal view returns (bool) {\n\n        bool success = true;\n\n\n\n        assembly {\n\n            // we know _preBytes_offset is 0\n\n            let fslot := sload(_preBytes_slot)\n\n            // Arrays of 31 bytes or less have an even value in their slot,\n\n            // while longer arrays have an odd value. The actual length is\n\n            // the slot divided by two for odd values, and the lowest order\n\n            // byte divided by two for even values.\n\n            // If the slot is even, bitwise and the slot with 255 and divide by\n\n            // two to get the length. If the slot is odd, bitwise and the slot\n\n            // with -1 and divide by two.\n\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n\n            let mlength := mload(_postBytes)\n\n\n\n            // if lengths don't match the arrays are not equal\n\n            switch eq(slength, mlength)\n\n            case 1 {\n\n                // fslot can contain both the length and contents of the array\n\n                // if slength < 32 bytes so let's prepare for that\n\n                // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n\n                // slength != 0\n\n                if iszero(iszero(slength)) {\n\n                    switch lt(slength, 32)\n\n                    case 1 {\n\n                        // blank the last byte which is the length\n\n                        fslot := mul(div(fslot, 0x100), 0x100)\n\n\n\n                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\n\n                            // unsuccess:\n\n                            success := 0\n\n                        }\n\n                    }\n\n                    default {\n\n                        // cb is a circuit breaker in the for loop since there's\n\n                        //  no said feature for inline assembly loops\n\n                        // cb = 1 - don't breaker\n\n                        // cb = 0 - break\n\n                        let cb := 1\n\n\n\n                        // get the keccak hash to get the contents of the array\n\n                        mstore(0x0, _preBytes_slot)\n\n                        let sc := keccak256(0x0, 0x20)\n\n\n\n                        let mc := add(_postBytes, 0x20)\n\n                        let end := add(mc, mlength)\n\n\n\n                        // the next line is the loop condition:\n\n                        // while(uint(mc < end) + cb == 2)\n\n                        for {} eq(add(lt(mc, end), cb), 2) {\n\n                            sc := add(sc, 1)\n\n                            mc := add(mc, 0x20)\n\n                        } {\n\n                            if iszero(eq(sload(sc), mload(mc))) {\n\n                                // unsuccess:\n\n                                success := 0\n\n                                cb := 0\n\n                            }\n\n                        }\n\n                    }\n\n                }\n\n            }\n\n            default {\n\n                // unsuccess:\n\n                success := 0\n\n            }\n\n        }\n\n\n\n        return success;\n",
          "message": "Utils.equalStorage (EthCrossChainUtils.sol#592-662) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 671,
          "vulnerability_to_line": 735,
          "vulnerability_code": "    function slice(\n\n        bytes memory _bytes,\n\n        uint _start,\n\n        uint _length\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        require(_bytes.length >= (_start + _length));\n\n\n\n        bytes memory tempBytes;\n\n\n\n        assembly {\n\n            switch iszero(_length)\n\n            case 0 {\n\n                // Get a location of some free memory and store it in tempBytes as\n\n                // Solidity does for memory variables.\n\n                tempBytes := mload(0x40)\n\n\n\n                // The first word of the slice result is potentially a partial\n\n                // word read from the original array. To read it, we calculate\n\n                // the length of that partial word and start copying that many\n\n                // bytes into the array. The first word we copy will start with\n\n                // data we don't care about, but the last `lengthmod` bytes will\n\n                // land at the beginning of the contents of the new array. When\n\n                // we're done copying, we overwrite the full first word with\n\n                // the actual length of the slice.\n\n                // lengthmod <= _length % 32\n\n                let lengthmod := and(_length, 31)\n\n\n\n                // The multiplication in the next line is necessary\n\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n\n                // the following copy loop was copying the origin's length\n\n                // and then ending prematurely not copying everything it should.\n\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n\n                let end := add(mc, _length)\n\n\n\n                for {\n\n                    // The multiplication in the next line has the same exact purpose\n\n                    // as the one above.\n\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n\n                } lt(mc, end) {\n\n                    mc := add(mc, 0x20)\n\n                    cc := add(cc, 0x20)\n\n                } {\n\n                    mstore(mc, mload(cc))\n\n                }\n\n\n\n                mstore(tempBytes, _length)\n\n\n\n                //update free-memory pointer\n\n                //allocating the array padded to 32 bytes like the compiler does now\n\n                mstore(0x40, and(add(mc, 31), not(31)))\n\n            }\n\n            //if we want a zero-length slice let's just return a zero-length array\n\n            default {\n\n                tempBytes := mload(0x40)\n\n\n\n                mstore(0x40, add(tempBytes, 0x20))\n\n            }\n\n        }\n\n\n\n        return tempBytes;\n",
          "message": "Utils.slice (EthCrossChainUtils.sol#671-735) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 782,
          "vulnerability_to_line": 795,
          "vulnerability_code": "    function isContract(address account) internal view returns (bool) {\n\n        // This method relies in extcodesize, which returns 0 for contracts in\n\n        // construction, since the code is only stored at the end of the\n\n        // constructor execution.\n\n\n\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n\n        // for accounts without code, i.e. `keccak256('')`\n\n        bytes32 codehash;\n\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly { codehash := extcodehash(account) }\n\n        return (codehash != 0x0 && codehash != accountHash);\n",
          "message": "Utils.isContract (EthCrossChainUtils.sol#782-795) is declared view but contains assembly code\n"
        },
        {
          "name": "uninitialized-local",
          "vulnerability_from_line": 1157,
          "vulnerability_to_line": null,
          "vulnerability_code": "        Header memory header;\n",
          "message": "header in ECCUtils.deserializeHeader (EthCrossChainUtils.sol#1157) is a local variable never initialiazed\n"
        },
        {
          "name": "uninitialized-local",
          "vulnerability_from_line": 1125,
          "vulnerability_to_line": null,
          "vulnerability_code": "        ToMerkleValue memory toMerkleValue;\n",
          "message": "toMerkleValue in ECCUtils.deserializeMerkleValue (EthCrossChainUtils.sol#1125) is a local variable never initialiazed\n"
        },
        {
          "name": "uninitialized-local",
          "vulnerability_from_line": 1132,
          "vulnerability_to_line": null,
          "vulnerability_code": "        TxParam memory txParam;\n",
          "message": "txParam in ECCUtils.deserializeMerkleValue (EthCrossChainUtils.sol#1132) is a local variable never initialiazed\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 25,
          "vulnerability_to_line": 41,
          "vulnerability_code": "    function NextBool(bytes memory buff, uint256 offset) internal pure returns(bool, uint256) {\n\n        require(offset + 1 <= buff.length && offset < offset + 1, \"Offset exceeds limit\");\n\n        // byte === bytes1\n\n        byte v;\n\n        assembly{\n\n            v := mload(add(add(buff, 0x20), offset))\n\n        }\n\n        bool value;\n\n        if (v == 0x01) {\n\n\t\t    value = true;\n\n    \t} else if (v == 0x00) {\n\n            value = false;\n\n        } else {\n\n            revert(\"NextBool value error\");\n\n        }\n\n        return (value, offset + 1);\n",
          "message": "ZeroCopySource.NextBool uses assembly (EthCrossChainUtils.sol#25-41)\n\t- EthCrossChainUtils.sol#29-31\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 48,
          "vulnerability_to_line": 55,
          "vulnerability_code": "    function NextByte(bytes memory buff, uint256 offset) internal pure returns (byte, uint256) {\n\n        require(offset + 1 <= buff.length && offset < offset + 1, \"NextByte, Offset exceeds maximum\");\n\n        byte v;\n\n        assembly{\n\n            v := mload(add(add(buff, 0x20), offset))\n\n        }\n\n        return (v, offset + 1);\n",
          "message": "ZeroCopySource.NextByte uses assembly (EthCrossChainUtils.sol#48-55)\n\t- EthCrossChainUtils.sol#51-53\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 62,
          "vulnerability_to_line": 73,
          "vulnerability_code": "    function NextUint8(bytes memory buff, uint256 offset) internal pure returns (uint8, uint256) {\n\n        require(offset + 1 <= buff.length && offset < offset + 1, \"NextUint8, Offset exceeds maximum\");\n\n        uint8 v;\n\n        assembly{\n\n            let tmpbytes := mload(0x40)\n\n            let bvalue := mload(add(add(buff, 0x20), offset))\n\n            mstore8(tmpbytes, byte(0, bvalue))\n\n            mstore(0x40, add(tmpbytes, 0x01))\n\n            v := mload(sub(tmpbytes, 0x1f))\n\n        }\n\n        return (v, offset + 1);\n",
          "message": "ZeroCopySource.NextUint8 uses assembly (EthCrossChainUtils.sol#62-73)\n\t- EthCrossChainUtils.sol#65-71\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 80,
          "vulnerability_to_line": 93,
          "vulnerability_code": "    function NextUint16(bytes memory buff, uint256 offset) internal pure returns (uint16, uint256) {\n\n        require(offset + 2 <= buff.length && offset < offset + 2, \"NextUint16, offset exceeds maximum\");\n\n        \n\n        uint16 v;\n\n        assembly {\n\n            let tmpbytes := mload(0x40)\n\n            let bvalue := mload(add(add(buff, 0x20), offset))\n\n            mstore8(tmpbytes, byte(0x01, bvalue))\n\n            mstore8(add(tmpbytes, 0x01), byte(0, bvalue))\n\n            mstore(0x40, add(tmpbytes, 0x02))\n\n            v := mload(sub(tmpbytes, 0x1e))\n\n        }\n\n        return (v, offset + 2);\n",
          "message": "ZeroCopySource.NextUint16 uses assembly (EthCrossChainUtils.sol#80-93)\n\t- EthCrossChainUtils.sol#84-91\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 101,
          "vulnerability_to_line": 121,
          "vulnerability_code": "    function NextUint32(bytes memory buff, uint256 offset) internal pure returns (uint32, uint256) {\n\n        require(offset + 4 <= buff.length && offset < offset + 4, \"NextUint32, offset exceeds maximum\");\n\n        uint32 v;\n\n        assembly {\n\n            let tmpbytes := mload(0x40)\n\n            let byteLen := 0x04\n\n            for {\n\n                let tindex := 0x00\n\n                let bindex := sub(byteLen, 0x01)\n\n                let bvalue := mload(add(add(buff, 0x20), offset))\n\n            } lt(tindex, byteLen) {\n\n                tindex := add(tindex, 0x01)\n\n                bindex := sub(bindex, 0x01)\n\n            }{\n\n                mstore8(add(tmpbytes, tindex), byte(bindex, bvalue))\n\n            }\n\n            mstore(0x40, add(tmpbytes, byteLen))\n\n            v := mload(sub(tmpbytes, sub(0x20, byteLen)))\n\n        }\n\n        return (v, offset + 4);\n",
          "message": "ZeroCopySource.NextUint32 uses assembly (EthCrossChainUtils.sol#101-121)\n\t- EthCrossChainUtils.sol#104-119\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 128,
          "vulnerability_to_line": 148,
          "vulnerability_code": "    function NextUint64(bytes memory buff, uint256 offset) internal pure returns (uint64, uint256) {\n\n        require(offset + 8 <= buff.length && offset < offset + 8, \"NextUint64, offset exceeds maximum\");\n\n        uint64 v;\n\n        assembly {\n\n            let tmpbytes := mload(0x40)\n\n            let byteLen := 0x08\n\n            for {\n\n                let tindex := 0x00\n\n                let bindex := sub(byteLen, 0x01)\n\n                let bvalue := mload(add(add(buff, 0x20), offset))\n\n            } lt(tindex, byteLen) {\n\n                tindex := add(tindex, 0x01)\n\n                bindex := sub(bindex, 0x01)\n\n            }{\n\n                mstore8(add(tmpbytes, tindex), byte(bindex, bvalue))\n\n            }\n\n            mstore(0x40, add(tmpbytes, byteLen))\n\n            v := mload(sub(tmpbytes, sub(0x20, byteLen)))\n\n        }\n\n        return (v, offset + 8);\n",
          "message": "ZeroCopySource.NextUint64 uses assembly (EthCrossChainUtils.sol#128-148)\n\t- EthCrossChainUtils.sol#131-146\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 156,
          "vulnerability_to_line": 177,
          "vulnerability_code": "    function NextUint255(bytes memory buff, uint256 offset) internal pure returns (uint256, uint256) {\n\n        require(offset + 32 <= buff.length && offset < offset + 32, \"NextUint255, offset exceeds maximum\");\n\n        uint256 v;\n\n        assembly {\n\n            let tmpbytes := mload(0x40)\n\n            let byteLen := 0x20\n\n            for {\n\n                let tindex := 0x00\n\n                let bindex := sub(byteLen, 0x01)\n\n                let bvalue := mload(add(add(buff, 0x20), offset))\n\n            } lt(tindex, byteLen) {\n\n                tindex := add(tindex, 0x01)\n\n                bindex := sub(bindex, 0x01)\n\n            }{\n\n                mstore8(add(tmpbytes, tindex), byte(bindex, bvalue))\n\n            }\n\n            mstore(0x40, add(tmpbytes, byteLen))\n\n            v := mload(tmpbytes)\n\n        }\n\n        require(v <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds the range\");\n\n        return (v, offset + 32);\n",
          "message": "ZeroCopySource.NextUint255 uses assembly (EthCrossChainUtils.sol#156-177)\n\t- EthCrossChainUtils.sol#159-174\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 184,
          "vulnerability_to_line": 239,
          "vulnerability_code": "    function NextVarBytes(bytes memory buff, uint256 offset) internal pure returns(bytes memory, uint256) {\n\n        uint len;\n\n        (len, offset) = NextVarUint(buff, offset);\n\n        require(offset + len <= buff.length && offset < offset + len, \"NextVarBytes, offset exceeds maximum\");\n\n        bytes memory tempBytes;\n\n        assembly{\n\n            switch iszero(len)\n\n            case 0 {\n\n                // Get a location of some free memory and store it in tempBytes as\n\n                // Solidity does for memory variables.\n\n                tempBytes := mload(0x40)\n\n\n\n                // The first word of the slice result is potentially a partial\n\n                // word read from the original array. To read it, we calculate\n\n                // the length of that partial word and start copying that many\n\n                // bytes into the array. The first word we copy will start with\n\n                // data we don't care about, but the last `lengthmod` bytes will\n\n                // land at the beginning of the contents of the new array. When\n\n                // we're done copying, we overwrite the full first word with\n\n                // the actual length of the slice.\n\n                let lengthmod := and(len, 31)\n\n\n\n                // The multiplication in the next line is necessary\n\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n\n                // the following copy loop was copying the origin's length\n\n                // and then ending prematurely not copying everything it should.\n\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n\n                let end := add(mc, len)\n\n\n\n                for {\n\n                    // The multiplication in the next line has the same exact purpose\n\n                    // as the one above.\n\n                    let cc := add(add(add(buff, lengthmod), mul(0x20, iszero(lengthmod))), offset)\n\n                } lt(mc, end) {\n\n                    mc := add(mc, 0x20)\n\n                    cc := add(cc, 0x20)\n\n                } {\n\n                    mstore(mc, mload(cc))\n\n                }\n\n\n\n                mstore(tempBytes, len)\n\n\n\n                //update free-memory pointer\n\n                //allocating the array padded to 32 bytes like the compiler does now\n\n                mstore(0x40, and(add(mc, 31), not(31)))\n\n            }\n\n            //if we want a zero-length slice let's just return a zero-length array\n\n            default {\n\n                tempBytes := mload(0x40)\n\n\n\n                mstore(0x40, add(tempBytes, 0x20))\n\n            }\n\n        }\n\n\n\n        return (tempBytes, offset + len);\n",
          "message": "ZeroCopySource.NextVarBytes uses assembly (EthCrossChainUtils.sol#184-239)\n\t- EthCrossChainUtils.sol#189-236\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 245,
          "vulnerability_to_line": 252,
          "vulnerability_code": "    function NextHash(bytes memory buff, uint256 offset) internal pure returns (bytes32 , uint256) {\n\n        require(offset + 32 <= buff.length && offset < offset + 32, \"NextHash, offset exceeds maximum\");\n\n        bytes32 v;\n\n        assembly {\n\n            v := mload(add(buff, add(offset, 0x20)))\n\n        }\n\n        return (v, offset + 32);\n",
          "message": "ZeroCopySource.NextHash uses assembly (EthCrossChainUtils.sol#245-252)\n\t- EthCrossChainUtils.sol#248-250\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 259,
          "vulnerability_to_line": 266,
          "vulnerability_code": "    function NextBytes20(bytes memory buff, uint256 offset) internal pure returns (bytes20 , uint256) {\n\n        require(offset + 20 <= buff.length && offset < offset + 20, \"NextBytes20, offset exceeds maximum\");\n\n        bytes20 v;\n\n        assembly {\n\n            v := mload(add(buff, add(offset, 0x20)))\n\n        }\n\n        return (v, offset + 20);\n",
          "message": "ZeroCopySource.NextBytes20 uses assembly (EthCrossChainUtils.sol#259-266)\n\t- EthCrossChainUtils.sol#262-264\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 320,
          "vulnerability_to_line": 337,
          "vulnerability_code": "    function WriteBool(bool b) internal pure returns (bytes memory) {\n\n        bytes memory buff;\n\n        assembly{\n\n            buff := mload(0x40)\n\n            mstore(buff, 1)\n\n            switch iszero(b)\n\n            case 1 {\n\n                mstore(add(buff, 0x20), shl(248, 0x00))\n\n                // mstore8(add(buff, 0x20), 0x00)\n\n            }\n\n            default {\n\n                mstore(add(buff, 0x20), shl(248, 0x01))\n\n                // mstore8(add(buff, 0x20), 0x01)\n\n            }\n\n            mstore(0x40, add(buff, 0x21))\n\n        }\n\n        return buff;\n",
          "message": "ZeroCopySink.WriteBool uses assembly (EthCrossChainUtils.sol#320-337)\n\t- EthCrossChainUtils.sol#322-335\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 351,
          "vulnerability_to_line": 361,
          "vulnerability_code": "    function WriteUint8(uint8 v) internal pure returns (bytes memory) {\n\n        bytes memory buff;\n\n        assembly{\n\n            buff := mload(0x40)\n\n            mstore(buff, 1)\n\n            mstore(add(buff, 0x20), shl(248, v))\n\n            // mstore(add(buff, 0x20), byte(0x1f, v))\n\n            mstore(0x40, add(buff, 0x21))\n\n        }\n\n        return buff;\n",
          "message": "ZeroCopySink.WriteUint8 uses assembly (EthCrossChainUtils.sol#351-361)\n\t- EthCrossChainUtils.sol#353-359\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 367,
          "vulnerability_to_line": 386,
          "vulnerability_code": "    function WriteUint16(uint16 v) internal pure returns (bytes memory) {\n\n        bytes memory buff;\n\n\n\n        assembly{\n\n            buff := mload(0x40)\n\n            let byteLen := 0x02\n\n            mstore(buff, byteLen)\n\n            for {\n\n                let mindex := 0x00\n\n                let vindex := 0x1f\n\n            } lt(mindex, byteLen) {\n\n                mindex := add(mindex, 0x01)\n\n                vindex := sub(vindex, 0x01)\n\n            }{\n\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\n\n            }\n\n            mstore(0x40, add(buff, 0x22))\n\n        }\n\n        return buff;\n",
          "message": "ZeroCopySink.WriteUint16 uses assembly (EthCrossChainUtils.sol#367-386)\n\t- EthCrossChainUtils.sol#370-384\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 392,
          "vulnerability_to_line": 410,
          "vulnerability_code": "    function WriteUint32(uint32 v) internal pure returns(bytes memory) {\n\n        bytes memory buff;\n\n        assembly{\n\n            buff := mload(0x40)\n\n            let byteLen := 0x04\n\n            mstore(buff, byteLen)\n\n            for {\n\n                let mindex := 0x00\n\n                let vindex := 0x1f\n\n            } lt(mindex, byteLen) {\n\n                mindex := add(mindex, 0x01)\n\n                vindex := sub(vindex, 0x01)\n\n            }{\n\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\n\n            }\n\n            mstore(0x40, add(buff, 0x24))\n\n        }\n\n        return buff;\n",
          "message": "ZeroCopySink.WriteUint32 uses assembly (EthCrossChainUtils.sol#392-410)\n\t- EthCrossChainUtils.sol#394-408\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 416,
          "vulnerability_to_line": 435,
          "vulnerability_code": "    function WriteUint64(uint64 v) internal pure returns(bytes memory) {\n\n        bytes memory buff;\n\n\n\n        assembly{\n\n            buff := mload(0x40)\n\n            let byteLen := 0x08\n\n            mstore(buff, byteLen)\n\n            for {\n\n                let mindex := 0x00\n\n                let vindex := 0x1f\n\n            } lt(mindex, byteLen) {\n\n                mindex := add(mindex, 0x01)\n\n                vindex := sub(vindex, 0x01)\n\n            }{\n\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\n\n            }\n\n            mstore(0x40, add(buff, 0x28))\n\n        }\n\n        return buff;\n",
          "message": "ZeroCopySink.WriteUint64 uses assembly (EthCrossChainUtils.sol#416-435)\n\t- EthCrossChainUtils.sol#419-433\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 441,
          "vulnerability_to_line": 461,
          "vulnerability_code": "    function WriteUint255(uint256 v) internal pure returns (bytes memory) {\n\n        require(v <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds uint255 range\");\n\n        bytes memory buff;\n\n\n\n        assembly{\n\n            buff := mload(0x40)\n\n            let byteLen := 0x20\n\n            mstore(buff, byteLen)\n\n            for {\n\n                let mindex := 0x00\n\n                let vindex := 0x1f\n\n            } lt(mindex, byteLen) {\n\n                mindex := add(mindex, 0x01)\n\n                vindex := sub(vindex, 0x01)\n\n            }{\n\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\n\n            }\n\n            mstore(0x40, add(buff, 0x40))\n\n        }\n\n        return buff;\n",
          "message": "ZeroCopySink.WriteUint255 uses assembly (EthCrossChainUtils.sol#441-461)\n\t- EthCrossChainUtils.sol#445-459\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 496,
          "vulnerability_to_line": 502,
          "vulnerability_code": "    function bytesToBytes32(bytes memory _bs) internal pure returns (bytes32 value) {\n\n        require(_bs.length == 32, \"bytes length is not 32.\");\n\n        assembly {\n\n            // load 32 bytes from memory starting from position _bs + 0x20 since the first 0x20 bytes stores _bs length\n\n            value := mload(add(_bs, 0x20))\n\n        }\n",
          "message": "Utils.bytesToBytes32 uses assembly (EthCrossChainUtils.sol#496-502)\n\t- EthCrossChainUtils.sol#498-501\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 508,
          "vulnerability_to_line": 515,
          "vulnerability_code": "    function bytesToUint256(bytes memory _bs) internal pure returns (uint256 value) {\n\n        require(_bs.length == 32, \"bytes length is not 32.\");\n\n        assembly {\n\n            // load 32 bytes from memory starting from position _bs + 32\n\n            value := mload(add(_bs, 0x20))\n\n        }\n\n        require(value <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds the range\");\n",
          "message": "Utils.bytesToUint256 uses assembly (EthCrossChainUtils.sol#508-515)\n\t- EthCrossChainUtils.sol#510-513\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 521,
          "vulnerability_to_line": 534,
          "vulnerability_code": "    function uint256ToBytes(uint256 _value) internal pure returns (bytes memory bs) {\n\n        require(_value <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds the range\");\n\n        assembly {\n\n            // Get a location of some free memory and store it in result as\n\n            // Solidity does for memory variables.\n\n            bs := mload(0x40)\n\n            // Put 0x20 at the first word, the length of bytes for uint256 value\n\n            mstore(bs, 0x20)\n\n            //In the next word, put value in bytes format to the next 32 bytes\n\n            mstore(add(bs, 0x20), _value)\n\n            // Update the free-memory pointer by padding our last write location to 32 bytes\n\n            mstore(0x40, add(bs, 0x40))\n\n        }\n",
          "message": "Utils.uint256ToBytes uses assembly (EthCrossChainUtils.sol#521-534)\n\t- EthCrossChainUtils.sol#523-533\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 540,
          "vulnerability_to_line": 549,
          "vulnerability_code": "    function bytesToAddress(bytes memory _bs) internal pure returns (address addr)\n\n    {\n\n        require(_bs.length == 20, \"bytes length does not match address\");\n\n        assembly {\n\n            // for _bs, first word store _bs.length, second word store _bs.value\n\n            // load 32 bytes from mem[_bs+20], convert it into Uint160, meaning we take last 20 bytes as addr (address).\n\n            addr := mload(add(_bs, 0x14))\n\n        }\n\n\n",
          "message": "Utils.bytesToAddress uses assembly (EthCrossChainUtils.sol#540-549)\n\t- EthCrossChainUtils.sol#543-547\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 555,
          "vulnerability_to_line": 567,
          "vulnerability_code": "    function addressToBytes(address _addr) internal pure returns (bytes memory bs){\n\n        assembly {\n\n            // Get a location of some free memory and store it in result as\n\n            // Solidity does for memory variables.\n\n            bs := mload(0x40)\n\n            // Put 20 (address byte length) at the first word, the length of bytes for uint256 value\n\n            mstore(bs, 0x14)\n\n            // logical shift left _a by 12 bytes, change _a from right-aligned to left-aligned\n\n            mstore(add(bs, 0x20), shl(96, _addr))\n\n            // Update the free-memory pointer by padding our last write location to 32 bytes\n\n            mstore(0x40, add(bs, 0x40))\n\n       }\n",
          "message": "Utils.addressToBytes uses assembly (EthCrossChainUtils.sol#555-567)\n\t- EthCrossChainUtils.sol#556-566\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 592,
          "vulnerability_to_line": 662,
          "vulnerability_code": "    function equalStorage(bytes storage _preBytes, bytes memory _postBytes) internal view returns (bool) {\n\n        bool success = true;\n\n\n\n        assembly {\n\n            // we know _preBytes_offset is 0\n\n            let fslot := sload(_preBytes_slot)\n\n            // Arrays of 31 bytes or less have an even value in their slot,\n\n            // while longer arrays have an odd value. The actual length is\n\n            // the slot divided by two for odd values, and the lowest order\n\n            // byte divided by two for even values.\n\n            // If the slot is even, bitwise and the slot with 255 and divide by\n\n            // two to get the length. If the slot is odd, bitwise and the slot\n\n            // with -1 and divide by two.\n\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n\n            let mlength := mload(_postBytes)\n\n\n\n            // if lengths don't match the arrays are not equal\n\n            switch eq(slength, mlength)\n\n            case 1 {\n\n                // fslot can contain both the length and contents of the array\n\n                // if slength < 32 bytes so let's prepare for that\n\n                // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n\n                // slength != 0\n\n                if iszero(iszero(slength)) {\n\n                    switch lt(slength, 32)\n\n                    case 1 {\n\n                        // blank the last byte which is the length\n\n                        fslot := mul(div(fslot, 0x100), 0x100)\n\n\n\n                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\n\n                            // unsuccess:\n\n                            success := 0\n\n                        }\n\n                    }\n\n                    default {\n\n                        // cb is a circuit breaker in the for loop since there's\n\n                        //  no said feature for inline assembly loops\n\n                        // cb = 1 - don't breaker\n\n                        // cb = 0 - break\n\n                        let cb := 1\n\n\n\n                        // get the keccak hash to get the contents of the array\n\n                        mstore(0x0, _preBytes_slot)\n\n                        let sc := keccak256(0x0, 0x20)\n\n\n\n                        let mc := add(_postBytes, 0x20)\n\n                        let end := add(mc, mlength)\n\n\n\n                        // the next line is the loop condition:\n\n                        // while(uint(mc < end) + cb == 2)\n\n                        for {} eq(add(lt(mc, end), cb), 2) {\n\n                            sc := add(sc, 1)\n\n                            mc := add(mc, 0x20)\n\n                        } {\n\n                            if iszero(eq(sload(sc), mload(mc))) {\n\n                                // unsuccess:\n\n                                success := 0\n\n                                cb := 0\n\n                            }\n\n                        }\n\n                    }\n\n                }\n\n            }\n\n            default {\n\n                // unsuccess:\n\n                success := 0\n\n            }\n\n        }\n\n\n\n        return success;\n",
          "message": "Utils.equalStorage uses assembly (EthCrossChainUtils.sol#592-662)\n\t- EthCrossChainUtils.sol#595-659\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 671,
          "vulnerability_to_line": 735,
          "vulnerability_code": "    function slice(\n\n        bytes memory _bytes,\n\n        uint _start,\n\n        uint _length\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        require(_bytes.length >= (_start + _length));\n\n\n\n        bytes memory tempBytes;\n\n\n\n        assembly {\n\n            switch iszero(_length)\n\n            case 0 {\n\n                // Get a location of some free memory and store it in tempBytes as\n\n                // Solidity does for memory variables.\n\n                tempBytes := mload(0x40)\n\n\n\n                // The first word of the slice result is potentially a partial\n\n                // word read from the original array. To read it, we calculate\n\n                // the length of that partial word and start copying that many\n\n                // bytes into the array. The first word we copy will start with\n\n                // data we don't care about, but the last `lengthmod` bytes will\n\n                // land at the beginning of the contents of the new array. When\n\n                // we're done copying, we overwrite the full first word with\n\n                // the actual length of the slice.\n\n                // lengthmod <= _length % 32\n\n                let lengthmod := and(_length, 31)\n\n\n\n                // The multiplication in the next line is necessary\n\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n\n                // the following copy loop was copying the origin's length\n\n                // and then ending prematurely not copying everything it should.\n\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n\n                let end := add(mc, _length)\n\n\n\n                for {\n\n                    // The multiplication in the next line has the same exact purpose\n\n                    // as the one above.\n\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n\n                } lt(mc, end) {\n\n                    mc := add(mc, 0x20)\n\n                    cc := add(cc, 0x20)\n\n                } {\n\n                    mstore(mc, mload(cc))\n\n                }\n\n\n\n                mstore(tempBytes, _length)\n\n\n\n                //update free-memory pointer\n\n                //allocating the array padded to 32 bytes like the compiler does now\n\n                mstore(0x40, and(add(mc, 31), not(31)))\n\n            }\n\n            //if we want a zero-length slice let's just return a zero-length array\n\n            default {\n\n                tempBytes := mload(0x40)\n\n\n\n                mstore(0x40, add(tempBytes, 0x20))\n\n            }\n\n        }\n\n\n\n        return tempBytes;\n",
          "message": "Utils.slice uses assembly (EthCrossChainUtils.sol#671-735)\n\t- EthCrossChainUtils.sol#684-732\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 782,
          "vulnerability_to_line": 795,
          "vulnerability_code": "    function isContract(address account) internal view returns (bool) {\n\n        // This method relies in extcodesize, which returns 0 for contracts in\n\n        // construction, since the code is only stored at the end of the\n\n        // constructor execution.\n\n\n\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n\n        // for accounts without code, i.e. `keccak256('')`\n\n        bytes32 codehash;\n\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly { codehash := extcodehash(account) }\n\n        return (codehash != 0x0 && codehash != accountHash);\n",
          "message": "Utils.isContract uses assembly (EthCrossChainUtils.sol#782-795)\n\t- EthCrossChainUtils.sol#793\n"
        },
        {
          "name": "solc-version",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.0;\n",
          "message": "Detected issues with version pragma in EthCrossChainUtils.sol:\n\t- pragma solidity^0.5.0 (EthCrossChainUtils.sol#3): it allows old versions\n\t- pragma solidity^0.5.0 (EthCrossChainUtils.sol#299): it allows old versions\n\t- pragma solidity^0.5.0 (EthCrossChainUtils.sol#487): it allows old versions\n\t- pragma solidity^0.5.0 (EthCrossChainUtils.sol#800): it allows old versions\n\t- pragma solidity^0.5.0 (EthCrossChainUtils.sol#959): it allows old versions\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 25,
          "vulnerability_to_line": 41,
          "vulnerability_code": "    function NextBool(bytes memory buff, uint256 offset) internal pure returns(bool, uint256) {\n\n        require(offset + 1 <= buff.length && offset < offset + 1, \"Offset exceeds limit\");\n\n        // byte === bytes1\n\n        byte v;\n\n        assembly{\n\n            v := mload(add(add(buff, 0x20), offset))\n\n        }\n\n        bool value;\n\n        if (v == 0x01) {\n\n\t\t    value = true;\n\n    \t} else if (v == 0x00) {\n\n            value = false;\n\n        } else {\n\n            revert(\"NextBool value error\");\n\n        }\n\n        return (value, offset + 1);\n",
          "message": "Function 'ZeroCopySource.NextBool' (EthCrossChainUtils.sol#25-41) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 48,
          "vulnerability_to_line": 55,
          "vulnerability_code": "    function NextByte(bytes memory buff, uint256 offset) internal pure returns (byte, uint256) {\n\n        require(offset + 1 <= buff.length && offset < offset + 1, \"NextByte, Offset exceeds maximum\");\n\n        byte v;\n\n        assembly{\n\n            v := mload(add(add(buff, 0x20), offset))\n\n        }\n\n        return (v, offset + 1);\n",
          "message": "Function 'ZeroCopySource.NextByte' (EthCrossChainUtils.sol#48-55) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 62,
          "vulnerability_to_line": 73,
          "vulnerability_code": "    function NextUint8(bytes memory buff, uint256 offset) internal pure returns (uint8, uint256) {\n\n        require(offset + 1 <= buff.length && offset < offset + 1, \"NextUint8, Offset exceeds maximum\");\n\n        uint8 v;\n\n        assembly{\n\n            let tmpbytes := mload(0x40)\n\n            let bvalue := mload(add(add(buff, 0x20), offset))\n\n            mstore8(tmpbytes, byte(0, bvalue))\n\n            mstore(0x40, add(tmpbytes, 0x01))\n\n            v := mload(sub(tmpbytes, 0x1f))\n\n        }\n\n        return (v, offset + 1);\n",
          "message": "Function 'ZeroCopySource.NextUint8' (EthCrossChainUtils.sol#62-73) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 80,
          "vulnerability_to_line": 93,
          "vulnerability_code": "    function NextUint16(bytes memory buff, uint256 offset) internal pure returns (uint16, uint256) {\n\n        require(offset + 2 <= buff.length && offset < offset + 2, \"NextUint16, offset exceeds maximum\");\n\n        \n\n        uint16 v;\n\n        assembly {\n\n            let tmpbytes := mload(0x40)\n\n            let bvalue := mload(add(add(buff, 0x20), offset))\n\n            mstore8(tmpbytes, byte(0x01, bvalue))\n\n            mstore8(add(tmpbytes, 0x01), byte(0, bvalue))\n\n            mstore(0x40, add(tmpbytes, 0x02))\n\n            v := mload(sub(tmpbytes, 0x1e))\n\n        }\n\n        return (v, offset + 2);\n",
          "message": "Function 'ZeroCopySource.NextUint16' (EthCrossChainUtils.sol#80-93) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 101,
          "vulnerability_to_line": 121,
          "vulnerability_code": "    function NextUint32(bytes memory buff, uint256 offset) internal pure returns (uint32, uint256) {\n\n        require(offset + 4 <= buff.length && offset < offset + 4, \"NextUint32, offset exceeds maximum\");\n\n        uint32 v;\n\n        assembly {\n\n            let tmpbytes := mload(0x40)\n\n            let byteLen := 0x04\n\n            for {\n\n                let tindex := 0x00\n\n                let bindex := sub(byteLen, 0x01)\n\n                let bvalue := mload(add(add(buff, 0x20), offset))\n\n            } lt(tindex, byteLen) {\n\n                tindex := add(tindex, 0x01)\n\n                bindex := sub(bindex, 0x01)\n\n            }{\n\n                mstore8(add(tmpbytes, tindex), byte(bindex, bvalue))\n\n            }\n\n            mstore(0x40, add(tmpbytes, byteLen))\n\n            v := mload(sub(tmpbytes, sub(0x20, byteLen)))\n\n        }\n\n        return (v, offset + 4);\n",
          "message": "Function 'ZeroCopySource.NextUint32' (EthCrossChainUtils.sol#101-121) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 128,
          "vulnerability_to_line": 148,
          "vulnerability_code": "    function NextUint64(bytes memory buff, uint256 offset) internal pure returns (uint64, uint256) {\n\n        require(offset + 8 <= buff.length && offset < offset + 8, \"NextUint64, offset exceeds maximum\");\n\n        uint64 v;\n\n        assembly {\n\n            let tmpbytes := mload(0x40)\n\n            let byteLen := 0x08\n\n            for {\n\n                let tindex := 0x00\n\n                let bindex := sub(byteLen, 0x01)\n\n                let bvalue := mload(add(add(buff, 0x20), offset))\n\n            } lt(tindex, byteLen) {\n\n                tindex := add(tindex, 0x01)\n\n                bindex := sub(bindex, 0x01)\n\n            }{\n\n                mstore8(add(tmpbytes, tindex), byte(bindex, bvalue))\n\n            }\n\n            mstore(0x40, add(tmpbytes, byteLen))\n\n            v := mload(sub(tmpbytes, sub(0x20, byteLen)))\n\n        }\n\n        return (v, offset + 8);\n",
          "message": "Function 'ZeroCopySource.NextUint64' (EthCrossChainUtils.sol#128-148) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 156,
          "vulnerability_to_line": 177,
          "vulnerability_code": "    function NextUint255(bytes memory buff, uint256 offset) internal pure returns (uint256, uint256) {\n\n        require(offset + 32 <= buff.length && offset < offset + 32, \"NextUint255, offset exceeds maximum\");\n\n        uint256 v;\n\n        assembly {\n\n            let tmpbytes := mload(0x40)\n\n            let byteLen := 0x20\n\n            for {\n\n                let tindex := 0x00\n\n                let bindex := sub(byteLen, 0x01)\n\n                let bvalue := mload(add(add(buff, 0x20), offset))\n\n            } lt(tindex, byteLen) {\n\n                tindex := add(tindex, 0x01)\n\n                bindex := sub(bindex, 0x01)\n\n            }{\n\n                mstore8(add(tmpbytes, tindex), byte(bindex, bvalue))\n\n            }\n\n            mstore(0x40, add(tmpbytes, byteLen))\n\n            v := mload(tmpbytes)\n\n        }\n\n        require(v <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds the range\");\n\n        return (v, offset + 32);\n",
          "message": "Function 'ZeroCopySource.NextUint255' (EthCrossChainUtils.sol#156-177) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 184,
          "vulnerability_to_line": 239,
          "vulnerability_code": "    function NextVarBytes(bytes memory buff, uint256 offset) internal pure returns(bytes memory, uint256) {\n\n        uint len;\n\n        (len, offset) = NextVarUint(buff, offset);\n\n        require(offset + len <= buff.length && offset < offset + len, \"NextVarBytes, offset exceeds maximum\");\n\n        bytes memory tempBytes;\n\n        assembly{\n\n            switch iszero(len)\n\n            case 0 {\n\n                // Get a location of some free memory and store it in tempBytes as\n\n                // Solidity does for memory variables.\n\n                tempBytes := mload(0x40)\n\n\n\n                // The first word of the slice result is potentially a partial\n\n                // word read from the original array. To read it, we calculate\n\n                // the length of that partial word and start copying that many\n\n                // bytes into the array. The first word we copy will start with\n\n                // data we don't care about, but the last `lengthmod` bytes will\n\n                // land at the beginning of the contents of the new array. When\n\n                // we're done copying, we overwrite the full first word with\n\n                // the actual length of the slice.\n\n                let lengthmod := and(len, 31)\n\n\n\n                // The multiplication in the next line is necessary\n\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n\n                // the following copy loop was copying the origin's length\n\n                // and then ending prematurely not copying everything it should.\n\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n\n                let end := add(mc, len)\n\n\n\n                for {\n\n                    // The multiplication in the next line has the same exact purpose\n\n                    // as the one above.\n\n                    let cc := add(add(add(buff, lengthmod), mul(0x20, iszero(lengthmod))), offset)\n\n                } lt(mc, end) {\n\n                    mc := add(mc, 0x20)\n\n                    cc := add(cc, 0x20)\n\n                } {\n\n                    mstore(mc, mload(cc))\n\n                }\n\n\n\n                mstore(tempBytes, len)\n\n\n\n                //update free-memory pointer\n\n                //allocating the array padded to 32 bytes like the compiler does now\n\n                mstore(0x40, and(add(mc, 31), not(31)))\n\n            }\n\n            //if we want a zero-length slice let's just return a zero-length array\n\n            default {\n\n                tempBytes := mload(0x40)\n\n\n\n                mstore(0x40, add(tempBytes, 0x20))\n\n            }\n\n        }\n\n\n\n        return (tempBytes, offset + len);\n",
          "message": "Function 'ZeroCopySource.NextVarBytes' (EthCrossChainUtils.sol#184-239) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 245,
          "vulnerability_to_line": 252,
          "vulnerability_code": "    function NextHash(bytes memory buff, uint256 offset) internal pure returns (bytes32 , uint256) {\n\n        require(offset + 32 <= buff.length && offset < offset + 32, \"NextHash, offset exceeds maximum\");\n\n        bytes32 v;\n\n        assembly {\n\n            v := mload(add(buff, add(offset, 0x20)))\n\n        }\n\n        return (v, offset + 32);\n",
          "message": "Function 'ZeroCopySource.NextHash' (EthCrossChainUtils.sol#245-252) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 259,
          "vulnerability_to_line": 266,
          "vulnerability_code": "    function NextBytes20(bytes memory buff, uint256 offset) internal pure returns (bytes20 , uint256) {\n\n        require(offset + 20 <= buff.length && offset < offset + 20, \"NextBytes20, offset exceeds maximum\");\n\n        bytes20 v;\n\n        assembly {\n\n            v := mload(add(buff, add(offset, 0x20)))\n\n        }\n\n        return (v, offset + 20);\n",
          "message": "Function 'ZeroCopySource.NextBytes20' (EthCrossChainUtils.sol#259-266) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 268,
          "vulnerability_to_line": 294,
          "vulnerability_code": "    function NextVarUint(bytes memory buff, uint256 offset) internal pure returns(uint, uint256) {\n\n        byte v;\n\n        (v, offset) = NextByte(buff, offset);\n\n\n\n        uint value;\n\n        if (v == 0xFD) {\n\n            // return NextUint16(buff, offset);\n\n            (value, offset) = NextUint16(buff, offset);\n\n            require(value >= 0xFD && value <= 0xFFFF, \"NextUint16, value outside range\");\n\n            return (value, offset);\n\n        } else if (v == 0xFE) {\n\n            // return NextUint32(buff, offset);\n\n            (value, offset) = NextUint32(buff, offset);\n\n            require(value > 0xFFFF && value <= 0xFFFFFFFF, \"NextVarUint, value outside range\");\n\n            return (value, offset);\n\n        } else if (v == 0xFF) {\n\n            // return NextUint64(buff, offset);\n\n            (value, offset) = NextUint64(buff, offset);\n\n            require(value > 0xFFFFFFFF, \"NextVarUint, value outside range\");\n\n            return (value, offset);\n\n        } else{\n\n            // return (uint8(v), offset);\n\n            value = uint8(v);\n\n            require(value < 0xFD, \"NextVarUint, value outside range\");\n\n            return (value, offset);\n\n        }\n",
          "message": "Function 'ZeroCopySource.NextVarUint' (EthCrossChainUtils.sol#268-294) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 320,
          "vulnerability_to_line": 337,
          "vulnerability_code": "    function WriteBool(bool b) internal pure returns (bytes memory) {\n\n        bytes memory buff;\n\n        assembly{\n\n            buff := mload(0x40)\n\n            mstore(buff, 1)\n\n            switch iszero(b)\n\n            case 1 {\n\n                mstore(add(buff, 0x20), shl(248, 0x00))\n\n                // mstore8(add(buff, 0x20), 0x00)\n\n            }\n\n            default {\n\n                mstore(add(buff, 0x20), shl(248, 0x01))\n\n                // mstore8(add(buff, 0x20), 0x01)\n\n            }\n\n            mstore(0x40, add(buff, 0x21))\n\n        }\n\n        return buff;\n",
          "message": "Function 'ZeroCopySink.WriteBool' (EthCrossChainUtils.sol#320-337) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 343,
          "vulnerability_to_line": 345,
          "vulnerability_code": "    function WriteByte(byte b) internal pure returns (bytes memory) {\n\n        return WriteUint8(uint8(b));\n",
          "message": "Function 'ZeroCopySink.WriteByte' (EthCrossChainUtils.sol#343-345) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 351,
          "vulnerability_to_line": 361,
          "vulnerability_code": "    function WriteUint8(uint8 v) internal pure returns (bytes memory) {\n\n        bytes memory buff;\n\n        assembly{\n\n            buff := mload(0x40)\n\n            mstore(buff, 1)\n\n            mstore(add(buff, 0x20), shl(248, v))\n\n            // mstore(add(buff, 0x20), byte(0x1f, v))\n\n            mstore(0x40, add(buff, 0x21))\n\n        }\n\n        return buff;\n",
          "message": "Function 'ZeroCopySink.WriteUint8' (EthCrossChainUtils.sol#351-361) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 367,
          "vulnerability_to_line": 386,
          "vulnerability_code": "    function WriteUint16(uint16 v) internal pure returns (bytes memory) {\n\n        bytes memory buff;\n\n\n\n        assembly{\n\n            buff := mload(0x40)\n\n            let byteLen := 0x02\n\n            mstore(buff, byteLen)\n\n            for {\n\n                let mindex := 0x00\n\n                let vindex := 0x1f\n\n            } lt(mindex, byteLen) {\n\n                mindex := add(mindex, 0x01)\n\n                vindex := sub(vindex, 0x01)\n\n            }{\n\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\n\n            }\n\n            mstore(0x40, add(buff, 0x22))\n\n        }\n\n        return buff;\n",
          "message": "Function 'ZeroCopySink.WriteUint16' (EthCrossChainUtils.sol#367-386) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 392,
          "vulnerability_to_line": 410,
          "vulnerability_code": "    function WriteUint32(uint32 v) internal pure returns(bytes memory) {\n\n        bytes memory buff;\n\n        assembly{\n\n            buff := mload(0x40)\n\n            let byteLen := 0x04\n\n            mstore(buff, byteLen)\n\n            for {\n\n                let mindex := 0x00\n\n                let vindex := 0x1f\n\n            } lt(mindex, byteLen) {\n\n                mindex := add(mindex, 0x01)\n\n                vindex := sub(vindex, 0x01)\n\n            }{\n\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\n\n            }\n\n            mstore(0x40, add(buff, 0x24))\n\n        }\n\n        return buff;\n",
          "message": "Function 'ZeroCopySink.WriteUint32' (EthCrossChainUtils.sol#392-410) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 416,
          "vulnerability_to_line": 435,
          "vulnerability_code": "    function WriteUint64(uint64 v) internal pure returns(bytes memory) {\n\n        bytes memory buff;\n\n\n\n        assembly{\n\n            buff := mload(0x40)\n\n            let byteLen := 0x08\n\n            mstore(buff, byteLen)\n\n            for {\n\n                let mindex := 0x00\n\n                let vindex := 0x1f\n\n            } lt(mindex, byteLen) {\n\n                mindex := add(mindex, 0x01)\n\n                vindex := sub(vindex, 0x01)\n\n            }{\n\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\n\n            }\n\n            mstore(0x40, add(buff, 0x28))\n\n        }\n\n        return buff;\n",
          "message": "Function 'ZeroCopySink.WriteUint64' (EthCrossChainUtils.sol#416-435) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 441,
          "vulnerability_to_line": 461,
          "vulnerability_code": "    function WriteUint255(uint256 v) internal pure returns (bytes memory) {\n\n        require(v <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds uint255 range\");\n\n        bytes memory buff;\n\n\n\n        assembly{\n\n            buff := mload(0x40)\n\n            let byteLen := 0x20\n\n            mstore(buff, byteLen)\n\n            for {\n\n                let mindex := 0x00\n\n                let vindex := 0x1f\n\n            } lt(mindex, byteLen) {\n\n                mindex := add(mindex, 0x01)\n\n                vindex := sub(vindex, 0x01)\n\n            }{\n\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\n\n            }\n\n            mstore(0x40, add(buff, 0x40))\n\n        }\n\n        return buff;\n",
          "message": "Function 'ZeroCopySink.WriteUint255' (EthCrossChainUtils.sol#441-461) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 467,
          "vulnerability_to_line": 470,
          "vulnerability_code": "    function WriteVarBytes(bytes memory data) internal pure returns (bytes memory) {\n\n        uint64 l = uint64(data.length);\n\n        return abi.encodePacked(WriteVarUint(l), data);\n",
          "message": "Function 'ZeroCopySink.WriteVarBytes' (EthCrossChainUtils.sol#467-470) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 472,
          "vulnerability_to_line": 482,
          "vulnerability_code": "    function WriteVarUint(uint64 v) internal pure returns (bytes memory) {\n\n        if (v < 0xFD){\n\n    \t\treturn WriteUint8(uint8(v));\n\n    \t} else if (v <= 0xFFFF) {\n\n    \t\treturn abi.encodePacked(WriteByte(0xFD), WriteUint16(uint16(v)));\n\n    \t} else if (v <= 0xFFFFFFFF) {\n\n            return abi.encodePacked(WriteByte(0xFE), WriteUint32(uint32(v)));\n\n    \t} else {\n\n    \t\treturn abi.encodePacked(WriteByte(0xFF), WriteUint64(uint64(v)));\n\n    \t}\n",
          "message": "Function 'ZeroCopySink.WriteVarUint' (EthCrossChainUtils.sol#472-482) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 496,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function bytesToBytes32(bytes memory _bs) internal pure returns (bytes32 value) {\n",
          "message": "Parameter '_bs' of Utils.bytesToBytes32 (EthCrossChainUtils.sol#496) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 508,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function bytesToUint256(bytes memory _bs) internal pure returns (uint256 value) {\n",
          "message": "Parameter '_bs' of Utils.bytesToUint256 (EthCrossChainUtils.sol#508) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 521,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function uint256ToBytes(uint256 _value) internal pure returns (bytes memory bs) {\n",
          "message": "Parameter '_value' of Utils.uint256ToBytes (EthCrossChainUtils.sol#521) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 540,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function bytesToAddress(bytes memory _bs) internal pure returns (address addr)\n",
          "message": "Parameter '_bs' of Utils.bytesToAddress (EthCrossChainUtils.sol#540) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 573,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function hashLeaf(bytes memory _data) internal pure returns (bytes32 result)  {\n",
          "message": "Parameter '_data' of Utils.hashLeaf (EthCrossChainUtils.sol#573) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 582,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function hashChildren(bytes32 _l, bytes32  _r) internal pure returns (bytes32 result)  {\n",
          "message": "Parameter '_l' of Utils.hashChildren (EthCrossChainUtils.sol#582) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 582,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function hashChildren(bytes32 _l, bytes32  _r) internal pure returns (bytes32 result)  {\n",
          "message": "Parameter '_r' of Utils.hashChildren (EthCrossChainUtils.sol#582) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 672,
          "vulnerability_to_line": null,
          "vulnerability_code": "        bytes memory _bytes,\n",
          "message": "Parameter '_bytes' of Utils.slice (EthCrossChainUtils.sol#672) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 673,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint _start,\n",
          "message": "Parameter '_start' of Utils.slice (EthCrossChainUtils.sol#673) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 674,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint _length\n",
          "message": "Parameter '_length' of Utils.slice (EthCrossChainUtils.sol#674) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 742,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function containMAddresses(address[] memory _keepers, address[] memory _signers, uint _m) internal pure returns (bool){\n",
          "message": "Parameter '_keepers' of Utils.containMAddresses (EthCrossChainUtils.sol#742) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 742,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function containMAddresses(address[] memory _keepers, address[] memory _signers, uint _m) internal pure returns (bool){\n",
          "message": "Parameter '_signers' of Utils.containMAddresses (EthCrossChainUtils.sol#742) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 742,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function containMAddresses(address[] memory _keepers, address[] memory _signers, uint _m) internal pure returns (bool){\n",
          "message": "Parameter '_m' of Utils.containMAddresses (EthCrossChainUtils.sol#742) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1005,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function merkleProve(bytes memory _auditPath, bytes32 _root) internal pure returns (bytes memory) {\n",
          "message": "Parameter '_auditPath' of ECCUtils.merkleProve (EthCrossChainUtils.sol#1005) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1005,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function merkleProve(bytes memory _auditPath, bytes32 _root) internal pure returns (bytes memory) {\n",
          "message": "Parameter '_root' of ECCUtils.merkleProve (EthCrossChainUtils.sol#1005) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1035,
          "vulnerability_to_line": 1051,
          "vulnerability_code": "    function _getBookKeeper(uint _keyLen, uint _m, bytes memory _pubKeyList) internal pure returns (bytes20, address[] memory){\n\n         bytes memory buff;\n\n         buff = ZeroCopySink.WriteUint16(uint16(_keyLen));\n\n         address[] memory keepers = new address[](_keyLen);\n\n         bytes32 hash;\n\n         bytes memory publicKey;\n\n         for(uint i = 0; i < _keyLen; i++){\n\n             publicKey = Utils.slice(_pubKeyList, i*POLYCHAIN_PUBKEY_LEN, POLYCHAIN_PUBKEY_LEN);\n\n             buff =  abi.encodePacked(buff, ZeroCopySink.WriteVarBytes(Utils.compressMCPubKey(publicKey)));\n\n             hash = keccak256(Utils.slice(publicKey, 3, 64));\n\n             keepers[i] = address(uint160(uint256(hash)));\n\n         }\n\n\n\n         buff = abi.encodePacked(buff, ZeroCopySink.WriteUint16(uint16(_m)));\n\n         bytes20  nextBookKeeper = ripemd160(abi.encodePacked(sha256(buff)));\n\n         return (nextBookKeeper, keepers);\n",
          "message": "Function 'ECCUtils._getBookKeeper' (EthCrossChainUtils.sol#1035-1051) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1035,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _getBookKeeper(uint _keyLen, uint _m, bytes memory _pubKeyList) internal pure returns (bytes20, address[] memory){\n",
          "message": "Parameter '_keyLen' of ECCUtils._getBookKeeper (EthCrossChainUtils.sol#1035) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1035,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _getBookKeeper(uint _keyLen, uint _m, bytes memory _pubKeyList) internal pure returns (bytes20, address[] memory){\n",
          "message": "Parameter '_m' of ECCUtils._getBookKeeper (EthCrossChainUtils.sol#1035) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1035,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _getBookKeeper(uint _keyLen, uint _m, bytes memory _pubKeyList) internal pure returns (bytes20, address[] memory){\n",
          "message": "Parameter '_pubKeyList' of ECCUtils._getBookKeeper (EthCrossChainUtils.sol#1035) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1058,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function verifyPubkey(bytes memory _pubKeyList) internal pure returns (bytes20, address[] memory) {\n",
          "message": "Parameter '_pubKeyList' of ECCUtils.verifyPubkey (EthCrossChainUtils.sol#1058) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1072,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function verifySig(bytes memory _rawHeader, bytes memory _sigList, address[] memory _keepers, uint _m) internal pure returns (bool){\n",
          "message": "Parameter '_rawHeader' of ECCUtils.verifySig (EthCrossChainUtils.sol#1072) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1072,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function verifySig(bytes memory _rawHeader, bytes memory _sigList, address[] memory _keepers, uint _m) internal pure returns (bool){\n",
          "message": "Parameter '_sigList' of ECCUtils.verifySig (EthCrossChainUtils.sol#1072) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1072,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function verifySig(bytes memory _rawHeader, bytes memory _sigList, address[] memory _keepers, uint _m) internal pure returns (bool){\n",
          "message": "Parameter '_keepers' of ECCUtils.verifySig (EthCrossChainUtils.sol#1072) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1072,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function verifySig(bytes memory _rawHeader, bytes memory _sigList, address[] memory _keepers, uint _m) internal pure returns (bool){\n",
          "message": "Parameter '_m' of ECCUtils.verifySig (EthCrossChainUtils.sol#1072) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1124,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function deserializeMerkleValue(bytes memory _valueBs) internal pure returns (ToMerkleValue memory) {\n",
          "message": "Parameter '_valueBs' of ECCUtils.deserializeMerkleValue (EthCrossChainUtils.sol#1124) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1156,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function deserializeHeader(bytes memory _headerBs) internal pure returns (Header memory) {\n",
          "message": "Parameter '_headerBs' of ECCUtils.deserializeHeader (EthCrossChainUtils.sol#1156) is not in mixedCase\n"
        }
      ]
    },
    "smartcheck": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 33,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (v == 0x01) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 35,
          "vulnerability_to_line": null,
          "vulnerability_code": "    \t} else if (v == 0x00) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 273,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (v == 0xFD) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 276,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(value >= 0xFD && value <= 0xFFFF, \"NextUint16, value outside range\");\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 276,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(value >= 0xFD && value <= 0xFFFF, \"NextUint16, value outside range\");\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 278,
          "vulnerability_to_line": null,
          "vulnerability_code": "        } else if (v == 0xFE) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 281,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(value > 0xFFFF && value <= 0xFFFFFFFF, \"NextVarUint, value outside range\");\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 281,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(value > 0xFFFF && value <= 0xFFFFFFFF, \"NextVarUint, value outside range\");\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 283,
          "vulnerability_to_line": null,
          "vulnerability_code": "        } else if (v == 0xFF) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 286,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(value > 0xFFFFFFFF, \"NextVarUint, value outside range\");\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 291,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(value < 0xFD, \"NextVarUint, value outside range\");\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 473,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (v < 0xFD){\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 475,
          "vulnerability_to_line": null,
          "vulnerability_code": "    \t} else if (v <= 0xFFFF) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 476,
          "vulnerability_to_line": null,
          "vulnerability_code": "    \t\treturn abi.encodePacked(WriteByte(0xFD), WriteUint16(uint16(v)));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 477,
          "vulnerability_to_line": null,
          "vulnerability_code": "    \t} else if (v <= 0xFFFFFFFF) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 478,
          "vulnerability_to_line": null,
          "vulnerability_code": "            return abi.encodePacked(WriteByte(0xFE), WriteUint32(uint32(v)));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 480,
          "vulnerability_to_line": null,
          "vulnerability_code": "    \t\treturn abi.encodePacked(WriteByte(0xFF), WriteUint64(uint64(v)));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 583,
          "vulnerability_to_line": null,
          "vulnerability_code": "        result = sha256(abi.encodePacked(bytes1(0x01), _l, _r));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 763,
          "vulnerability_to_line": null,
          "vulnerability_code": "             newkey[2] = byte(0x02);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 765,
          "vulnerability_to_line": null,
          "vulnerability_code": "             newkey[2] = byte(0x03);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 1017,
          "vulnerability_to_line": null,
          "vulnerability_code": "            if (pos == 0x00) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 1019,
          "vulnerability_to_line": null,
          "vulnerability_code": "            } else if (pos == 0x01) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 574,
          "vulnerability_to_line": null,
          "vulnerability_code": "        result = sha256(abi.encodePacked(byte(0x0), _data));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 744,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(uint i = 0; i < _signers.length; i++){\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 745,
          "vulnerability_to_line": null,
          "vulnerability_code": "            for (uint j = 0; j < _keepers.length; j++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
          "vulnerability_from_line": 496,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function bytesToBytes32(bytes memory _bs) internal pure returns (bytes32 value) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
          "vulnerability_from_line": 521,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function uint256ToBytes(uint256 _value) internal pure returns (bytes memory bs) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
          "vulnerability_from_line": 540,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function bytesToAddress(bytes memory _bs) internal pure returns (address addr)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
          "vulnerability_from_line": 555,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function addressToBytes(address _addr) internal pure returns (bytes memory bs){\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 744,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(uint i = 0; i < _signers.length; i++){\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 745,
          "vulnerability_to_line": null,
          "vulnerability_code": "            for (uint j = 0; j < _keepers.length; j++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 1097,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(uint i = 0; i < keeperLen; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 299,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 487,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 800,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 959,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_REVERT_REQUIRE",
          "vulnerability_from_line": 35,
          "vulnerability_to_line": null,
          "vulnerability_code": "    \t} else if (v == 0x00) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_REVERT_REQUIRE",
          "vulnerability_from_line": 1019,
          "vulnerability_to_line": null,
          "vulnerability_code": "            } else if (pos == 0x01) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SAFEMATH",
          "vulnerability_from_line": 965,
          "vulnerability_to_line": null,
          "vulnerability_code": "    using SafeMath for uint256;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 25,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function NextBool(bytes memory buff, uint256 offset) internal pure returns(bool, uint256) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 48,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function NextByte(bytes memory buff, uint256 offset) internal pure returns (byte, uint256) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 62,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function NextUint8(bytes memory buff, uint256 offset) internal pure returns (uint8, uint256) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 80,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function NextUint16(bytes memory buff, uint256 offset) internal pure returns (uint16, uint256) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 101,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function NextUint32(bytes memory buff, uint256 offset) internal pure returns (uint32, uint256) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 128,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function NextUint64(bytes memory buff, uint256 offset) internal pure returns (uint64, uint256) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 156,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function NextUint255(bytes memory buff, uint256 offset) internal pure returns (uint256, uint256) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 184,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function NextVarBytes(bytes memory buff, uint256 offset) internal pure returns(bytes memory, uint256) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 245,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function NextHash(bytes memory buff, uint256 offset) internal pure returns (bytes32 , uint256) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 259,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function NextBytes20(bytes memory buff, uint256 offset) internal pure returns (bytes20 , uint256) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 320,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function WriteBool(bool b) internal pure returns (bytes memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 351,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function WriteUint8(uint8 v) internal pure returns (bytes memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 367,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function WriteUint16(uint16 v) internal pure returns (bytes memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 392,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function WriteUint32(uint32 v) internal pure returns(bytes memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 416,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function WriteUint64(uint64 v) internal pure returns(bytes memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 441,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function WriteUint255(uint256 v) internal pure returns (bytes memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 496,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function bytesToBytes32(bytes memory _bs) internal pure returns (bytes32 value) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 508,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function bytesToUint256(bytes memory _bs) internal pure returns (uint256 value) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 521,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function uint256ToBytes(uint256 _value) internal pure returns (bytes memory bs) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 540,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function bytesToAddress(bytes memory _bs) internal pure returns (address addr)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 555,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function addressToBytes(address _addr) internal pure returns (bytes memory bs){\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 671,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function slice(\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
          "vulnerability_from_line": 592,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function equalStorage(bytes storage _preBytes, bytes memory _postBytes) internal view returns (bool) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
          "vulnerability_from_line": 782,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function isContract(address account) internal view returns (bool) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 25,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function NextBool(bytes memory buff, uint256 offset) internal pure returns(bool, uint256) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 48,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function NextByte(bytes memory buff, uint256 offset) internal pure returns (byte, uint256) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 62,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function NextUint8(bytes memory buff, uint256 offset) internal pure returns (uint8, uint256) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 80,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function NextUint16(bytes memory buff, uint256 offset) internal pure returns (uint16, uint256) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 101,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function NextUint32(bytes memory buff, uint256 offset) internal pure returns (uint32, uint256) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 128,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function NextUint64(bytes memory buff, uint256 offset) internal pure returns (uint64, uint256) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 156,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function NextUint255(bytes memory buff, uint256 offset) internal pure returns (uint256, uint256) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 184,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function NextVarBytes(bytes memory buff, uint256 offset) internal pure returns(bytes memory, uint256) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 245,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function NextHash(bytes memory buff, uint256 offset) internal pure returns (bytes32 , uint256) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 259,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function NextBytes20(bytes memory buff, uint256 offset) internal pure returns (bytes20 , uint256) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 268,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function NextVarUint(bytes memory buff, uint256 offset) internal pure returns(uint, uint256) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 1035,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _getBookKeeper(uint _keyLen, uint _m, bytes memory _pubKeyList) internal pure returns (bytes20, address[] memory){\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 1058,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function verifyPubkey(bytes memory _pubKeyList) internal pure returns (bytes20, address[] memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 29,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly{\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 51,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly{\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 65,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly{\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 84,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 104,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 131,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 159,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 189,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly{\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 248,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 262,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 322,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly{\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 353,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly{\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 370,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly{\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 394,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly{\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 419,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly{\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 445,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly{\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 498,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 510,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 523,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 543,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 556,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 595,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 684,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 793,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly { codehash := extcodehash(account) }\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 997,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint constant POLYCHAIN_PUBKEY_LEN = 67;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 998,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint constant POLYCHAIN_SIGNATURE_LEN = 65;\n",
          "message": null
        }
      ]
    },
    "oyente": {
      "successfull_analysis": false,
      "errors": [
        "exception (IndexError: pop from empty list)"
      ],
      "vulnerability_findings": []
    },
    "mythril": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": []
    },
    "osiris": {
      "successfull_analysis": false,
      "errors": [
        "Solidity compilation failed"
      ],
      "vulnerability_findings": []
    }
  }
}