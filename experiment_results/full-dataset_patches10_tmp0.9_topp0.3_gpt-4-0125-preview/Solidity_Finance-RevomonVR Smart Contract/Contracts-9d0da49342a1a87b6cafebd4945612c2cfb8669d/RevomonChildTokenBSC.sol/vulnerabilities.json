{
  "smartbugs_completed": true,
  "analyzer_results": {
    "semgrep": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 654,
          "vulnerability_to_line": null,
          "vulnerability_code": "            for (uint256 i = 0; i < _lgeWhitelistRounds.length; i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 19,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor () internal { }\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 503,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor (string memory name, string memory symbol, uint8 decimals) public {\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 504,
          "vulnerability_to_line": null,
          "vulnerability_code": "        _name = name;\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 505,
          "vulnerability_to_line": null,
          "vulnerability_code": "        _symbol = symbol;\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 506,
          "vulnerability_to_line": null,
          "vulnerability_code": "        _decimals = decimals;\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 507,
          "vulnerability_to_line": null,
          "vulnerability_code": "    }\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 561,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor () internal {\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 562,
          "vulnerability_to_line": null,
          "vulnerability_code": "        _whitelister = _msgSender();\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 563,
          "vulnerability_to_line": null,
          "vulnerability_code": "    }\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 711,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor () public ERC20Detailed(\"Revomon\", \"REVO\", 18) {\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 712,
          "vulnerability_to_line": null,
          "vulnerability_code": "        _mint(_msgSender(), 100000000000000000000000000);\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 713,
          "vulnerability_to_line": null,
          "vulnerability_code": "    }\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 604,
          "vulnerability_to_line": null,
          "vulnerability_code": "                _lgeWhitelistRounds.push(WhitelistRound(durations[i], amountsMax[i]));\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 630,
          "vulnerability_to_line": null,
          "vulnerability_code": "            _lgeWhitelistRounds[index].addresses[addresses[i]] = enabled;\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 654,
          "vulnerability_to_line": null,
          "vulnerability_code": "            for (uint256 i = 0; i < _lgeWhitelistRounds.length; i++) {\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 656,
          "vulnerability_to_line": null,
          "vulnerability_code": "                WhitelistRound storage wlRound = _lgeWhitelistRounds[i];\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 603,
          "vulnerability_to_line": null,
          "vulnerability_code": "            for (uint256 i = 0; i < durations.length; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 629,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 i = 0; i < addresses.length; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 654,
          "vulnerability_to_line": null,
          "vulnerability_code": "            for (uint256 i = 0; i < _lgeWhitelistRounds.length; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 132,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(c >= a, \"SafeMath: addition overflow\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 186,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(c / a == b, \"SafeMath: multiplication overflow\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 412,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(sender != address(0), \"ERC20: transfer from the zero address\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 413,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 430,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(account != address(0), \"ERC20: mint to the zero address\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 449,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(account != address(0), \"ERC20: burn from the zero address\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 470,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(owner != address(0), \"ERC20: approve from the zero address\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 471,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(spender != address(0), \"ERC20: approve to the zero address\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 566,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_whitelister == _msgSender(), \"Caller is not the whitelister\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 580,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(newWhitelister != address(0), \"New whitelister is the zero address\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 595,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(durations.length == amountsMax.length, \"Invalid whitelist(s)\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 620,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(index < _lgeWhitelistRounds.length, \"Invalid index\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 621,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(amountMax > 0, \"Invalid amountMax\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 690,
          "vulnerability_to_line": null,
          "vulnerability_code": "                require(wlRound.addresses[recipient], \"LGE - Buyer is not whitelisted\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 697,
          "vulnerability_to_line": null,
          "vulnerability_code": "                require(amount <= amountRemaining, \"LGE - Amount exceeds whitelist maximum\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 678,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if(_lgeTimestamp == 0 && sender != _lgePairAddress && recipient == _lgePairAddress && amount > 0)\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 679,
          "vulnerability_to_line": null,
          "vulnerability_code": "            _lgeTimestamp = now;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 681,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if(sender == _lgePairAddress && recipient != _lgePairAddress) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 682,
          "vulnerability_to_line": null,
          "vulnerability_code": "            //buying\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 683,
          "vulnerability_to_line": null,
          "vulnerability_code": "            \n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 684,
          "vulnerability_to_line": null,
          "vulnerability_code": "            (uint256 wlRoundNumber,,,,,) = getLGEWhitelistRound();\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 685,
          "vulnerability_to_line": null,
          "vulnerability_code": "        \n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 686,
          "vulnerability_to_line": null,
          "vulnerability_code": "            if(wlRoundNumber > 0) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 687,
          "vulnerability_to_line": null,
          "vulnerability_code": "                \n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 688,
          "vulnerability_to_line": null,
          "vulnerability_code": "                WhitelistRound storage wlRound = _lgeWhitelistRounds[wlRoundNumber.sub(1)];\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 689,
          "vulnerability_to_line": null,
          "vulnerability_code": "                \n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 690,
          "vulnerability_to_line": null,
          "vulnerability_code": "                require(wlRound.addresses[recipient], \"LGE - Buyer is not whitelisted\");\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 603,
          "vulnerability_to_line": null,
          "vulnerability_code": "            for (uint256 i = 0; i < durations.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 629,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 i = 0; i < addresses.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 654,
          "vulnerability_to_line": null,
          "vulnerability_code": "            for (uint256 i = 0; i < _lgeWhitelistRounds.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 186,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(c / a == b, \"SafeMath: multiplication overflow\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 412,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(sender != address(0), \"ERC20: transfer from the zero address\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 413,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 449,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(account != address(0), \"ERC20: burn from the zero address\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 470,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(owner != address(0), \"ERC20: approve from the zero address\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 471,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(spender != address(0), \"ERC20: approve to the zero address\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 580,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(newWhitelister != address(0), \"New whitelister is the zero address\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 697,
          "vulnerability_to_line": null,
          "vulnerability_code": "                require(amount <= amountRemaining, \"LGE - Amount exceeds whitelist maximum\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        }
      ]
    },
    "slither": {
      "successfull_analysis": true,
      "errors": [
        "EXIT_CODE_36"
      ],
      "vulnerability_findings": [
        {
          "name": "incorrect-equality",
          "vulnerability_from_line": 673,
          "vulnerability_to_line": 704,
          "vulnerability_code": "    function _applyLGEWhitelist(address sender, address recipient, uint256 amount) internal {\n\n        \n\n        if(_lgePairAddress == address(0) || _lgeWhitelistRounds.length == 0)\n\n            return;\n\n        \n\n        if(_lgeTimestamp == 0 && sender != _lgePairAddress && recipient == _lgePairAddress && amount > 0)\n\n            _lgeTimestamp = now;\n\n        \n\n        if(sender == _lgePairAddress && recipient != _lgePairAddress) {\n\n            //buying\n\n            \n\n            (uint256 wlRoundNumber,,,,,) = getLGEWhitelistRound();\n\n        \n\n            if(wlRoundNumber > 0) {\n\n                \n\n                WhitelistRound storage wlRound = _lgeWhitelistRounds[wlRoundNumber.sub(1)];\n\n                \n\n                require(wlRound.addresses[recipient], \"LGE - Buyer is not whitelisted\");\n\n                \n\n                uint256 amountRemaining = 0;\n\n                \n\n                if(wlRound.purchased[recipient] < wlRound.amountMax)\n\n                    amountRemaining = wlRound.amountMax.sub(wlRound.purchased[recipient]);\n\n    \n\n                require(amount <= amountRemaining, \"LGE - Amount exceeds whitelist maximum\");\n\n                wlRound.purchased[recipient] = wlRound.purchased[recipient].add(amount);\n\n                \n\n            }\n\n            \n\n        }\n\n        \n",
          "message": "LGEWhitelisted._applyLGEWhitelist (RevomonChildTokenBSC.sol#673-704) uses a dangerous strict equality:\n\t- _lgeTimestamp == 0 && sender != _lgePairAddress && recipient == _lgePairAddress && amount > 0\n"
        },
        {
          "name": "shadowing-local",
          "vulnerability_from_line": 503,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor (string memory name, string memory symbol, uint8 decimals) public {\n",
          "message": "ERC20Detailed.constructor.name (local variable @ RevomonChildTokenBSC.sol#503) shadows:\n\t- ERC20Detailed.name (function @ RevomonChildTokenBSC.sol#512-514)\n"
        },
        {
          "name": "shadowing-local",
          "vulnerability_from_line": 503,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor (string memory name, string memory symbol, uint8 decimals) public {\n",
          "message": "ERC20Detailed.constructor.symbol (local variable @ RevomonChildTokenBSC.sol#503) shadows:\n\t- ERC20Detailed.symbol (function @ RevomonChildTokenBSC.sol#520-522)\n"
        },
        {
          "name": "shadowing-local",
          "vulnerability_from_line": 503,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor (string memory name, string memory symbol, uint8 decimals) public {\n",
          "message": "ERC20Detailed.constructor.decimals (local variable @ RevomonChildTokenBSC.sol#503) shadows:\n\t- ERC20Detailed.decimals (function @ RevomonChildTokenBSC.sol#536-538)\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 300,
          "vulnerability_to_line": 302,
          "vulnerability_code": "    function totalSupply() public view returns (uint256) {\n\n        return _totalSupply;\n",
          "message": "ERC20.totalSupply (RevomonChildTokenBSC.sol#300-302) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 40,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function totalSupply() external view returns (uint256);\n",
          "message": "IERC20.totalSupply (RevomonChildTokenBSC.sol#40) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 45,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function balanceOf(address account) external view returns (uint256);\n",
          "message": "IERC20.balanceOf (RevomonChildTokenBSC.sol#45) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 307,
          "vulnerability_to_line": 309,
          "vulnerability_code": "    function balanceOf(address account) public view returns (uint256) {\n\n        return _balances[account];\n",
          "message": "ERC20.balanceOf (RevomonChildTokenBSC.sol#307-309) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 54,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function transfer(address recipient, uint256 amount) external returns (bool);\n",
          "message": "IERC20.transfer (RevomonChildTokenBSC.sol#54) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 319,
          "vulnerability_to_line": 322,
          "vulnerability_code": "    function transfer(address recipient, uint256 amount) public returns (bool) {\n\n        _transfer(_msgSender(), recipient, amount);\n\n        return true;\n",
          "message": "ERC20.transfer (RevomonChildTokenBSC.sol#319-322) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 327,
          "vulnerability_to_line": 329,
          "vulnerability_code": "    function allowance(address owner, address spender) public view returns (uint256) {\n\n        return _allowances[owner][spender];\n",
          "message": "ERC20.allowance (RevomonChildTokenBSC.sol#327-329) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 63,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function allowance(address owner, address spender) external view returns (uint256);\n",
          "message": "IERC20.allowance (RevomonChildTokenBSC.sol#63) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 338,
          "vulnerability_to_line": 341,
          "vulnerability_code": "    function approve(address spender, uint256 amount) public returns (bool) {\n\n        _approve(_msgSender(), spender, amount);\n\n        return true;\n",
          "message": "ERC20.approve (RevomonChildTokenBSC.sol#338-341) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 79,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function approve(address spender, uint256 amount) external returns (bool);\n",
          "message": "IERC20.approve (RevomonChildTokenBSC.sol#79) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 355,
          "vulnerability_to_line": 359,
          "vulnerability_code": "    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\n\n        _transfer(sender, recipient, amount);\n\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n\n        return true;\n",
          "message": "ERC20.transferFrom (RevomonChildTokenBSC.sol#355-359) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 90,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n",
          "message": "IERC20.transferFrom (RevomonChildTokenBSC.sol#90) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 373,
          "vulnerability_to_line": 376,
          "vulnerability_code": "    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n\n        return true;\n",
          "message": "ERC20.increaseAllowance (RevomonChildTokenBSC.sol#373-376) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 392,
          "vulnerability_to_line": 395,
          "vulnerability_code": "    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n\n        return true;\n",
          "message": "ERC20.decreaseAllowance (RevomonChildTokenBSC.sol#392-395) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 512,
          "vulnerability_to_line": 514,
          "vulnerability_code": "    function name() public view returns (string memory) {\n\n        return _name;\n",
          "message": "ERC20Detailed.name (RevomonChildTokenBSC.sol#512-514) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 520,
          "vulnerability_to_line": 522,
          "vulnerability_code": "    function symbol() public view returns (string memory) {\n\n        return _symbol;\n",
          "message": "ERC20Detailed.symbol (RevomonChildTokenBSC.sol#520-522) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 536,
          "vulnerability_to_line": 538,
          "vulnerability_code": "    function decimals() public view returns (uint8) {\n\n        return _decimals;\n",
          "message": "ERC20Detailed.decimals (RevomonChildTokenBSC.sol#536-538) should be declared external\n"
        },
        {
          "name": "solc-version",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.0;\n",
          "message": "Detected issues with version pragma in RevomonChildTokenBSC.sol:\n\t- pragma solidity^0.5.0 (RevomonChildTokenBSC.sol#3): it allows old versions\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 22,
          "vulnerability_to_line": 24,
          "vulnerability_code": "    function _msgSender() internal view returns (address payable) {\n\n        return msg.sender;\n",
          "message": "Function 'Context._msgSender' (RevomonChildTokenBSC.sol#22-24) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 26,
          "vulnerability_to_line": 29,
          "vulnerability_code": "    function _msgData() internal view returns (bytes memory) {\n\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n\n        return msg.data;\n",
          "message": "Function 'Context._msgData' (RevomonChildTokenBSC.sol#26-29) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 411,
          "vulnerability_to_line": 418,
          "vulnerability_code": "    function _transfer(address sender, address recipient, uint256 amount) internal {\n\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n\n        _balances[recipient] = _balances[recipient].add(amount);\n\n        emit Transfer(sender, recipient, amount);\n",
          "message": "Function 'ERC20._transfer' (RevomonChildTokenBSC.sol#411-418) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 429,
          "vulnerability_to_line": 435,
          "vulnerability_code": "    function _mint(address account, uint256 amount) internal {\n\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n\n\n        _totalSupply = _totalSupply.add(amount);\n\n        _balances[account] = _balances[account].add(amount);\n\n        emit Transfer(address(0), account, amount);\n",
          "message": "Function 'ERC20._mint' (RevomonChildTokenBSC.sol#429-435) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 448,
          "vulnerability_to_line": 454,
          "vulnerability_code": "    function _burn(address account, uint256 amount) internal {\n\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n\n        _totalSupply = _totalSupply.sub(amount);\n\n        emit Transfer(account, address(0), amount);\n",
          "message": "Function 'ERC20._burn' (RevomonChildTokenBSC.sol#448-454) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 469,
          "vulnerability_to_line": 475,
          "vulnerability_code": "    function _approve(address owner, address spender, uint256 amount) internal {\n\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n\n\n        _allowances[owner][spender] = amount;\n\n        emit Approval(owner, spender, amount);\n",
          "message": "Function 'ERC20._approve' (RevomonChildTokenBSC.sol#469-475) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 483,
          "vulnerability_to_line": 486,
          "vulnerability_code": "    function _burnFrom(address account, uint256 amount) internal {\n\n        _burn(account, amount);\n\n        _approve(account, _msgSender(), _allowances[account][_msgSender()].sub(amount, \"ERC20: burn amount exceeds allowance\"));\n",
          "message": "Function 'ERC20._burnFrom' (RevomonChildTokenBSC.sol#483-486) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 579,
          "vulnerability_to_line": 583,
          "vulnerability_code": "    function _transferWhitelister(address newWhitelister) internal {\n\n        require(newWhitelister != address(0), \"New whitelister is the zero address\");\n\n        emit WhitelisterTransferred(_whitelister, newWhitelister);\n\n        _whitelister = newWhitelister;\n",
          "message": "Function 'LGEWhitelisted._transferWhitelister' (RevomonChildTokenBSC.sol#579-583) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 673,
          "vulnerability_to_line": 704,
          "vulnerability_code": "    function _applyLGEWhitelist(address sender, address recipient, uint256 amount) internal {\n\n        \n\n        if(_lgePairAddress == address(0) || _lgeWhitelistRounds.length == 0)\n\n            return;\n\n        \n\n        if(_lgeTimestamp == 0 && sender != _lgePairAddress && recipient == _lgePairAddress && amount > 0)\n\n            _lgeTimestamp = now;\n\n        \n\n        if(sender == _lgePairAddress && recipient != _lgePairAddress) {\n\n            //buying\n\n            \n\n            (uint256 wlRoundNumber,,,,,) = getLGEWhitelistRound();\n\n        \n\n            if(wlRoundNumber > 0) {\n\n                \n\n                WhitelistRound storage wlRound = _lgeWhitelistRounds[wlRoundNumber.sub(1)];\n\n                \n\n                require(wlRound.addresses[recipient], \"LGE - Buyer is not whitelisted\");\n\n                \n\n                uint256 amountRemaining = 0;\n\n                \n\n                if(wlRound.purchased[recipient] < wlRound.amountMax)\n\n                    amountRemaining = wlRound.amountMax.sub(wlRound.purchased[recipient]);\n\n    \n\n                require(amount <= amountRemaining, \"LGE - Amount exceeds whitelist maximum\");\n\n                wlRound.purchased[recipient] = wlRound.purchased[recipient].add(amount);\n\n                \n\n            }\n\n            \n\n        }\n\n        \n",
          "message": "Function 'LGEWhitelisted._applyLGEWhitelist' (RevomonChildTokenBSC.sol#673-704) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 552,
          "vulnerability_to_line": null,
          "vulnerability_code": "    WhitelistRound[] public _lgeWhitelistRounds;\n",
          "message": "Variable 'LGEWhitelisted._lgeWhitelistRounds' (RevomonChildTokenBSC.sol#552) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 554,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint256 public _lgeTimestamp;\n",
          "message": "Variable 'LGEWhitelisted._lgeTimestamp' (RevomonChildTokenBSC.sol#554) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 555,
          "vulnerability_to_line": null,
          "vulnerability_code": "    address public _lgePairAddress;\n",
          "message": "Variable 'LGEWhitelisted._lgePairAddress' (RevomonChildTokenBSC.sol#555) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 557,
          "vulnerability_to_line": null,
          "vulnerability_code": "    address public _whitelister;\n",
          "message": "Variable 'LGEWhitelisted._whitelister' (RevomonChildTokenBSC.sol#557) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 715,
          "vulnerability_to_line": 718,
          "vulnerability_code": "    function _transfer(address sender, address recipient, uint256 amount) internal {\n\n        _applyLGEWhitelist(sender, recipient, amount);\n\n        super._transfer(sender, recipient, amount);\n",
          "message": "Function 'RevoToken._transfer' (RevomonChildTokenBSC.sol#715-718) is not in mixedCase\n"
        }
      ]
    },
    "smartcheck": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 572,
          "vulnerability_to_line": null,
          "vulnerability_code": "        _whitelister = address(0);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ERC20_APPROVE",
          "vulnerability_from_line": 338,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function approve(address spender, uint256 amount) public returns (bool) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 291,
          "vulnerability_to_line": null,
          "vulnerability_code": "    mapping (address => uint256) private _balances;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 293,
          "vulnerability_to_line": null,
          "vulnerability_code": "    mapping (address => mapping (address => uint256)) private _allowances;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 295,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint256 private _totalSupply;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 494,
          "vulnerability_to_line": null,
          "vulnerability_code": "    string private _name;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 495,
          "vulnerability_to_line": null,
          "vulnerability_code": "    string private _symbol;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 496,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint8 private _decimals;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SAFEMATH",
          "vulnerability_from_line": 289,
          "vulnerability_to_line": null,
          "vulnerability_code": "    using SafeMath for uint256;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SAFEMATH",
          "vulnerability_from_line": 543,
          "vulnerability_to_line": null,
          "vulnerability_code": "    using SafeMath for uint256;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 594,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function createLGEWhitelist(address pairAddress, uint256[] calldata durations, uint256[] calldata amountsMax) external onlyWhitelister() {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 594,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function createLGEWhitelist(address pairAddress, uint256[] calldata durations, uint256[] calldata amountsMax) external onlyWhitelister() {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 594,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function createLGEWhitelist(address pairAddress, uint256[] calldata durations, uint256[] calldata amountsMax) external onlyWhitelister() {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 594,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function createLGEWhitelist(address pairAddress, uint256[] calldata durations, uint256[] calldata amountsMax) external onlyWhitelister() {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 595,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(durations.length == amountsMax.length, \"Invalid whitelist(s)\");\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 595,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(durations.length == amountsMax.length, \"Invalid whitelist(s)\");\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 597,
          "vulnerability_to_line": null,
          "vulnerability_code": "        _lgePairAddress = pairAddress;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 599,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if(durations.length > 0) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 603,
          "vulnerability_to_line": null,
          "vulnerability_code": "            for (uint256 i = 0; i < durations.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 603,
          "vulnerability_to_line": null,
          "vulnerability_code": "            for (uint256 i = 0; i < durations.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 603,
          "vulnerability_to_line": null,
          "vulnerability_code": "            for (uint256 i = 0; i < durations.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 604,
          "vulnerability_to_line": null,
          "vulnerability_code": "                _lgeWhitelistRounds.push(WhitelistRound(durations[i], amountsMax[i]));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 604,
          "vulnerability_to_line": null,
          "vulnerability_code": "                _lgeWhitelistRounds.push(WhitelistRound(durations[i], amountsMax[i]));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 604,
          "vulnerability_to_line": null,
          "vulnerability_code": "                _lgeWhitelistRounds.push(WhitelistRound(durations[i], amountsMax[i]));\n",
          "message": null
        }
      ]
    },
    "oyente": {
      "successfull_analysis": false,
      "errors": [
        "exception (RuntimeError: Source map error, unknown name(SHR) or instr_name(INVALID))"
      ],
      "vulnerability_findings": []
    },
    "mythril": {
      "successfull_analysis": false,
      "errors": [
        "DOCKER_TIMEOUT"
      ],
      "vulnerability_findings": []
    },
    "osiris": {
      "successfull_analysis": false,
      "errors": [
        "Solidity compilation failed"
      ],
      "vulnerability_findings": []
    }
  }
}