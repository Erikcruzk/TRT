{
  "smartbugs_completed": true,
  "analyzer_results": {
    "semgrep": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 30,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor () public {\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 31,
          "vulnerability_to_line": null,
          "vulnerability_code": "        DOMAIN_SEPARATOR = keccak256(abi.encode(\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 32,
          "vulnerability_to_line": null,
          "vulnerability_code": "            EIP712DOMAIN_TYPEHASH,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 33,
          "vulnerability_to_line": null,
          "vulnerability_code": "            keccak256(\"Opium Network\"),\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 34,
          "vulnerability_to_line": null,
          "vulnerability_code": "            keccak256(\"1\"),\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 35,
          "vulnerability_to_line": null,
          "vulnerability_code": "            address(this)\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 36,
          "vulnerability_to_line": null,
          "vulnerability_code": "        ));\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 37,
          "vulnerability_to_line": null,
          "vulnerability_code": "    }\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 208,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_signature.length == 65, \"ORDER:INVALID_SIGNATURE_LENGTH\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 240,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (v != 27 && v != 28) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 241,
          "vulnerability_to_line": null,
          "vulnerability_code": "            return (address(0));\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 242,
          "vulnerability_to_line": null,
          "vulnerability_code": "        } else {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 243,
          "vulnerability_to_line": null,
          "vulnerability_code": "            // solium-disable-next-line arg-overflow\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 244,
          "vulnerability_to_line": null,
          "vulnerability_code": "            return ecrecover(_hash, v, r, s);\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 245,
          "vulnerability_to_line": null,
          "vulnerability_code": "        }\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        }
      ]
    },
    "slither": {
      "successfull_analysis": true,
      "errors": [
        "EXIT_CODE_12"
      ],
      "vulnerability_findings": [
        {
          "name": "constant-function",
          "vulnerability_from_line": 42,
          "vulnerability_to_line": 57,
          "vulnerability_code": "    function hashEIP712Message(bytes32 hashStruct) internal view returns (bytes32 result) {\n\n        bytes32 domainSeparator = DOMAIN_SEPARATOR;\n\n\n\n        assembly {\n\n            // Load free memory pointer\n\n            let memPtr := mload(64)\n\n\n\n            mstore(memPtr, 0x1901000000000000000000000000000000000000000000000000000000000000)  // EIP191 header\n\n            mstore(add(memPtr, 2), domainSeparator)                                            // EIP712 domain hash\n\n            mstore(add(memPtr, 34), hashStruct)                                                 // Hash of struct\n\n\n\n            // Compute hash\n\n            result := keccak256(memPtr, 66)\n\n        }\n\n        return result;\n",
          "message": "LibEIP712.hashEIP712Message (LibOrder.sol#42-57) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 219,
          "vulnerability_to_line": 246,
          "vulnerability_code": "    function retrieveAddress(bytes32 _hash, bytes memory _signature) private pure returns (address) {\n\n        bytes32 r;\n\n        bytes32 s;\n\n        uint8 v;\n\n\n\n        // Divide the signature in r, s and v variables\n\n        // ecrecover takes the signature parameters, and the only way to get them\n\n        // currently is to use assembly.\n\n        // solium-disable-next-line security/no-inline-assembly\n\n        assembly {\n\n            r := mload(add(_signature, 32))\n\n            s := mload(add(_signature, 64))\n\n            v := byte(0, mload(add(_signature, 96)))\n\n        }\n\n\n\n        // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\n\n        if (v < 27) {\n\n            v += 27;\n\n        }\n\n\n\n        // If the version is correct return the signer address\n\n        if (v != 27 && v != 28) {\n\n            return (address(0));\n\n        } else {\n\n            // solium-disable-next-line arg-overflow\n\n            return ecrecover(_hash, v, r, s);\n\n        }\n",
          "message": "LibOrder.retrieveAddress (LibOrder.sol#219-246) is declared view but contains assembly code\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 42,
          "vulnerability_to_line": 57,
          "vulnerability_code": "    function hashEIP712Message(bytes32 hashStruct) internal view returns (bytes32 result) {\n\n        bytes32 domainSeparator = DOMAIN_SEPARATOR;\n\n\n\n        assembly {\n\n            // Load free memory pointer\n\n            let memPtr := mload(64)\n\n\n\n            mstore(memPtr, 0x1901000000000000000000000000000000000000000000000000000000000000)  // EIP191 header\n\n            mstore(add(memPtr, 2), domainSeparator)                                            // EIP712 domain hash\n\n            mstore(add(memPtr, 34), hashStruct)                                                 // Hash of struct\n\n\n\n            // Compute hash\n\n            result := keccak256(memPtr, 66)\n\n        }\n\n        return result;\n",
          "message": "LibEIP712.hashEIP712Message uses assembly (LibOrder.sol#42-57)\n\t- LibOrder.sol#45-55\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 219,
          "vulnerability_to_line": 246,
          "vulnerability_code": "    function retrieveAddress(bytes32 _hash, bytes memory _signature) private pure returns (address) {\n\n        bytes32 r;\n\n        bytes32 s;\n\n        uint8 v;\n\n\n\n        // Divide the signature in r, s and v variables\n\n        // ecrecover takes the signature parameters, and the only way to get them\n\n        // currently is to use assembly.\n\n        // solium-disable-next-line security/no-inline-assembly\n\n        assembly {\n\n            r := mload(add(_signature, 32))\n\n            s := mload(add(_signature, 64))\n\n            v := byte(0, mload(add(_signature, 96)))\n\n        }\n\n\n\n        // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\n\n        if (v < 27) {\n\n            v += 27;\n\n        }\n\n\n\n        // If the version is correct return the signer address\n\n        if (v != 27 && v != 28) {\n\n            return (address(0));\n\n        } else {\n\n            // solium-disable-next-line arg-overflow\n\n            return ecrecover(_hash, v, r, s);\n\n        }\n",
          "message": "LibOrder.retrieveAddress uses assembly (LibOrder.sol#219-246)\n\t- LibOrder.sol#228-232\n"
        },
        {
          "name": "pragma",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.4;\n",
          "message": "Different versions of Solidity is used in LibOrder.sol:\n\t- Version used: ['ABIEncoderV2', '^0.5.4']\n\t- LibOrder.sol#3 declares pragma solidity^0.5.4\n\t- LibOrder.sol#62 declares pragma solidity^0.5.4\n\t- LibOrder.sol#63 declares pragma experimentalABIEncoderV2\n"
        },
        {
          "name": "solc-version",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.4;\n",
          "message": "Detected issues with version pragma in LibOrder.sol:\n\t- pragma solidity^0.5.4 (LibOrder.sol#3): it allows old versions\n\t- pragma solidity^0.5.4 (LibOrder.sol#62): it allows old versions\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 27,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bytes32 internal DOMAIN_SEPARATOR;\n",
          "message": "Variable 'LibEIP712.DOMAIN_SEPARATOR' (LibOrder.sol#27) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 165,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function hashOrder(Order memory _order) internal pure returns (bytes32 hash) {\n",
          "message": "Parameter '_order' of LibOrder.hashOrder (LibOrder.sol#165) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 207,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function verifySignature(bytes32 _hash, bytes memory _signature, address _address) internal view returns (bool) {\n",
          "message": "Parameter '_hash' of LibOrder.verifySignature (LibOrder.sol#207) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 207,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function verifySignature(bytes32 _hash, bytes memory _signature, address _address) internal view returns (bool) {\n",
          "message": "Parameter '_signature' of LibOrder.verifySignature (LibOrder.sol#207) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 207,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function verifySignature(bytes32 _hash, bytes memory _signature, address _address) internal view returns (bool) {\n",
          "message": "Parameter '_address' of LibOrder.verifySignature (LibOrder.sol#207) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 219,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function retrieveAddress(bytes32 _hash, bytes memory _signature) private pure returns (address) {\n",
          "message": "Parameter '_hash' of LibOrder.retrieveAddress (LibOrder.sol#219) is not in mixedCase\n"
        }
      ]
    },
    "smartcheck": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 241,
          "vulnerability_to_line": null,
          "vulnerability_code": "            return (address(0));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.4;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 62,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.4;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 219,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function retrieveAddress(bytes32 _hash, bytes memory _signature) private pure returns (address) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
          "vulnerability_from_line": 42,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function hashEIP712Message(bytes32 hashStruct) internal view returns (bytes32 result) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 45,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 228,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        }
      ]
    },
    "oyente": {
      "successfull_analysis": false,
      "errors": [
        "exception (IndexError: pop from empty list)"
      ],
      "vulnerability_findings": []
    },
    "mythril": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": []
    },
    "osiris": {
      "successfull_analysis": false,
      "errors": [
        "Solidity compilation failed"
      ],
      "vulnerability_findings": []
    }
  }
}