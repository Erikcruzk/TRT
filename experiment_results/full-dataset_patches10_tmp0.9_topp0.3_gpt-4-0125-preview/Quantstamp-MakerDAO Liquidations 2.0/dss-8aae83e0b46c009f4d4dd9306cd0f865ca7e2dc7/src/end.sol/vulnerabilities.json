{
  "smartbugs_completed": true,
  "analyzer_results": {
    "semgrep": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 278,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor() public {\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 279,
          "vulnerability_to_line": null,
          "vulnerability_code": "        wards[msg.sender] = 1;\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 280,
          "vulnerability_to_line": null,
          "vulnerability_code": "        live = 1;\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 281,
          "vulnerability_to_line": null,
          "vulnerability_code": "        emit Rely(msg.sender);\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 282,
          "vulnerability_to_line": null,
          "vulnerability_code": "    }\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 234,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(wards[msg.sender] == 1, \"End/not-authorized\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 312,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(live == 1, \"End/not-live\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 319,
          "vulnerability_to_line": null,
          "vulnerability_code": "        else revert(\"End/file-unrecognized-param\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 323,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(live == 1, \"End/not-live\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 325,
          "vulnerability_to_line": null,
          "vulnerability_code": "        else revert(\"End/file-unrecognized-param\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 331,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(live == 1, \"End/not-live\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 344,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(live == 0, \"End/still-live\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 345,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(tag[ilk] == 0, \"End/tag-ilk-already-defined\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 354,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(tag[ilk] != 0, \"End/tag-ilk-not-defined\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 366,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(int256(lot) >= 0 && int256(art) >= 0, \"End/overflow\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 372,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(tag[ilk] != 0, \"End/tag-ilk-not-defined\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 386,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(int256(lot) >= 0 && int256(art) >= 0, \"End/overflow\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 392,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(tag[ilk] != 0, \"End/tag-ilk-not-defined\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 400,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(wad <= 2**255 && art <= 2**255, \"End/overflow\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 406,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(live == 0, \"End/still-live\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 408,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(art == 0, \"End/art-not-zero\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 409,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(ink <= 2**255, \"End/overflow\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 415,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(live == 0, \"End/still-live\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 416,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(debt == 0, \"End/debt-not-zero\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 417,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(vat.dai(address(vow)) == 0, \"End/surplus-not-zero\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 418,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(block.timestamp >= add(when, wait), \"End/wait-not-finished\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 423,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(debt != 0, \"End/debt-zero\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 424,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(fix[ilk] == 0, \"End/fix-ilk-already-defined\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 433,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(debt != 0, \"End/debt-zero\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 439,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(fix[ilk] != 0, \"End/fix-ilk-not-defined\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 442,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(out[ilk][msg.sender] <= bag[msg.sender], \"End/insufficient-bag-balance\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 366,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(int256(lot) >= 0 && int256(art) >= 0, \"End/overflow\");\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 386,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(int256(lot) >= 0 && int256(art) >= 0, \"End/overflow\");\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 400,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(wad <= 2**255 && art <= 2**255, \"End/overflow\");\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        }
      ]
    },
    "slither": {
      "successfull_analysis": true,
      "errors": [
        "EXIT_CODE_17"
      ],
      "vulnerability_findings": [
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 343,
          "vulnerability_to_line": 351,
          "vulnerability_code": "    function cage(bytes32 ilk) external {\n\n        require(live == 0, \"End/still-live\");\n\n        require(tag[ilk] == 0, \"End/tag-ilk-already-defined\");\n\n        (Art[ilk],,,,) = vat.ilks(ilk);\n\n        (PipLike pip,) = spot.ilks(ilk);\n\n        // par is a ray, pip returns a wad\n\n        tag[ilk] = wdiv(spot.par(), uint256(pip.read()));\n\n        emit Cage(ilk);\n",
          "message": "Reentrancy in End.cage (end.sol#343-351):\n\tExternal calls:\n\t- (Art[ilk],None,None,None,None) = vat.ilks(ilk) (end.sol#346)\n\t- (pip) = spot.ilks(ilk) (end.sol#347)\n\t- tag[ilk] = wdiv(spot.par(),uint256(pip.read())) (end.sol#349)\n\tState variables written after the call(s):\n\t- tag (end.sol#349)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 422,
          "vulnerability_to_line": 430,
          "vulnerability_code": "    function flow(bytes32 ilk) external {\n\n        require(debt != 0, \"End/debt-zero\");\n\n        require(fix[ilk] == 0, \"End/fix-ilk-already-defined\");\n\n\n\n        (, uint256 rate,,,) = vat.ilks(ilk);\n\n        uint256 wad = rmul(rmul(Art[ilk], rate), tag[ilk]);\n\n        fix[ilk] = rdiv(mul(sub(wad, gap[ilk]), RAY), debt);\n\n        emit Flow(ilk);\n",
          "message": "Reentrancy in End.flow (end.sol#422-430):\n\tExternal calls:\n\t- (rate) = vat.ilks(ilk) (end.sol#426)\n\tState variables written after the call(s):\n\t- fix (end.sol#428)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 414,
          "vulnerability_to_line": 421,
          "vulnerability_code": "    function thaw() external {\n\n        require(live == 0, \"End/still-live\");\n\n        require(debt == 0, \"End/debt-not-zero\");\n\n        require(vat.dai(address(vow)) == 0, \"End/surplus-not-zero\");\n\n        require(block.timestamp >= add(when, wait), \"End/wait-not-finished\");\n\n        debt = vat.debt();\n\n        emit Thaw();\n",
          "message": "Reentrancy in End.thaw (end.sol#414-421):\n\tExternal calls:\n\t- require(bool,string)(vat.dai(address(vow)) == 0,End/surplus-not-zero) (end.sol#417)\n\t- debt = vat.debt() (end.sol#419)\n\tState variables written after the call(s):\n\t- debt (end.sol#419)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 438,
          "vulnerability_to_line": 444,
          "vulnerability_code": "    function cash(bytes32 ilk, uint256 wad) external {\n\n        require(fix[ilk] != 0, \"End/fix-ilk-not-defined\");\n\n        vat.flux(ilk, address(this), msg.sender, rmul(wad, fix[ilk]));\n\n        out[ilk][msg.sender] = add(out[ilk][msg.sender], wad);\n\n        require(out[ilk][msg.sender] <= bag[msg.sender], \"End/insufficient-bag-balance\");\n\n        emit Cash(ilk, msg.sender, wad);\n",
          "message": "Reentrancy in End.cash (end.sol#438-444):\n\tExternal calls:\n\t- vat.flux(ilk,address(this),msg.sender,rmul(wad,fix[ilk])) (end.sol#440)\n\tState variables written after the call(s):\n\t- out (end.sol#441)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 432,
          "vulnerability_to_line": 437,
          "vulnerability_code": "    function pack(uint256 wad) external {\n\n        require(debt != 0, \"End/debt-zero\");\n\n        vat.move(msg.sender, address(vow), mul(wad, RAY));\n\n        bag[msg.sender] = add(bag[msg.sender], wad);\n\n        emit Pack(msg.sender, wad);\n",
          "message": "Reentrancy in End.pack (end.sol#432-437):\n\tExternal calls:\n\t- vat.move(msg.sender,address(vow),mul(wad,RAY)) (end.sol#434)\n\tState variables written after the call(s):\n\t- bag (end.sol#435)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 391,
          "vulnerability_to_line": 403,
          "vulnerability_code": "    function skim(bytes32 ilk, address urn) external {\n\n        require(tag[ilk] != 0, \"End/tag-ilk-not-defined\");\n\n        (, uint256 rate,,,) = vat.ilks(ilk);\n\n        (uint256 ink, uint256 art) = vat.urns(ilk, urn);\n\n\n\n        uint256 owe = rmul(rmul(art, rate), tag[ilk]);\n\n        uint256 wad = min(ink, owe);\n\n        gap[ilk] = add(gap[ilk], sub(owe, wad));\n\n\n\n        require(wad <= 2**255 && art <= 2**255, \"End/overflow\");\n\n        vat.grab(ilk, urn, address(this), address(vow), -int256(wad), -int256(art));\n\n        emit Skim(ilk, urn, wad, art);\n",
          "message": "Reentrancy in End.skim (end.sol#391-403):\n\tExternal calls:\n\t- (rate) = vat.ilks(ilk) (end.sol#393)\n\t- (ink,art) = vat.urns(ilk,urn) (end.sol#394)\n\tState variables written after the call(s):\n\t- gap (end.sol#398)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 371,
          "vulnerability_to_line": 389,
          "vulnerability_code": "    function skip(bytes32 ilk, uint256 id) external {\n\n        require(tag[ilk] != 0, \"End/tag-ilk-not-defined\");\n\n\n\n        (address _flip,,) = cat.ilks(ilk);\n\n        FlipLike flip = FlipLike(_flip);\n\n        (, uint256 rate,,,) = vat.ilks(ilk);\n\n        (uint256 bid, uint256 lot,,,, address usr,, uint256 tab) = flip.bids(id);\n\n\n\n        vat.suck(address(vow), address(vow),  tab);\n\n        vat.suck(address(vow), address(this), bid);\n\n        vat.hope(address(flip));\n\n        flip.yank(id);\n\n\n\n        uint256 art = tab / rate;\n\n        Art[ilk] = add(Art[ilk], art);\n\n        require(int256(lot) >= 0 && int256(art) >= 0, \"End/overflow\");\n\n        vat.grab(ilk, usr, address(this), address(vow), int256(lot), int256(art));\n\n        emit Skip(ilk, id, usr, tab, lot, art);\n",
          "message": "Reentrancy in End.skip (end.sol#371-389):\n\tExternal calls:\n\t- (_flip) = cat.ilks(ilk) (end.sol#374)\n\t- (rate) = vat.ilks(ilk) (end.sol#376)\n\t- (bid,lot,usr,tab) = flip.bids(id) (end.sol#377)\n\t- vat.suck(address(vow),address(vow),tab) (end.sol#379)\n\t- vat.suck(address(vow),address(this),bid) (end.sol#380)\n\t- vat.hope(address(flip)) (end.sol#381)\n\t- flip.yank(id) (end.sol#382)\n\tState variables written after the call(s):\n\t- Art (end.sol#385)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 353,
          "vulnerability_to_line": 369,
          "vulnerability_code": "    function snip(bytes32 ilk, uint256 id) external {\n\n        require(tag[ilk] != 0, \"End/tag-ilk-not-defined\");\n\n\n\n        (address _clip,,,) = dog.ilks(ilk);\n\n        ClipLike clip = ClipLike(_clip);\n\n        (, uint256 rate,,,) = vat.ilks(ilk);\n\n        (, uint256 tab, uint256 lot, address usr,,) = clip.sales(id);\n\n\n\n        vat.suck(address(vow), address(vow),  tab);\n\n        clip.yank(id);\n\n\n\n        uint256 art = tab / rate;\n\n        Art[ilk] = add(Art[ilk], art);\n\n        require(int256(lot) >= 0 && int256(art) >= 0, \"End/overflow\");\n\n        vat.grab(ilk, usr, address(this), address(vow), int256(lot), int256(art));\n\n        emit Snip(ilk, id, usr, tab, lot, art);\n",
          "message": "Reentrancy in End.snip (end.sol#353-369):\n\tExternal calls:\n\t- (_clip) = dog.ilks(ilk) (end.sol#356)\n\t- (rate) = vat.ilks(ilk) (end.sol#358)\n\t- (tab,lot,usr) = clip.sales(id) (end.sol#359)\n\t- vat.suck(address(vow),address(vow),tab) (end.sol#361)\n\t- clip.yank(id) (end.sol#362)\n\tState variables written after the call(s):\n\t- Art (end.sol#365)\n"
        },
        {
          "name": "timestamp",
          "vulnerability_from_line": 287,
          "vulnerability_to_line": 290,
          "vulnerability_code": "    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\n\n        z = x + y;\n\n        require(z >= x);\n",
          "message": "End.add (end.sol#287-290) uses timestamp for comparisons\n\tDangerous comparisons:\n\t- require(bool)(z >= x) (end.sol#289)\n"
        },
        {
          "name": "timestamp",
          "vulnerability_from_line": 414,
          "vulnerability_to_line": 421,
          "vulnerability_code": "    function thaw() external {\n\n        require(live == 0, \"End/still-live\");\n\n        require(debt == 0, \"End/debt-not-zero\");\n\n        require(vat.dai(address(vow)) == 0, \"End/surplus-not-zero\");\n\n        require(block.timestamp >= add(when, wait), \"End/wait-not-finished\");\n\n        debt = vat.debt();\n\n        emit Thaw();\n",
          "message": "End.thaw (end.sol#414-421) uses timestamp for comparisons\n\tDangerous comparisons:\n\t- require(bool,string)(block.timestamp >= add(when,wait),End/wait-not-finished) (end.sol#418)\n"
        },
        {
          "name": "solc-version",
          "vulnerability_from_line": 23,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity >=0.6.12;\n",
          "message": "Detected issues with version pragma in end.sol:\n\t- pragma solidity>=0.6.12 (end.sol#23): it allows old versions\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 26,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function dai(address) external view returns (uint256);\n",
          "message": "Parameter '' of VatLike.dai (end.sol#26) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 40,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function hope(address) external;\n",
          "message": "Parameter '' of VatLike.hope (end.sol#40) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 48,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function ilks(bytes32) external returns (\n",
          "message": "Parameter '' of CatLike.ilks (end.sol#48) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 57,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function ilks(bytes32) external returns (\n",
          "message": "Parameter '' of DogLike.ilks (end.sol#57) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 106,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function ilks(bytes32) external view returns (\n",
          "message": "Parameter '' of SpotLike.ilks (end.sol#106) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 253,
          "vulnerability_to_line": null,
          "vulnerability_code": "    mapping (bytes32 => uint256) public Art;  // Total debt per ilk      [wad]\n",
          "message": "Variable 'End.Art' (end.sol#253) is not in mixedCase\n"
        }
      ]
    },
    "smartcheck": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 23,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity >=0.6.12;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_REVERT_REQUIRE",
          "vulnerability_from_line": 318,
          "vulnerability_to_line": null,
          "vulnerability_code": "        else if (what == \"spot\") spot = SpotLike(data);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_REVERT_REQUIRE",
          "vulnerability_from_line": 324,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (what == \"wait\") wait = data;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 27,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function ilks(bytes32 ilk) external returns (\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 34,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function urns(bytes32 ilk, address urn) external returns (\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 48,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function ilks(bytes32) external returns (\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 57,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function ilks(bytes32) external returns (\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 75,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function bids(uint256 id) external view returns (\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 89,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function sales(uint256 id) external view returns (\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 106,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function ilks(bytes32) external view returns (\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 285,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint256 constant WAD = 10 ** 18;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 286,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint256 constant RAY = 10 ** 27;\n",
          "message": null
        }
      ]
    },
    "oyente": {
      "successfull_analysis": false,
      "errors": [
        "exception (RuntimeError: Source map error, unknown name(SHR) or instr_name(INVALID))"
      ],
      "vulnerability_findings": []
    },
    "mythril": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "Exception State (SWC 110)",
          "vulnerability_from_line": 278,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor() public {\n",
          "message": "An assertion violation was triggered.\nIt is possible to trigger an assertion violation. Note that Solidity assert() statements should only be used to check invariants. Review the transaction trace generated for this issue and either make sure your program logic is correct, or use require() instead of assert() if your goal is to constrain user inputs or enforce preconditions. Remember to validate inputs from both callers (for instance, via passed arguments) and callees (for instance, via return values).\nClassification: SWC-110"
        }
      ]
    },
    "osiris": {
      "successfull_analysis": false,
      "errors": [
        "Solidity compilation failed"
      ],
      "vulnerability_findings": []
    }
  }
}