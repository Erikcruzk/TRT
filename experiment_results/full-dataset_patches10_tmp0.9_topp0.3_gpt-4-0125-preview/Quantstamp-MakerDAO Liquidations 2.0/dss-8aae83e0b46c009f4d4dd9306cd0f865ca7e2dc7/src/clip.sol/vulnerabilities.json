{
  "smartbugs_completed": true,
  "analyzer_results": {
    "semgrep": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "init-variables-with-default-value",
          "vulnerability_from_line": 94,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint256 public stopped = 0;\n",
          "message": "Uninitialized variables are assigned with the types default value. Explicitly initializing a variable with its default value costs unnecessary gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 134,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor(address vat_, address spotter_, address dog_, bytes32 ilk_) public {\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 135,
          "vulnerability_to_line": null,
          "vulnerability_code": "        vat     = VatLike(vat_);\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 136,
          "vulnerability_to_line": null,
          "vulnerability_code": "        spotter = SpotterLike(spotter_);\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 137,
          "vulnerability_to_line": null,
          "vulnerability_code": "        dog     = DogLike(dog_);\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 138,
          "vulnerability_to_line": null,
          "vulnerability_code": "        ilk     = ilk_;\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 139,
          "vulnerability_to_line": null,
          "vulnerability_code": "        buf     = RAY;\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 140,
          "vulnerability_to_line": null,
          "vulnerability_code": "\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 141,
          "vulnerability_to_line": null,
          "vulnerability_code": "        wards[msg.sender] = 1;\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 142,
          "vulnerability_to_line": null,
          "vulnerability_code": "        emit Rely(msg.sender);\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 143,
          "vulnerability_to_line": null,
          "vulnerability_code": "    }\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 56,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(wards[msg.sender] == 1, \"Clipper/not-authorized\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 147,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(locked == 0, \"Clipper/system-locked\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 154,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(stopped < level, \"Clipper/stopped-incorrect\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 166,
          "vulnerability_to_line": null,
          "vulnerability_code": "        else revert(\"Clipper/file-unrecognized-param\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 174,
          "vulnerability_to_line": null,
          "vulnerability_code": "        else revert(\"Clipper/file-unrecognized-param\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 215,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(has, \"Clipper/invalid-price\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 235,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(tab  >          0, \"Clipper/zero-tab\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 236,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(lot  >          0, \"Clipper/zero-lot\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 237,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(usr != address(0), \"Clipper/zero-usr\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 239,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(id   >          0, \"Clipper/overflow\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 252,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(top > 0, \"Clipper/zero-top-price\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 275,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(usr != address(0), \"Clipper/not-running-auction\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 280,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(done, \"Clipper/cannot-reset\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 288,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(top > 0, \"Clipper/zero-top-price\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 343,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(usr != address(0), \"Clipper/not-running-auction\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 351,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(!done, \"Clipper/needs-reset\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 355,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(max >= price, \"Clipper/too-expensive\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 379,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    require(tab > dust, \"Clipper/no-partial-purchase\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 465,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(sales[id].usr != address(0), \"Clipper/not-running-auction\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 297,
          "vulnerability_to_line": null,
          "vulnerability_code": "            if (tab >= dust && mul(lot, price) >= dust) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 298,
          "vulnerability_to_line": null,
          "vulnerability_code": "                coin = add(_tip, wmul(tab, _chip));\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 299,
          "vulnerability_to_line": null,
          "vulnerability_code": "                vat.suck(vow, kpr, coin);\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 300,
          "vulnerability_to_line": null,
          "vulnerability_code": "            }\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 374,
          "vulnerability_to_line": null,
          "vulnerability_code": "            } else if (owe < tab && slice < lot) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 375,
          "vulnerability_to_line": null,
          "vulnerability_code": "                // if slice == lot => auction completed => dust doesn't matter\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 376,
          "vulnerability_to_line": null,
          "vulnerability_code": "                (,,,, uint256 dust) = vat.ilks(ilk);\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 377,
          "vulnerability_to_line": null,
          "vulnerability_code": "                if (tab - owe < dust) {     // safe as owe < tab\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 378,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    // if tab <= dust, buyers have to buy the whole thing\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 379,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    require(tab > dust, \"Clipper/no-partial-purchase\");\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 380,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    // Adjust amount to pay\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 381,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    owe = tab - dust;       // owe' <= owe\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 382,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    // Adjust slice\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 383,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    slice = owe / price;    // slice' = owe' / price < owe / price == slice < lot\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 399,
          "vulnerability_to_line": null,
          "vulnerability_code": "            if (data.length > 0 && who != address(vat) && who != address(dog_)) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 400,
          "vulnerability_to_line": null,
          "vulnerability_code": "                ClipperCallee(who).clipperCall(msg.sender, owe, slice, data);\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 401,
          "vulnerability_to_line": null,
          "vulnerability_code": "            }\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        }
      ]
    },
    "slither": {
      "successfull_analysis": true,
      "errors": [
        "EXIT_CODE_37"
      ],
      "vulnerability_findings": [
        {
          "name": "incorrect-equality",
          "vulnerability_from_line": 192,
          "vulnerability_to_line": 194,
          "vulnerability_code": "    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n\n        require(y == 0 || (z = x * y) / y == x);\n",
          "message": "Clipper.mul (clip.sol#192-194) uses a dangerous strict equality:\n\t- require(bool)(y == 0 || (z = x * y) / y == x)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 423,
          "vulnerability_to_line": 432,
          "vulnerability_code": "    function _remove(uint256 id) internal {\n\n        uint256 _move    = active[active.length - 1];\n\n        if (id != _move) {\n\n            uint256 _index   = sales[id].pos;\n\n            active[_index]   = _move;\n\n            sales[_move].pos = _index;\n\n        }\n\n        active.pop();\n\n        delete sales[id];\n",
          "message": "Reentrancy in Clipper._remove (clip.sol#423-432):\n\tExternal calls:\n\t- active.pop() (clip.sol#430)\n\tState variables written after the call(s):\n\t- sales (clip.sol#431)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 228,
          "vulnerability_to_line": 265,
          "vulnerability_code": "    function kick(\n\n        uint256 tab,  // Debt                   [rad]\n\n        uint256 lot,  // Collateral             [wad]\n\n        address usr,  // Liquidated CDP\n\n        address kpr   // Keeper that called dog.bark()\n\n    ) external auth lock isStopped(1) returns (uint256 id) {\n\n        // Input validation\n\n        require(tab  >          0, \"Clipper/zero-tab\");\n\n        require(lot  >          0, \"Clipper/zero-lot\");\n\n        require(usr != address(0), \"Clipper/zero-usr\");\n\n        id = ++kicks;\n\n        require(id   >          0, \"Clipper/overflow\");\n\n\n\n        active.push(id);\n\n\n\n        sales[id].pos = active.length - 1;\n\n\n\n        sales[id].tab = tab;\n\n        sales[id].lot = lot;\n\n        sales[id].usr = usr;\n\n        sales[id].tic = uint96(block.timestamp);\n\n\n\n        uint256 top;\n\n        top = rmul(getPrice(), buf);\n\n        require(top > 0, \"Clipper/zero-top-price\");\n\n        sales[id].top = top;\n\n\n\n        // incentive to kick auction\n\n        uint256 _tip  = tip;\n\n        uint256 _chip = chip;\n\n        uint256 coin;\n\n        if (_tip > 0 || _chip > 0) {\n\n            coin = add(_tip, wmul(tab, _chip));\n\n            vat.suck(vow, kpr, coin);\n\n        }\n\n\n\n        emit Kick(id, top, tab, lot, usr, kpr, coin);\n",
          "message": "Reentrancy in Clipper.kick (clip.sol#228-265):\n\tExternal calls:\n\t- top = rmul(getPrice(),buf) (clip.sol#251)\n\tState variables written after the call(s):\n\t- sales (clip.sol#253)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 269,
          "vulnerability_to_line": 304,
          "vulnerability_code": "    function redo(uint256 id, address kpr) external lock isStopped(2) {\n\n        // Read auction data\n\n        address usr = sales[id].usr;\n\n        uint96  tic = sales[id].tic;\n\n        uint256 top = sales[id].top;\n\n\n\n        require(usr != address(0), \"Clipper/not-running-auction\");\n\n\n\n        // Check that auction needs reset\n\n        // and compute current price [ray]\n\n        (bool done,) = status(tic, top);\n\n        require(done, \"Clipper/cannot-reset\");\n\n\n\n        uint256 tab   = sales[id].tab;\n\n        uint256 lot   = sales[id].lot;\n\n        sales[id].tic = uint96(block.timestamp);\n\n\n\n        uint256 price = getPrice();\n\n        top = rmul(price, buf);\n\n        require(top > 0, \"Clipper/zero-top-price\");\n\n        sales[id].top = top;\n\n\n\n        // incentive to redo auction\n\n        uint256 _tip  = tip;\n\n        uint256 _chip = chip;\n\n        uint256 coin;\n\n        if (_tip > 0 || _chip > 0) {\n\n            (,,,, uint256 dust) = vat.ilks(ilk);\n\n            if (tab >= dust && mul(lot, price) >= dust) {\n\n                coin = add(_tip, wmul(tab, _chip));\n\n                vat.suck(vow, kpr, coin);\n\n            }\n\n        }\n\n\n\n        emit Redo(id, top, tab, lot, usr, kpr, coin);\n",
          "message": "Reentrancy in Clipper.redo (clip.sol#269-304):\n\tExternal calls:\n\t- (done) = status(tic,top) (clip.sol#279)\n\tState variables written after the call(s):\n\t- sales (clip.sol#284)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 269,
          "vulnerability_to_line": 304,
          "vulnerability_code": "    function redo(uint256 id, address kpr) external lock isStopped(2) {\n\n        // Read auction data\n\n        address usr = sales[id].usr;\n\n        uint96  tic = sales[id].tic;\n\n        uint256 top = sales[id].top;\n\n\n\n        require(usr != address(0), \"Clipper/not-running-auction\");\n\n\n\n        // Check that auction needs reset\n\n        // and compute current price [ray]\n\n        (bool done,) = status(tic, top);\n\n        require(done, \"Clipper/cannot-reset\");\n\n\n\n        uint256 tab   = sales[id].tab;\n\n        uint256 lot   = sales[id].lot;\n\n        sales[id].tic = uint96(block.timestamp);\n\n\n\n        uint256 price = getPrice();\n\n        top = rmul(price, buf);\n\n        require(top > 0, \"Clipper/zero-top-price\");\n\n        sales[id].top = top;\n\n\n\n        // incentive to redo auction\n\n        uint256 _tip  = tip;\n\n        uint256 _chip = chip;\n\n        uint256 coin;\n\n        if (_tip > 0 || _chip > 0) {\n\n            (,,,, uint256 dust) = vat.ilks(ilk);\n\n            if (tab >= dust && mul(lot, price) >= dust) {\n\n                coin = add(_tip, wmul(tab, _chip));\n\n                vat.suck(vow, kpr, coin);\n\n            }\n\n        }\n\n\n\n        emit Redo(id, top, tab, lot, usr, kpr, coin);\n",
          "message": "Reentrancy in Clipper.redo (clip.sol#269-304):\n\tExternal calls:\n\t- (done) = status(tic,top) (clip.sol#279)\n\t- price = getPrice() (clip.sol#286)\n\tState variables written after the call(s):\n\t- sales (clip.sol#289)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 332,
          "vulnerability_to_line": 421,
          "vulnerability_code": "    function take(\n\n        uint256 id,           // Auction id\n\n        uint256 amt,          // Upper limit on amount of collateral to buy  [wad]\n\n        uint256 max,          // Maximum acceptable price (DAI / collateral) [ray]\n\n        address who,          // Receiver of collateral and external call address\n\n        bytes calldata data   // Data to pass in external call; if length 0, no call is done\n\n    ) external lock isStopped(2) {\n\n\n\n        address usr = sales[id].usr;\n\n        uint96  tic = sales[id].tic;\n\n\n\n        require(usr != address(0), \"Clipper/not-running-auction\");\n\n\n\n        uint256 price;\n\n        {\n\n            bool done;\n\n            (done, price) = status(tic, sales[id].top);\n\n\n\n            // Check that auction doesn't need reset\n\n            require(!done, \"Clipper/needs-reset\");\n\n        }\n\n\n\n        // Ensure price is acceptable to buyer\n\n        require(max >= price, \"Clipper/too-expensive\");\n\n\n\n        uint256 lot = sales[id].lot;\n\n        uint256 tab = sales[id].tab;\n\n        uint256 owe;\n\n\n\n        {\n\n            // Purchase as much as possible, up to amt\n\n            uint256 slice = min(lot, amt);  // slice <= lot\n\n\n\n            // DAI needed to buy a slice of this sale\n\n            owe = mul(slice, price);\n\n\n\n            // Don't collect more than tab of DAI\n\n            if (owe > tab) {\n\n                // Total debt will be paid\n\n                owe = tab;                  // owe' <= owe\n\n                // Adjust slice\n\n                slice = owe / price;        // slice' = owe' / price <= owe / price == slice <= lot\n\n            } else if (owe < tab && slice < lot) {\n\n                // if slice == lot => auction completed => dust doesn't matter\n\n                (,,,, uint256 dust) = vat.ilks(ilk);\n\n                if (tab - owe < dust) {     // safe as owe < tab\n\n                    // if tab <= dust, buyers have to buy the whole thing\n\n                    require(tab > dust, \"Clipper/no-partial-purchase\");\n\n                    // Adjust amount to pay\n\n                    owe = tab - dust;       // owe' <= owe\n\n                    // Adjust slice\n\n                    slice = owe / price;    // slice' = owe' / price < owe / price == slice < lot\n\n                }\n\n            }\n\n\n\n            // Calculate remaining tab after operation\n\n            tab = tab - owe;  // safe since owe <= tab\n\n            // Calculate remaining lot after operation\n\n            lot = lot - slice;\n\n\n\n            // Send collateral to who\n\n            vat.flux(ilk, address(this), who, slice);\n\n\n\n            // Do external call (if data is defined) but to be\n\n            // extremely careful we don't allow to do it to the two\n\n            // contracts which the Clipper needs to be authorized\n\n            DogLike dog_ = dog;\n\n            if (data.length > 0 && who != address(vat) && who != address(dog_)) {\n\n                ClipperCallee(who).clipperCall(msg.sender, owe, slice, data);\n\n            }\n\n\n\n            // Get DAI from caller\n\n            vat.move(msg.sender, vow, owe);\n\n\n\n            // Removes Dai out for liquidation from accumulator\n\n            dog_.digs(ilk, lot == 0 ? tab + owe : owe);\n\n        }\n\n\n\n        if (lot == 0) {\n\n            _remove(id);\n\n        } else if (tab == 0) {\n\n            vat.flux(ilk, address(this), usr, lot);\n\n            _remove(id);\n\n        } else {\n\n            sales[id].tab = tab;\n\n            sales[id].lot = lot;\n\n        }\n\n\n\n        emit Take(id, max, price, owe, tab, lot, usr);\n",
          "message": "Reentrancy in Clipper.take (clip.sol#332-421):\n\tExternal calls:\n\t- (done,price) = status(tic,sales[id].top) (clip.sol#348)\n\t- (dust) = vat.ilks(ilk) (clip.sol#376)\n\t- vat.flux(ilk,address(this),who,slice) (clip.sol#393)\n\t- ClipperCallee(who).clipperCall(msg.sender,owe,slice,data) (clip.sol#400)\n\t- vat.move(msg.sender,vow,owe) (clip.sol#404)\n\t- _remove(id) (clip.sol#411)\n\t- dog_.digs(ilk,tab + owe) (clip.sol#407)\n\t- dog_.digs(ilk,owe) (clip.sol#407)\n\tState variables written after the call(s):\n\t- sales (clip.sol#411)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 332,
          "vulnerability_to_line": 421,
          "vulnerability_code": "    function take(\n\n        uint256 id,           // Auction id\n\n        uint256 amt,          // Upper limit on amount of collateral to buy  [wad]\n\n        uint256 max,          // Maximum acceptable price (DAI / collateral) [ray]\n\n        address who,          // Receiver of collateral and external call address\n\n        bytes calldata data   // Data to pass in external call; if length 0, no call is done\n\n    ) external lock isStopped(2) {\n\n\n\n        address usr = sales[id].usr;\n\n        uint96  tic = sales[id].tic;\n\n\n\n        require(usr != address(0), \"Clipper/not-running-auction\");\n\n\n\n        uint256 price;\n\n        {\n\n            bool done;\n\n            (done, price) = status(tic, sales[id].top);\n\n\n\n            // Check that auction doesn't need reset\n\n            require(!done, \"Clipper/needs-reset\");\n\n        }\n\n\n\n        // Ensure price is acceptable to buyer\n\n        require(max >= price, \"Clipper/too-expensive\");\n\n\n\n        uint256 lot = sales[id].lot;\n\n        uint256 tab = sales[id].tab;\n\n        uint256 owe;\n\n\n\n        {\n\n            // Purchase as much as possible, up to amt\n\n            uint256 slice = min(lot, amt);  // slice <= lot\n\n\n\n            // DAI needed to buy a slice of this sale\n\n            owe = mul(slice, price);\n\n\n\n            // Don't collect more than tab of DAI\n\n            if (owe > tab) {\n\n                // Total debt will be paid\n\n                owe = tab;                  // owe' <= owe\n\n                // Adjust slice\n\n                slice = owe / price;        // slice' = owe' / price <= owe / price == slice <= lot\n\n            } else if (owe < tab && slice < lot) {\n\n                // if slice == lot => auction completed => dust doesn't matter\n\n                (,,,, uint256 dust) = vat.ilks(ilk);\n\n                if (tab - owe < dust) {     // safe as owe < tab\n\n                    // if tab <= dust, buyers have to buy the whole thing\n\n                    require(tab > dust, \"Clipper/no-partial-purchase\");\n\n                    // Adjust amount to pay\n\n                    owe = tab - dust;       // owe' <= owe\n\n                    // Adjust slice\n\n                    slice = owe / price;    // slice' = owe' / price < owe / price == slice < lot\n\n                }\n\n            }\n\n\n\n            // Calculate remaining tab after operation\n\n            tab = tab - owe;  // safe since owe <= tab\n\n            // Calculate remaining lot after operation\n\n            lot = lot - slice;\n\n\n\n            // Send collateral to who\n\n            vat.flux(ilk, address(this), who, slice);\n\n\n\n            // Do external call (if data is defined) but to be\n\n            // extremely careful we don't allow to do it to the two\n\n            // contracts which the Clipper needs to be authorized\n\n            DogLike dog_ = dog;\n\n            if (data.length > 0 && who != address(vat) && who != address(dog_)) {\n\n                ClipperCallee(who).clipperCall(msg.sender, owe, slice, data);\n\n            }\n\n\n\n            // Get DAI from caller\n\n            vat.move(msg.sender, vow, owe);\n\n\n\n            // Removes Dai out for liquidation from accumulator\n\n            dog_.digs(ilk, lot == 0 ? tab + owe : owe);\n\n        }\n\n\n\n        if (lot == 0) {\n\n            _remove(id);\n\n        } else if (tab == 0) {\n\n            vat.flux(ilk, address(this), usr, lot);\n\n            _remove(id);\n\n        } else {\n\n            sales[id].tab = tab;\n\n            sales[id].lot = lot;\n\n        }\n\n\n\n        emit Take(id, max, price, owe, tab, lot, usr);\n",
          "message": "Reentrancy in Clipper.take (clip.sol#332-421):\n\tExternal calls:\n\t- (done,price) = status(tic,sales[id].top) (clip.sol#348)\n\t- (dust) = vat.ilks(ilk) (clip.sol#376)\n\t- vat.flux(ilk,address(this),who,slice) (clip.sol#393)\n\t- ClipperCallee(who).clipperCall(msg.sender,owe,slice,data) (clip.sol#400)\n\t- vat.move(msg.sender,vow,owe) (clip.sol#404)\n\t- vat.flux(ilk,address(this),usr,lot) (clip.sol#413)\n\t- _remove(id) (clip.sol#414)\n\t- dog_.digs(ilk,tab + owe) (clip.sol#407)\n\t- dog_.digs(ilk,owe) (clip.sol#407)\n\tState variables written after the call(s):\n\t- sales (clip.sol#414)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 332,
          "vulnerability_to_line": 421,
          "vulnerability_code": "    function take(\n\n        uint256 id,           // Auction id\n\n        uint256 amt,          // Upper limit on amount of collateral to buy  [wad]\n\n        uint256 max,          // Maximum acceptable price (DAI / collateral) [ray]\n\n        address who,          // Receiver of collateral and external call address\n\n        bytes calldata data   // Data to pass in external call; if length 0, no call is done\n\n    ) external lock isStopped(2) {\n\n\n\n        address usr = sales[id].usr;\n\n        uint96  tic = sales[id].tic;\n\n\n\n        require(usr != address(0), \"Clipper/not-running-auction\");\n\n\n\n        uint256 price;\n\n        {\n\n            bool done;\n\n            (done, price) = status(tic, sales[id].top);\n\n\n\n            // Check that auction doesn't need reset\n\n            require(!done, \"Clipper/needs-reset\");\n\n        }\n\n\n\n        // Ensure price is acceptable to buyer\n\n        require(max >= price, \"Clipper/too-expensive\");\n\n\n\n        uint256 lot = sales[id].lot;\n\n        uint256 tab = sales[id].tab;\n\n        uint256 owe;\n\n\n\n        {\n\n            // Purchase as much as possible, up to amt\n\n            uint256 slice = min(lot, amt);  // slice <= lot\n\n\n\n            // DAI needed to buy a slice of this sale\n\n            owe = mul(slice, price);\n\n\n\n            // Don't collect more than tab of DAI\n\n            if (owe > tab) {\n\n                // Total debt will be paid\n\n                owe = tab;                  // owe' <= owe\n\n                // Adjust slice\n\n                slice = owe / price;        // slice' = owe' / price <= owe / price == slice <= lot\n\n            } else if (owe < tab && slice < lot) {\n\n                // if slice == lot => auction completed => dust doesn't matter\n\n                (,,,, uint256 dust) = vat.ilks(ilk);\n\n                if (tab - owe < dust) {     // safe as owe < tab\n\n                    // if tab <= dust, buyers have to buy the whole thing\n\n                    require(tab > dust, \"Clipper/no-partial-purchase\");\n\n                    // Adjust amount to pay\n\n                    owe = tab - dust;       // owe' <= owe\n\n                    // Adjust slice\n\n                    slice = owe / price;    // slice' = owe' / price < owe / price == slice < lot\n\n                }\n\n            }\n\n\n\n            // Calculate remaining tab after operation\n\n            tab = tab - owe;  // safe since owe <= tab\n\n            // Calculate remaining lot after operation\n\n            lot = lot - slice;\n\n\n\n            // Send collateral to who\n\n            vat.flux(ilk, address(this), who, slice);\n\n\n\n            // Do external call (if data is defined) but to be\n\n            // extremely careful we don't allow to do it to the two\n\n            // contracts which the Clipper needs to be authorized\n\n            DogLike dog_ = dog;\n\n            if (data.length > 0 && who != address(vat) && who != address(dog_)) {\n\n                ClipperCallee(who).clipperCall(msg.sender, owe, slice, data);\n\n            }\n\n\n\n            // Get DAI from caller\n\n            vat.move(msg.sender, vow, owe);\n\n\n\n            // Removes Dai out for liquidation from accumulator\n\n            dog_.digs(ilk, lot == 0 ? tab + owe : owe);\n\n        }\n\n\n\n        if (lot == 0) {\n\n            _remove(id);\n\n        } else if (tab == 0) {\n\n            vat.flux(ilk, address(this), usr, lot);\n\n            _remove(id);\n\n        } else {\n\n            sales[id].tab = tab;\n\n            sales[id].lot = lot;\n\n        }\n\n\n\n        emit Take(id, max, price, owe, tab, lot, usr);\n",
          "message": "Reentrancy in Clipper.take (clip.sol#332-421):\n\tExternal calls:\n\t- (done,price) = status(tic,sales[id].top) (clip.sol#348)\n\t- (dust) = vat.ilks(ilk) (clip.sol#376)\n\t- vat.flux(ilk,address(this),who,slice) (clip.sol#393)\n\t- ClipperCallee(who).clipperCall(msg.sender,owe,slice,data) (clip.sol#400)\n\t- vat.move(msg.sender,vow,owe) (clip.sol#404)\n\t- dog_.digs(ilk,tab + owe) (clip.sol#407)\n\t- dog_.digs(ilk,owe) (clip.sol#407)\n\tState variables written after the call(s):\n\t- sales (clip.sol#416)\n\t- sales (clip.sol#417)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 464,
          "vulnerability_to_line": 470,
          "vulnerability_code": "    function yank(uint256 id) external auth lock {\n\n        require(sales[id].usr != address(0), \"Clipper/not-running-auction\");\n\n        dog.digs(ilk, sales[id].tab);\n\n        vat.flux(ilk, address(this), msg.sender, sales[id].lot);\n\n        _remove(id);\n\n        emit Yank(id);\n",
          "message": "Reentrancy in Clipper.yank (clip.sol#464-470):\n\tExternal calls:\n\t- dog.digs(ilk,sales[id].tab) (clip.sol#466)\n\t- vat.flux(ilk,address(this),msg.sender,sales[id].lot) (clip.sol#467)\n\t- _remove(id) (clip.sol#468)\n\tState variables written after the call(s):\n\t- sales (clip.sol#468)\n"
        },
        {
          "name": "uninitialized-local",
          "vulnerability_from_line": 294,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint256 coin;\n",
          "message": "coin in Clipper.redo (clip.sol#294) is a local variable never initialiazed\n"
        },
        {
          "name": "uninitialized-local",
          "vulnerability_from_line": 258,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint256 coin;\n",
          "message": "coin in Clipper.kick (clip.sol#258) is a local variable never initialiazed\n"
        },
        {
          "name": "unused-return",
          "vulnerability_from_line": 423,
          "vulnerability_to_line": 432,
          "vulnerability_code": "    function _remove(uint256 id) internal {\n\n        uint256 _move    = active[active.length - 1];\n\n        if (id != _move) {\n\n            uint256 _index   = sales[id].pos;\n\n            active[_index]   = _move;\n\n            sales[_move].pos = _index;\n\n        }\n\n        active.pop();\n\n        delete sales[id];\n",
          "message": "Clipper._remove (clip.sol#423-432) does not use the value returned by external calls:\n\t-active.pop() (clip.sol#430)\n"
        },
        {
          "name": "timestamp",
          "vulnerability_from_line": 189,
          "vulnerability_to_line": 191,
          "vulnerability_code": "    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n\n        require((z = x - y) <= x);\n",
          "message": "Clipper.sub (clip.sol#189-191) uses timestamp for comparisons\n\tDangerous comparisons:\n\t- require(bool)((z = x - y) <= x) (clip.sol#190)\n"
        },
        {
          "name": "timestamp",
          "vulnerability_from_line": 192,
          "vulnerability_to_line": 194,
          "vulnerability_code": "    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n\n        require(y == 0 || (z = x * y) / y == x);\n",
          "message": "Clipper.mul (clip.sol#192-194) uses timestamp for comparisons\n\tDangerous comparisons:\n\t- require(bool)(y == 0 || (z = x * y) / y == x) (clip.sol#193)\n"
        },
        {
          "name": "timestamp",
          "vulnerability_from_line": 458,
          "vulnerability_to_line": 461,
          "vulnerability_code": "    function status(uint96 tic, uint256 top) internal view returns (bool done, uint256 price) {\n\n        price = calc.price(top, sub(block.timestamp, tic));\n\n        done  = (sub(block.timestamp, tic) > tail || rdiv(price, top) < cusp);\n",
          "message": "Clipper.status (clip.sol#458-461) uses timestamp for comparisons\n\tDangerous comparisons:\n\t- done = (sub(block.timestamp,tic) > tail || rdiv(price,top) < cusp) (clip.sol#460)\n"
        },
        {
          "name": "solc-version",
          "vulnerability_from_line": 20,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity >=0.6.12;\n",
          "message": "Detected issues with version pragma in clip.sol:\n\t- pragma solidity>=0.6.12 (clip.sol#20): it allows old versions\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 23,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function move(address,address,uint256) external;\n",
          "message": "Parameter '' of VatLike.move (clip.sol#23) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 23,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function move(address,address,uint256) external;\n",
          "message": "Parameter '_scope_0' of VatLike.move (clip.sol#23) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 23,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function move(address,address,uint256) external;\n",
          "message": "Parameter '_scope_1' of VatLike.move (clip.sol#23) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 24,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function flux(bytes32,address,address,uint256) external;\n",
          "message": "Parameter '' of VatLike.flux (clip.sol#24) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 24,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function flux(bytes32,address,address,uint256) external;\n",
          "message": "Parameter '_scope_0' of VatLike.flux (clip.sol#24) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 24,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function flux(bytes32,address,address,uint256) external;\n",
          "message": "Parameter '_scope_1' of VatLike.flux (clip.sol#24) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 24,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function flux(bytes32,address,address,uint256) external;\n",
          "message": "Parameter '_scope_2' of VatLike.flux (clip.sol#24) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 25,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function ilks(bytes32) external returns (uint256, uint256, uint256, uint256, uint256);\n",
          "message": "Parameter '' of VatLike.ilks (clip.sol#25) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 26,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function suck(address,address,uint256) external;\n",
          "message": "Parameter '' of VatLike.suck (clip.sol#26) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 26,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function suck(address,address,uint256) external;\n",
          "message": "Parameter '_scope_0' of VatLike.suck (clip.sol#26) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 26,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function suck(address,address,uint256) external;\n",
          "message": "Parameter '_scope_1' of VatLike.suck (clip.sol#26) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 35,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function ilks(bytes32) external returns (PipLike, uint256);\n",
          "message": "Parameter '' of SpotterLike.ilks (clip.sol#35) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 39,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function digs(bytes32, uint256) external;\n",
          "message": "Parameter '' of DogLike.digs (clip.sol#39) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 39,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function digs(bytes32, uint256) external;\n",
          "message": "Parameter '_scope_0' of DogLike.digs (clip.sol#39) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 43,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function clipperCall(address, uint256, uint256, bytes calldata) external;\n",
          "message": "Parameter '' of ClipperCallee.clipperCall (clip.sol#43) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 43,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function clipperCall(address, uint256, uint256, bytes calldata) external;\n",
          "message": "Parameter '_scope_0' of ClipperCallee.clipperCall (clip.sol#43) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 43,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function clipperCall(address, uint256, uint256, bytes calldata) external;\n",
          "message": "Parameter '_scope_1' of ClipperCallee.clipperCall (clip.sol#43) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 43,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function clipperCall(address, uint256, uint256, bytes calldata) external;\n",
          "message": "Parameter '_scope_2' of ClipperCallee.clipperCall (clip.sol#43) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 47,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function price(uint256, uint256) external view returns (uint256);\n",
          "message": "Parameter '' of AbacusLike.price (clip.sol#47) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 47,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function price(uint256, uint256) external view returns (uint256);\n",
          "message": "Parameter '_scope_0' of AbacusLike.price (clip.sol#47) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 423,
          "vulnerability_to_line": 432,
          "vulnerability_code": "    function _remove(uint256 id) internal {\n\n        uint256 _move    = active[active.length - 1];\n\n        if (id != _move) {\n\n            uint256 _index   = sales[id].pos;\n\n            active[_index]   = _move;\n\n            sales[_move].pos = _index;\n\n        }\n\n        active.pop();\n\n        delete sales[id];\n",
          "message": "Function 'Clipper._remove' (clip.sol#423-432) is not in mixedCase\n"
        }
      ]
    },
    "smartcheck": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 20,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity >=0.6.12;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_REVERT_REQUIRE",
          "vulnerability_from_line": 165,
          "vulnerability_to_line": null,
          "vulnerability_code": "        else if (what == \"stopped\") stopped = data;           // Set breaker (0, 1 or 2)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_REVERT_REQUIRE",
          "vulnerability_from_line": 173,
          "vulnerability_to_line": null,
          "vulnerability_code": "        else if (what == \"calc\")  calc = AbacusLike(data);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 25,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function ilks(bytes32) external returns (uint256, uint256, uint256, uint256, uint256);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 30,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function peek() external returns (bytes32, bool);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 35,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function ilks(bytes32) external returns (PipLike, uint256);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 446,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getStatus(uint256 id) external view returns (bool needsRedo, uint256 price) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 458,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function status(uint96 tic, uint256 top) internal view returns (bool done, uint256 price) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 61,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bytes32  immutable public ilk;   // Collateral type of this Clipper\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 61,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bytes32  immutable public ilk;   // Collateral type of this Clipper\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 179,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint256 constant BLN = 10 **  9;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 180,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint256 constant WAD = 10 ** 18;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 181,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint256 constant RAY = 10 ** 27;\n",
          "message": null
        }
      ]
    },
    "oyente": {
      "successfull_analysis": false,
      "errors": [
        "exception (RuntimeError: Source map error, unknown name(SHR) or instr_name(INVALID))"
      ],
      "vulnerability_findings": []
    },
    "mythril": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "Exception State (SWC 110)",
          "vulnerability_from_line": 94,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint256 public stopped = 0;\n",
          "message": "An assertion violation was triggered.\nIt is possible to trigger an assertion violation. Note that Solidity assert() statements should only be used to check invariants. Review the transaction trace generated for this issue and either make sure your program logic is correct, or use require() instead of assert() if your goal is to constrain user inputs or enforce preconditions. Remember to validate inputs from both callers (for instance, via passed arguments) and callees (for instance, via return values).\nClassification: SWC-110"
        }
      ]
    },
    "osiris": {
      "successfull_analysis": false,
      "errors": [
        "Solidity compilation failed"
      ],
      "vulnerability_findings": []
    }
  }
}