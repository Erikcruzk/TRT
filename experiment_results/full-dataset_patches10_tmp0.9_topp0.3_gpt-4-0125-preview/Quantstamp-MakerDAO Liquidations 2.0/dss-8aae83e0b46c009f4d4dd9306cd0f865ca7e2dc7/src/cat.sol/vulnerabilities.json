{
  "smartbugs_completed": true,
  "analyzer_results": {
    "semgrep": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 91,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor(address vat_) public {\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 92,
          "vulnerability_to_line": null,
          "vulnerability_code": "        wards[msg.sender] = 1;\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 93,
          "vulnerability_to_line": null,
          "vulnerability_code": "        vat = VatLike(vat_);\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 94,
          "vulnerability_to_line": null,
          "vulnerability_code": "        live = 1;\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 95,
          "vulnerability_to_line": null,
          "vulnerability_code": "    }\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 60,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(wards[msg.sender] == 1, \"Cat/not-authorized\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 116,
          "vulnerability_to_line": null,
          "vulnerability_code": "        else revert(\"Cat/file-unrecognized-param\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 120,
          "vulnerability_to_line": null,
          "vulnerability_code": "        else revert(\"Cat/file-unrecognized-param\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 125,
          "vulnerability_to_line": null,
          "vulnerability_code": "        else revert(\"Cat/file-unrecognized-param\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 133,
          "vulnerability_to_line": null,
          "vulnerability_code": "        else revert(\"Cat/file-unrecognized-param\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 141,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(live == 1, \"Cat/not-live\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 142,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(spot > 0 && mul(ink, spot) < mul(art, rate), \"Cat/not-unsafe\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 150,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(litter < box && room >= dust, \"Cat/liquidation-limit-hit\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 157,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(dart >  0      && dink >  0     , \"Cat/null-auction\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 158,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(dart <= 2**255 && dink <= 2**255, \"Cat/overflow\"    );\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 142,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(spot > 0 && mul(ink, spot) < mul(art, rate), \"Cat/not-unsafe\");\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 150,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(litter < box && room >= dust, \"Cat/liquidation-limit-hit\");\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 157,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(dart >  0      && dink >  0     , \"Cat/null-auction\");\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 158,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(dart <= 2**255 && dink <= 2**255, \"Cat/overflow\"    );\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        }
      ]
    },
    "slither": {
      "successfull_analysis": true,
      "errors": [
        "EXIT_CODE_15"
      ],
      "vulnerability_findings": [
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 137,
          "vulnerability_to_line": 182,
          "vulnerability_code": "    function bite(bytes32 ilk, address urn) external returns (uint256 id) {\n\n        (,uint256 rate,uint256 spot,,uint256 dust) = vat.ilks(ilk);\n\n        (uint256 ink, uint256 art) = vat.urns(ilk, urn);\n\n\n\n        require(live == 1, \"Cat/not-live\");\n\n        require(spot > 0 && mul(ink, spot) < mul(art, rate), \"Cat/not-unsafe\");\n\n\n\n        Ilk memory milk = ilks[ilk];\n\n        uint256 dart;\n\n        {\n\n            uint256 room = sub(box, litter);\n\n\n\n            // test whether the remaining space in the litterbox is dusty\n\n            require(litter < box && room >= dust, \"Cat/liquidation-limit-hit\");\n\n\n\n            dart = min(art, mul(min(milk.dunk, room), WAD) / rate / milk.chop);\n\n        }\n\n\n\n        uint256 dink = min(ink, mul(ink, dart) / art);\n\n\n\n        require(dart >  0      && dink >  0     , \"Cat/null-auction\");\n\n        require(dart <= 2**255 && dink <= 2**255, \"Cat/overflow\"    );\n\n\n\n        // This may leave the CDP in a dusty state\n\n        vat.grab(\n\n            ilk, urn, address(this), address(vow), -int256(dink), -int256(dart)\n\n        );\n\n        vow.fess(mul(dart, rate));\n\n\n\n        { // Avoid stack too deep\n\n            // This calcuation will overflow if dart*rate exceeds ~10^14,\n\n            // i.e. the maximum dunk is roughly 100 trillion DAI.\n\n            uint256 tab = mul(mul(dart, rate), milk.chop) / WAD;\n\n            litter = add(litter, tab);\n\n\n\n            id = Kicker(milk.flip).kick({\n\n                urn: urn,\n\n                gal: address(vow),\n\n                tab: tab,\n\n                lot: dink,\n\n                bid: 0\n\n            });\n\n        }\n\n\n\n        emit Bite(ilk, urn, dink, dart, mul(dart, rate), milk.flip, id);\n",
          "message": "Reentrancy in Cat.bite (cat.sol#137-182):\n\tExternal calls:\n\t- (rate,spot,dust) = vat.ilks(ilk) (cat.sol#138)\n\t- (ink,art) = vat.urns(ilk,urn) (cat.sol#139)\n\t- vat.grab(ilk,urn,address(this),address(vow),- int256(dink),- int256(dart)) (cat.sol#161-163)\n\t- vow.fess(mul(dart,rate)) (cat.sol#164)\n\tState variables written after the call(s):\n\t- litter (cat.sol#170)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 127,
          "vulnerability_to_line": 134,
          "vulnerability_code": "    function file(bytes32 ilk, bytes32 what, address flip) external auth {\n\n        if (what == \"flip\") {\n\n            vat.nope(ilks[ilk].flip);\n\n            ilks[ilk].flip = flip;\n\n            vat.hope(flip);\n\n        }\n\n        else revert(\"Cat/file-unrecognized-param\");\n",
          "message": "Reentrancy in Cat.file (cat.sol#127-134):\n\tExternal calls:\n\t- vat.nope(ilks[ilk].flip) (cat.sol#129)\n\tState variables written after the call(s):\n\t- ilks (cat.sol#130)\n"
        },
        {
          "name": "solc-version",
          "vulnerability_from_line": 22,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity >=0.5.12;\n",
          "message": "Detected issues with version pragma in cat.sol:\n\t- pragma solidity>=0.5.12 (cat.sol#22): it allows old versions\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 34,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function ilks(bytes32) external view returns (\n",
          "message": "Parameter '' of VatLike.ilks (cat.sol#34) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 41,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function urns(bytes32,address) external view returns (\n",
          "message": "Parameter '' of VatLike.urns (cat.sol#41) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 41,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function urns(bytes32,address) external view returns (\n",
          "message": "Parameter '_scope_0' of VatLike.urns (cat.sol#41) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 45,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function grab(bytes32,address,address,address,int256,int256) external;\n",
          "message": "Parameter '' of VatLike.grab (cat.sol#45) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 45,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function grab(bytes32,address,address,address,int256,int256) external;\n",
          "message": "Parameter '_scope_0' of VatLike.grab (cat.sol#45) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 45,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function grab(bytes32,address,address,address,int256,int256) external;\n",
          "message": "Parameter '_scope_1' of VatLike.grab (cat.sol#45) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 45,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function grab(bytes32,address,address,address,int256,int256) external;\n",
          "message": "Parameter '_scope_2' of VatLike.grab (cat.sol#45) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 45,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function grab(bytes32,address,address,address,int256,int256) external;\n",
          "message": "Parameter '_scope_3' of VatLike.grab (cat.sol#45) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 45,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function grab(bytes32,address,address,address,int256,int256) external;\n",
          "message": "Parameter '_scope_4' of VatLike.grab (cat.sol#45) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 46,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function hope(address) external;\n",
          "message": "Parameter '' of VatLike.hope (cat.sol#46) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 47,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function nope(address) external;\n",
          "message": "Parameter '' of VatLike.nope (cat.sol#47) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 51,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function fess(uint256) external;\n",
          "message": "Parameter '' of VowLike.fess (cat.sol#51) is not in mixedCase\n"
        }
      ]
    },
    "smartcheck": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 22,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity >=0.5.12;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_REVERT_REQUIRE",
          "vulnerability_from_line": 115,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (what == \"vow\") vow = VowLike(data);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_REVERT_REQUIRE",
          "vulnerability_from_line": 119,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (what == \"box\") box = data;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_REVERT_REQUIRE",
          "vulnerability_from_line": 124,
          "vulnerability_to_line": null,
          "vulnerability_code": "        else if (what == \"dunk\") ilks[ilk].dunk = data;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_REVERT_REQUIRE",
          "vulnerability_from_line": 128,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (what == \"flip\") {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 34,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function ilks(bytes32) external view returns (\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 41,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function urns(bytes32,address) external view returns (\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 98,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint256 constant WAD = 10 ** 18;\n",
          "message": null
        }
      ]
    },
    "oyente": {
      "successfull_analysis": false,
      "errors": [
        "exception (RuntimeError: Source map error, unknown name(SHR) or instr_name(INVALID))"
      ],
      "vulnerability_findings": []
    },
    "mythril": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "Exception State (SWC 110)",
          "vulnerability_from_line": 91,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor(address vat_) public {\n",
          "message": "An assertion violation was triggered.\nIt is possible to trigger an assertion violation. Note that Solidity assert() statements should only be used to check invariants. Review the transaction trace generated for this issue and either make sure your program logic is correct, or use require() instead of assert() if your goal is to constrain user inputs or enforce preconditions. Remember to validate inputs from both callers (for instance, via passed arguments) and callees (for instance, via return values).\nClassification: SWC-110"
        }
      ]
    },
    "osiris": {
      "successfull_analysis": false,
      "errors": [
        "Solidity compilation failed"
      ],
      "vulnerability_findings": []
    }
  }
}