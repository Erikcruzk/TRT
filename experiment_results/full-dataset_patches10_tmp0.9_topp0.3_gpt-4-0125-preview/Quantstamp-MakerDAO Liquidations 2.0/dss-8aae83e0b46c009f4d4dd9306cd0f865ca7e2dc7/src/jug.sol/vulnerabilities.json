{
  "smartbugs_completed": true,
  "analyzer_results": {
    "semgrep": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 58,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor(address vat_) public {\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 59,
          "vulnerability_to_line": null,
          "vulnerability_code": "        wards[msg.sender] = 1;\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 60,
          "vulnerability_to_line": null,
          "vulnerability_code": "        vat = VatLike(vat_);\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 61,
          "vulnerability_to_line": null,
          "vulnerability_code": "    }\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 42,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(wards[msg.sender] == 1, \"Jug/not-authorized\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 105,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(i.duty == 0, \"Jug/ilk-already-init\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 110,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(now == ilks[ilk].rho, \"Jug/rho-not-updated\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 112,
          "vulnerability_to_line": null,
          "vulnerability_code": "        else revert(\"Jug/file-unrecognized-param\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 116,
          "vulnerability_to_line": null,
          "vulnerability_code": "        else revert(\"Jug/file-unrecognized-param\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 120,
          "vulnerability_to_line": null,
          "vulnerability_code": "        else revert(\"Jug/file-unrecognized-param\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 125,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(now >= ilks[ilk].rho, \"Jug/invalid-now\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 94,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(int(x) >= 0 && int(y) >= 0);\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        }
      ]
    },
    "slither": {
      "successfull_analysis": true,
      "errors": [
        "EXIT_CODE_10"
      ],
      "vulnerability_findings": [
        {
          "name": "constant-function",
          "vulnerability_from_line": 64,
          "vulnerability_to_line": 86,
          "vulnerability_code": "    function rpow(uint x, uint n, uint b) internal pure returns (uint z) {\n\n      assembly {\n\n        switch x case 0 {switch n case 0 {z := b} default {z := 0}}\n\n        default {\n\n          switch mod(n, 2) case 0 { z := b } default { z := x }\n\n          let half := div(b, 2)  // for rounding.\n\n          for { n := div(n, 2) } n { n := div(n,2) } {\n\n            let xx := mul(x, x)\n\n            if iszero(eq(div(xx, x), x)) { revert(0,0) }\n\n            let xxRound := add(xx, half)\n\n            if lt(xxRound, xx) { revert(0,0) }\n\n            x := div(xxRound, b)\n\n            if mod(n,2) {\n\n              let zx := mul(z, x)\n\n              if and(iszero(iszero(x)), iszero(eq(div(zx, x), z))) { revert(0,0) }\n\n              let zxRound := add(zx, half)\n\n              if lt(zxRound, zx) { revert(0,0) }\n\n              z := div(zxRound, b)\n\n            }\n\n          }\n\n        }\n\n      }\n",
          "message": "Jug.rpow (jug.sol#64-86) is declared view but contains assembly code\n"
        },
        {
          "name": "incorrect-equality",
          "vulnerability_from_line": 109,
          "vulnerability_to_line": 113,
          "vulnerability_code": "    function file(bytes32 ilk, bytes32 what, uint data) external auth {\n\n        require(now == ilks[ilk].rho, \"Jug/rho-not-updated\");\n\n        if (what == \"duty\") ilks[ilk].duty = data;\n\n        else revert(\"Jug/file-unrecognized-param\");\n",
          "message": "Jug.file (jug.sol#109-113) uses a dangerous strict equality:\n\t- require(bool,string)(now == ilks[ilk].rho,Jug/rho-not-updated)\n"
        },
        {
          "name": "incorrect-equality",
          "vulnerability_from_line": 109,
          "vulnerability_to_line": 113,
          "vulnerability_code": "    function file(bytes32 ilk, bytes32 what, uint data) external auth {\n\n        require(now == ilks[ilk].rho, \"Jug/rho-not-updated\");\n\n        if (what == \"duty\") ilks[ilk].duty = data;\n\n        else revert(\"Jug/file-unrecognized-param\");\n",
          "message": "Jug.file (jug.sol#109-113) uses a dangerous strict equality:\n\t- require(bool,string)(now == ilks[ilk].rho,Jug/rho-not-updated)\nJug.rmul (jug.sol#96-100) uses a dangerous strict equality:\n\t- require(bool)(y == 0 || z / y == x)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 124,
          "vulnerability_to_line": 130,
          "vulnerability_code": "    function drip(bytes32 ilk) external returns (uint rate) {\n\n        require(now >= ilks[ilk].rho, \"Jug/invalid-now\");\n\n        (, uint prev) = vat.ilks(ilk);\n\n        rate = rmul(rpow(add(base, ilks[ilk].duty), now - ilks[ilk].rho, ONE), prev);\n\n        vat.fold(ilk, vow, diff(rate, prev));\n\n        ilks[ilk].rho = now;\n",
          "message": "Reentrancy in Jug.drip (jug.sol#124-130):\n\tExternal calls:\n\t- (prev) = vat.ilks(ilk) (jug.sol#126)\n\t- vat.fold(ilk,vow,diff(rate,prev)) (jug.sol#128)\n\tState variables written after the call(s):\n\t- ilks (jug.sol#129)\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 64,
          "vulnerability_to_line": 86,
          "vulnerability_code": "    function rpow(uint x, uint n, uint b) internal pure returns (uint z) {\n\n      assembly {\n\n        switch x case 0 {switch n case 0 {z := b} default {z := 0}}\n\n        default {\n\n          switch mod(n, 2) case 0 { z := b } default { z := x }\n\n          let half := div(b, 2)  // for rounding.\n\n          for { n := div(n, 2) } n { n := div(n,2) } {\n\n            let xx := mul(x, x)\n\n            if iszero(eq(div(xx, x), x)) { revert(0,0) }\n\n            let xxRound := add(xx, half)\n\n            if lt(xxRound, xx) { revert(0,0) }\n\n            x := div(xxRound, b)\n\n            if mod(n,2) {\n\n              let zx := mul(z, x)\n\n              if and(iszero(iszero(x)), iszero(eq(div(zx, x), z))) { revert(0,0) }\n\n              let zxRound := add(zx, half)\n\n              if lt(zxRound, zx) { revert(0,0) }\n\n              z := div(zxRound, b)\n\n            }\n\n          }\n\n        }\n\n      }\n",
          "message": "Jug.rpow uses assembly (jug.sol#64-86)\n\t- jug.sol#65-85\n"
        },
        {
          "name": "solc-version",
          "vulnerability_from_line": 22,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity >=0.5.12;\n",
          "message": "Detected issues with version pragma in jug.sol:\n\t- pragma solidity>=0.5.12 (jug.sol#22): it allows old versions\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 29,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function ilks(bytes32) external returns (\n",
          "message": "Parameter '' of VatLike.ilks (jug.sol#29) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 33,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function fold(bytes32,address,int) external;\n",
          "message": "Parameter '' of VatLike.fold (jug.sol#33) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 33,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function fold(bytes32,address,int) external;\n",
          "message": "Parameter '_scope_0' of VatLike.fold (jug.sol#33) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 33,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function fold(bytes32,address,int) external;\n",
          "message": "Parameter '_scope_1' of VatLike.fold (jug.sol#33) is not in mixedCase\n"
        }
      ]
    },
    "smartcheck": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "SOLIDITY_EXACT_TIME",
          "vulnerability_from_line": 110,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(now == ilks[ilk].rho, \"Jug/rho-not-updated\");\n",
          "message": null
        },
        {
          "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
          "vulnerability_from_line": 64,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function rpow(uint x, uint n, uint b) internal pure returns (uint z) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 22,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity >=0.5.12;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_REVERT_REQUIRE",
          "vulnerability_from_line": 111,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (what == \"duty\") ilks[ilk].duty = data;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_REVERT_REQUIRE",
          "vulnerability_from_line": 115,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (what == \"base\") base = data;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_REVERT_REQUIRE",
          "vulnerability_from_line": 119,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (what == \"vow\") vow = data;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 64,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function rpow(uint x, uint n, uint b) internal pure returns (uint z) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 29,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function ilks(bytes32) external returns (\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 65,
          "vulnerability_to_line": null,
          "vulnerability_code": "      assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 87,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint256 constant ONE = 10 ** 27;\n",
          "message": null
        }
      ]
    },
    "oyente": {
      "successfull_analysis": false,
      "errors": [
        "exception (RuntimeError: Source map error, unknown name(SHR) or instr_name(INVALID))"
      ],
      "vulnerability_findings": []
    },
    "mythril": {
      "successfull_analysis": false,
      "errors": [
        "Solc experienced a fatal error"
      ],
      "vulnerability_findings": []
    },
    "osiris": {
      "successfull_analysis": false,
      "errors": [
        "Solidity compilation failed"
      ],
      "vulnerability_findings": []
    }
  }
}