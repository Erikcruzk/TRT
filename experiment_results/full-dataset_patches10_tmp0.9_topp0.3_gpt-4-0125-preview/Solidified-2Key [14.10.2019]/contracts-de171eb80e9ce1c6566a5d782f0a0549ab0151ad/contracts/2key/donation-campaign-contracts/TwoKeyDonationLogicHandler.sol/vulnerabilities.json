{
  "smartbugs_completed": true,
  "analyzer_results": {
    "semgrep": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 396,
          "vulnerability_to_line": null,
          "vulnerability_code": "        while (idx + 65 <= sig.length) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 400,
          "vulnerability_to_line": null,
          "vulnerability_code": "            if (idx + msg_len <= sig.length) {  // its  a < and not a <= because we dont want this to be the final iteration for the converter\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 451,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(uint i = 0; i < influencers.length; i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 452,
          "vulnerability_to_line": null,
          "vulnerability_code": "            if (i < weights.length) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 832,
          "vulnerability_to_line": null,
          "vulnerability_code": "                if (i == influencers.length - 1) {  // if its the last influencer then all the bounty goes to it.\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 840,
          "vulnerability_to_line": null,
          "vulnerability_code": "                        b = totalBounty2keys.div(influencers.length - i);\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 836,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    uint256 cut = ITwoKeyDonationCampaign(twoKeyDonationCampaign).getReferrerCut(influencers[i]);\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 867,
          "vulnerability_to_line": null,
          "vulnerability_code": "            influencer = plasmaOf(ITwoKeyDonationCampaign(twoKeyDonationCampaign).getReceivedFrom(influencer));\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 868,
          "vulnerability_to_line": null,
          "vulnerability_code": "            if (influencer == plasmaOf(contractor)) {\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 877,
          "vulnerability_to_line": null,
          "vulnerability_code": "            influencer = plasmaOf(ITwoKeyDonationCampaign(twoKeyDonationCampaign).getReceivedFrom(influencer));\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 913,
          "vulnerability_to_line": null,
          "vulnerability_code": "            earnings[i] = referrerPlasma2EarningsPerConversion[_referrerAddress][_conversionIds[i]];\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 939,
          "vulnerability_to_line": null,
          "vulnerability_code": "            referrersPendingPlasmaBalance[i] = ITwoKeyDonationCampaign(twoKeyDonationCampaign).getReferrerPlasmaBalance(_referrerPlasmaList[i]);\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 940,
          "vulnerability_to_line": null,
          "vulnerability_code": "            referrersTotalEarningsPlasmaBalance[i] = referrerPlasma2TotalEarnings2key[_referrerPlasmaList[i]];\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 451,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(uint i = 0; i < influencers.length; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 523,
          "vulnerability_to_line": null,
          "vulnerability_code": "            for(uint i=0; i<numberOfInfluencers;i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 544,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(uint i=1; i<numberOfElements; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 912,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(uint i=0; i<len; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 938,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i=0; i<numberOfAddresses; i++){\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 323,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require (sig.length >= 65+idx, 'bad signature length');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 350,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(v==27 || v==28,'bad sig v');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 402,
          "vulnerability_to_line": null,
          "vulnerability_code": "                require(weights[count_influencers] > 0,'weight not defined (1..255)');  // 255 are used to indicate default (equal part) behaviour\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 432,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(idx == sig.length,'illegal message size');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 442,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(old_key != address(0),'no public link key');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 453,
          "vulnerability_to_line": null,
          "vulnerability_code": "                require (recoverHash(keccak256(abi.encodePacked(weights[i], keys[i], influencers[i])),sig,offsets[i]) == old_key, 'illegal signature');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 457,
          "vulnerability_to_line": null,
          "vulnerability_code": "                require (recoverHash(keccak256(abi.encodePacked(influencers[i])),sig,offsets[i]) == old_key, 'illegal last signature');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 837,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    if (cut > 0 && cut <= 101) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 838,
          "vulnerability_to_line": null,
          "vulnerability_code": "                        b = totalBounty2keys.mul(cut.sub(1)).div(100);\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 839,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    } else {// cut == 0 or 255 indicates equal particine of the bounty\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 840,
          "vulnerability_to_line": null,
          "vulnerability_code": "                        b = totalBounty2keys.div(influencers.length - i);\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 841,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    }\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-prefix-decrement-not-postfix",
          "vulnerability_from_line": 878,
          "vulnerability_to_line": null,
          "vulnerability_code": "            n_influencers--;\n",
          "message": "Consider using the prefix decrement expression whenever the return value is not needed. The prefix decrement expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 362,
          "vulnerability_to_line": null,
          "vulnerability_code": "            n_influencers++;\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 403,
          "vulnerability_to_line": null,
          "vulnerability_code": "                idx++;\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 430,
          "vulnerability_to_line": null,
          "vulnerability_code": "            count_influencers++;\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 451,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(uint i = 0; i < influencers.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 523,
          "vulnerability_to_line": null,
          "vulnerability_code": "            for(uint i=0; i<numberOfInfluencers;i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 544,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(uint i=1; i<numberOfElements; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 805,
          "vulnerability_to_line": null,
          "vulnerability_code": "            for(i=0; i<numberOfInfluencers; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 815,
          "vulnerability_to_line": null,
          "vulnerability_code": "            for(i=0; i<numberOfInfluencers - 1; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 825,
          "vulnerability_to_line": null,
          "vulnerability_code": "            for(i=0; i<numberOfInfluencers; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 829,
          "vulnerability_to_line": null,
          "vulnerability_code": "            for (i = 0; i < numberOfInfluencers; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 871,
          "vulnerability_to_line": null,
          "vulnerability_code": "            n_influencers++;\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 912,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(uint i=0; i<len; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 938,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i=0; i<numberOfAddresses; i++){\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        }
      ]
    },
    "slither": {
      "successfull_analysis": true,
      "errors": [
        "EXIT_CODE_121"
      ],
      "vulnerability_findings": [
        {
          "name": "uninitialized-state",
          "vulnerability_from_line": 618,
          "vulnerability_to_line": null,
          "vulnerability_code": "    address internal _implementation;\n",
          "message": "UpgradeabilityCampaignStorage._implementation (TwoKeyDonationLogicHandler.sol#618) is never initialized. It is used in:\n\t- implementation (TwoKeyDonationLogicHandler.sol#624-626)\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 207,
          "vulnerability_to_line": 233,
          "vulnerability_code": "    function params0(address c, bytes _method) public view returns (uint answer) {\n\n        // https://medium.com/@blockchain101/calling-the-function-of-another-contract-in-solidity-f9edfa921f4c\n\n        //    dc = c;\n\n        bytes4 sig = bytes4(keccak256(_method));\n\n        assembly {\n\n        // move pointer to free memory spot\n\n            let ptr := mload(0x40)\n\n        // put function sig at memory spot\n\n            mstore(ptr,sig)\n\n\n\n            let result := call(  // use WARNING because this should be staticcall BUT geth crash!\n\n            15000, // gas limit\n\n            c, // sload(dc_slot),  // to addr. append var to _slot to access storage variable\n\n            0, // not transfer any ether (comment if using staticcall)\n\n            ptr, // Inputs are stored at location ptr\n\n            0x04, // Inputs are 0 bytes long\n\n            ptr,  //Store output over input\n\n            0x20) //Outputs are 1 bytes long\n\n\n\n            if eq(result, 0) {\n\n                revert(0, 0)\n\n            }\n\n\n\n            answer := mload(ptr) // Assign output to answer var\n\n            mstore(0x40,add(ptr,0x24)) // Set storage pointer to new space\n\n        }\n",
          "message": "Call.params0 (TwoKeyDonationLogicHandler.sol#207-233) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 235,
          "vulnerability_to_line": 263,
          "vulnerability_code": "    function params1(address c, bytes _method, uint _val) public view returns (uint answer) {\n\n        // https://medium.com/@blockchain101/calling-the-function-of-another-contract-in-solidity-f9edfa921f4c\n\n        //    dc = c;\n\n        bytes4 sig = bytes4(keccak256(_method));\n\n        assembly {\n\n        // move pointer to free memory spot\n\n            let ptr := mload(0x40)\n\n        // put function sig at memory spot\n\n            mstore(ptr,sig)\n\n        // append argument after function sig\n\n            mstore(add(ptr,0x04), _val)\n\n\n\n            let result := call(  // use WARNING because this should be staticcall BUT geth crash!\n\n            15000, // gas limit\n\n            c, // sload(dc_slot),  // to addr. append var to _slot to access storage variable\n\n            0, // not transfer any ether (comment if using staticcall)\n\n            ptr, // Inputs are stored at location ptr\n\n            0x24, // Inputs are 0 bytes long\n\n            ptr,  //Store output over input\n\n            0x20) //Outputs are 1 bytes long\n\n\n\n            if eq(result, 0) {\n\n                revert(0, 0)\n\n            }\n\n\n\n            answer := mload(ptr) // Assign output to answer var\n\n            mstore(0x40,add(ptr,0x24)) // Set storage pointer to new space\n\n        }\n",
          "message": "Call.params1 (TwoKeyDonationLogicHandler.sol#235-263) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 265,
          "vulnerability_to_line": 295,
          "vulnerability_code": "    function params2(address c, bytes _method, uint _val1, uint _val2) public view returns (uint answer) {\n\n        // https://medium.com/@blockchain101/calling-the-function-of-another-contract-in-solidity-f9edfa921f4c\n\n        //    dc = c;\n\n        bytes4 sig = bytes4(keccak256(_method));\n\n        assembly {\n\n        // move pointer to free memory spot\n\n            let ptr := mload(0x40)\n\n        // put function sig at memory spot\n\n            mstore(ptr,sig)\n\n        // append argument after function sig\n\n            mstore(add(ptr,0x04), _val1)\n\n            mstore(add(ptr,0x24), _val2)\n\n\n\n            let result := call(  // use WARNING because this should be staticcall BUT geth crash!\n\n            15000, // gas limit\n\n            c, // sload(dc_slot),  // to addr. append var to _slot to access storage variable\n\n            0, // not transfer any ether (comment if using staticcall)\n\n            ptr, // Inputs are stored at location ptr\n\n            0x44, // Inputs are 4 bytes for signature and 2 uint256\n\n            ptr,  //Store output over input\n\n            0x20) //Outputs are 1 uint long\n\n\n\n        // TODO cause revert\n\n        //            if eq(result, 0) {\n\n        //                revert(0, 0)\n\n        //            }\n\n\n\n            answer := mload(ptr) // Assign output to answer var\n\n            mstore(0x40,add(ptr,0x20)) // Set storage pointer to new space\n\n        }\n",
          "message": "Call.params2 (TwoKeyDonationLogicHandler.sol#265-295) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 297,
          "vulnerability_to_line": 305,
          "vulnerability_code": "    function loadAddress(bytes sig, uint idx) public pure returns (address) {\n\n        address influencer;\n\n        idx += 20;\n\n        assembly\n\n        {\n\n            influencer := mload(add(sig, idx))\n\n        }\n\n        return influencer;\n",
          "message": "Call.loadAddress (TwoKeyDonationLogicHandler.sol#297-305) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 307,
          "vulnerability_to_line": 315,
          "vulnerability_code": "    function loadUint8(bytes sig, uint idx) public pure returns (uint8) {\n\n        uint8 weight;\n\n        idx += 1;\n\n        assembly\n\n        {\n\n            weight := mload(add(sig, idx))\n\n        }\n\n        return weight;\n",
          "message": "Call.loadUint8 (TwoKeyDonationLogicHandler.sol#307-315) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 318,
          "vulnerability_to_line": 353,
          "vulnerability_code": "    function recoverHash(bytes32 hash, bytes sig, uint idx) public pure returns (address) {\n\n        // same as recoverHash in utils/sign.js\n\n        // The signature format is a compact form of:\n\n        //   {bytes32 r}{bytes32 s}{uint8 v}\n\n        // Compact means, uint8 is not padded to 32 bytes.\n\n        require (sig.length >= 65+idx, 'bad signature length');\n\n        idx += 32;\n\n        bytes32 r;\n\n        assembly\n\n        {\n\n            r := mload(add(sig, idx))\n\n        }\n\n\n\n        idx += 32;\n\n        bytes32 s;\n\n        assembly\n\n        {\n\n            s := mload(add(sig, idx))\n\n        }\n\n\n\n        idx += 1;\n\n        uint8 v;\n\n        assembly\n\n        {\n\n            v := mload(add(sig, idx))\n\n        }\n\n        if (v >= 32) { // handle case when signature was made with ethereum web3.eth.sign or getSign which is for signing ethereum transactions\n\n            v -= 32;\n\n            bytes memory prefix = \"\\x19Ethereum Signed Message:\\n32\"; // 32 is the number of bytes in the following hash\n\n            hash = keccak256(abi.encodePacked(prefix, hash));\n\n        }\n\n        if (v <= 1) v += 27;\n\n        require(v==27 || v==28,'bad sig v');\n\n        return ecrecover(hash, v, r, s);\n\n\n",
          "message": "Call.recoverHash (TwoKeyDonationLogicHandler.sol#318-353) is declared view but contains assembly code\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 689,
          "vulnerability_to_line": 727,
          "vulnerability_code": "    function setInitialParamsDonationLogicHandler(\n\n        uint[] numberValues,\n\n        string _currency,\n\n        address _contractor,\n\n        address _moderator,\n\n        address twoKeySingletonRegistry,\n\n        address _twoKeyDonationCampaign,\n\n        address _twoKeyDonationConversionHandler\n\n    )\n\n    public\n\n    {\n\n        require(initialized == false);\n\n\n\n        twoKeyDonationCampaign = _twoKeyDonationCampaign;\n\n        twoKeyDonationConversionHandler = _twoKeyDonationConversionHandler;\n\n\n\n        powerLawFactor = 2;\n\n        campaignStartTime = numberValues[1];\n\n        campaignEndTime = numberValues[2];\n\n        minDonationAmountWei = numberValues[3];\n\n        maxDonationAmountWei = numberValues[4];\n\n        campaignGoal = numberValues[5];\n\n        incentiveModel = IncentiveModel(numberValues[7]);\n\n\n\n        contractor = _contractor;\n\n        moderator = _moderator;\n\n        currency = _currency;\n\n\n\n        twoKeySingletoneRegistry = twoKeySingletonRegistry;\n\n        twoKeyEventSource = ITwoKeySingletoneRegistryFetchAddress(twoKeySingletoneRegistry)\n\n            .getContractProxyAddress(\"TwoKeyEventSource\");\n\n        twoKeyMaintainersRegistry = ITwoKeySingletoneRegistryFetchAddress(twoKeySingletoneRegistry)\n\n            .getContractProxyAddress(\"TwoKeyMaintainersRegistry\");\n\n        twoKeyRegistry = ITwoKeySingletoneRegistryFetchAddress(twoKeySingletoneRegistry)\n\n            .getContractProxyAddress(\"TwoKeyRegistry\");\n\n\n\n        ownerPlasma = plasmaOf(contractor);\n\n        initialized = true;\n",
          "message": "Reentrancy in TwoKeyDonationLogicHandler.setInitialParamsDonationLogicHandler (TwoKeyDonationLogicHandler.sol#689-727):\n\tExternal calls:\n\t- twoKeyEventSource = ITwoKeySingletoneRegistryFetchAddress(twoKeySingletoneRegistry).getContractProxyAddress(TwoKeyEventSource) (TwoKeyDonationLogicHandler.sol#718-719)\n\t- twoKeyMaintainersRegistry = ITwoKeySingletoneRegistryFetchAddress(twoKeySingletoneRegistry).getContractProxyAddress(TwoKeyMaintainersRegistry) (TwoKeyDonationLogicHandler.sol#720-721)\n\t- twoKeyRegistry = ITwoKeySingletoneRegistryFetchAddress(twoKeySingletoneRegistry).getContractProxyAddress(TwoKeyRegistry) (TwoKeyDonationLogicHandler.sol#722-723)\n\t- ownerPlasma = plasmaOf(contractor) (TwoKeyDonationLogicHandler.sol#725)\n\tState variables written after the call(s):\n\t- initialized (TwoKeyDonationLogicHandler.sol#726)\n"
        },
        {
          "name": "uninitialized-local",
          "vulnerability_from_line": 1058,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address _address;\n",
          "message": "_address in TwoKeyDonationLogicHandler.getSuperStatistics (TwoKeyDonationLogicHandler.sol#1058) is a local variable never initialiazed\n"
        },
        {
          "name": "uninitialized-local",
          "vulnerability_from_line": 1056,
          "vulnerability_to_line": null,
          "vulnerability_code": "        bool flag;\n",
          "message": "flag in TwoKeyDonationLogicHandler.getSuperStatistics (TwoKeyDonationLogicHandler.sol#1056) is a local variable never initialiazed\n"
        },
        {
          "name": "uninitialized-local",
          "vulnerability_from_line": 991,
          "vulnerability_to_line": null,
          "vulnerability_code": "            bool isConverter;\n",
          "message": "isConverter in TwoKeyDonationLogicHandler.getAddressStatistic (TwoKeyDonationLogicHandler.sol#991) is a local variable never initialiazed\n"
        },
        {
          "name": "uninitialized-local",
          "vulnerability_from_line": 983,
          "vulnerability_to_line": null,
          "vulnerability_code": "        bytes32 state; // NOT-EXISTING AS CONVERTER DEFAULT STATE\n",
          "message": "state in TwoKeyDonationLogicHandler.getAddressStatistic (TwoKeyDonationLogicHandler.sol#983) is a local variable never initialiazed\n"
        },
        {
          "name": "uninitialized-local",
          "vulnerability_from_line": 992,
          "vulnerability_to_line": null,
          "vulnerability_code": "            bool isReferrer;\n",
          "message": "isReferrer in TwoKeyDonationLogicHandler.getAddressStatistic (TwoKeyDonationLogicHandler.sol#992) is a local variable never initialiazed\n"
        },
        {
          "name": "calls-loop",
          "vulnerability_from_line": 836,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    uint256 cut = ITwoKeyDonationCampaign(twoKeyDonationCampaign).getReferrerCut(influencers[i]);\n",
          "message": "TwoKeyDonationLogicHandler.updateRefchainRewards has external calls inside a loop:\n\t- cut = ITwoKeyDonationCampaign(twoKeyDonationCampaign).getReferrerCut(influencers[i]) (TwoKeyDonationLogicHandler.sol#836)\n"
        },
        {
          "name": "calls-loop",
          "vulnerability_from_line": 867,
          "vulnerability_to_line": null,
          "vulnerability_code": "            influencer = plasmaOf(ITwoKeyDonationCampaign(twoKeyDonationCampaign).getReceivedFrom(influencer));\n",
          "message": "TwoKeyDonationLogicHandler.getReferrers has external calls inside a loop:\n\t- influencer = plasmaOf(ITwoKeyDonationCampaign(twoKeyDonationCampaign).getReceivedFrom(influencer)) (TwoKeyDonationLogicHandler.sol#867)\n"
        },
        {
          "name": "calls-loop",
          "vulnerability_from_line": 877,
          "vulnerability_to_line": null,
          "vulnerability_code": "            influencer = plasmaOf(ITwoKeyDonationCampaign(twoKeyDonationCampaign).getReceivedFrom(influencer));\n",
          "message": "TwoKeyDonationLogicHandler.getReferrers has external calls inside a loop:\n\t- influencer = plasmaOf(ITwoKeyDonationCampaign(twoKeyDonationCampaign).getReceivedFrom(influencer)) (TwoKeyDonationLogicHandler.sol#877)\n"
        },
        {
          "name": "calls-loop",
          "vulnerability_from_line": 939,
          "vulnerability_to_line": null,
          "vulnerability_code": "            referrersPendingPlasmaBalance[i] = ITwoKeyDonationCampaign(twoKeyDonationCampaign).getReferrerPlasmaBalance(_referrerPlasmaList[i]);\n",
          "message": "TwoKeyDonationLogicHandler.getReferrersBalancesAndTotalEarnings has external calls inside a loop:\n\t- referrersPendingPlasmaBalance[i] = ITwoKeyDonationCampaign(twoKeyDonationCampaign).getReferrerPlasmaBalance(_referrerPlasmaList[i]) (TwoKeyDonationLogicHandler.sol#939)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 689,
          "vulnerability_to_line": 727,
          "vulnerability_code": "    function setInitialParamsDonationLogicHandler(\n\n        uint[] numberValues,\n\n        string _currency,\n\n        address _contractor,\n\n        address _moderator,\n\n        address twoKeySingletonRegistry,\n\n        address _twoKeyDonationCampaign,\n\n        address _twoKeyDonationConversionHandler\n\n    )\n\n    public\n\n    {\n\n        require(initialized == false);\n\n\n\n        twoKeyDonationCampaign = _twoKeyDonationCampaign;\n\n        twoKeyDonationConversionHandler = _twoKeyDonationConversionHandler;\n\n\n\n        powerLawFactor = 2;\n\n        campaignStartTime = numberValues[1];\n\n        campaignEndTime = numberValues[2];\n\n        minDonationAmountWei = numberValues[3];\n\n        maxDonationAmountWei = numberValues[4];\n\n        campaignGoal = numberValues[5];\n\n        incentiveModel = IncentiveModel(numberValues[7]);\n\n\n\n        contractor = _contractor;\n\n        moderator = _moderator;\n\n        currency = _currency;\n\n\n\n        twoKeySingletoneRegistry = twoKeySingletonRegistry;\n\n        twoKeyEventSource = ITwoKeySingletoneRegistryFetchAddress(twoKeySingletoneRegistry)\n\n            .getContractProxyAddress(\"TwoKeyEventSource\");\n\n        twoKeyMaintainersRegistry = ITwoKeySingletoneRegistryFetchAddress(twoKeySingletoneRegistry)\n\n            .getContractProxyAddress(\"TwoKeyMaintainersRegistry\");\n\n        twoKeyRegistry = ITwoKeySingletoneRegistryFetchAddress(twoKeySingletoneRegistry)\n\n            .getContractProxyAddress(\"TwoKeyRegistry\");\n\n\n\n        ownerPlasma = plasmaOf(contractor);\n\n        initialized = true;\n",
          "message": "Reentrancy in TwoKeyDonationLogicHandler.setInitialParamsDonationLogicHandler (TwoKeyDonationLogicHandler.sol#689-727):\n\tExternal calls:\n\t- twoKeyEventSource = ITwoKeySingletoneRegistryFetchAddress(twoKeySingletoneRegistry).getContractProxyAddress(TwoKeyEventSource) (TwoKeyDonationLogicHandler.sol#718-719)\n\t- twoKeyMaintainersRegistry = ITwoKeySingletoneRegistryFetchAddress(twoKeySingletoneRegistry).getContractProxyAddress(TwoKeyMaintainersRegistry) (TwoKeyDonationLogicHandler.sol#720-721)\n\tState variables written after the call(s):\n\t- twoKeyMaintainersRegistry (TwoKeyDonationLogicHandler.sol#720-721)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 689,
          "vulnerability_to_line": 727,
          "vulnerability_code": "    function setInitialParamsDonationLogicHandler(\n\n        uint[] numberValues,\n\n        string _currency,\n\n        address _contractor,\n\n        address _moderator,\n\n        address twoKeySingletonRegistry,\n\n        address _twoKeyDonationCampaign,\n\n        address _twoKeyDonationConversionHandler\n\n    )\n\n    public\n\n    {\n\n        require(initialized == false);\n\n\n\n        twoKeyDonationCampaign = _twoKeyDonationCampaign;\n\n        twoKeyDonationConversionHandler = _twoKeyDonationConversionHandler;\n\n\n\n        powerLawFactor = 2;\n\n        campaignStartTime = numberValues[1];\n\n        campaignEndTime = numberValues[2];\n\n        minDonationAmountWei = numberValues[3];\n\n        maxDonationAmountWei = numberValues[4];\n\n        campaignGoal = numberValues[5];\n\n        incentiveModel = IncentiveModel(numberValues[7]);\n\n\n\n        contractor = _contractor;\n\n        moderator = _moderator;\n\n        currency = _currency;\n\n\n\n        twoKeySingletoneRegistry = twoKeySingletonRegistry;\n\n        twoKeyEventSource = ITwoKeySingletoneRegistryFetchAddress(twoKeySingletoneRegistry)\n\n            .getContractProxyAddress(\"TwoKeyEventSource\");\n\n        twoKeyMaintainersRegistry = ITwoKeySingletoneRegistryFetchAddress(twoKeySingletoneRegistry)\n\n            .getContractProxyAddress(\"TwoKeyMaintainersRegistry\");\n\n        twoKeyRegistry = ITwoKeySingletoneRegistryFetchAddress(twoKeySingletoneRegistry)\n\n            .getContractProxyAddress(\"TwoKeyRegistry\");\n\n\n\n        ownerPlasma = plasmaOf(contractor);\n\n        initialized = true;\n",
          "message": "Reentrancy in TwoKeyDonationLogicHandler.setInitialParamsDonationLogicHandler (TwoKeyDonationLogicHandler.sol#689-727):\n\tExternal calls:\n\t- twoKeyEventSource = ITwoKeySingletoneRegistryFetchAddress(twoKeySingletoneRegistry).getContractProxyAddress(TwoKeyEventSource) (TwoKeyDonationLogicHandler.sol#718-719)\n\t- twoKeyMaintainersRegistry = ITwoKeySingletoneRegistryFetchAddress(twoKeySingletoneRegistry).getContractProxyAddress(TwoKeyMaintainersRegistry) (TwoKeyDonationLogicHandler.sol#720-721)\n\t- twoKeyRegistry = ITwoKeySingletoneRegistryFetchAddress(twoKeySingletoneRegistry).getContractProxyAddress(TwoKeyRegistry) (TwoKeyDonationLogicHandler.sol#722-723)\n\tState variables written after the call(s):\n\t- twoKeyRegistry (TwoKeyDonationLogicHandler.sol#722-723)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 689,
          "vulnerability_to_line": 727,
          "vulnerability_code": "    function setInitialParamsDonationLogicHandler(\n\n        uint[] numberValues,\n\n        string _currency,\n\n        address _contractor,\n\n        address _moderator,\n\n        address twoKeySingletonRegistry,\n\n        address _twoKeyDonationCampaign,\n\n        address _twoKeyDonationConversionHandler\n\n    )\n\n    public\n\n    {\n\n        require(initialized == false);\n\n\n\n        twoKeyDonationCampaign = _twoKeyDonationCampaign;\n\n        twoKeyDonationConversionHandler = _twoKeyDonationConversionHandler;\n\n\n\n        powerLawFactor = 2;\n\n        campaignStartTime = numberValues[1];\n\n        campaignEndTime = numberValues[2];\n\n        minDonationAmountWei = numberValues[3];\n\n        maxDonationAmountWei = numberValues[4];\n\n        campaignGoal = numberValues[5];\n\n        incentiveModel = IncentiveModel(numberValues[7]);\n\n\n\n        contractor = _contractor;\n\n        moderator = _moderator;\n\n        currency = _currency;\n\n\n\n        twoKeySingletoneRegistry = twoKeySingletonRegistry;\n\n        twoKeyEventSource = ITwoKeySingletoneRegistryFetchAddress(twoKeySingletoneRegistry)\n\n            .getContractProxyAddress(\"TwoKeyEventSource\");\n\n        twoKeyMaintainersRegistry = ITwoKeySingletoneRegistryFetchAddress(twoKeySingletoneRegistry)\n\n            .getContractProxyAddress(\"TwoKeyMaintainersRegistry\");\n\n        twoKeyRegistry = ITwoKeySingletoneRegistryFetchAddress(twoKeySingletoneRegistry)\n\n            .getContractProxyAddress(\"TwoKeyRegistry\");\n\n\n\n        ownerPlasma = plasmaOf(contractor);\n\n        initialized = true;\n",
          "message": "Reentrancy in TwoKeyDonationLogicHandler.setInitialParamsDonationLogicHandler (TwoKeyDonationLogicHandler.sol#689-727):\n\tExternal calls:\n\t- twoKeyEventSource = ITwoKeySingletoneRegistryFetchAddress(twoKeySingletoneRegistry).getContractProxyAddress(TwoKeyEventSource) (TwoKeyDonationLogicHandler.sol#718-719)\n\t- twoKeyMaintainersRegistry = ITwoKeySingletoneRegistryFetchAddress(twoKeySingletoneRegistry).getContractProxyAddress(TwoKeyMaintainersRegistry) (TwoKeyDonationLogicHandler.sol#720-721)\n\t- twoKeyRegistry = ITwoKeySingletoneRegistryFetchAddress(twoKeySingletoneRegistry).getContractProxyAddress(TwoKeyRegistry) (TwoKeyDonationLogicHandler.sol#722-723)\n\t- ownerPlasma = plasmaOf(contractor) (TwoKeyDonationLogicHandler.sol#725)\n\tState variables written after the call(s):\n\t- ownerPlasma (TwoKeyDonationLogicHandler.sol#725)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 785,
          "vulnerability_to_line": 849,
          "vulnerability_code": "    function updateRefchainRewards(\n\n        uint256 _maxReferralRewardETHWei,\n\n        address _converter,\n\n        uint _conversionId,\n\n        uint totalBounty2keys\n\n    )\n\n    public\n\n    {\n\n        require(msg.sender == twoKeyDonationCampaign);\n\n\n\n//        Get all the influencers\n\n        address[] memory influencers = getReferrers(_converter);\n\n\n\n        //Get array length\n\n        uint numberOfInfluencers = influencers.length;\n\n\n\n        uint i;\n\n        uint reward;\n\n        if(incentiveModel == IncentiveModel.VANILLA_AVERAGE) {\n\n            reward = IncentiveModels.averageModelRewards(totalBounty2keys, numberOfInfluencers);\n\n            for(i=0; i<numberOfInfluencers; i++) {\n\n                updateReferrerMappings(influencers[i], reward, _conversionId);\n\n\n\n            }\n\n        } else if (incentiveModel == IncentiveModel.VANILLA_AVERAGE_LAST_3X) {\n\n            uint rewardForLast;\n\n            // Calculate reward for regular ones and for the last\n\n            (reward, rewardForLast) = IncentiveModels.averageLast3xRewards(totalBounty2keys, numberOfInfluencers);\n\n\n\n            //Update equal rewards to all influencers but last\n\n            for(i=0; i<numberOfInfluencers - 1; i++) {\n\n                updateReferrerMappings(influencers[i], reward, _conversionId);\n\n\n\n            }\n\n            //Update reward for last\n\n            updateReferrerMappings(influencers[numberOfInfluencers-1], rewardForLast, _conversionId);\n\n        } else if(incentiveModel == IncentiveModel.VANILLA_POWER_LAW) {\n\n            // Get rewards per referrer\n\n            uint [] memory rewards = IncentiveModels.powerLawRewards(totalBounty2keys, numberOfInfluencers, 2);\n\n            //Iterate through all referrers and distribute rewards\n\n            for(i=0; i<numberOfInfluencers; i++) {\n\n                updateReferrerMappings(influencers[i], rewards[i], _conversionId);\n\n            }\n\n        } else if(incentiveModel == IncentiveModel.MANUAL) {\n\n            for (i = 0; i < numberOfInfluencers; i++) {\n\n                uint256 b;\n\n\n\n                if (i == influencers.length - 1) {  // if its the last influencer then all the bounty goes to it.\n\n                    b = totalBounty2keys;\n\n                }\n\n                else {\n\n                    uint256 cut = ITwoKeyDonationCampaign(twoKeyDonationCampaign).getReferrerCut(influencers[i]);\n\n                    if (cut > 0 && cut <= 101) {\n\n                        b = totalBounty2keys.mul(cut.sub(1)).div(100);\n\n                    } else {// cut == 0 or 255 indicates equal particine of the bounty\n\n                        b = totalBounty2keys.div(influencers.length - i);\n\n                    }\n\n                }\n\n\n\n                updateReferrerMappings(influencers[i], b, _conversionId);\n\n                //Decrease bounty for distributed\n\n                totalBounty2keys = totalBounty2keys.sub(b);\n\n            }\n\n        }\n",
          "message": "Reentrancy in TwoKeyDonationLogicHandler.updateRefchainRewards (TwoKeyDonationLogicHandler.sol#785-849):\n\tExternal calls:\n\t- influencers = getReferrers(_converter) (TwoKeyDonationLogicHandler.sol#796)\n\t- updateReferrerMappings(influencers[i],reward,_conversionId) (TwoKeyDonationLogicHandler.sol#806)\n\tState variables written after the call(s):\n\t- referrerPlasma2EarningsPerConversion (TwoKeyDonationLogicHandler.sol#806)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 785,
          "vulnerability_to_line": 849,
          "vulnerability_code": "    function updateRefchainRewards(\n\n        uint256 _maxReferralRewardETHWei,\n\n        address _converter,\n\n        uint _conversionId,\n\n        uint totalBounty2keys\n\n    )\n\n    public\n\n    {\n\n        require(msg.sender == twoKeyDonationCampaign);\n\n\n\n//        Get all the influencers\n\n        address[] memory influencers = getReferrers(_converter);\n\n\n\n        //Get array length\n\n        uint numberOfInfluencers = influencers.length;\n\n\n\n        uint i;\n\n        uint reward;\n\n        if(incentiveModel == IncentiveModel.VANILLA_AVERAGE) {\n\n            reward = IncentiveModels.averageModelRewards(totalBounty2keys, numberOfInfluencers);\n\n            for(i=0; i<numberOfInfluencers; i++) {\n\n                updateReferrerMappings(influencers[i], reward, _conversionId);\n\n\n\n            }\n\n        } else if (incentiveModel == IncentiveModel.VANILLA_AVERAGE_LAST_3X) {\n\n            uint rewardForLast;\n\n            // Calculate reward for regular ones and for the last\n\n            (reward, rewardForLast) = IncentiveModels.averageLast3xRewards(totalBounty2keys, numberOfInfluencers);\n\n\n\n            //Update equal rewards to all influencers but last\n\n            for(i=0; i<numberOfInfluencers - 1; i++) {\n\n                updateReferrerMappings(influencers[i], reward, _conversionId);\n\n\n\n            }\n\n            //Update reward for last\n\n            updateReferrerMappings(influencers[numberOfInfluencers-1], rewardForLast, _conversionId);\n\n        } else if(incentiveModel == IncentiveModel.VANILLA_POWER_LAW) {\n\n            // Get rewards per referrer\n\n            uint [] memory rewards = IncentiveModels.powerLawRewards(totalBounty2keys, numberOfInfluencers, 2);\n\n            //Iterate through all referrers and distribute rewards\n\n            for(i=0; i<numberOfInfluencers; i++) {\n\n                updateReferrerMappings(influencers[i], rewards[i], _conversionId);\n\n            }\n\n        } else if(incentiveModel == IncentiveModel.MANUAL) {\n\n            for (i = 0; i < numberOfInfluencers; i++) {\n\n                uint256 b;\n\n\n\n                if (i == influencers.length - 1) {  // if its the last influencer then all the bounty goes to it.\n\n                    b = totalBounty2keys;\n\n                }\n\n                else {\n\n                    uint256 cut = ITwoKeyDonationCampaign(twoKeyDonationCampaign).getReferrerCut(influencers[i]);\n\n                    if (cut > 0 && cut <= 101) {\n\n                        b = totalBounty2keys.mul(cut.sub(1)).div(100);\n\n                    } else {// cut == 0 or 255 indicates equal particine of the bounty\n\n                        b = totalBounty2keys.div(influencers.length - i);\n\n                    }\n\n                }\n\n\n\n                updateReferrerMappings(influencers[i], b, _conversionId);\n\n                //Decrease bounty for distributed\n\n                totalBounty2keys = totalBounty2keys.sub(b);\n\n            }\n\n        }\n",
          "message": "Reentrancy in TwoKeyDonationLogicHandler.updateRefchainRewards (TwoKeyDonationLogicHandler.sol#785-849):\n\tExternal calls:\n\t- influencers = getReferrers(_converter) (TwoKeyDonationLogicHandler.sol#796)\n\t- updateReferrerMappings(influencers[i],reward,_conversionId) (TwoKeyDonationLogicHandler.sol#816)\n\tState variables written after the call(s):\n\t- referrerPlasma2EarningsPerConversion (TwoKeyDonationLogicHandler.sol#816)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 785,
          "vulnerability_to_line": 849,
          "vulnerability_code": "    function updateRefchainRewards(\n\n        uint256 _maxReferralRewardETHWei,\n\n        address _converter,\n\n        uint _conversionId,\n\n        uint totalBounty2keys\n\n    )\n\n    public\n\n    {\n\n        require(msg.sender == twoKeyDonationCampaign);\n\n\n\n//        Get all the influencers\n\n        address[] memory influencers = getReferrers(_converter);\n\n\n\n        //Get array length\n\n        uint numberOfInfluencers = influencers.length;\n\n\n\n        uint i;\n\n        uint reward;\n\n        if(incentiveModel == IncentiveModel.VANILLA_AVERAGE) {\n\n            reward = IncentiveModels.averageModelRewards(totalBounty2keys, numberOfInfluencers);\n\n            for(i=0; i<numberOfInfluencers; i++) {\n\n                updateReferrerMappings(influencers[i], reward, _conversionId);\n\n\n\n            }\n\n        } else if (incentiveModel == IncentiveModel.VANILLA_AVERAGE_LAST_3X) {\n\n            uint rewardForLast;\n\n            // Calculate reward for regular ones and for the last\n\n            (reward, rewardForLast) = IncentiveModels.averageLast3xRewards(totalBounty2keys, numberOfInfluencers);\n\n\n\n            //Update equal rewards to all influencers but last\n\n            for(i=0; i<numberOfInfluencers - 1; i++) {\n\n                updateReferrerMappings(influencers[i], reward, _conversionId);\n\n\n\n            }\n\n            //Update reward for last\n\n            updateReferrerMappings(influencers[numberOfInfluencers-1], rewardForLast, _conversionId);\n\n        } else if(incentiveModel == IncentiveModel.VANILLA_POWER_LAW) {\n\n            // Get rewards per referrer\n\n            uint [] memory rewards = IncentiveModels.powerLawRewards(totalBounty2keys, numberOfInfluencers, 2);\n\n            //Iterate through all referrers and distribute rewards\n\n            for(i=0; i<numberOfInfluencers; i++) {\n\n                updateReferrerMappings(influencers[i], rewards[i], _conversionId);\n\n            }\n\n        } else if(incentiveModel == IncentiveModel.MANUAL) {\n\n            for (i = 0; i < numberOfInfluencers; i++) {\n\n                uint256 b;\n\n\n\n                if (i == influencers.length - 1) {  // if its the last influencer then all the bounty goes to it.\n\n                    b = totalBounty2keys;\n\n                }\n\n                else {\n\n                    uint256 cut = ITwoKeyDonationCampaign(twoKeyDonationCampaign).getReferrerCut(influencers[i]);\n\n                    if (cut > 0 && cut <= 101) {\n\n                        b = totalBounty2keys.mul(cut.sub(1)).div(100);\n\n                    } else {// cut == 0 or 255 indicates equal particine of the bounty\n\n                        b = totalBounty2keys.div(influencers.length - i);\n\n                    }\n\n                }\n\n\n\n                updateReferrerMappings(influencers[i], b, _conversionId);\n\n                //Decrease bounty for distributed\n\n                totalBounty2keys = totalBounty2keys.sub(b);\n\n            }\n\n        }\n",
          "message": "Reentrancy in TwoKeyDonationLogicHandler.updateRefchainRewards (TwoKeyDonationLogicHandler.sol#785-849):\n\tExternal calls:\n\t- influencers = getReferrers(_converter) (TwoKeyDonationLogicHandler.sol#796)\n\t- updateReferrerMappings(influencers[numberOfInfluencers - 1],rewardForLast,_conversionId) (TwoKeyDonationLogicHandler.sol#820)\n\tState variables written after the call(s):\n\t- referrerPlasma2EarningsPerConversion (TwoKeyDonationLogicHandler.sol#820)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 785,
          "vulnerability_to_line": 849,
          "vulnerability_code": "    function updateRefchainRewards(\n\n        uint256 _maxReferralRewardETHWei,\n\n        address _converter,\n\n        uint _conversionId,\n\n        uint totalBounty2keys\n\n    )\n\n    public\n\n    {\n\n        require(msg.sender == twoKeyDonationCampaign);\n\n\n\n//        Get all the influencers\n\n        address[] memory influencers = getReferrers(_converter);\n\n\n\n        //Get array length\n\n        uint numberOfInfluencers = influencers.length;\n\n\n\n        uint i;\n\n        uint reward;\n\n        if(incentiveModel == IncentiveModel.VANILLA_AVERAGE) {\n\n            reward = IncentiveModels.averageModelRewards(totalBounty2keys, numberOfInfluencers);\n\n            for(i=0; i<numberOfInfluencers; i++) {\n\n                updateReferrerMappings(influencers[i], reward, _conversionId);\n\n\n\n            }\n\n        } else if (incentiveModel == IncentiveModel.VANILLA_AVERAGE_LAST_3X) {\n\n            uint rewardForLast;\n\n            // Calculate reward for regular ones and for the last\n\n            (reward, rewardForLast) = IncentiveModels.averageLast3xRewards(totalBounty2keys, numberOfInfluencers);\n\n\n\n            //Update equal rewards to all influencers but last\n\n            for(i=0; i<numberOfInfluencers - 1; i++) {\n\n                updateReferrerMappings(influencers[i], reward, _conversionId);\n\n\n\n            }\n\n            //Update reward for last\n\n            updateReferrerMappings(influencers[numberOfInfluencers-1], rewardForLast, _conversionId);\n\n        } else if(incentiveModel == IncentiveModel.VANILLA_POWER_LAW) {\n\n            // Get rewards per referrer\n\n            uint [] memory rewards = IncentiveModels.powerLawRewards(totalBounty2keys, numberOfInfluencers, 2);\n\n            //Iterate through all referrers and distribute rewards\n\n            for(i=0; i<numberOfInfluencers; i++) {\n\n                updateReferrerMappings(influencers[i], rewards[i], _conversionId);\n\n            }\n\n        } else if(incentiveModel == IncentiveModel.MANUAL) {\n\n            for (i = 0; i < numberOfInfluencers; i++) {\n\n                uint256 b;\n\n\n\n                if (i == influencers.length - 1) {  // if its the last influencer then all the bounty goes to it.\n\n                    b = totalBounty2keys;\n\n                }\n\n                else {\n\n                    uint256 cut = ITwoKeyDonationCampaign(twoKeyDonationCampaign).getReferrerCut(influencers[i]);\n\n                    if (cut > 0 && cut <= 101) {\n\n                        b = totalBounty2keys.mul(cut.sub(1)).div(100);\n\n                    } else {// cut == 0 or 255 indicates equal particine of the bounty\n\n                        b = totalBounty2keys.div(influencers.length - i);\n\n                    }\n\n                }\n\n\n\n                updateReferrerMappings(influencers[i], b, _conversionId);\n\n                //Decrease bounty for distributed\n\n                totalBounty2keys = totalBounty2keys.sub(b);\n\n            }\n\n        }\n",
          "message": "Reentrancy in TwoKeyDonationLogicHandler.updateRefchainRewards (TwoKeyDonationLogicHandler.sol#785-849):\n\tExternal calls:\n\t- influencers = getReferrers(_converter) (TwoKeyDonationLogicHandler.sol#796)\n\t- updateReferrerMappings(influencers[i],rewards[i],_conversionId) (TwoKeyDonationLogicHandler.sol#826)\n\tState variables written after the call(s):\n\t- referrerPlasma2EarningsPerConversion (TwoKeyDonationLogicHandler.sol#826)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 785,
          "vulnerability_to_line": 849,
          "vulnerability_code": "    function updateRefchainRewards(\n\n        uint256 _maxReferralRewardETHWei,\n\n        address _converter,\n\n        uint _conversionId,\n\n        uint totalBounty2keys\n\n    )\n\n    public\n\n    {\n\n        require(msg.sender == twoKeyDonationCampaign);\n\n\n\n//        Get all the influencers\n\n        address[] memory influencers = getReferrers(_converter);\n\n\n\n        //Get array length\n\n        uint numberOfInfluencers = influencers.length;\n\n\n\n        uint i;\n\n        uint reward;\n\n        if(incentiveModel == IncentiveModel.VANILLA_AVERAGE) {\n\n            reward = IncentiveModels.averageModelRewards(totalBounty2keys, numberOfInfluencers);\n\n            for(i=0; i<numberOfInfluencers; i++) {\n\n                updateReferrerMappings(influencers[i], reward, _conversionId);\n\n\n\n            }\n\n        } else if (incentiveModel == IncentiveModel.VANILLA_AVERAGE_LAST_3X) {\n\n            uint rewardForLast;\n\n            // Calculate reward for regular ones and for the last\n\n            (reward, rewardForLast) = IncentiveModels.averageLast3xRewards(totalBounty2keys, numberOfInfluencers);\n\n\n\n            //Update equal rewards to all influencers but last\n\n            for(i=0; i<numberOfInfluencers - 1; i++) {\n\n                updateReferrerMappings(influencers[i], reward, _conversionId);\n\n\n\n            }\n\n            //Update reward for last\n\n            updateReferrerMappings(influencers[numberOfInfluencers-1], rewardForLast, _conversionId);\n\n        } else if(incentiveModel == IncentiveModel.VANILLA_POWER_LAW) {\n\n            // Get rewards per referrer\n\n            uint [] memory rewards = IncentiveModels.powerLawRewards(totalBounty2keys, numberOfInfluencers, 2);\n\n            //Iterate through all referrers and distribute rewards\n\n            for(i=0; i<numberOfInfluencers; i++) {\n\n                updateReferrerMappings(influencers[i], rewards[i], _conversionId);\n\n            }\n\n        } else if(incentiveModel == IncentiveModel.MANUAL) {\n\n            for (i = 0; i < numberOfInfluencers; i++) {\n\n                uint256 b;\n\n\n\n                if (i == influencers.length - 1) {  // if its the last influencer then all the bounty goes to it.\n\n                    b = totalBounty2keys;\n\n                }\n\n                else {\n\n                    uint256 cut = ITwoKeyDonationCampaign(twoKeyDonationCampaign).getReferrerCut(influencers[i]);\n\n                    if (cut > 0 && cut <= 101) {\n\n                        b = totalBounty2keys.mul(cut.sub(1)).div(100);\n\n                    } else {// cut == 0 or 255 indicates equal particine of the bounty\n\n                        b = totalBounty2keys.div(influencers.length - i);\n\n                    }\n\n                }\n\n\n\n                updateReferrerMappings(influencers[i], b, _conversionId);\n\n                //Decrease bounty for distributed\n\n                totalBounty2keys = totalBounty2keys.sub(b);\n\n            }\n\n        }\n",
          "message": "Reentrancy in TwoKeyDonationLogicHandler.updateRefchainRewards (TwoKeyDonationLogicHandler.sol#785-849):\n\tExternal calls:\n\t- influencers = getReferrers(_converter) (TwoKeyDonationLogicHandler.sol#796)\n\t- cut = ITwoKeyDonationCampaign(twoKeyDonationCampaign).getReferrerCut(influencers[i]) (TwoKeyDonationLogicHandler.sol#836)\n\t- updateReferrerMappings(influencers[i],b,_conversionId) (TwoKeyDonationLogicHandler.sol#844)\n\tState variables written after the call(s):\n\t- referrerPlasma2EarningsPerConversion (TwoKeyDonationLogicHandler.sol#844)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 766,
          "vulnerability_to_line": 777,
          "vulnerability_code": "    function updateReferrerMappings(\n\n        address referrerPlasma,\n\n        uint reward,\n\n        uint conversionId\n\n    )\n\n    internal\n\n    {\n\n        ITwoKeyDonationCampaign(twoKeyDonationCampaign).updateReferrerPlasmaBalance(referrerPlasma,reward);\n\n        referrerPlasma2TotalEarnings2key[referrerPlasma] = referrerPlasma2TotalEarnings2key[referrerPlasma].add(reward);\n\n        referrerPlasma2EarningsPerConversion[referrerPlasma][conversionId] = reward;\n\n        referrerPlasmaAddressToCounterOfConversions[referrerPlasma] += 1;\n",
          "message": "Reentrancy in TwoKeyDonationLogicHandler.updateReferrerMappings (TwoKeyDonationLogicHandler.sol#766-777):\n\tExternal calls:\n\t- ITwoKeyDonationCampaign(twoKeyDonationCampaign).updateReferrerPlasmaBalance(referrerPlasma,reward) (TwoKeyDonationLogicHandler.sol#773)\n\tState variables written after the call(s):\n\t- referrerPlasma2EarningsPerConversion (TwoKeyDonationLogicHandler.sol#775)\n\t- referrerPlasma2TotalEarnings2key (TwoKeyDonationLogicHandler.sol#774)\n\t- referrerPlasmaAddressToCounterOfConversions (TwoKeyDonationLogicHandler.sol#776)\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 207,
          "vulnerability_to_line": 233,
          "vulnerability_code": "    function params0(address c, bytes _method) public view returns (uint answer) {\n\n        // https://medium.com/@blockchain101/calling-the-function-of-another-contract-in-solidity-f9edfa921f4c\n\n        //    dc = c;\n\n        bytes4 sig = bytes4(keccak256(_method));\n\n        assembly {\n\n        // move pointer to free memory spot\n\n            let ptr := mload(0x40)\n\n        // put function sig at memory spot\n\n            mstore(ptr,sig)\n\n\n\n            let result := call(  // use WARNING because this should be staticcall BUT geth crash!\n\n            15000, // gas limit\n\n            c, // sload(dc_slot),  // to addr. append var to _slot to access storage variable\n\n            0, // not transfer any ether (comment if using staticcall)\n\n            ptr, // Inputs are stored at location ptr\n\n            0x04, // Inputs are 0 bytes long\n\n            ptr,  //Store output over input\n\n            0x20) //Outputs are 1 bytes long\n\n\n\n            if eq(result, 0) {\n\n                revert(0, 0)\n\n            }\n\n\n\n            answer := mload(ptr) // Assign output to answer var\n\n            mstore(0x40,add(ptr,0x24)) // Set storage pointer to new space\n\n        }\n",
          "message": "Call.params0 uses assembly (TwoKeyDonationLogicHandler.sol#207-233)\n\t- TwoKeyDonationLogicHandler.sol#211-233\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 235,
          "vulnerability_to_line": 263,
          "vulnerability_code": "    function params1(address c, bytes _method, uint _val) public view returns (uint answer) {\n\n        // https://medium.com/@blockchain101/calling-the-function-of-another-contract-in-solidity-f9edfa921f4c\n\n        //    dc = c;\n\n        bytes4 sig = bytes4(keccak256(_method));\n\n        assembly {\n\n        // move pointer to free memory spot\n\n            let ptr := mload(0x40)\n\n        // put function sig at memory spot\n\n            mstore(ptr,sig)\n\n        // append argument after function sig\n\n            mstore(add(ptr,0x04), _val)\n\n\n\n            let result := call(  // use WARNING because this should be staticcall BUT geth crash!\n\n            15000, // gas limit\n\n            c, // sload(dc_slot),  // to addr. append var to _slot to access storage variable\n\n            0, // not transfer any ether (comment if using staticcall)\n\n            ptr, // Inputs are stored at location ptr\n\n            0x24, // Inputs are 0 bytes long\n\n            ptr,  //Store output over input\n\n            0x20) //Outputs are 1 bytes long\n\n\n\n            if eq(result, 0) {\n\n                revert(0, 0)\n\n            }\n\n\n\n            answer := mload(ptr) // Assign output to answer var\n\n            mstore(0x40,add(ptr,0x24)) // Set storage pointer to new space\n\n        }\n",
          "message": "Call.params1 uses assembly (TwoKeyDonationLogicHandler.sol#235-263)\n\t- TwoKeyDonationLogicHandler.sol#239-263\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 265,
          "vulnerability_to_line": 295,
          "vulnerability_code": "    function params2(address c, bytes _method, uint _val1, uint _val2) public view returns (uint answer) {\n\n        // https://medium.com/@blockchain101/calling-the-function-of-another-contract-in-solidity-f9edfa921f4c\n\n        //    dc = c;\n\n        bytes4 sig = bytes4(keccak256(_method));\n\n        assembly {\n\n        // move pointer to free memory spot\n\n            let ptr := mload(0x40)\n\n        // put function sig at memory spot\n\n            mstore(ptr,sig)\n\n        // append argument after function sig\n\n            mstore(add(ptr,0x04), _val1)\n\n            mstore(add(ptr,0x24), _val2)\n\n\n\n            let result := call(  // use WARNING because this should be staticcall BUT geth crash!\n\n            15000, // gas limit\n\n            c, // sload(dc_slot),  // to addr. append var to _slot to access storage variable\n\n            0, // not transfer any ether (comment if using staticcall)\n\n            ptr, // Inputs are stored at location ptr\n\n            0x44, // Inputs are 4 bytes for signature and 2 uint256\n\n            ptr,  //Store output over input\n\n            0x20) //Outputs are 1 uint long\n\n\n\n        // TODO cause revert\n\n        //            if eq(result, 0) {\n\n        //                revert(0, 0)\n\n        //            }\n\n\n\n            answer := mload(ptr) // Assign output to answer var\n\n            mstore(0x40,add(ptr,0x20)) // Set storage pointer to new space\n\n        }\n",
          "message": "Call.params2 uses assembly (TwoKeyDonationLogicHandler.sol#265-295)\n\t- TwoKeyDonationLogicHandler.sol#269-295\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 297,
          "vulnerability_to_line": 305,
          "vulnerability_code": "    function loadAddress(bytes sig, uint idx) public pure returns (address) {\n\n        address influencer;\n\n        idx += 20;\n\n        assembly\n\n        {\n\n            influencer := mload(add(sig, idx))\n\n        }\n\n        return influencer;\n",
          "message": "Call.loadAddress uses assembly (TwoKeyDonationLogicHandler.sol#297-305)\n\t- TwoKeyDonationLogicHandler.sol#300-304\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 307,
          "vulnerability_to_line": 315,
          "vulnerability_code": "    function loadUint8(bytes sig, uint idx) public pure returns (uint8) {\n\n        uint8 weight;\n\n        idx += 1;\n\n        assembly\n\n        {\n\n            weight := mload(add(sig, idx))\n\n        }\n\n        return weight;\n",
          "message": "Call.loadUint8 uses assembly (TwoKeyDonationLogicHandler.sol#307-315)\n\t- TwoKeyDonationLogicHandler.sol#310-314\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 318,
          "vulnerability_to_line": 353,
          "vulnerability_code": "    function recoverHash(bytes32 hash, bytes sig, uint idx) public pure returns (address) {\n\n        // same as recoverHash in utils/sign.js\n\n        // The signature format is a compact form of:\n\n        //   {bytes32 r}{bytes32 s}{uint8 v}\n\n        // Compact means, uint8 is not padded to 32 bytes.\n\n        require (sig.length >= 65+idx, 'bad signature length');\n\n        idx += 32;\n\n        bytes32 r;\n\n        assembly\n\n        {\n\n            r := mload(add(sig, idx))\n\n        }\n\n\n\n        idx += 32;\n\n        bytes32 s;\n\n        assembly\n\n        {\n\n            s := mload(add(sig, idx))\n\n        }\n\n\n\n        idx += 1;\n\n        uint8 v;\n\n        assembly\n\n        {\n\n            v := mload(add(sig, idx))\n\n        }\n\n        if (v >= 32) { // handle case when signature was made with ethereum web3.eth.sign or getSign which is for signing ethereum transactions\n\n            v -= 32;\n\n            bytes memory prefix = \"\\x19Ethereum Signed Message:\\n32\"; // 32 is the number of bytes in the following hash\n\n            hash = keccak256(abi.encodePacked(prefix, hash));\n\n        }\n\n        if (v <= 1) v += 27;\n\n        require(v==27 || v==28,'bad sig v');\n\n        return ecrecover(hash, v, r, s);\n\n\n",
          "message": "Call.recoverHash uses assembly (TwoKeyDonationLogicHandler.sol#318-353)\n\t- TwoKeyDonationLogicHandler.sol#326-331\n\t- TwoKeyDonationLogicHandler.sol#333-338\n\t- TwoKeyDonationLogicHandler.sol#340-344\n"
        },
        {
          "name": "constable-states",
          "vulnerability_from_line": 618,
          "vulnerability_to_line": null,
          "vulnerability_code": "    address internal _implementation;\n",
          "message": "UpgradeabilityCampaignStorage._implementation should be constant (TwoKeyDonationLogicHandler.sol#618)\nUpgradeabilityCampaignStorage.twoKeyFactory should be constant (TwoKeyDonationLogicHandler.sol#615)\n"
        },
        {
          "name": "pragma",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.24;\n",
          "message": "Different versions of Solidity is used in TwoKeyDonationLogicHandler.sol:\n\t- Version used: ['^0.4.0', '^0.4.24']\n\t- TwoKeyDonationLogicHandler.sol#3 declares pragma solidity^0.4.24\n\t- TwoKeyDonationLogicHandler.sol#16 declares pragma solidity^0.4.0\n\t- TwoKeyDonationLogicHandler.sol#43 declares pragma solidity^0.4.24\n\t- TwoKeyDonationLogicHandler.sol#55 declares pragma solidity^0.4.24\n\t- TwoKeyDonationLogicHandler.sol#82 declares pragma solidity^0.4.24\n\t- TwoKeyDonationLogicHandler.sol#94 declares pragma solidity^0.4.24\n\t- TwoKeyDonationLogicHandler.sol#106 declares pragma solidity^0.4.0\n\t- TwoKeyDonationLogicHandler.sol#141 declares pragma solidity^0.4.24\n\t- TwoKeyDonationLogicHandler.sol#149 declares pragma solidity^0.4.24\n\t- TwoKeyDonationLogicHandler.sol#204 declares pragma solidity^0.4.24\n\t- TwoKeyDonationLogicHandler.sol#467 declares pragma solidity^0.4.24\n\t- TwoKeyDonationLogicHandler.sol#554 declares pragma solidity^0.4.24\n\t- TwoKeyDonationLogicHandler.sol#565 declares pragma solidity^0.4.24\n\t- TwoKeyDonationLogicHandler.sol#605 declares pragma solidity^0.4.24\n\t- TwoKeyDonationLogicHandler.sol#631 declares pragma solidity^0.4.24\n\t- TwoKeyDonationLogicHandler.sol#644 declares pragma solidity^0.4.24\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 9,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getContractProxyAddress(string _contractName) public view returns (address);\n",
          "message": "ITwoKeySingletoneRegistryFetchAddress.getContractProxyAddress (TwoKeyDonationLogicHandler.sol#9) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 10,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getNonUpgradableContractAddress(string contractName) public view returns (address);\n",
          "message": "ITwoKeySingletoneRegistryFetchAddress.getNonUpgradableContractAddress (TwoKeyDonationLogicHandler.sol#10) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 11,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getLatestContractVersion(string contractName) public view returns (string);\n",
          "message": "ITwoKeySingletoneRegistryFetchAddress.getLatestContractVersion (TwoKeyDonationLogicHandler.sol#11) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 20,
          "vulnerability_to_line": 23,
          "vulnerability_code": "    function buyTokensForModeratorRewards(\n\n        uint moderatorFee\n\n    )\n",
          "message": "ITwoKeyDonationCampaign.buyTokensForModeratorRewards (TwoKeyDonationLogicHandler.sol#20-23) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 25,
          "vulnerability_to_line": 31,
          "vulnerability_code": "    function buyTokensAndDistributeReferrerRewards(\n\n        uint256 _maxReferralRewardETHWei,\n\n        address _converter,\n\n        uint _conversionId\n\n    )\n\n    public\n",
          "message": "ITwoKeyDonationCampaign.buyTokensAndDistributeReferrerRewards (TwoKeyDonationLogicHandler.sol#25-31) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 33,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getReferrerPlasmaBalance(address _influencer) public view returns (uint);\n",
          "message": "ITwoKeyDonationCampaign.getReferrerPlasmaBalance (TwoKeyDonationLogicHandler.sol#33) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 34,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function updateReferrerPlasmaBalance(address _influencer, uint _balance) public;\n",
          "message": "ITwoKeyDonationCampaign.updateReferrerPlasmaBalance (TwoKeyDonationLogicHandler.sol#34) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 35,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getReferrerCut(address me) public view returns (uint256);\n",
          "message": "ITwoKeyDonationCampaign.getReferrerCut (TwoKeyDonationLogicHandler.sol#35) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 36,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function updateContractorProceeds(uint value) public;\n",
          "message": "ITwoKeyDonationCampaign.updateContractorProceeds (TwoKeyDonationLogicHandler.sol#36) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 37,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getReceivedFrom(address _receiver) public view returns (address);\n",
          "message": "ITwoKeyDonationCampaign.getReceivedFrom (TwoKeyDonationLogicHandler.sol#37) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 38,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function balanceOf(address _owner) public view returns (uint256);\n",
          "message": "ITwoKeyDonationCampaign.balanceOf (TwoKeyDonationLogicHandler.sol#38) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 50,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getBaseToTargetRate(string _currency) public view returns (uint);\n",
          "message": "ITwoKeyExchangeRateContract.getBaseToTargetRate (TwoKeyDonationLogicHandler.sol#50) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 59,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function addTwoKeyEventSource(address _twoKeyEventSource) public;\n",
          "message": "ITwoKeyReg.addTwoKeyEventSource (TwoKeyDonationLogicHandler.sol#59) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 60,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function changeTwoKeyEventSource(address _twoKeyEventSource) public;\n",
          "message": "ITwoKeyReg.changeTwoKeyEventSource (TwoKeyDonationLogicHandler.sol#60) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 61,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function addWhereContractor(address _userAddress, address _contractAddress) public;\n",
          "message": "ITwoKeyReg.addWhereContractor (TwoKeyDonationLogicHandler.sol#61) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 62,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function addWhereModerator(address _userAddress, address _contractAddress) public;\n",
          "message": "ITwoKeyReg.addWhereModerator (TwoKeyDonationLogicHandler.sol#62) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 63,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function addWhereReferrer(address _userAddress, address _contractAddress) public;\n",
          "message": "ITwoKeyReg.addWhereReferrer (TwoKeyDonationLogicHandler.sol#63) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 64,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function addWhereConverter(address _userAddress, address _contractAddress) public;\n",
          "message": "ITwoKeyReg.addWhereConverter (TwoKeyDonationLogicHandler.sol#64) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 65,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getContractsWhereUserIsContractor(address _userAddress) public view returns (address[]);\n",
          "message": "ITwoKeyReg.getContractsWhereUserIsContractor (TwoKeyDonationLogicHandler.sol#65) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 66,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getContractsWhereUserIsModerator(address _userAddress) public view returns (address[]);\n",
          "message": "ITwoKeyReg.getContractsWhereUserIsModerator (TwoKeyDonationLogicHandler.sol#66) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 67,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getContractsWhereUserIsRefferer(address _userAddress) public view returns (address[]);\n",
          "message": "ITwoKeyReg.getContractsWhereUserIsRefferer (TwoKeyDonationLogicHandler.sol#67) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 68,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getContractsWhereUserIsConverter(address _userAddress) public view returns (address[]);\n",
          "message": "ITwoKeyReg.getContractsWhereUserIsConverter (TwoKeyDonationLogicHandler.sol#68) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 69,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getTwoKeyEventSourceAddress() public view returns (address);\n",
          "message": "ITwoKeyReg.getTwoKeyEventSourceAddress (TwoKeyDonationLogicHandler.sol#69) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 70,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function addName(string _name, address _sender, string _fullName, string _email, bytes signature) public;\n",
          "message": "ITwoKeyReg.addName (TwoKeyDonationLogicHandler.sol#70) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 71,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function addNameByUser(string _name) public;\n",
          "message": "ITwoKeyReg.addNameByUser (TwoKeyDonationLogicHandler.sol#71) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 72,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getName2Owner(string _name) public view returns (address);\n",
          "message": "ITwoKeyReg.getName2Owner (TwoKeyDonationLogicHandler.sol#72) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 73,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getOwner2Name(address _sender) public view returns (string);\n",
          "message": "ITwoKeyReg.getOwner2Name (TwoKeyDonationLogicHandler.sol#73) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 74,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getPlasmaToEthereum(address plasma) public view returns (address);\n",
          "message": "ITwoKeyReg.getPlasmaToEthereum (TwoKeyDonationLogicHandler.sol#74) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 75,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getEthereumToPlasma(address ethereum) public view returns (address);\n",
          "message": "ITwoKeyReg.getEthereumToPlasma (TwoKeyDonationLogicHandler.sol#75) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 76,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function checkIfTwoKeyMaintainerExists(address _maintainer) public view returns (bool);\n",
          "message": "ITwoKeyReg.checkIfTwoKeyMaintainerExists (TwoKeyDonationLogicHandler.sol#76) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 88,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getReceivedFrom(address _receiver) public view returns (address);\n",
          "message": "ITwoKeyAcquisitionARC.getReceivedFrom (TwoKeyDonationLogicHandler.sol#88) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 89,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function balanceOf(address _owner) public view returns (uint256);\n",
          "message": "ITwoKeyAcquisitionARC.balanceOf (TwoKeyDonationLogicHandler.sol#89) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 98,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function ethereumOf(address me) public view returns (address);\n",
          "message": "ITwoKeyEventSource.ethereumOf (TwoKeyDonationLogicHandler.sol#98) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 99,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function plasmaOf(address me) public view returns (address);\n",
          "message": "ITwoKeyEventSource.plasmaOf (TwoKeyDonationLogicHandler.sol#99) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 100,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function isAddressMaintainer(address _maintainer) public view returns (bool);\n",
          "message": "ITwoKeyEventSource.isAddressMaintainer (TwoKeyDonationLogicHandler.sol#100) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 101,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getTwoKeyDefaultIntegratorFeeFromAdmin() public view returns (uint);\n",
          "message": "ITwoKeyEventSource.getTwoKeyDefaultIntegratorFeeFromAdmin (TwoKeyDonationLogicHandler.sol#101) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 109,
          "vulnerability_to_line": 116,
          "vulnerability_code": "    function supportForCreateConversion(\n\n        address _converterAddress,\n\n        uint _conversionAmount,\n\n        uint _maxReferralRewardETHWei,\n\n        bool _isKYCRequired\n\n    )\n\n    public\n",
          "message": "ITwoKeyDonationConversionHandler.supportForCreateConversion (TwoKeyDonationLogicHandler.sol#109-116) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 118,
          "vulnerability_to_line": 121,
          "vulnerability_code": "    function executeConversion(\n\n        uint _conversionId\n\n    )\n",
          "message": "ITwoKeyDonationConversionHandler.executeConversion (TwoKeyDonationLogicHandler.sol#118-121) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 123,
          "vulnerability_to_line": 128,
          "vulnerability_code": "    function getAmountConverterSpent(\n\n        address converter\n\n    )\n\n    public\n\n    view\n",
          "message": "ITwoKeyDonationConversionHandler.getAmountConverterSpent (TwoKeyDonationLogicHandler.sol#123-128) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 144,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function onlyMaintainer(address _sender) public view returns (bool);\n",
          "message": "ITwoKeyMaintainersRegistry.onlyMaintainer (TwoKeyDonationLogicHandler.sol#144) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 207,
          "vulnerability_to_line": 233,
          "vulnerability_code": "    function params0(address c, bytes _method) public view returns (uint answer) {\n\n        // https://medium.com/@blockchain101/calling-the-function-of-another-contract-in-solidity-f9edfa921f4c\n\n        //    dc = c;\n\n        bytes4 sig = bytes4(keccak256(_method));\n\n        assembly {\n\n        // move pointer to free memory spot\n\n            let ptr := mload(0x40)\n\n        // put function sig at memory spot\n\n            mstore(ptr,sig)\n\n\n\n            let result := call(  // use WARNING because this should be staticcall BUT geth crash!\n\n            15000, // gas limit\n\n            c, // sload(dc_slot),  // to addr. append var to _slot to access storage variable\n\n            0, // not transfer any ether (comment if using staticcall)\n\n            ptr, // Inputs are stored at location ptr\n\n            0x04, // Inputs are 0 bytes long\n\n            ptr,  //Store output over input\n\n            0x20) //Outputs are 1 bytes long\n\n\n\n            if eq(result, 0) {\n\n                revert(0, 0)\n\n            }\n\n\n\n            answer := mload(ptr) // Assign output to answer var\n\n            mstore(0x40,add(ptr,0x24)) // Set storage pointer to new space\n\n        }\n",
          "message": "Call.params0 (TwoKeyDonationLogicHandler.sol#207-233) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 235,
          "vulnerability_to_line": 263,
          "vulnerability_code": "    function params1(address c, bytes _method, uint _val) public view returns (uint answer) {\n\n        // https://medium.com/@blockchain101/calling-the-function-of-another-contract-in-solidity-f9edfa921f4c\n\n        //    dc = c;\n\n        bytes4 sig = bytes4(keccak256(_method));\n\n        assembly {\n\n        // move pointer to free memory spot\n\n            let ptr := mload(0x40)\n\n        // put function sig at memory spot\n\n            mstore(ptr,sig)\n\n        // append argument after function sig\n\n            mstore(add(ptr,0x04), _val)\n\n\n\n            let result := call(  // use WARNING because this should be staticcall BUT geth crash!\n\n            15000, // gas limit\n\n            c, // sload(dc_slot),  // to addr. append var to _slot to access storage variable\n\n            0, // not transfer any ether (comment if using staticcall)\n\n            ptr, // Inputs are stored at location ptr\n\n            0x24, // Inputs are 0 bytes long\n\n            ptr,  //Store output over input\n\n            0x20) //Outputs are 1 bytes long\n\n\n\n            if eq(result, 0) {\n\n                revert(0, 0)\n\n            }\n\n\n\n            answer := mload(ptr) // Assign output to answer var\n\n            mstore(0x40,add(ptr,0x24)) // Set storage pointer to new space\n\n        }\n",
          "message": "Call.params1 (TwoKeyDonationLogicHandler.sol#235-263) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 265,
          "vulnerability_to_line": 295,
          "vulnerability_code": "    function params2(address c, bytes _method, uint _val1, uint _val2) public view returns (uint answer) {\n\n        // https://medium.com/@blockchain101/calling-the-function-of-another-contract-in-solidity-f9edfa921f4c\n\n        //    dc = c;\n\n        bytes4 sig = bytes4(keccak256(_method));\n\n        assembly {\n\n        // move pointer to free memory spot\n\n            let ptr := mload(0x40)\n\n        // put function sig at memory spot\n\n            mstore(ptr,sig)\n\n        // append argument after function sig\n\n            mstore(add(ptr,0x04), _val1)\n\n            mstore(add(ptr,0x24), _val2)\n\n\n\n            let result := call(  // use WARNING because this should be staticcall BUT geth crash!\n\n            15000, // gas limit\n\n            c, // sload(dc_slot),  // to addr. append var to _slot to access storage variable\n\n            0, // not transfer any ether (comment if using staticcall)\n\n            ptr, // Inputs are stored at location ptr\n\n            0x44, // Inputs are 4 bytes for signature and 2 uint256\n\n            ptr,  //Store output over input\n\n            0x20) //Outputs are 1 uint long\n\n\n\n        // TODO cause revert\n\n        //            if eq(result, 0) {\n\n        //                revert(0, 0)\n\n        //            }\n\n\n\n            answer := mload(ptr) // Assign output to answer var\n\n            mstore(0x40,add(ptr,0x20)) // Set storage pointer to new space\n\n        }\n",
          "message": "Call.params2 (TwoKeyDonationLogicHandler.sol#265-295) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 437,
          "vulnerability_to_line": 462,
          "vulnerability_code": "    function recoverSig(bytes sig, address old_key, address last_address) public pure returns (address[], address[], uint8[]) {\n\n        // validate sig AND\n\n        // recover the information from the signature: influencers, public_link_keys, weights/cuts\n\n        // influencers may have one more address than the keys and weights arrays\n\n        //\n\n        require(old_key != address(0),'no public link key');\n\n\n\n        address[] memory influencers;\n\n        address[] memory keys;\n\n        uint8[] memory weights;\n\n        uint[] memory offsets;\n\n        (influencers, keys, weights, offsets) = recoverSigParts(sig, last_address);\n\n\n\n        // check if we received a valid signature\n\n        for(uint i = 0; i < influencers.length; i++) {\n\n            if (i < weights.length) {\n\n                require (recoverHash(keccak256(abi.encodePacked(weights[i], keys[i], influencers[i])),sig,offsets[i]) == old_key, 'illegal signature');\n\n                old_key = keys[i];\n\n            } else {\n\n                // signed message for the last step is the address of the converter\n\n                require (recoverHash(keccak256(abi.encodePacked(influencers[i])),sig,offsets[i]) == old_key, 'illegal last signature');\n\n            }\n\n        }\n\n\n\n        return (influencers, keys, weights);\n",
          "message": "Call.recoverSig (TwoKeyDonationLogicHandler.sol#437-462) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 592,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function addVersion(string _contractName, string version, address implementation) public;\n",
          "message": "ITwoKeySingletonesRegistry.addVersion (TwoKeyDonationLogicHandler.sol#592) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 600,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getVersion(string _contractName, string version) public view returns (address);\n",
          "message": "ITwoKeySingletonesRegistry.getVersion (TwoKeyDonationLogicHandler.sol#600) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 624,
          "vulnerability_to_line": 626,
          "vulnerability_code": "    function implementation() public view returns (address) {\n\n        return _implementation;\n",
          "message": "UpgradeabilityCampaignStorage.implementation (TwoKeyDonationLogicHandler.sol#624-626) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 689,
          "vulnerability_to_line": 727,
          "vulnerability_code": "    function setInitialParamsDonationLogicHandler(\n\n        uint[] numberValues,\n\n        string _currency,\n\n        address _contractor,\n\n        address _moderator,\n\n        address twoKeySingletonRegistry,\n\n        address _twoKeyDonationCampaign,\n\n        address _twoKeyDonationConversionHandler\n\n    )\n\n    public\n\n    {\n\n        require(initialized == false);\n\n\n\n        twoKeyDonationCampaign = _twoKeyDonationCampaign;\n\n        twoKeyDonationConversionHandler = _twoKeyDonationConversionHandler;\n\n\n\n        powerLawFactor = 2;\n\n        campaignStartTime = numberValues[1];\n\n        campaignEndTime = numberValues[2];\n\n        minDonationAmountWei = numberValues[3];\n\n        maxDonationAmountWei = numberValues[4];\n\n        campaignGoal = numberValues[5];\n\n        incentiveModel = IncentiveModel(numberValues[7]);\n\n\n\n        contractor = _contractor;\n\n        moderator = _moderator;\n\n        currency = _currency;\n\n\n\n        twoKeySingletoneRegistry = twoKeySingletonRegistry;\n\n        twoKeyEventSource = ITwoKeySingletoneRegistryFetchAddress(twoKeySingletoneRegistry)\n\n            .getContractProxyAddress(\"TwoKeyEventSource\");\n\n        twoKeyMaintainersRegistry = ITwoKeySingletoneRegistryFetchAddress(twoKeySingletoneRegistry)\n\n            .getContractProxyAddress(\"TwoKeyMaintainersRegistry\");\n\n        twoKeyRegistry = ITwoKeySingletoneRegistryFetchAddress(twoKeySingletoneRegistry)\n\n            .getContractProxyAddress(\"TwoKeyRegistry\");\n\n\n\n        ownerPlasma = plasmaOf(contractor);\n\n        initialized = true;\n",
          "message": "TwoKeyDonationLogicHandler.setInitialParamsDonationLogicHandler (TwoKeyDonationLogicHandler.sol#689-727) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 730,
          "vulnerability_to_line": 740,
          "vulnerability_code": "    function checkHowMuchUserCanSpend(\n\n        address _converter\n\n    )\n\n    public\n\n    view\n\n    returns (uint)\n\n    {\n\n        uint amountAlreadySpent = ITwoKeyDonationConversionHandler(twoKeyDonationConversionHandler).getAmountConverterSpent(_converter);\n\n        uint leftToSpend = getHowMuchLeftForUserToSpend(amountAlreadySpent);\n\n        return leftToSpend;\n",
          "message": "TwoKeyDonationLogicHandler.checkHowMuchUserCanSpend (TwoKeyDonationLogicHandler.sol#730-740) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 785,
          "vulnerability_to_line": 849,
          "vulnerability_code": "    function updateRefchainRewards(\n\n        uint256 _maxReferralRewardETHWei,\n\n        address _converter,\n\n        uint _conversionId,\n\n        uint totalBounty2keys\n\n    )\n\n    public\n\n    {\n\n        require(msg.sender == twoKeyDonationCampaign);\n\n\n\n//        Get all the influencers\n\n        address[] memory influencers = getReferrers(_converter);\n\n\n\n        //Get array length\n\n        uint numberOfInfluencers = influencers.length;\n\n\n\n        uint i;\n\n        uint reward;\n\n        if(incentiveModel == IncentiveModel.VANILLA_AVERAGE) {\n\n            reward = IncentiveModels.averageModelRewards(totalBounty2keys, numberOfInfluencers);\n\n            for(i=0; i<numberOfInfluencers; i++) {\n\n                updateReferrerMappings(influencers[i], reward, _conversionId);\n\n\n\n            }\n\n        } else if (incentiveModel == IncentiveModel.VANILLA_AVERAGE_LAST_3X) {\n\n            uint rewardForLast;\n\n            // Calculate reward for regular ones and for the last\n\n            (reward, rewardForLast) = IncentiveModels.averageLast3xRewards(totalBounty2keys, numberOfInfluencers);\n\n\n\n            //Update equal rewards to all influencers but last\n\n            for(i=0; i<numberOfInfluencers - 1; i++) {\n\n                updateReferrerMappings(influencers[i], reward, _conversionId);\n\n\n\n            }\n\n            //Update reward for last\n\n            updateReferrerMappings(influencers[numberOfInfluencers-1], rewardForLast, _conversionId);\n\n        } else if(incentiveModel == IncentiveModel.VANILLA_POWER_LAW) {\n\n            // Get rewards per referrer\n\n            uint [] memory rewards = IncentiveModels.powerLawRewards(totalBounty2keys, numberOfInfluencers, 2);\n\n            //Iterate through all referrers and distribute rewards\n\n            for(i=0; i<numberOfInfluencers; i++) {\n\n                updateReferrerMappings(influencers[i], rewards[i], _conversionId);\n\n            }\n\n        } else if(incentiveModel == IncentiveModel.MANUAL) {\n\n            for (i = 0; i < numberOfInfluencers; i++) {\n\n                uint256 b;\n\n\n\n                if (i == influencers.length - 1) {  // if its the last influencer then all the bounty goes to it.\n\n                    b = totalBounty2keys;\n\n                }\n\n                else {\n\n                    uint256 cut = ITwoKeyDonationCampaign(twoKeyDonationCampaign).getReferrerCut(influencers[i]);\n\n                    if (cut > 0 && cut <= 101) {\n\n                        b = totalBounty2keys.mul(cut.sub(1)).div(100);\n\n                    } else {// cut == 0 or 255 indicates equal particine of the bounty\n\n                        b = totalBounty2keys.div(influencers.length - i);\n\n                    }\n\n                }\n\n\n\n                updateReferrerMappings(influencers[i], b, _conversionId);\n\n                //Decrease bounty for distributed\n\n                totalBounty2keys = totalBounty2keys.sub(b);\n\n            }\n\n        }\n",
          "message": "TwoKeyDonationLogicHandler.updateRefchainRewards (TwoKeyDonationLogicHandler.sol#785-849) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 892,
          "vulnerability_to_line": 918,
          "vulnerability_code": "    function getReferrerBalanceAndTotalEarningsAndNumberOfConversions(\n\n        address _referrerAddress,\n\n        bytes _sig,\n\n        uint[] _conversionIds\n\n    )\n\n    public\n\n    view\n\n    returns (uint,uint,uint,uint[],address)\n\n    {\n\n        if(_sig.length > 0) {\n\n            _referrerAddress = recover(_sig);\n\n        }\n\n        else {\n\n            require(msg.sender == _referrerAddress || msg.sender == contractor || ITwoKeyMaintainersRegistry(twoKeyMaintainersRegistry).onlyMaintainer(msg.sender));\n\n            _referrerAddress = plasmaOf(_referrerAddress);\n\n        }\n\n\n\n        uint len = _conversionIds.length;\n\n        uint[] memory earnings = new uint[](len);\n\n\n\n        for(uint i=0; i<len; i++) {\n\n            earnings[i] = referrerPlasma2EarningsPerConversion[_referrerAddress][_conversionIds[i]];\n\n        }\n\n\n\n        uint referrerBalance = ITwoKeyDonationCampaign(twoKeyDonationCampaign).getReferrerPlasmaBalance(_referrerAddress);\n\n        return (referrerBalance, referrerPlasma2TotalEarnings2key[_referrerAddress], referrerPlasmaAddressToCounterOfConversions[_referrerAddress], earnings, _referrerAddress);\n",
          "message": "TwoKeyDonationLogicHandler.getReferrerBalanceAndTotalEarningsAndNumberOfConversions (TwoKeyDonationLogicHandler.sol#892-918) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 925,
          "vulnerability_to_line": 944,
          "vulnerability_code": "    function getReferrersBalancesAndTotalEarnings(\n\n        address[] _referrerPlasmaList\n\n    )\n\n    public\n\n    view\n\n    returns (uint256[], uint256[])\n\n    {\n\n        require(ITwoKeyMaintainersRegistry(twoKeyMaintainersRegistry).onlyMaintainer(msg.sender));\n\n\n\n        uint numberOfAddresses = _referrerPlasmaList.length;\n\n        uint256[] memory referrersPendingPlasmaBalance = new uint256[](numberOfAddresses);\n\n        uint256[] memory referrersTotalEarningsPlasmaBalance = new uint256[](numberOfAddresses);\n\n\n\n        for (uint i=0; i<numberOfAddresses; i++){\n\n            referrersPendingPlasmaBalance[i] = ITwoKeyDonationCampaign(twoKeyDonationCampaign).getReferrerPlasmaBalance(_referrerPlasmaList[i]);\n\n            referrersTotalEarningsPlasmaBalance[i] = referrerPlasma2TotalEarnings2key[_referrerPlasmaList[i]];\n\n        }\n\n\n\n        return (referrersPendingPlasmaBalance, referrersTotalEarningsPlasmaBalance);\n",
          "message": "TwoKeyDonationLogicHandler.getReferrersBalancesAndTotalEarnings (TwoKeyDonationLogicHandler.sol#925-944) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 1038,
          "vulnerability_to_line": 1070,
          "vulnerability_code": "    function getSuperStatistics(\n\n        address _user,\n\n        bool plasma,\n\n        bytes signature\n\n    )\n\n    public\n\n    view\n\n    returns (bytes)\n\n    {\n\n        address eth_address = _user;\n\n\n\n        if (plasma) {\n\n            (eth_address) = ITwoKeyReg(twoKeyRegistry).getPlasmaToEthereum(_user);\n\n        }\n\n\n\n        bytes memory userData = ITwoKeyReg(twoKeyRegistry).getUserData(eth_address);\n\n\n\n        bool isJoined = getAddressJoinedStatus(_user);\n\n        bool flag;\n\n\n\n        address _address;\n\n\n\n        if(msg.sender == contractor || msg.sender == eth_address) {\n\n            flag = true;\n\n        } else {\n\n            _address = recover(signature);\n\n            if(_address == ownerPlasma) {\n\n                flag = true;\n\n            }\n\n        }\n\n        bytes memory stats = getAddressStatistic(_user, plasma, flag, _address);\n\n        return abi.encodePacked(userData, isJoined, eth_address, stats);\n",
          "message": "TwoKeyDonationLogicHandler.getSuperStatistics (TwoKeyDonationLogicHandler.sol#1038-1070) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 1077,
          "vulnerability_to_line": 1079,
          "vulnerability_code": "    function getIncentiveModel() public view returns (IncentiveModel) {\n\n        return incentiveModel;\n",
          "message": "TwoKeyDonationLogicHandler.getIncentiveModel (TwoKeyDonationLogicHandler.sol#1077-1079) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 1119,
          "vulnerability_to_line": 1125,
          "vulnerability_code": "    function getConstantInfo()\n\n    public\n\n    view\n\n    returns (uint,uint,uint,uint,uint)\n\n    {\n\n        return (campaignStartTime,campaignEndTime, minDonationAmountWei, maxDonationAmountWei, campaignGoal);\n",
          "message": "TwoKeyDonationLogicHandler.getConstantInfo (TwoKeyDonationLogicHandler.sol#1119-1125) should be declared external\n"
        },
        {
          "name": "solc-version",
          "vulnerability_from_line": 16,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.0;\n",
          "message": "Detected issues with version pragma in TwoKeyDonationLogicHandler.sol:\n\t- pragma solidity^0.4.0 (TwoKeyDonationLogicHandler.sol#16): it allows old versions\n\t- pragma solidity^0.4.0 (TwoKeyDonationLogicHandler.sol#106): it allows old versions\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 161,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n",
          "message": "Parameter '_a' of SafeMath.mul (TwoKeyDonationLogicHandler.sol#161) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 161,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n",
          "message": "Parameter '_b' of SafeMath.mul (TwoKeyDonationLogicHandler.sol#161) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 177,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n",
          "message": "Parameter '_a' of SafeMath.div (TwoKeyDonationLogicHandler.sol#177) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 177,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n",
          "message": "Parameter '_b' of SafeMath.div (TwoKeyDonationLogicHandler.sol#177) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 187,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n",
          "message": "Parameter '_a' of SafeMath.sub (TwoKeyDonationLogicHandler.sol#187) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 187,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n",
          "message": "Parameter '_b' of SafeMath.sub (TwoKeyDonationLogicHandler.sol#187) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 195,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n",
          "message": "Parameter '_a' of SafeMath.add (TwoKeyDonationLogicHandler.sol#195) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 195,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n",
          "message": "Parameter '_b' of SafeMath.add (TwoKeyDonationLogicHandler.sol#195) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 207,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function params0(address c, bytes _method) public view returns (uint answer) {\n",
          "message": "Parameter '_method' of Call.params0 (TwoKeyDonationLogicHandler.sol#207) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 235,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function params1(address c, bytes _method, uint _val) public view returns (uint answer) {\n",
          "message": "Parameter '_method' of Call.params1 (TwoKeyDonationLogicHandler.sol#235) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 265,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function params2(address c, bytes _method, uint _val1, uint _val2) public view returns (uint answer) {\n",
          "message": "Parameter '_method' of Call.params2 (TwoKeyDonationLogicHandler.sol#265) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 370,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function recoverSigParts(bytes sig, address last_address) private pure returns (address[], address[], uint8[], uint[]) {\n",
          "message": "Parameter 'last_address' of Call.recoverSigParts (TwoKeyDonationLogicHandler.sol#370) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 437,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function recoverSig(bytes sig, address old_key, address last_address) public pure returns (address[], address[], uint8[]) {\n",
          "message": "Parameter 'old_key' of Call.recoverSig (TwoKeyDonationLogicHandler.sol#437) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 437,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function recoverSig(bytes sig, address old_key, address last_address) public pure returns (address[], address[], uint8[]) {\n",
          "message": "Parameter 'last_address' of Call.recoverSig (TwoKeyDonationLogicHandler.sol#437) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 618,
          "vulnerability_to_line": null,
          "vulnerability_code": "    address internal _implementation;\n",
          "message": "Variable 'UpgradeabilityCampaignStorage._implementation' (TwoKeyDonationLogicHandler.sol#618) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 691,
          "vulnerability_to_line": null,
          "vulnerability_code": "        string _currency,\n",
          "message": "Parameter '_currency' of TwoKeyDonationLogicHandler.setInitialParamsDonationLogicHandler (TwoKeyDonationLogicHandler.sol#691) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 692,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address _contractor,\n",
          "message": "Parameter '_contractor' of TwoKeyDonationLogicHandler.setInitialParamsDonationLogicHandler (TwoKeyDonationLogicHandler.sol#692) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 693,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address _moderator,\n",
          "message": "Parameter '_moderator' of TwoKeyDonationLogicHandler.setInitialParamsDonationLogicHandler (TwoKeyDonationLogicHandler.sol#693) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 695,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address _twoKeyDonationCampaign,\n",
          "message": "Parameter '_twoKeyDonationCampaign' of TwoKeyDonationLogicHandler.setInitialParamsDonationLogicHandler (TwoKeyDonationLogicHandler.sol#695) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 696,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address _twoKeyDonationConversionHandler\n",
          "message": "Parameter '_twoKeyDonationConversionHandler' of TwoKeyDonationLogicHandler.setInitialParamsDonationLogicHandler (TwoKeyDonationLogicHandler.sol#696) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 731,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address _converter\n",
          "message": "Parameter '_converter' of TwoKeyDonationLogicHandler.checkHowMuchUserCanSpend (TwoKeyDonationLogicHandler.sol#731) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 787,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address _converter,\n",
          "message": "Parameter '_converter' of TwoKeyDonationLogicHandler.updateRefchainRewards (TwoKeyDonationLogicHandler.sol#787) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 788,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint _conversionId,\n",
          "message": "Parameter '_conversionId' of TwoKeyDonationLogicHandler.updateRefchainRewards (TwoKeyDonationLogicHandler.sol#788) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 893,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address _referrerAddress,\n",
          "message": "Parameter '_referrerAddress' of TwoKeyDonationLogicHandler.getReferrerBalanceAndTotalEarningsAndNumberOfConversions (TwoKeyDonationLogicHandler.sol#893) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 894,
          "vulnerability_to_line": null,
          "vulnerability_code": "        bytes _sig,\n",
          "message": "Parameter '_sig' of TwoKeyDonationLogicHandler.getReferrerBalanceAndTotalEarningsAndNumberOfConversions (TwoKeyDonationLogicHandler.sol#894) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 895,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint[] _conversionIds\n",
          "message": "Parameter '_conversionIds' of TwoKeyDonationLogicHandler.getReferrerBalanceAndTotalEarningsAndNumberOfConversions (TwoKeyDonationLogicHandler.sol#895) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 926,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address[] _referrerPlasmaList\n",
          "message": "Parameter '_referrerPlasmaList' of TwoKeyDonationLogicHandler.getReferrersBalancesAndTotalEarnings (TwoKeyDonationLogicHandler.sol#926) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 952,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address _address\n",
          "message": "Parameter '_address' of TwoKeyDonationLogicHandler.getAddressJoinedStatus (TwoKeyDonationLogicHandler.sol#952) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 974,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address _address,\n",
          "message": "Parameter '_address' of TwoKeyDonationLogicHandler.getAddressStatistic (TwoKeyDonationLogicHandler.sol#974) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1039,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address _user,\n",
          "message": "Parameter '_user' of TwoKeyDonationLogicHandler.getSuperStatistics (TwoKeyDonationLogicHandler.sol#1039) is not in mixedCase\n"
        },
        {
          "name": "unused-state",
          "vulnerability_from_line": 613,
          "vulnerability_to_line": null,
          "vulnerability_code": "    ITwoKeySingletonesRegistry internal registry;\n",
          "message": "UpgradeabilityCampaignStorage.registry (TwoKeyDonationLogicHandler.sol#613) is never used in TwoKeyDonationLogicHandler\nUpgradeabilityCampaignStorage.twoKeyFactory (TwoKeyDonationLogicHandler.sol#615) is never used in TwoKeyDonationLogicHandler\n"
        }
      ]
    },
    "smartcheck": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 451,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(uint i = 0; i < influencers.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 396,
          "vulnerability_to_line": null,
          "vulnerability_code": "        while (idx + 65 <= sig.length) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
          "vulnerability_from_line": 207,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function params0(address c, bytes _method) public view returns (uint answer) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
          "vulnerability_from_line": 235,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function params1(address c, bytes _method, uint _val) public view returns (uint answer) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
          "vulnerability_from_line": 265,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function params2(address c, bytes _method, uint _val1, uint _val2) public view returns (uint answer) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 451,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(uint i = 0; i < influencers.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 805,
          "vulnerability_to_line": null,
          "vulnerability_code": "            for(i=0; i<numberOfInfluencers; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 825,
          "vulnerability_to_line": null,
          "vulnerability_code": "            for(i=0; i<numberOfInfluencers; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 829,
          "vulnerability_to_line": null,
          "vulnerability_code": "            for (i = 0; i < numberOfInfluencers; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 912,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(uint i=0; i<len; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 938,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i=0; i<numberOfAddresses; i++){\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 396,
          "vulnerability_to_line": null,
          "vulnerability_code": "        while (idx + 65 <= sig.length) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 866,
          "vulnerability_to_line": null,
          "vulnerability_code": "        while (true) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.24;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 16,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 43,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.24;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 55,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.24;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 82,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.24;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 94,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.24;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 106,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 141,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.24;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 149,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.24;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 204,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.24;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 467,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.24;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 554,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.24;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 565,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.24;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 605,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.24;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 631,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.24;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 644,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.24;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SAFEMATH",
          "vulnerability_from_line": 660,
          "vulnerability_to_line": null,
          "vulnerability_code": "    using SafeMath for uint256;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 297,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function loadAddress(bytes sig, uint idx) public pure returns (address) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 307,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function loadUint8(bytes sig, uint idx) public pure returns (uint8) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 318,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function recoverHash(bytes32 hash, bytes sig, uint idx) public pure returns (address) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
          "vulnerability_from_line": 207,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function params0(address c, bytes _method) public view returns (uint answer) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
          "vulnerability_from_line": 235,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function params1(address c, bytes _method, uint _val) public view returns (uint answer) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
          "vulnerability_from_line": 265,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function params2(address c, bytes _method, uint _val1, uint _val2) public view returns (uint answer) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 355,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function recoverSigMemory(bytes sig) private pure returns (address[], address[], uint8[], uint[], uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 370,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function recoverSigParts(bytes sig, address last_address) private pure returns (address[], address[], uint8[], uint[]) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 500,
          "vulnerability_to_line": null,
          "vulnerability_code": "    ) internal pure returns (uint,uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 9,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getContractProxyAddress(string _contractName) public view returns (address);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 10,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getNonUpgradableContractAddress(string contractName) public view returns (address);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 11,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getLatestContractVersion(string contractName) public view returns (string);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 11,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getLatestContractVersion(string contractName) public view returns (string);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 50,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getBaseToTargetRate(string _currency) public view returns (uint);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 65,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getContractsWhereUserIsContractor(address _userAddress) public view returns (address[]);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 66,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getContractsWhereUserIsModerator(address _userAddress) public view returns (address[]);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 67,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getContractsWhereUserIsRefferer(address _userAddress) public view returns (address[]);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 68,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getContractsWhereUserIsConverter(address _userAddress) public view returns (address[]);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 70,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function addName(string _name, address _sender, string _fullName, string _email, bytes signature) public;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 70,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function addName(string _name, address _sender, string _fullName, string _email, bytes signature) public;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 70,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function addName(string _name, address _sender, string _fullName, string _email, bytes signature) public;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 70,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function addName(string _name, address _sender, string _fullName, string _email, bytes signature) public;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 71,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function addNameByUser(string _name) public;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 72,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getName2Owner(string _name) public view returns (address);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 73,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getOwner2Name(address _sender) public view returns (string);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 207,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function params0(address c, bytes _method) public view returns (uint answer) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 235,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function params1(address c, bytes _method, uint _val) public view returns (uint answer) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 265,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function params2(address c, bytes _method, uint _val1, uint _val2) public view returns (uint answer) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 297,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function loadAddress(bytes sig, uint idx) public pure returns (address) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 307,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function loadUint8(bytes sig, uint idx) public pure returns (uint8) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 318,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function recoverHash(bytes32 hash, bytes sig, uint idx) public pure returns (address) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 355,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function recoverSigMemory(bytes sig) private pure returns (address[], address[], uint8[], uint[], uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 355,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function recoverSigMemory(bytes sig) private pure returns (address[], address[], uint8[], uint[], uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 355,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function recoverSigMemory(bytes sig) private pure returns (address[], address[], uint8[], uint[], uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 355,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function recoverSigMemory(bytes sig) private pure returns (address[], address[], uint8[], uint[], uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 355,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function recoverSigMemory(bytes sig) private pure returns (address[], address[], uint8[], uint[], uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 370,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function recoverSigParts(bytes sig, address last_address) private pure returns (address[], address[], uint8[], uint[]) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 370,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function recoverSigParts(bytes sig, address last_address) private pure returns (address[], address[], uint8[], uint[]) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 370,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function recoverSigParts(bytes sig, address last_address) private pure returns (address[], address[], uint8[], uint[]) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 370,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function recoverSigParts(bytes sig, address last_address) private pure returns (address[], address[], uint8[], uint[]) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 370,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function recoverSigParts(bytes sig, address last_address) private pure returns (address[], address[], uint8[], uint[]) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 437,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function recoverSig(bytes sig, address old_key, address last_address) public pure returns (address[], address[], uint8[]) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 437,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function recoverSig(bytes sig, address old_key, address last_address) public pure returns (address[], address[], uint8[]) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 437,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function recoverSig(bytes sig, address old_key, address last_address) public pure returns (address[], address[], uint8[]) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 437,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function recoverSig(bytes sig, address old_key, address last_address) public pure returns (address[], address[], uint8[]) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 519,
          "vulnerability_to_line": null,
          "vulnerability_code": "    ) internal pure returns (uint[]) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 592,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function addVersion(string _contractName, string version, address implementation) public;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 592,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function addVersion(string _contractName, string version, address implementation) public;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 600,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getVersion(string _contractName, string version) public view returns (address);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 600,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getVersion(string _contractName, string version) public view returns (address);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 690,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint[] numberValues,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 691,
          "vulnerability_to_line": null,
          "vulnerability_code": "        string _currency,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 861,
          "vulnerability_to_line": null,
          "vulnerability_code": "    returns (address[])\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 894,
          "vulnerability_to_line": null,
          "vulnerability_code": "        bytes _sig,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 895,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint[] _conversionIds\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 899,
          "vulnerability_to_line": null,
          "vulnerability_code": "    returns (uint,uint,uint,uint[],address)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 926,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address[] _referrerPlasmaList\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 930,
          "vulnerability_to_line": null,
          "vulnerability_code": "    returns (uint256[], uint256[])\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 930,
          "vulnerability_to_line": null,
          "vulnerability_code": "    returns (uint256[], uint256[])\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 981,
          "vulnerability_to_line": null,
          "vulnerability_code": "    returns (bytes)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 1020,
          "vulnerability_to_line": null,
          "vulnerability_code": "        bytes signature\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 1041,
          "vulnerability_to_line": null,
          "vulnerability_code": "        bytes signature\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 1045,
          "vulnerability_to_line": null,
          "vulnerability_code": "    returns (bytes)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 211,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 239,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 269,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 300,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 310,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 326,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 333,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 340,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 592,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function addVersion(string _contractName, string version, address implementation) public;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 600,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getVersion(string _contractName, string version) public view returns (address);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 661,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bool initialized;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 663,
          "vulnerability_to_line": null,
          "vulnerability_code": "    IncentiveModel incentiveModel; //Incentive model for rewards\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 664,
          "vulnerability_to_line": null,
          "vulnerability_code": "    address twoKeySingletoneRegistry;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 667,
          "vulnerability_to_line": null,
          "vulnerability_code": "    address ownerPlasma;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 669,
          "vulnerability_to_line": null,
          "vulnerability_code": "    address twoKeyMaintainersRegistry;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 670,
          "vulnerability_to_line": null,
          "vulnerability_code": "    address twoKeyRegistry;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 671,
          "vulnerability_to_line": null,
          "vulnerability_code": "    address twoKeyEventSource;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 672,
          "vulnerability_to_line": null,
          "vulnerability_code": "    address contractor;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 673,
          "vulnerability_to_line": null,
          "vulnerability_code": "    address moderator;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 675,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint powerLawFactor;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 676,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint campaignStartTime; // Time when campaign starts\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 677,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint campaignEndTime; // Time when campaign ends\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 678,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint minDonationAmountWei; // Minimal donation amount\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 679,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint maxDonationAmountWei; // Maximal donation amount\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 680,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint campaignGoal; // Goal of the campaign, how many funds to raise\n",
          "message": null
        }
      ]
    },
    "oyente": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "Integer Overflow",
          "vulnerability_from_line": 307,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function loadUint8(bytes sig, uint idx) public pure returns (uint8) {\n",
          "message": null
        },
        {
          "name": "Integer Overflow",
          "vulnerability_from_line": 1038,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getSuperStatistics(\n",
          "message": null
        },
        {
          "name": "Integer Underflow",
          "vulnerability_from_line": 682,
          "vulnerability_to_line": null,
          "vulnerability_code": "    string public currency;\n",
          "message": null
        }
      ]
    },
    "mythril": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "Integer Arithmetic Bugs (SWC 101)",
          "vulnerability_from_line": 207,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function params0(address c, bytes _method) public view returns (uint answer) {\n",
          "message": "The arithmetic operator can overflow.\nIt is possible to cause an integer overflow or underflow in the arithmetic operation. \nClassification: SWC-101"
        },
        {
          "name": "Integer Arithmetic Bugs (SWC 101)",
          "vulnerability_from_line": 235,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function params1(address c, bytes _method, uint _val) public view returns (uint answer) {\n",
          "message": "The arithmetic operator can overflow.\nIt is possible to cause an integer overflow or underflow in the arithmetic operation. \nClassification: SWC-101"
        },
        {
          "name": "Integer Arithmetic Bugs (SWC 101)",
          "vulnerability_from_line": 265,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function params2(address c, bytes _method, uint _val1, uint _val2) public view returns (uint answer) {\n",
          "message": "The arithmetic operator can overflow.\nIt is possible to cause an integer overflow or underflow in the arithmetic operation. \nClassification: SWC-101"
        },
        {
          "name": "Integer Arithmetic Bugs (SWC 101)",
          "vulnerability_from_line": 437,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function recoverSig(bytes sig, address old_key, address last_address) public pure returns (address[], address[], uint8[]) {\n",
          "message": "The arithmetic operator can overflow.\nIt is possible to cause an integer overflow or underflow in the arithmetic operation. \nClassification: SWC-101"
        },
        {
          "name": "External Call To User-Supplied Address (SWC 107)",
          "vulnerability_from_line": 217,
          "vulnerability_to_line": null,
          "vulnerability_code": "            let result := call(  // use WARNING because this should be staticcall BUT geth crash!\n",
          "message": "A call to a user-supplied address is executed.\nAn external message call to an address specified by the caller is executed. Note that the callee account might contain arbitrary code and could re-enter any function within this contract. Reentering the contract in an intermediate state may lead to unexpected behaviour. Make sure that no state modifications are executed after this call and/or reentrancy guards are in place.\nClassification: SWC-107"
        },
        {
          "name": "External Call To User-Supplied Address (SWC 107)",
          "vulnerability_from_line": 247,
          "vulnerability_to_line": null,
          "vulnerability_code": "            let result := call(  // use WARNING because this should be staticcall BUT geth crash!\n",
          "message": "A call to a user-supplied address is executed.\nAn external message call to an address specified by the caller is executed. Note that the callee account might contain arbitrary code and could re-enter any function within this contract. Reentering the contract in an intermediate state may lead to unexpected behaviour. Make sure that no state modifications are executed after this call and/or reentrancy guards are in place.\nClassification: SWC-107"
        },
        {
          "name": "External Call To User-Supplied Address (SWC 107)",
          "vulnerability_from_line": 278,
          "vulnerability_to_line": null,
          "vulnerability_code": "            let result := call(  // use WARNING because this should be staticcall BUT geth crash!\n",
          "message": "A call to a user-supplied address is executed.\nAn external message call to an address specified by the caller is executed. Note that the callee account might contain arbitrary code and could re-enter any function within this contract. Reentering the contract in an intermediate state may lead to unexpected behaviour. Make sure that no state modifications are executed after this call and/or reentrancy guards are in place.\nClassification: SWC-107"
        },
        {
          "name": "Unchecked return value from external call. (SWC 104)",
          "vulnerability_from_line": 278,
          "vulnerability_to_line": null,
          "vulnerability_code": "            let result := call(  // use WARNING because this should be staticcall BUT geth crash!\n",
          "message": "The return value of a message call is not checked.\nExternal calls return a boolean value. If the callee halts with an exception, 'false' is returned and execution continues in the caller. The caller should check whether an exception happened and react accordingly to avoid unexpected behavior. For example it is often desirable to wrap external calls in require() so the transaction is reverted if the call fails.\nClassification: SWC-104"
        },
        {
          "name": "Jump to an arbitrary instruction (SWC 127)",
          "vulnerability_from_line": 318,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function recoverHash(bytes32 hash, bytes sig, uint idx) public pure returns (address) {\n",
          "message": "The caller can redirect execution to arbitrary bytecode locations.\nIt is possible to redirect the control flow to arbitrary locations in the code. This may allow an attacker to bypass security controls or manipulate the business logic of the smart contract. Avoid using low-level-operations and assembly to prevent this issue.\nClassification: SWC-127"
        },
        {
          "name": "Exception State (SWC 110)",
          "vulnerability_from_line": 396,
          "vulnerability_to_line": null,
          "vulnerability_code": "        while (idx + 65 <= sig.length) {\n",
          "message": "An assertion violation was triggered.\nIt is possible to trigger an assertion violation. Note that Solidity assert() statements should only be used to check invariants. Review the transaction trace generated for this issue and either make sure your program logic is correct, or use require() instead of assert() if your goal is to constrain user inputs or enforce preconditions. Remember to validate inputs from both callers (for instance, via passed arguments) and callees (for instance, via return values).\nClassification: SWC-110"
        }
      ]
    },
    "osiris": {
      "successfull_analysis": true,
      "errors": [
        "DOCKER_TIMEOUT"
      ],
      "vulnerability_findings": [
        {
          "name": "Overflow bugs",
          "vulnerability_from_line": 323,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require (sig.length >= 65+idx, 'bad signature length');\n",
          "message": null
        },
        {
          "name": "Underflow bugs",
          "vulnerability_from_line": 358,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint n_influencers = (sig.length-21) / (65+msg_len);\n",
          "message": null
        }
      ]
    }
  }
}