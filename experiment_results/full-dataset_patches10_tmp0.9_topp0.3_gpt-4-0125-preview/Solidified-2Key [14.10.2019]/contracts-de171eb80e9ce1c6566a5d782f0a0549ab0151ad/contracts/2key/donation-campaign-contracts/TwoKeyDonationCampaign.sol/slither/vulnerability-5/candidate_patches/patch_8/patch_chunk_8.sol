function distributeArcsBasedOnSignature(
    bytes sig,
    address _converter
)
private
{
    address[] memory influencers;
    address[] memory keys;
    uint8[] memory weights;
    address old_address;
    (influencers, keys, weights, old_address) = super.getInfluencersKeysAndWeightsFromSignature(sig, _converter);
    uint i;
    address new_address;
    uint numberOfInfluencers = influencers.length;
    for (i = 0; i < numberOfInfluencers; i++) {
        new_address = twoKeyEventSource.plasmaOf(influencers[i]);

        require(received_from[new_address] == 0 || received_from[new_address] == old_address,'only tree ARCs allowed');

        if (received_from[new_address] == 0) {
            balances[old_address] = balances[old_address].sub(1);
            balances[new_address] = balances[new_address].add(1);
        }
        received_from[new_address] = old_address;
        old_address = new_address;

        // TODO Updating the public key of influencers may not be a good idea because it will require the influencers to use
        // a deterministic private/public key in the link and this might require user interaction (MetaMask signature)
        // TODO a possible solution is change public_link_key to address=>address[]
        // update (only once) the public address used by each influencer
        // we will need this in case one of the influencers will want to start his own off-chain link
        if (i < keys.length) {
            setPublicLinkKeyOf(new_address, keys[i]);
        }

        // update (only once) the cut used by each influencer
        // we will need this in case one of the influencers will want to start his own off-chain link
        if (i < weights.length) {
            setCutOf(new_address, uint256(weights[i]));
        }
    }
}