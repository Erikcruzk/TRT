pragma solidity ^0.4.24;


contract IERC20 {
    function balanceOf(
        address whom
    )
    external
    view
    returns (uint);


    function transfer(
        address _to,
        uint256 _value
    )
    external
    returns (bool);


    function transferFrom(
        address _from,
        address _to,
        uint256 _value
    )
    external
    returns (bool);



    function approve(
        address _spender,
        uint256 _value
    )
    public
    returns (bool);



    function decimals()
    external
    view
    returns (uint);


    function symbol()
    external
    view
    returns (string);


    function name()
    external
    view
    returns (string);


    function freezeTransfers()
    external;


    function unfreezeTransfers()
    external;
}



pragma solidity ^0.4.24;


contract ITwoKeyEventSource {
    function ethereumOf(address me) public view returns (address);
    function plasmaOf(address me) public view returns (address);
    function isAddressMaintainer(address _maintainer) public view returns (bool);
    function getTwoKeyDefaultIntegratorFeeFromAdmin() public view returns (uint);
}



pragma solidity ^0.4.24;


function withdrawTokens(uint part) public returns (bool) {
    require(msg.sender == converter || ITwoKeyEventSource(twoKeyEventSource).isAddressMaintainer(msg.sender) == true);
    require(isWithdrawn[part] == false && part < numberOfVestingPortions+1 && block.timestamp > tokenUnlockingDate[part]);
    uint amount;
    if(part == 0) {
        amount = baseTokens;
    } else {
        amount = bonusTokens / numberOfVestingPortions;
    }
    // Update the state before calling external contracts
    isWithdrawn[part] = true;

    // External call to a contract
    require(IERC20(assetContractERC20).transfer(converter,amount));

    // Emit an event after tokens are transferred
    emit TokensWithdrawn(
        block.timestamp,
        msg.sender,
        converter,
        part,
        amount
    );

    return true;
}