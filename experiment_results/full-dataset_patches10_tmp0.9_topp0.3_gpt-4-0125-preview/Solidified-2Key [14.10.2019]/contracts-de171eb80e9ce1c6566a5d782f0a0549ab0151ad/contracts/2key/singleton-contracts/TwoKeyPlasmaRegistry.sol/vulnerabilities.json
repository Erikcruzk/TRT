{
  "smartbugs_completed": true,
  "analyzer_results": {
    "semgrep": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 371,
          "vulnerability_to_line": null,
          "vulnerability_code": "        while (idx + 65 <= sig.length) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 375,
          "vulnerability_to_line": null,
          "vulnerability_code": "            if (idx + msg_len <= sig.length) {  // its  a < and not a <= because we dont want this to be the final iteration for the converter\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 426,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(uint i = 0; i < influencers.length; i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 427,
          "vulnerability_to_line": null,
          "vulnerability_code": "            if (i < weights.length) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 426,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(uint i = 0; i < influencers.length; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 298,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require (sig.length >= 65+idx, 'bad signature length');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 325,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(v==27 || v==28,'bad sig v');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 377,
          "vulnerability_to_line": null,
          "vulnerability_code": "                require(weights[count_influencers] > 0,'weight not defined (1..255)');  // 255 are used to indicate default (equal part) behaviour\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 407,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(idx == sig.length,'illegal message size');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 417,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(old_key != address(0),'no public link key');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 428,
          "vulnerability_to_line": null,
          "vulnerability_code": "                require (recoverHash(keccak256(abi.encodePacked(weights[i], keys[i], influencers[i])),sig,offsets[i]) == old_key, 'illegal signature');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 432,
          "vulnerability_to_line": null,
          "vulnerability_code": "                require (recoverHash(keccak256(abi.encodePacked(influencers[i])),sig,offsets[i]) == old_key, 'illegal last signature');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 337,
          "vulnerability_to_line": null,
          "vulnerability_code": "            n_influencers++;\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 378,
          "vulnerability_to_line": null,
          "vulnerability_code": "                idx++;\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 405,
          "vulnerability_to_line": null,
          "vulnerability_code": "            count_influencers++;\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 426,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(uint i = 0; i < influencers.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        }
      ]
    },
    "slither": {
      "successfull_analysis": true,
      "errors": [
        "EXIT_CODE_54"
      ],
      "vulnerability_findings": [
        {
          "name": "uninitialized-state",
          "vulnerability_from_line": 51,
          "vulnerability_to_line": null,
          "vulnerability_code": "    ITwoKeySingletonesRegistry internal registry;\n",
          "message": "UpgradeabilityStorage.registry (TwoKeyPlasmaRegistry.sol#51) is never initialized. It is used in:\n\t- initialize (TwoKeyPlasmaRegistry.sol#74-76)\n"
        },
        {
          "name": "uninitialized-state",
          "vulnerability_from_line": 54,
          "vulnerability_to_line": null,
          "vulnerability_code": "    address internal _implementation;\n",
          "message": "UpgradeabilityStorage._implementation (TwoKeyPlasmaRegistry.sol#54) is never initialized. It is used in:\n\t- implementation (TwoKeyPlasmaRegistry.sol#60-62)\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 182,
          "vulnerability_to_line": 208,
          "vulnerability_code": "    function params0(address c, bytes _method) public view returns (uint answer) {\n\n        // https://medium.com/@blockchain101/calling-the-function-of-another-contract-in-solidity-f9edfa921f4c\n\n        //    dc = c;\n\n        bytes4 sig = bytes4(keccak256(_method));\n\n        assembly {\n\n        // move pointer to free memory spot\n\n            let ptr := mload(0x40)\n\n        // put function sig at memory spot\n\n            mstore(ptr,sig)\n\n\n\n            let result := call(  // use WARNING because this should be staticcall BUT geth crash!\n\n            15000, // gas limit\n\n            c, // sload(dc_slot),  // to addr. append var to _slot to access storage variable\n\n            0, // not transfer any ether (comment if using staticcall)\n\n            ptr, // Inputs are stored at location ptr\n\n            0x04, // Inputs are 0 bytes long\n\n            ptr,  //Store output over input\n\n            0x20) //Outputs are 1 bytes long\n\n\n\n            if eq(result, 0) {\n\n                revert(0, 0)\n\n            }\n\n\n\n            answer := mload(ptr) // Assign output to answer var\n\n            mstore(0x40,add(ptr,0x24)) // Set storage pointer to new space\n\n        }\n",
          "message": "Call.params0 (TwoKeyPlasmaRegistry.sol#182-208) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 210,
          "vulnerability_to_line": 238,
          "vulnerability_code": "    function params1(address c, bytes _method, uint _val) public view returns (uint answer) {\n\n        // https://medium.com/@blockchain101/calling-the-function-of-another-contract-in-solidity-f9edfa921f4c\n\n        //    dc = c;\n\n        bytes4 sig = bytes4(keccak256(_method));\n\n        assembly {\n\n        // move pointer to free memory spot\n\n            let ptr := mload(0x40)\n\n        // put function sig at memory spot\n\n            mstore(ptr,sig)\n\n        // append argument after function sig\n\n            mstore(add(ptr,0x04), _val)\n\n\n\n            let result := call(  // use WARNING because this should be staticcall BUT geth crash!\n\n            15000, // gas limit\n\n            c, // sload(dc_slot),  // to addr. append var to _slot to access storage variable\n\n            0, // not transfer any ether (comment if using staticcall)\n\n            ptr, // Inputs are stored at location ptr\n\n            0x24, // Inputs are 0 bytes long\n\n            ptr,  //Store output over input\n\n            0x20) //Outputs are 1 bytes long\n\n\n\n            if eq(result, 0) {\n\n                revert(0, 0)\n\n            }\n\n\n\n            answer := mload(ptr) // Assign output to answer var\n\n            mstore(0x40,add(ptr,0x24)) // Set storage pointer to new space\n\n        }\n",
          "message": "Call.params1 (TwoKeyPlasmaRegistry.sol#210-238) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 240,
          "vulnerability_to_line": 270,
          "vulnerability_code": "    function params2(address c, bytes _method, uint _val1, uint _val2) public view returns (uint answer) {\n\n        // https://medium.com/@blockchain101/calling-the-function-of-another-contract-in-solidity-f9edfa921f4c\n\n        //    dc = c;\n\n        bytes4 sig = bytes4(keccak256(_method));\n\n        assembly {\n\n        // move pointer to free memory spot\n\n            let ptr := mload(0x40)\n\n        // put function sig at memory spot\n\n            mstore(ptr,sig)\n\n        // append argument after function sig\n\n            mstore(add(ptr,0x04), _val1)\n\n            mstore(add(ptr,0x24), _val2)\n\n\n\n            let result := call(  // use WARNING because this should be staticcall BUT geth crash!\n\n            15000, // gas limit\n\n            c, // sload(dc_slot),  // to addr. append var to _slot to access storage variable\n\n            0, // not transfer any ether (comment if using staticcall)\n\n            ptr, // Inputs are stored at location ptr\n\n            0x44, // Inputs are 4 bytes for signature and 2 uint256\n\n            ptr,  //Store output over input\n\n            0x20) //Outputs are 1 uint long\n\n\n\n        // TODO cause revert\n\n        //            if eq(result, 0) {\n\n        //                revert(0, 0)\n\n        //            }\n\n\n\n            answer := mload(ptr) // Assign output to answer var\n\n            mstore(0x40,add(ptr,0x20)) // Set storage pointer to new space\n\n        }\n",
          "message": "Call.params2 (TwoKeyPlasmaRegistry.sol#240-270) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 272,
          "vulnerability_to_line": 280,
          "vulnerability_code": "    function loadAddress(bytes sig, uint idx) public pure returns (address) {\n\n        address influencer;\n\n        idx += 20;\n\n        assembly\n\n        {\n\n            influencer := mload(add(sig, idx))\n\n        }\n\n        return influencer;\n",
          "message": "Call.loadAddress (TwoKeyPlasmaRegistry.sol#272-280) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 282,
          "vulnerability_to_line": 290,
          "vulnerability_code": "    function loadUint8(bytes sig, uint idx) public pure returns (uint8) {\n\n        uint8 weight;\n\n        idx += 1;\n\n        assembly\n\n        {\n\n            weight := mload(add(sig, idx))\n\n        }\n\n        return weight;\n",
          "message": "Call.loadUint8 (TwoKeyPlasmaRegistry.sol#282-290) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 293,
          "vulnerability_to_line": 328,
          "vulnerability_code": "    function recoverHash(bytes32 hash, bytes sig, uint idx) public pure returns (address) {\n\n        // same as recoverHash in utils/sign.js\n\n        // The signature format is a compact form of:\n\n        //   {bytes32 r}{bytes32 s}{uint8 v}\n\n        // Compact means, uint8 is not padded to 32 bytes.\n\n        require (sig.length >= 65+idx, 'bad signature length');\n\n        idx += 32;\n\n        bytes32 r;\n\n        assembly\n\n        {\n\n            r := mload(add(sig, idx))\n\n        }\n\n\n\n        idx += 32;\n\n        bytes32 s;\n\n        assembly\n\n        {\n\n            s := mload(add(sig, idx))\n\n        }\n\n\n\n        idx += 1;\n\n        uint8 v;\n\n        assembly\n\n        {\n\n            v := mload(add(sig, idx))\n\n        }\n\n        if (v >= 32) { // handle case when signature was made with ethereum web3.eth.sign or getSign which is for signing ethereum transactions\n\n            v -= 32;\n\n            bytes memory prefix = \"\\x19Ethereum Signed Message:\\n32\"; // 32 is the number of bytes in the following hash\n\n            hash = keccak256(abi.encodePacked(prefix, hash));\n\n        }\n\n        if (v <= 1) v += 27;\n\n        require(v==27 || v==28,'bad sig v');\n\n        return ecrecover(hash, v, r, s);\n\n\n",
          "message": "Call.recoverHash (TwoKeyPlasmaRegistry.sol#293-328) is declared view but contains assembly code\n"
        },
        {
          "name": "locked-ether",
          "vulnerability_from_line": 74,
          "vulnerability_to_line": 76,
          "vulnerability_code": "    function initialize(address sender) public payable {\n\n        require(msg.sender == address(registry));\n",
          "message": "Contract locking ether found in TwoKeyPlasmaRegistry.sol:\n\tContract TwoKeyPlasmaRegistry has payable functions:\n\t - initialize (TwoKeyPlasmaRegistry.sol#74-76)\n\tBut does not have a function to withdraw the ether\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 182,
          "vulnerability_to_line": 208,
          "vulnerability_code": "    function params0(address c, bytes _method) public view returns (uint answer) {\n\n        // https://medium.com/@blockchain101/calling-the-function-of-another-contract-in-solidity-f9edfa921f4c\n\n        //    dc = c;\n\n        bytes4 sig = bytes4(keccak256(_method));\n\n        assembly {\n\n        // move pointer to free memory spot\n\n            let ptr := mload(0x40)\n\n        // put function sig at memory spot\n\n            mstore(ptr,sig)\n\n\n\n            let result := call(  // use WARNING because this should be staticcall BUT geth crash!\n\n            15000, // gas limit\n\n            c, // sload(dc_slot),  // to addr. append var to _slot to access storage variable\n\n            0, // not transfer any ether (comment if using staticcall)\n\n            ptr, // Inputs are stored at location ptr\n\n            0x04, // Inputs are 0 bytes long\n\n            ptr,  //Store output over input\n\n            0x20) //Outputs are 1 bytes long\n\n\n\n            if eq(result, 0) {\n\n                revert(0, 0)\n\n            }\n\n\n\n            answer := mload(ptr) // Assign output to answer var\n\n            mstore(0x40,add(ptr,0x24)) // Set storage pointer to new space\n\n        }\n",
          "message": "Call.params0 uses assembly (TwoKeyPlasmaRegistry.sol#182-208)\n\t- TwoKeyPlasmaRegistry.sol#186-208\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 210,
          "vulnerability_to_line": 238,
          "vulnerability_code": "    function params1(address c, bytes _method, uint _val) public view returns (uint answer) {\n\n        // https://medium.com/@blockchain101/calling-the-function-of-another-contract-in-solidity-f9edfa921f4c\n\n        //    dc = c;\n\n        bytes4 sig = bytes4(keccak256(_method));\n\n        assembly {\n\n        // move pointer to free memory spot\n\n            let ptr := mload(0x40)\n\n        // put function sig at memory spot\n\n            mstore(ptr,sig)\n\n        // append argument after function sig\n\n            mstore(add(ptr,0x04), _val)\n\n\n\n            let result := call(  // use WARNING because this should be staticcall BUT geth crash!\n\n            15000, // gas limit\n\n            c, // sload(dc_slot),  // to addr. append var to _slot to access storage variable\n\n            0, // not transfer any ether (comment if using staticcall)\n\n            ptr, // Inputs are stored at location ptr\n\n            0x24, // Inputs are 0 bytes long\n\n            ptr,  //Store output over input\n\n            0x20) //Outputs are 1 bytes long\n\n\n\n            if eq(result, 0) {\n\n                revert(0, 0)\n\n            }\n\n\n\n            answer := mload(ptr) // Assign output to answer var\n\n            mstore(0x40,add(ptr,0x24)) // Set storage pointer to new space\n\n        }\n",
          "message": "Call.params1 uses assembly (TwoKeyPlasmaRegistry.sol#210-238)\n\t- TwoKeyPlasmaRegistry.sol#214-238\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 240,
          "vulnerability_to_line": 270,
          "vulnerability_code": "    function params2(address c, bytes _method, uint _val1, uint _val2) public view returns (uint answer) {\n\n        // https://medium.com/@blockchain101/calling-the-function-of-another-contract-in-solidity-f9edfa921f4c\n\n        //    dc = c;\n\n        bytes4 sig = bytes4(keccak256(_method));\n\n        assembly {\n\n        // move pointer to free memory spot\n\n            let ptr := mload(0x40)\n\n        // put function sig at memory spot\n\n            mstore(ptr,sig)\n\n        // append argument after function sig\n\n            mstore(add(ptr,0x04), _val1)\n\n            mstore(add(ptr,0x24), _val2)\n\n\n\n            let result := call(  // use WARNING because this should be staticcall BUT geth crash!\n\n            15000, // gas limit\n\n            c, // sload(dc_slot),  // to addr. append var to _slot to access storage variable\n\n            0, // not transfer any ether (comment if using staticcall)\n\n            ptr, // Inputs are stored at location ptr\n\n            0x44, // Inputs are 4 bytes for signature and 2 uint256\n\n            ptr,  //Store output over input\n\n            0x20) //Outputs are 1 uint long\n\n\n\n        // TODO cause revert\n\n        //            if eq(result, 0) {\n\n        //                revert(0, 0)\n\n        //            }\n\n\n\n            answer := mload(ptr) // Assign output to answer var\n\n            mstore(0x40,add(ptr,0x20)) // Set storage pointer to new space\n\n        }\n",
          "message": "Call.params2 uses assembly (TwoKeyPlasmaRegistry.sol#240-270)\n\t- TwoKeyPlasmaRegistry.sol#244-270\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 272,
          "vulnerability_to_line": 280,
          "vulnerability_code": "    function loadAddress(bytes sig, uint idx) public pure returns (address) {\n\n        address influencer;\n\n        idx += 20;\n\n        assembly\n\n        {\n\n            influencer := mload(add(sig, idx))\n\n        }\n\n        return influencer;\n",
          "message": "Call.loadAddress uses assembly (TwoKeyPlasmaRegistry.sol#272-280)\n\t- TwoKeyPlasmaRegistry.sol#275-279\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 282,
          "vulnerability_to_line": 290,
          "vulnerability_code": "    function loadUint8(bytes sig, uint idx) public pure returns (uint8) {\n\n        uint8 weight;\n\n        idx += 1;\n\n        assembly\n\n        {\n\n            weight := mload(add(sig, idx))\n\n        }\n\n        return weight;\n",
          "message": "Call.loadUint8 uses assembly (TwoKeyPlasmaRegistry.sol#282-290)\n\t- TwoKeyPlasmaRegistry.sol#285-289\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 293,
          "vulnerability_to_line": 328,
          "vulnerability_code": "    function recoverHash(bytes32 hash, bytes sig, uint idx) public pure returns (address) {\n\n        // same as recoverHash in utils/sign.js\n\n        // The signature format is a compact form of:\n\n        //   {bytes32 r}{bytes32 s}{uint8 v}\n\n        // Compact means, uint8 is not padded to 32 bytes.\n\n        require (sig.length >= 65+idx, 'bad signature length');\n\n        idx += 32;\n\n        bytes32 r;\n\n        assembly\n\n        {\n\n            r := mload(add(sig, idx))\n\n        }\n\n\n\n        idx += 32;\n\n        bytes32 s;\n\n        assembly\n\n        {\n\n            s := mload(add(sig, idx))\n\n        }\n\n\n\n        idx += 1;\n\n        uint8 v;\n\n        assembly\n\n        {\n\n            v := mload(add(sig, idx))\n\n        }\n\n        if (v >= 32) { // handle case when signature was made with ethereum web3.eth.sign or getSign which is for signing ethereum transactions\n\n            v -= 32;\n\n            bytes memory prefix = \"\\x19Ethereum Signed Message:\\n32\"; // 32 is the number of bytes in the following hash\n\n            hash = keccak256(abi.encodePacked(prefix, hash));\n\n        }\n\n        if (v <= 1) v += 27;\n\n        require(v==27 || v==28,'bad sig v');\n\n        return ecrecover(hash, v, r, s);\n\n\n",
          "message": "Call.recoverHash uses assembly (TwoKeyPlasmaRegistry.sol#293-328)\n\t- TwoKeyPlasmaRegistry.sol#301-306\n\t- TwoKeyPlasmaRegistry.sol#308-313\n\t- TwoKeyPlasmaRegistry.sol#315-319\n"
        },
        {
          "name": "constable-states",
          "vulnerability_from_line": 54,
          "vulnerability_to_line": null,
          "vulnerability_code": "    address internal _implementation;\n",
          "message": "UpgradeabilityStorage._implementation should be constant (TwoKeyPlasmaRegistry.sol#54)\n"
        },
        {
          "name": "pragma",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.24;\n",
          "message": "Different versions of Solidity is used in TwoKeyPlasmaRegistry.sol:\n\t- Version used: ['^0.4.0', '^0.4.24']\n\t- TwoKeyPlasmaRegistry.sol#3 declares pragma solidity^0.4.24\n\t- TwoKeyPlasmaRegistry.sol#43 declares pragma solidity^0.4.24\n\t- TwoKeyPlasmaRegistry.sol#67 declares pragma solidity^0.4.24\n\t- TwoKeyPlasmaRegistry.sol#81 declares pragma solidity^0.4.0\n\t- TwoKeyPlasmaRegistry.sol#132 declares pragma solidity^0.4.24\n\t- TwoKeyPlasmaRegistry.sol#140 declares pragma solidity^0.4.24\n\t- TwoKeyPlasmaRegistry.sol#148 declares pragma solidity^0.4.24\n\t- TwoKeyPlasmaRegistry.sol#161 declares pragma solidity^0.4.24\n\t- TwoKeyPlasmaRegistry.sol#179 declares pragma solidity^0.4.24\n\t- TwoKeyPlasmaRegistry.sol#442 declares pragma solidity^0.4.24\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 30,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function addVersion(string _contractName, string version, address implementation) public;\n",
          "message": "ITwoKeySingletonesRegistry.addVersion (TwoKeyPlasmaRegistry.sol#30) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 38,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getVersion(string _contractName, string version) public view returns (address);\n",
          "message": "ITwoKeySingletonesRegistry.getVersion (TwoKeyPlasmaRegistry.sol#38) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 60,
          "vulnerability_to_line": 62,
          "vulnerability_code": "    function implementation() public view returns (address) {\n\n        return _implementation;\n",
          "message": "UpgradeabilityStorage.implementation (TwoKeyPlasmaRegistry.sol#60-62) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 74,
          "vulnerability_to_line": 76,
          "vulnerability_code": "    function initialize(address sender) public payable {\n\n        require(msg.sender == address(registry));\n",
          "message": "Upgradeable.initialize (TwoKeyPlasmaRegistry.sol#74-76) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 143,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function onlyMaintainer(address _sender) public view returns (bool);\n",
          "message": "ITwoKeyMaintainersRegistry.onlyMaintainer (TwoKeyPlasmaRegistry.sol#143) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 154,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getContractProxyAddress(string _contractName) public view returns (address);\n",
          "message": "ITwoKeySingletoneRegistryFetchAddress.getContractProxyAddress (TwoKeyPlasmaRegistry.sol#154) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 155,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getNonUpgradableContractAddress(string contractName) public view returns (address);\n",
          "message": "ITwoKeySingletoneRegistryFetchAddress.getNonUpgradableContractAddress (TwoKeyPlasmaRegistry.sol#155) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 156,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getLatestContractVersion(string contractName) public view returns (string);\n",
          "message": "ITwoKeySingletoneRegistryFetchAddress.getLatestContractVersion (TwoKeyPlasmaRegistry.sol#156) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 164,
          "vulnerability_to_line": 168,
          "vulnerability_code": "    function emitPlasma2EthereumEvent(\n\n        address _plasma,\n\n        address _ethereum\n\n    )\n",
          "message": "ITwoKeyPlasmaEvents.emitPlasma2EthereumEvent (TwoKeyPlasmaRegistry.sol#164-168) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 170,
          "vulnerability_to_line": 174,
          "vulnerability_code": "    function emitPlasma2HandleEvent(\n\n        address _plasma,\n\n        string _handle\n\n    )\n",
          "message": "ITwoKeyPlasmaEvents.emitPlasma2HandleEvent (TwoKeyPlasmaRegistry.sol#170-174) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 182,
          "vulnerability_to_line": 208,
          "vulnerability_code": "    function params0(address c, bytes _method) public view returns (uint answer) {\n\n        // https://medium.com/@blockchain101/calling-the-function-of-another-contract-in-solidity-f9edfa921f4c\n\n        //    dc = c;\n\n        bytes4 sig = bytes4(keccak256(_method));\n\n        assembly {\n\n        // move pointer to free memory spot\n\n            let ptr := mload(0x40)\n\n        // put function sig at memory spot\n\n            mstore(ptr,sig)\n\n\n\n            let result := call(  // use WARNING because this should be staticcall BUT geth crash!\n\n            15000, // gas limit\n\n            c, // sload(dc_slot),  // to addr. append var to _slot to access storage variable\n\n            0, // not transfer any ether (comment if using staticcall)\n\n            ptr, // Inputs are stored at location ptr\n\n            0x04, // Inputs are 0 bytes long\n\n            ptr,  //Store output over input\n\n            0x20) //Outputs are 1 bytes long\n\n\n\n            if eq(result, 0) {\n\n                revert(0, 0)\n\n            }\n\n\n\n            answer := mload(ptr) // Assign output to answer var\n\n            mstore(0x40,add(ptr,0x24)) // Set storage pointer to new space\n\n        }\n",
          "message": "Call.params0 (TwoKeyPlasmaRegistry.sol#182-208) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 210,
          "vulnerability_to_line": 238,
          "vulnerability_code": "    function params1(address c, bytes _method, uint _val) public view returns (uint answer) {\n\n        // https://medium.com/@blockchain101/calling-the-function-of-another-contract-in-solidity-f9edfa921f4c\n\n        //    dc = c;\n\n        bytes4 sig = bytes4(keccak256(_method));\n\n        assembly {\n\n        // move pointer to free memory spot\n\n            let ptr := mload(0x40)\n\n        // put function sig at memory spot\n\n            mstore(ptr,sig)\n\n        // append argument after function sig\n\n            mstore(add(ptr,0x04), _val)\n\n\n\n            let result := call(  // use WARNING because this should be staticcall BUT geth crash!\n\n            15000, // gas limit\n\n            c, // sload(dc_slot),  // to addr. append var to _slot to access storage variable\n\n            0, // not transfer any ether (comment if using staticcall)\n\n            ptr, // Inputs are stored at location ptr\n\n            0x24, // Inputs are 0 bytes long\n\n            ptr,  //Store output over input\n\n            0x20) //Outputs are 1 bytes long\n\n\n\n            if eq(result, 0) {\n\n                revert(0, 0)\n\n            }\n\n\n\n            answer := mload(ptr) // Assign output to answer var\n\n            mstore(0x40,add(ptr,0x24)) // Set storage pointer to new space\n\n        }\n",
          "message": "Call.params1 (TwoKeyPlasmaRegistry.sol#210-238) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 240,
          "vulnerability_to_line": 270,
          "vulnerability_code": "    function params2(address c, bytes _method, uint _val1, uint _val2) public view returns (uint answer) {\n\n        // https://medium.com/@blockchain101/calling-the-function-of-another-contract-in-solidity-f9edfa921f4c\n\n        //    dc = c;\n\n        bytes4 sig = bytes4(keccak256(_method));\n\n        assembly {\n\n        // move pointer to free memory spot\n\n            let ptr := mload(0x40)\n\n        // put function sig at memory spot\n\n            mstore(ptr,sig)\n\n        // append argument after function sig\n\n            mstore(add(ptr,0x04), _val1)\n\n            mstore(add(ptr,0x24), _val2)\n\n\n\n            let result := call(  // use WARNING because this should be staticcall BUT geth crash!\n\n            15000, // gas limit\n\n            c, // sload(dc_slot),  // to addr. append var to _slot to access storage variable\n\n            0, // not transfer any ether (comment if using staticcall)\n\n            ptr, // Inputs are stored at location ptr\n\n            0x44, // Inputs are 4 bytes for signature and 2 uint256\n\n            ptr,  //Store output over input\n\n            0x20) //Outputs are 1 uint long\n\n\n\n        // TODO cause revert\n\n        //            if eq(result, 0) {\n\n        //                revert(0, 0)\n\n        //            }\n\n\n\n            answer := mload(ptr) // Assign output to answer var\n\n            mstore(0x40,add(ptr,0x20)) // Set storage pointer to new space\n\n        }\n",
          "message": "Call.params2 (TwoKeyPlasmaRegistry.sol#240-270) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 412,
          "vulnerability_to_line": 437,
          "vulnerability_code": "    function recoverSig(bytes sig, address old_key, address last_address) public pure returns (address[], address[], uint8[]) {\n\n        // validate sig AND\n\n        // recover the information from the signature: influencers, public_link_keys, weights/cuts\n\n        // influencers may have one more address than the keys and weights arrays\n\n        //\n\n        require(old_key != address(0),'no public link key');\n\n\n\n        address[] memory influencers;\n\n        address[] memory keys;\n\n        uint8[] memory weights;\n\n        uint[] memory offsets;\n\n        (influencers, keys, weights, offsets) = recoverSigParts(sig, last_address);\n\n\n\n        // check if we received a valid signature\n\n        for(uint i = 0; i < influencers.length; i++) {\n\n            if (i < weights.length) {\n\n                require (recoverHash(keccak256(abi.encodePacked(weights[i], keys[i], influencers[i])),sig,offsets[i]) == old_key, 'illegal signature');\n\n                old_key = keys[i];\n\n            } else {\n\n                // signed message for the last step is the address of the converter\n\n                require (recoverHash(keccak256(abi.encodePacked(influencers[i])),sig,offsets[i]) == old_key, 'illegal last signature');\n\n            }\n\n        }\n\n\n\n        return (influencers, keys, weights);\n",
          "message": "Call.recoverSig (TwoKeyPlasmaRegistry.sol#412-437) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 457,
          "vulnerability_to_line": 469,
          "vulnerability_code": "    function setInitialParams(\n\n        address _twoKeyPlasmaSingletonRegistry,\n\n        address _proxyStorage\n\n    )\n\n    public\n\n    {\n\n        require(initialized == false);\n\n\n\n        TWO_KEY_PLASMA_SINGLETON_REGISTRY = _twoKeyPlasmaSingletonRegistry;\n\n        PROXY_STORAGE_CONTRACT = ITwoKeyPlasmaRegistryStorage(_proxyStorage);\n\n\n\n        initialized = true;\n",
          "message": "TwoKeyPlasmaRegistry.setInitialParams (TwoKeyPlasmaRegistry.sol#457-469) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 485,
          "vulnerability_to_line": 496,
          "vulnerability_code": "    function linkUsernameAndAddress(bytes signature, address plasma_address, string username) public {\n\n        require(msg.sender == plasma_address || onlyMaintainer());\n\n        bytes32 hash = keccak256(abi.encodePacked(keccak256(abi.encodePacked(\"bytes binding to plasma address\")),keccak256(abi.encodePacked(plasma_address))));\n\n        require (signature.length == 65);\n\n        address plasma = Call.recoverHash(hash,signature,0);\n\n        require(plasma == plasma_address);\n\n\n\n        PROXY_STORAGE_CONTRACT.setString(keccak256(\"addressToUsername\", plasma_address), username);\n\n        PROXY_STORAGE_CONTRACT.setAddress(keccak256(\"usernameToAddress\",username), plasma_address);\n\n\n\n        emitPlasma2Handle(plasma_address, username);\n",
          "message": "TwoKeyPlasmaRegistry.linkUsernameAndAddress (TwoKeyPlasmaRegistry.sol#485-496) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 498,
          "vulnerability_to_line": 509,
          "vulnerability_code": "    function add_plasma2ethereum(address plasma_address, bytes sig) public {\n\n        require(msg.sender == plasma_address || onlyMaintainer());\n\n        bytes32 hash = keccak256(abi.encodePacked(keccak256(abi.encodePacked(\"bytes binding to plasma address\")),keccak256(abi.encodePacked(plasma_address))));\n\n        require (sig.length == 65);\n\n        address eth_address = Call.recoverHash(hash,sig,0);\n\n        address ethereum = PROXY_STORAGE_CONTRACT.getAddress(keccak256(\"plasma2ethereum\", plasma_address));\n\n        require(ethereum == address(0) || ethereum == eth_address);\n\n        PROXY_STORAGE_CONTRACT.setAddress(keccak256(\"plasma2ethereum\", plasma_address), eth_address);\n\n        PROXY_STORAGE_CONTRACT.setAddress(keccak256(\"ethereum2plasma\",eth_address), plasma_address);\n\n\n\n        emitPlasma2Ethereum(plasma_address, eth_address);\n",
          "message": "TwoKeyPlasmaRegistry.add_plasma2ethereum (TwoKeyPlasmaRegistry.sol#498-509) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 521,
          "vulnerability_to_line": 528,
          "vulnerability_code": "    function plasma2ethereum(\n\n        address _plasma\n\n    )\n\n    public\n\n    view\n\n    returns (address) {\n\n        return PROXY_STORAGE_CONTRACT.getAddress(keccak256(\"plasma2ethereum\", _plasma));\n",
          "message": "TwoKeyPlasmaRegistry.plasma2ethereum (TwoKeyPlasmaRegistry.sol#521-528) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 530,
          "vulnerability_to_line": 537,
          "vulnerability_code": "    function ethereum2plasma(\n\n        address _ethereum\n\n    )\n\n    public\n\n    view\n\n    returns (address) {\n\n        return PROXY_STORAGE_CONTRACT.getAddress(keccak256(\"ethereum2plasma\", _ethereum));\n",
          "message": "TwoKeyPlasmaRegistry.ethereum2plasma (TwoKeyPlasmaRegistry.sol#530-537) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 543,
          "vulnerability_to_line": 554,
          "vulnerability_code": "    function recover(\n\n        bytes signature\n\n    )\n\n    public\n\n    view\n\n    returns (address)\n\n    {\n\n        bytes32 hash = keccak256(abi.encodePacked(keccak256(abi.encodePacked(\"bytes binding referrer to plasma\")),\n\n            keccak256(abi.encodePacked(\"GET_REFERRER_REWARDS\"))));\n\n        address recoveredAddress = Call.recoverHash(hash, signature, 0);\n\n        return recoveredAddress;\n",
          "message": "TwoKeyPlasmaRegistry.recover (TwoKeyPlasmaRegistry.sol#543-554) should be declared external\n"
        },
        {
          "name": "solc-version",
          "vulnerability_from_line": 81,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.0;\n",
          "message": "Detected issues with version pragma in TwoKeyPlasmaRegistry.sol:\n\t- pragma solidity^0.4.0 (TwoKeyPlasmaRegistry.sol#81): it allows old versions\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 54,
          "vulnerability_to_line": null,
          "vulnerability_code": "    address internal _implementation;\n",
          "message": "Variable 'UpgradeabilityStorage._implementation' (TwoKeyPlasmaRegistry.sol#54) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 182,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function params0(address c, bytes _method) public view returns (uint answer) {\n",
          "message": "Parameter '_method' of Call.params0 (TwoKeyPlasmaRegistry.sol#182) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 210,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function params1(address c, bytes _method, uint _val) public view returns (uint answer) {\n",
          "message": "Parameter '_method' of Call.params1 (TwoKeyPlasmaRegistry.sol#210) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 240,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function params2(address c, bytes _method, uint _val1, uint _val2) public view returns (uint answer) {\n",
          "message": "Parameter '_method' of Call.params2 (TwoKeyPlasmaRegistry.sol#240) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 345,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function recoverSigParts(bytes sig, address last_address) private pure returns (address[], address[], uint8[], uint[]) {\n",
          "message": "Parameter 'last_address' of Call.recoverSigParts (TwoKeyPlasmaRegistry.sol#345) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 412,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function recoverSig(bytes sig, address old_key, address last_address) public pure returns (address[], address[], uint8[]) {\n",
          "message": "Parameter 'old_key' of Call.recoverSig (TwoKeyPlasmaRegistry.sol#412) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 412,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function recoverSig(bytes sig, address old_key, address last_address) public pure returns (address[], address[], uint8[]) {\n",
          "message": "Parameter 'last_address' of Call.recoverSig (TwoKeyPlasmaRegistry.sol#412) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 458,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address _twoKeyPlasmaSingletonRegistry,\n",
          "message": "Parameter '_twoKeyPlasmaSingletonRegistry' of TwoKeyPlasmaRegistry.setInitialParams (TwoKeyPlasmaRegistry.sol#458) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 459,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address _proxyStorage\n",
          "message": "Parameter '_proxyStorage' of TwoKeyPlasmaRegistry.setInitialParams (TwoKeyPlasmaRegistry.sol#459) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 485,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function linkUsernameAndAddress(bytes signature, address plasma_address, string username) public {\n",
          "message": "Parameter 'plasma_address' of TwoKeyPlasmaRegistry.linkUsernameAndAddress (TwoKeyPlasmaRegistry.sol#485) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 498,
          "vulnerability_to_line": 509,
          "vulnerability_code": "    function add_plasma2ethereum(address plasma_address, bytes sig) public {\n\n        require(msg.sender == plasma_address || onlyMaintainer());\n\n        bytes32 hash = keccak256(abi.encodePacked(keccak256(abi.encodePacked(\"bytes binding to plasma address\")),keccak256(abi.encodePacked(plasma_address))));\n\n        require (sig.length == 65);\n\n        address eth_address = Call.recoverHash(hash,sig,0);\n\n        address ethereum = PROXY_STORAGE_CONTRACT.getAddress(keccak256(\"plasma2ethereum\", plasma_address));\n\n        require(ethereum == address(0) || ethereum == eth_address);\n\n        PROXY_STORAGE_CONTRACT.setAddress(keccak256(\"plasma2ethereum\", plasma_address), eth_address);\n\n        PROXY_STORAGE_CONTRACT.setAddress(keccak256(\"ethereum2plasma\",eth_address), plasma_address);\n\n\n\n        emitPlasma2Ethereum(plasma_address, eth_address);\n",
          "message": "Function 'TwoKeyPlasmaRegistry.add_plasma2ethereum' (TwoKeyPlasmaRegistry.sol#498-509) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 498,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function add_plasma2ethereum(address plasma_address, bytes sig) public {\n",
          "message": "Parameter 'plasma_address' of TwoKeyPlasmaRegistry.add_plasma2ethereum (TwoKeyPlasmaRegistry.sol#498) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 522,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address _plasma\n",
          "message": "Parameter '_plasma' of TwoKeyPlasmaRegistry.plasma2ethereum (TwoKeyPlasmaRegistry.sol#522) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 531,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address _ethereum\n",
          "message": "Parameter '_ethereum' of TwoKeyPlasmaRegistry.ethereum2plasma (TwoKeyPlasmaRegistry.sol#531) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 452,
          "vulnerability_to_line": null,
          "vulnerability_code": "    address public TWO_KEY_PLASMA_SINGLETON_REGISTRY;\n",
          "message": "Variable 'TwoKeyPlasmaRegistry.TWO_KEY_PLASMA_SINGLETON_REGISTRY' (TwoKeyPlasmaRegistry.sol#452) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 455,
          "vulnerability_to_line": null,
          "vulnerability_code": "    ITwoKeyPlasmaRegistryStorage public PROXY_STORAGE_CONTRACT;\n",
          "message": "Variable 'TwoKeyPlasmaRegistry.PROXY_STORAGE_CONTRACT' (TwoKeyPlasmaRegistry.sol#455) is not in mixedCase\n"
        }
      ]
    },
    "smartcheck": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 426,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(uint i = 0; i < influencers.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 371,
          "vulnerability_to_line": null,
          "vulnerability_code": "        while (idx + 65 <= sig.length) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
          "vulnerability_from_line": 182,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function params0(address c, bytes _method) public view returns (uint answer) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
          "vulnerability_from_line": 210,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function params1(address c, bytes _method, uint _val) public view returns (uint answer) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
          "vulnerability_from_line": 240,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function params2(address c, bytes _method, uint _val1, uint _val2) public view returns (uint answer) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 426,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(uint i = 0; i < influencers.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 371,
          "vulnerability_to_line": null,
          "vulnerability_code": "        while (idx + 65 <= sig.length) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_LOCKED_MONEY",
          "vulnerability_from_line": 69,
          "vulnerability_to_line": null,
          "vulnerability_code": "contract Upgradeable is UpgradeabilityStorage {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.24;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 43,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.24;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 67,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.24;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 81,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 132,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.24;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 140,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.24;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 148,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.24;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 161,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.24;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 179,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.24;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 442,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.24;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 272,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function loadAddress(bytes sig, uint idx) public pure returns (address) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 282,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function loadUint8(bytes sig, uint idx) public pure returns (uint8) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 293,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function recoverHash(bytes32 hash, bytes sig, uint idx) public pure returns (address) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
          "vulnerability_from_line": 182,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function params0(address c, bytes _method) public view returns (uint answer) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
          "vulnerability_from_line": 210,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function params1(address c, bytes _method, uint _val) public view returns (uint answer) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
          "vulnerability_from_line": 240,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function params2(address c, bytes _method, uint _val1, uint _val2) public view returns (uint answer) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 330,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function recoverSigMemory(bytes sig) private pure returns (address[], address[], uint8[], uint[], uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 345,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function recoverSigParts(bytes sig, address last_address) private pure returns (address[], address[], uint8[], uint[]) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 492,
          "vulnerability_to_line": null,
          "vulnerability_code": "        PROXY_STORAGE_CONTRACT.setString(keccak256(\"addressToUsername\", plasma_address), username);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 493,
          "vulnerability_to_line": null,
          "vulnerability_code": "        PROXY_STORAGE_CONTRACT.setAddress(keccak256(\"usernameToAddress\",username), plasma_address);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 503,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address ethereum = PROXY_STORAGE_CONTRACT.getAddress(keccak256(\"plasma2ethereum\", plasma_address));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 505,
          "vulnerability_to_line": null,
          "vulnerability_code": "        PROXY_STORAGE_CONTRACT.setAddress(keccak256(\"plasma2ethereum\", plasma_address), eth_address);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 506,
          "vulnerability_to_line": null,
          "vulnerability_code": "        PROXY_STORAGE_CONTRACT.setAddress(keccak256(\"ethereum2plasma\",eth_address), plasma_address);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 527,
          "vulnerability_to_line": null,
          "vulnerability_code": "        return PROXY_STORAGE_CONTRACT.getAddress(keccak256(\"plasma2ethereum\", _plasma));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 536,
          "vulnerability_to_line": null,
          "vulnerability_code": "        return PROXY_STORAGE_CONTRACT.getAddress(keccak256(\"ethereum2plasma\", _ethereum));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 30,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function addVersion(string _contractName, string version, address implementation) public;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 30,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function addVersion(string _contractName, string version, address implementation) public;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 38,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getVersion(string _contractName, string version) public view returns (address);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 38,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getVersion(string _contractName, string version) public view returns (address);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 154,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getContractProxyAddress(string _contractName) public view returns (address);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 155,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getNonUpgradableContractAddress(string contractName) public view returns (address);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 156,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getLatestContractVersion(string contractName) public view returns (string);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 156,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getLatestContractVersion(string contractName) public view returns (string);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 172,
          "vulnerability_to_line": null,
          "vulnerability_code": "        string _handle\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 182,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function params0(address c, bytes _method) public view returns (uint answer) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 210,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function params1(address c, bytes _method, uint _val) public view returns (uint answer) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 240,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function params2(address c, bytes _method, uint _val1, uint _val2) public view returns (uint answer) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 272,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function loadAddress(bytes sig, uint idx) public pure returns (address) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 282,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function loadUint8(bytes sig, uint idx) public pure returns (uint8) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 293,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function recoverHash(bytes32 hash, bytes sig, uint idx) public pure returns (address) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 330,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function recoverSigMemory(bytes sig) private pure returns (address[], address[], uint8[], uint[], uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 330,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function recoverSigMemory(bytes sig) private pure returns (address[], address[], uint8[], uint[], uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 330,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function recoverSigMemory(bytes sig) private pure returns (address[], address[], uint8[], uint[], uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 330,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function recoverSigMemory(bytes sig) private pure returns (address[], address[], uint8[], uint[], uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 330,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function recoverSigMemory(bytes sig) private pure returns (address[], address[], uint8[], uint[], uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 345,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function recoverSigParts(bytes sig, address last_address) private pure returns (address[], address[], uint8[], uint[]) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 345,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function recoverSigParts(bytes sig, address last_address) private pure returns (address[], address[], uint8[], uint[]) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 345,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function recoverSigParts(bytes sig, address last_address) private pure returns (address[], address[], uint8[], uint[]) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 345,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function recoverSigParts(bytes sig, address last_address) private pure returns (address[], address[], uint8[], uint[]) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 345,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function recoverSigParts(bytes sig, address last_address) private pure returns (address[], address[], uint8[], uint[]) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 412,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function recoverSig(bytes sig, address old_key, address last_address) public pure returns (address[], address[], uint8[]) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 412,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function recoverSig(bytes sig, address old_key, address last_address) public pure returns (address[], address[], uint8[]) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 412,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function recoverSig(bytes sig, address old_key, address last_address) public pure returns (address[], address[], uint8[]) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 412,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function recoverSig(bytes sig, address old_key, address last_address) public pure returns (address[], address[], uint8[]) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 472,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getAddressFromTwoKeySingletonRegistry(string contractName) internal view returns (address) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 485,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function linkUsernameAndAddress(bytes signature, address plasma_address, string username) public {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 485,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function linkUsernameAndAddress(bytes signature, address plasma_address, string username) public {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 498,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function add_plasma2ethereum(address plasma_address, bytes sig) public {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 516,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function emitPlasma2Handle(address plasma, string handle) internal {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 544,
          "vulnerability_to_line": null,
          "vulnerability_code": "        bytes signature\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 186,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 214,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 244,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 275,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 285,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 301,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 308,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 315,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 30,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function addVersion(string _contractName, string version, address implementation) public;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 38,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getVersion(string _contractName, string version) public view returns (address);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 453,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bool initialized;\n",
          "message": null
        }
      ]
    },
    "oyente": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "Integer Overflow",
          "vulnerability_from_line": 282,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function loadUint8(bytes sig, uint idx) public pure returns (uint8) {\n",
          "message": null
        },
        {
          "name": "Integer Overflow",
          "vulnerability_from_line": 498,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function add_plasma2ethereum(address plasma_address, bytes sig) public {\n",
          "message": null
        }
      ]
    },
    "mythril": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "Integer Arithmetic Bugs (SWC 101)",
          "vulnerability_from_line": 182,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function params0(address c, bytes _method) public view returns (uint answer) {\n",
          "message": "The arithmetic operator can overflow.\nIt is possible to cause an integer overflow or underflow in the arithmetic operation. \nClassification: SWC-101"
        },
        {
          "name": "Integer Arithmetic Bugs (SWC 101)",
          "vulnerability_from_line": 210,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function params1(address c, bytes _method, uint _val) public view returns (uint answer) {\n",
          "message": "The arithmetic operator can overflow.\nIt is possible to cause an integer overflow or underflow in the arithmetic operation. \nClassification: SWC-101"
        },
        {
          "name": "Integer Arithmetic Bugs (SWC 101)",
          "vulnerability_from_line": 240,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function params2(address c, bytes _method, uint _val1, uint _val2) public view returns (uint answer) {\n",
          "message": "The arithmetic operator can overflow.\nIt is possible to cause an integer overflow or underflow in the arithmetic operation. \nClassification: SWC-101"
        },
        {
          "name": "Integer Arithmetic Bugs (SWC 101)",
          "vulnerability_from_line": 412,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function recoverSig(bytes sig, address old_key, address last_address) public pure returns (address[], address[], uint8[]) {\n",
          "message": "The arithmetic operator can overflow.\nIt is possible to cause an integer overflow or underflow in the arithmetic operation. \nClassification: SWC-101"
        },
        {
          "name": "External Call To User-Supplied Address (SWC 107)",
          "vulnerability_from_line": 192,
          "vulnerability_to_line": null,
          "vulnerability_code": "            let result := call(  // use WARNING because this should be staticcall BUT geth crash!\n",
          "message": "A call to a user-supplied address is executed.\nAn external message call to an address specified by the caller is executed. Note that the callee account might contain arbitrary code and could re-enter any function within this contract. Reentering the contract in an intermediate state may lead to unexpected behaviour. Make sure that no state modifications are executed after this call and/or reentrancy guards are in place.\nClassification: SWC-107"
        },
        {
          "name": "External Call To User-Supplied Address (SWC 107)",
          "vulnerability_from_line": 222,
          "vulnerability_to_line": null,
          "vulnerability_code": "            let result := call(  // use WARNING because this should be staticcall BUT geth crash!\n",
          "message": "A call to a user-supplied address is executed.\nAn external message call to an address specified by the caller is executed. Note that the callee account might contain arbitrary code and could re-enter any function within this contract. Reentering the contract in an intermediate state may lead to unexpected behaviour. Make sure that no state modifications are executed after this call and/or reentrancy guards are in place.\nClassification: SWC-107"
        },
        {
          "name": "External Call To User-Supplied Address (SWC 107)",
          "vulnerability_from_line": 253,
          "vulnerability_to_line": null,
          "vulnerability_code": "            let result := call(  // use WARNING because this should be staticcall BUT geth crash!\n",
          "message": "A call to a user-supplied address is executed.\nAn external message call to an address specified by the caller is executed. Note that the callee account might contain arbitrary code and could re-enter any function within this contract. Reentering the contract in an intermediate state may lead to unexpected behaviour. Make sure that no state modifications are executed after this call and/or reentrancy guards are in place.\nClassification: SWC-107"
        },
        {
          "name": "Unchecked return value from external call. (SWC 104)",
          "vulnerability_from_line": 253,
          "vulnerability_to_line": null,
          "vulnerability_code": "            let result := call(  // use WARNING because this should be staticcall BUT geth crash!\n",
          "message": "The return value of a message call is not checked.\nExternal calls return a boolean value. If the callee halts with an exception, 'false' is returned and execution continues in the caller. The caller should check whether an exception happened and react accordingly to avoid unexpected behavior. For example it is often desirable to wrap external calls in require() so the transaction is reverted if the call fails.\nClassification: SWC-104"
        },
        {
          "name": "Jump to an arbitrary instruction (SWC 127)",
          "vulnerability_from_line": 293,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function recoverHash(bytes32 hash, bytes sig, uint idx) public pure returns (address) {\n",
          "message": "The caller can redirect execution to arbitrary bytecode locations.\nIt is possible to redirect the control flow to arbitrary locations in the code. This may allow an attacker to bypass security controls or manipulate the business logic of the smart contract. Avoid using low-level-operations and assembly to prevent this issue.\nClassification: SWC-127"
        },
        {
          "name": "Exception State (SWC 110)",
          "vulnerability_from_line": 371,
          "vulnerability_to_line": null,
          "vulnerability_code": "        while (idx + 65 <= sig.length) {\n",
          "message": "An assertion violation was triggered.\nIt is possible to trigger an assertion violation. Note that Solidity assert() statements should only be used to check invariants. Review the transaction trace generated for this issue and either make sure your program logic is correct, or use require() instead of assert() if your goal is to constrain user inputs or enforce preconditions. Remember to validate inputs from both callers (for instance, via passed arguments) and callees (for instance, via return values).\nClassification: SWC-110"
        }
      ]
    },
    "osiris": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "Overflow bugs",
          "vulnerability_from_line": 298,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require (sig.length >= 65+idx, 'bad signature length');\n",
          "message": null
        },
        {
          "name": "Underflow bugs",
          "vulnerability_from_line": 333,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint n_influencers = (sig.length-21) / (65+msg_len);\n",
          "message": null
        }
      ]
    }
  }
}