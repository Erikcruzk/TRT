pragma solidity ^0.4.24;


contract IERC20 {
    function balanceOf(
        address whom
    )
    external
    view
    returns (uint);


    function transfer(
        address _to,
        uint256 _value
    )
    external
    returns (bool);


    function transferFrom(
        address _from,
        address _to,
        uint256 _value
    )
    external
    returns (bool);



    function approve(
        address _spender,
        uint256 _value
    )
    public
    returns (bool);



    function decimals()
    external
    view
    returns (uint);


    function symbol()
    external
    view
    returns (string);


    function name()
    external
    view
    returns (string);


    function freezeTransfers()
    external;


    function unfreezeTransfers()
    external;
}



pragma solidity ^0.4.24;


contract ITwoKeyReg {
    function addTwoKeyEventSource(address _twoKeyEventSource) public;
    function changeTwoKeyEventSource(address _twoKeyEventSource) public;
    function addWhereContractor(address _userAddress, address _contractAddress) public;
    function addWhereModerator(address _userAddress, address _contractAddress) public;
    function addWhereReferrer(address _userAddress, address _contractAddress) public;
    function addWhereConverter(address _userAddress, address _contractAddress) public;
    function getContractsWhereUserIsContractor(address _userAddress) public view returns (address[]);
    function getContractsWhereUserIsModerator(address _userAddress) public view returns (address[]);
    function getContractsWhereUserIsRefferer(address _userAddress) public view returns (address[]);
    function getContractsWhereUserIsConverter(address _userAddress) public view returns (address[]);
    function getTwoKeyEventSourceAddress() public view returns (address);
    function addName(string _name, address _sender, string _fullName, string _email, bytes signature) public;
    function addNameByUser(string _name) public;
    function getName2Owner(string _name) public view returns (address);
    function getOwner2Name(address _sender) public view returns (string);
    function getPlasmaToEthereum(address plasma) public view returns (address);
    function getEthereumToPlasma(address ethereum) public view returns (address);
    function checkIfTwoKeyMaintainerExists(address _maintainer) public view returns (bool);
    function getUserData(address _user) external view returns (bytes);
}



pragma solidity ^0.4.24;





interface ITwoKeySingletonesRegistry {

    



    event ProxyCreated(address proxy);


    




    event VersionAdded(string version, address implementation);

    




    function addVersion(string _contractName, string version, address implementation) public;

    





    function getVersion(string _contractName, string version) public view returns (address);
}



pragma solidity ^0.4.24;





function beginMigration() public onlyMaintainer {
    require(_implementation != address(0), "Implementation address is not set.");
    Upgradeable(_implementation).initialize(msg.sender);
}



pragma solidity ^0.4.24;

contract Upgradeable is UpgradeabilityStorage {
    



    function initialize(address sender) public payable {
        require(msg.sender == address(registry));
    }
}



pragma solidity ^0.4.24;




contract ITwoKeySingletoneRegistryFetchAddress {
    function getContractProxyAddress(string _contractName) public view returns (address);
    function getNonUpgradableContractAddress(string contractName) public view returns (address);
    function getLatestContractVersion(string contractName) public view returns (string);
}



pragma solidity ^0.4.24;

contract ITwoKeyMaintainersRegistry {
    function onlyMaintainer(address _sender) public view returns (bool);
}



pragma solidity ^0.4.24;


contract ITwoKeySingletonUtils {

    address public TWO_KEY_SINGLETON_REGISTRY;

    
    modifier onlyMaintainer {
        address twoKeyMaintainersRegistry = getAddressFromTwoKeySingletonRegistry("TwoKeyMaintainersRegistry");
        require(ITwoKeyMaintainersRegistry(twoKeyMaintainersRegistry).onlyMaintainer(msg.sender));
        _;
    }

    
    function getAddressFromTwoKeySingletonRegistry(string contractName) internal view returns (address) {
        return ITwoKeySingletoneRegistryFetchAddress(TWO_KEY_SINGLETON_REGISTRY)
        .getContractProxyAddress(contractName);
    }
}



pragma solidity ^0.4.0;

contract IStructuredStorage {

    function setProxyLogicContractAndDeployer(address _proxyLogicContract, address _deployer) external;
    function setProxyLogicContract(address _proxyLogicContract) external;

    
    function getUint(bytes32 _key) external view returns(uint);
    function getString(bytes32 _key) external view returns(string);
    function getAddress(bytes32 _key) external view returns(address);
    function getBytes(bytes32 _key) external view returns(bytes);
    function getBool(bytes32 _key) external view returns(bool);
    function getInt(bytes32 _key) external view returns(int);
    function getBytes32(bytes32 _key) external view returns(bytes32);

    
    function getBytes32Array(bytes32 _key) external view returns (bytes32[]);
    function getAddressArray(bytes32 _key) external view returns (address[]);
    function getUintArray(bytes32 _key) external view returns (uint[]);
    function getIntArray(bytes32 _key) external view returns (int[]);
    function getBoolArray(bytes32 _key) external view returns (bool[]);

    
    function setUint(bytes32 _key, uint _value) external;
    function setString(bytes32 _key, string _value) external;
    function setAddress(bytes32 _key, address _value) external;
    function setBytes(bytes32 _key, bytes _value) external;
    function setBool(bytes32 _key, bool _value) external;
    function setInt(bytes32 _key, int _value) external;
    function setBytes32(bytes32 _key, bytes32 _value) external;

    
    function setBytes32Array(bytes32 _key, bytes32[] _value) external;
    function setAddressArray(bytes32 _key, address[] _value) external;
    function setUintArray(bytes32 _key, uint[] _value) external;
    function setIntArray(bytes32 _key, int[] _value) external;
    function setBoolArray(bytes32 _key, bool[] _value) external;

    
    function deleteUint(bytes32 _key) external;
    function deleteString(bytes32 _key) external;
    function deleteAddress(bytes32 _key) external;
    function deleteBytes(bytes32 _key) external;
    function deleteBool(bytes32 _key) external;
    function deleteInt(bytes32 _key) external;
    function deleteBytes32(bytes32 _key) external;
}



pragma solidity ^0.4.24;

contract ITwoKeyAdminStorage is IStructuredStorage {

}



pragma solidity ^0.4.24;






contract TwoKeyAdmin is Upgradeable, ITwoKeySingletonUtils {

	bool initialized = false;

	ITwoKeyAdminStorage public PROXY_STORAGE_CONTRACT;
	address public twoKeyCongress;
	address twoKeyEconomy;


    
	modifier onlyTwoKeyCongress {
		require(msg.sender == twoKeyCongress);
	    _;
	}

    
    modifier onlyTwoKeyUpgradableExchange {
		address twoKeyUpgradableExchange = getAddressFromTwoKeySingletonRegistry("TwoKeyUpgradableExchange");
        require(msg.sender == address(twoKeyUpgradableExchange));
        _;
    }

    





    function setInitialParams(
		address _twoKeySingletonRegistry,
		address _proxyStorageContract,
        address _twoKeyCongress,
        address _economy,
		uint _twoKeyTokenReleaseDate
    ) external {
        require(initialized == false);

		TWO_KEY_SINGLETON_REGISTRY = _twoKeySingletonRegistry;
		PROXY_STORAGE_CONTRACT = ITwoKeyAdminStorage(_proxyStorageContract);
		twoKeyCongress = _twoKeyCongress;
		twoKeyEconomy = _economy;

		setUint("twoKeyIntegratorDefaultFeePercent",2);
		setUint("twoKeyNetworkTaxPercent",2);
		setUint("twoKeyTokenRate", 95);
		setUint("rewardReleaseAfter",_twoKeyTokenReleaseDate);

        initialized = true;
    }

    
    
    
    
	function transferByAdmins(
		address _to,
		uint256 _tokens
	)
	external
	onlyTwoKeyCongress
	{
		require (_to != address(0));
		IERC20(twoKeyEconomy).transfer(_to, _tokens);
	}

    
    
    
    
	function transferEtherByAdmins(
		address to,
		uint256 amount
	)
	external
	onlyTwoKeyCongress
	{
		require(to != address(0));
		to.transfer(amount);
	}

    
	function destroy()
	public
	onlyTwoKeyCongress
	{
        selfdestruct(twoKeyCongress);
	}

    
	
	
    function addNameToReg(
		string _name,
		address _addr,
		string fullName,
		string email,
		bytes signature
	) external {
		address twoKeyRegistry = getAddressFromTwoKeySingletonRegistry("TwoKeyRegistry");
    	ITwoKeyReg(twoKeyRegistry).addName(_name, _addr, fullName, email, signature);
    }


	
	function freezeTransfersInEconomy()
	external
	onlyTwoKeyCongress
	{
		IERC20(address(twoKeyEconomy)).freezeTransfers();
	}

	
	function unfreezeTransfersInEconomy()
	external
	onlyTwoKeyCongress
	{
		IERC20(address(twoKeyEconomy)).unfreezeTransfers();
	}

	
    function transfer2KeyTokens(
		address _to,
		uint256 _amount
	)
	public
	onlyTwoKeyCongress
	returns (bool)
	{
		bool completed = IERC20(twoKeyEconomy).transfer(_to, _amount);
		return completed;
	}

	
	function getUint(
		string key
	)
	internal
	view
	returns (uint)
	{
		return PROXY_STORAGE_CONTRACT.getUint(keccak256(key));
	}

	
	function setUint(
		string key,
		uint value
	)
	internal
	{
		PROXY_STORAGE_CONTRACT.setUint(keccak256(key), value);
	}

	function getTwoKeyRewardsReleaseDate()
	external
	view
	returns(uint)
	{
		return getUint("rewardReleaseAfter");
	}


	function getDefaultIntegratorFeePercent()
	public
	view
	returns (uint)
	{
		return getUint("twoKeyIntegratorDefaultFeePercent");
	}


	function getDefaultNetworkTaxPercent()
	public
	view
	returns (uint)
	{
		return getUint("twoKeyNetworkTaxPercent");
	}


	function getTwoKeyTokenRate()
	public
	view
	returns (uint)
	{
		return getUint("twoKeyTokenRate");
	}


	
	
	function()
	external
	payable
	{

	}


}