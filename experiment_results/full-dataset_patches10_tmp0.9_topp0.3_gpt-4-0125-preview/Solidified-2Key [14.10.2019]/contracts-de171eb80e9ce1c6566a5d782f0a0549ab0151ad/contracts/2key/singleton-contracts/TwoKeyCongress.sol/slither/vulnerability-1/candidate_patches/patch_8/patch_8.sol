pragma solidity ^0.4.24;






library SafeMath {

  


  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {
    
    
    
    if (_a == 0) {
      return 0;
    }

    c = _a * _b;
    require(c / _a == _b);
    return c;
  }

  


  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {
    
    
    
    return _a / _b;
  }

  


  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {
    require(_b <= _a);
    return _a - _b;
  }

  


  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {
    c = _a + _b;
    require(c >= _a);
    return c;
  }
}



pragma solidity ^0.4.24;

function vote(
    uint proposalNumber,
    bool supportsProposal,
    string justificationText)
public
onlyMembers
returns (uint256 voteID)
{
    Proposal storage p = proposals[proposalNumber]; 
    require(now <= p.minExecutionDate);
    require(!p.voted[msg.sender]);                  
    p.voted[msg.sender] = true;                     
    p.numberOfVotes++;
    voteID = p.numberOfVotes;                     
    p.votes.push(Vote({ inSupport: supportsProposal, voter: msg.sender, justification: justificationText }));
    uint votingPower = getMemberVotingPower(msg.sender);
    if (supportsProposal) {                         
        p.currentResult+= int(votingPower);                          
    } else {                                        
        p.currentResult-= int(votingPower);                          
    }
    
    emit Voted(proposalNumber,  supportsProposal, msg.sender, justificationText);
    return voteID;
}