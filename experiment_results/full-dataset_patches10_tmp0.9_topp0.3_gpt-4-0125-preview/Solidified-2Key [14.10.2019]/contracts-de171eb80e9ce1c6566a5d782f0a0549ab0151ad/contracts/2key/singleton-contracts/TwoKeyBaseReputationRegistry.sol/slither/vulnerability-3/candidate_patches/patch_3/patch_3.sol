pragma solidity ^0.4.24;





interface ITwoKeySingletonesRegistry {

    



    event ProxyCreated(address proxy);


    




    event VersionAdded(string version, address implementation);

    




    function addVersion(string _contractName, string version, address implementation) public;

    





    function getVersion(string _contractName, string version) public view returns (address);
}



pragma solidity ^0.4.24;





contract UpgradeabilityStorage {
    
    ITwoKeySingletonesRegistry internal registry;

    
    address internal _implementation;

    



    function implementation() public view returns (address) {
        return _implementation;
    }
}



pragma solidity ^0.4.24;

contract Upgradeable is UpgradeabilityStorage {
    



    function initialize(address sender) public payable {
        require(msg.sender == address(registry));
    }
}



pragma solidity ^0.4.24;


contract ITwoKeyReg {
    function addTwoKeyEventSource(address _twoKeyEventSource) public;
    function changeTwoKeyEventSource(address _twoKeyEventSource) public;
    function addWhereContractor(address _userAddress, address _contractAddress) public;
    function addWhereModerator(address _userAddress, address _contractAddress) public;
    function addWhereReferrer(address _userAddress, address _contractAddress) public;
    function addWhereConverter(address _userAddress, address _contractAddress) public;
    function getContractsWhereUserIsContractor(address _userAddress) public view returns (address[]);
    function getContractsWhereUserIsModerator(address _userAddress) public view returns (address[]);
    function getContractsWhereUserIsRefferer(address _userAddress) public view returns (address[]);
    function getContractsWhereUserIsConverter(address _userAddress) public view returns (address[]);
    function getTwoKeyEventSourceAddress() public view returns (address);
    function addName(string _name, address _sender, string _fullName, string _email, bytes signature) public;
    function addNameByUser(string _name) public;
    function getName2Owner(string _name) public view returns (address);
    function getOwner2Name(address _sender) public view returns (string);
    function getPlasmaToEthereum(address plasma) public view returns (address);
    function getEthereumToPlasma(address ethereum) public view returns (address);
    function checkIfTwoKeyMaintainerExists(address _maintainer) public view returns (bool);
    function getUserData(address _user) external view returns (bytes);
}



pragma solidity ^0.4.24;




contract ITwoKeyAcquisitionLogicHandler {
    function checkIsCampaignActive() public view returns (bool);
    bool public IS_CAMPAIGN_ACTIVE;
    function canConversionBeCreated(address converter, uint amountWillingToSpend, bool isFiat) public view returns (bool);
    function getEstimatedTokenAmount(uint conversionAmountETHWei, bool isFiatConversion) public view returns (uint, uint);

    function setTwoKeyAcquisitionCampaignContract(
        address _acquisitionCampaignAddress,
        address twoKeySingletoneRegistry,
        address _twoKeyConversionHandler) public;

    function getReferrers(address customer, address acquisitionCampaignContract) public view returns (address[]);
    function updateRefchainRewards(uint256 _maxReferralRewardETHWei, address _converter, uint _conversionId, uint totalBounty2keys) public;
    function getReferrerPlasmaTotalEarnings(address _referrer) public view returns (uint);
}



pragma solidity ^0.4.24;




contract ITwoKeyCampaignPublicAddresses {
    address public twoKeySingletonesRegistry;
    address public contractor; 
    address public moderator; 
    function publicLinkKeyOf(address me) public view returns (address);
}



pragma solidity ^0.4.24;





contract ITwoKeyAcquisitionCampaignStateVariables is ITwoKeyCampaignPublicAddresses {
    address public twoKeyAcquisitionLogicHandler;
    address public conversionHandler;

    function getInventoryBalance() public view returns (uint);
}



pragma solidity ^0.4.24;




contract ITwoKeySingletoneRegistryFetchAddress {
    function getContractProxyAddress(string _contractName) public view returns (address);
    function getNonUpgradableContractAddress(string contractName) public view returns (address);
    function getLatestContractVersion(string contractName) public view returns (string);
}



pragma solidity ^0.4.24;




contract ITwoKeyCampaignValidator {
    function isCampaignValidated(address campaign) public view returns (bool);
    function isConversionHandlerCodeValid(address conversionHandler) public view returns (bool);
    function validateAcquisitionCampaign(address campaign, string nonSingletonHash) public;
    function validateDonationCampaign(address campaign, address donationConversionHandler, string nonSingletonHash) public;
}



pragma solidity ^0.4.24;






library SafeMath {

  


  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {
    
    
    
    if (_a == 0) {
      return 0;
    }

    c = _a * _b;
    require(c / _a == _b);
    return c;
  }

  


  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {
    
    
    
    return _a / _b;
  }

  


  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {
    require(_b <= _a);
    return _a - _b;
  }

  


  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {
    c = _a + _b;
    require(c >= _a);
    return c;
  }
}



pragma solidity ^0.4.24;

contract ITwoKeyMaintainersRegistry {
    function onlyMaintainer(address _sender) public view returns (bool);
}



pragma solidity ^0.4.24;


contract ITwoKeySingletonUtils {

    address public TWO_KEY_SINGLETON_REGISTRY;

    
    modifier onlyMaintainer {
        address twoKeyMaintainersRegistry = getAddressFromTwoKeySingletonRegistry("TwoKeyMaintainersRegistry");
        require(ITwoKeyMaintainersRegistry(twoKeyMaintainersRegistry).onlyMaintainer(msg.sender));
        _;
    }

    
    function getAddressFromTwoKeySingletonRegistry(string contractName) internal view returns (address) {
        return ITwoKeySingletoneRegistryFetchAddress(TWO_KEY_SINGLETON_REGISTRY)
        .getContractProxyAddress(contractName);
    }
}



pragma solidity ^0.4.0;

contract IStructuredStorage {

    function setProxyLogicContractAndDeployer(address _proxyLogicContract, address _deployer) external;
    function setProxyLogicContract(address _proxyLogicContract) external;

    
    function getUint(bytes32 _key) external view returns(uint);
    function getString(bytes32 _key) external view returns(string);
    function getAddress(bytes32 _key) external view returns(address);
    function getBytes(bytes32 _key) external view returns(bytes);
    function getBool(bytes32 _key) external view returns(bool);
    function getInt(bytes32 _key) external view returns(int);
    function getBytes32(bytes32 _key) external view returns(bytes32);

    
    function getBytes32Array(bytes32 _key) external view returns (bytes32[]);
    function getAddressArray(bytes32 _key) external view returns (address[]);
    function getUintArray(bytes32 _key) external view returns (uint[]);
    function getIntArray(bytes32 _key) external view returns (int[]);
    function getBoolArray(bytes32 _key) external view returns (bool[]);

    
    function setUint(bytes32 _key, uint _value) external;
    function setString(bytes32 _key, string _value) external;
    function setAddress(bytes32 _key, address _value) external;
    function setBytes(bytes32 _key, bytes _value) external;
    function setBool(bytes32 _key, bool _value) external;
    function setInt(bytes32 _key, int _value) external;
    function setBytes32(bytes32 _key, bytes32 _value) external;

    
    function setBytes32Array(bytes32 _key, bytes32[] _value) external;
    function setAddressArray(bytes32 _key, address[] _value) external;
    function setUintArray(bytes32 _key, uint[] _value) external;
    function setIntArray(bytes32 _key, int[] _value) external;
    function setBoolArray(bytes32 _key, bool[] _value) external;

    
    function deleteUint(bytes32 _key) external;
    function deleteString(bytes32 _key) external;
    function deleteAddress(bytes32 _key) external;
    function deleteBytes(bytes32 _key) external;
    function deleteBool(bytes32 _key) external;
    function deleteInt(bytes32 _key) external;
    function deleteBytes32(bytes32 _key) external;
}



pragma solidity ^0.4.24;

contract ITwoKeyBaseReputationRegistryStorage is IStructuredStorage {

}



pragma solidity ^0.4.24;












function updateOnConversionExecutedEvent(
    address converter,
    address contractor,
    address acquisitionCampaign
)
public
{
    validateCall(acquisitionCampaign);
    int d = 1;
    int initialRewardWei = 10*(10**18);

    address logicHandlerAddress = getLogicHandlerAddress(acquisitionCampaign);

    bytes32 keyHashContractorScore = keccak256("address2contractorGlobalReputationScoreWei", contractor);
    int contractorScore = PROXY_STORAGE_CONTRACT.getInt(keyHashContractorScore);
    PROXY_STORAGE_CONTRACT.setInt(keyHashContractorScore, contractorScore + initialRewardWei);

    bytes32 keyHashConverterScore = keccak256("address2converterGlobalReputationScoreWei", converter);
    int converterScore = PROXY_STORAGE_CONTRACT.getInt(keyHashConverterScore);
    PROXY_STORAGE_CONTRACT.setInt(keyHashConverterScore, converterScore + initialRewardWei);

    address[] memory referrers = ITwoKeyAcquisitionLogicHandler(logicHandlerAddress).getReferrers(converter, acquisitionCampaign);

    int referrerScoreIncrement = initialRewardWei;
    for(uint i = 0; i < referrers.length; i++) {
        referrerScoreIncrement = referrerScoreIncrement / 2; // Safe division, reducing reward by half each iteration
        bytes32 keyHashReferrerScore = keccak256("plasmaAddress2referrerGlobalReputationScoreWei", referrers[i]);
        int referrerScore = PROXY_STORAGE_CONTRACT.getInt(keyHashReferrerScore);
        PROXY_STORAGE_CONTRACT.setInt(keyHashReferrerScore, referrerScore + referrerScoreIncrement);
    }
}