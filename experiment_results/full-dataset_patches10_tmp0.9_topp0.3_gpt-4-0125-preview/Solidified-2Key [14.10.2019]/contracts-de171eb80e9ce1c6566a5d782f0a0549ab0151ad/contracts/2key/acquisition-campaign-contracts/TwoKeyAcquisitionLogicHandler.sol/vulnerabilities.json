{
  "smartbugs_completed": true,
  "analyzer_results": {
    "semgrep": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 478,
          "vulnerability_to_line": null,
          "vulnerability_code": "        while (idx + 65 <= sig.length) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 482,
          "vulnerability_to_line": null,
          "vulnerability_code": "            if (idx + msg_len <= sig.length) {  // its  a < and not a <= because we dont want this to be the final iteration for the converter\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 533,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(uint i = 0; i < influencers.length; i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 534,
          "vulnerability_to_line": null,
          "vulnerability_code": "            if (i < weights.length) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 1294,
          "vulnerability_to_line": null,
          "vulnerability_code": "                if (i == influencers.length - 1) {  // if its the last influencer then all the bounty goes to it.\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 1302,
          "vulnerability_to_line": null,
          "vulnerability_code": "                        b = totalBounty2keys.div(influencers.length - i);\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 1216,
          "vulnerability_to_line": null,
          "vulnerability_code": "            if (influencer == plasmaOf(contractor)) {\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 1298,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    uint256 cut = ITwoKeyAcquisitionCampaignERC20(twoKeyAcquisitionCampaign).getReferrerCut(influencers[i]);\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 1357,
          "vulnerability_to_line": null,
          "vulnerability_code": "            referrersPendingPlasmaBalance[i] = ITwoKeyAcquisitionCampaignERC20(twoKeyAcquisitionCampaign).getReferrerPlasmaBalance(_referrerPlasmaList[i]);\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 1358,
          "vulnerability_to_line": null,
          "vulnerability_code": "            referrersTotalEarningsPlasmaBalance[i] = referrerPlasma2TotalEarnings2key[_referrerPlasmaList[i]];\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 1395,
          "vulnerability_to_line": null,
          "vulnerability_code": "            earnings[i] = referrerPlasma2EarningsPerConversion[_referrer][conversionIds[i]];\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 533,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(uint i = 0; i < influencers.length; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 605,
          "vulnerability_to_line": null,
          "vulnerability_code": "            for(uint i=0; i<numberOfInfluencers;i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 626,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(uint i=1; i<numberOfElements; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 1356,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i=0; i<numberOfAddresses; i++){\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 1394,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(uint i=0; i<len; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 405,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require (sig.length >= 65+idx, 'bad signature length');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 432,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(v==27 || v==28,'bad sig v');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 484,
          "vulnerability_to_line": null,
          "vulnerability_code": "                require(weights[count_influencers] > 0,'weight not defined (1..255)');  // 255 are used to indicate default (equal part) behaviour\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 514,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(idx == sig.length,'illegal message size');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 524,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(old_key != address(0),'no public link key');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 535,
          "vulnerability_to_line": null,
          "vulnerability_code": "                require (recoverHash(keccak256(abi.encodePacked(weights[i], keys[i], influencers[i])),sig,offsets[i]) == old_key, 'illegal signature');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 539,
          "vulnerability_to_line": null,
          "vulnerability_code": "                require (recoverHash(keccak256(abi.encodePacked(influencers[i])),sig,offsets[i]) == old_key, 'illegal last signature');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 807,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(values[1] >= values[0], \"max contribution criteria not satisfied\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 808,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(values[4] > values[3], \"campaign start time can't be greater than end time\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 947,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if(block.timestamp >= campaignStartTime && block.timestamp <= campaignEndTime) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 948,
          "vulnerability_to_line": null,
          "vulnerability_code": "            return true;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 949,
          "vulnerability_to_line": null,
          "vulnerability_code": "        }\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 1299,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    if (cut > 0 && cut <= 101) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 1300,
          "vulnerability_to_line": null,
          "vulnerability_code": "                        b = totalBounty2keys.mul(cut.sub(1)).div(100);\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 1301,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    } else {// cut == 0 or 255 indicates equal particine of the bounty\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 1302,
          "vulnerability_to_line": null,
          "vulnerability_code": "                        b = totalBounty2keys.div(influencers.length - i);\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 1303,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    }\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-prefix-decrement-not-postfix",
          "vulnerability_from_line": 1227,
          "vulnerability_to_line": null,
          "vulnerability_code": "            n_influencers--;\n",
          "message": "Consider using the prefix decrement expression whenever the return value is not needed. The prefix decrement expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 444,
          "vulnerability_to_line": null,
          "vulnerability_code": "            n_influencers++;\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 485,
          "vulnerability_to_line": null,
          "vulnerability_code": "                idx++;\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 512,
          "vulnerability_to_line": null,
          "vulnerability_code": "            count_influencers++;\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 533,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(uint i = 0; i < influencers.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 605,
          "vulnerability_to_line": null,
          "vulnerability_code": "            for(uint i=0; i<numberOfInfluencers;i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 626,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(uint i=1; i<numberOfElements; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 1219,
          "vulnerability_to_line": null,
          "vulnerability_code": "            n_influencers++;\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 1267,
          "vulnerability_to_line": null,
          "vulnerability_code": "            for(i=0; i<numberOfInfluencers; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 1277,
          "vulnerability_to_line": null,
          "vulnerability_code": "            for(i=0; i<numberOfInfluencers - 1; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 1287,
          "vulnerability_to_line": null,
          "vulnerability_code": "            for(i=0; i<numberOfInfluencers; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 1291,
          "vulnerability_to_line": null,
          "vulnerability_code": "            for (i = 0; i < numberOfInfluencers; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 1356,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i=0; i<numberOfAddresses; i++){\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 1394,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(uint i=0; i<len; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 807,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(values[1] >= values[0], \"max contribution criteria not satisfied\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 808,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(values[4] > values[3], \"campaign start time can't be greater than end time\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        }
      ]
    },
    "slither": {
      "successfull_analysis": true,
      "errors": [
        "DOCKER_RECEIVED_SIGNAL_6"
      ],
      "vulnerability_findings": [
        {
          "name": "uninitialized-state",
          "vulnerability_from_line": 700,
          "vulnerability_to_line": null,
          "vulnerability_code": "    address internal _implementation;\n",
          "message": "UpgradeabilityCampaignStorage._implementation (TwoKeyAcquisitionLogicHandler.sol#700) is never initialized. It is used in:\n\t- implementation (TwoKeyAcquisitionLogicHandler.sol#706-708)\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 289,
          "vulnerability_to_line": 315,
          "vulnerability_code": "    function params0(address c, bytes _method) public view returns (uint answer) {\n\n        // https://medium.com/@blockchain101/calling-the-function-of-another-contract-in-solidity-f9edfa921f4c\n\n        //    dc = c;\n\n        bytes4 sig = bytes4(keccak256(_method));\n\n        assembly {\n\n        // move pointer to free memory spot\n\n            let ptr := mload(0x40)\n\n        // put function sig at memory spot\n\n            mstore(ptr,sig)\n\n\n\n            let result := call(  // use WARNING because this should be staticcall BUT geth crash!\n\n            15000, // gas limit\n\n            c, // sload(dc_slot),  // to addr. append var to _slot to access storage variable\n\n            0, // not transfer any ether (comment if using staticcall)\n\n            ptr, // Inputs are stored at location ptr\n\n            0x04, // Inputs are 0 bytes long\n\n            ptr,  //Store output over input\n\n            0x20) //Outputs are 1 bytes long\n\n\n\n            if eq(result, 0) {\n\n                revert(0, 0)\n\n            }\n\n\n\n            answer := mload(ptr) // Assign output to answer var\n\n            mstore(0x40,add(ptr,0x24)) // Set storage pointer to new space\n\n        }\n",
          "message": "Call.params0 (TwoKeyAcquisitionLogicHandler.sol#289-315) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 317,
          "vulnerability_to_line": 345,
          "vulnerability_code": "    function params1(address c, bytes _method, uint _val) public view returns (uint answer) {\n\n        // https://medium.com/@blockchain101/calling-the-function-of-another-contract-in-solidity-f9edfa921f4c\n\n        //    dc = c;\n\n        bytes4 sig = bytes4(keccak256(_method));\n\n        assembly {\n\n        // move pointer to free memory spot\n\n            let ptr := mload(0x40)\n\n        // put function sig at memory spot\n\n            mstore(ptr,sig)\n\n        // append argument after function sig\n\n            mstore(add(ptr,0x04), _val)\n\n\n\n            let result := call(  // use WARNING because this should be staticcall BUT geth crash!\n\n            15000, // gas limit\n\n            c, // sload(dc_slot),  // to addr. append var to _slot to access storage variable\n\n            0, // not transfer any ether (comment if using staticcall)\n\n            ptr, // Inputs are stored at location ptr\n\n            0x24, // Inputs are 0 bytes long\n\n            ptr,  //Store output over input\n\n            0x20) //Outputs are 1 bytes long\n\n\n\n            if eq(result, 0) {\n\n                revert(0, 0)\n\n            }\n\n\n\n            answer := mload(ptr) // Assign output to answer var\n\n            mstore(0x40,add(ptr,0x24)) // Set storage pointer to new space\n\n        }\n",
          "message": "Call.params1 (TwoKeyAcquisitionLogicHandler.sol#317-345) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 347,
          "vulnerability_to_line": 377,
          "vulnerability_code": "    function params2(address c, bytes _method, uint _val1, uint _val2) public view returns (uint answer) {\n\n        // https://medium.com/@blockchain101/calling-the-function-of-another-contract-in-solidity-f9edfa921f4c\n\n        //    dc = c;\n\n        bytes4 sig = bytes4(keccak256(_method));\n\n        assembly {\n\n        // move pointer to free memory spot\n\n            let ptr := mload(0x40)\n\n        // put function sig at memory spot\n\n            mstore(ptr,sig)\n\n        // append argument after function sig\n\n            mstore(add(ptr,0x04), _val1)\n\n            mstore(add(ptr,0x24), _val2)\n\n\n\n            let result := call(  // use WARNING because this should be staticcall BUT geth crash!\n\n            15000, // gas limit\n\n            c, // sload(dc_slot),  // to addr. append var to _slot to access storage variable\n\n            0, // not transfer any ether (comment if using staticcall)\n\n            ptr, // Inputs are stored at location ptr\n\n            0x44, // Inputs are 4 bytes for signature and 2 uint256\n\n            ptr,  //Store output over input\n\n            0x20) //Outputs are 1 uint long\n\n\n\n        // TODO cause revert\n\n        //            if eq(result, 0) {\n\n        //                revert(0, 0)\n\n        //            }\n\n\n\n            answer := mload(ptr) // Assign output to answer var\n\n            mstore(0x40,add(ptr,0x20)) // Set storage pointer to new space\n\n        }\n",
          "message": "Call.params2 (TwoKeyAcquisitionLogicHandler.sol#347-377) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 379,
          "vulnerability_to_line": 387,
          "vulnerability_code": "    function loadAddress(bytes sig, uint idx) public pure returns (address) {\n\n        address influencer;\n\n        idx += 20;\n\n        assembly\n\n        {\n\n            influencer := mload(add(sig, idx))\n\n        }\n\n        return influencer;\n",
          "message": "Call.loadAddress (TwoKeyAcquisitionLogicHandler.sol#379-387) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 389,
          "vulnerability_to_line": 397,
          "vulnerability_code": "    function loadUint8(bytes sig, uint idx) public pure returns (uint8) {\n\n        uint8 weight;\n\n        idx += 1;\n\n        assembly\n\n        {\n\n            weight := mload(add(sig, idx))\n\n        }\n\n        return weight;\n",
          "message": "Call.loadUint8 (TwoKeyAcquisitionLogicHandler.sol#389-397) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 400,
          "vulnerability_to_line": 435,
          "vulnerability_code": "    function recoverHash(bytes32 hash, bytes sig, uint idx) public pure returns (address) {\n\n        // same as recoverHash in utils/sign.js\n\n        // The signature format is a compact form of:\n\n        //   {bytes32 r}{bytes32 s}{uint8 v}\n\n        // Compact means, uint8 is not padded to 32 bytes.\n\n        require (sig.length >= 65+idx, 'bad signature length');\n\n        idx += 32;\n\n        bytes32 r;\n\n        assembly\n\n        {\n\n            r := mload(add(sig, idx))\n\n        }\n\n\n\n        idx += 32;\n\n        bytes32 s;\n\n        assembly\n\n        {\n\n            s := mload(add(sig, idx))\n\n        }\n\n\n\n        idx += 1;\n\n        uint8 v;\n\n        assembly\n\n        {\n\n            v := mload(add(sig, idx))\n\n        }\n\n        if (v >= 32) { // handle case when signature was made with ethereum web3.eth.sign or getSign which is for signing ethereum transactions\n\n            v -= 32;\n\n            bytes memory prefix = \"\\x19Ethereum Signed Message:\\n32\"; // 32 is the number of bytes in the following hash\n\n            hash = keccak256(abi.encodePacked(prefix, hash));\n\n        }\n\n        if (v <= 1) v += 27;\n\n        require(v==27 || v==28,'bad sig v');\n\n        return ecrecover(hash, v, r, s);\n\n\n",
          "message": "Call.recoverHash (TwoKeyAcquisitionLogicHandler.sol#400-435) is declared view but contains assembly code\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 851,
          "vulnerability_to_line": 857,
          "vulnerability_code": "    function activateCampaign() public onlyContractor {\n\n        require(IS_CAMPAIGN_ACTIVE == false);\n\n        uint balanceOfTokenBeingSoldOnAcquisition = getInventoryBalance();\n\n        //balance is in weis, price is in weis and hardcap is regular number\n\n        require((balanceOfTokenBeingSoldOnAcquisition * pricePerUnitInETHWeiOrUSD).div(10**18) >= campaignHardCapWei);\n\n        IS_CAMPAIGN_ACTIVE = true;\n",
          "message": "Reentrancy in TwoKeyAcquisitionLogicHandler.activateCampaign (TwoKeyAcquisitionLogicHandler.sol#851-857):\n\tExternal calls:\n\t- balanceOfTokenBeingSoldOnAcquisition = getInventoryBalance() (TwoKeyAcquisitionLogicHandler.sol#853)\n\tState variables written after the call(s):\n\t- IS_CAMPAIGN_ACTIVE (TwoKeyAcquisitionLogicHandler.sol#856)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 795,
          "vulnerability_to_line": 846,
          "vulnerability_code": "    function setInitialParamsLogicHandler(\n\n        uint [] values,\n\n        string _currency,\n\n        address _assetContractERC20,\n\n        address _moderator,\n\n        address _contractor,\n\n        address _acquisitionCampaignAddress,\n\n        address _twoKeySingletoneRegistry,\n\n        address _twoKeyConversionHandler\n\n    )\n\n    public\n\n    {\n\n        require(values[1] >= values[0], \"max contribution criteria not satisfied\");\n\n        require(values[4] > values[3], \"campaign start time can't be greater than end time\");\n\n        require(isCampaignInitialized == false);\n\n\n\n        if(values[0] == values[1]) {\n\n            isFixedInvestmentAmount = true;\n\n        }\n\n\n\n        minContributionETHorFiatCurrency = values[0];\n\n        maxContributionETHorFiatCurrency = values[1];\n\n        pricePerUnitInETHWeiOrUSD = values[2];\n\n        campaignStartTime = values[3];\n\n        campaignEndTime = values[4];\n\n        maxConverterBonusPercent = values[5];\n\n\n\n        //Add as 6th argument incentive model uint\n\n        incentiveModel = IncentiveModel(values[6]);\n\n        if(values[7] == 1) {\n\n            isAcceptingFiatOnly = true;\n\n        }\n\n\n\n        campaignHardCapWei = values[8];\n\n\n\n        currency = _currency;\n\n        assetContractERC20 = _assetContractERC20;\n\n        moderator = _moderator;\n\n        contractor = _contractor;\n\n        unit_decimals = IERC20(_assetContractERC20).decimals();\n\n\n\n        twoKeyAcquisitionCampaign = _acquisitionCampaignAddress;\n\n        twoKeySingletoneRegistry = _twoKeySingletoneRegistry;\n\n\n\n        twoKeyRegistry = ITwoKeySingletoneRegistryFetchAddress(twoKeySingletoneRegistry).getContractProxyAddress(\"TwoKeyRegistry\");\n\n        twoKeyMaintainersRegistry = ITwoKeySingletoneRegistryFetchAddress(twoKeySingletoneRegistry).getContractProxyAddress(\"TwoKeyMaintainersRegistry\");\n\n\n\n        ownerPlasma = plasmaOf(contractor);\n\n        twoKeyConversionHandler = _twoKeyConversionHandler;\n\n\n\n        isCampaignInitialized = true;\n",
          "message": "Reentrancy in TwoKeyAcquisitionLogicHandler.setInitialParamsLogicHandler (TwoKeyAcquisitionLogicHandler.sol#795-846):\n\tExternal calls:\n\t- unit_decimals = IERC20(_assetContractERC20).decimals() (TwoKeyAcquisitionLogicHandler.sol#834)\n\t- twoKeyRegistry = ITwoKeySingletoneRegistryFetchAddress(twoKeySingletoneRegistry).getContractProxyAddress(TwoKeyRegistry) (TwoKeyAcquisitionLogicHandler.sol#839)\n\t- twoKeyMaintainersRegistry = ITwoKeySingletoneRegistryFetchAddress(twoKeySingletoneRegistry).getContractProxyAddress(TwoKeyMaintainersRegistry) (TwoKeyAcquisitionLogicHandler.sol#840)\n\t- ownerPlasma = plasmaOf(contractor) (TwoKeyAcquisitionLogicHandler.sol#842)\n\tState variables written after the call(s):\n\t- isCampaignInitialized (TwoKeyAcquisitionLogicHandler.sol#845)\n"
        },
        {
          "name": "uninitialized-local",
          "vulnerability_from_line": 1104,
          "vulnerability_to_line": null,
          "vulnerability_code": "        bytes32 state; // NOT-EXISTING AS CONVERTER DEFAULT STATE\n",
          "message": "state in TwoKeyAcquisitionLogicHandler.getAddressStatistic (TwoKeyAcquisitionLogicHandler.sol#1104) is a local variable never initialiazed\n"
        },
        {
          "name": "uninitialized-local",
          "vulnerability_from_line": 1181,
          "vulnerability_to_line": null,
          "vulnerability_code": "        bool flag;\n",
          "message": "flag in TwoKeyAcquisitionLogicHandler.getSuperStatistics (TwoKeyAcquisitionLogicHandler.sol#1181) is a local variable never initialiazed\n"
        },
        {
          "name": "uninitialized-local",
          "vulnerability_from_line": 1183,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address _address;\n",
          "message": "_address in TwoKeyAcquisitionLogicHandler.getSuperStatistics (TwoKeyAcquisitionLogicHandler.sol#1183) is a local variable never initialiazed\n"
        },
        {
          "name": "uninitialized-local",
          "vulnerability_from_line": 1112,
          "vulnerability_to_line": null,
          "vulnerability_code": "            bool isConverter;\n",
          "message": "isConverter in TwoKeyAcquisitionLogicHandler.getAddressStatistic (TwoKeyAcquisitionLogicHandler.sol#1112) is a local variable never initialiazed\n"
        },
        {
          "name": "uninitialized-local",
          "vulnerability_from_line": 1113,
          "vulnerability_to_line": null,
          "vulnerability_code": "            bool isReferrer;\n",
          "message": "isReferrer in TwoKeyAcquisitionLogicHandler.getAddressStatistic (TwoKeyAcquisitionLogicHandler.sol#1113) is a local variable never initialiazed\n"
        },
        {
          "name": "calls-loop",
          "vulnerability_from_line": 1215,
          "vulnerability_to_line": null,
          "vulnerability_code": "            influencer = plasmaOf(ITwoKeyAcquisitionARC(acquisitionCampaignContract).getReceivedFrom(influencer));\n",
          "message": "TwoKeyAcquisitionLogicHandler.getReferrers has external calls inside a loop:\n\t- influencer = plasmaOf(ITwoKeyAcquisitionARC(acquisitionCampaignContract).getReceivedFrom(influencer)) (TwoKeyAcquisitionLogicHandler.sol#1215)\n"
        },
        {
          "name": "calls-loop",
          "vulnerability_from_line": 1226,
          "vulnerability_to_line": null,
          "vulnerability_code": "            influencer = plasmaOf(ITwoKeyAcquisitionARC(acquisitionCampaignContract).getReceivedFrom(influencer));\n",
          "message": "TwoKeyAcquisitionLogicHandler.getReferrers has external calls inside a loop:\n\t- influencer = plasmaOf(ITwoKeyAcquisitionARC(acquisitionCampaignContract).getReceivedFrom(influencer)) (TwoKeyAcquisitionLogicHandler.sol#1226)\n"
        },
        {
          "name": "calls-loop",
          "vulnerability_from_line": 1298,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    uint256 cut = ITwoKeyAcquisitionCampaignERC20(twoKeyAcquisitionCampaign).getReferrerCut(influencers[i]);\n",
          "message": "TwoKeyAcquisitionLogicHandler.updateRefchainRewards has external calls inside a loop:\n\t- cut = ITwoKeyAcquisitionCampaignERC20(twoKeyAcquisitionCampaign).getReferrerCut(influencers[i]) (TwoKeyAcquisitionLogicHandler.sol#1298)\n"
        },
        {
          "name": "calls-loop",
          "vulnerability_from_line": 1357,
          "vulnerability_to_line": null,
          "vulnerability_code": "            referrersPendingPlasmaBalance[i] = ITwoKeyAcquisitionCampaignERC20(twoKeyAcquisitionCampaign).getReferrerPlasmaBalance(_referrerPlasmaList[i]);\n",
          "message": "TwoKeyAcquisitionLogicHandler.getReferrersBalancesAndTotalEarnings has external calls inside a loop:\n\t- referrersPendingPlasmaBalance[i] = ITwoKeyAcquisitionCampaignERC20(twoKeyAcquisitionCampaign).getReferrerPlasmaBalance(_referrerPlasmaList[i]) (TwoKeyAcquisitionLogicHandler.sol#1357)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 795,
          "vulnerability_to_line": 846,
          "vulnerability_code": "    function setInitialParamsLogicHandler(\n\n        uint [] values,\n\n        string _currency,\n\n        address _assetContractERC20,\n\n        address _moderator,\n\n        address _contractor,\n\n        address _acquisitionCampaignAddress,\n\n        address _twoKeySingletoneRegistry,\n\n        address _twoKeyConversionHandler\n\n    )\n\n    public\n\n    {\n\n        require(values[1] >= values[0], \"max contribution criteria not satisfied\");\n\n        require(values[4] > values[3], \"campaign start time can't be greater than end time\");\n\n        require(isCampaignInitialized == false);\n\n\n\n        if(values[0] == values[1]) {\n\n            isFixedInvestmentAmount = true;\n\n        }\n\n\n\n        minContributionETHorFiatCurrency = values[0];\n\n        maxContributionETHorFiatCurrency = values[1];\n\n        pricePerUnitInETHWeiOrUSD = values[2];\n\n        campaignStartTime = values[3];\n\n        campaignEndTime = values[4];\n\n        maxConverterBonusPercent = values[5];\n\n\n\n        //Add as 6th argument incentive model uint\n\n        incentiveModel = IncentiveModel(values[6]);\n\n        if(values[7] == 1) {\n\n            isAcceptingFiatOnly = true;\n\n        }\n\n\n\n        campaignHardCapWei = values[8];\n\n\n\n        currency = _currency;\n\n        assetContractERC20 = _assetContractERC20;\n\n        moderator = _moderator;\n\n        contractor = _contractor;\n\n        unit_decimals = IERC20(_assetContractERC20).decimals();\n\n\n\n        twoKeyAcquisitionCampaign = _acquisitionCampaignAddress;\n\n        twoKeySingletoneRegistry = _twoKeySingletoneRegistry;\n\n\n\n        twoKeyRegistry = ITwoKeySingletoneRegistryFetchAddress(twoKeySingletoneRegistry).getContractProxyAddress(\"TwoKeyRegistry\");\n\n        twoKeyMaintainersRegistry = ITwoKeySingletoneRegistryFetchAddress(twoKeySingletoneRegistry).getContractProxyAddress(\"TwoKeyMaintainersRegistry\");\n\n\n\n        ownerPlasma = plasmaOf(contractor);\n\n        twoKeyConversionHandler = _twoKeyConversionHandler;\n\n\n\n        isCampaignInitialized = true;\n",
          "message": "Reentrancy in TwoKeyAcquisitionLogicHandler.setInitialParamsLogicHandler (TwoKeyAcquisitionLogicHandler.sol#795-846):\n\tExternal calls:\n\t- unit_decimals = IERC20(_assetContractERC20).decimals() (TwoKeyAcquisitionLogicHandler.sol#834)\n\tState variables written after the call(s):\n\t- twoKeyAcquisitionCampaign (TwoKeyAcquisitionLogicHandler.sol#836)\n\t- twoKeySingletoneRegistry (TwoKeyAcquisitionLogicHandler.sol#837)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 795,
          "vulnerability_to_line": 846,
          "vulnerability_code": "    function setInitialParamsLogicHandler(\n\n        uint [] values,\n\n        string _currency,\n\n        address _assetContractERC20,\n\n        address _moderator,\n\n        address _contractor,\n\n        address _acquisitionCampaignAddress,\n\n        address _twoKeySingletoneRegistry,\n\n        address _twoKeyConversionHandler\n\n    )\n\n    public\n\n    {\n\n        require(values[1] >= values[0], \"max contribution criteria not satisfied\");\n\n        require(values[4] > values[3], \"campaign start time can't be greater than end time\");\n\n        require(isCampaignInitialized == false);\n\n\n\n        if(values[0] == values[1]) {\n\n            isFixedInvestmentAmount = true;\n\n        }\n\n\n\n        minContributionETHorFiatCurrency = values[0];\n\n        maxContributionETHorFiatCurrency = values[1];\n\n        pricePerUnitInETHWeiOrUSD = values[2];\n\n        campaignStartTime = values[3];\n\n        campaignEndTime = values[4];\n\n        maxConverterBonusPercent = values[5];\n\n\n\n        //Add as 6th argument incentive model uint\n\n        incentiveModel = IncentiveModel(values[6]);\n\n        if(values[7] == 1) {\n\n            isAcceptingFiatOnly = true;\n\n        }\n\n\n\n        campaignHardCapWei = values[8];\n\n\n\n        currency = _currency;\n\n        assetContractERC20 = _assetContractERC20;\n\n        moderator = _moderator;\n\n        contractor = _contractor;\n\n        unit_decimals = IERC20(_assetContractERC20).decimals();\n\n\n\n        twoKeyAcquisitionCampaign = _acquisitionCampaignAddress;\n\n        twoKeySingletoneRegistry = _twoKeySingletoneRegistry;\n\n\n\n        twoKeyRegistry = ITwoKeySingletoneRegistryFetchAddress(twoKeySingletoneRegistry).getContractProxyAddress(\"TwoKeyRegistry\");\n\n        twoKeyMaintainersRegistry = ITwoKeySingletoneRegistryFetchAddress(twoKeySingletoneRegistry).getContractProxyAddress(\"TwoKeyMaintainersRegistry\");\n\n\n\n        ownerPlasma = plasmaOf(contractor);\n\n        twoKeyConversionHandler = _twoKeyConversionHandler;\n\n\n\n        isCampaignInitialized = true;\n",
          "message": "Reentrancy in TwoKeyAcquisitionLogicHandler.setInitialParamsLogicHandler (TwoKeyAcquisitionLogicHandler.sol#795-846):\n\tExternal calls:\n\t- unit_decimals = IERC20(_assetContractERC20).decimals() (TwoKeyAcquisitionLogicHandler.sol#834)\n\t- twoKeyRegistry = ITwoKeySingletoneRegistryFetchAddress(twoKeySingletoneRegistry).getContractProxyAddress(TwoKeyRegistry) (TwoKeyAcquisitionLogicHandler.sol#839)\n\tState variables written after the call(s):\n\t- twoKeyRegistry (TwoKeyAcquisitionLogicHandler.sol#839)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 795,
          "vulnerability_to_line": 846,
          "vulnerability_code": "    function setInitialParamsLogicHandler(\n\n        uint [] values,\n\n        string _currency,\n\n        address _assetContractERC20,\n\n        address _moderator,\n\n        address _contractor,\n\n        address _acquisitionCampaignAddress,\n\n        address _twoKeySingletoneRegistry,\n\n        address _twoKeyConversionHandler\n\n    )\n\n    public\n\n    {\n\n        require(values[1] >= values[0], \"max contribution criteria not satisfied\");\n\n        require(values[4] > values[3], \"campaign start time can't be greater than end time\");\n\n        require(isCampaignInitialized == false);\n\n\n\n        if(values[0] == values[1]) {\n\n            isFixedInvestmentAmount = true;\n\n        }\n\n\n\n        minContributionETHorFiatCurrency = values[0];\n\n        maxContributionETHorFiatCurrency = values[1];\n\n        pricePerUnitInETHWeiOrUSD = values[2];\n\n        campaignStartTime = values[3];\n\n        campaignEndTime = values[4];\n\n        maxConverterBonusPercent = values[5];\n\n\n\n        //Add as 6th argument incentive model uint\n\n        incentiveModel = IncentiveModel(values[6]);\n\n        if(values[7] == 1) {\n\n            isAcceptingFiatOnly = true;\n\n        }\n\n\n\n        campaignHardCapWei = values[8];\n\n\n\n        currency = _currency;\n\n        assetContractERC20 = _assetContractERC20;\n\n        moderator = _moderator;\n\n        contractor = _contractor;\n\n        unit_decimals = IERC20(_assetContractERC20).decimals();\n\n\n\n        twoKeyAcquisitionCampaign = _acquisitionCampaignAddress;\n\n        twoKeySingletoneRegistry = _twoKeySingletoneRegistry;\n\n\n\n        twoKeyRegistry = ITwoKeySingletoneRegistryFetchAddress(twoKeySingletoneRegistry).getContractProxyAddress(\"TwoKeyRegistry\");\n\n        twoKeyMaintainersRegistry = ITwoKeySingletoneRegistryFetchAddress(twoKeySingletoneRegistry).getContractProxyAddress(\"TwoKeyMaintainersRegistry\");\n\n\n\n        ownerPlasma = plasmaOf(contractor);\n\n        twoKeyConversionHandler = _twoKeyConversionHandler;\n\n\n\n        isCampaignInitialized = true;\n",
          "message": "Reentrancy in TwoKeyAcquisitionLogicHandler.setInitialParamsLogicHandler (TwoKeyAcquisitionLogicHandler.sol#795-846):\n\tExternal calls:\n\t- unit_decimals = IERC20(_assetContractERC20).decimals() (TwoKeyAcquisitionLogicHandler.sol#834)\n\t- twoKeyRegistry = ITwoKeySingletoneRegistryFetchAddress(twoKeySingletoneRegistry).getContractProxyAddress(TwoKeyRegistry) (TwoKeyAcquisitionLogicHandler.sol#839)\n\t- twoKeyMaintainersRegistry = ITwoKeySingletoneRegistryFetchAddress(twoKeySingletoneRegistry).getContractProxyAddress(TwoKeyMaintainersRegistry) (TwoKeyAcquisitionLogicHandler.sol#840)\n\tState variables written after the call(s):\n\t- twoKeyMaintainersRegistry (TwoKeyAcquisitionLogicHandler.sol#840)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 795,
          "vulnerability_to_line": 846,
          "vulnerability_code": "    function setInitialParamsLogicHandler(\n\n        uint [] values,\n\n        string _currency,\n\n        address _assetContractERC20,\n\n        address _moderator,\n\n        address _contractor,\n\n        address _acquisitionCampaignAddress,\n\n        address _twoKeySingletoneRegistry,\n\n        address _twoKeyConversionHandler\n\n    )\n\n    public\n\n    {\n\n        require(values[1] >= values[0], \"max contribution criteria not satisfied\");\n\n        require(values[4] > values[3], \"campaign start time can't be greater than end time\");\n\n        require(isCampaignInitialized == false);\n\n\n\n        if(values[0] == values[1]) {\n\n            isFixedInvestmentAmount = true;\n\n        }\n\n\n\n        minContributionETHorFiatCurrency = values[0];\n\n        maxContributionETHorFiatCurrency = values[1];\n\n        pricePerUnitInETHWeiOrUSD = values[2];\n\n        campaignStartTime = values[3];\n\n        campaignEndTime = values[4];\n\n        maxConverterBonusPercent = values[5];\n\n\n\n        //Add as 6th argument incentive model uint\n\n        incentiveModel = IncentiveModel(values[6]);\n\n        if(values[7] == 1) {\n\n            isAcceptingFiatOnly = true;\n\n        }\n\n\n\n        campaignHardCapWei = values[8];\n\n\n\n        currency = _currency;\n\n        assetContractERC20 = _assetContractERC20;\n\n        moderator = _moderator;\n\n        contractor = _contractor;\n\n        unit_decimals = IERC20(_assetContractERC20).decimals();\n\n\n\n        twoKeyAcquisitionCampaign = _acquisitionCampaignAddress;\n\n        twoKeySingletoneRegistry = _twoKeySingletoneRegistry;\n\n\n\n        twoKeyRegistry = ITwoKeySingletoneRegistryFetchAddress(twoKeySingletoneRegistry).getContractProxyAddress(\"TwoKeyRegistry\");\n\n        twoKeyMaintainersRegistry = ITwoKeySingletoneRegistryFetchAddress(twoKeySingletoneRegistry).getContractProxyAddress(\"TwoKeyMaintainersRegistry\");\n\n\n\n        ownerPlasma = plasmaOf(contractor);\n\n        twoKeyConversionHandler = _twoKeyConversionHandler;\n\n\n\n        isCampaignInitialized = true;\n",
          "message": "Reentrancy in TwoKeyAcquisitionLogicHandler.setInitialParamsLogicHandler (TwoKeyAcquisitionLogicHandler.sol#795-846):\n\tExternal calls:\n\t- unit_decimals = IERC20(_assetContractERC20).decimals() (TwoKeyAcquisitionLogicHandler.sol#834)\n\t- twoKeyRegistry = ITwoKeySingletoneRegistryFetchAddress(twoKeySingletoneRegistry).getContractProxyAddress(TwoKeyRegistry) (TwoKeyAcquisitionLogicHandler.sol#839)\n\t- twoKeyMaintainersRegistry = ITwoKeySingletoneRegistryFetchAddress(twoKeySingletoneRegistry).getContractProxyAddress(TwoKeyMaintainersRegistry) (TwoKeyAcquisitionLogicHandler.sol#840)\n\t- ownerPlasma = plasmaOf(contractor) (TwoKeyAcquisitionLogicHandler.sol#842)\n\tState variables written after the call(s):\n\t- ownerPlasma (TwoKeyAcquisitionLogicHandler.sol#842)\n\t- twoKeyConversionHandler (TwoKeyAcquisitionLogicHandler.sol#843)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 1247,
          "vulnerability_to_line": 1311,
          "vulnerability_code": "    function updateRefchainRewards(\n\n        uint256 _maxReferralRewardETHWei,\n\n        address _converter,\n\n        uint _conversionId,\n\n        uint totalBounty2keys\n\n    )\n\n    public\n\n    {\n\n        require(msg.sender == twoKeyAcquisitionCampaign);\n\n\n\n        //Get all the influencers\n\n        address[] memory influencers = getReferrers(_converter,twoKeyAcquisitionCampaign);\n\n\n\n        //Get array length\n\n        uint numberOfInfluencers = influencers.length;\n\n\n\n        uint i;\n\n        uint reward;\n\n        if(incentiveModel == IncentiveModel.VANILLA_AVERAGE) {\n\n            reward = IncentiveModels.averageModelRewards(totalBounty2keys, numberOfInfluencers);\n\n            for(i=0; i<numberOfInfluencers; i++) {\n\n                updateReferrerMappings(influencers[i], reward, _conversionId);\n\n\n\n            }\n\n        } else if (incentiveModel == IncentiveModel.VANILLA_AVERAGE_LAST_3X) {\n\n            uint rewardForLast;\n\n            // Calculate reward for regular ones and for the last\n\n            (reward, rewardForLast) = IncentiveModels.averageLast3xRewards(totalBounty2keys, numberOfInfluencers);\n\n\n\n            //Update equal rewards to all influencers but last\n\n            for(i=0; i<numberOfInfluencers - 1; i++) {\n\n                updateReferrerMappings(influencers[i], reward, _conversionId);\n\n\n\n            }\n\n            //Update reward for last\n\n            updateReferrerMappings(influencers[numberOfInfluencers-1], rewardForLast, _conversionId);\n\n        } else if(incentiveModel == IncentiveModel.VANILLA_POWER_LAW) {\n\n            // Get rewards per referrer\n\n            uint [] memory rewards = IncentiveModels.powerLawRewards(totalBounty2keys, numberOfInfluencers, 2);\n\n            //Iterate through all referrers and distribute rewards\n\n            for(i=0; i<numberOfInfluencers; i++) {\n\n                updateReferrerMappings(influencers[i], rewards[i], _conversionId);\n\n            }\n\n        } else if(incentiveModel == IncentiveModel.MANUAL) {\n\n            for (i = 0; i < numberOfInfluencers; i++) {\n\n                uint256 b;\n\n\n\n                if (i == influencers.length - 1) {  // if its the last influencer then all the bounty goes to it.\n\n                    b = totalBounty2keys;\n\n                }\n\n                else {\n\n                    uint256 cut = ITwoKeyAcquisitionCampaignERC20(twoKeyAcquisitionCampaign).getReferrerCut(influencers[i]);\n\n                    if (cut > 0 && cut <= 101) {\n\n                        b = totalBounty2keys.mul(cut.sub(1)).div(100);\n\n                    } else {// cut == 0 or 255 indicates equal particine of the bounty\n\n                        b = totalBounty2keys.div(influencers.length - i);\n\n                    }\n\n                }\n\n\n\n                updateReferrerMappings(influencers[i], b, _conversionId);\n\n                //Decrease bounty for distributed\n\n                totalBounty2keys = totalBounty2keys.sub(b);\n\n            }\n\n        }\n",
          "message": "Reentrancy in TwoKeyAcquisitionLogicHandler.updateRefchainRewards (TwoKeyAcquisitionLogicHandler.sol#1247-1311):\n\tExternal calls:\n\t- influencers = getReferrers(_converter,twoKeyAcquisitionCampaign) (TwoKeyAcquisitionLogicHandler.sol#1258)\n\t- updateReferrerMappings(influencers[i],reward,_conversionId) (TwoKeyAcquisitionLogicHandler.sol#1268)\n\tState variables written after the call(s):\n\t- referrerPlasma2EarningsPerConversion (TwoKeyAcquisitionLogicHandler.sol#1268)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 1247,
          "vulnerability_to_line": 1311,
          "vulnerability_code": "    function updateRefchainRewards(\n\n        uint256 _maxReferralRewardETHWei,\n\n        address _converter,\n\n        uint _conversionId,\n\n        uint totalBounty2keys\n\n    )\n\n    public\n\n    {\n\n        require(msg.sender == twoKeyAcquisitionCampaign);\n\n\n\n        //Get all the influencers\n\n        address[] memory influencers = getReferrers(_converter,twoKeyAcquisitionCampaign);\n\n\n\n        //Get array length\n\n        uint numberOfInfluencers = influencers.length;\n\n\n\n        uint i;\n\n        uint reward;\n\n        if(incentiveModel == IncentiveModel.VANILLA_AVERAGE) {\n\n            reward = IncentiveModels.averageModelRewards(totalBounty2keys, numberOfInfluencers);\n\n            for(i=0; i<numberOfInfluencers; i++) {\n\n                updateReferrerMappings(influencers[i], reward, _conversionId);\n\n\n\n            }\n\n        } else if (incentiveModel == IncentiveModel.VANILLA_AVERAGE_LAST_3X) {\n\n            uint rewardForLast;\n\n            // Calculate reward for regular ones and for the last\n\n            (reward, rewardForLast) = IncentiveModels.averageLast3xRewards(totalBounty2keys, numberOfInfluencers);\n\n\n\n            //Update equal rewards to all influencers but last\n\n            for(i=0; i<numberOfInfluencers - 1; i++) {\n\n                updateReferrerMappings(influencers[i], reward, _conversionId);\n\n\n\n            }\n\n            //Update reward for last\n\n            updateReferrerMappings(influencers[numberOfInfluencers-1], rewardForLast, _conversionId);\n\n        } else if(incentiveModel == IncentiveModel.VANILLA_POWER_LAW) {\n\n            // Get rewards per referrer\n\n            uint [] memory rewards = IncentiveModels.powerLawRewards(totalBounty2keys, numberOfInfluencers, 2);\n\n            //Iterate through all referrers and distribute rewards\n\n            for(i=0; i<numberOfInfluencers; i++) {\n\n                updateReferrerMappings(influencers[i], rewards[i], _conversionId);\n\n            }\n\n        } else if(incentiveModel == IncentiveModel.MANUAL) {\n\n            for (i = 0; i < numberOfInfluencers; i++) {\n\n                uint256 b;\n\n\n\n                if (i == influencers.length - 1) {  // if its the last influencer then all the bounty goes to it.\n\n                    b = totalBounty2keys;\n\n                }\n\n                else {\n\n                    uint256 cut = ITwoKeyAcquisitionCampaignERC20(twoKeyAcquisitionCampaign).getReferrerCut(influencers[i]);\n\n                    if (cut > 0 && cut <= 101) {\n\n                        b = totalBounty2keys.mul(cut.sub(1)).div(100);\n\n                    } else {// cut == 0 or 255 indicates equal particine of the bounty\n\n                        b = totalBounty2keys.div(influencers.length - i);\n\n                    }\n\n                }\n\n\n\n                updateReferrerMappings(influencers[i], b, _conversionId);\n\n                //Decrease bounty for distributed\n\n                totalBounty2keys = totalBounty2keys.sub(b);\n\n            }\n\n        }\n",
          "message": "Reentrancy in TwoKeyAcquisitionLogicHandler.updateRefchainRewards (TwoKeyAcquisitionLogicHandler.sol#1247-1311):\n\tExternal calls:\n\t- influencers = getReferrers(_converter,twoKeyAcquisitionCampaign) (TwoKeyAcquisitionLogicHandler.sol#1258)\n\t- updateReferrerMappings(influencers[i],reward,_conversionId) (TwoKeyAcquisitionLogicHandler.sol#1278)\n\tState variables written after the call(s):\n\t- referrerPlasma2EarningsPerConversion (TwoKeyAcquisitionLogicHandler.sol#1278)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 1247,
          "vulnerability_to_line": 1311,
          "vulnerability_code": "    function updateRefchainRewards(\n\n        uint256 _maxReferralRewardETHWei,\n\n        address _converter,\n\n        uint _conversionId,\n\n        uint totalBounty2keys\n\n    )\n\n    public\n\n    {\n\n        require(msg.sender == twoKeyAcquisitionCampaign);\n\n\n\n        //Get all the influencers\n\n        address[] memory influencers = getReferrers(_converter,twoKeyAcquisitionCampaign);\n\n\n\n        //Get array length\n\n        uint numberOfInfluencers = influencers.length;\n\n\n\n        uint i;\n\n        uint reward;\n\n        if(incentiveModel == IncentiveModel.VANILLA_AVERAGE) {\n\n            reward = IncentiveModels.averageModelRewards(totalBounty2keys, numberOfInfluencers);\n\n            for(i=0; i<numberOfInfluencers; i++) {\n\n                updateReferrerMappings(influencers[i], reward, _conversionId);\n\n\n\n            }\n\n        } else if (incentiveModel == IncentiveModel.VANILLA_AVERAGE_LAST_3X) {\n\n            uint rewardForLast;\n\n            // Calculate reward for regular ones and for the last\n\n            (reward, rewardForLast) = IncentiveModels.averageLast3xRewards(totalBounty2keys, numberOfInfluencers);\n\n\n\n            //Update equal rewards to all influencers but last\n\n            for(i=0; i<numberOfInfluencers - 1; i++) {\n\n                updateReferrerMappings(influencers[i], reward, _conversionId);\n\n\n\n            }\n\n            //Update reward for last\n\n            updateReferrerMappings(influencers[numberOfInfluencers-1], rewardForLast, _conversionId);\n\n        } else if(incentiveModel == IncentiveModel.VANILLA_POWER_LAW) {\n\n            // Get rewards per referrer\n\n            uint [] memory rewards = IncentiveModels.powerLawRewards(totalBounty2keys, numberOfInfluencers, 2);\n\n            //Iterate through all referrers and distribute rewards\n\n            for(i=0; i<numberOfInfluencers; i++) {\n\n                updateReferrerMappings(influencers[i], rewards[i], _conversionId);\n\n            }\n\n        } else if(incentiveModel == IncentiveModel.MANUAL) {\n\n            for (i = 0; i < numberOfInfluencers; i++) {\n\n                uint256 b;\n\n\n\n                if (i == influencers.length - 1) {  // if its the last influencer then all the bounty goes to it.\n\n                    b = totalBounty2keys;\n\n                }\n\n                else {\n\n                    uint256 cut = ITwoKeyAcquisitionCampaignERC20(twoKeyAcquisitionCampaign).getReferrerCut(influencers[i]);\n\n                    if (cut > 0 && cut <= 101) {\n\n                        b = totalBounty2keys.mul(cut.sub(1)).div(100);\n\n                    } else {// cut == 0 or 255 indicates equal particine of the bounty\n\n                        b = totalBounty2keys.div(influencers.length - i);\n\n                    }\n\n                }\n\n\n\n                updateReferrerMappings(influencers[i], b, _conversionId);\n\n                //Decrease bounty for distributed\n\n                totalBounty2keys = totalBounty2keys.sub(b);\n\n            }\n\n        }\n",
          "message": "Reentrancy in TwoKeyAcquisitionLogicHandler.updateRefchainRewards (TwoKeyAcquisitionLogicHandler.sol#1247-1311):\n\tExternal calls:\n\t- influencers = getReferrers(_converter,twoKeyAcquisitionCampaign) (TwoKeyAcquisitionLogicHandler.sol#1258)\n\t- updateReferrerMappings(influencers[numberOfInfluencers - 1],rewardForLast,_conversionId) (TwoKeyAcquisitionLogicHandler.sol#1282)\n\tState variables written after the call(s):\n\t- referrerPlasma2EarningsPerConversion (TwoKeyAcquisitionLogicHandler.sol#1282)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 1247,
          "vulnerability_to_line": 1311,
          "vulnerability_code": "    function updateRefchainRewards(\n\n        uint256 _maxReferralRewardETHWei,\n\n        address _converter,\n\n        uint _conversionId,\n\n        uint totalBounty2keys\n\n    )\n\n    public\n\n    {\n\n        require(msg.sender == twoKeyAcquisitionCampaign);\n\n\n\n        //Get all the influencers\n\n        address[] memory influencers = getReferrers(_converter,twoKeyAcquisitionCampaign);\n\n\n\n        //Get array length\n\n        uint numberOfInfluencers = influencers.length;\n\n\n\n        uint i;\n\n        uint reward;\n\n        if(incentiveModel == IncentiveModel.VANILLA_AVERAGE) {\n\n            reward = IncentiveModels.averageModelRewards(totalBounty2keys, numberOfInfluencers);\n\n            for(i=0; i<numberOfInfluencers; i++) {\n\n                updateReferrerMappings(influencers[i], reward, _conversionId);\n\n\n\n            }\n\n        } else if (incentiveModel == IncentiveModel.VANILLA_AVERAGE_LAST_3X) {\n\n            uint rewardForLast;\n\n            // Calculate reward for regular ones and for the last\n\n            (reward, rewardForLast) = IncentiveModels.averageLast3xRewards(totalBounty2keys, numberOfInfluencers);\n\n\n\n            //Update equal rewards to all influencers but last\n\n            for(i=0; i<numberOfInfluencers - 1; i++) {\n\n                updateReferrerMappings(influencers[i], reward, _conversionId);\n\n\n\n            }\n\n            //Update reward for last\n\n            updateReferrerMappings(influencers[numberOfInfluencers-1], rewardForLast, _conversionId);\n\n        } else if(incentiveModel == IncentiveModel.VANILLA_POWER_LAW) {\n\n            // Get rewards per referrer\n\n            uint [] memory rewards = IncentiveModels.powerLawRewards(totalBounty2keys, numberOfInfluencers, 2);\n\n            //Iterate through all referrers and distribute rewards\n\n            for(i=0; i<numberOfInfluencers; i++) {\n\n                updateReferrerMappings(influencers[i], rewards[i], _conversionId);\n\n            }\n\n        } else if(incentiveModel == IncentiveModel.MANUAL) {\n\n            for (i = 0; i < numberOfInfluencers; i++) {\n\n                uint256 b;\n\n\n\n                if (i == influencers.length - 1) {  // if its the last influencer then all the bounty goes to it.\n\n                    b = totalBounty2keys;\n\n                }\n\n                else {\n\n                    uint256 cut = ITwoKeyAcquisitionCampaignERC20(twoKeyAcquisitionCampaign).getReferrerCut(influencers[i]);\n\n                    if (cut > 0 && cut <= 101) {\n\n                        b = totalBounty2keys.mul(cut.sub(1)).div(100);\n\n                    } else {// cut == 0 or 255 indicates equal particine of the bounty\n\n                        b = totalBounty2keys.div(influencers.length - i);\n\n                    }\n\n                }\n\n\n\n                updateReferrerMappings(influencers[i], b, _conversionId);\n\n                //Decrease bounty for distributed\n\n                totalBounty2keys = totalBounty2keys.sub(b);\n\n            }\n\n        }\n",
          "message": "Reentrancy in TwoKeyAcquisitionLogicHandler.updateRefchainRewards (TwoKeyAcquisitionLogicHandler.sol#1247-1311):\n\tExternal calls:\n\t- influencers = getReferrers(_converter,twoKeyAcquisitionCampaign) (TwoKeyAcquisitionLogicHandler.sol#1258)\n\t- updateReferrerMappings(influencers[i],rewards[i],_conversionId) (TwoKeyAcquisitionLogicHandler.sol#1288)\n\tState variables written after the call(s):\n\t- referrerPlasma2EarningsPerConversion (TwoKeyAcquisitionLogicHandler.sol#1288)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 1247,
          "vulnerability_to_line": 1311,
          "vulnerability_code": "    function updateRefchainRewards(\n\n        uint256 _maxReferralRewardETHWei,\n\n        address _converter,\n\n        uint _conversionId,\n\n        uint totalBounty2keys\n\n    )\n\n    public\n\n    {\n\n        require(msg.sender == twoKeyAcquisitionCampaign);\n\n\n\n        //Get all the influencers\n\n        address[] memory influencers = getReferrers(_converter,twoKeyAcquisitionCampaign);\n\n\n\n        //Get array length\n\n        uint numberOfInfluencers = influencers.length;\n\n\n\n        uint i;\n\n        uint reward;\n\n        if(incentiveModel == IncentiveModel.VANILLA_AVERAGE) {\n\n            reward = IncentiveModels.averageModelRewards(totalBounty2keys, numberOfInfluencers);\n\n            for(i=0; i<numberOfInfluencers; i++) {\n\n                updateReferrerMappings(influencers[i], reward, _conversionId);\n\n\n\n            }\n\n        } else if (incentiveModel == IncentiveModel.VANILLA_AVERAGE_LAST_3X) {\n\n            uint rewardForLast;\n\n            // Calculate reward for regular ones and for the last\n\n            (reward, rewardForLast) = IncentiveModels.averageLast3xRewards(totalBounty2keys, numberOfInfluencers);\n\n\n\n            //Update equal rewards to all influencers but last\n\n            for(i=0; i<numberOfInfluencers - 1; i++) {\n\n                updateReferrerMappings(influencers[i], reward, _conversionId);\n\n\n\n            }\n\n            //Update reward for last\n\n            updateReferrerMappings(influencers[numberOfInfluencers-1], rewardForLast, _conversionId);\n\n        } else if(incentiveModel == IncentiveModel.VANILLA_POWER_LAW) {\n\n            // Get rewards per referrer\n\n            uint [] memory rewards = IncentiveModels.powerLawRewards(totalBounty2keys, numberOfInfluencers, 2);\n\n            //Iterate through all referrers and distribute rewards\n\n            for(i=0; i<numberOfInfluencers; i++) {\n\n                updateReferrerMappings(influencers[i], rewards[i], _conversionId);\n\n            }\n\n        } else if(incentiveModel == IncentiveModel.MANUAL) {\n\n            for (i = 0; i < numberOfInfluencers; i++) {\n\n                uint256 b;\n\n\n\n                if (i == influencers.length - 1) {  // if its the last influencer then all the bounty goes to it.\n\n                    b = totalBounty2keys;\n\n                }\n\n                else {\n\n                    uint256 cut = ITwoKeyAcquisitionCampaignERC20(twoKeyAcquisitionCampaign).getReferrerCut(influencers[i]);\n\n                    if (cut > 0 && cut <= 101) {\n\n                        b = totalBounty2keys.mul(cut.sub(1)).div(100);\n\n                    } else {// cut == 0 or 255 indicates equal particine of the bounty\n\n                        b = totalBounty2keys.div(influencers.length - i);\n\n                    }\n\n                }\n\n\n\n                updateReferrerMappings(influencers[i], b, _conversionId);\n\n                //Decrease bounty for distributed\n\n                totalBounty2keys = totalBounty2keys.sub(b);\n\n            }\n\n        }\n",
          "message": "Reentrancy in TwoKeyAcquisitionLogicHandler.updateRefchainRewards (TwoKeyAcquisitionLogicHandler.sol#1247-1311):\n\tExternal calls:\n\t- influencers = getReferrers(_converter,twoKeyAcquisitionCampaign) (TwoKeyAcquisitionLogicHandler.sol#1258)\n\t- cut = ITwoKeyAcquisitionCampaignERC20(twoKeyAcquisitionCampaign).getReferrerCut(influencers[i]) (TwoKeyAcquisitionLogicHandler.sol#1298)\n\t- updateReferrerMappings(influencers[i],b,_conversionId) (TwoKeyAcquisitionLogicHandler.sol#1306)\n\tState variables written after the call(s):\n\t- referrerPlasma2EarningsPerConversion (TwoKeyAcquisitionLogicHandler.sol#1306)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 1234,
          "vulnerability_to_line": 1239,
          "vulnerability_code": "    function updateReferrerMappings(address referrerPlasma, uint reward, uint conversionId) internal {\n\n        ITwoKeyAcquisitionCampaignERC20(twoKeyAcquisitionCampaign).updateReferrerPlasmaBalance(referrerPlasma,reward);\n\n        referrerPlasma2TotalEarnings2key[referrerPlasma] = referrerPlasma2TotalEarnings2key[referrerPlasma].add(reward);\n\n        referrerPlasma2EarningsPerConversion[referrerPlasma][conversionId] = reward;\n\n        referrerPlasmaAddressToCounterOfConversions[referrerPlasma] += 1;\n",
          "message": "Reentrancy in TwoKeyAcquisitionLogicHandler.updateReferrerMappings (TwoKeyAcquisitionLogicHandler.sol#1234-1239):\n\tExternal calls:\n\t- ITwoKeyAcquisitionCampaignERC20(twoKeyAcquisitionCampaign).updateReferrerPlasmaBalance(referrerPlasma,reward) (TwoKeyAcquisitionLogicHandler.sol#1235)\n\tState variables written after the call(s):\n\t- referrerPlasma2EarningsPerConversion (TwoKeyAcquisitionLogicHandler.sol#1237)\n\t- referrerPlasma2TotalEarnings2key (TwoKeyAcquisitionLogicHandler.sol#1236)\n\t- referrerPlasmaAddressToCounterOfConversions (TwoKeyAcquisitionLogicHandler.sol#1238)\n"
        },
        {
          "name": "timestamp",
          "vulnerability_from_line": 942,
          "vulnerability_to_line": 951,
          "vulnerability_code": "    function checkIsCampaignActive()\n\n    public\n\n    view\n\n    returns (bool)\n\n    {\n\n        if(block.timestamp >= campaignStartTime && block.timestamp <= campaignEndTime) {\n\n            return true;\n\n        }\n\n        return false;\n",
          "message": "TwoKeyAcquisitionLogicHandler.checkIsCampaignActive (TwoKeyAcquisitionLogicHandler.sol#942-951) uses timestamp for comparisons\n\tDangerous comparisons:\n\t- block.timestamp >= campaignStartTime && block.timestamp <= campaignEndTime (TwoKeyAcquisitionLogicHandler.sol#947-949)\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 289,
          "vulnerability_to_line": 315,
          "vulnerability_code": "    function params0(address c, bytes _method) public view returns (uint answer) {\n\n        // https://medium.com/@blockchain101/calling-the-function-of-another-contract-in-solidity-f9edfa921f4c\n\n        //    dc = c;\n\n        bytes4 sig = bytes4(keccak256(_method));\n\n        assembly {\n\n        // move pointer to free memory spot\n\n            let ptr := mload(0x40)\n\n        // put function sig at memory spot\n\n            mstore(ptr,sig)\n\n\n\n            let result := call(  // use WARNING because this should be staticcall BUT geth crash!\n\n            15000, // gas limit\n\n            c, // sload(dc_slot),  // to addr. append var to _slot to access storage variable\n\n            0, // not transfer any ether (comment if using staticcall)\n\n            ptr, // Inputs are stored at location ptr\n\n            0x04, // Inputs are 0 bytes long\n\n            ptr,  //Store output over input\n\n            0x20) //Outputs are 1 bytes long\n\n\n\n            if eq(result, 0) {\n\n                revert(0, 0)\n\n            }\n\n\n\n            answer := mload(ptr) // Assign output to answer var\n\n            mstore(0x40,add(ptr,0x24)) // Set storage pointer to new space\n\n        }\n",
          "message": "Call.params0 uses assembly (TwoKeyAcquisitionLogicHandler.sol#289-315)\n\t- TwoKeyAcquisitionLogicHandler.sol#293-315\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 317,
          "vulnerability_to_line": 345,
          "vulnerability_code": "    function params1(address c, bytes _method, uint _val) public view returns (uint answer) {\n\n        // https://medium.com/@blockchain101/calling-the-function-of-another-contract-in-solidity-f9edfa921f4c\n\n        //    dc = c;\n\n        bytes4 sig = bytes4(keccak256(_method));\n\n        assembly {\n\n        // move pointer to free memory spot\n\n            let ptr := mload(0x40)\n\n        // put function sig at memory spot\n\n            mstore(ptr,sig)\n\n        // append argument after function sig\n\n            mstore(add(ptr,0x04), _val)\n\n\n\n            let result := call(  // use WARNING because this should be staticcall BUT geth crash!\n\n            15000, // gas limit\n\n            c, // sload(dc_slot),  // to addr. append var to _slot to access storage variable\n\n            0, // not transfer any ether (comment if using staticcall)\n\n            ptr, // Inputs are stored at location ptr\n\n            0x24, // Inputs are 0 bytes long\n\n            ptr,  //Store output over input\n\n            0x20) //Outputs are 1 bytes long\n\n\n\n            if eq(result, 0) {\n\n                revert(0, 0)\n\n            }\n\n\n\n            answer := mload(ptr) // Assign output to answer var\n\n            mstore(0x40,add(ptr,0x24)) // Set storage pointer to new space\n\n        }\n",
          "message": "Call.params1 uses assembly (TwoKeyAcquisitionLogicHandler.sol#317-345)\n\t- TwoKeyAcquisitionLogicHandler.sol#321-345\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 347,
          "vulnerability_to_line": 377,
          "vulnerability_code": "    function params2(address c, bytes _method, uint _val1, uint _val2) public view returns (uint answer) {\n\n        // https://medium.com/@blockchain101/calling-the-function-of-another-contract-in-solidity-f9edfa921f4c\n\n        //    dc = c;\n\n        bytes4 sig = bytes4(keccak256(_method));\n\n        assembly {\n\n        // move pointer to free memory spot\n\n            let ptr := mload(0x40)\n\n        // put function sig at memory spot\n\n            mstore(ptr,sig)\n\n        // append argument after function sig\n\n            mstore(add(ptr,0x04), _val1)\n\n            mstore(add(ptr,0x24), _val2)\n\n\n\n            let result := call(  // use WARNING because this should be staticcall BUT geth crash!\n\n            15000, // gas limit\n\n            c, // sload(dc_slot),  // to addr. append var to _slot to access storage variable\n\n            0, // not transfer any ether (comment if using staticcall)\n\n            ptr, // Inputs are stored at location ptr\n\n            0x44, // Inputs are 4 bytes for signature and 2 uint256\n\n            ptr,  //Store output over input\n\n            0x20) //Outputs are 1 uint long\n\n\n\n        // TODO cause revert\n\n        //            if eq(result, 0) {\n\n        //                revert(0, 0)\n\n        //            }\n\n\n\n            answer := mload(ptr) // Assign output to answer var\n\n            mstore(0x40,add(ptr,0x20)) // Set storage pointer to new space\n\n        }\n",
          "message": "Call.params2 uses assembly (TwoKeyAcquisitionLogicHandler.sol#347-377)\n\t- TwoKeyAcquisitionLogicHandler.sol#351-377\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 379,
          "vulnerability_to_line": 387,
          "vulnerability_code": "    function loadAddress(bytes sig, uint idx) public pure returns (address) {\n\n        address influencer;\n\n        idx += 20;\n\n        assembly\n\n        {\n\n            influencer := mload(add(sig, idx))\n\n        }\n\n        return influencer;\n",
          "message": "Call.loadAddress uses assembly (TwoKeyAcquisitionLogicHandler.sol#379-387)\n\t- TwoKeyAcquisitionLogicHandler.sol#382-386\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 389,
          "vulnerability_to_line": 397,
          "vulnerability_code": "    function loadUint8(bytes sig, uint idx) public pure returns (uint8) {\n\n        uint8 weight;\n\n        idx += 1;\n\n        assembly\n\n        {\n\n            weight := mload(add(sig, idx))\n\n        }\n\n        return weight;\n",
          "message": "Call.loadUint8 uses assembly (TwoKeyAcquisitionLogicHandler.sol#389-397)\n\t- TwoKeyAcquisitionLogicHandler.sol#392-396\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 400,
          "vulnerability_to_line": 435,
          "vulnerability_code": "    function recoverHash(bytes32 hash, bytes sig, uint idx) public pure returns (address) {\n\n        // same as recoverHash in utils/sign.js\n\n        // The signature format is a compact form of:\n\n        //   {bytes32 r}{bytes32 s}{uint8 v}\n\n        // Compact means, uint8 is not padded to 32 bytes.\n\n        require (sig.length >= 65+idx, 'bad signature length');\n\n        idx += 32;\n\n        bytes32 r;\n\n        assembly\n\n        {\n\n            r := mload(add(sig, idx))\n\n        }\n\n\n\n        idx += 32;\n\n        bytes32 s;\n\n        assembly\n\n        {\n\n            s := mload(add(sig, idx))\n\n        }\n\n\n\n        idx += 1;\n\n        uint8 v;\n\n        assembly\n\n        {\n\n            v := mload(add(sig, idx))\n\n        }\n\n        if (v >= 32) { // handle case when signature was made with ethereum web3.eth.sign or getSign which is for signing ethereum transactions\n\n            v -= 32;\n\n            bytes memory prefix = \"\\x19Ethereum Signed Message:\\n32\"; // 32 is the number of bytes in the following hash\n\n            hash = keccak256(abi.encodePacked(prefix, hash));\n\n        }\n\n        if (v <= 1) v += 27;\n\n        require(v==27 || v==28,'bad sig v');\n\n        return ecrecover(hash, v, r, s);\n\n\n",
          "message": "Call.recoverHash uses assembly (TwoKeyAcquisitionLogicHandler.sol#400-435)\n\t- TwoKeyAcquisitionLogicHandler.sol#408-413\n\t- TwoKeyAcquisitionLogicHandler.sol#415-420\n\t- TwoKeyAcquisitionLogicHandler.sol#422-426\n"
        },
        {
          "name": "constable-states",
          "vulnerability_from_line": 141,
          "vulnerability_to_line": null,
          "vulnerability_code": "    address public conversionHandler;\n",
          "message": "ITwoKeyAcquisitionCampaignERC20.conversionHandler should be constant (TwoKeyAcquisitionLogicHandler.sol#141)\nITwoKeyConversionHandler.isFiatConversionAutomaticallyApproved should be constant (TwoKeyAcquisitionLogicHandler.sol#86)\nUpgradeabilityCampaignStorage._implementation should be constant (TwoKeyAcquisitionLogicHandler.sol#700)\nUpgradeabilityCampaignStorage.twoKeyFactory should be constant (TwoKeyAcquisitionLogicHandler.sol#697)\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 10,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getBaseToTargetRate(string _currency) public view returns (uint);\n",
          "message": "ITwoKeyExchangeRateContract.getBaseToTargetRate (TwoKeyAcquisitionLogicHandler.sol#10) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 45,
          "vulnerability_to_line": 50,
          "vulnerability_code": "    function approve(\n\n        address _spender,\n\n        uint256 _value\n\n    )\n\n    public\n",
          "message": "IERC20.approve (TwoKeyAcquisitionLogicHandler.sol#45-50) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 88,
          "vulnerability_to_line": 100,
          "vulnerability_code": "    function supportForCreateConversion(\n\n        address _contractor,\n\n        address _converterAddress,\n\n        uint256 _conversionAmount,\n\n        uint256 _maxReferralRewardETHWei,\n\n        uint256 baseTokensForConverterUnits,\n\n        uint256 bonusTokensForConverterUnits,\n\n        bool isConversionFiat,\n\n        bool _isAnonymous,\n\n        bool _isKYCRequired\n\n    )\n\n    public\n",
          "message": "ITwoKeyConversionHandler.supportForCreateConversion (TwoKeyAcquisitionLogicHandler.sol#88-100) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 102,
          "vulnerability_to_line": 105,
          "vulnerability_code": "    function executeConversion(\n\n        uint _conversionId\n\n    )\n",
          "message": "ITwoKeyConversionHandler.executeConversion (TwoKeyAcquisitionLogicHandler.sol#102-105) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 116,
          "vulnerability_to_line": 121,
          "vulnerability_code": "    function getConverterPurchasesStats(\n\n        address _converter\n\n    )\n\n    public\n\n    view\n",
          "message": "ITwoKeyConversionHandler.getConverterPurchasesStats (TwoKeyAcquisitionLogicHandler.sol#116-121) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 124,
          "vulnerability_to_line": 129,
          "vulnerability_code": "    function getStateForConverter(\n\n        address _converter\n\n    )\n\n    public\n\n    view\n",
          "message": "ITwoKeyConversionHandler.getStateForConverter (TwoKeyAcquisitionLogicHandler.sol#124-129) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 142,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function buyTokensAndDistributeReferrerRewards(uint256 _maxReferralRewardETHWei, address _converter, uint _conversionId, bool _isConversionFiat) public returns (uint);\n",
          "message": "ITwoKeyAcquisitionCampaignERC20.buyTokensAndDistributeReferrerRewards (TwoKeyAcquisitionLogicHandler.sol#142) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 143,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function moveFungibleAsset(address _to, uint256 _amount) public;\n",
          "message": "ITwoKeyAcquisitionCampaignERC20.moveFungibleAsset (TwoKeyAcquisitionLogicHandler.sol#143) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 144,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function updateContractorProceeds(uint value) public;\n",
          "message": "ITwoKeyAcquisitionCampaignERC20.updateContractorProceeds (TwoKeyAcquisitionLogicHandler.sol#144) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 145,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function sendBackEthWhenConversionCancelled(address _cancelledConverter, uint _conversionAmount) public;\n",
          "message": "ITwoKeyAcquisitionCampaignERC20.sendBackEthWhenConversionCancelled (TwoKeyAcquisitionLogicHandler.sol#145) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 146,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function buyTokensForModeratorRewards(uint moderatorFee) public;\n",
          "message": "ITwoKeyAcquisitionCampaignERC20.buyTokensForModeratorRewards (TwoKeyAcquisitionLogicHandler.sol#146) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 147,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function updateReservedAmountOfTokensIfConversionRejectedOrExecuted(uint value) public;\n",
          "message": "ITwoKeyAcquisitionCampaignERC20.updateReservedAmountOfTokensIfConversionRejectedOrExecuted (TwoKeyAcquisitionLogicHandler.sol#147) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 149,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getStatistics(address ethereum, address plasma) public view returns (uint,uint,uint,uint);\n",
          "message": "ITwoKeyAcquisitionCampaignERC20.getStatistics (TwoKeyAcquisitionLogicHandler.sol#149) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 151,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getTotalReferrerEarnings(address _referrer, address eth_address) public view returns (uint);\n",
          "message": "ITwoKeyAcquisitionCampaignERC20.getTotalReferrerEarnings (TwoKeyAcquisitionLogicHandler.sol#151) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 152,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getReferrerPlasmaBalance(address _influencer) public view returns (uint);\n",
          "message": "ITwoKeyAcquisitionCampaignERC20.getReferrerPlasmaBalance (TwoKeyAcquisitionLogicHandler.sol#152) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 153,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function updateReferrerPlasmaBalance(address _influencer, uint _balance) public;\n",
          "message": "ITwoKeyAcquisitionCampaignERC20.updateReferrerPlasmaBalance (TwoKeyAcquisitionLogicHandler.sol#153) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 154,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getReferrerCut(address me) public view returns (uint256);\n",
          "message": "ITwoKeyAcquisitionCampaignERC20.getReferrerCut (TwoKeyAcquisitionLogicHandler.sol#154) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 163,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function addTwoKeyEventSource(address _twoKeyEventSource) public;\n",
          "message": "ITwoKeyReg.addTwoKeyEventSource (TwoKeyAcquisitionLogicHandler.sol#163) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 164,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function changeTwoKeyEventSource(address _twoKeyEventSource) public;\n",
          "message": "ITwoKeyReg.changeTwoKeyEventSource (TwoKeyAcquisitionLogicHandler.sol#164) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 165,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function addWhereContractor(address _userAddress, address _contractAddress) public;\n",
          "message": "ITwoKeyReg.addWhereContractor (TwoKeyAcquisitionLogicHandler.sol#165) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 166,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function addWhereModerator(address _userAddress, address _contractAddress) public;\n",
          "message": "ITwoKeyReg.addWhereModerator (TwoKeyAcquisitionLogicHandler.sol#166) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 167,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function addWhereReferrer(address _userAddress, address _contractAddress) public;\n",
          "message": "ITwoKeyReg.addWhereReferrer (TwoKeyAcquisitionLogicHandler.sol#167) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 168,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function addWhereConverter(address _userAddress, address _contractAddress) public;\n",
          "message": "ITwoKeyReg.addWhereConverter (TwoKeyAcquisitionLogicHandler.sol#168) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 169,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getContractsWhereUserIsContractor(address _userAddress) public view returns (address[]);\n",
          "message": "ITwoKeyReg.getContractsWhereUserIsContractor (TwoKeyAcquisitionLogicHandler.sol#169) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 170,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getContractsWhereUserIsModerator(address _userAddress) public view returns (address[]);\n",
          "message": "ITwoKeyReg.getContractsWhereUserIsModerator (TwoKeyAcquisitionLogicHandler.sol#170) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 171,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getContractsWhereUserIsRefferer(address _userAddress) public view returns (address[]);\n",
          "message": "ITwoKeyReg.getContractsWhereUserIsRefferer (TwoKeyAcquisitionLogicHandler.sol#171) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 172,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getContractsWhereUserIsConverter(address _userAddress) public view returns (address[]);\n",
          "message": "ITwoKeyReg.getContractsWhereUserIsConverter (TwoKeyAcquisitionLogicHandler.sol#172) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 173,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getTwoKeyEventSourceAddress() public view returns (address);\n",
          "message": "ITwoKeyReg.getTwoKeyEventSourceAddress (TwoKeyAcquisitionLogicHandler.sol#173) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 174,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function addName(string _name, address _sender, string _fullName, string _email, bytes signature) public;\n",
          "message": "ITwoKeyReg.addName (TwoKeyAcquisitionLogicHandler.sol#174) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 175,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function addNameByUser(string _name) public;\n",
          "message": "ITwoKeyReg.addNameByUser (TwoKeyAcquisitionLogicHandler.sol#175) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 176,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getName2Owner(string _name) public view returns (address);\n",
          "message": "ITwoKeyReg.getName2Owner (TwoKeyAcquisitionLogicHandler.sol#176) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 177,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getOwner2Name(address _sender) public view returns (string);\n",
          "message": "ITwoKeyReg.getOwner2Name (TwoKeyAcquisitionLogicHandler.sol#177) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 178,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getPlasmaToEthereum(address plasma) public view returns (address);\n",
          "message": "ITwoKeyReg.getPlasmaToEthereum (TwoKeyAcquisitionLogicHandler.sol#178) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 179,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getEthereumToPlasma(address ethereum) public view returns (address);\n",
          "message": "ITwoKeyReg.getEthereumToPlasma (TwoKeyAcquisitionLogicHandler.sol#179) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 180,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function checkIfTwoKeyMaintainerExists(address _maintainer) public view returns (bool);\n",
          "message": "ITwoKeyReg.checkIfTwoKeyMaintainerExists (TwoKeyAcquisitionLogicHandler.sol#180) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 192,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getReceivedFrom(address _receiver) public view returns (address);\n",
          "message": "ITwoKeyAcquisitionARC.getReceivedFrom (TwoKeyAcquisitionLogicHandler.sol#192) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 193,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function balanceOf(address _owner) public view returns (uint256);\n",
          "message": "ITwoKeyAcquisitionARC.balanceOf (TwoKeyAcquisitionLogicHandler.sol#193) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 204,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getContractProxyAddress(string _contractName) public view returns (address);\n",
          "message": "ITwoKeySingletoneRegistryFetchAddress.getContractProxyAddress (TwoKeyAcquisitionLogicHandler.sol#204) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 205,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getNonUpgradableContractAddress(string contractName) public view returns (address);\n",
          "message": "ITwoKeySingletoneRegistryFetchAddress.getNonUpgradableContractAddress (TwoKeyAcquisitionLogicHandler.sol#205) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 206,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getLatestContractVersion(string contractName) public view returns (string);\n",
          "message": "ITwoKeySingletoneRegistryFetchAddress.getLatestContractVersion (TwoKeyAcquisitionLogicHandler.sol#206) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 215,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function ethereumOf(address me) public view returns (address);\n",
          "message": "ITwoKeyEventSource.ethereumOf (TwoKeyAcquisitionLogicHandler.sol#215) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 216,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function plasmaOf(address me) public view returns (address);\n",
          "message": "ITwoKeyEventSource.plasmaOf (TwoKeyAcquisitionLogicHandler.sol#216) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 217,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function isAddressMaintainer(address _maintainer) public view returns (bool);\n",
          "message": "ITwoKeyEventSource.isAddressMaintainer (TwoKeyAcquisitionLogicHandler.sol#217) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 218,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getTwoKeyDefaultIntegratorFeeFromAdmin() public view returns (uint);\n",
          "message": "ITwoKeyEventSource.getTwoKeyDefaultIntegratorFeeFromAdmin (TwoKeyAcquisitionLogicHandler.sol#218) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 226,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function onlyMaintainer(address _sender) public view returns (bool);\n",
          "message": "ITwoKeyMaintainersRegistry.onlyMaintainer (TwoKeyAcquisitionLogicHandler.sol#226) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 289,
          "vulnerability_to_line": 315,
          "vulnerability_code": "    function params0(address c, bytes _method) public view returns (uint answer) {\n\n        // https://medium.com/@blockchain101/calling-the-function-of-another-contract-in-solidity-f9edfa921f4c\n\n        //    dc = c;\n\n        bytes4 sig = bytes4(keccak256(_method));\n\n        assembly {\n\n        // move pointer to free memory spot\n\n            let ptr := mload(0x40)\n\n        // put function sig at memory spot\n\n            mstore(ptr,sig)\n\n\n\n            let result := call(  // use WARNING because this should be staticcall BUT geth crash!\n\n            15000, // gas limit\n\n            c, // sload(dc_slot),  // to addr. append var to _slot to access storage variable\n\n            0, // not transfer any ether (comment if using staticcall)\n\n            ptr, // Inputs are stored at location ptr\n\n            0x04, // Inputs are 0 bytes long\n\n            ptr,  //Store output over input\n\n            0x20) //Outputs are 1 bytes long\n\n\n\n            if eq(result, 0) {\n\n                revert(0, 0)\n\n            }\n\n\n\n            answer := mload(ptr) // Assign output to answer var\n\n            mstore(0x40,add(ptr,0x24)) // Set storage pointer to new space\n\n        }\n",
          "message": "Call.params0 (TwoKeyAcquisitionLogicHandler.sol#289-315) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 317,
          "vulnerability_to_line": 345,
          "vulnerability_code": "    function params1(address c, bytes _method, uint _val) public view returns (uint answer) {\n\n        // https://medium.com/@blockchain101/calling-the-function-of-another-contract-in-solidity-f9edfa921f4c\n\n        //    dc = c;\n\n        bytes4 sig = bytes4(keccak256(_method));\n\n        assembly {\n\n        // move pointer to free memory spot\n\n            let ptr := mload(0x40)\n\n        // put function sig at memory spot\n\n            mstore(ptr,sig)\n\n        // append argument after function sig\n\n            mstore(add(ptr,0x04), _val)\n\n\n\n            let result := call(  // use WARNING because this should be staticcall BUT geth crash!\n\n            15000, // gas limit\n\n            c, // sload(dc_slot),  // to addr. append var to _slot to access storage variable\n\n            0, // not transfer any ether (comment if using staticcall)\n\n            ptr, // Inputs are stored at location ptr\n\n            0x24, // Inputs are 0 bytes long\n\n            ptr,  //Store output over input\n\n            0x20) //Outputs are 1 bytes long\n\n\n\n            if eq(result, 0) {\n\n                revert(0, 0)\n\n            }\n\n\n\n            answer := mload(ptr) // Assign output to answer var\n\n            mstore(0x40,add(ptr,0x24)) // Set storage pointer to new space\n\n        }\n",
          "message": "Call.params1 (TwoKeyAcquisitionLogicHandler.sol#317-345) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 347,
          "vulnerability_to_line": 377,
          "vulnerability_code": "    function params2(address c, bytes _method, uint _val1, uint _val2) public view returns (uint answer) {\n\n        // https://medium.com/@blockchain101/calling-the-function-of-another-contract-in-solidity-f9edfa921f4c\n\n        //    dc = c;\n\n        bytes4 sig = bytes4(keccak256(_method));\n\n        assembly {\n\n        // move pointer to free memory spot\n\n            let ptr := mload(0x40)\n\n        // put function sig at memory spot\n\n            mstore(ptr,sig)\n\n        // append argument after function sig\n\n            mstore(add(ptr,0x04), _val1)\n\n            mstore(add(ptr,0x24), _val2)\n\n\n\n            let result := call(  // use WARNING because this should be staticcall BUT geth crash!\n\n            15000, // gas limit\n\n            c, // sload(dc_slot),  // to addr. append var to _slot to access storage variable\n\n            0, // not transfer any ether (comment if using staticcall)\n\n            ptr, // Inputs are stored at location ptr\n\n            0x44, // Inputs are 4 bytes for signature and 2 uint256\n\n            ptr,  //Store output over input\n\n            0x20) //Outputs are 1 uint long\n\n\n\n        // TODO cause revert\n\n        //            if eq(result, 0) {\n\n        //                revert(0, 0)\n\n        //            }\n\n\n\n            answer := mload(ptr) // Assign output to answer var\n\n            mstore(0x40,add(ptr,0x20)) // Set storage pointer to new space\n\n        }\n",
          "message": "Call.params2 (TwoKeyAcquisitionLogicHandler.sol#347-377) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 519,
          "vulnerability_to_line": 544,
          "vulnerability_code": "    function recoverSig(bytes sig, address old_key, address last_address) public pure returns (address[], address[], uint8[]) {\n\n        // validate sig AND\n\n        // recover the information from the signature: influencers, public_link_keys, weights/cuts\n\n        // influencers may have one more address than the keys and weights arrays\n\n        //\n\n        require(old_key != address(0),'no public link key');\n\n\n\n        address[] memory influencers;\n\n        address[] memory keys;\n\n        uint8[] memory weights;\n\n        uint[] memory offsets;\n\n        (influencers, keys, weights, offsets) = recoverSigParts(sig, last_address);\n\n\n\n        // check if we received a valid signature\n\n        for(uint i = 0; i < influencers.length; i++) {\n\n            if (i < weights.length) {\n\n                require (recoverHash(keccak256(abi.encodePacked(weights[i], keys[i], influencers[i])),sig,offsets[i]) == old_key, 'illegal signature');\n\n                old_key = keys[i];\n\n            } else {\n\n                // signed message for the last step is the address of the converter\n\n                require (recoverHash(keccak256(abi.encodePacked(influencers[i])),sig,offsets[i]) == old_key, 'illegal last signature');\n\n            }\n\n        }\n\n\n\n        return (influencers, keys, weights);\n",
          "message": "Call.recoverSig (TwoKeyAcquisitionLogicHandler.sol#519-544) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 674,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function addVersion(string _contractName, string version, address implementation) public;\n",
          "message": "ITwoKeySingletonesRegistry.addVersion (TwoKeyAcquisitionLogicHandler.sol#674) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 682,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getVersion(string _contractName, string version) public view returns (address);\n",
          "message": "ITwoKeySingletonesRegistry.getVersion (TwoKeyAcquisitionLogicHandler.sol#682) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 706,
          "vulnerability_to_line": 708,
          "vulnerability_code": "    function implementation() public view returns (address) {\n\n        return _implementation;\n",
          "message": "UpgradeabilityCampaignStorage.implementation (TwoKeyAcquisitionLogicHandler.sol#706-708) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 795,
          "vulnerability_to_line": 846,
          "vulnerability_code": "    function setInitialParamsLogicHandler(\n\n        uint [] values,\n\n        string _currency,\n\n        address _assetContractERC20,\n\n        address _moderator,\n\n        address _contractor,\n\n        address _acquisitionCampaignAddress,\n\n        address _twoKeySingletoneRegistry,\n\n        address _twoKeyConversionHandler\n\n    )\n\n    public\n\n    {\n\n        require(values[1] >= values[0], \"max contribution criteria not satisfied\");\n\n        require(values[4] > values[3], \"campaign start time can't be greater than end time\");\n\n        require(isCampaignInitialized == false);\n\n\n\n        if(values[0] == values[1]) {\n\n            isFixedInvestmentAmount = true;\n\n        }\n\n\n\n        minContributionETHorFiatCurrency = values[0];\n\n        maxContributionETHorFiatCurrency = values[1];\n\n        pricePerUnitInETHWeiOrUSD = values[2];\n\n        campaignStartTime = values[3];\n\n        campaignEndTime = values[4];\n\n        maxConverterBonusPercent = values[5];\n\n\n\n        //Add as 6th argument incentive model uint\n\n        incentiveModel = IncentiveModel(values[6]);\n\n        if(values[7] == 1) {\n\n            isAcceptingFiatOnly = true;\n\n        }\n\n\n\n        campaignHardCapWei = values[8];\n\n\n\n        currency = _currency;\n\n        assetContractERC20 = _assetContractERC20;\n\n        moderator = _moderator;\n\n        contractor = _contractor;\n\n        unit_decimals = IERC20(_assetContractERC20).decimals();\n\n\n\n        twoKeyAcquisitionCampaign = _acquisitionCampaignAddress;\n\n        twoKeySingletoneRegistry = _twoKeySingletoneRegistry;\n\n\n\n        twoKeyRegistry = ITwoKeySingletoneRegistryFetchAddress(twoKeySingletoneRegistry).getContractProxyAddress(\"TwoKeyRegistry\");\n\n        twoKeyMaintainersRegistry = ITwoKeySingletoneRegistryFetchAddress(twoKeySingletoneRegistry).getContractProxyAddress(\"TwoKeyMaintainersRegistry\");\n\n\n\n        ownerPlasma = plasmaOf(contractor);\n\n        twoKeyConversionHandler = _twoKeyConversionHandler;\n\n\n\n        isCampaignInitialized = true;\n",
          "message": "TwoKeyAcquisitionLogicHandler.setInitialParamsLogicHandler (TwoKeyAcquisitionLogicHandler.sol#795-846) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 851,
          "vulnerability_to_line": 857,
          "vulnerability_code": "    function activateCampaign() public onlyContractor {\n\n        require(IS_CAMPAIGN_ACTIVE == false);\n\n        uint balanceOfTokenBeingSoldOnAcquisition = getInventoryBalance();\n\n        //balance is in weis, price is in weis and hardcap is regular number\n\n        require((balanceOfTokenBeingSoldOnAcquisition * pricePerUnitInETHWeiOrUSD).div(10**18) >= campaignHardCapWei);\n\n        IS_CAMPAIGN_ACTIVE = true;\n",
          "message": "TwoKeyAcquisitionLogicHandler.activateCampaign (TwoKeyAcquisitionLogicHandler.sol#851-857) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 876,
          "vulnerability_to_line": 892,
          "vulnerability_code": "    function canConversionBeCreated(address converter, uint amountWillingToSpend, bool isFiat) public view returns (bool) {\n\n        bool canConvert = checkIsCampaignActive();\n\n        if(IS_CAMPAIGN_ACTIVE == false) {\n\n            return false;\n\n        }\n\n        if(canConvert == false) {\n\n            return false;\n\n        }\n\n        //If we reach this point means we have reached point that campaign is still active\n\n        if(isFiat) {\n\n            (canConvert,)= canMakeFiatConversion(converter, amountWillingToSpend);\n\n        } else {\n\n            (canConvert,) = canMakeETHConversion(converter, amountWillingToSpend);\n\n        }\n\n\n\n        return canConvert;\n",
          "message": "TwoKeyAcquisitionLogicHandler.canConversionBeCreated (TwoKeyAcquisitionLogicHandler.sol#876-892) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 958,
          "vulnerability_to_line": 964,
          "vulnerability_code": "    function getInvestmentRules()\n\n    public\n\n    view\n\n    returns (bool,uint,uint)\n\n    {\n\n        return (isFixedInvestmentAmount, minContributionETHorFiatCurrency, maxContributionETHorFiatCurrency);\n",
          "message": "TwoKeyAcquisitionLogicHandler.getInvestmentRules (TwoKeyAcquisitionLogicHandler.sol#958-964) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 973,
          "vulnerability_to_line": 1000,
          "vulnerability_code": "    function getEstimatedTokenAmount(\n\n        uint conversionAmountETHWeiOrFiat,\n\n        bool isFiatConversion\n\n    )\n\n    public\n\n    view\n\n    returns (uint, uint)\n\n    {\n\n        uint value = pricePerUnitInETHWeiOrUSD;\n\n        uint baseTokensForConverterUnits;\n\n        uint bonusTokensForConverterUnits;\n\n        if(isFiatConversion == true) {\n\n            baseTokensForConverterUnits = conversionAmountETHWeiOrFiat.mul(10**18).div(value);\n\n            bonusTokensForConverterUnits = baseTokensForConverterUnits.mul(maxConverterBonusPercent).div(100);\n\n            return (baseTokensForConverterUnits, bonusTokensForConverterUnits);\n\n        } else {\n\n            if(keccak256(currency) != keccak256('ETH')) {\n\n                address ethUSDExchangeContract = ITwoKeySingletoneRegistryFetchAddress(twoKeySingletoneRegistry).getContractProxyAddress(\"TwoKeyExchangeRateContract\");\n\n                uint rate = ITwoKeyExchangeRateContract(ethUSDExchangeContract).getBaseToTargetRate(currency);\n\n\n\n                conversionAmountETHWeiOrFiat = (conversionAmountETHWeiOrFiat.mul(rate)).div(10 ** 18); //converting eth to $wei\n\n            }\n\n        }\n\n\n\n        baseTokensForConverterUnits = conversionAmountETHWeiOrFiat.mul(10 ** unit_decimals).div(value);\n\n        bonusTokensForConverterUnits = baseTokensForConverterUnits.mul(maxConverterBonusPercent).div(100);\n\n        return (baseTokensForConverterUnits, bonusTokensForConverterUnits);\n",
          "message": "TwoKeyAcquisitionLogicHandler.getEstimatedTokenAmount (TwoKeyAcquisitionLogicHandler.sol#973-1000) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 1007,
          "vulnerability_to_line": 1014,
          "vulnerability_code": "    function updateMinContributionETHOrUSD(\n\n        uint value\n\n    )\n\n    public\n\n    onlyContractor\n\n    {\n\n        minContributionETHorFiatCurrency = value;\n",
          "message": "TwoKeyAcquisitionLogicHandler.updateMinContributionETHOrUSD (TwoKeyAcquisitionLogicHandler.sol#1007-1014) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 1034,
          "vulnerability_to_line": 1048,
          "vulnerability_code": "    function getConstantInfo()\n\n    public\n\n    view\n\n    returns (uint,uint,uint,uint,uint,uint,uint)\n\n    {\n\n        return (\n\n            campaignStartTime,\n\n            campaignEndTime,\n\n            minContributionETHorFiatCurrency,\n\n            maxContributionETHorFiatCurrency,\n\n            unit_decimals,\n\n            pricePerUnitInETHWeiOrUSD,\n\n            maxConverterBonusPercent\n\n        );\n",
          "message": "TwoKeyAcquisitionLogicHandler.getConstantInfo (TwoKeyAcquisitionLogicHandler.sol#1034-1048) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 1163,
          "vulnerability_to_line": 1195,
          "vulnerability_code": "    function getSuperStatistics(\n\n        address _user,\n\n        bool plasma,\n\n        bytes signature\n\n    )\n\n    public\n\n    view\n\n    returns (bytes)\n\n    {\n\n        address eth_address = _user;\n\n\n\n        if (plasma) {\n\n            (eth_address) = ITwoKeyReg(twoKeyRegistry).getPlasmaToEthereum(_user);\n\n        }\n\n\n\n        bytes memory userData = ITwoKeyReg(twoKeyRegistry).getUserData(eth_address);\n\n\n\n        bool isJoined = getAddressJoinedStatus(_user);\n\n        bool flag;\n\n\n\n        address _address;\n\n\n\n        if(msg.sender == contractor || msg.sender == eth_address) {\n\n            flag = true;\n\n        } else {\n\n            _address = recover(signature);\n\n            if(_address == ownerPlasma) {\n\n                flag = true;\n\n            }\n\n        }\n\n        bytes memory stats = getAddressStatistic(_user, plasma, flag, _address);\n\n        return abi.encodePacked(userData, isJoined, eth_address, stats);\n",
          "message": "TwoKeyAcquisitionLogicHandler.getSuperStatistics (TwoKeyAcquisitionLogicHandler.sol#1163-1195) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 1247,
          "vulnerability_to_line": 1311,
          "vulnerability_code": "    function updateRefchainRewards(\n\n        uint256 _maxReferralRewardETHWei,\n\n        address _converter,\n\n        uint _conversionId,\n\n        uint totalBounty2keys\n\n    )\n\n    public\n\n    {\n\n        require(msg.sender == twoKeyAcquisitionCampaign);\n\n\n\n        //Get all the influencers\n\n        address[] memory influencers = getReferrers(_converter,twoKeyAcquisitionCampaign);\n\n\n\n        //Get array length\n\n        uint numberOfInfluencers = influencers.length;\n\n\n\n        uint i;\n\n        uint reward;\n\n        if(incentiveModel == IncentiveModel.VANILLA_AVERAGE) {\n\n            reward = IncentiveModels.averageModelRewards(totalBounty2keys, numberOfInfluencers);\n\n            for(i=0; i<numberOfInfluencers; i++) {\n\n                updateReferrerMappings(influencers[i], reward, _conversionId);\n\n\n\n            }\n\n        } else if (incentiveModel == IncentiveModel.VANILLA_AVERAGE_LAST_3X) {\n\n            uint rewardForLast;\n\n            // Calculate reward for regular ones and for the last\n\n            (reward, rewardForLast) = IncentiveModels.averageLast3xRewards(totalBounty2keys, numberOfInfluencers);\n\n\n\n            //Update equal rewards to all influencers but last\n\n            for(i=0; i<numberOfInfluencers - 1; i++) {\n\n                updateReferrerMappings(influencers[i], reward, _conversionId);\n\n\n\n            }\n\n            //Update reward for last\n\n            updateReferrerMappings(influencers[numberOfInfluencers-1], rewardForLast, _conversionId);\n\n        } else if(incentiveModel == IncentiveModel.VANILLA_POWER_LAW) {\n\n            // Get rewards per referrer\n\n            uint [] memory rewards = IncentiveModels.powerLawRewards(totalBounty2keys, numberOfInfluencers, 2);\n\n            //Iterate through all referrers and distribute rewards\n\n            for(i=0; i<numberOfInfluencers; i++) {\n\n                updateReferrerMappings(influencers[i], rewards[i], _conversionId);\n\n            }\n\n        } else if(incentiveModel == IncentiveModel.MANUAL) {\n\n            for (i = 0; i < numberOfInfluencers; i++) {\n\n                uint256 b;\n\n\n\n                if (i == influencers.length - 1) {  // if its the last influencer then all the bounty goes to it.\n\n                    b = totalBounty2keys;\n\n                }\n\n                else {\n\n                    uint256 cut = ITwoKeyAcquisitionCampaignERC20(twoKeyAcquisitionCampaign).getReferrerCut(influencers[i]);\n\n                    if (cut > 0 && cut <= 101) {\n\n                        b = totalBounty2keys.mul(cut.sub(1)).div(100);\n\n                    } else {// cut == 0 or 255 indicates equal particine of the bounty\n\n                        b = totalBounty2keys.div(influencers.length - i);\n\n                    }\n\n                }\n\n\n\n                updateReferrerMappings(influencers[i], b, _conversionId);\n\n                //Decrease bounty for distributed\n\n                totalBounty2keys = totalBounty2keys.sub(b);\n\n            }\n\n        }\n",
          "message": "TwoKeyAcquisitionLogicHandler.updateRefchainRewards (TwoKeyAcquisitionLogicHandler.sol#1247-1311) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 1343,
          "vulnerability_to_line": 1362,
          "vulnerability_code": "    function getReferrersBalancesAndTotalEarnings(\n\n        address[] _referrerPlasmaList\n\n    )\n\n    public\n\n    view\n\n    returns (uint256[], uint256[])\n\n    {\n\n        require(ITwoKeyMaintainersRegistry(twoKeyMaintainersRegistry).onlyMaintainer(msg.sender));\n\n\n\n        uint numberOfAddresses = _referrerPlasmaList.length;\n\n        uint256[] memory referrersPendingPlasmaBalance = new uint256[](numberOfAddresses);\n\n        uint256[] memory referrersTotalEarningsPlasmaBalance = new uint256[](numberOfAddresses);\n\n\n\n        for (uint i=0; i<numberOfAddresses; i++){\n\n            referrersPendingPlasmaBalance[i] = ITwoKeyAcquisitionCampaignERC20(twoKeyAcquisitionCampaign).getReferrerPlasmaBalance(_referrerPlasmaList[i]);\n\n            referrersTotalEarningsPlasmaBalance[i] = referrerPlasma2TotalEarnings2key[_referrerPlasmaList[i]];\n\n        }\n\n\n\n        return (referrersPendingPlasmaBalance, referrersTotalEarningsPlasmaBalance);\n",
          "message": "TwoKeyAcquisitionLogicHandler.getReferrersBalancesAndTotalEarnings (TwoKeyAcquisitionLogicHandler.sol#1343-1362) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 1373,
          "vulnerability_to_line": 1400,
          "vulnerability_code": "    function getReferrerBalanceAndTotalEarningsAndNumberOfConversions(\n\n        address _referrer,\n\n        bytes signature,\n\n        uint[] conversionIds\n\n    )\n\n    public\n\n    view\n\n    returns (uint,uint,uint,uint[])\n\n    {\n\n        if(_referrer != address(0)) {\n\n            require(msg.sender == _referrer || msg.sender == contractor || ITwoKeyMaintainersRegistry(twoKeyMaintainersRegistry).onlyMaintainer(msg.sender));\n\n            _referrer = plasmaOf(_referrer);\n\n        } else {\n\n            bytes32 hash = keccak256(abi.encodePacked(keccak256(abi.encodePacked(\"bytes binding referrer to plasma\")),\n\n                keccak256(abi.encodePacked(\"GET_REFERRER_REWARDS\"))));\n\n            _referrer = Call.recoverHash(hash, signature, 0);\n\n        }\n\n\n\n        uint len = conversionIds.length;\n\n        uint[] memory earnings = new uint[](len);\n\n\n\n        for(uint i=0; i<len; i++) {\n\n            earnings[i] = referrerPlasma2EarningsPerConversion[_referrer][conversionIds[i]];\n\n        }\n\n\n\n        uint referrerBalance = ITwoKeyAcquisitionCampaignERC20(twoKeyAcquisitionCampaign).getReferrerPlasmaBalance(_referrer);\n\n        return (referrerBalance, referrerPlasma2TotalEarnings2key[_referrer], referrerPlasmaAddressToCounterOfConversions[_referrer], earnings);\n",
          "message": "TwoKeyAcquisitionLogicHandler.getReferrerBalanceAndTotalEarningsAndNumberOfConversions (TwoKeyAcquisitionLogicHandler.sol#1373-1400) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 1403,
          "vulnerability_to_line": 1412,
          "vulnerability_code": "    function getReferrerPlasmaTotalEarnings(\n\n        address _referrer\n\n    )\n\n    public\n\n    view\n\n    returns (uint)\n\n    {\n\n        require(msg.sender == twoKeyAcquisitionCampaign);\n\n        return referrerPlasma2TotalEarnings2key[_referrer];\n",
          "message": "TwoKeyAcquisitionLogicHandler.getReferrerPlasmaTotalEarnings (TwoKeyAcquisitionLogicHandler.sol#1403-1412) should be declared external\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 151,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getTotalReferrerEarnings(address _referrer, address eth_address) public view returns (uint);\n",
          "message": "Parameter 'eth_address' of ITwoKeyAcquisitionCampaignERC20.getTotalReferrerEarnings (TwoKeyAcquisitionLogicHandler.sol#151) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 243,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n",
          "message": "Parameter '_a' of SafeMath.mul (TwoKeyAcquisitionLogicHandler.sol#243) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 243,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n",
          "message": "Parameter '_b' of SafeMath.mul (TwoKeyAcquisitionLogicHandler.sol#243) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 259,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n",
          "message": "Parameter '_a' of SafeMath.div (TwoKeyAcquisitionLogicHandler.sol#259) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 259,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n",
          "message": "Parameter '_b' of SafeMath.div (TwoKeyAcquisitionLogicHandler.sol#259) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 269,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n",
          "message": "Parameter '_a' of SafeMath.sub (TwoKeyAcquisitionLogicHandler.sol#269) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 269,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n",
          "message": "Parameter '_b' of SafeMath.sub (TwoKeyAcquisitionLogicHandler.sol#269) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 277,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n",
          "message": "Parameter '_a' of SafeMath.add (TwoKeyAcquisitionLogicHandler.sol#277) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 277,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n",
          "message": "Parameter '_b' of SafeMath.add (TwoKeyAcquisitionLogicHandler.sol#277) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 289,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function params0(address c, bytes _method) public view returns (uint answer) {\n",
          "message": "Parameter '_method' of Call.params0 (TwoKeyAcquisitionLogicHandler.sol#289) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 317,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function params1(address c, bytes _method, uint _val) public view returns (uint answer) {\n",
          "message": "Parameter '_method' of Call.params1 (TwoKeyAcquisitionLogicHandler.sol#317) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 347,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function params2(address c, bytes _method, uint _val1, uint _val2) public view returns (uint answer) {\n",
          "message": "Parameter '_method' of Call.params2 (TwoKeyAcquisitionLogicHandler.sol#347) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 452,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function recoverSigParts(bytes sig, address last_address) private pure returns (address[], address[], uint8[], uint[]) {\n",
          "message": "Parameter 'last_address' of Call.recoverSigParts (TwoKeyAcquisitionLogicHandler.sol#452) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 519,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function recoverSig(bytes sig, address old_key, address last_address) public pure returns (address[], address[], uint8[]) {\n",
          "message": "Parameter 'old_key' of Call.recoverSig (TwoKeyAcquisitionLogicHandler.sol#519) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 519,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function recoverSig(bytes sig, address old_key, address last_address) public pure returns (address[], address[], uint8[]) {\n",
          "message": "Parameter 'last_address' of Call.recoverSig (TwoKeyAcquisitionLogicHandler.sol#519) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 700,
          "vulnerability_to_line": null,
          "vulnerability_code": "    address internal _implementation;\n",
          "message": "Variable 'UpgradeabilityCampaignStorage._implementation' (TwoKeyAcquisitionLogicHandler.sol#700) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 797,
          "vulnerability_to_line": null,
          "vulnerability_code": "        string _currency,\n",
          "message": "Parameter '_currency' of TwoKeyAcquisitionLogicHandler.setInitialParamsLogicHandler (TwoKeyAcquisitionLogicHandler.sol#797) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 798,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address _assetContractERC20,\n",
          "message": "Parameter '_assetContractERC20' of TwoKeyAcquisitionLogicHandler.setInitialParamsLogicHandler (TwoKeyAcquisitionLogicHandler.sol#798) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 799,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address _moderator,\n",
          "message": "Parameter '_moderator' of TwoKeyAcquisitionLogicHandler.setInitialParamsLogicHandler (TwoKeyAcquisitionLogicHandler.sol#799) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 800,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address _contractor,\n",
          "message": "Parameter '_contractor' of TwoKeyAcquisitionLogicHandler.setInitialParamsLogicHandler (TwoKeyAcquisitionLogicHandler.sol#800) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 801,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address _acquisitionCampaignAddress,\n",
          "message": "Parameter '_acquisitionCampaignAddress' of TwoKeyAcquisitionLogicHandler.setInitialParamsLogicHandler (TwoKeyAcquisitionLogicHandler.sol#801) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 802,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address _twoKeySingletoneRegistry,\n",
          "message": "Parameter '_twoKeySingletoneRegistry' of TwoKeyAcquisitionLogicHandler.setInitialParamsLogicHandler (TwoKeyAcquisitionLogicHandler.sol#802) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 803,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address _twoKeyConversionHandler\n",
          "message": "Parameter '_twoKeyConversionHandler' of TwoKeyAcquisitionLogicHandler.setInitialParamsLogicHandler (TwoKeyAcquisitionLogicHandler.sol#803) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1071,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address _address\n",
          "message": "Parameter '_address' of TwoKeyAcquisitionLogicHandler.getAddressJoinedStatus (TwoKeyAcquisitionLogicHandler.sol#1071) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1095,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address _address,\n",
          "message": "Parameter '_address' of TwoKeyAcquisitionLogicHandler.getAddressStatistic (TwoKeyAcquisitionLogicHandler.sol#1095) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1164,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address _user,\n",
          "message": "Parameter '_user' of TwoKeyAcquisitionLogicHandler.getSuperStatistics (TwoKeyAcquisitionLogicHandler.sol#1164) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1249,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address _converter,\n",
          "message": "Parameter '_converter' of TwoKeyAcquisitionLogicHandler.updateRefchainRewards (TwoKeyAcquisitionLogicHandler.sol#1249) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1250,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint _conversionId,\n",
          "message": "Parameter '_conversionId' of TwoKeyAcquisitionLogicHandler.updateRefchainRewards (TwoKeyAcquisitionLogicHandler.sol#1250) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1344,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address[] _referrerPlasmaList\n",
          "message": "Parameter '_referrerPlasmaList' of TwoKeyAcquisitionLogicHandler.getReferrersBalancesAndTotalEarnings (TwoKeyAcquisitionLogicHandler.sol#1344) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1374,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address _referrer,\n",
          "message": "Parameter '_referrer' of TwoKeyAcquisitionLogicHandler.getReferrerBalanceAndTotalEarningsAndNumberOfConversions (TwoKeyAcquisitionLogicHandler.sol#1374) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1404,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address _referrer\n",
          "message": "Parameter '_referrer' of TwoKeyAcquisitionLogicHandler.getReferrerPlasmaTotalEarnings (TwoKeyAcquisitionLogicHandler.sol#1404) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 752,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bool public IS_CAMPAIGN_ACTIVE;\n",
          "message": "Variable 'TwoKeyAcquisitionLogicHandler.IS_CAMPAIGN_ACTIVE' (TwoKeyAcquisitionLogicHandler.sol#752) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 775,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint unit_decimals; // ERC20 selling data\n",
          "message": "Variable 'TwoKeyAcquisitionLogicHandler.unit_decimals' (TwoKeyAcquisitionLogicHandler.sol#775) is not in mixedCase\n"
        },
        {
          "name": "unused-state",
          "vulnerability_from_line": 695,
          "vulnerability_to_line": null,
          "vulnerability_code": "    ITwoKeySingletonesRegistry internal registry;\n",
          "message": "UpgradeabilityCampaignStorage.registry (TwoKeyAcquisitionLogicHandler.sol#695) is never used in TwoKeyAcquisitionLogicHandler\nUpgradeabilityCampaignStorage.twoKeyFactory (TwoKeyAcquisitionLogicHandler.sol#697) is never used in TwoKeyAcquisitionLogicHandler\n"
        }
      ]
    },
    "smartcheck": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 533,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(uint i = 0; i < influencers.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 478,
          "vulnerability_to_line": null,
          "vulnerability_code": "        while (idx + 65 <= sig.length) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
          "vulnerability_from_line": 289,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function params0(address c, bytes _method) public view returns (uint answer) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
          "vulnerability_from_line": 317,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function params1(address c, bytes _method, uint _val) public view returns (uint answer) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
          "vulnerability_from_line": 347,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function params2(address c, bytes _method, uint _val1, uint _val2) public view returns (uint answer) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 533,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(uint i = 0; i < influencers.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 1267,
          "vulnerability_to_line": null,
          "vulnerability_code": "            for(i=0; i<numberOfInfluencers; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 1287,
          "vulnerability_to_line": null,
          "vulnerability_code": "            for(i=0; i<numberOfInfluencers; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 1291,
          "vulnerability_to_line": null,
          "vulnerability_code": "            for (i = 0; i < numberOfInfluencers; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 1356,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i=0; i<numberOfAddresses; i++){\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 1394,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(uint i=0; i<len; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 478,
          "vulnerability_to_line": null,
          "vulnerability_code": "        while (idx + 65 <= sig.length) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 1214,
          "vulnerability_to_line": null,
          "vulnerability_code": "        while (true) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.24;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 15,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.24;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 82,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.24;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 136,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.24;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 159,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.24;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 186,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.24;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 198,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.24;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 211,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.24;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 223,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.24;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 231,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.24;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 286,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.24;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 549,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.24;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 636,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.24;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 647,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.24;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 687,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.24;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 713,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.24;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 726,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.24;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SAFEMATH",
          "vulnerability_from_line": 748,
          "vulnerability_to_line": null,
          "vulnerability_code": "    using SafeMath for uint256;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 379,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function loadAddress(bytes sig, uint idx) public pure returns (address) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 389,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function loadUint8(bytes sig, uint idx) public pure returns (uint8) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 400,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function recoverHash(bytes32 hash, bytes sig, uint idx) public pure returns (address) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
          "vulnerability_from_line": 289,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function params0(address c, bytes _method) public view returns (uint answer) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
          "vulnerability_from_line": 317,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function params1(address c, bytes _method, uint _val) public view returns (uint answer) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
          "vulnerability_from_line": 347,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function params2(address c, bytes _method, uint _val1, uint _val2) public view returns (uint answer) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 437,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function recoverSigMemory(bytes sig) private pure returns (address[], address[], uint8[], uint[], uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 452,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function recoverSigParts(bytes sig, address last_address) private pure returns (address[], address[], uint8[], uint[]) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 582,
          "vulnerability_to_line": null,
          "vulnerability_code": "    ) internal pure returns (uint,uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 896,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function canMakeFiatConversion(address converter, uint amountWillingToSpendFiatWei) internal view returns (bool,uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 10,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getBaseToTargetRate(string _currency) public view returns (uint);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 169,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getContractsWhereUserIsContractor(address _userAddress) public view returns (address[]);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 170,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getContractsWhereUserIsModerator(address _userAddress) public view returns (address[]);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 171,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getContractsWhereUserIsRefferer(address _userAddress) public view returns (address[]);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 172,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getContractsWhereUserIsConverter(address _userAddress) public view returns (address[]);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 174,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function addName(string _name, address _sender, string _fullName, string _email, bytes signature) public;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 174,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function addName(string _name, address _sender, string _fullName, string _email, bytes signature) public;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 174,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function addName(string _name, address _sender, string _fullName, string _email, bytes signature) public;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 174,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function addName(string _name, address _sender, string _fullName, string _email, bytes signature) public;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 175,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function addNameByUser(string _name) public;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 176,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getName2Owner(string _name) public view returns (address);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 177,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getOwner2Name(address _sender) public view returns (string);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 204,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getContractProxyAddress(string _contractName) public view returns (address);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 205,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getNonUpgradableContractAddress(string contractName) public view returns (address);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 206,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getLatestContractVersion(string contractName) public view returns (string);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 206,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getLatestContractVersion(string contractName) public view returns (string);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 289,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function params0(address c, bytes _method) public view returns (uint answer) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 317,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function params1(address c, bytes _method, uint _val) public view returns (uint answer) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 347,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function params2(address c, bytes _method, uint _val1, uint _val2) public view returns (uint answer) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 379,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function loadAddress(bytes sig, uint idx) public pure returns (address) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 389,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function loadUint8(bytes sig, uint idx) public pure returns (uint8) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 400,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function recoverHash(bytes32 hash, bytes sig, uint idx) public pure returns (address) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 437,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function recoverSigMemory(bytes sig) private pure returns (address[], address[], uint8[], uint[], uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 437,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function recoverSigMemory(bytes sig) private pure returns (address[], address[], uint8[], uint[], uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 437,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function recoverSigMemory(bytes sig) private pure returns (address[], address[], uint8[], uint[], uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 437,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function recoverSigMemory(bytes sig) private pure returns (address[], address[], uint8[], uint[], uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 437,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function recoverSigMemory(bytes sig) private pure returns (address[], address[], uint8[], uint[], uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 452,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function recoverSigParts(bytes sig, address last_address) private pure returns (address[], address[], uint8[], uint[]) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 452,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function recoverSigParts(bytes sig, address last_address) private pure returns (address[], address[], uint8[], uint[]) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 452,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function recoverSigParts(bytes sig, address last_address) private pure returns (address[], address[], uint8[], uint[]) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 452,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function recoverSigParts(bytes sig, address last_address) private pure returns (address[], address[], uint8[], uint[]) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 452,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function recoverSigParts(bytes sig, address last_address) private pure returns (address[], address[], uint8[], uint[]) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 519,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function recoverSig(bytes sig, address old_key, address last_address) public pure returns (address[], address[], uint8[]) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 519,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function recoverSig(bytes sig, address old_key, address last_address) public pure returns (address[], address[], uint8[]) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 519,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function recoverSig(bytes sig, address old_key, address last_address) public pure returns (address[], address[], uint8[]) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 519,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function recoverSig(bytes sig, address old_key, address last_address) public pure returns (address[], address[], uint8[]) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 601,
          "vulnerability_to_line": null,
          "vulnerability_code": "    ) internal pure returns (uint[]) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 674,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function addVersion(string _contractName, string version, address implementation) public;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 674,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function addVersion(string _contractName, string version, address implementation) public;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 682,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getVersion(string _contractName, string version) public view returns (address);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 682,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getVersion(string _contractName, string version) public view returns (address);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 796,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint [] values,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 797,
          "vulnerability_to_line": null,
          "vulnerability_code": "        string _currency,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 1102,
          "vulnerability_to_line": null,
          "vulnerability_code": "    returns (bytes)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 1145,
          "vulnerability_to_line": null,
          "vulnerability_code": "        bytes signature\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 1166,
          "vulnerability_to_line": null,
          "vulnerability_code": "        bytes signature\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 1170,
          "vulnerability_to_line": null,
          "vulnerability_code": "    returns (bytes)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 1209,
          "vulnerability_to_line": null,
          "vulnerability_code": "    returns (address[])\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 1344,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address[] _referrerPlasmaList\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 1348,
          "vulnerability_to_line": null,
          "vulnerability_code": "    returns (uint256[], uint256[])\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 1348,
          "vulnerability_to_line": null,
          "vulnerability_code": "    returns (uint256[], uint256[])\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 1375,
          "vulnerability_to_line": null,
          "vulnerability_code": "        bytes signature,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 1376,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint[] conversionIds\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 1380,
          "vulnerability_to_line": null,
          "vulnerability_code": "    returns (uint,uint,uint,uint[])\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 293,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 321,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 351,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 382,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 392,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 408,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 415,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 422,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 674,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function addVersion(string _contractName, string version, address implementation) public;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 682,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getVersion(string _contractName, string version) public view returns (address);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 750,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bool isCampaignInitialized;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 759,
          "vulnerability_to_line": null,
          "vulnerability_code": "    address twoKeyRegistry;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 760,
          "vulnerability_to_line": null,
          "vulnerability_code": "    address twoKeyMaintainersRegistry;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 762,
          "vulnerability_to_line": null,
          "vulnerability_code": "    address assetContractERC20;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 763,
          "vulnerability_to_line": null,
          "vulnerability_code": "    address contractor;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 764,
          "vulnerability_to_line": null,
          "vulnerability_code": "    address moderator;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 767,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bool isFixedInvestmentAmount; // This means that minimal contribution is equal maximal contribution\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 768,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bool isAcceptingFiatOnly; // Means that only fiat conversions will be able to execute -> no referral rewards at all\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 770,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint campaignStartTime; // Time when campaign start\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 771,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint campaignEndTime; // Time when campaign ends\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 772,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint minContributionETHorFiatCurrency; //Minimal contribution\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 773,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint maxContributionETHorFiatCurrency; //Maximal contribution\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 774,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint pricePerUnitInETHWeiOrUSD; // There's single price for the unit ERC20 (Should be in WEI)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 775,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint unit_decimals; // ERC20 selling data\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 776,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint maxConverterBonusPercent; // Maximal bonus percent per converter\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 777,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint campaignHardCapWei; // Hard cap of campaign\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 782,
          "vulnerability_to_line": null,
          "vulnerability_code": "    IncentiveModel incentiveModel;\n",
          "message": null
        }
      ]
    },
    "oyente": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "Integer Overflow",
          "vulnerability_from_line": 389,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function loadUint8(bytes sig, uint idx) public pure returns (uint8) {\n",
          "message": null
        }
      ]
    },
    "mythril": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "Integer Arithmetic Bugs (SWC 101)",
          "vulnerability_from_line": 289,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function params0(address c, bytes _method) public view returns (uint answer) {\n",
          "message": "The arithmetic operator can overflow.\nIt is possible to cause an integer overflow or underflow in the arithmetic operation. \nClassification: SWC-101"
        },
        {
          "name": "Integer Arithmetic Bugs (SWC 101)",
          "vulnerability_from_line": 317,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function params1(address c, bytes _method, uint _val) public view returns (uint answer) {\n",
          "message": "The arithmetic operator can overflow.\nIt is possible to cause an integer overflow or underflow in the arithmetic operation. \nClassification: SWC-101"
        },
        {
          "name": "Integer Arithmetic Bugs (SWC 101)",
          "vulnerability_from_line": 347,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function params2(address c, bytes _method, uint _val1, uint _val2) public view returns (uint answer) {\n",
          "message": "The arithmetic operator can overflow.\nIt is possible to cause an integer overflow or underflow in the arithmetic operation. \nClassification: SWC-101"
        },
        {
          "name": "Integer Arithmetic Bugs (SWC 101)",
          "vulnerability_from_line": 519,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function recoverSig(bytes sig, address old_key, address last_address) public pure returns (address[], address[], uint8[]) {\n",
          "message": "The arithmetic operator can overflow.\nIt is possible to cause an integer overflow or underflow in the arithmetic operation. \nClassification: SWC-101"
        },
        {
          "name": "External Call To User-Supplied Address (SWC 107)",
          "vulnerability_from_line": 299,
          "vulnerability_to_line": null,
          "vulnerability_code": "            let result := call(  // use WARNING because this should be staticcall BUT geth crash!\n",
          "message": "A call to a user-supplied address is executed.\nAn external message call to an address specified by the caller is executed. Note that the callee account might contain arbitrary code and could re-enter any function within this contract. Reentering the contract in an intermediate state may lead to unexpected behaviour. Make sure that no state modifications are executed after this call and/or reentrancy guards are in place.\nClassification: SWC-107"
        },
        {
          "name": "External Call To User-Supplied Address (SWC 107)",
          "vulnerability_from_line": 329,
          "vulnerability_to_line": null,
          "vulnerability_code": "            let result := call(  // use WARNING because this should be staticcall BUT geth crash!\n",
          "message": "A call to a user-supplied address is executed.\nAn external message call to an address specified by the caller is executed. Note that the callee account might contain arbitrary code and could re-enter any function within this contract. Reentering the contract in an intermediate state may lead to unexpected behaviour. Make sure that no state modifications are executed after this call and/or reentrancy guards are in place.\nClassification: SWC-107"
        },
        {
          "name": "External Call To User-Supplied Address (SWC 107)",
          "vulnerability_from_line": 360,
          "vulnerability_to_line": null,
          "vulnerability_code": "            let result := call(  // use WARNING because this should be staticcall BUT geth crash!\n",
          "message": "A call to a user-supplied address is executed.\nAn external message call to an address specified by the caller is executed. Note that the callee account might contain arbitrary code and could re-enter any function within this contract. Reentering the contract in an intermediate state may lead to unexpected behaviour. Make sure that no state modifications are executed after this call and/or reentrancy guards are in place.\nClassification: SWC-107"
        },
        {
          "name": "Unchecked return value from external call. (SWC 104)",
          "vulnerability_from_line": 360,
          "vulnerability_to_line": null,
          "vulnerability_code": "            let result := call(  // use WARNING because this should be staticcall BUT geth crash!\n",
          "message": "The return value of a message call is not checked.\nExternal calls return a boolean value. If the callee halts with an exception, 'false' is returned and execution continues in the caller. The caller should check whether an exception happened and react accordingly to avoid unexpected behavior. For example it is often desirable to wrap external calls in require() so the transaction is reverted if the call fails.\nClassification: SWC-104"
        },
        {
          "name": "Jump to an arbitrary instruction (SWC 127)",
          "vulnerability_from_line": 400,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function recoverHash(bytes32 hash, bytes sig, uint idx) public pure returns (address) {\n",
          "message": "The caller can redirect execution to arbitrary bytecode locations.\nIt is possible to redirect the control flow to arbitrary locations in the code. This may allow an attacker to bypass security controls or manipulate the business logic of the smart contract. Avoid using low-level-operations and assembly to prevent this issue.\nClassification: SWC-127"
        }
      ]
    },
    "osiris": {
      "successfull_analysis": true,
      "errors": [
        "DOCKER_TIMEOUT"
      ],
      "vulnerability_findings": [
        {
          "name": "Overflow bugs",
          "vulnerability_from_line": 405,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require (sig.length >= 65+idx, 'bad signature length');\n",
          "message": null
        },
        {
          "name": "Underflow bugs",
          "vulnerability_from_line": 440,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint n_influencers = (sig.length-21) / (65+msg_len);\n",
          "message": null
        }
      ]
    }
  }
}