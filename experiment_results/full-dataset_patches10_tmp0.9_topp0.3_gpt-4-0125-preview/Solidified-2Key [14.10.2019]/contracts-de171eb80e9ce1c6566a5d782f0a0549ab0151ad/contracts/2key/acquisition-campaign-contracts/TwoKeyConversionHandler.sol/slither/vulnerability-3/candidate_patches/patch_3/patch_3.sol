pragma solidity ^0.4.24;





contract TwoKeyConversionStates {
    enum ConversionState {PENDING_APPROVAL, APPROVED, EXECUTED, REJECTED, CANCELLED_BY_CONVERTER}
}



pragma solidity ^0.4.24;

contract TwoKeyConverterStates {
    enum ConverterState {NOT_EXISTING, PENDING_APPROVAL, APPROVED, REJECTED}

    
    
    
    function convertConverterStateToBytes(
        ConverterState state
    )
    internal
    pure
    returns (bytes32)
    {
        if(ConverterState.NOT_EXISTING == state) {
            return bytes32("NOT_EXISTING");
        }
        else if(ConverterState.PENDING_APPROVAL == state) {
            return bytes32("PENDING_APPROVAL");
        }
        else if(ConverterState.APPROVED == state) {
            return bytes32("APPROVED");
        }
        else if(ConverterState.REJECTED == state) {
            return bytes32("REJECTED");
        }
    }
}



pragma solidity ^0.4.24;



contract ITwoKeyAcquisitionCampaignERC20 {
    address public conversionHandler;
    function buyTokensAndDistributeReferrerRewards(uint256 _maxReferralRewardETHWei, address _converter, uint _conversionId, bool _isConversionFiat) public returns (uint);
    function moveFungibleAsset(address _to, uint256 _amount) public;
    function updateContractorProceeds(uint value) public;
    function sendBackEthWhenConversionCancelled(address _cancelledConverter, uint _conversionAmount) public;
    function buyTokensForModeratorRewards(uint moderatorFee) public;
    function updateReservedAmountOfTokensIfConversionRejectedOrExecuted(uint value) public;
    function refundConverterAndRemoveUnits(address _converter, uint amountOfEther, uint amountOfUnits) external;
    function getStatistics(address ethereum, address plasma) public view returns (uint,uint,uint,uint);
    function getAvailableAndNonReservedTokensAmount() external view returns (uint);
    function getTotalReferrerEarnings(address _referrer, address eth_address) public view returns (uint);
    function getReferrerPlasmaBalance(address _influencer) public view returns (uint);
    function updateReferrerPlasmaBalance(address _influencer, uint _balance) public;
    function getReferrerCut(address me) public view returns (uint256);
}



pragma solidity ^0.4.24;


contract ITwoKeyEventSource {
    function ethereumOf(address me) public view returns (address);
    function plasmaOf(address me) public view returns (address);
    function isAddressMaintainer(address _maintainer) public view returns (bool);
    function getTwoKeyDefaultIntegratorFeeFromAdmin() public view returns (uint);
}



pragma solidity ^0.4.24;




contract ITwoKeyBaseReputationRegistry {
    function updateOnConversionExecutedEvent(address converter, address contractor, address acquisitionCampaign) public;
    function updateOnConversionRejectedEvent(address converter, address contractor, address acquisitionCampaign) public;
}



pragma solidity ^0.4.24;



contract ITwoKeyPurchasesHandler {

    function startVesting(
        uint _baseTokens,
        uint _bonusTokens,
        uint _conversionId,
        address _converter
    )
    public;
}



pragma solidity ^0.4.24;






library SafeMath {

  


  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {
    
    
    
    if (_a == 0) {
      return 0;
    }

    c = _a * _b;
    require(c / _a == _b);
    return c;
  }

  


  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {
    
    
    
    return _a / _b;
  }

  


  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {
    require(_b <= _a);
    return _a - _b;
  }

  


  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {
    c = _a + _b;
    require(c >= _a);
    return c;
  }
}



pragma solidity ^0.4.24;





interface ITwoKeySingletonesRegistry {

    



    event ProxyCreated(address proxy);


    




    event VersionAdded(string version, address implementation);

    




    function addVersion(string _contractName, string version, address implementation) public;

    





    function getVersion(string _contractName, string version) public view returns (address);
}



pragma solidity ^0.4.24;





contract UpgradeabilityCampaignStorage {
    
    ITwoKeySingletonesRegistry internal registry;

    address internal twoKeyFactory;

    
    address internal _implementation;

    



    function implementation() public view returns (address) {
        return _implementation;
    }
}



pragma solidity ^0.4.24;

contract UpgradeableCampaign is UpgradeabilityCampaignStorage {






}



pragma solidity ^0.4.24;












function executeConversion(
    uint _conversionId
)
external
{
    Conversion storage conversion = conversions[_conversionId];

    uint totalUnits = conversion.baseTokenUnits + conversion.bonusTokenUnits;

    require(converterToState[conversion.converter] == ConverterState.APPROVED, "Converter not approved");

    if(conversion.isConversionFiat) {
        if(isFiatConversionAutomaticallyApproved) {
            counters[1] --; // Decrease number of approved conversions
        } else {
            require(conversion.state == ConversionState.PENDING_APPROVAL, "Conversion not pending approval");
            require(msg.sender == contractor, "Only contractor can execute this conversion"); // first check who calls this in order to save gas
            uint availableTokens = twoKeyAcquisitionCampaignERC20.getAvailableAndNonReservedTokensAmount();
            require(totalUnits < availableTokens, "Not enough available tokens");
            counters[0]--; //Decrease number of pending conversions
        }

        //Update raised funds FIAT once the conversion is executed
        counters[9] = counters[9].add(conversion.conversionAmount);

        //Update amount converter spent in FIAT
        amountConverterSpentFiatWei[conversion.converter] = amountConverterSpentFiatWei[conversion.converter].add(conversion.conversionAmount);
    } else {
        require(conversion.state == ConversionState.APPROVED, "Conversion must be approved for non-fiat");
        amountConverterSpentEthWEI[conversion.converter] = amountConverterSpentEthWEI[conversion.converter].add(conversion.conversionAmount);
        counters[1]--; //Decrease number of approved conversions
    }
    //Update bought units
    unitsConverterBought[conversion.converter] = unitsConverterBought[conversion.converter].add(conversion.baseTokenUnits + conversion.bonusTokenUnits);

    // Total rewards for referrers
    uint totalReward2keys = 0;

    // Buy tokens from campaign and distribute rewards between referrers
    totalReward2keys = twoKeyAcquisitionCampaignERC20.buyTokensAndDistributeReferrerRewards(
        conversion.maxReferralRewardETHWei,
        conversion.converter,
        _conversionId,
        conversion.isConversionFiat
    );

    // Update reputation points in registry for conversion executed event
    ITwoKeyBaseReputationRegistry(twoKeyBaseReputationRegistry).updateOnConversionExecutedEvent(
        conversion.converter,
        contractor,
        twoKeyAcquisitionCampaignERC20
    );

    // Add total rewards
    counters[8] = counters[8].add(totalReward2keys);

    // update reserved amount of tokens on acquisition contract
    twoKeyAcquisitionCampaignERC20.updateReservedAmountOfTokensIfConversionRejectedOrExecuted(totalUnits); // External call after state updates

    //Update total raised funds
    if(!conversion.isConversionFiat) {
        // update moderator balances
        twoKeyAcquisitionCampaignERC20.buyTokensForModeratorRewards(conversion.moderatorFeeETHWei); // External call after state updates
        // update contractor proceeds
        twoKeyAcquisitionCampaignERC20.updateContractorProceeds(conversion.contractorProceedsETHWei); // External call after state updates
        // add conversion amount to counter
        counters[6] = counters[6].add(conversion.conversionAmount);
    }

    if(!doesConverterHaveExecutedConversions[conversion.converter]) {
        counters[5]++; //increase number of unique converters
        doesConverterHaveExecutedConversions[conversion.converter] = true;
    }

    ITwoKeyPurchasesHandler(twoKeyPurchasesHandler).startVesting(
        conversion.baseTokenUnits,
        conversion.bonusTokenUnits,
        _conversionId,
        conversion.converter
    ); // External call after state updates

    // Transfer tokens to lockup contract
    twoKeyAcquisitionCampaignERC20.moveFungibleAsset(address(twoKeyPurchasesHandler), totalUnits); // External call after state updates

    conversion.maxReferralReward2key = totalReward2keys;
    conversion.state = ConversionState.EXECUTED;
    counters[3]++; //Increase number of executed conversions
    counters[7] = counters[7].add(totalUnits); //update sold tokens once conversion is executed
}