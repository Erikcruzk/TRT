pragma solidity ^0.4.24;





contract TwoKeyConversionStates {
    enum ConversionState {PENDING_APPROVAL, APPROVED, EXECUTED, REJECTED, CANCELLED_BY_CONVERTER}
}



pragma solidity ^0.4.24;

contract TwoKeyConverterStates {
    enum ConverterState {NOT_EXISTING, PENDING_APPROVAL, APPROVED, REJECTED}

    
    
    
    function convertConverterStateToBytes(
        ConverterState state
    )
    internal
    pure
    returns (bytes32)
    {
        if(ConverterState.NOT_EXISTING == state) {
            return bytes32("NOT_EXISTING");
        }
        else if(ConverterState.PENDING_APPROVAL == state) {
            return bytes32("PENDING_APPROVAL");
        }
        else if(ConverterState.APPROVED == state) {
            return bytes32("APPROVED");
        }
        else if(ConverterState.REJECTED == state) {
            return bytes32("REJECTED");
        }
    }
}



pragma solidity ^0.4.24;



contract ITwoKeyAcquisitionCampaignERC20 {
    address public conversionHandler;
    function buyTokensAndDistributeReferrerRewards(uint256 _maxReferralRewardETHWei, address _converter, uint _conversionId, bool _isConversionFiat) public returns (uint);
    function moveFungibleAsset(address _to, uint256 _amount) public;
    function updateContractorProceeds(uint value) public;
    function sendBackEthWhenConversionCancelled(address _cancelledConverter, uint _conversionAmount) public;
    function buyTokensForModeratorRewards(uint moderatorFee) public;
    function updateReservedAmountOfTokensIfConversionRejectedOrExecuted(uint value) public;
    function refundConverterAndRemoveUnits(address _converter, uint amountOfEther, uint amountOfUnits) external;
    function getStatistics(address ethereum, address plasma) public view returns (uint,uint,uint,uint);
    function getAvailableAndNonReservedTokensAmount() external view returns (uint);
    function getTotalReferrerEarnings(address _referrer, address eth_address) public view returns (uint);
    function getReferrerPlasmaBalance(address _influencer) public view returns (uint);
    function updateReferrerPlasmaBalance(address _influencer, uint _balance) public;
    function getReferrerCut(address me) public view returns (uint256);
}



pragma solidity ^0.4.24;


contract ITwoKeyEventSource {
    function ethereumOf(address me) public view returns (address);
    function plasmaOf(address me) public view returns (address);
    function isAddressMaintainer(address _maintainer) public view returns (bool);
    function getTwoKeyDefaultIntegratorFeeFromAdmin() public view returns (uint);
}



pragma solidity ^0.4.24;




contract ITwoKeyBaseReputationRegistry {
    function updateOnConversionExecutedEvent(address converter, address contractor, address acquisitionCampaign) public;
    function updateOnConversionRejectedEvent(address converter, address contractor, address acquisitionCampaign) public;
}



pragma solidity ^0.4.24;



contract ITwoKeyPurchasesHandler {

    function startVesting(
        uint _baseTokens,
        uint _bonusTokens,
        uint _conversionId,
        address _converter
    )
    public;
}



pragma solidity ^0.4.24;






library SafeMath {

  


  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {
    
    
    
    if (_a == 0) {
      return 0;
    }

    c = _a * _b;
    require(c / _a == _b);
    return c;
  }

  


  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {
    
    
    
    return _a / _b;
  }

  


  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {
    require(_b <= _a);
    return _a - _b;
  }

  


  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {
    c = _a + _b;
    require(c >= _a);
    return c;
  }
}



pragma solidity ^0.4.24;





interface ITwoKeySingletonesRegistry {

    



    event ProxyCreated(address proxy);


    




    event VersionAdded(string version, address implementation);

    




    function addVersion(string _contractName, string version, address implementation) public;

    





    function getVersion(string _contractName, string version) public view returns (address);
}



pragma solidity ^0.4.24;





function beginMigration() public {
        require(_implementation != address(0), "Implementation address must be set");
        require(msg.sender == contractor || ITwoKeyEventSource(twoKeyEventSource).isAddressMaintainer(msg.sender), "Sender must be contractor or maintainer");
        twoKeyAcquisitionCampaignERC20.moveFungibleAsset(contractor, twoKeyAcquisitionCampaignERC20.getAvailableAndNonReservedTokensAmount());
        isCampaignInitialized = false;
    }



pragma solidity ^0.4.24;

contract UpgradeableCampaign is UpgradeabilityCampaignStorage {






}



pragma solidity ^0.4.24;












contract TwoKeyConversionHandler is UpgradeableCampaign, TwoKeyConversionStates, TwoKeyConverterStates {

    using SafeMath for uint256;

    bool isCampaignInitialized;

    bool public isFiatConversionAutomaticallyApproved;

    event ConversionCreated(uint conversionId);
    uint numberOfConversions;

    Conversion[] conversions;
    ITwoKeyAcquisitionCampaignERC20 twoKeyAcquisitionCampaignERC20;

    mapping(address => uint256) private amountConverterSpentFiatWei; 
    mapping(address => uint256) private amountConverterSpentEthWEI; 
    mapping(address => uint256) private unitsConverterBought; 


    mapping(bytes32 => address[]) stateToConverter; 
    mapping(address => uint[]) converterToHisConversions;

    mapping(address => ConverterState) converterToState; 
    mapping(address => bool) isConverterAnonymous;
    mapping(address => bool) doesConverterHaveExecutedConversions;
    












    uint [] counters;

    uint expiryConversionInHours; 

    address twoKeyEventSource;
    address contractor;
    address assetContractERC20;
    address twoKeyBaseReputationRegistry;
    address public twoKeyPurchasesHandler;


    
    struct Conversion {
        address contractor; 
        uint256 contractorProceedsETHWei; 
        address converter; 
        ConversionState state;
        uint256 conversionAmount; 
        uint256 maxReferralRewardETHWei; 
        uint256 maxReferralReward2key;
        uint256 moderatorFeeETHWei;
        uint256 baseTokenUnits;
        uint256 bonusTokenUnits;
        uint256 conversionCreatedAt; 
        uint256 conversionExpiresAt; 
        bool isConversionFiat;
    }

    modifier onlyContractorOrMaintainer {
        require(msg.sender == contractor || ITwoKeyEventSource(twoKeyEventSource).isAddressMaintainer(msg.sender));
        _;
    }


    function setInitialParamsConversionHandler(
        uint [] values,
        address _twoKeyAcquisitionCampaignERC20,
        address _twoKeyPurchasesHandler,
        address _contractor,
        address _assetContractERC20,
        address _twoKeyEventSource,
        address _twoKeyBaseReputationRegistry
    )
    public
    {
        require(isCampaignInitialized == false);
        counters = new uint[](10);

        expiryConversionInHours = values[0];

        if(values[1] == 1) {
            isFiatConversionAutomaticallyApproved = true;
        }

        
        twoKeyPurchasesHandler = _twoKeyPurchasesHandler;
        twoKeyAcquisitionCampaignERC20 = ITwoKeyAcquisitionCampaignERC20(_twoKeyAcquisitionCampaignERC20);

        contractor = _contractor;
        assetContractERC20 =_assetContractERC20;
        twoKeyEventSource = _twoKeyEventSource;
        twoKeyBaseReputationRegistry = _twoKeyBaseReputationRegistry;
        isCampaignInitialized = true;
    }

    




    function calculateModeratorFee(
        uint256 _conversionAmountETHWei
    )
    private
    view
    returns (uint256)
    {
        uint256 fee = _conversionAmountETHWei.mul(ITwoKeyEventSource(twoKeyEventSource).getTwoKeyDefaultIntegratorFeeFromAdmin()).div(100);
        return fee;
    }


    
    
    
    
    
    function supportForCreateConversion(
        address _contractor,
        address _converterAddress,
        uint256 _conversionAmount,
        uint256 _maxReferralRewardETHWei,
        uint256 baseTokensForConverterUnits,
        uint256 bonusTokensForConverterUnits,
        bool isConversionFiat,
        bool _isAnonymous,
        bool _isKYCRequired
    )
    public
    returns (uint)
    {
        require(msg.sender == address(twoKeyAcquisitionCampaignERC20));

        
        if(_isKYCRequired == true) {
            require(converterToState[_converterAddress] != ConverterState.REJECTED); 
            
            if(converterToState[_converterAddress] == ConverterState.NOT_EXISTING) {
                converterToState[_converterAddress] = ConverterState.PENDING_APPROVAL;
                stateToConverter[bytes32("PENDING_APPROVAL")].push(_converterAddress);
            }
        } else {
            
            if(converterToState[_converterAddress] == ConverterState.NOT_EXISTING) {
                converterToState[_converterAddress] = ConverterState.APPROVED;
                stateToConverter[bytes32("APPROVED")].push(_converterAddress);
            }
        }

        
        isConverterAnonymous[_converterAddress] = _isAnonymous;


        uint _moderatorFeeETHWei = 0;
        uint256 _contractorProceeds = _conversionAmount; 

        ConversionState state;

        if(isConversionFiat == false) {
            _moderatorFeeETHWei = calculateModeratorFee(_conversionAmount);
            _contractorProceeds = _conversionAmount - _maxReferralRewardETHWei - _moderatorFeeETHWei;
            
            state = ConversionState.APPROVED; 
            counters[1]++;
        } else {
            
            if(isFiatConversionAutomaticallyApproved) {
                state = ConversionState.APPROVED;
                counters[1] ++; 
            } else {
                state = ConversionState.PENDING_APPROVAL; 
                counters[0]++; 
            }
        }

        Conversion memory c = Conversion(_contractor, _contractorProceeds, _converterAddress,
            state ,_conversionAmount, _maxReferralRewardETHWei, 0, _moderatorFeeETHWei, baseTokensForConverterUnits,
            bonusTokensForConverterUnits,
            now, now + expiryConversionInHours * (1 hours), isConversionFiat);

        conversions.push(c);

        converterToHisConversions[_converterAddress].push(numberOfConversions);
        emit ConversionCreated(numberOfConversions);
        numberOfConversions++;

        return numberOfConversions-1;
    }


    



    function executeConversion(
        uint _conversionId
    )
    public
    {
        Conversion conversion = conversions[_conversionId];

        uint totalUnits = conversion.baseTokenUnits + conversion.bonusTokenUnits;

        
        require(converterToState[conversion.converter] == ConverterState.APPROVED);

        if(conversion.isConversionFiat == true) {
            if(isFiatConversionAutomaticallyApproved) {
                counters[1] --; 
            } else {
                require(conversion.state == ConversionState.PENDING_APPROVAL);
                require(msg.sender == contractor); 
                uint availableTokens = twoKeyAcquisitionCampaignERC20.getAvailableAndNonReservedTokensAmount();
                require(totalUnits < availableTokens);
                counters[0]--; 
            }

            
            counters[9] = counters[9].add(conversion.conversionAmount);

            
            amountConverterSpentFiatWei[conversion.converter] = amountConverterSpentFiatWei[conversion.converter].add(conversion.conversionAmount);
        } else {
            require(conversion.state == ConversionState.APPROVED);
            amountConverterSpentEthWEI[conversion.converter] = amountConverterSpentEthWEI[conversion.converter].add(conversion.conversionAmount);
            counters[1]--; 
        }
        
        unitsConverterBought[conversion.converter] = unitsConverterBought[conversion.converter].add(conversion.baseTokenUnits + conversion.bonusTokenUnits);

        
        uint totalReward2keys = 0;

        
        totalReward2keys = twoKeyAcquisitionCampaignERC20.buyTokensAndDistributeReferrerRewards(
            conversion.maxReferralRewardETHWei,
            conversion.converter,
            _conversionId,
            conversion.isConversionFiat
        );


        ITwoKeyBaseReputationRegistry(twoKeyBaseReputationRegistry).updateOnConversionExecutedEvent(
            conversion.converter,
            contractor,
            twoKeyAcquisitionCampaignERC20
        );

        
        counters[8] = counters[8].add(totalReward2keys);

        
        twoKeyAcquisitionCampaignERC20.updateReservedAmountOfTokensIfConversionRejectedOrExecuted(totalUnits);

        
        if(conversion.isConversionFiat == false) {
            
            twoKeyAcquisitionCampaignERC20.buyTokensForModeratorRewards(conversion.moderatorFeeETHWei);
            
            twoKeyAcquisitionCampaignERC20.updateContractorProceeds(conversion.contractorProceedsETHWei);
            
            counters[6] = counters[6].add(conversion.conversionAmount);
        }

        if(doesConverterHaveExecutedConversions[conversion.converter] == false) {
            counters[5]++; 
            doesConverterHaveExecutedConversions[conversion.converter] = true;
        }

        ITwoKeyPurchasesHandler(twoKeyPurchasesHandler).startVesting(
            conversion.baseTokenUnits,
            conversion.bonusTokenUnits,
            _conversionId,
            conversion.converter
        );

        
        twoKeyAcquisitionCampaignERC20.moveFungibleAsset(address(twoKeyPurchasesHandler), totalUnits);

        conversion.maxReferralReward2key = totalReward2keys;
        conversion.state = ConversionState.EXECUTED;
        counters[3]++; 
        counters[7] = counters[7].add(totalUnits); 
    }


    



    function getConversion(
        uint conversionId
    )
    external
    view
    returns (bytes)
    {
        Conversion memory conversion = conversions[conversionId];
        address empty = address(0);
        if(isConverterAnonymous[conversion.converter] == false) {
            empty = conversion.converter;
        }
        return abi.encodePacked (
            conversion.contractor,
            conversion.contractorProceedsETHWei,
            empty,
            conversion.state,
            conversion.conversionAmount,
            conversion.maxReferralRewardETHWei,
            conversion.maxReferralReward2key,
            conversion.moderatorFeeETHWei,
            conversion.baseTokenUnits,
            conversion.bonusTokenUnits,
            conversion.conversionCreatedAt,
            conversion.conversionExpiresAt,
            conversion.isConversionFiat
        );
    }


    function getAllConvertersPerState(
        bytes32 state
    )
    public
    view
    onlyContractorOrMaintainer
    returns (address[])
    {
        return stateToConverter[state];
    }


    
    
    
    function moveFromStateAToStateB(
        address _converter,
        bytes32 destinationState
    )
    internal
    {
        ConverterState state = converterToState[_converter];
        bytes32 key = convertConverterStateToBytes(state);
        address[] memory pending = stateToConverter[key];
        for(uint i=0; i< pending.length; i++) {
            if(pending[i] == _converter) {
                stateToConverter[destinationState].push(_converter);
                pending[i] = pending[pending.length-1];
                delete pending[pending.length-1];
                stateToConverter[key] = pending;
                stateToConverter[key].length--;
                break;
            }
        }
    }


    
    
    
    function moveFromPendingOrRejectedToApprovedState(
        address _converter
    )
    internal
    {
        bytes32 destination = bytes32("APPROVED");
        moveFromStateAToStateB(_converter, destination);
        converterToState[_converter] = ConverterState.APPROVED;
    }


    
    
    
    function moveFromPendingToRejectedState(
        address _converter
    )
    internal
    {
        bytes32 destination = bytes32("REJECTED");
        moveFromStateAToStateB(_converter, destination);
        converterToState[_converter] = ConverterState.REJECTED;
    }


    
    
    
    function approveConverter(
        address _converter
    )
    public
    onlyContractorOrMaintainer
    {
        require(converterToState[_converter] == ConverterState.PENDING_APPROVAL);
        uint len = converterToHisConversions[_converter].length;
        for(uint i=0; i<len; i++) {
            uint conversionId = converterToHisConversions[_converter][i];
            Conversion c = conversions[conversionId];
            if(c.state == ConversionState.PENDING_APPROVAL && c.isConversionFiat == true) {
                
                counters[0]--; 
                counters[1]++; 
                c.state = ConversionState.APPROVED;

            }
        }
        moveFromPendingOrRejectedToApprovedState(_converter);
    }


    
    
    
    function rejectConverter(
        address _converter
    )
    public
    onlyContractorOrMaintainer
    {
        require(converterToState[_converter] == ConverterState.PENDING_APPROVAL);
        moveFromPendingToRejectedState(_converter);
        uint reservedAmount = 0;
        uint refundAmount = 0;
        uint len = converterToHisConversions[_converter].length;
        for(uint i=0; i< len; i++) {
            uint conversionId = converterToHisConversions[_converter][i];
            Conversion c = conversions[conversionId];
            if(c.state == ConversionState.PENDING_APPROVAL || c.state == ConversionState.APPROVED) {
                counters[0]--; 
                counters[2]++; 
                ITwoKeyBaseReputationRegistry(twoKeyBaseReputationRegistry).updateOnConversionRejectedEvent(_converter, contractor, twoKeyAcquisitionCampaignERC20);
                c.state = ConversionState.REJECTED;
                reservedAmount += c.baseTokenUnits + c.bonusTokenUnits;
                if(c.isConversionFiat == false) {
                    refundAmount += c.conversionAmount;
                }
            }
        }
        
        if(reservedAmount > 0 && refundAmount > 0) {
            twoKeyAcquisitionCampaignERC20.updateReservedAmountOfTokensIfConversionRejectedOrExecuted(reservedAmount);
            twoKeyAcquisitionCampaignERC20.sendBackEthWhenConversionCancelled(_converter, refundAmount);
        }
    }


    





    function getConverterConversionIds(
        address _converter
    )
    public
    view
    returns (uint[])
    {

        return converterToHisConversions[_converter];
    }

    function getLastConverterConversionId(
        address _converter
    )
    public
    view
    returns (uint)
    {
        return converterToHisConversions[_converter][converterToHisConversions[_converter].length - 1];
    }


    



    function getNumberOfConversions()
    external
    view
    returns (uint)
    {
        return numberOfConversions;
    }


    




    function converterCancelConversion(
        uint _conversionId
    )
    external
    {
        Conversion conversion = conversions[_conversionId];

        require(conversion.conversionCreatedAt + 10*(1 days) < block.timestamp);
        require(msg.sender == conversion.converter);
        require(conversion.state == ConversionState.PENDING_APPROVAL);

        counters[0]--; 
        counters[4]++; 
        conversion.state = ConversionState.CANCELLED_BY_CONVERTER;
        twoKeyAcquisitionCampaignERC20.sendBackEthWhenConversionCancelled(msg.sender, conversion.conversionAmount);
    }

    



    function getCampaignSummary()
    public
    view
    returns (uint,uint,uint,uint[])
    {
        bytes32 pending = convertConverterStateToBytes(ConverterState.PENDING_APPROVAL);
        bytes32 approved = convertConverterStateToBytes(ConverterState.APPROVED);
        bytes32 rejected = convertConverterStateToBytes(ConverterState.REJECTED);

        uint numberOfPending = stateToConverter[pending].length;
        uint numberOfApproved = stateToConverter[approved].length;
        uint numberOfRejected = stateToConverter[rejected].length;

        return (
            numberOfPending,
            numberOfApproved,
            numberOfRejected,
            counters
        );
    }

    




    function getStateForConverter(
        address _converter
    )
    external
    view
    returns (bytes32)
    {
        return convertConverterStateToBytes(converterToState[_converter]);
    }


    



    function getConverterPurchasesStats(
        address _converter
    )
    public
    view
    returns (uint,uint,uint)
    {
        return (
            amountConverterSpentEthWEI[_converter],
            amountConverterSpentFiatWei[_converter],
            unitsConverterBought[_converter]
        );
    }

}