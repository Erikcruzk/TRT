pragma solidity ^0.4.24;





contract TwoKeyConversionStates {
    enum ConversionState {PENDING_APPROVAL, APPROVED, EXECUTED, REJECTED, CANCELLED_BY_CONVERTER}
}



pragma solidity ^0.4.24;


contract IERC20 {
    function balanceOf(
        address whom
    )
    external
    view
    returns (uint);


    function transfer(
        address _to,
        uint256 _value
    )
    external
    returns (bool);


    function transferFrom(
        address _from,
        address _to,
        uint256 _value
    )
    external
    returns (bool);



    function approve(
        address _spender,
        uint256 _value
    )
    public
    returns (bool);



    function decimals()
    external
    view
    returns (uint);


    function symbol()
    external
    view
    returns (string);


    function name()
    external
    view
    returns (string);


    function freezeTransfers()
    external;


    function unfreezeTransfers()
    external;
}



pragma solidity ^0.4.24;








contract TwoKeyAirdropCampaign is TwoKeyConversionStates {


    
    bool isActivated = false;
    
    address constant TWO_KEY_ECONOMY = address(0);
    
    address constant TWO_KEY_SINGLETONE_ADDRESSES = address(0);
    
    address contractor;
    
    uint inventoryAmount;
    
    address erc20ContractAddress;
    
    uint campaignStartTime;
    
    uint campaignEndTime;
    
    uint public numberOfTokensPerConverter;
    
    uint referralReward;
    
    Conversion[] conversions;
    
    uint numberOfConversions = 0;
    
    uint maxNumberOfConversions;
    
    mapping(address => uint) converterToConversionId;
    
    mapping(address => uint) referrerBalances;
    
    mapping(address => uint) referrerTotalEarnings;
    
    uint constant CONVERSION_FEE_2KEY = 5;

    struct Conversion {
        address converter;
        uint conversionTime; 
        ConversionState state;
    }

    
    modifier isOngoing {
        require(block.timestamp >= campaignStartTime && block.timestamp <= campaignEndTime);
        _;
    }

    
    modifier onlyIfMaxNumberOfConversionsNotReached {
        require(numberOfConversions < maxNumberOfConversions);
        _;
    }

    
    modifier onlyContractor {
        require(msg.sender == contractor);
        _;
    }

    
    modifier onlyIfActivated {
        require(isActivated == true);
        _;
    }

    constructor(
        uint _inventory,
        address _erc20ContractAddress,
        uint _campaignStartTime,
        uint _campaignEndTime,
        uint _numberOfTokensPerConverterAndReferralChain
    ) public {
        contractor = msg.sender;
        inventoryAmount = _inventory;
        erc20ContractAddress = _erc20ContractAddress;
        campaignStartTime = _campaignStartTime;
        campaignEndTime = _campaignEndTime;
        numberOfTokensPerConverter = _numberOfTokensPerConverterAndReferralChain;
        referralReward = _numberOfTokensPerConverterAndReferralChain;
        maxNumberOfConversions = inventoryAmount / (2*_numberOfTokensPerConverterAndReferralChain);
        if(inventoryAmount - maxNumberOfConversions*2*_numberOfTokensPerConverterAndReferralChain > 0 ) {
            
        }
    }

    




    function activateCampaign() external onlyContractor {
        uint balance = IERC20(TWO_KEY_ECONOMY).balanceOf(address(this));
        if(erc20ContractAddress == TWO_KEY_ECONOMY) {
            require(balance == numberOfConversions * CONVERSION_FEE_2KEY + inventoryAmount);
        } else {
            require(balance == numberOfConversions * CONVERSION_FEE_2KEY);
        }
        isActivated = true;
    }

    



    function convert(bytes signature) external onlyIfActivated onlyIfMaxNumberOfConversionsNotReached {
        
        
        
        
        Conversion memory c = Conversion({
            converter: msg.sender,
            conversionTime: block.timestamp,
            state: ConversionState.PENDING_APPROVAL
        });
        conversions.push(c);
        numberOfConversions++;
    }

    




    function approveConversion(uint conversionId) external onlyContractor {
        Conversion memory c = conversions[conversionId];
        if(c.state == ConversionState.PENDING_APPROVAL) {
            c.state = ConversionState.APPROVED;
        }
        conversions[conversionId] = c;
    }

    




    function rejectConversion(uint conversionId) external onlyContractor {
        Conversion memory c = conversions[conversionId];
        if(c.state == ConversionState.PENDING_APPROVAL) {
            c.state = ConversionState.REJECTED;
        }
        conversions[conversionId] = c;
    }

    



    function getContractInformations() external view returns (bytes) {
        return abi.encodePacked(
            contractor,
            inventoryAmount,
            erc20ContractAddress,
            campaignStartTime,
            campaignEndTime,
            numberOfTokensPerConverter,
            numberOfConversions,
            maxNumberOfConversions
        );
    }

    




    function getReferrerBalanceAndTotalEarnings(address _referrer) external view returns (uint,uint) {
        require(msg.sender == contractor || msg.sender == _referrer);
        return (referrerBalances[_referrer], referrerTotalEarnings[_referrer]);
    }

    




    function getConversion(uint conversionId) external view returns (address, uint, bytes32) {
        Conversion memory conversion = conversions[conversionId];
        require(msg.sender == conversion.converter || msg.sender == contractor);
        return (conversion.converter, conversion.conversionTime, convertConversionStateToBytes(conversion.state));
    }

    




    function getConverterBalance(address _converter) external view returns (uint) {
        require(msg.sender == _converter || msg.sender == contractor);
        uint conversionId = converterToConversionId[_converter];
        Conversion memory conversion = conversions[conversionId];
        if(conversion.state == ConversionState.APPROVED) {
            return numberOfTokensPerConverter;
        } else {
            return 0;
        }
    }

    


function converterWithdraw() external {
    uint conversionId = converterToConversionId[msg.sender];
    Conversion storage c = conversions[conversionId];
    require(c.state == ConversionState.APPROVED);
    c.state = ConversionState.EXECUTED;
    require(IERC20(erc20ContractAddress).transfer(msg.sender, numberOfTokensPerConverter)); 
}

    



    function referrerWithdraw() external {
        require(referrerBalances[msg.sender] > 0);
        IERC20(erc20ContractAddress).transfer(msg.sender, referrerBalances[msg.sender]);
        referrerBalances[msg.sender] = 0;
    }


    function convertConversionStateToBytes(ConversionState state) internal pure returns (bytes32) {
        if(state == ConversionState.PENDING_APPROVAL) {
            return bytes32("PENDING_APPROVAL");
        } else if(state == ConversionState.APPROVED) {
            return bytes32("APPROVED");
        } else if(state == ConversionState.EXECUTED) {
            return bytes32("EXECUTED");
        } else if(state == ConversionState.REJECTED) {
            return bytes32("REJECTED");
        } else if(state == ConversionState.CANCELLED_BY_CONVERTER) {
            return bytes32("CANCELLED_BY_CONVERTER");
        } else {
            return bytes32(0);
        }
    }
}