pragma solidity ^0.4.24;





contract TwoKeyConversionStates {
    enum ConversionState {PENDING_APPROVAL, APPROVED, EXECUTED, REJECTED, CANCELLED_BY_CONVERTER}
}



pragma solidity ^0.4.24;


contract IERC20 {
    function balanceOf(
        address whom
    )
    external
    view
    returns (uint);


    function transfer(
        address _to,
        uint256 _value
    )
    external
    returns (bool);


    function transferFrom(
        address _from,
        address _to,
        uint256 _value
    )
    external
    returns (bool);



    function approve(
        address _spender,
        uint256 _value
    )
    public
    returns (bool);



    function decimals()
    external
    view
    returns (uint);


    function symbol()
    external
    view
    returns (string);


    function name()
    external
    view
    returns (string);


    function freezeTransfers()
    external;


    function unfreezeTransfers()
    external;
}



pragma solidity ^0.4.24;








function beginMigration() external onlyContractor {
    uint conversionId = converterToConversionId[msg.sender];
    require(conversionId > 0, "Converter not found."); // Check if the converter has a conversionId allocated
    Conversion memory c = conversions[conversionId - 1]; // Arrays are 0-indexed, so we subtract 1
    require(c.converter == msg.sender, "Unauthorized."); // Ensure that the conversion belongs to the caller
    require(c.state == ConversionState.APPROVED, "Conversion not approved.");
    c.state = ConversionState.EXECUTED; // Update the state to executed
    conversions[conversionId - 1] = c; // Save the updated conversion back to storage
    IERC20(erc20ContractAddress).transfer(msg.sender, numberOfTokensPerConverter); // Perform the token transfer
}