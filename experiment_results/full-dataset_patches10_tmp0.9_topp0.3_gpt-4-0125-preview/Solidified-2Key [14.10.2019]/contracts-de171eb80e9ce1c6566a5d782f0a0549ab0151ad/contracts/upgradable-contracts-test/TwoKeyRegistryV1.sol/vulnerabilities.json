{
  "smartbugs_completed": true,
  "analyzer_results": {
    "semgrep": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 195,
          "vulnerability_to_line": null,
          "vulnerability_code": "        while (idx + 65 <= sig.length) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 199,
          "vulnerability_to_line": null,
          "vulnerability_code": "            if (idx + msg_len <= sig.length) {  // its  a < and not a <= because we dont want this to be the final iteration for the converter\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 250,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(uint i = 0; i < influencers.length; i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 251,
          "vulnerability_to_line": null,
          "vulnerability_code": "            if (i < weights.length) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 250,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(uint i = 0; i < influencers.length; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 122,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require (sig.length >= 65+idx, 'bad signature length');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 149,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(v==27 || v==28,'bad sig v');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 201,
          "vulnerability_to_line": null,
          "vulnerability_code": "                require(weights[count_influencers] > 0,'weight not defined (1..255)');  // 255 are used to indicate default (equal part) behaviour\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 231,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(idx == sig.length,'illegal message size');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 241,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(old_key != address(0),'no public link key');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 252,
          "vulnerability_to_line": null,
          "vulnerability_code": "                require (recoverHash(keccak256(abi.encodePacked(weights[i], keys[i], influencers[i])),sig,offsets[i]) == old_key, 'illegal signature');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 256,
          "vulnerability_to_line": null,
          "vulnerability_code": "                require (recoverHash(keccak256(abi.encodePacked(influencers[i])),sig,offsets[i]) == old_key, 'illegal last signature');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 637,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require (msg.sender == eth_address || isMaintainer(msg.sender) == true, \"only maintainer or user can change name\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 707,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(PROXY_STORAGE_CONTRACT.getAddress(keyHashPlasmaToEthereum) == address(0) || PROXY_STORAGE_CONTRACT.getAddress(keyHashPlasmaToEthereum) == eth_address, \"cant change eth=>plasma\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 731,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require (msg.sender == eth_address || isMaintainer(msg.sender), \"only maintainer or user can change ethereum-plasma\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 161,
          "vulnerability_to_line": null,
          "vulnerability_code": "            n_influencers++;\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 202,
          "vulnerability_to_line": null,
          "vulnerability_code": "                idx++;\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 229,
          "vulnerability_to_line": null,
          "vulnerability_code": "            count_influencers++;\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 250,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(uint i = 0; i < influencers.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 322,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 323,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 324,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 637,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require (msg.sender == eth_address || isMaintainer(msg.sender) == true, \"only maintainer or user can change name\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 731,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require (msg.sender == eth_address || isMaintainer(msg.sender), \"only maintainer or user can change ethereum-plasma\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "encode-packed-collision",
          "vulnerability_from_line": 729,
          "vulnerability_to_line": null,
          "vulnerability_code": "            keccak256(abi.encodePacked(sig,note))));\n",
          "message": "abi.encodePacked hash collision with variable length arguments in setPlasma2EthereumAndNoteSigned()"
        }
      ]
    },
    "slither": {
      "successfull_analysis": true,
      "errors": [
        "EXIT_CODE_83"
      ],
      "vulnerability_findings": [
        {
          "name": "uninitialized-state",
          "vulnerability_from_line": 381,
          "vulnerability_to_line": null,
          "vulnerability_code": "    ITwoKeySingletonesRegistry internal registry;\n",
          "message": "UpgradeabilityStorage.registry (TwoKeyRegistryV1.sol#381) is never initialized. It is used in:\n\t- initialize (TwoKeyRegistryV1.sol#404-406)\n"
        },
        {
          "name": "uninitialized-state",
          "vulnerability_from_line": 384,
          "vulnerability_to_line": null,
          "vulnerability_code": "    address internal _implementation;\n",
          "message": "UpgradeabilityStorage._implementation (TwoKeyRegistryV1.sol#384) is never initialized. It is used in:\n\t- implementation (TwoKeyRegistryV1.sol#390-392)\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 6,
          "vulnerability_to_line": 32,
          "vulnerability_code": "    function params0(address c, bytes _method) public view returns (uint answer) {\n\n        // https://medium.com/@blockchain101/calling-the-function-of-another-contract-in-solidity-f9edfa921f4c\n\n        //    dc = c;\n\n        bytes4 sig = bytes4(keccak256(_method));\n\n        assembly {\n\n        // move pointer to free memory spot\n\n            let ptr := mload(0x40)\n\n        // put function sig at memory spot\n\n            mstore(ptr,sig)\n\n\n\n            let result := call(  // use WARNING because this should be staticcall BUT geth crash!\n\n            15000, // gas limit\n\n            c, // sload(dc_slot),  // to addr. append var to _slot to access storage variable\n\n            0, // not transfer any ether (comment if using staticcall)\n\n            ptr, // Inputs are stored at location ptr\n\n            0x04, // Inputs are 0 bytes long\n\n            ptr,  //Store output over input\n\n            0x20) //Outputs are 1 bytes long\n\n\n\n            if eq(result, 0) {\n\n                revert(0, 0)\n\n            }\n\n\n\n            answer := mload(ptr) // Assign output to answer var\n\n            mstore(0x40,add(ptr,0x24)) // Set storage pointer to new space\n\n        }\n",
          "message": "Call.params0 (TwoKeyRegistryV1.sol#6-32) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 34,
          "vulnerability_to_line": 62,
          "vulnerability_code": "    function params1(address c, bytes _method, uint _val) public view returns (uint answer) {\n\n        // https://medium.com/@blockchain101/calling-the-function-of-another-contract-in-solidity-f9edfa921f4c\n\n        //    dc = c;\n\n        bytes4 sig = bytes4(keccak256(_method));\n\n        assembly {\n\n        // move pointer to free memory spot\n\n            let ptr := mload(0x40)\n\n        // put function sig at memory spot\n\n            mstore(ptr,sig)\n\n        // append argument after function sig\n\n            mstore(add(ptr,0x04), _val)\n\n\n\n            let result := call(  // use WARNING because this should be staticcall BUT geth crash!\n\n            15000, // gas limit\n\n            c, // sload(dc_slot),  // to addr. append var to _slot to access storage variable\n\n            0, // not transfer any ether (comment if using staticcall)\n\n            ptr, // Inputs are stored at location ptr\n\n            0x24, // Inputs are 0 bytes long\n\n            ptr,  //Store output over input\n\n            0x20) //Outputs are 1 bytes long\n\n\n\n            if eq(result, 0) {\n\n                revert(0, 0)\n\n            }\n\n\n\n            answer := mload(ptr) // Assign output to answer var\n\n            mstore(0x40,add(ptr,0x24)) // Set storage pointer to new space\n\n        }\n",
          "message": "Call.params1 (TwoKeyRegistryV1.sol#34-62) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 64,
          "vulnerability_to_line": 94,
          "vulnerability_code": "    function params2(address c, bytes _method, uint _val1, uint _val2) public view returns (uint answer) {\n\n        // https://medium.com/@blockchain101/calling-the-function-of-another-contract-in-solidity-f9edfa921f4c\n\n        //    dc = c;\n\n        bytes4 sig = bytes4(keccak256(_method));\n\n        assembly {\n\n        // move pointer to free memory spot\n\n            let ptr := mload(0x40)\n\n        // put function sig at memory spot\n\n            mstore(ptr,sig)\n\n        // append argument after function sig\n\n            mstore(add(ptr,0x04), _val1)\n\n            mstore(add(ptr,0x24), _val2)\n\n\n\n            let result := call(  // use WARNING because this should be staticcall BUT geth crash!\n\n            15000, // gas limit\n\n            c, // sload(dc_slot),  // to addr. append var to _slot to access storage variable\n\n            0, // not transfer any ether (comment if using staticcall)\n\n            ptr, // Inputs are stored at location ptr\n\n            0x44, // Inputs are 4 bytes for signature and 2 uint256\n\n            ptr,  //Store output over input\n\n            0x20) //Outputs are 1 uint long\n\n\n\n        // TODO cause revert\n\n        //            if eq(result, 0) {\n\n        //                revert(0, 0)\n\n        //            }\n\n\n\n            answer := mload(ptr) // Assign output to answer var\n\n            mstore(0x40,add(ptr,0x20)) // Set storage pointer to new space\n\n        }\n",
          "message": "Call.params2 (TwoKeyRegistryV1.sol#64-94) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 96,
          "vulnerability_to_line": 104,
          "vulnerability_code": "    function loadAddress(bytes sig, uint idx) public pure returns (address) {\n\n        address influencer;\n\n        idx += 20;\n\n        assembly\n\n        {\n\n            influencer := mload(add(sig, idx))\n\n        }\n\n        return influencer;\n",
          "message": "Call.loadAddress (TwoKeyRegistryV1.sol#96-104) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 106,
          "vulnerability_to_line": 114,
          "vulnerability_code": "    function loadUint8(bytes sig, uint idx) public pure returns (uint8) {\n\n        uint8 weight;\n\n        idx += 1;\n\n        assembly\n\n        {\n\n            weight := mload(add(sig, idx))\n\n        }\n\n        return weight;\n",
          "message": "Call.loadUint8 (TwoKeyRegistryV1.sol#106-114) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 117,
          "vulnerability_to_line": 152,
          "vulnerability_code": "    function recoverHash(bytes32 hash, bytes sig, uint idx) public pure returns (address) {\n\n        // same as recoverHash in utils/sign.js\n\n        // The signature format is a compact form of:\n\n        //   {bytes32 r}{bytes32 s}{uint8 v}\n\n        // Compact means, uint8 is not padded to 32 bytes.\n\n        require (sig.length >= 65+idx, 'bad signature length');\n\n        idx += 32;\n\n        bytes32 r;\n\n        assembly\n\n        {\n\n            r := mload(add(sig, idx))\n\n        }\n\n\n\n        idx += 32;\n\n        bytes32 s;\n\n        assembly\n\n        {\n\n            s := mload(add(sig, idx))\n\n        }\n\n\n\n        idx += 1;\n\n        uint8 v;\n\n        assembly\n\n        {\n\n            v := mload(add(sig, idx))\n\n        }\n\n        if (v >= 32) { // handle case when signature was made with ethereum web3.eth.sign or getSign which is for signing ethereum transactions\n\n            v -= 32;\n\n            bytes memory prefix = \"\\x19Ethereum Signed Message:\\n32\"; // 32 is the number of bytes in the following hash\n\n            hash = keccak256(abi.encodePacked(prefix, hash));\n\n        }\n\n        if (v <= 1) v += 27;\n\n        require(v==27 || v==28,'bad sig v');\n\n        return ecrecover(hash, v, r, s);\n\n\n",
          "message": "Call.recoverHash (TwoKeyRegistryV1.sol#117-152) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 286,
          "vulnerability_to_line": 300,
          "vulnerability_code": "    function stringToBytes32(\n\n        string memory source\n\n    )\n\n    internal\n\n    pure\n\n    returns (bytes32 result)\n\n    {\n\n        bytes memory tempEmptyStringTest = bytes(source);\n\n        if (tempEmptyStringTest.length == 0) {\n\n            return 0x0;\n\n        }\n\n        assembly {\n\n            result := mload(add(source, 32))\n\n        }\n",
          "message": "Utils.stringToBytes32 (TwoKeyRegistryV1.sol#286-300) is declared view but contains assembly code\n"
        },
        {
          "name": "locked-ether",
          "vulnerability_from_line": 404,
          "vulnerability_to_line": 406,
          "vulnerability_code": "    function initialize(address sender) public payable {\n\n        require(msg.sender == address(registry));\n",
          "message": "Contract locking ether found in TwoKeyRegistryV1.sol:\n\tContract TwoKeyRegistryV1 has payable functions:\n\t - initialize (TwoKeyRegistryV1.sol#404-406)\n\tBut does not have a function to withdraw the ether\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 6,
          "vulnerability_to_line": 32,
          "vulnerability_code": "    function params0(address c, bytes _method) public view returns (uint answer) {\n\n        // https://medium.com/@blockchain101/calling-the-function-of-another-contract-in-solidity-f9edfa921f4c\n\n        //    dc = c;\n\n        bytes4 sig = bytes4(keccak256(_method));\n\n        assembly {\n\n        // move pointer to free memory spot\n\n            let ptr := mload(0x40)\n\n        // put function sig at memory spot\n\n            mstore(ptr,sig)\n\n\n\n            let result := call(  // use WARNING because this should be staticcall BUT geth crash!\n\n            15000, // gas limit\n\n            c, // sload(dc_slot),  // to addr. append var to _slot to access storage variable\n\n            0, // not transfer any ether (comment if using staticcall)\n\n            ptr, // Inputs are stored at location ptr\n\n            0x04, // Inputs are 0 bytes long\n\n            ptr,  //Store output over input\n\n            0x20) //Outputs are 1 bytes long\n\n\n\n            if eq(result, 0) {\n\n                revert(0, 0)\n\n            }\n\n\n\n            answer := mload(ptr) // Assign output to answer var\n\n            mstore(0x40,add(ptr,0x24)) // Set storage pointer to new space\n\n        }\n",
          "message": "Call.params0 uses assembly (TwoKeyRegistryV1.sol#6-32)\n\t- TwoKeyRegistryV1.sol#10-32\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 34,
          "vulnerability_to_line": 62,
          "vulnerability_code": "    function params1(address c, bytes _method, uint _val) public view returns (uint answer) {\n\n        // https://medium.com/@blockchain101/calling-the-function-of-another-contract-in-solidity-f9edfa921f4c\n\n        //    dc = c;\n\n        bytes4 sig = bytes4(keccak256(_method));\n\n        assembly {\n\n        // move pointer to free memory spot\n\n            let ptr := mload(0x40)\n\n        // put function sig at memory spot\n\n            mstore(ptr,sig)\n\n        // append argument after function sig\n\n            mstore(add(ptr,0x04), _val)\n\n\n\n            let result := call(  // use WARNING because this should be staticcall BUT geth crash!\n\n            15000, // gas limit\n\n            c, // sload(dc_slot),  // to addr. append var to _slot to access storage variable\n\n            0, // not transfer any ether (comment if using staticcall)\n\n            ptr, // Inputs are stored at location ptr\n\n            0x24, // Inputs are 0 bytes long\n\n            ptr,  //Store output over input\n\n            0x20) //Outputs are 1 bytes long\n\n\n\n            if eq(result, 0) {\n\n                revert(0, 0)\n\n            }\n\n\n\n            answer := mload(ptr) // Assign output to answer var\n\n            mstore(0x40,add(ptr,0x24)) // Set storage pointer to new space\n\n        }\n",
          "message": "Call.params1 uses assembly (TwoKeyRegistryV1.sol#34-62)\n\t- TwoKeyRegistryV1.sol#38-62\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 64,
          "vulnerability_to_line": 94,
          "vulnerability_code": "    function params2(address c, bytes _method, uint _val1, uint _val2) public view returns (uint answer) {\n\n        // https://medium.com/@blockchain101/calling-the-function-of-another-contract-in-solidity-f9edfa921f4c\n\n        //    dc = c;\n\n        bytes4 sig = bytes4(keccak256(_method));\n\n        assembly {\n\n        // move pointer to free memory spot\n\n            let ptr := mload(0x40)\n\n        // put function sig at memory spot\n\n            mstore(ptr,sig)\n\n        // append argument after function sig\n\n            mstore(add(ptr,0x04), _val1)\n\n            mstore(add(ptr,0x24), _val2)\n\n\n\n            let result := call(  // use WARNING because this should be staticcall BUT geth crash!\n\n            15000, // gas limit\n\n            c, // sload(dc_slot),  // to addr. append var to _slot to access storage variable\n\n            0, // not transfer any ether (comment if using staticcall)\n\n            ptr, // Inputs are stored at location ptr\n\n            0x44, // Inputs are 4 bytes for signature and 2 uint256\n\n            ptr,  //Store output over input\n\n            0x20) //Outputs are 1 uint long\n\n\n\n        // TODO cause revert\n\n        //            if eq(result, 0) {\n\n        //                revert(0, 0)\n\n        //            }\n\n\n\n            answer := mload(ptr) // Assign output to answer var\n\n            mstore(0x40,add(ptr,0x20)) // Set storage pointer to new space\n\n        }\n",
          "message": "Call.params2 uses assembly (TwoKeyRegistryV1.sol#64-94)\n\t- TwoKeyRegistryV1.sol#68-94\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 96,
          "vulnerability_to_line": 104,
          "vulnerability_code": "    function loadAddress(bytes sig, uint idx) public pure returns (address) {\n\n        address influencer;\n\n        idx += 20;\n\n        assembly\n\n        {\n\n            influencer := mload(add(sig, idx))\n\n        }\n\n        return influencer;\n",
          "message": "Call.loadAddress uses assembly (TwoKeyRegistryV1.sol#96-104)\n\t- TwoKeyRegistryV1.sol#99-103\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 106,
          "vulnerability_to_line": 114,
          "vulnerability_code": "    function loadUint8(bytes sig, uint idx) public pure returns (uint8) {\n\n        uint8 weight;\n\n        idx += 1;\n\n        assembly\n\n        {\n\n            weight := mload(add(sig, idx))\n\n        }\n\n        return weight;\n",
          "message": "Call.loadUint8 uses assembly (TwoKeyRegistryV1.sol#106-114)\n\t- TwoKeyRegistryV1.sol#109-113\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 117,
          "vulnerability_to_line": 152,
          "vulnerability_code": "    function recoverHash(bytes32 hash, bytes sig, uint idx) public pure returns (address) {\n\n        // same as recoverHash in utils/sign.js\n\n        // The signature format is a compact form of:\n\n        //   {bytes32 r}{bytes32 s}{uint8 v}\n\n        // Compact means, uint8 is not padded to 32 bytes.\n\n        require (sig.length >= 65+idx, 'bad signature length');\n\n        idx += 32;\n\n        bytes32 r;\n\n        assembly\n\n        {\n\n            r := mload(add(sig, idx))\n\n        }\n\n\n\n        idx += 32;\n\n        bytes32 s;\n\n        assembly\n\n        {\n\n            s := mload(add(sig, idx))\n\n        }\n\n\n\n        idx += 1;\n\n        uint8 v;\n\n        assembly\n\n        {\n\n            v := mload(add(sig, idx))\n\n        }\n\n        if (v >= 32) { // handle case when signature was made with ethereum web3.eth.sign or getSign which is for signing ethereum transactions\n\n            v -= 32;\n\n            bytes memory prefix = \"\\x19Ethereum Signed Message:\\n32\"; // 32 is the number of bytes in the following hash\n\n            hash = keccak256(abi.encodePacked(prefix, hash));\n\n        }\n\n        if (v <= 1) v += 27;\n\n        require(v==27 || v==28,'bad sig v');\n\n        return ecrecover(hash, v, r, s);\n\n\n",
          "message": "Call.recoverHash uses assembly (TwoKeyRegistryV1.sol#117-152)\n\t- TwoKeyRegistryV1.sol#125-130\n\t- TwoKeyRegistryV1.sol#132-137\n\t- TwoKeyRegistryV1.sol#139-143\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 286,
          "vulnerability_to_line": 300,
          "vulnerability_code": "    function stringToBytes32(\n\n        string memory source\n\n    )\n\n    internal\n\n    pure\n\n    returns (bytes32 result)\n\n    {\n\n        bytes memory tempEmptyStringTest = bytes(source);\n\n        if (tempEmptyStringTest.length == 0) {\n\n            return 0x0;\n\n        }\n\n        assembly {\n\n            result := mload(add(source, 32))\n\n        }\n",
          "message": "Utils.stringToBytes32 uses assembly (TwoKeyRegistryV1.sol#286-300)\n\t- TwoKeyRegistryV1.sol#297-300\n"
        },
        {
          "name": "constable-states",
          "vulnerability_from_line": 384,
          "vulnerability_to_line": null,
          "vulnerability_code": "    address internal _implementation;\n",
          "message": "UpgradeabilityStorage._implementation should be constant (TwoKeyRegistryV1.sol#384)\n"
        },
        {
          "name": "pragma",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.24;\n",
          "message": "Different versions of Solidity is used in TwoKeyRegistryV1.sol:\n\t- Version used: ['^0.4.0', '^0.4.24']\n\t- TwoKeyRegistryV1.sol#3 declares pragma solidity^0.4.24\n\t- TwoKeyRegistryV1.sol#266 declares pragma solidity^0.4.24\n\t- TwoKeyRegistryV1.sol#274 declares pragma solidity^0.4.0\n\t- TwoKeyRegistryV1.sol#333 declares pragma solidity^0.4.24\n\t- TwoKeyRegistryV1.sol#373 declares pragma solidity^0.4.24\n\t- TwoKeyRegistryV1.sol#397 declares pragma solidity^0.4.24\n\t- TwoKeyRegistryV1.sol#411 declares pragma solidity^0.4.24\n\t- TwoKeyRegistryV1.sol#424 declares pragma solidity^0.4.24\n\t- TwoKeyRegistryV1.sol#447 declares pragma solidity^0.4.0\n\t- TwoKeyRegistryV1.sol#498 declares pragma solidity^0.4.24\n\t- TwoKeyRegistryV1.sol#506 declares pragma solidity^0.4.24\n\t- TwoKeyRegistryV1.sol#940 declares pragma solidity^0.4.24\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 6,
          "vulnerability_to_line": 32,
          "vulnerability_code": "    function params0(address c, bytes _method) public view returns (uint answer) {\n\n        // https://medium.com/@blockchain101/calling-the-function-of-another-contract-in-solidity-f9edfa921f4c\n\n        //    dc = c;\n\n        bytes4 sig = bytes4(keccak256(_method));\n\n        assembly {\n\n        // move pointer to free memory spot\n\n            let ptr := mload(0x40)\n\n        // put function sig at memory spot\n\n            mstore(ptr,sig)\n\n\n\n            let result := call(  // use WARNING because this should be staticcall BUT geth crash!\n\n            15000, // gas limit\n\n            c, // sload(dc_slot),  // to addr. append var to _slot to access storage variable\n\n            0, // not transfer any ether (comment if using staticcall)\n\n            ptr, // Inputs are stored at location ptr\n\n            0x04, // Inputs are 0 bytes long\n\n            ptr,  //Store output over input\n\n            0x20) //Outputs are 1 bytes long\n\n\n\n            if eq(result, 0) {\n\n                revert(0, 0)\n\n            }\n\n\n\n            answer := mload(ptr) // Assign output to answer var\n\n            mstore(0x40,add(ptr,0x24)) // Set storage pointer to new space\n\n        }\n",
          "message": "Call.params0 (TwoKeyRegistryV1.sol#6-32) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 34,
          "vulnerability_to_line": 62,
          "vulnerability_code": "    function params1(address c, bytes _method, uint _val) public view returns (uint answer) {\n\n        // https://medium.com/@blockchain101/calling-the-function-of-another-contract-in-solidity-f9edfa921f4c\n\n        //    dc = c;\n\n        bytes4 sig = bytes4(keccak256(_method));\n\n        assembly {\n\n        // move pointer to free memory spot\n\n            let ptr := mload(0x40)\n\n        // put function sig at memory spot\n\n            mstore(ptr,sig)\n\n        // append argument after function sig\n\n            mstore(add(ptr,0x04), _val)\n\n\n\n            let result := call(  // use WARNING because this should be staticcall BUT geth crash!\n\n            15000, // gas limit\n\n            c, // sload(dc_slot),  // to addr. append var to _slot to access storage variable\n\n            0, // not transfer any ether (comment if using staticcall)\n\n            ptr, // Inputs are stored at location ptr\n\n            0x24, // Inputs are 0 bytes long\n\n            ptr,  //Store output over input\n\n            0x20) //Outputs are 1 bytes long\n\n\n\n            if eq(result, 0) {\n\n                revert(0, 0)\n\n            }\n\n\n\n            answer := mload(ptr) // Assign output to answer var\n\n            mstore(0x40,add(ptr,0x24)) // Set storage pointer to new space\n\n        }\n",
          "message": "Call.params1 (TwoKeyRegistryV1.sol#34-62) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 64,
          "vulnerability_to_line": 94,
          "vulnerability_code": "    function params2(address c, bytes _method, uint _val1, uint _val2) public view returns (uint answer) {\n\n        // https://medium.com/@blockchain101/calling-the-function-of-another-contract-in-solidity-f9edfa921f4c\n\n        //    dc = c;\n\n        bytes4 sig = bytes4(keccak256(_method));\n\n        assembly {\n\n        // move pointer to free memory spot\n\n            let ptr := mload(0x40)\n\n        // put function sig at memory spot\n\n            mstore(ptr,sig)\n\n        // append argument after function sig\n\n            mstore(add(ptr,0x04), _val1)\n\n            mstore(add(ptr,0x24), _val2)\n\n\n\n            let result := call(  // use WARNING because this should be staticcall BUT geth crash!\n\n            15000, // gas limit\n\n            c, // sload(dc_slot),  // to addr. append var to _slot to access storage variable\n\n            0, // not transfer any ether (comment if using staticcall)\n\n            ptr, // Inputs are stored at location ptr\n\n            0x44, // Inputs are 4 bytes for signature and 2 uint256\n\n            ptr,  //Store output over input\n\n            0x20) //Outputs are 1 uint long\n\n\n\n        // TODO cause revert\n\n        //            if eq(result, 0) {\n\n        //                revert(0, 0)\n\n        //            }\n\n\n\n            answer := mload(ptr) // Assign output to answer var\n\n            mstore(0x40,add(ptr,0x20)) // Set storage pointer to new space\n\n        }\n",
          "message": "Call.params2 (TwoKeyRegistryV1.sol#64-94) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 236,
          "vulnerability_to_line": 261,
          "vulnerability_code": "    function recoverSig(bytes sig, address old_key, address last_address) public pure returns (address[], address[], uint8[]) {\n\n        // validate sig AND\n\n        // recover the information from the signature: influencers, public_link_keys, weights/cuts\n\n        // influencers may have one more address than the keys and weights arrays\n\n        //\n\n        require(old_key != address(0),'no public link key');\n\n\n\n        address[] memory influencers;\n\n        address[] memory keys;\n\n        uint8[] memory weights;\n\n        uint[] memory offsets;\n\n        (influencers, keys, weights, offsets) = recoverSigParts(sig, last_address);\n\n\n\n        // check if we received a valid signature\n\n        for(uint i = 0; i < influencers.length; i++) {\n\n            if (i < weights.length) {\n\n                require (recoverHash(keccak256(abi.encodePacked(weights[i], keys[i], influencers[i])),sig,offsets[i]) == old_key, 'illegal signature');\n\n                old_key = keys[i];\n\n            } else {\n\n                // signed message for the last step is the address of the converter\n\n                require (recoverHash(keccak256(abi.encodePacked(influencers[i])),sig,offsets[i]) == old_key, 'illegal last signature');\n\n            }\n\n        }\n\n\n\n        return (influencers, keys, weights);\n",
          "message": "Call.recoverSig (TwoKeyRegistryV1.sol#236-261) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 269,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function onlyMaintainer(address _sender) public view returns (bool);\n",
          "message": "ITwoKeyMaintainersRegistry.onlyMaintainer (TwoKeyRegistryV1.sol#269) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 360,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function addVersion(string _contractName, string version, address implementation) public;\n",
          "message": "ITwoKeySingletonesRegistry.addVersion (TwoKeyRegistryV1.sol#360) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 368,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getVersion(string _contractName, string version) public view returns (address);\n",
          "message": "ITwoKeySingletonesRegistry.getVersion (TwoKeyRegistryV1.sol#368) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 390,
          "vulnerability_to_line": 392,
          "vulnerability_code": "    function implementation() public view returns (address) {\n\n        return _implementation;\n",
          "message": "UpgradeabilityStorage.implementation (TwoKeyRegistryV1.sol#390-392) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 404,
          "vulnerability_to_line": 406,
          "vulnerability_code": "    function initialize(address sender) public payable {\n\n        require(msg.sender == address(registry));\n",
          "message": "Upgradeable.initialize (TwoKeyRegistryV1.sol#404-406) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 417,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getContractProxyAddress(string _contractName) public view returns (address);\n",
          "message": "ITwoKeySingletoneRegistryFetchAddress.getContractProxyAddress (TwoKeyRegistryV1.sol#417) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 418,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getNonUpgradableContractAddress(string contractName) public view returns (address);\n",
          "message": "ITwoKeySingletoneRegistryFetchAddress.getNonUpgradableContractAddress (TwoKeyRegistryV1.sol#418) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 419,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getLatestContractVersion(string contractName) public view returns (string);\n",
          "message": "ITwoKeySingletoneRegistryFetchAddress.getLatestContractVersion (TwoKeyRegistryV1.sol#419) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 579,
          "vulnerability_to_line": 593,
          "vulnerability_code": "    function addNameAndSetWalletName(\n\n        string _name,\n\n        address _sender,\n\n        string _fullName,\n\n        string _email,\n\n        string _username_walletName,\n\n        bytes _signatureName,\n\n        bytes _signatureWalletName\n\n    )\n\n    public\n\n    {\n\n        require(isMaintainer(msg.sender));\n\n        addName(_name, _sender, _fullName, _email, _signatureName);\n\n        setWalletName(_name, _sender, _username_walletName, _signatureWalletName);\n",
          "message": "TwoKeyRegistry.addNameAndSetWalletName (TwoKeyRegistryV1.sol#579-593) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 628,
          "vulnerability_to_line": 639,
          "vulnerability_code": "    function addNameSigned(\n\n        string _name,\n\n        bytes external_sig\n\n    )\n\n    public\n\n    {\n\n        bytes32 hash = keccak256(abi.encodePacked(keccak256(abi.encodePacked(\"bytes binding to name\")),\n\n            keccak256(abi.encodePacked(_name))));\n\n        address eth_address = Call.recoverHash(hash,external_sig,0);\n\n        require (msg.sender == eth_address || isMaintainer(msg.sender) == true, \"only maintainer or user can change name\");\n\n        addNameInternal(_name, eth_address);\n",
          "message": "TwoKeyRegistry.addNameSigned (TwoKeyRegistryV1.sol#628-639) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 651,
          "vulnerability_to_line": 658,
          "vulnerability_code": "    function setNoteByUser(\n\n        bytes note\n\n    )\n\n    public\n\n    {\n\n        // note is a message you can store with sig. For example it could be the secret you used encrypted by you\n\n        setNoteInternal(note, msg.sender);\n",
          "message": "TwoKeyRegistry.setNoteByUser (TwoKeyRegistryV1.sol#651-658) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 713,
          "vulnerability_to_line": 719,
          "vulnerability_code": "    function addPlasma2EthereumByUser(\n\n        bytes sig\n\n    )\n\n    public\n\n    {\n\n        addPlasma2EthereumInternal(sig, msg.sender);\n",
          "message": "TwoKeyRegistry.addPlasma2EthereumByUser (TwoKeyRegistryV1.sol#713-719) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 721,
          "vulnerability_to_line": 734,
          "vulnerability_code": "    function setPlasma2EthereumAndNoteSigned(\n\n        bytes sig,\n\n        bytes note,\n\n        bytes external_sig\n\n    )\n\n    public\n\n    {\n\n        bytes32 hash = keccak256(abi.encodePacked(keccak256(abi.encodePacked(\"bytes binding to ethereum-plasma\")),\n\n            keccak256(abi.encodePacked(sig,note))));\n\n        address eth_address = Call.recoverHash(hash,external_sig,0);\n\n        require (msg.sender == eth_address || isMaintainer(msg.sender), \"only maintainer or user can change ethereum-plasma\");\n\n        addPlasma2EthereumInternal(sig, eth_address);\n\n        setNoteInternal(note, eth_address);\n",
          "message": "TwoKeyRegistry.setPlasma2EthereumAndNoteSigned (TwoKeyRegistryV1.sol#721-734) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 803,
          "vulnerability_to_line": 816,
          "vulnerability_code": "    function getPlasmaToEthereum(\n\n        address plasma\n\n    )\n\n    public\n\n    view\n\n    returns (address)\n\n    {\n\n        bytes32 keyHashPlasmaToEthereum = keccak256(\"plasma2ethereum\", plasma);\n\n        address ethereum = PROXY_STORAGE_CONTRACT.getAddress(keyHashPlasmaToEthereum);\n\n        if(ethereum!= address(0)) {\n\n            return ethereum;\n\n        }\n\n        return plasma;\n",
          "message": "TwoKeyRegistry.getPlasmaToEthereum (TwoKeyRegistryV1.sol#803-816) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 823,
          "vulnerability_to_line": 836,
          "vulnerability_code": "    function getEthereumToPlasma(\n\n        address ethereum\n\n    )\n\n    public\n\n    view\n\n    returns (address)\n\n    {\n\n        bytes32 keyHashEthereumToPlasma = keccak256(\"ethereum2plasma\", ethereum);\n\n        address plasma = PROXY_STORAGE_CONTRACT.getAddress(keyHashEthereumToPlasma);\n\n        if(plasma != address(0)) {\n\n            return plasma;\n\n        }\n\n        return ethereum;\n",
          "message": "TwoKeyRegistry.getEthereumToPlasma (TwoKeyRegistryV1.sol#823-836) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 884,
          "vulnerability_to_line": 892,
          "vulnerability_code": "    function notes(\n\n        address keyAddress\n\n    )\n\n    public\n\n    view\n\n    returns (bytes)\n\n    {\n\n        return PROXY_STORAGE_CONTRACT.getBytes(keccak256(\"notes\", keyAddress));\n",
          "message": "TwoKeyRegistry.notes (TwoKeyRegistryV1.sol#884-892) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 894,
          "vulnerability_to_line": 902,
          "vulnerability_code": "    function address2walletTag(\n\n        address keyAddress\n\n    )\n\n    public\n\n    view\n\n    returns (bytes32)\n\n    {\n\n        return PROXY_STORAGE_CONTRACT.getBytes32(keccak256(\"address2walletTag\", keyAddress));\n",
          "message": "TwoKeyRegistry.address2walletTag (TwoKeyRegistryV1.sol#894-902) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 904,
          "vulnerability_to_line": 912,
          "vulnerability_code": "    function walletTag2address(\n\n        bytes32 walletTag\n\n    )\n\n    public\n\n    view\n\n    returns (address)\n\n    {\n\n        return PROXY_STORAGE_CONTRACT.getAddress(keccak256(\"walletTag2address\", walletTag));\n",
          "message": "TwoKeyRegistry.walletTag2address (TwoKeyRegistryV1.sol#904-912) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 914,
          "vulnerability_to_line": 922,
          "vulnerability_code": "    function address2username(\n\n        address keyAddress\n\n    )\n\n    public\n\n    view\n\n    returns (string)\n\n    {\n\n        return PROXY_STORAGE_CONTRACT.getString(keccak256(\"address2username\", keyAddress));\n",
          "message": "TwoKeyRegistry.address2username (TwoKeyRegistryV1.sol#914-922) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 924,
          "vulnerability_to_line": 932,
          "vulnerability_code": "    function username2currentAddress(\n\n        bytes32 _username\n\n    )\n\n    public\n\n    view\n\n    returns (address)\n\n    {\n\n        return PROXY_STORAGE_CONTRACT.getAddress(keccak256(\"username2currentAddress\", _username));\n",
          "message": "TwoKeyRegistry.username2currentAddress (TwoKeyRegistryV1.sol#924-932) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 943,
          "vulnerability_to_line": 947,
          "vulnerability_code": "    function getMaintainers() public view returns (address[]) {\n\n        address [] memory add = new address[](1);\n\n        add[0] = 0x9aace881c7a80b596d38eaff66edbb5368d2f2c5;\n\n        return add;\n",
          "message": "TwoKeyRegistryV1.getMaintainers (TwoKeyRegistryV1.sol#943-947) should be declared external\n"
        },
        {
          "name": "solc-version",
          "vulnerability_from_line": 274,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.0;\n",
          "message": "Detected issues with version pragma in TwoKeyRegistryV1.sol:\n\t- pragma solidity^0.4.0 (TwoKeyRegistryV1.sol#274): it allows old versions\n\t- pragma solidity^0.4.0 (TwoKeyRegistryV1.sol#447): it allows old versions\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 6,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function params0(address c, bytes _method) public view returns (uint answer) {\n",
          "message": "Parameter '_method' of Call.params0 (TwoKeyRegistryV1.sol#6) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 34,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function params1(address c, bytes _method, uint _val) public view returns (uint answer) {\n",
          "message": "Parameter '_method' of Call.params1 (TwoKeyRegistryV1.sol#34) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 64,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function params2(address c, bytes _method, uint _val1, uint _val2) public view returns (uint answer) {\n",
          "message": "Parameter '_method' of Call.params2 (TwoKeyRegistryV1.sol#64) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 169,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function recoverSigParts(bytes sig, address last_address) private pure returns (address[], address[], uint8[], uint[]) {\n",
          "message": "Parameter 'last_address' of Call.recoverSigParts (TwoKeyRegistryV1.sol#169) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 236,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function recoverSig(bytes sig, address old_key, address last_address) public pure returns (address[], address[], uint8[]) {\n",
          "message": "Parameter 'old_key' of Call.recoverSig (TwoKeyRegistryV1.sol#236) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 236,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function recoverSig(bytes sig, address old_key, address last_address) public pure returns (address[], address[], uint8[]) {\n",
          "message": "Parameter 'last_address' of Call.recoverSig (TwoKeyRegistryV1.sol#236) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 308,
          "vulnerability_to_line": null,
          "vulnerability_code": "        string _a,\n",
          "message": "Parameter '_a' of Utils.strConcat (TwoKeyRegistryV1.sol#308) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 309,
          "vulnerability_to_line": null,
          "vulnerability_code": "        string _b,\n",
          "message": "Parameter '_b' of Utils.strConcat (TwoKeyRegistryV1.sol#309) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 310,
          "vulnerability_to_line": null,
          "vulnerability_code": "        string _c\n",
          "message": "Parameter '_c' of Utils.strConcat (TwoKeyRegistryV1.sol#310) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 384,
          "vulnerability_to_line": null,
          "vulnerability_code": "    address internal _implementation;\n",
          "message": "Variable 'UpgradeabilityStorage._implementation' (TwoKeyRegistryV1.sol#384) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 429,
          "vulnerability_to_line": null,
          "vulnerability_code": "    address public TWO_KEY_SINGLETON_REGISTRY;\n",
          "message": "Variable 'ITwoKeySingletonUtils.TWO_KEY_SINGLETON_REGISTRY' (TwoKeyRegistryV1.sol#429) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 535,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address _twoKeySingletonesRegistry,\n",
          "message": "Parameter '_twoKeySingletonesRegistry' of TwoKeyRegistry.setInitialParams (TwoKeyRegistryV1.sol#535) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 536,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address _proxyStorage\n",
          "message": "Parameter '_proxyStorage' of TwoKeyRegistry.setInitialParams (TwoKeyRegistryV1.sol#536) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 555,
          "vulnerability_to_line": null,
          "vulnerability_code": "        string _name,\n",
          "message": "Parameter '_name' of TwoKeyRegistry.addNameInternal (TwoKeyRegistryV1.sol#555) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 556,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address _sender\n",
          "message": "Parameter '_sender' of TwoKeyRegistry.addNameInternal (TwoKeyRegistryV1.sol#556) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 580,
          "vulnerability_to_line": null,
          "vulnerability_code": "        string _name,\n",
          "message": "Parameter '_name' of TwoKeyRegistry.addNameAndSetWalletName (TwoKeyRegistryV1.sol#580) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 581,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address _sender,\n",
          "message": "Parameter '_sender' of TwoKeyRegistry.addNameAndSetWalletName (TwoKeyRegistryV1.sol#581) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 582,
          "vulnerability_to_line": null,
          "vulnerability_code": "        string _fullName,\n",
          "message": "Parameter '_fullName' of TwoKeyRegistry.addNameAndSetWalletName (TwoKeyRegistryV1.sol#582) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 583,
          "vulnerability_to_line": null,
          "vulnerability_code": "        string _email,\n",
          "message": "Parameter '_email' of TwoKeyRegistry.addNameAndSetWalletName (TwoKeyRegistryV1.sol#583) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 584,
          "vulnerability_to_line": null,
          "vulnerability_code": "        string _username_walletName,\n",
          "message": "Parameter '_username_walletName' of TwoKeyRegistry.addNameAndSetWalletName (TwoKeyRegistryV1.sol#584) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 585,
          "vulnerability_to_line": null,
          "vulnerability_code": "        bytes _signatureName,\n",
          "message": "Parameter '_signatureName' of TwoKeyRegistry.addNameAndSetWalletName (TwoKeyRegistryV1.sol#585) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 586,
          "vulnerability_to_line": null,
          "vulnerability_code": "        bytes _signatureWalletName\n",
          "message": "Parameter '_signatureWalletName' of TwoKeyRegistry.addNameAndSetWalletName (TwoKeyRegistryV1.sol#586) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 599,
          "vulnerability_to_line": null,
          "vulnerability_code": "        string _name,\n",
          "message": "Parameter '_name' of TwoKeyRegistry.addName (TwoKeyRegistryV1.sol#599) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 600,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address _sender,\n",
          "message": "Parameter '_sender' of TwoKeyRegistry.addName (TwoKeyRegistryV1.sol#600) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 601,
          "vulnerability_to_line": null,
          "vulnerability_code": "        string _fullName,\n",
          "message": "Parameter '_fullName' of TwoKeyRegistry.addName (TwoKeyRegistryV1.sol#601) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 602,
          "vulnerability_to_line": null,
          "vulnerability_code": "        string _email,\n",
          "message": "Parameter '_email' of TwoKeyRegistry.addName (TwoKeyRegistryV1.sol#602) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 629,
          "vulnerability_to_line": null,
          "vulnerability_code": "        string _name,\n",
          "message": "Parameter '_name' of TwoKeyRegistry.addNameSigned (TwoKeyRegistryV1.sol#629) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 630,
          "vulnerability_to_line": null,
          "vulnerability_code": "        bytes external_sig\n",
          "message": "Parameter 'external_sig' of TwoKeyRegistry.addNameSigned (TwoKeyRegistryV1.sol#630) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 667,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address _address,\n",
          "message": "Parameter '_address' of TwoKeyRegistry.setWalletName (TwoKeyRegistryV1.sol#667) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 668,
          "vulnerability_to_line": null,
          "vulnerability_code": "        string memory _username_walletName,\n",
          "message": "Parameter '_username_walletName' of TwoKeyRegistry.setWalletName (TwoKeyRegistryV1.sol#668) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 696,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address eth_address\n",
          "message": "Parameter 'eth_address' of TwoKeyRegistry.addPlasma2EthereumInternal (TwoKeyRegistryV1.sol#696) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 724,
          "vulnerability_to_line": null,
          "vulnerability_code": "        bytes external_sig\n",
          "message": "Parameter 'external_sig' of TwoKeyRegistry.setPlasma2EthereumAndNoteSigned (TwoKeyRegistryV1.sol#724) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 741,
          "vulnerability_to_line": null,
          "vulnerability_code": "        string _name\n",
          "message": "Parameter '_name' of TwoKeyRegistry.getUserName2UserAddress (TwoKeyRegistryV1.sol#741) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 756,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address _sender\n",
          "message": "Parameter '_sender' of TwoKeyRegistry.getUserAddress2UserName (TwoKeyRegistryV1.sol#756) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 845,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address _userAddress\n",
          "message": "Parameter '_userAddress' of TwoKeyRegistry.checkIfUserExists (TwoKeyRegistryV1.sol#845) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 866,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address _user\n",
          "message": "Parameter '_user' of TwoKeyRegistry.getUserData (TwoKeyRegistryV1.sol#866) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 925,
          "vulnerability_to_line": null,
          "vulnerability_code": "        bytes32 _username\n",
          "message": "Parameter '_username' of TwoKeyRegistry.username2currentAddress (TwoKeyRegistryV1.sol#925) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 519,
          "vulnerability_to_line": null,
          "vulnerability_code": "    ITwoKeyRegistryStorage public PROXY_STORAGE_CONTRACT;\n",
          "message": "Variable 'TwoKeyRegistry.PROXY_STORAGE_CONTRACT' (TwoKeyRegistryV1.sol#519) is not in mixedCase\n"
        }
      ]
    },
    "smartcheck": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 945,
          "vulnerability_to_line": null,
          "vulnerability_code": "        add[0] = 0x9aace881c7a80b596d38eaff66edbb5368d2f2c5;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 295,
          "vulnerability_to_line": null,
          "vulnerability_code": "            return 0x0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 250,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(uint i = 0; i < influencers.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 322,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 323,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 324,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 195,
          "vulnerability_to_line": null,
          "vulnerability_code": "        while (idx + 65 <= sig.length) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
          "vulnerability_from_line": 6,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function params0(address c, bytes _method) public view returns (uint answer) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
          "vulnerability_from_line": 34,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function params1(address c, bytes _method, uint _val) public view returns (uint answer) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
          "vulnerability_from_line": 64,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function params2(address c, bytes _method, uint _val1, uint _val2) public view returns (uint answer) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 250,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(uint i = 0; i < influencers.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 322,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 323,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 324,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 195,
          "vulnerability_to_line": null,
          "vulnerability_code": "        while (idx + 65 <= sig.length) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_LOCKED_MONEY",
          "vulnerability_from_line": 399,
          "vulnerability_to_line": null,
          "vulnerability_code": "contract Upgradeable is UpgradeabilityStorage {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.24;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 266,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.24;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 274,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 333,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.24;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 373,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.24;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 397,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.24;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 411,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.24;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 424,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.24;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 447,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 498,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.24;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 506,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.24;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 940,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.24;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_REVERT_REQUIRE",
          "vulnerability_from_line": 566,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (PROXY_STORAGE_CONTRACT.getAddress(keyHashUserNameToAddress) != address(0)) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 96,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function loadAddress(bytes sig, uint idx) public pure returns (address) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 106,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function loadUint8(bytes sig, uint idx) public pure returns (uint8) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 117,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function recoverHash(bytes32 hash, bytes sig, uint idx) public pure returns (address) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 286,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function stringToBytes32(\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
          "vulnerability_from_line": 6,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function params0(address c, bytes _method) public view returns (uint answer) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
          "vulnerability_from_line": 34,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function params1(address c, bytes _method, uint _val) public view returns (uint answer) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
          "vulnerability_from_line": 64,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function params2(address c, bytes _method, uint _val1, uint _val2) public view returns (uint answer) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 154,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function recoverSigMemory(bytes sig) private pure returns (address[], address[], uint8[], uint[], uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 169,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function recoverSigParts(bytes sig, address last_address) private pure returns (address[], address[], uint8[], uint[]) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 562,
          "vulnerability_to_line": null,
          "vulnerability_code": "        bytes32 keyHashUserNameToAddress = keccak256(\"username2currentAddress\", name);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 563,
          "vulnerability_to_line": null,
          "vulnerability_code": "        bytes32 keyHashAddressToUserName = keccak256(\"address2username\", _sender);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 614,
          "vulnerability_to_line": null,
          "vulnerability_code": "        bytes32 keyHashUsername = keccak256(\"addressToUserData\", \"username\", _sender);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 615,
          "vulnerability_to_line": null,
          "vulnerability_code": "        bytes32 keyHashFullName = keccak256(\"addressToUserData\", \"fullName\", _sender);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 616,
          "vulnerability_to_line": null,
          "vulnerability_code": "        bytes32 keyHashEmail = keccak256(\"addressToUserData\", \"email\", _sender);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 647,
          "vulnerability_to_line": null,
          "vulnerability_code": "        bytes32 keyHashNotes = keccak256(\"notes\", me);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 676,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address usersAddress = PROXY_STORAGE_CONTRACT.getAddress(keccak256(\"username2currentAddress\", usernameHex));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 687,
          "vulnerability_to_line": null,
          "vulnerability_code": "        bytes32 keyHashAddress2WalletTag = keccak256(\"address2walletTag\", _address);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 690,
          "vulnerability_to_line": null,
          "vulnerability_code": "        bytes32 keyHashWalletTag2Address = keccak256(\"walletTag2address\", walletTag);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 704,
          "vulnerability_to_line": null,
          "vulnerability_code": "        bytes32 keyHashPlasmaToEthereum = keccak256(\"plasma2ethereum\", plasma_address);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 705,
          "vulnerability_to_line": null,
          "vulnerability_code": "        bytes32 keyHashEthereumToPlasma = keccak256(\"ethereum2plasma\", eth_address);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 748,
          "vulnerability_to_line": null,
          "vulnerability_code": "        return PROXY_STORAGE_CONTRACT.getAddress(keccak256(\"username2currentAddress\", _name));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 762,
          "vulnerability_to_line": null,
          "vulnerability_code": "        return PROXY_STORAGE_CONTRACT.getString(keccak256(\"address2username\", _sender));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 810,
          "vulnerability_to_line": null,
          "vulnerability_code": "        bytes32 keyHashPlasmaToEthereum = keccak256(\"plasma2ethereum\", plasma);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 830,
          "vulnerability_to_line": null,
          "vulnerability_code": "        bytes32 keyHashEthereumToPlasma = keccak256(\"ethereum2plasma\", ethereum);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 851,
          "vulnerability_to_line": null,
          "vulnerability_code": "        string memory username = PROXY_STORAGE_CONTRACT.getString(keccak256(\"address2username\", _userAddress));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 853,
          "vulnerability_to_line": null,
          "vulnerability_code": "        bytes32 keyHashEthereumToPlasma = keccak256(\"ethereum2plasma\", _userAddress);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 856,
          "vulnerability_to_line": null,
          "vulnerability_code": "        bytes memory savedNotes = PROXY_STORAGE_CONTRACT.getBytes(keccak256(\"notes\", _userAddress));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 857,
          "vulnerability_to_line": null,
          "vulnerability_code": "        bytes32 walletTag = PROXY_STORAGE_CONTRACT.getBytes32(keccak256(\"address2walletTag\", _userAddress));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 872,
          "vulnerability_to_line": null,
          "vulnerability_code": "        bytes32 keyHashUsername = keccak256(\"addressToUserData\", \"username\", _user);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 873,
          "vulnerability_to_line": null,
          "vulnerability_code": "        bytes32 keyHashFullName = keccak256(\"addressToUserData\", \"fullName\", _user);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 874,
          "vulnerability_to_line": null,
          "vulnerability_code": "        bytes32 keyHashEmail = keccak256(\"addressToUserData\", \"email\", _user);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 891,
          "vulnerability_to_line": null,
          "vulnerability_code": "        return PROXY_STORAGE_CONTRACT.getBytes(keccak256(\"notes\", keyAddress));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 901,
          "vulnerability_to_line": null,
          "vulnerability_code": "        return PROXY_STORAGE_CONTRACT.getBytes32(keccak256(\"address2walletTag\", keyAddress));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 911,
          "vulnerability_to_line": null,
          "vulnerability_code": "        return PROXY_STORAGE_CONTRACT.getAddress(keccak256(\"walletTag2address\", walletTag));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 921,
          "vulnerability_to_line": null,
          "vulnerability_code": "        return PROXY_STORAGE_CONTRACT.getString(keccak256(\"address2username\", keyAddress));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 931,
          "vulnerability_to_line": null,
          "vulnerability_code": "        return PROXY_STORAGE_CONTRACT.getAddress(keccak256(\"username2currentAddress\", _username));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 6,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function params0(address c, bytes _method) public view returns (uint answer) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 34,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function params1(address c, bytes _method, uint _val) public view returns (uint answer) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 64,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function params2(address c, bytes _method, uint _val1, uint _val2) public view returns (uint answer) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 96,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function loadAddress(bytes sig, uint idx) public pure returns (address) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 106,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function loadUint8(bytes sig, uint idx) public pure returns (uint8) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 117,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function recoverHash(bytes32 hash, bytes sig, uint idx) public pure returns (address) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 154,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function recoverSigMemory(bytes sig) private pure returns (address[], address[], uint8[], uint[], uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 154,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function recoverSigMemory(bytes sig) private pure returns (address[], address[], uint8[], uint[], uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 154,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function recoverSigMemory(bytes sig) private pure returns (address[], address[], uint8[], uint[], uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 154,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function recoverSigMemory(bytes sig) private pure returns (address[], address[], uint8[], uint[], uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 154,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function recoverSigMemory(bytes sig) private pure returns (address[], address[], uint8[], uint[], uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 169,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function recoverSigParts(bytes sig, address last_address) private pure returns (address[], address[], uint8[], uint[]) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 169,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function recoverSigParts(bytes sig, address last_address) private pure returns (address[], address[], uint8[], uint[]) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 169,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function recoverSigParts(bytes sig, address last_address) private pure returns (address[], address[], uint8[], uint[]) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 169,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function recoverSigParts(bytes sig, address last_address) private pure returns (address[], address[], uint8[], uint[]) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 169,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function recoverSigParts(bytes sig, address last_address) private pure returns (address[], address[], uint8[], uint[]) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 236,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function recoverSig(bytes sig, address old_key, address last_address) public pure returns (address[], address[], uint8[]) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 236,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function recoverSig(bytes sig, address old_key, address last_address) public pure returns (address[], address[], uint8[]) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 236,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function recoverSig(bytes sig, address old_key, address last_address) public pure returns (address[], address[], uint8[]) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 236,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function recoverSig(bytes sig, address old_key, address last_address) public pure returns (address[], address[], uint8[]) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 308,
          "vulnerability_to_line": null,
          "vulnerability_code": "        string _a,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 309,
          "vulnerability_to_line": null,
          "vulnerability_code": "        string _b,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 310,
          "vulnerability_to_line": null,
          "vulnerability_code": "        string _c\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 314,
          "vulnerability_to_line": null,
          "vulnerability_code": "    returns (string)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 360,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function addVersion(string _contractName, string version, address implementation) public;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 360,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function addVersion(string _contractName, string version, address implementation) public;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 368,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getVersion(string _contractName, string version) public view returns (address);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 368,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getVersion(string _contractName, string version) public view returns (address);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 417,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getContractProxyAddress(string _contractName) public view returns (address);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 418,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getNonUpgradableContractAddress(string contractName) public view returns (address);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 419,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getLatestContractVersion(string contractName) public view returns (string);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 419,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getLatestContractVersion(string contractName) public view returns (string);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 439,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getAddressFromTwoKeySingletonRegistry(string contractName) internal view returns (address) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 555,
          "vulnerability_to_line": null,
          "vulnerability_code": "        string _name,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 580,
          "vulnerability_to_line": null,
          "vulnerability_code": "        string _name,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 582,
          "vulnerability_to_line": null,
          "vulnerability_code": "        string _fullName,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 583,
          "vulnerability_to_line": null,
          "vulnerability_code": "        string _email,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 584,
          "vulnerability_to_line": null,
          "vulnerability_code": "        string _username_walletName,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 585,
          "vulnerability_to_line": null,
          "vulnerability_code": "        bytes _signatureName,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 586,
          "vulnerability_to_line": null,
          "vulnerability_code": "        bytes _signatureWalletName\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 599,
          "vulnerability_to_line": null,
          "vulnerability_code": "        string _name,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 601,
          "vulnerability_to_line": null,
          "vulnerability_code": "        string _fullName,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 602,
          "vulnerability_to_line": null,
          "vulnerability_code": "        string _email,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 603,
          "vulnerability_to_line": null,
          "vulnerability_code": "        bytes signature\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 629,
          "vulnerability_to_line": null,
          "vulnerability_code": "        string _name,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 630,
          "vulnerability_to_line": null,
          "vulnerability_code": "        bytes external_sig\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 642,
          "vulnerability_to_line": null,
          "vulnerability_code": "        bytes note,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 652,
          "vulnerability_to_line": null,
          "vulnerability_code": "        bytes note\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 669,
          "vulnerability_to_line": null,
          "vulnerability_code": "        bytes signature\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 695,
          "vulnerability_to_line": null,
          "vulnerability_code": "        bytes sig,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 714,
          "vulnerability_to_line": null,
          "vulnerability_code": "        bytes sig\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 722,
          "vulnerability_to_line": null,
          "vulnerability_code": "        bytes sig,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 723,
          "vulnerability_to_line": null,
          "vulnerability_code": "        bytes note,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 724,
          "vulnerability_to_line": null,
          "vulnerability_code": "        bytes external_sig\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 889,
          "vulnerability_to_line": null,
          "vulnerability_code": "    returns (bytes)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 919,
          "vulnerability_to_line": null,
          "vulnerability_code": "    returns (string)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 943,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getMaintainers() public view returns (address[]) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 10,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 38,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 68,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 99,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 109,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 125,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 132,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 139,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 297,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 360,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function addVersion(string _contractName, string version, address implementation) public;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 368,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getVersion(string _contractName, string version) public view returns (address);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 517,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bool initialized;\n",
          "message": null
        }
      ]
    },
    "oyente": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "Integer Overflow",
          "vulnerability_from_line": 106,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function loadUint8(bytes sig, uint idx) public pure returns (uint8) {\n",
          "message": null
        },
        {
          "name": "Integer Overflow",
          "vulnerability_from_line": 651,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setNoteByUser(\n",
          "message": null
        },
        {
          "name": "Integer Overflow",
          "vulnerability_from_line": 651,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setNoteByUser(\n",
          "message": null
        }
      ]
    },
    "mythril": {
      "successfull_analysis": false,
      "errors": [
        "DOCKER_TIMEOUT"
      ],
      "vulnerability_findings": []
    },
    "osiris": {
      "successfull_analysis": true,
      "errors": [
        "DOCKER_TIMEOUT"
      ],
      "vulnerability_findings": [
        {
          "name": "Overflow bugs",
          "vulnerability_from_line": 122,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require (sig.length >= 65+idx, 'bad signature length');\n",
          "message": null
        },
        {
          "name": "Underflow bugs",
          "vulnerability_from_line": 157,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint n_influencers = (sig.length-21) / (65+msg_len);\n",
          "message": null
        }
      ]
    }
  }
}