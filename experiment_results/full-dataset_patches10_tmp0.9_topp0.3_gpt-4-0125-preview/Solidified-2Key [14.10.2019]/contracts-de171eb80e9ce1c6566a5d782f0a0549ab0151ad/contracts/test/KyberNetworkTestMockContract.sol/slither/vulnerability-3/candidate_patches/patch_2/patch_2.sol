pragma solidity ^0.4.24;







contract ERC20Basic {
  function totalSupply() public view returns (uint256);
  function balanceOf(address _who) public view returns (uint256);
  function transfer(address _to, uint256 _value) public returns (bool);
  function allowance(address _ocwner, address _spender) public view returns (uint256);
  function approve(address spender, uint tokens) public returns (bool success);
  function transferFrom(address _from, address _to, uint256 _value) public returns (bool);

  event Transfer(address indexed from, address indexed to, uint256 value);
  event Approval(address indexed tokenOwner, address indexed spender, uint tokens);
}



pragma solidity ^0.4.24;





contract ERC20 is ERC20Basic {

}



pragma solidity ^0.4.24;






library SafeMath {

  


  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {
    
    
    
    if (_a == 0) {
      return 0;
    }

    c = _a * _b;
    require(c / _a == _b);
    return c;
  }

  


  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {
    
    
    
    return _a / _b;
  }

  


  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {
    require(_b <= _a);
    return _a - _b;
  }

  


  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {
    c = _a + _b;
    require(c >= _a);
    return c;
  }
}



pragma solidity ^0.4.24;







contract StandardTokenModified is ERC20Basic {

    using SafeMath for uint256;

    uint256 internal totalSupply_;
    string public name;
    string public symbol;
    uint8 public decimals;
    bool public transfersFrozen = false;


    mapping (address => mapping (address => uint256)) internal allowed;
    mapping(address => uint256) internal balances;

    modifier onlyIfNotFrozen {
        require(transfersFrozen == false);
        _;
    }

    





    function transferFrom(
        address _from,
        address _to,
        uint256 _value
    )
    public
    onlyIfNotFrozen
    returns (bool)
    {
        require(_value <= balances[_from]);
        require(_value <= allowed[_from][msg.sender]);
        require(_to != address(0));

        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
        emit Transfer(_from, _to, _value);
        return true;
    }

    








    function approve(address _spender, uint256 _value) public returns (bool) {
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    





    function allowance(
        address _owner,
        address _spender
    )
    public
    view
    returns (uint256)
    {
        return allowed[_owner][_spender];
    }

    








    function increaseApproval(
        address _spender,
        uint256 _addedValue
    )
    public
    returns (bool)
    {
        allowed[msg.sender][_spender] = (
        allowed[msg.sender][_spender].add(_addedValue));
        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
        return true;
    }

    








    function decreaseApproval(
        address _spender,
        uint256 _subtractedValue
    )
    public
    returns (bool)
    {
        uint256 oldValue = allowed[msg.sender][_spender];
        if (_subtractedValue >= oldValue) {
            allowed[msg.sender][_spender] = 0;
        } else {
            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
        }
        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
        return true;
    }

    


    function totalSupply() public view returns (uint256) {
        return totalSupply_;
    }

    




    function transfer(address _to, uint256 _value) public onlyIfNotFrozen returns (bool) {
        require(_value <= balances[msg.sender]);
        require(_to != address(0));
        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    




    function balanceOf(address _owner) public view returns (uint256) {
        return balances[_owner];
    }



}



pragma solidity ^0.4.24;





contract FungibleMockToken is StandardTokenModified {
    string public name;
    string public symbol;
    uint8 public decimals;

    constructor (string _name, string _symbol, address _owner) public {
        name = _name;
        symbol = _symbol;

        decimals = 18;
        totalSupply_= 1000000000000000000000000000; 
        balances[_owner]= totalSupply_;
    }


}


contract TestA {
    FungibleMockToken public ft;
    TestB public  tb;
    
    function setTestBAndFt(address _tb, address _ft) public {
        tb = TestB(_tb);
        ft = FungibleMockToken(_ft);
    }
    
    function x(address contractY) public {
        ft.approve(contractY, 100);
        tb.getTokens();
    }
}

contract TestB {
        FungibleMockToken public ft;

    function setTestBAndFt(address _ft) public {
        ft = FungibleMockToken(_ft);
    }
    
    function getTokens() public {
        ft.transferFrom(msg.sender, address(this), 100);
    }
}



pragma solidity ^0.4.0;


function swapEtherToToken(
    ERC20 token,
    uint minConversionRate
)
    external
    payable
    returns(uint)
{
    require(msg.value > 0, "Ether value must be greater than 0");
    // Implementation for swapping Ether to Token
    // This should include transfer of Ether to an appropriate recipient such as a liquidity pool,
    // and the issuance of tokens to the msg.sender based on the current conversion rate.
    // This is a mock example and should be replaced with actual logic.
    
    uint256 tokenAmount = msg.value * minConversionRate;
    // Assume token.transfer(msg.sender, tokenAmount) is the method to send tokens to the user.
    require(token.transfer(msg.sender, tokenAmount), "Failed to transfer tokens");

    return tokenAmount;
}