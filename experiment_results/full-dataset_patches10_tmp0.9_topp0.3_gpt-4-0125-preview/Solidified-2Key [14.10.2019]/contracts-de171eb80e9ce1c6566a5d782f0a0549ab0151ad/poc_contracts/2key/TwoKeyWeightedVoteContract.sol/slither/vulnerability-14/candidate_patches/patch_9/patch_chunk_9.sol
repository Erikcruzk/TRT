function transferSig(bytes sig) public returns (address[]) {
    require((sig.length-21) % (65+1+65+20) == 0, 'signature is not version 1 and/or does not include cut of last vote');
    
    address[] memory voters = super.transferSig(sig);

    for (uint i = 0; i < voters.length; i++) {
      address influencer = voters[i];

      
      uint256 cut = cutOf(influencer);
      bool new_votter = !voted[influencer];
      voted[influencer] = true;
      if (new_votter) {
        total_vote++;
      }
      bool yes;
      uint256 weight;
      if (0 < cut && cut <= 101) {
        yes = true;
        if (new_votter) {
          voted_yes++;
        }
        weight = cut-1;
      } else if (154 < cut && cut < 255) {
        yes = false;
        if (new_votter) {
          voted_no++;
        }
        weight = 255-cut;
      } else { 
        weight = 0;
      }
      if (new_votter) {
        if (yes) {
          total_weight += int(weight);
        } else {
          total_weight -= int(weight);
        }
      }
      weight -= voted_weight[influencer];

      if (weight > 0) {
        uint tokens = weight.mul(cost);

        {
            uint _units = Call.params1(erc20_token_sell_contract, "balanceOf(address)",uint(ethereumOf(influencer)));
            if (_units < tokens) {
              tokens = _units;
            }
            
            uint _allowance = Call.params2(erc20_token_sell_contract, "allowance(address,address)",uint(ethereumOf(influencer)),uint(this));
            if (_allowance < tokens) {
              tokens = _allowance;
            }
            
            if (tokens > 0) {
              weight = tokens.div(cost);
              if (yes) {
                weighted_yes += weight;
              } else {
                weighted_no += weight;
              }
              voted_weight[influencer] += weight;

              
              transferCoins(voters, i, tokens);
            }
        }
      }
    }

    return voters;
  }