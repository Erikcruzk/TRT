function transferSig(bytes sig) public returns (address[]) {
    address old_address;
    assembly {
      old_address := mload(add(sig, 21))
    }
    old_address = plasmaOf(old_address);
    address old_key = public_link_key[old_address];

    address[] memory influencers;
    address[] memory keys;
    uint8[] memory weights;
    (influencers, keys, weights) = Call.recoverSig(sig, old_key, plasmaOf(msg.sender));

    require(
            influencers[influencers.length-1] == senderPlasma() ||
            owner == msg.sender,'only the contractor or the last in the link can call transferSig');

    uint i;
    address new_address;
    
    for (i = 0; i < influencers.length; i++) {
      new_address = plasmaOf(influencers[i]);

      if (received_from[new_address] == 0) {
        if(!transferFromInternal(old_address, new_address, 1)) {
          revert("TransferFromInternal failed.");
        }
      } else {
        require(received_from[new_address] == old_address,'only tree ARCs allowed');
      }
      old_address = new_address;

      if (i < keys.length) {
        setPublicLinkKeyOf(new_address, keys[i]);
      }

      if (i < weights.length) {
        setCutOf(new_address, uint256(weights[i]));
      }
    }

    return influencers;
  }