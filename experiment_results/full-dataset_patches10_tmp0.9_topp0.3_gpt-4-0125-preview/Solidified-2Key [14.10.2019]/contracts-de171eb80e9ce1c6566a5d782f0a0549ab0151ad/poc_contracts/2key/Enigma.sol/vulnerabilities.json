{
  "smartbugs_completed": true,
  "analyzer_results": {
    "semgrep": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 679,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint pi = 0; pi < workersParams.length; pi++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 692,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint wi = 0; wi < workerAddresses.length; wi++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 694,
          "vulnerability_to_line": null,
          "vulnerability_code": "                workersParams[ti].workerAddresses.length++;\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 709,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < workersParams.length; i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 746,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < addrs.length; i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 753,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint iw = 0; iw < addrs.length; iw++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 451,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor(address _tokenAddress, address _principal) public {\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 452,
          "vulnerability_to_line": null,
          "vulnerability_code": "        engToken = IERC20(_tokenAddress);\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 453,
          "vulnerability_to_line": null,
          "vulnerability_code": "        principal = _principal;\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 454,
          "vulnerability_to_line": null,
          "vulnerability_code": "    }\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 679,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint pi = 0; pi < workersParams.length; pi++) {\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 681,
          "vulnerability_to_line": null,
          "vulnerability_code": "            if (workersParams[pi].firstBlockNumber == 0) {\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 684,
          "vulnerability_to_line": null,
          "vulnerability_code": "            } else if (workersParams[pi].firstBlockNumber < workersParams[ti].firstBlockNumber) {\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 684,
          "vulnerability_to_line": null,
          "vulnerability_code": "            } else if (workersParams[pi].firstBlockNumber < workersParams[ti].firstBlockNumber) {\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 692,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint wi = 0; wi < workerAddresses.length; wi++) {\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 693,
          "vulnerability_to_line": null,
          "vulnerability_code": "            if (workerAddresses[wi] != 0x0) {\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 694,
          "vulnerability_to_line": null,
          "vulnerability_code": "                workersParams[ti].workerAddresses.length++;\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 695,
          "vulnerability_to_line": null,
          "vulnerability_code": "                workersParams[ti].workerAddresses[wi] = workerAddresses[wi];\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 695,
          "vulnerability_to_line": null,
          "vulnerability_code": "                workersParams[ti].workerAddresses[wi] = workerAddresses[wi];\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 709,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < workersParams.length; i++) {\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 710,
          "vulnerability_to_line": null,
          "vulnerability_code": "            if (workersParams[i].firstBlockNumber <= blockNumber && (ci == - 1 || workersParams[i].firstBlockNumber > workersParams[uint(ci)].firstBlockNumber)) {\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 710,
          "vulnerability_to_line": null,
          "vulnerability_code": "            if (workersParams[i].firstBlockNumber <= blockNumber && (ci == - 1 || workersParams[i].firstBlockNumber > workersParams[uint(ci)].firstBlockNumber)) {\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 710,
          "vulnerability_to_line": null,
          "vulnerability_code": "            if (workersParams[i].firstBlockNumber <= blockNumber && (ci == - 1 || workersParams[i].firstBlockNumber > workersParams[uint(ci)].firstBlockNumber)) {\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 747,
          "vulnerability_to_line": null,
          "vulnerability_code": "            if (addrs[i] != 0x0 && workers[addrs[i]].signer != principal) {\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 747,
          "vulnerability_to_line": null,
          "vulnerability_code": "            if (addrs[i] != 0x0 && workers[addrs[i]].signer != principal) {\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 754,
          "vulnerability_to_line": null,
          "vulnerability_code": "            if (addrs[iw] != 0x0 && workers[addrs[iw]].signer != principal) {\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 754,
          "vulnerability_to_line": null,
          "vulnerability_code": "            if (addrs[iw] != 0x0 && workers[addrs[iw]].signer != principal) {\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 679,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint pi = 0; pi < workersParams.length; pi++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 692,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint wi = 0; wi < workerAddresses.length; wi++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 709,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < workersParams.length; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 746,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < addrs.length; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 753,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint iw = 0; iw < addrs.length; iw++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 463,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(worker.status > 0, \"Unregistered worker.\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 542,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(tasks[taskId].dappContract == 0x0, \"Task with the same taskId already exist\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 615,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(tasks[taskId].status == TaskStatus.InProgress, \"Illegal status, task must be in progress.\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 617,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(block.number > blockNumber, \"Block number in the future.\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 620,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(sigAddr != address(0), \"Cannot verify this signature.\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 621,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(sigAddr == workers[msg.sender].signer, \"Invalid signature.\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 626,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(reward > 0, \"Reward cannot be zero.\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 629,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(executeCall(tasks[taskId].dappContract, 0, data), \"Unable to invoke the callback\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 670,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(workers[msg.sender].signer == principal, \"Only the Principal can update the seed\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 673,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(sigAddr == principal, \"Invalid signature\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 729,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(idx != - 1, \"No workers parameters entry for specified block number\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 793,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(workers[custodian].signer != 0x0, \"Worker not registered\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 105,
          "vulnerability_to_line": null,
          "vulnerability_code": "    if (v != 27 && v != 28) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 106,
          "vulnerability_to_line": null,
          "vulnerability_code": "      return (address(0));\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 107,
          "vulnerability_to_line": null,
          "vulnerability_code": "    } else {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 108,
          "vulnerability_to_line": null,
          "vulnerability_code": "      // solium-disable-next-line arg-overflow\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 109,
          "vulnerability_to_line": null,
          "vulnerability_code": "      return ecrecover(_hash, v, r, s);\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 110,
          "vulnerability_to_line": null,
          "vulnerability_code": "    }\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 710,
          "vulnerability_to_line": null,
          "vulnerability_code": "            if (workersParams[i].firstBlockNumber <= blockNumber && (ci == - 1 || workersParams[i].firstBlockNumber > workersParams[uint(ci)].firstBlockNumber)) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 711,
          "vulnerability_to_line": null,
          "vulnerability_code": "                ci = int8(i);\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 712,
          "vulnerability_to_line": null,
          "vulnerability_code": "            }\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 747,
          "vulnerability_to_line": null,
          "vulnerability_code": "            if (addrs[i] != 0x0 && workers[addrs[i]].signer != principal) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 748,
          "vulnerability_to_line": null,
          "vulnerability_code": "                cpt++;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 749,
          "vulnerability_to_line": null,
          "vulnerability_code": "            }\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 754,
          "vulnerability_to_line": null,
          "vulnerability_code": "            if (addrs[iw] != 0x0 && workers[addrs[iw]].signer != principal) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 755,
          "vulnerability_to_line": null,
          "vulnerability_code": "                _workers[cur] = addrs[iw];\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 756,
          "vulnerability_to_line": null,
          "vulnerability_code": "                cur++;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 757,
          "vulnerability_to_line": null,
          "vulnerability_code": "            }\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 484,
          "vulnerability_to_line": null,
          "vulnerability_code": "            workerAddresses.length++;\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 679,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint pi = 0; pi < workersParams.length; pi++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 692,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint wi = 0; wi < workerAddresses.length; wi++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 694,
          "vulnerability_to_line": null,
          "vulnerability_code": "                workersParams[ti].workerAddresses.length++;\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 709,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < workersParams.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 746,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < addrs.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 748,
          "vulnerability_to_line": null,
          "vulnerability_code": "                cpt++;\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 753,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint iw = 0; iw < addrs.length; iw++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 756,
          "vulnerability_to_line": null,
          "vulnerability_code": "                cur++;\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 542,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(tasks[taskId].dappContract == 0x0, \"Task with the same taskId already exist\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 615,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(tasks[taskId].status == TaskStatus.InProgress, \"Illegal status, task must be in progress.\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 670,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(workers[msg.sender].signer == principal, \"Only the Principal can update the seed\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 729,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(idx != - 1, \"No workers parameters entry for specified block number\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "encode-packed-collision",
          "vulnerability_from_line": 513,
          "vulnerability_to_line": null,
          "vulnerability_code": "        bytes32 hash = keccak256(abi.encodePacked(dappContract, callable, callableArgs, blockNumber));\n",
          "message": "abi.encodePacked hash collision with variable length arguments in generateTaskId()"
        }
      ]
    },
    "slither": {
      "successfull_analysis": true,
      "errors": [
        "EXIT_CODE_61"
      ],
      "vulnerability_findings": [
        {
          "name": "uninitialized-state",
          "vulnerability_from_line": 169,
          "vulnerability_to_line": null,
          "vulnerability_code": "  uint256 internal totalSupply_;\n",
          "message": "StandardToken.totalSupply_ (Enigma.sol#169) is never initialized. It is used in:\n\t- totalSupply (Enigma.sol#286-288)\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 75,
          "vulnerability_to_line": 111,
          "vulnerability_code": "  function recover(bytes32 _hash, bytes _sig)\n\n    internal\n\n    pure\n\n    returns (address)\n\n  {\n\n    bytes32 r;\n\n    bytes32 s;\n\n    uint8 v;\n\n\n\n    // Check the signature length\n\n    if (_sig.length != 65) {\n\n      return (address(0));\n\n    }\n\n\n\n    // Divide the signature in r, s and v variables\n\n    // ecrecover takes the signature parameters, and the only way to get them\n\n    // currently is to use assembly.\n\n    // solium-disable-next-line security/no-inline-assembly\n\n    assembly {\n\n      r := mload(add(_sig, 32))\n\n      s := mload(add(_sig, 64))\n\n      v := byte(0, mload(add(_sig, 96)))\n\n    }\n\n\n\n    // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\n\n    if (v < 27) {\n\n      v += 27;\n\n    }\n\n\n\n    // If the version is correct return the signer address\n\n    if (v != 27 && v != 28) {\n\n      return (address(0));\n\n    } else {\n\n      // solium-disable-next-line arg-overflow\n\n      return ecrecover(_hash, v, r, s);\n\n    }\n",
          "message": "ECRecovery.recover (Enigma.sol#75-111) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 327,
          "vulnerability_to_line": 342,
          "vulnerability_code": "    function at(address _addr) internal view returns (bytes o_code) {\n\n        assembly {\n\n        // retrieve the size of the code, this needs assembly\n\n            let size := extcodesize(_addr)\n\n        // allocate output byte array - this could also be done without assembly\n\n        // by using o_code = new bytes(size)\n\n            o_code := mload(0x40)\n\n        // new \"memory end\" including padding\n\n            mstore(0x40, add(o_code, and(add(add(size, 0x20), 0x1f), not(0x1f))))\n\n        // store length in memory\n\n            mstore(o_code, size)\n\n        // actually retrieve the code, this needs assembly\n\n            extcodecopy(_addr, add(o_code, 0x20), 0, size)\n\n        }\n\n    }\n",
          "message": "GetCode.at (Enigma.sol#327-342) is declared view but contains assembly code\n"
        },
        {
          "name": "locked-ether",
          "vulnerability_from_line": 475,
          "vulnerability_to_line": 499,
          "vulnerability_code": "    function register(address signer, bytes report)\n\n        public\n\n        payable\n\n        returns (ReturnValue)\n\n    {\n\n        // TODO: consider exit if both signer and custodian as matching\n\n        // If the custodian is not already register, we add an index entry\n\n        if (workers[msg.sender].signer == 0x0) {\n\n            uint index = workerAddresses.length;\n\n            workerAddresses.length++;\n\n            workerAddresses[index] = msg.sender;\n\n        }\n\n\n\n        // Set the custodian attributes\n\n        workers[msg.sender].signer = signer;\n\n        workers[msg.sender].balance = msg.value;\n\n        workers[msg.sender].report = report;\n\n        workers[msg.sender].status = 1;\n\n\n\n        emit Register(msg.sender, signer, true);\n\n\n\n        return ReturnValue.Ok;\n\n    }\n\n\n",
          "message": "Contract locking ether found in Enigma.sol:\n\tContract Enigma has payable functions:\n\t - register (Enigma.sol#475-499)\n\tBut does not have a function to withdraw the ether\n"
        },
        {
          "name": "unused-return",
          "vulnerability_from_line": 528,
          "vulnerability_to_line": 572,
          "vulnerability_code": "    function compute(\n\n        address dappContract,\n\n        string callable,\n\n        bytes callableArgs,\n\n        string callback,\n\n        uint256 fee,\n\n        bytes32[] preprocessors,\n\n        uint256 blockNumber\n\n    )\n\n        public\n\n        returns (ReturnValue)\n\n    {\n\n        // TODO: Add a multiplier to the fee (like ETH => wei) in order to accept smaller denominations\n\n        bytes32 taskId = generateTaskId(dappContract, callable, callableArgs, blockNumber);\n\n        require(tasks[taskId].dappContract == 0x0, \"Task with the same taskId already exist\");\n\n\n\n        tasks[taskId].reward = fee;\n\n        tasks[taskId].callable = callable;\n\n        tasks[taskId].callableArgs = callableArgs;\n\n        tasks[taskId].callback = callback;\n\n        tasks[taskId].status = TaskStatus.InProgress;\n\n        tasks[taskId].dappContract = dappContract;\n\n        tasks[taskId].blockNumber = blockNumber;\n\n\n\n        // Emit the ComputeTask event which each node is watching for\n\n        emit ComputeTask(\n\n            dappContract,\n\n            taskId,\n\n            callable,\n\n            callableArgs,\n\n            callback,\n\n            fee,\n\n            preprocessors,\n\n            blockNumber,\n\n            true\n\n        );\n\n\n\n        // Transferring before emitting does not work\n\n        // TODO: check the allowance first\n\n        engToken.transferFrom(msg.sender, this, fee);\n\n\n\n        return ReturnValue.Ok;\n\n    }\n\n\n",
          "message": "Enigma.compute (Enigma.sol#528-572) does not use the value returned by external calls:\n\t-engToken.transferFrom(msg.sender,this,fee) (Enigma.sol#567-568)\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 75,
          "vulnerability_to_line": 111,
          "vulnerability_code": "  function recover(bytes32 _hash, bytes _sig)\n\n    internal\n\n    pure\n\n    returns (address)\n\n  {\n\n    bytes32 r;\n\n    bytes32 s;\n\n    uint8 v;\n\n\n\n    // Check the signature length\n\n    if (_sig.length != 65) {\n\n      return (address(0));\n\n    }\n\n\n\n    // Divide the signature in r, s and v variables\n\n    // ecrecover takes the signature parameters, and the only way to get them\n\n    // currently is to use assembly.\n\n    // solium-disable-next-line security/no-inline-assembly\n\n    assembly {\n\n      r := mload(add(_sig, 32))\n\n      s := mload(add(_sig, 64))\n\n      v := byte(0, mload(add(_sig, 96)))\n\n    }\n\n\n\n    // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\n\n    if (v < 27) {\n\n      v += 27;\n\n    }\n\n\n\n    // If the version is correct return the signer address\n\n    if (v != 27 && v != 28) {\n\n      return (address(0));\n\n    } else {\n\n      // solium-disable-next-line arg-overflow\n\n      return ecrecover(_hash, v, r, s);\n\n    }\n",
          "message": "ECRecovery.recover uses assembly (Enigma.sol#75-111)\n\t- Enigma.sol#93-100\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 327,
          "vulnerability_to_line": 342,
          "vulnerability_code": "    function at(address _addr) internal view returns (bytes o_code) {\n\n        assembly {\n\n        // retrieve the size of the code, this needs assembly\n\n            let size := extcodesize(_addr)\n\n        // allocate output byte array - this could also be done without assembly\n\n        // by using o_code = new bytes(size)\n\n            o_code := mload(0x40)\n\n        // new \"memory end\" including padding\n\n            mstore(0x40, add(o_code, and(add(add(size, 0x20), 0x1f), not(0x1f))))\n\n        // store length in memory\n\n            mstore(o_code, size)\n\n        // actually retrieve the code, this needs assembly\n\n            extcodecopy(_addr, add(o_code, 0x20), 0, size)\n\n        }\n\n    }\n",
          "message": "GetCode.at uses assembly (Enigma.sol#327-342)\n\t- Enigma.sol#328-342\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 592,
          "vulnerability_to_line": 601,
          "vulnerability_code": "    function executeCall(address to, uint256 value, bytes data)\n\n        internal\n\n        returns (bool success)\n\n    {\n\n        assembly {\n\n            success := call(gas, to, value, add(data, 0x20), mload(data), 0, 0)\n\n        }\n\n    }\n\n\n",
          "message": "Enigma.executeCall uses assembly (Enigma.sol#592-601)\n\t- Enigma.sol#596-601\n"
        },
        {
          "name": "constable-states",
          "vulnerability_from_line": 172,
          "vulnerability_to_line": null,
          "vulnerability_code": "  uint8 public decimals;\n",
          "message": "StandardToken.decimals should be constant (Enigma.sol#172)\nStandardToken.name should be constant (Enigma.sol#170)\nStandardToken.symbol should be constant (Enigma.sol#171)\nStandardToken.totalSupply_ should be constant (Enigma.sol#169)\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 286,
          "vulnerability_to_line": 288,
          "vulnerability_code": "  function totalSupply() public view returns (uint256) {\n\n    return totalSupply_;\n",
          "message": "StandardToken.totalSupply (Enigma.sol#286-288) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 142,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function totalSupply() public view returns (uint256);\n",
          "message": "ERC20Basic.totalSupply (Enigma.sol#142) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 143,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function balanceOf(address _who) public view returns (uint256);\n",
          "message": "ERC20Basic.balanceOf (Enigma.sol#143) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 310,
          "vulnerability_to_line": 312,
          "vulnerability_code": "  function balanceOf(address _owner) public view returns (uint256) {\n\n    return balances[_owner];\n",
          "message": "StandardToken.balanceOf (Enigma.sol#310-312) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 295,
          "vulnerability_to_line": 303,
          "vulnerability_code": "  function transfer(address _to, uint256 _value) public returns (bool) {\n\n    require(_value <= balances[msg.sender]);\n\n    require(_to != address(0));\n\n\n\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n\n    balances[_to] = balances[_to].add(_value);\n\n    emit Transfer(msg.sender, _to, _value);\n\n    return true;\n",
          "message": "StandardToken.transfer (Enigma.sol#295-303) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 144,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function transfer(address _to, uint256 _value) public returns (bool);\n",
          "message": "ERC20Basic.transfer (Enigma.sol#144) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 145,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function allowance(address _ocwner, address _spender) public view returns (uint256);\n",
          "message": "ERC20Basic.allowance (Enigma.sol#145) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 224,
          "vulnerability_to_line": 233,
          "vulnerability_code": "  function allowance(\n\n    address _owner,\n\n    address _spender\n\n   )\n\n    public\n\n    view\n\n    returns (uint256)\n\n  {\n\n    return allowed[_owner][_spender];\n",
          "message": "StandardToken.allowance (Enigma.sol#224-233) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 146,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function approve(address spender, uint tokens) public returns (bool success);\n",
          "message": "ERC20Basic.approve (Enigma.sol#146) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 212,
          "vulnerability_to_line": 216,
          "vulnerability_code": "  function approve(address _spender, uint256 _value) public returns (bool) {\n\n    allowed[msg.sender][_spender] = _value;\n\n    emit Approval(msg.sender, _spender, _value);\n\n    return true;\n",
          "message": "StandardToken.approve (Enigma.sol#212-216) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 184,
          "vulnerability_to_line": 201,
          "vulnerability_code": "  function transferFrom(\n\n    address _from,\n\n    address _to,\n\n    uint256 _value\n\n  )\n\n    public\n\n    returns (bool)\n\n  {\n\n    require(_value <= balances[_from]);\n\n    require(_value <= allowed[_from][msg.sender]);\n\n    require(_to != address(0));\n\n\n\n    balances[_from] = balances[_from].sub(_value);\n\n    balances[_to] = balances[_to].add(_value);\n\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n\n    emit Transfer(_from, _to, _value);\n\n    return true;\n",
          "message": "StandardToken.transferFrom (Enigma.sol#184-201) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 147,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function transferFrom(address _from, address _to, uint256 _value) public returns (bool);\n",
          "message": "ERC20Basic.transferFrom (Enigma.sol#147) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 244,
          "vulnerability_to_line": 255,
          "vulnerability_code": "  function increaseApproval(\n\n    address _spender,\n\n    uint256 _addedValue\n\n  )\n\n    public\n\n    returns (bool)\n\n  {\n\n    allowed[msg.sender][_spender] = (\n\n      allowed[msg.sender][_spender].add(_addedValue));\n\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n\n    return true;\n",
          "message": "StandardToken.increaseApproval (Enigma.sol#244-255) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 266,
          "vulnerability_to_line": 281,
          "vulnerability_code": "  function decreaseApproval(\n\n    address _spender,\n\n    uint256 _subtractedValue\n\n  )\n\n    public\n\n    returns (bool)\n\n  {\n\n    uint256 oldValue = allowed[msg.sender][_spender];\n\n    if (_subtractedValue >= oldValue) {\n\n      allowed[msg.sender][_spender] = 0;\n\n    } else {\n\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n\n    }\n\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n\n    return true;\n",
          "message": "StandardToken.decreaseApproval (Enigma.sol#266-281) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 352,
          "vulnerability_to_line": 353,
          "vulnerability_code": "    function balanceOf(address who) public view returns (uint256);\n",
          "message": "IERC20.balanceOf (Enigma.sol#352-353) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 353,
          "vulnerability_to_line": 354,
          "vulnerability_code": "    function transfer(address to, uint256 value) public returns (bool);\n",
          "message": "IERC20.transfer (Enigma.sol#353-354) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 354,
          "vulnerability_to_line": 355,
          "vulnerability_code": "    function allowance(address owner, address spender) public view returns (uint256);\n",
          "message": "IERC20.allowance (Enigma.sol#354-355) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 355,
          "vulnerability_to_line": 356,
          "vulnerability_code": "    function transferFrom(address from, address to, uint256 value) public returns (bool);\n",
          "message": "IERC20.transferFrom (Enigma.sol#355-356) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 356,
          "vulnerability_to_line": 358,
          "vulnerability_code": "    function approve(address spender, uint256 value) public returns (bool);\n\n\n",
          "message": "IERC20.approve (Enigma.sol#356-358) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 475,
          "vulnerability_to_line": 499,
          "vulnerability_code": "    function register(address signer, bytes report)\n\n        public\n\n        payable\n\n        returns (ReturnValue)\n\n    {\n\n        // TODO: consider exit if both signer and custodian as matching\n\n        // If the custodian is not already register, we add an index entry\n\n        if (workers[msg.sender].signer == 0x0) {\n\n            uint index = workerAddresses.length;\n\n            workerAddresses.length++;\n\n            workerAddresses[index] = msg.sender;\n\n        }\n\n\n\n        // Set the custodian attributes\n\n        workers[msg.sender].signer = signer;\n\n        workers[msg.sender].balance = msg.value;\n\n        workers[msg.sender].report = report;\n\n        workers[msg.sender].status = 1;\n\n\n\n        emit Register(msg.sender, signer, true);\n\n\n\n        return ReturnValue.Ok;\n\n    }\n\n\n",
          "message": "Enigma.register (Enigma.sol#475-499) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 528,
          "vulnerability_to_line": 572,
          "vulnerability_code": "    function compute(\n\n        address dappContract,\n\n        string callable,\n\n        bytes callableArgs,\n\n        string callback,\n\n        uint256 fee,\n\n        bytes32[] preprocessors,\n\n        uint256 blockNumber\n\n    )\n\n        public\n\n        returns (ReturnValue)\n\n    {\n\n        // TODO: Add a multiplier to the fee (like ETH => wei) in order to accept smaller denominations\n\n        bytes32 taskId = generateTaskId(dappContract, callable, callableArgs, blockNumber);\n\n        require(tasks[taskId].dappContract == 0x0, \"Task with the same taskId already exist\");\n\n\n\n        tasks[taskId].reward = fee;\n\n        tasks[taskId].callable = callable;\n\n        tasks[taskId].callableArgs = callableArgs;\n\n        tasks[taskId].callback = callback;\n\n        tasks[taskId].status = TaskStatus.InProgress;\n\n        tasks[taskId].dappContract = dappContract;\n\n        tasks[taskId].blockNumber = blockNumber;\n\n\n\n        // Emit the ComputeTask event which each node is watching for\n\n        emit ComputeTask(\n\n            dappContract,\n\n            taskId,\n\n            callable,\n\n            callableArgs,\n\n            callback,\n\n            fee,\n\n            preprocessors,\n\n            blockNumber,\n\n            true\n\n        );\n\n\n\n        // Transferring before emitting does not work\n\n        // TODO: check the allowance first\n\n        engToken.transferFrom(msg.sender, this, fee);\n\n\n\n        return ReturnValue.Ok;\n\n    }\n\n\n",
          "message": "Enigma.compute (Enigma.sol#528-572) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 609,
          "vulnerability_to_line": 647,
          "vulnerability_code": "    function commitResults(bytes32 taskId, bytes data, bytes sig, uint256 blockNumber)\n\n        public\n\n        workerRegistered(msg.sender)\n\n        returns (ReturnValue)\n\n    {\n\n        // Task must be solved only once\n\n        require(tasks[taskId].status == TaskStatus.InProgress, \"Illegal status, task must be in progress.\");\n\n        // TODO: run worker selection algo to validate right worker\n\n        require(block.number > blockNumber, \"Block number in the future.\");\n\n\n\n        address sigAddr = verifyCommitSig(tasks[taskId], data, sig);\n\n        require(sigAddr != address(0), \"Cannot verify this signature.\");\n\n        require(sigAddr == workers[msg.sender].signer, \"Invalid signature.\");\n\n\n\n        // The contract must hold enough fund to distribute reward\n\n        // TODO: validate that the reward matches the opcodes computed\n\n        uint256 reward = tasks[taskId].reward;\n\n        require(reward > 0, \"Reward cannot be zero.\");\n\n\n\n        // Invoking the callback method of the original contract\n\n        require(executeCall(tasks[taskId].dappContract, 0, data), \"Unable to invoke the callback\");\n\n\n\n        // Keep a trace of the task worker and proof\n\n        tasks[taskId].worker = msg.sender;\n\n        tasks[taskId].sig = sig;\n\n        tasks[taskId].status = TaskStatus.Executed;\n\n\n\n        // TODO: send directly to the worker's custodian instead\n\n        // Put the reward in the worker's bank\n\n        // He can withdraw later\n\n        Worker storage worker = workers[msg.sender];\n\n        worker.balance = worker.balance.add(reward);\n\n\n\n        emit CommitResults(tasks[taskId].dappContract, sigAddr, sig, reward, true);\n\n\n\n        return ReturnValue.Ok;\n\n    }\n\n\n",
          "message": "Enigma.commitResults (Enigma.sol#609-647) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 665,
          "vulnerability_to_line": 702,
          "vulnerability_code": "    function setWorkersParams(uint256 seed, bytes sig)\n\n        public\n\n        workerRegistered(msg.sender)\n\n        returns (ReturnValue)\n\n    {\n\n        require(workers[msg.sender].signer == principal, \"Only the Principal can update the seed\");\n\n\n\n        address sigAddr = verifyParamsSig(seed, sig);\n\n        require(sigAddr == principal, \"Invalid signature\");\n\n\n\n        // Create a new workers parameters item for the specified seed.\n\n        // The workers parameters list is a sort of cache, it never grows beyond its limit.\n\n        // If the list is full, the new item will replace the item assigned to the lowest block number.\n\n        uint ti = 0;\n\n        for (uint pi = 0; pi < workersParams.length; pi++) {\n\n            // Find an empty slot in the array, if full use the lowest block number\n\n            if (workersParams[pi].firstBlockNumber == 0) {\n\n                ti = pi;\n\n                break;\n\n            } else if (workersParams[pi].firstBlockNumber < workersParams[ti].firstBlockNumber) {\n\n                ti = pi;\n\n            }\n\n        }\n\n        workersParams[ti].firstBlockNumber = block.number;\n\n        workersParams[ti].seed = seed;\n\n\n\n        // Copy the current worker list\n\n        for (uint wi = 0; wi < workerAddresses.length; wi++) {\n\n            if (workerAddresses[wi] != 0x0) {\n\n                workersParams[ti].workerAddresses.length++;\n\n                workersParams[ti].workerAddresses[wi] = workerAddresses[wi];\n\n            }\n\n        }\n\n        emit WorkersParameterized(seed, workerAddresses, true);\n\n        return ReturnValue.Ok;\n\n    }\n\n\n",
          "message": "Enigma.setWorkersParams (Enigma.sol#665-702) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 768,
          "vulnerability_to_line": 781,
          "vulnerability_code": "    function selectWorker(uint256 blockNumber, bytes32 taskId)\n\n        public\n\n        view\n\n        returns (address)\n\n    {\n\n        (uint256 b, uint256 seed, address[] memory workerArray) = getWorkersParams(blockNumber);\n\n        address[] memory _workers = filterWorkers(workerArray);\n\n\n\n        bytes32 hash = keccak256(abi.encodePacked(seed, taskId));\n\n        uint256 index = uint256(hash) % _workers.length;\n\n        return _workers[index];\n\n    }\n\n\n",
          "message": "Enigma.selectWorker (Enigma.sol#768-781) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 786,
          "vulnerability_to_line": 796,
          "vulnerability_code": "    function getReport(address custodian)\n\n        public\n\n        view\n\n        workerRegistered(custodian)\n\n        returns (address, bytes)\n\n    {\n\n        // The RLP encoded report and signer's address for the specified worker\n\n        require(workers[custodian].signer != 0x0, \"Worker not registered\");\n\n        return (workers[custodian].signer, workers[custodian].report);\n\n    }\n",
          "message": "Enigma.getReport (Enigma.sol#786-796) should be declared external\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 15,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n",
          "message": "Parameter '_a' of SafeMath.mul (Enigma.sol#15) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 15,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n",
          "message": "Parameter '_b' of SafeMath.mul (Enigma.sol#15) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 31,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n",
          "message": "Parameter '_a' of SafeMath.div (Enigma.sol#31) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 31,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n",
          "message": "Parameter '_b' of SafeMath.div (Enigma.sol#31) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 41,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n",
          "message": "Parameter '_a' of SafeMath.sub (Enigma.sol#41) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 41,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n",
          "message": "Parameter '_b' of SafeMath.sub (Enigma.sol#41) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 49,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n",
          "message": "Parameter '_a' of SafeMath.add (Enigma.sol#49) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 49,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n",
          "message": "Parameter '_b' of SafeMath.add (Enigma.sol#49) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 75,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function recover(bytes32 _hash, bytes _sig)\n",
          "message": "Parameter '_hash' of ECRecovery.recover (Enigma.sol#75) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 75,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function recover(bytes32 _hash, bytes _sig)\n",
          "message": "Parameter '_sig' of ECRecovery.recover (Enigma.sol#75) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 118,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function toEthSignedMessageHash(bytes32 _hash)\n",
          "message": "Parameter '_hash' of ECRecovery.toEthSignedMessageHash (Enigma.sol#118) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 310,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function balanceOf(address _owner) public view returns (uint256) {\n",
          "message": "Parameter '_owner' of StandardToken.balanceOf (Enigma.sol#310) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 295,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function transfer(address _to, uint256 _value) public returns (bool) {\n",
          "message": "Parameter '_to' of StandardToken.transfer (Enigma.sol#295) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 295,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function transfer(address _to, uint256 _value) public returns (bool) {\n",
          "message": "Parameter '_value' of StandardToken.transfer (Enigma.sol#295) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 225,
          "vulnerability_to_line": null,
          "vulnerability_code": "    address _owner,\n",
          "message": "Parameter '_owner' of StandardToken.allowance (Enigma.sol#225) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 226,
          "vulnerability_to_line": null,
          "vulnerability_code": "    address _spender\n",
          "message": "Parameter '_spender' of StandardToken.allowance (Enigma.sol#226) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 212,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function approve(address _spender, uint256 _value) public returns (bool) {\n",
          "message": "Parameter '_spender' of StandardToken.approve (Enigma.sol#212) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 212,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function approve(address _spender, uint256 _value) public returns (bool) {\n",
          "message": "Parameter '_value' of StandardToken.approve (Enigma.sol#212) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 185,
          "vulnerability_to_line": null,
          "vulnerability_code": "    address _from,\n",
          "message": "Parameter '_from' of StandardToken.transferFrom (Enigma.sol#185) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 186,
          "vulnerability_to_line": null,
          "vulnerability_code": "    address _to,\n",
          "message": "Parameter '_to' of StandardToken.transferFrom (Enigma.sol#186) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 187,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint256 _value\n",
          "message": "Parameter '_value' of StandardToken.transferFrom (Enigma.sol#187) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 245,
          "vulnerability_to_line": null,
          "vulnerability_code": "    address _spender,\n",
          "message": "Parameter '_spender' of StandardToken.increaseApproval (Enigma.sol#245) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 246,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint256 _addedValue\n",
          "message": "Parameter '_addedValue' of StandardToken.increaseApproval (Enigma.sol#246) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 267,
          "vulnerability_to_line": null,
          "vulnerability_code": "    address _spender,\n",
          "message": "Parameter '_spender' of StandardToken.decreaseApproval (Enigma.sol#267) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 268,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint256 _subtractedValue\n",
          "message": "Parameter '_subtractedValue' of StandardToken.decreaseApproval (Enigma.sol#268) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 451,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor(address _tokenAddress, address _principal) public {\n",
          "message": "Parameter '_tokenAddress' of Enigma. (Enigma.sol#451) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 451,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor(address _tokenAddress, address _principal) public {\n",
          "message": "Parameter '_principal' of Enigma. (Enigma.sol#451) is not in mixedCase\n"
        }
      ]
    },
    "smartcheck": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 86,
          "vulnerability_to_line": null,
          "vulnerability_code": "      return (address(0));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 106,
          "vulnerability_to_line": null,
          "vulnerability_code": "      return (address(0));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ARRAY_LENGTH_MANIPULATION",
          "vulnerability_from_line": 484,
          "vulnerability_to_line": null,
          "vulnerability_code": "            workerAddresses.length++;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ARRAY_LENGTH_MANIPULATION",
          "vulnerability_from_line": 694,
          "vulnerability_to_line": null,
          "vulnerability_code": "                workersParams[ti].workerAddresses.length++;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ERC20_APPROVE",
          "vulnerability_from_line": 212,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function approve(address _spender, uint256 _value) public returns (bool) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 679,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint pi = 0; pi < workersParams.length; pi++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 692,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint wi = 0; wi < workerAddresses.length; wi++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 709,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < workersParams.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 746,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < addrs.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 753,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint iw = 0; iw < addrs.length; iw++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
          "vulnerability_from_line": 327,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function at(address _addr) internal view returns (bytes o_code) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
          "vulnerability_from_line": 592,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function executeCall(address to, uint256 value, bytes data)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 679,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint pi = 0; pi < workersParams.length; pi++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 692,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint wi = 0; wi < workerAddresses.length; wi++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 709,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < workersParams.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 746,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < addrs.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 753,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint iw = 0; iw < addrs.length; iw++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.24;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 58,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.24;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 133,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.24;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 155,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.24;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 318,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.24;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 346,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.24;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SAFEMATH",
          "vulnerability_from_line": 167,
          "vulnerability_to_line": null,
          "vulnerability_code": "  using SafeMath for uint256;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SAFEMATH",
          "vulnerability_from_line": 364,
          "vulnerability_to_line": null,
          "vulnerability_code": "    using SafeMath for uint256;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 75,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function recover(bytes32 _hash, bytes _sig)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
          "vulnerability_from_line": 327,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function at(address _addr) internal view returns (bytes o_code) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 75,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function recover(bytes32 _hash, bytes _sig)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 327,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function at(address _addr) internal view returns (bytes o_code) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 475,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function register(address signer, bytes report)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 508,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function generateTaskId(address dappContract, string callable, bytes callableArgs, uint256 blockNumber)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 508,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function generateTaskId(address dappContract, string callable, bytes callableArgs, uint256 blockNumber)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 530,
          "vulnerability_to_line": null,
          "vulnerability_code": "        string callable,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 531,
          "vulnerability_to_line": null,
          "vulnerability_code": "        bytes callableArgs,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 532,
          "vulnerability_to_line": null,
          "vulnerability_code": "        string callback,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 534,
          "vulnerability_to_line": null,
          "vulnerability_code": "        bytes32[] preprocessors,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 573,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function verifyCommitSig(Task task, bytes data, bytes sig)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 573,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function verifyCommitSig(Task task, bytes data, bytes sig)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 573,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function verifyCommitSig(Task task, bytes data, bytes sig)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 592,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function executeCall(address to, uint256 value, bytes data)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 609,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function commitResults(bytes32 taskId, bytes data, bytes sig, uint256 blockNumber)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 609,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function commitResults(bytes32 taskId, bytes data, bytes sig, uint256 blockNumber)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 648,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function verifyParamsSig(uint256 seed, bytes sig)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 665,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setWorkersParams(uint256 seed, bytes sig)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 725,
          "vulnerability_to_line": null,
          "vulnerability_code": "        returns (uint256, uint256, address[])\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 739,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function filterWorkers(address[] addrs)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 742,
          "vulnerability_to_line": null,
          "vulnerability_code": "        returns (address[])\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 790,
          "vulnerability_to_line": null,
          "vulnerability_code": "        returns (address, bytes)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 93,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 328,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 596,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 393,
          "vulnerability_to_line": null,
          "vulnerability_code": "    address principal;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 423,
          "vulnerability_to_line": null,
          "vulnerability_code": "    WorkersParams[5] workersParams;\n",
          "message": null
        }
      ]
    },
    "oyente": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "Callstack Depth Attack Vulnerability",
          "vulnerability_from_line": 597,
          "vulnerability_to_line": null,
          "vulnerability_code": "            success := call(gas, to, value, add(data, 0x20), mload(data), 0, 0)\n",
          "message": null
        },
        {
          "name": "Integer Overflow",
          "vulnerability_from_line": 475,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function register(address signer, bytes report)\n",
          "message": null
        },
        {
          "name": "Integer Underflow",
          "vulnerability_from_line": 429,
          "vulnerability_to_line": null,
          "vulnerability_code": "    mapping(address => Worker) public workers;\n",
          "message": null
        },
        {
          "name": "Integer Overflow",
          "vulnerability_from_line": 50,
          "vulnerability_to_line": null,
          "vulnerability_code": "    c = _a + _b;\n",
          "message": null
        },
        {
          "name": "Integer Underflow",
          "vulnerability_from_line": 170,
          "vulnerability_to_line": null,
          "vulnerability_code": "  string public name;\n",
          "message": null
        }
      ]
    },
    "mythril": {
      "successfull_analysis": false,
      "errors": [
        "DOCKER_TIMEOUT"
      ],
      "vulnerability_findings": []
    },
    "osiris": {
      "successfull_analysis": true,
      "errors": [
        "SYMBOLIC EXECUTION TIMEOUT"
      ],
      "vulnerability_findings": [
        {
          "name": "Callstack bug",
          "vulnerability_from_line": 597,
          "vulnerability_to_line": null,
          "vulnerability_code": "            success := call(gas, to, value, add(data, 0x20), mload(data), 0, 0)\n",
          "message": null
        },
        {
          "name": "Overflow bugs",
          "vulnerability_from_line": 732,
          "vulnerability_to_line": null,
          "vulnerability_code": "        WorkersParams memory _workerParams = workersParams[index];\n",
          "message": null
        },
        {
          "name": "Truncation bugs",
          "vulnerability_from_line": 10,
          "vulnerability_to_line": null,
          "vulnerability_code": "library SafeMath {\n",
          "message": null
        },
        {
          "name": "Truncation bugs",
          "vulnerability_from_line": 13,
          "vulnerability_to_line": null,
          "vulnerability_code": "  * @dev Multiplies two numbers, throws on overflow.\n",
          "message": null
        },
        {
          "name": "Truncation bugs",
          "vulnerability_from_line": 429,
          "vulnerability_to_line": null,
          "vulnerability_code": "    mapping(address => Worker) public workers;\n",
          "message": null
        },
        {
          "name": "Truncation bugs",
          "vulnerability_from_line": 462,
          "vulnerability_to_line": null,
          "vulnerability_code": "        Worker memory worker = workers[user];\n",
          "message": null
        },
        {
          "name": "Underflow bugs",
          "vulnerability_from_line": 8,
          "vulnerability_to_line": null,
          "vulnerability_code": " * @dev Math operations with safety checks that throw on error\n",
          "message": null
        }
      ]
    }
  }
}