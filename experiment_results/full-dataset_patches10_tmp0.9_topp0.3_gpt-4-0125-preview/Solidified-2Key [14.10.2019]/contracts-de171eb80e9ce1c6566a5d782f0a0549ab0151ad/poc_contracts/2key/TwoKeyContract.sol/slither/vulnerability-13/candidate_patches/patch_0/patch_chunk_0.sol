function buyProductInternal(uint256 _units, uint256 _bounty) public payable {
    
    address customer = senderPlasma();
    require(balanceOf(customer) > 0,"no arcs");

    uint256 _total_units = total_units();


    require(_units > 0,"no units requested");
    require(_total_units >= _units,"not enough units available in stock");
    address[] memory influencers = getInfluencers(customer);
    uint n_influencers = influencers.length;

    
    uint256 total_bounty = 0;
    for (uint i = 0; i < n_influencers; i++) {
      address influencer = plasmaOf(influencers[i]);  
      uint256 b;
      if (i == n_influencers-1) {  
        b = _bounty;
      } else {
        uint256 cut = cutOf(influencer);
        if (cut > 0 && cut <= 101) {
          b = _bounty.mul(cut.sub(1)).div(100);
        } else {  
          b = _bounty.div(n_influencers-i);
        }
      }
      xbalances[influencer] = xbalances[influencer].add(b);
      emit Rewarded(influencer, b);
      total_bounty = total_bounty.add(b);
      _bounty = _bounty.sub(b);
    }

    // Ensure no re-entrancy for the state update by subtracting bounty first
    xbalances[owner_plasma] = xbalances[owner_plasma].add(msg.value).sub(total_bounty); 

    // Interaction with external contract should happen at the end
    units[customer] = units[customer].add(_units);

    emit Fulfilled(customer, units[customer]);
  }