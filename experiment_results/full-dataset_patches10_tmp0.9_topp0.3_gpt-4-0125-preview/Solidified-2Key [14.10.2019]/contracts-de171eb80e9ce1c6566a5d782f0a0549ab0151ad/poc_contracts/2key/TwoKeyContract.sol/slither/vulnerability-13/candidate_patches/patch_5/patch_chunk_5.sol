function buyProductInternal(uint256 _units, uint256 _bounty) public payable {
    address customer = senderPlasma();
    require(balanceOf(customer) > 0,"no arcs");

    uint256 _total_units = total_units();

    require(_units > 0,"no units requested");
    require(_total_units >= _units,"not enough units available in stock");
    address[] memory influencers = getInfluencers(customer);
    uint n_influencers = influencers.length;

    uint256 total_bounty = 0;
    for (uint i = 0; i < n_influencers; i++) {
        address influencer = plasmaOf(influencers[i]);  // influencers is in reverse order
        uint256 b;
        if (i == n_influencers-1) {  // if its the last influencer then all the bounty goes to it.
            b = _bounty;
        } else {
            uint256 cut = cutOf(influencer);
            if (cut > 0 && cut <= 101) {
                b = _bounty.mul(cut.sub(1)).div(100);
            } else {  // cut == 0 or 255 indicates equal particine of the bounty
                b = _bounty.div(n_influencers-i);
            }
        }
        xbalances[influencer] = xbalances[influencer].add(b);
        emit Rewarded(influencer, b);
        total_bounty = total_bounty.add(b);
        _bounty = _bounty.sub(b);
    }

    // all that is left from the cost is given to the owner for selling the product
    xbalances[owner_plasma] = xbalances[owner_plasma].add(msg.value).sub(total_bounty); // TODO we want the cost of a token to be fixed?
    units[customer] = units[customer].add(_units);

    emit Fulfilled(customer, units[customer]);
}