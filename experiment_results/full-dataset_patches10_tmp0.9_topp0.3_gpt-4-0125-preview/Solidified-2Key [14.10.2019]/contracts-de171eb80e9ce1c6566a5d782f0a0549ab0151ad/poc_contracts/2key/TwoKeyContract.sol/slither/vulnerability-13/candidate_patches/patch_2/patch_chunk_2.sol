function buyProductInternal(uint256 _units, uint256 _bounty) public payable {
    address customer = senderPlasma();
    require(balanceOf(customer) > 0,"no arcs");

    uint256 _total_units = total_units();
    require(_units > 0,"no units requested");
    require(_total_units >= _units,"not enough units available in stock");
    address[] memory influencers = getInfluencers(customer);
    uint n_influencers = influencers.length;

    uint256 total_bounty = 0;
    for (uint i = 0; i < n_influencers; i++) {
        address influencer = plasmaOf(influencers[i]);
        uint256 b;
        if (i == n_influencers-1) {
            b = _bounty;
        } else {
            uint256 cut = cutOf(influencer);
            if (cut > 0 && cut <= 101) {
                b = _bounty.mul(cut.sub(1)).div(100);
            } else {
                b = _bounty.div(n_influencers-i);
            }
        }
        // Update balance within a critical section to avoid reentrancy attack
        xbalances[influencer] = xbalances[influencer].add(b);
        emit Rewarded(influencer, b);
        total_bounty = total_bounty.add(b);
        _bounty = _bounty.sub(b);
    }

    // Deduct the total bounty from msg.value to ensure no funds are locked within the contract mistakenly
    uint256 valueAfterBounty = msg.value.sub(total_bounty);
    // Update owner balance within a critical section to avoid reentrancy attack
    xbalances[owner_plasma] = xbalances[owner_plasma].add(valueAfterBounty);

    units[customer] = units[customer].add(_units);
    emit Fulfilled(customer, units[customer]);

    // After all state changes are done, safely transfer bounty to influencers
    for (uint j = 0; j < n_influencers; j++) {
        address influencer = plasmaOf(influencers[j]);
        uint256 influencerBounty = xbalances[influencer];
        if (influencerBounty > 0) {
            xbalances[influencer] = 0; // Reentrancy protection
            require(influencer.send(influencerBounty), "Transfer failed.");
        }
    }
}