pragma solidity ^0.4.24;







contract ERC20Basic {
  function totalSupply() public view returns (uint256);
  function balanceOf(address _who) public view returns (uint256);
  function transfer(address _to, uint256 _value) public returns (bool);
  function allowance(address _ocwner, address _spender) public view returns (uint256);
  function approve(address spender, uint tokens) public returns (bool success);
  function transferFrom(address _from, address _to, uint256 _value) public returns (bool);

  event Transfer(address indexed from, address indexed to, uint256 value);
  event Approval(address indexed tokenOwner, address indexed spender, uint tokens);
}



pragma solidity ^0.4.24;






library SafeMath {

  


  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {
    
    
    
    if (_a == 0) {
      return 0;
    }

    c = _a * _b;
    assert(c / _a == _b);
    return c;
  }

  


  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {
    
    
    
    return _a / _b;
  }

  


  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {
    assert(_b <= _a);
    return _a - _b;
  }

  


  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {
    c = _a + _b;
    assert(c >= _a);
    return c;
  }
}



pragma solidity ^0.4.24;






contract BasicToken is ERC20Basic {

  using SafeMath for uint256;

  mapping(address => uint256) internal balances;

  uint256 internal totalSupply_;
  string public name;
  string public symbol;
  uint8 public decimals;
  bool public frozen = false;

  


  function totalSupply() public view returns (uint256) {
    return totalSupply_;
  }

  




  function transfer(address _to, uint256 _value) public returns (bool) {
    require(_value <= balances[msg.sender]);
    require(_to != address(0));

    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    emit Transfer(msg.sender, _to, _value);
    return true;
  }

  




  function balanceOf(address _owner) public view returns (uint256) {
    return balances[_owner];
  }



  function approve(address _spender, uint256 _value) public returns (bool);
  event Approval(
    address indexed owner,
    address indexed spender,
    uint256 value
  );

}



pragma solidity ^0.4.24;







contract Ownable {
  address public owner;


  event OwnershipRenounced(address indexed previousOwner);
  event OwnershipTransferred(
    address indexed previousOwner,
    address indexed newOwner
  );


  



  constructor() public {
    owner = msg.sender;
  }

  


  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }

  





  function renounceOwnership() public onlyOwner {
    emit OwnershipRenounced(owner);
    owner = address(0);
  }

  



  function transferOwnership(address _newOwner) public onlyOwner {
    _transferOwnership(_newOwner);
  }

  



  function _transferOwnership(address _newOwner) internal {
    require(_newOwner != address(0));
    emit OwnershipTransferred(owner, _newOwner);
    owner = _newOwner;
  }
}



pragma solidity ^0.4.24;









contract StandardToken is ERC20Basic {

  using SafeMath for uint256;

  uint256 internal totalSupply_;
  string public name;
  string public symbol;
  uint8 public decimals;

  mapping (address => mapping (address => uint256)) internal allowed;
  mapping(address => uint256) internal balances;


  





  function transferFrom(
    address _from,
    address _to,
    uint256 _value
  )
    public
    returns (bool)
  {
    require(_value <= balances[_from]);
    require(_value <= allowed[_from][msg.sender]);
    require(_to != address(0));

    balances[_from] = balances[_from].sub(_value);
    balances[_to] = balances[_to].add(_value);
    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
    emit Transfer(_from, _to, _value);
    return true;
  }

  








  function approve(address _spender, uint256 _value) public returns (bool) {
    allowed[msg.sender][_spender] = _value;
    emit Approval(msg.sender, _spender, _value);
    return true;
  }

  





  function allowance(
    address _owner,
    address _spender
   )
    public
    view
    returns (uint256)
  {
    return allowed[_owner][_spender];
  }

  








  function increaseApproval(
    address _spender,
    uint256 _addedValue
  )
    public
    returns (bool)
  {
    allowed[msg.sender][_spender] = (
      allowed[msg.sender][_spender].add(_addedValue));
    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }

  








  function decreaseApproval(
    address _spender,
    uint256 _subtractedValue
  )
    public
    returns (bool)
  {
    uint256 oldValue = allowed[msg.sender][_spender];
    if (_subtractedValue >= oldValue) {
      allowed[msg.sender][_spender] = 0;
    } else {
      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
    }
    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }

  


  function totalSupply() public view returns (uint256) {
    return totalSupply_;
  }

  




  function transfer(address _to, uint256 _value) public returns (bool) {
    require(_value <= balances[msg.sender]);
    require(_to != address(0));

    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    emit Transfer(msg.sender, _to, _value);
    return true;
  }

  




  function balanceOf(address _owner) public view returns (uint256) {
    return balances[_owner];
  }

}



pragma solidity ^0.4.24;

contract TwoKeyTypes {
	enum CampaignType { NonFungible, Fungible, Counter, None }
}



pragma solidity ^0.4.24;





contract Destructible is Ownable {
  


  function destroy() public onlyOwner {
    selfdestruct(owner);
  }

  function destroyAndSend(address _recipient) public onlyOwner {
    selfdestruct(_recipient);
  }
}



pragma solidity ^0.4.24;





contract ERC20 is ERC20Basic {

}



pragma solidity ^0.4.24;



contract TwoKeyEconomy is StandardToken, Ownable {
  string public name = 'TwoKeyEconomy';
  string public symbol = '2Key';
  uint8 public decimals = 18;


  constructor() Ownable() public {
    totalSupply_ = 1000000000000000000000000000;
    balances[msg.sender] = totalSupply_;
  }

  function transferFrom(
    address _from,
    address _to,
    uint256 _value
  )
  public
  returns (bool)
  {
    require(_value <= balances[_from]);

    require(_to != address(0));

    balances[_from] = balances[_from].sub(_value);
    balances[_to] = balances[_to].add(_value);

    emit Transfer(_from, _to, _value);
    return true;
  }

}



pragma solidity ^0.4.24;








library SafeERC20 {
  function safeTransfer(
    ERC20Basic _token,
    address _to,
    uint256 _value
  )
    internal
  {
    require(_token.transfer(_to, _value));
  }

  function safeTransferFrom(
    ERC20 _token,
    address _from,
    address _to,
    uint256 _value
  )
    internal
  {
    require(_token.transferFrom(_from, _to, _value));
  }

  function safeApprove(
    ERC20 _token,
    address _spender,
    uint256 _value
  )
    internal
  {
    require(_token.approve(_spender, _value));
  }
}



pragma solidity ^0.4.24;















contract Crowdsale {
  using SafeMath for uint256;
  using SafeERC20 for ERC20;

  
  ERC20 public token;

  
  address public wallet;

  
  
  
  
  uint256 public rate;

  
  uint256 public weiRaised;

  






  event TokenPurchase(
    address indexed purchaser,
    address indexed beneficiary,
    uint256 value,
    uint256 amount
  );

  




  constructor(uint256 _rate, address _wallet, ERC20 _token) public {
    require(_rate > 0);
    require(_wallet != address(0));
    require(_token != address(0));

    rate = _rate;
    wallet = _wallet;
    token = _token;
  }

  
  
  

  


  function () external payable {
    buyTokens(msg.sender);
  }

  



  function buyTokens(address _beneficiary) public payable {

    uint256 weiAmount = msg.value;
    _preValidatePurchase(_beneficiary, weiAmount);

    
    uint256 tokens = _getTokenAmount(weiAmount);

    
    weiRaised = weiRaised.add(weiAmount);

    _processPurchase(_beneficiary, tokens);
    emit TokenPurchase(
      msg.sender,
      _beneficiary,
      weiAmount,
      tokens
    );

    _updatePurchasingState(_beneficiary, weiAmount);

    _forwardFunds();
    _postValidatePurchase(_beneficiary, weiAmount);
  }

  
  
  

  







  function _preValidatePurchase(
    address _beneficiary,
    uint256 _weiAmount
  )
  internal
  {
    require(_beneficiary != address(0));
    require(_weiAmount != 0);
  }

  




  function _postValidatePurchase(
    address _beneficiary,
    uint256 _weiAmount
  )
  internal
  {
    
  }

  




  function _deliverTokens(
    address _beneficiary,
    uint256 _tokenAmount
  )
  internal
  {
    token.safeTransfer(_beneficiary, _tokenAmount);
  }

  




  function _processPurchase(
    address _beneficiary,
    uint256 _tokenAmount
  )
  internal
  {
    _deliverTokens(_beneficiary, _tokenAmount);
  }

  




  function _updatePurchasingState(
    address _beneficiary,
    uint256 _weiAmount
  )
  internal
  {
    
  }

  




  function _getTokenAmount(uint256 _weiAmount)
  internal view returns (uint256)
  {
    return _weiAmount.mul(rate);
  }

  


  function _forwardFunds() internal {
    wallet.transfer(msg.value);
  }
}



pragma solidity ^0.4.24;



contract TwoKeyUpgradableExchange is Crowdsale, Ownable {

	address filler;

	event TokenSell(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);

	modifier onlyAlive() {
		require(filler == address(0));
		_;
	}

	constructor(uint256 _rate, address _wallet, ERC20 _token)
		Crowdsale(_rate, _wallet, _token) Ownable() public {
	}

	function sellTokens(uint256 _tokenAmount) public onlyAlive payable {
		require(token.allowance(this, msg.sender) >= _tokenAmount);
		require(token.transferFrom(msg.sender, this, _tokenAmount));

		uint256 weiAmount = _getWeiAmount(_tokenAmount);
		require(weiAmount >= address(this).balance);
	    weiRaised = weiRaised.sub(weiAmount);
	    msg.sender.transfer(weiAmount);

	    emit TokenSell(msg.sender, wallet, weiAmount, _tokenAmount);
	}

	function _getWeiAmount(uint256 _tokenAmount) internal view returns (uint256) {
	    return _tokenAmount.div(rate);
	}

	function upgrade(address _to) public onlyAlive onlyOwner {
		filler = _to;
	}

	function() external payable {
		if (filler != address(0))
			filler.transfer(msg.value);
	}

	function buyTokens(address _beneficiary) public onlyAlive payable {
		super.buyTokens(_beneficiary);
	}

}



pragma solidity ^0.4.24;



interface AdminContract {

	function replaceOneself(address newAdminContract) external;

	function transferByAdmins(address to, uint256 tokens) external;

	function upgradeEconomyExchangeByAdmins(address newExchange) external;

	function transferEtherByAdmins(address to, uint256 amount) external;

}



contract TwoKeyAdmin is Ownable, Destructible, AdminContract {


	TwoKeyEconomy economy;
	address electorateAdmins;
	TwoKeyUpgradableExchange exchange;
	address public newAdmin;
	bool wasReplaced;

	constructor(
		TwoKeyEconomy _economy,
		address _electorateAdmins,
		TwoKeyUpgradableExchange _exchange) Ownable() Destructible() payable public {
		require(_economy != address(0));
		require(_electorateAdmins != address(0));
		require(_exchange != address(0));
		wasReplaced = false;
		economy = _economy;
		exchange = _exchange;
		electorateAdmins = _electorateAdmins;
	}

	function replaceOneself(address newAdminContract) external wasNotReplaced adminsVotingApproved {
		AdminContract adminContract = AdminContract(newAdminContract);
		uint balanceOfOldAdmin = economy.balanceOf(adminContract);
		
		wasReplaced = true;
		economy.transfer(newAdminContract, balanceOfOldAdmin);
		economy.transferOwnership(newAdminContract);
		exchange.transferOwnership(newAdminContract);
		newAdminContract.transfer(address(this).balance);
	}

	function transferByAdmins(address _to, uint256 _tokens) external wasNotReplaced adminsVotingApproved {
		economy.transfer(_to, _tokens);
	}


	function upgradeEconomyExchangeByAdmins(address newExchange) external wasNotReplaced adminsVotingApproved {
		if (newExchange != address(0))
			exchange.upgrade(newExchange);
	}

	function transferEtherByAdmins(address to, uint256 amount) external wasNotReplaced adminsVotingApproved {
		require(to != address(0)  && amount > 0);
		to.transfer(amount);
	}


	

	function() public payable {
		if (wasReplaced) {
			newAdmin.transfer(msg.value);
		}
	}

	function destroy() public adminsVotingApproved {
		if (wasReplaced)
			selfdestruct(owner);
		else
			selfdestruct(newAdmin);
	}

	
	modifier adminsVotingApproved() {
		require(msg.sender == electorateAdmins);
	    _;
	}

	modifier wasNotReplaced() {
		require(!wasReplaced);
		_;
	}


}



pragma solidity ^0.4.24;







library GetCode {
    function at(address _addr) internal view returns (bytes o_code) {
        assembly {
        
            let size := extcodesize(_addr)
        
        
            o_code := mload(0x40)
        
            mstore(0x40, add(o_code, and(add(add(size, 0x20), 0x1f), not(0x1f))))
        
            mstore(o_code, size)
        
            extcodecopy(_addr, add(o_code, 0x20), 0, size)
        }
    }
}



pragma solidity ^0.4.24;



contract TwoKeyEventSource is TwoKeyTypes {

    mapping(address => bool) public activeUser;

    
    event Created(address indexed _campaign, address indexed _owner);
    event Joined(address indexed _campaign, address indexed _from, address indexed _to);
    event Escrow(address indexed _campaign, address indexed _converter, uint256 _tokenID, address _childContractID, uint256 _indexOrAmount, CampaignType _type);
    event Rewarded(address indexed _campaign, address indexed _to, uint256 _amount);
    event Fulfilled(address indexed _campaign, address indexed _converter, uint256 indexed _tokenID, address _childContractID, uint256 _indexOrAmount, CampaignType _type);
    event Cancelled(address indexed _campaign, address indexed _converter, uint256 indexed _tokenID, address _childContractID, uint256 _indexOrAmount, CampaignType _type);
    event Code(bytes32 _code, uint256 _index);
    event PublicLinkKey(address campaign, address owner, address key);




    
    TwoKeyAdmin twoKeyAdmin;



    
    mapping(bytes32 => bool) canEmit;

    
    mapping(bytes32 => CampaignType) codeToType;


    
    mapping(address => bool) authorizedSubadmins;



    
    modifier onlyAdmin {
        require(msg.sender == address(twoKeyAdmin));
        _;
    }

    
    modifier onlyAuthorizedSubadmins {
        require(authorizedSubadmins[msg.sender] == true || msg.sender == address(twoKeyAdmin));
        _;
    }

    
    modifier onlyAllowedContracts {
        
        bytes memory code = GetCode.at(msg.sender);
        bytes32 cc = keccak256(abi.encodePacked(code));
        emit Code(cc,1);

        _;
    }

    
    
    constructor(address _twoKeyAdminAddress) public {
        twoKeyAdmin = TwoKeyAdmin(_twoKeyAdminAddress);
    }

    
    
    
    
    function addContract(address _contractAddress) public onlyAuthorizedSubadmins {
        require(_contractAddress != address(0));
        bytes memory _contractCode = GetCode.at(_contractAddress);
        bytes32 cc = keccak256(abi.encodePacked(_contractCode));
        emit Code(cc,2);
        canEmit[cc] = true;
    }

    
    
    
    
    function removeContract(address _contractAddress) public onlyAuthorizedSubadmins {
        require(_contractAddress != address(0));
        bytes memory _contractCode = GetCode.at(_contractAddress);
        bytes32 cc = keccak256(abi.encodePacked(_contractCode));
        emit Code(cc,3);
        canEmit[cc] = false;
    }

    
    
    
    function addAuthorizedAddress(address _newAddress) public onlyAdmin {
        require(_newAddress != address(0));
        authorizedSubadmins[_newAddress] = true;
    }

    
    
    
    function removeAuthorizedAddress(address _authorizedAddress) public onlyAdmin {
        require(_authorizedAddress != address(0));
        require(authorizedSubadmins[_authorizedAddress] == true);

        authorizedSubadmins[_authorizedAddress] = false;
    }

    
    
    
    
    function addCampaignType(bytes _contractCode, CampaignType _campaignType) public onlyAdmin {
        bytes32 cc = keccak256(abi.encodePacked(_contractCode));
        require(canEmit[cc] == true); 
        codeToType[cc] = _campaignType;
    }

    
    
    
    function changeAdmin(address _newAdminAddress) public onlyAdmin {
        twoKeyAdmin = TwoKeyAdmin(_newAdminAddress);
    }

    function checkCanEmit(bytes _contractCode) public view returns (bool) {
        bytes32 cc = keccak256(abi.encodePacked(_contractCode));
        return canEmit[cc];
    }

    
    
    function created(address _campaign, address _owner) public onlyAllowedContracts{
    	emit Created(_campaign, _owner);
    }

    
    
    function joined(address _campaign, address _from, address _to) public onlyAllowedContracts {
      activeUser[_to] = true;  
    	emit Joined(_campaign, _from, _to);
    }

    
    
    function escrow(address _campaign, address _converter, uint256 _tokenID, address _childContractID, uint256 _indexOrAmount, CampaignType _type) public onlyAllowedContracts{
    	emit Escrow(_campaign, _converter, _tokenID, _childContractID, _indexOrAmount, _type);
    }

    
    
    function rewarded(address _campaign, address _to, uint256 _amount) public onlyAllowedContracts {
    	emit Rewarded(_campaign, _to, _amount);
	}

    
    
	function fulfilled(address  _campaign, address _converter, uint256 _tokenID, address _childContractID, uint256 _indexOrAmount, CampaignType _type) public onlyAllowedContracts {
		emit Fulfilled(_campaign, _converter, _tokenID, _childContractID, _indexOrAmount, _type);
	}

    
    
	function cancelled(address  _campaign, address _converter, uint256 _tokenID, address _childContractID, uint256 _indexOrAmount, CampaignType _type) public onlyAllowedContracts{
		emit Cancelled(_campaign, _converter, _tokenID, _childContractID, _indexOrAmount, _type);
	}


    function getAdmin() public view returns (address) {
        return address(twoKeyAdmin);
    }

    function checkIsAuthorized(address _subAdmin) public view returns (bool) {
        return authorizedSubadmins[_subAdmin];
    }
}



pragma solidity ^0.4.24;

library Call {
    function params0(address c, bytes _method) public view returns (uint answer) {
        
        
        bytes4 sig = bytes4(keccak256(_method));
        assembly {
        
            let ptr := mload(0x40)
        
            mstore(ptr,sig)

            let result := call(  
            15000, 
            c, 
            0, 
            ptr, 
            0x04, 
            ptr,  
            0x20) 

            if eq(result, 0) {
                revert(0, 0)
            }

            answer := mload(ptr) 
            mstore(0x40,add(ptr,0x24)) 
        }
    }

    function params1(address c, bytes _method, uint _val) public view returns (uint answer) {
        
        
        bytes4 sig = bytes4(keccak256(_method));
        assembly {
        
            let ptr := mload(0x40)
        
            mstore(ptr,sig)
        
            mstore(add(ptr,0x04), _val)

            let result := call(  
            15000, 
            c, 
            0, 
            ptr, 
            0x24, 
            ptr,  
            0x20) 

            if eq(result, 0) {
                revert(0, 0)
            }

            answer := mload(ptr) 
            mstore(0x40,add(ptr,0x24)) 
        }
    }

    function params2(address c, bytes _method, uint _val1, uint _val2) public view returns (uint answer) {
        
        
        bytes4 sig = bytes4(keccak256(_method));
        assembly {
        
            let ptr := mload(0x40)
        
            mstore(ptr,sig)
        
            mstore(add(ptr,0x04), _val1)
            mstore(add(ptr,0x24), _val2)

            let result := call(  
            15000, 
            c, 
            0, 
            ptr, 
            0x44, 
            ptr,  
            0x20) 

        
        
        
        

            answer := mload(ptr) 
            mstore(0x40,add(ptr,0x20)) 
        }
    }

    function loadAddress(bytes sig, uint idx) public pure returns (address) {
        address influencer;
        idx += 20;
        assembly
        {
            influencer := mload(add(sig, idx))
        }
        return influencer;
    }

    function loadUint8(bytes sig, uint idx) public pure returns (uint8) {
        uint8 weight;
        idx += 1;
        assembly
        {
            weight := mload(add(sig, idx))
        }
        return weight;
    }


    function recoverHash(bytes32 hash, bytes sig, uint idx) public pure returns (address) {
        
        
        
        
        require (sig.length >= 65+idx, 'bad signature length');
        idx += 32;
        bytes32 r;
        assembly
        {
            r := mload(add(sig, idx))
        }

        idx += 32;
        bytes32 s;
        assembly
        {
            s := mload(add(sig, idx))
        }

        idx += 1;
        uint8 v;
        assembly
        {
            v := mload(add(sig, idx))
        }
        if (v >= 32) { 
            v -= 32;
            bytes memory prefix = "\x19Ethereum Signed Message:\n32"; 
            hash = keccak256(abi.encodePacked(prefix, hash));
        }
        if (v <= 1) v += 27;
        require(v==27 || v==28,'bad sig v');
        return ecrecover(hash, v, r, s);

    }

    function recoverSigMemory(bytes sig) private pure returns (address[], address[], uint8[], uint[], uint) {
        uint8 version = loadUint8(sig, 0);
        uint msg_len = (version == 1) ? 1+65+20 : 1+20+20;
        uint n_influencers = (sig.length-21) / (65+msg_len);
        uint8[] memory weights = new uint8[](n_influencers);
        address[] memory keys = new address[](n_influencers);
        if ((sig.length-21) % (65+msg_len) > 0) {
            n_influencers++;
        }
        address[] memory influencers = new address[](n_influencers);
        uint[] memory offsets = new uint[](n_influencers);

        return (influencers, keys, weights, offsets, msg_len);
    }

    function recoverSigParts(bytes sig, address last_address) private pure returns (address[], address[], uint8[], uint[]) {
        
        
        
        
        
        
        
        
        
        
        
        
        
        uint idx = 0;
        uint msg_len;
        uint8[] memory weights;
        address[] memory keys;
        address[] memory influencers;
        uint[] memory offsets;
        (influencers, keys, weights, offsets, msg_len) = recoverSigMemory(sig);
        idx += 1;  

        idx += 20; 
        uint count_influencers = 0;

        while (idx + 65 <= sig.length) {
            offsets[count_influencers] = idx;
            idx += 65;  

            if (idx + msg_len <= sig.length) {  
                weights[count_influencers] = loadUint8(sig, idx);
                require(weights[count_influencers] > 0,'weight not defined (1..255)');  
                idx++;


                if (msg_len == 41)  
                {
                    influencers[count_influencers] = loadAddress(sig, idx);
                    idx += 20;
                    keys[count_influencers] = loadAddress(sig, idx);
                    idx += 20;
                } else if (msg_len == 86)  
                {
                    keys[count_influencers] = loadAddress(sig, idx+65);
                    influencers[count_influencers] = recoverHash(
                        keccak256(
                            abi.encodePacked(
                                keccak256(abi.encodePacked("bytes binding to weight","bytes binding to public")),
                                keccak256(abi.encodePacked(weights[count_influencers],keys[count_influencers]))
                            )
                        ),sig,idx);
                    idx += 65;
                    idx += 20;
                }

            } else {
                
                influencers[count_influencers] = last_address;
            }
            count_influencers++;
        }
        require(idx == sig.length,'illegal message size');

        return (influencers, keys, weights, offsets);
    }

    function recoverSig(bytes sig, address old_key, address last_address) public pure returns (address[], address[], uint8[]) {
        
        
        
        
        require(old_key != address(0),'no public link key');

        address[] memory influencers;
        address[] memory keys;
        uint8[] memory weights;
        uint[] memory offsets;
        (influencers, keys, weights, offsets) = recoverSigParts(sig, last_address);

        
        for(uint i = 0; i < influencers.length; i++) {
            if (i < weights.length) {
                require (recoverHash(keccak256(abi.encodePacked(weights[i], keys[i], influencers[i])),sig,offsets[i]) == old_key, 'illegal signature');
                old_key = keys[i];
            } else {
                
                require (recoverHash(keccak256(abi.encodePacked(influencers[i])),sig,offsets[i]) == old_key, 'illegal last signature');
            }
        }

        return (influencers, keys, weights);
    }
}



pragma solidity ^0.4.24;




contract TwoKeyReg is Ownable {
  mapping(address => string) public owner2name;
  mapping(bytes32 => address) public name2owner;
  
  
  
  
  mapping(address => address) public plasma2ethereum;
  mapping(address => address) public ethereum2plasma;
  mapping(address => bytes) public notes;

  event UserNameChanged(address owner, string name);

  TwoKeyEventSource eventSource;

  
  constructor(TwoKeyEventSource _eventSource) public {
    eventSource = _eventSource;
  }

  function addNameInternal(string _name, address _sender) private {
    
    require(name2owner[keccak256(abi.encodePacked(_name))] == 0 || name2owner[keccak256(abi.encodePacked(_name))] == _sender, "name already assigned");

    
    bytes memory last_name = bytes(owner2name[_sender]);
    if (last_name.length != 0) {
      name2owner[keccak256(abi.encodePacked(owner2name[_sender]))] = 0;
    }
    owner2name[_sender] = _name;
    name2owner[keccak256(abi.encodePacked(_name))] = _sender;
    emit UserNameChanged(_sender, _name);
  }

  function addName(string _name, address _sender) onlyOwner public {
    addNameInternal(_name, _sender);
  }

  function addNameByUser(string _name) public {
    addNameInternal(_name, msg.sender);
  }

  function addNameSigned(string _name, bytes external_sig) public {
    bytes32 hash = keccak256(abi.encodePacked(keccak256(abi.encodePacked("bytes binding to name")),
      keccak256(abi.encodePacked(_name))));
    address eth_address = Call.recoverHash(hash,external_sig,0);
    require (msg.sender == eth_address || msg.sender == owner, "only owner or user can change name");
    addNameInternal(_name, eth_address);
  }

  function setNoteInternal(bytes note, address me) private {
    
    notes[me] = note;
  }

  function setNoteByUser(bytes note) public {
    
    setNoteInternal(note, msg.sender);
  }

  function addPlasma2EthereumInternal(bytes sig, address eth_address) private {
      
      
    bytes32 hash = keccak256(abi.encodePacked(keccak256(abi.encodePacked("bytes binding to ethereum address")),keccak256(abi.encodePacked(eth_address))));
    address plasma_address = Call.recoverHash(hash,sig,0);
    require(plasma2ethereum[plasma_address] == address(0) || plasma2ethereum[plasma_address] == eth_address, "cant change eth=>plasma");
    plasma2ethereum[plasma_address] = eth_address;
    ethereum2plasma[eth_address] = plasma_address;
  }

  function addPlasma2EthereumByUser(bytes sig) public {
    addPlasma2EthereumInternal(sig, msg.sender);
  }

  function setPlasma2EthereumAndNoteSigned(bytes sig, bytes note, bytes external_sig) public {
    bytes32 hash = keccak256(abi.encodePacked(keccak256(abi.encodePacked("bytes binding to ethereum-plasma")),
      keccak256(abi.encodePacked(sig,note))));
    address eth_address = Call.recoverHash(hash,external_sig,0);
    require (msg.sender == eth_address || msg.sender == owner, "only owner or user can change ethereum-plasma");
    addPlasma2EthereumInternal(sig, eth_address);
    setNoteInternal(note, eth_address);
  }

  function getName2Owner(string _name) public view returns (address) {
    return name2owner[keccak256(abi.encodePacked(_name))];
  }
  function getOwner2Name(address _sender) public view returns (string) {
    return owner2name[_sender];
  }
}



pragma solidity ^0.4.24; 













contract TwoKeyContract is StandardToken, Ownable {
  event Fulfilled(address indexed to, uint256 units);
  event Rewarded(address indexed to, uint256 amount);
  event Log1(string s, uint256 units);
  event Log1A(string s, address a);


  using SafeMath for uint256;
  
  TwoKeyReg registry;
  TwoKeyEventSource eventSource;

  
  address owner_plasma; 
  string public name;
  string public ipfs_hash;
  string public symbol;
  uint8 public decimals = 0;  
  uint256 public cost; 
  uint256 public bounty; 
  uint256 public quota;  
  uint256 unit_decimals;  

  
  
  mapping (address => address) public received_from;
  mapping(address => uint256) public xbalances; 
  mapping(address => uint256) public units; 

  
  
  mapping(address => uint256) internal influencer2cut;

  
  
  function senderPlasma() public view returns (address) {
    address me = msg.sender;
    if (registry == address(0)) {
      return me;
    }
    address plasma = registry.ethereum2plasma(me);
    require(plasma != address(0),'your plasma address was not found in registry');

    return plasma;
  }

  function plasmaOf(address me) public view returns (address) {
    address plasma = me;
    if (registry == address(0)) {
      return plasma;
    }
    plasma = registry.ethereum2plasma(plasma);
    if (plasma != address(0)) {
      return plasma;
    }
    return me;  
  }

  function ethereumOf(address me) public view returns (address) {
    
    address ethereum = me;
    if (registry == address(0)) {
      return ethereum;
    }
    ethereum = registry.plasma2ethereum(ethereum);
    if (ethereum != address(0)) {
      return ethereum;
    }
    return me; 
  }

  function setCutOf(address me, uint256 cut) internal {
    
    
    
    address plasma = plasmaOf(me);
    require(influencer2cut[plasma] == 0 || influencer2cut[plasma] == cut, 'cut already set differently');
    influencer2cut[plasma] = cut;
  }

  function setCut(uint256 cut) public {
    setCutOf(msg.sender, cut);
  }

  function cutOf(address me) public view returns (uint256) {
    return influencer2cut[plasmaOf(me)];
  }

  function getCuts(address last_influencer) public view returns (uint256[]) {
    address[] memory influencers = getInfluencers(last_influencer);
    uint n_influencers = influencers.length;
    uint256[] memory cuts = new uint256[](n_influencers + 1);
    for (uint i = 0; i < n_influencers; i++) {
      address influencer = influencers[i];
      cuts[i] = cutOf(influencer);
    }
    cuts[n_influencers] = cutOf(last_influencer);
    return cuts;
  }

  





  function transferFrom(address _from, address _to, uint256 _value) public onlyOwner returns (bool) {
    return transferFromInternal(_from, _to, _value);
  }
  function transferFromInternal(address _from, address _to, uint256 _value) internal returns (bool) {
    
    require(_value == 1, 'can only transfer 1 ARC');
    require(_from != address(0), '_from undefined');
    require(_to != address(0), '_to undefined');
    _from = plasmaOf(_from);
    _to = plasmaOf(_to);





    require(balances[_from] > 0,'_from does not have arcs');
    balances[_from] = balances[_from].sub(1);
    balances[_to] = balances[_to].add(quota);
    totalSupply_ = totalSupply_.add(quota.sub(1));

    emit Transfer(_from, _to, 1);
    if (received_from[_to] == 0) {
      
      if (eventSource != address(0)) {
        eventSource.joined(this, _from, _to);
      }
    }
    received_from[_to] = _from;
    return true;
  }

  




  function transfer(address _to, uint256 _value) public returns (bool) {
    revert('transfer not implemented');
    return false;
  }

  function getConstantInfo() public view returns (string,string,uint256,uint256,uint256,address,string,uint256) {
    return (name,symbol,cost,bounty,quota,owner,ipfs_hash,unit_decimals);
  }

  function total_units() public view returns (uint256);

  




  function balanceOf(address me) public view returns (uint256) {
    return balances[plasmaOf(me)];
  }

  function xbalanceOf(address me) public view returns (uint256) {
    return xbalances[plasmaOf(me)];
  }

  function unitsOf(address me) public view returns (uint256) {
    return units[plasmaOf(me)];
  }

  function getDynamicInfo(address me) public view returns (uint256,uint256,uint256,uint256,uint256,uint256,uint256) {
    
    return (balanceOf(me),unitsOf(me),xbalanceOf(me),totalSupply_,address(this).balance,total_units(),cutOf(me));
  }

   function () external payable {
     buyProduct();
   }

  
  function buyFrom(address _from) public payable {
    _from = plasmaOf(_from);
    address _to = senderPlasma();
    if (balanceOf(_to) == 0) {
      transferFromInternal(_from, _to, 1);
    }
    buyProduct();
  }

function beginMigration() public {
  require(msg.sender == owner);
}

  
  function buyProduct() public payable;

  function getInfluencers(address customer) public view returns (address[]) {
    
    
    address influencer = plasmaOf(customer);
    
    uint n_influencers = 0;
    while (true) {
      influencer = plasmaOf(received_from[influencer]);  
      require(influencer != address(0),'not connected to contractor');
      if (influencer == owner_plasma) {
        break;
      }
      n_influencers++;
    }
    
    address[] memory influencers = new address[](n_influencers);
    
    
    influencer = plasmaOf(customer);
    while (n_influencers > 0) {
      influencer = plasmaOf(received_from[influencer]);
      n_influencers--;
      influencers[n_influencers] = influencer;
    }

    return influencers;
  }

  function buyProductInternal(uint256 _units, uint256 _bounty) public payable {
    
    
    address customer = senderPlasma();
    require(balanceOf(customer) > 0,"no arcs");

    uint256 _total_units = total_units();


    require(_units > 0,"no units requested");
    require(_total_units >= _units,"not enough units available in stock");
    address[] memory influencers = getInfluencers(customer);
    uint n_influencers = influencers.length;

    
    uint256 total_bounty = 0;
    for (uint i = 0; i < n_influencers; i++) {
      address influencer = plasmaOf(influencers[i]);  
      uint256 b;
      if (i == n_influencers-1) {  
        b = _bounty;
      } else {
        uint256 cut = cutOf(influencer);
        if (cut > 0 && cut <= 101) {
          b = _bounty.mul(cut.sub(1)).div(100);
        } else {  
          b = _bounty.div(n_influencers-i);
        }
      }
      xbalances[influencer] = xbalances[influencer].add(b);
      emit Rewarded(influencer, b);
      total_bounty = total_bounty.add(b);
      _bounty = _bounty.sub(b);
    }

    
    xbalances[owner_plasma] = xbalances[owner_plasma].add(msg.value).sub(total_bounty); 
    units[customer] = units[customer].add(_units);

    emit Fulfilled(customer, units[customer]);
  }
}

contract TwoKeyAcquisitionContract is TwoKeyContract
{
  uint256 public _total_units; 

  
  constructor(TwoKeyReg _reg, TwoKeyEventSource _eventSource, string _name, string _symbol,
        uint256 _tSupply, uint256 _quota, uint256 _cost, uint256 _bounty,
        uint256 _units, string _ipfs_hash) public {
    require(_bounty <= _cost,"bounty bigger than cost");
    
    
    
    
    
    name = _name;
    symbol = _symbol;
    totalSupply_ = _tSupply;
    cost = _cost;
    bounty = _bounty;
    quota = _quota;
    _total_units = _units;
    ipfs_hash = _ipfs_hash;
    unit_decimals = 0;  


    registry = _reg;
    owner_plasma = plasmaOf(owner); 
    received_from[owner_plasma] = owner_plasma;  
    balances[owner_plasma] = _tSupply;

    if (_eventSource != address(0)) {
      eventSource = _eventSource;
      eventSource.created(this, owner);
    }
  }

  function total_units() public view returns (uint256) {
    return _total_units;
  }

  
  function buyProduct() public payable {
    
    uint _units = msg.value.div(cost);
    require(msg.value == cost * _units, "ethere sent does not divide equally into units");
    
    
    uint256 _bounty = bounty.mul(_units);

    buyProductInternal(_units, _bounty);

    _total_units = _total_units.sub(_units);
  }
}

contract TwoKeyPresellContract is TwoKeyContract {
  StandardToken public erc20_token_sell_contract;



  
  constructor(TwoKeyReg _reg, TwoKeyEventSource _eventSource, string _name, string _symbol,
        uint256 _tSupply, uint256 _quota, uint256 _cost, uint256 _bounty,
        string _ipfs_hash, StandardToken _erc20_token_sell_contract) public {
    require(_bounty <= _cost,"bounty bigger than cost");
    
    
    
    
    
    name = _name;
    symbol = _symbol;
    totalSupply_ = _tSupply;
    cost = _cost;
    bounty = _bounty;
    quota = _quota;
    ipfs_hash = _ipfs_hash;
    registry = _reg;
    owner_plasma = plasmaOf(owner); 
    received_from[owner_plasma] = owner_plasma;  
    balances[owner_plasma] = _tSupply;
    if (_eventSource != address(0)) {
      eventSource = _eventSource;
      eventSource.created(this, owner);
    }

    if (_erc20_token_sell_contract != address(0)) {
      
      erc20_token_sell_contract = _erc20_token_sell_contract;
      unit_decimals = Call.params0(erc20_token_sell_contract, "decimals()");

      require(unit_decimals >= 0,"unit decimals to low");
      require(unit_decimals <= 18,"unit decimals to big");
    }
  }

  function total_units() public view returns (uint256) {
    uint256 _total_units;

    _total_units = Call.params1(erc20_token_sell_contract, "balanceOf(address)",uint(this));
    return _total_units;
  }

  

  function buyProduct() public payable {


    
    uint256 _units = msg.value.mul(10**unit_decimals).div(cost);

    
    
    uint256 _bounty = bounty.mul(_units).div(10**unit_decimals);


    buyProductInternal(_units, _bounty);




    
    
    require(address(erc20_token_sell_contract).call(bytes4(keccak256("transfer(address,uint256)")),msg.sender,_units),
      "failed to send coins");
  }
}