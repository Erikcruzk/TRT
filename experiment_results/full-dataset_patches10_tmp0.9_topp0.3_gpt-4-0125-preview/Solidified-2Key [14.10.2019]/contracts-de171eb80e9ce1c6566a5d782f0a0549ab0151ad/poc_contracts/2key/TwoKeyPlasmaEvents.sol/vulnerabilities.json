{
  "smartbugs_completed": true,
  "analyzer_results": {
    "semgrep": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 195,
          "vulnerability_to_line": null,
          "vulnerability_code": "        while (idx + 65 <= sig.length) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 199,
          "vulnerability_to_line": null,
          "vulnerability_code": "            if (idx + msg_len <= sig.length) {  // its  a < and not a <= because we dont want this to be the final iteration for the converter\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 250,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(uint i = 0; i < influencers.length; i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 251,
          "vulnerability_to_line": null,
          "vulnerability_code": "            if (i < weights.length) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 693,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (i = 0; i < influencers.length; i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 717,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (i = 0; i < keys.length; i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 726,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (i = 0; i < weights.length; i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 820,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(uint i=0; i< visitsList.length; i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 837,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(uint i=0; i< visitListTimestamps.length; i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 250,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(uint i = 0; i < influencers.length; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 820,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(uint i=0; i< visitsList.length; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 837,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(uint i=0; i< visitListTimestamps.length; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 122,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require (sig.length >= 65+idx, 'bad signature length');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 149,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(v==27 || v==28,'bad sig v');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 201,
          "vulnerability_to_line": null,
          "vulnerability_code": "                require(weights[count_influencers] > 0,'weight not defined (1..255)');  // 255 are used to indicate default (equal part) behaviour\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 231,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(idx == sig.length,'illegal message size');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 241,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(old_key != address(0),'no public link key');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 252,
          "vulnerability_to_line": null,
          "vulnerability_code": "                require (recoverHash(keccak256(abi.encodePacked(weights[i], keys[i], influencers[i])),sig,offsets[i]) == old_key, 'illegal signature');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 256,
          "vulnerability_to_line": null,
          "vulnerability_code": "                require (recoverHash(keccak256(abi.encodePacked(influencers[i])),sig,offsets[i]) == old_key, 'illegal last signature');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 684,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if(influencers.length > 1 && getCampaignToReferrerToCounted(c,influencers[influencers.length-2]) == false && influencers[influencers.length-2] != contractor) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 685,
          "vulnerability_to_line": null,
          "vulnerability_code": "            setCampaignToReferrerToCounted(c, influencers[influencers.length-2]);\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 686,
          "vulnerability_to_line": null,
          "vulnerability_code": "            bytes32 key = keccak256(\"campaign2numberOfForwarders\",c);\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 687,
          "vulnerability_to_line": null,
          "vulnerability_code": "            PROXY_STORAGE_CONTRACT.setUint(key, PROXY_STORAGE_CONTRACT.getUint(key) + 1);\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 688,
          "vulnerability_to_line": null,
          "vulnerability_code": "        }\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 161,
          "vulnerability_to_line": null,
          "vulnerability_code": "            n_influencers++;\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 202,
          "vulnerability_to_line": null,
          "vulnerability_code": "                idx++;\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 229,
          "vulnerability_to_line": null,
          "vulnerability_code": "            count_influencers++;\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 250,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(uint i = 0; i < influencers.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 693,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (i = 0; i < influencers.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 717,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (i = 0; i < keys.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 726,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (i = 0; i < weights.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 820,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(uint i=0; i< visitsList.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 837,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(uint i=0; i< visitListTimestamps.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        }
      ]
    },
    "slither": {
      "successfull_analysis": true,
      "errors": [
        "EXIT_CODE_99"
      ],
      "vulnerability_findings": [
        {
          "name": "uninitialized-state",
          "vulnerability_from_line": 314,
          "vulnerability_to_line": null,
          "vulnerability_code": "    ITwoKeySingletonesRegistry internal registry;\n",
          "message": "UpgradeabilityStorage.registry (TwoKeyPlasmaEvents.sol#314) is never initialized. It is used in:\n\t- initialize (TwoKeyPlasmaEvents.sol#337-339)\n"
        },
        {
          "name": "uninitialized-state",
          "vulnerability_from_line": 317,
          "vulnerability_to_line": null,
          "vulnerability_code": "    address internal _implementation;\n",
          "message": "UpgradeabilityStorage._implementation (TwoKeyPlasmaEvents.sol#317) is never initialized. It is used in:\n\t- implementation (TwoKeyPlasmaEvents.sol#323-325)\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 6,
          "vulnerability_to_line": 32,
          "vulnerability_code": "    function params0(address c, bytes _method) public view returns (uint answer) {\n\n        // https://medium.com/@blockchain101/calling-the-function-of-another-contract-in-solidity-f9edfa921f4c\n\n        //    dc = c;\n\n        bytes4 sig = bytes4(keccak256(_method));\n\n        assembly {\n\n        // move pointer to free memory spot\n\n            let ptr := mload(0x40)\n\n        // put function sig at memory spot\n\n            mstore(ptr,sig)\n\n\n\n            let result := call(  // use WARNING because this should be staticcall BUT geth crash!\n\n            15000, // gas limit\n\n            c, // sload(dc_slot),  // to addr. append var to _slot to access storage variable\n\n            0, // not transfer any ether (comment if using staticcall)\n\n            ptr, // Inputs are stored at location ptr\n\n            0x04, // Inputs are 0 bytes long\n\n            ptr,  //Store output over input\n\n            0x20) //Outputs are 1 bytes long\n\n\n\n            if eq(result, 0) {\n\n                revert(0, 0)\n\n            }\n\n\n\n            answer := mload(ptr) // Assign output to answer var\n\n            mstore(0x40,add(ptr,0x24)) // Set storage pointer to new space\n\n        }\n",
          "message": "Call.params0 (TwoKeyPlasmaEvents.sol#6-32) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 34,
          "vulnerability_to_line": 62,
          "vulnerability_code": "    function params1(address c, bytes _method, uint _val) public view returns (uint answer) {\n\n        // https://medium.com/@blockchain101/calling-the-function-of-another-contract-in-solidity-f9edfa921f4c\n\n        //    dc = c;\n\n        bytes4 sig = bytes4(keccak256(_method));\n\n        assembly {\n\n        // move pointer to free memory spot\n\n            let ptr := mload(0x40)\n\n        // put function sig at memory spot\n\n            mstore(ptr,sig)\n\n        // append argument after function sig\n\n            mstore(add(ptr,0x04), _val)\n\n\n\n            let result := call(  // use WARNING because this should be staticcall BUT geth crash!\n\n            15000, // gas limit\n\n            c, // sload(dc_slot),  // to addr. append var to _slot to access storage variable\n\n            0, // not transfer any ether (comment if using staticcall)\n\n            ptr, // Inputs are stored at location ptr\n\n            0x24, // Inputs are 0 bytes long\n\n            ptr,  //Store output over input\n\n            0x20) //Outputs are 1 bytes long\n\n\n\n            if eq(result, 0) {\n\n                revert(0, 0)\n\n            }\n\n\n\n            answer := mload(ptr) // Assign output to answer var\n\n            mstore(0x40,add(ptr,0x24)) // Set storage pointer to new space\n\n        }\n",
          "message": "Call.params1 (TwoKeyPlasmaEvents.sol#34-62) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 64,
          "vulnerability_to_line": 94,
          "vulnerability_code": "    function params2(address c, bytes _method, uint _val1, uint _val2) public view returns (uint answer) {\n\n        // https://medium.com/@blockchain101/calling-the-function-of-another-contract-in-solidity-f9edfa921f4c\n\n        //    dc = c;\n\n        bytes4 sig = bytes4(keccak256(_method));\n\n        assembly {\n\n        // move pointer to free memory spot\n\n            let ptr := mload(0x40)\n\n        // put function sig at memory spot\n\n            mstore(ptr,sig)\n\n        // append argument after function sig\n\n            mstore(add(ptr,0x04), _val1)\n\n            mstore(add(ptr,0x24), _val2)\n\n\n\n            let result := call(  // use WARNING because this should be staticcall BUT geth crash!\n\n            15000, // gas limit\n\n            c, // sload(dc_slot),  // to addr. append var to _slot to access storage variable\n\n            0, // not transfer any ether (comment if using staticcall)\n\n            ptr, // Inputs are stored at location ptr\n\n            0x44, // Inputs are 4 bytes for signature and 2 uint256\n\n            ptr,  //Store output over input\n\n            0x20) //Outputs are 1 uint long\n\n\n\n        // TODO cause revert\n\n        //            if eq(result, 0) {\n\n        //                revert(0, 0)\n\n        //            }\n\n\n\n            answer := mload(ptr) // Assign output to answer var\n\n            mstore(0x40,add(ptr,0x20)) // Set storage pointer to new space\n\n        }\n",
          "message": "Call.params2 (TwoKeyPlasmaEvents.sol#64-94) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 96,
          "vulnerability_to_line": 104,
          "vulnerability_code": "    function loadAddress(bytes sig, uint idx) public pure returns (address) {\n\n        address influencer;\n\n        idx += 20;\n\n        assembly\n\n        {\n\n            influencer := mload(add(sig, idx))\n\n        }\n\n        return influencer;\n",
          "message": "Call.loadAddress (TwoKeyPlasmaEvents.sol#96-104) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 106,
          "vulnerability_to_line": 114,
          "vulnerability_code": "    function loadUint8(bytes sig, uint idx) public pure returns (uint8) {\n\n        uint8 weight;\n\n        idx += 1;\n\n        assembly\n\n        {\n\n            weight := mload(add(sig, idx))\n\n        }\n\n        return weight;\n",
          "message": "Call.loadUint8 (TwoKeyPlasmaEvents.sol#106-114) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 117,
          "vulnerability_to_line": 152,
          "vulnerability_code": "    function recoverHash(bytes32 hash, bytes sig, uint idx) public pure returns (address) {\n\n        // same as recoverHash in utils/sign.js\n\n        // The signature format is a compact form of:\n\n        //   {bytes32 r}{bytes32 s}{uint8 v}\n\n        // Compact means, uint8 is not padded to 32 bytes.\n\n        require (sig.length >= 65+idx, 'bad signature length');\n\n        idx += 32;\n\n        bytes32 r;\n\n        assembly\n\n        {\n\n            r := mload(add(sig, idx))\n\n        }\n\n\n\n        idx += 32;\n\n        bytes32 s;\n\n        assembly\n\n        {\n\n            s := mload(add(sig, idx))\n\n        }\n\n\n\n        idx += 1;\n\n        uint8 v;\n\n        assembly\n\n        {\n\n            v := mload(add(sig, idx))\n\n        }\n\n        if (v >= 32) { // handle case when signature was made with ethereum web3.eth.sign or getSign which is for signing ethereum transactions\n\n            v -= 32;\n\n            bytes memory prefix = \"\\x19Ethereum Signed Message:\\n32\"; // 32 is the number of bytes in the following hash\n\n            hash = keccak256(abi.encodePacked(prefix, hash));\n\n        }\n\n        if (v <= 1) v += 27;\n\n        require(v==27 || v==28,'bad sig v');\n\n        return ecrecover(hash, v, r, s);\n\n\n",
          "message": "Call.recoverHash (TwoKeyPlasmaEvents.sol#117-152) is declared view but contains assembly code\n"
        },
        {
          "name": "locked-ether",
          "vulnerability_from_line": 337,
          "vulnerability_to_line": 339,
          "vulnerability_code": "    function initialize(address sender) public payable {\n\n        require(msg.sender == address(registry));\n",
          "message": "Contract locking ether found in TwoKeyPlasmaEvents.sol:\n\tContract TwoKeyPlasmaEvents has payable functions:\n\t - initialize (TwoKeyPlasmaEvents.sol#337-339)\n\tBut does not have a function to withdraw the ether\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 6,
          "vulnerability_to_line": 32,
          "vulnerability_code": "    function params0(address c, bytes _method) public view returns (uint answer) {\n\n        // https://medium.com/@blockchain101/calling-the-function-of-another-contract-in-solidity-f9edfa921f4c\n\n        //    dc = c;\n\n        bytes4 sig = bytes4(keccak256(_method));\n\n        assembly {\n\n        // move pointer to free memory spot\n\n            let ptr := mload(0x40)\n\n        // put function sig at memory spot\n\n            mstore(ptr,sig)\n\n\n\n            let result := call(  // use WARNING because this should be staticcall BUT geth crash!\n\n            15000, // gas limit\n\n            c, // sload(dc_slot),  // to addr. append var to _slot to access storage variable\n\n            0, // not transfer any ether (comment if using staticcall)\n\n            ptr, // Inputs are stored at location ptr\n\n            0x04, // Inputs are 0 bytes long\n\n            ptr,  //Store output over input\n\n            0x20) //Outputs are 1 bytes long\n\n\n\n            if eq(result, 0) {\n\n                revert(0, 0)\n\n            }\n\n\n\n            answer := mload(ptr) // Assign output to answer var\n\n            mstore(0x40,add(ptr,0x24)) // Set storage pointer to new space\n\n        }\n",
          "message": "Call.params0 uses assembly (TwoKeyPlasmaEvents.sol#6-32)\n\t- TwoKeyPlasmaEvents.sol#10-32\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 34,
          "vulnerability_to_line": 62,
          "vulnerability_code": "    function params1(address c, bytes _method, uint _val) public view returns (uint answer) {\n\n        // https://medium.com/@blockchain101/calling-the-function-of-another-contract-in-solidity-f9edfa921f4c\n\n        //    dc = c;\n\n        bytes4 sig = bytes4(keccak256(_method));\n\n        assembly {\n\n        // move pointer to free memory spot\n\n            let ptr := mload(0x40)\n\n        // put function sig at memory spot\n\n            mstore(ptr,sig)\n\n        // append argument after function sig\n\n            mstore(add(ptr,0x04), _val)\n\n\n\n            let result := call(  // use WARNING because this should be staticcall BUT geth crash!\n\n            15000, // gas limit\n\n            c, // sload(dc_slot),  // to addr. append var to _slot to access storage variable\n\n            0, // not transfer any ether (comment if using staticcall)\n\n            ptr, // Inputs are stored at location ptr\n\n            0x24, // Inputs are 0 bytes long\n\n            ptr,  //Store output over input\n\n            0x20) //Outputs are 1 bytes long\n\n\n\n            if eq(result, 0) {\n\n                revert(0, 0)\n\n            }\n\n\n\n            answer := mload(ptr) // Assign output to answer var\n\n            mstore(0x40,add(ptr,0x24)) // Set storage pointer to new space\n\n        }\n",
          "message": "Call.params1 uses assembly (TwoKeyPlasmaEvents.sol#34-62)\n\t- TwoKeyPlasmaEvents.sol#38-62\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 64,
          "vulnerability_to_line": 94,
          "vulnerability_code": "    function params2(address c, bytes _method, uint _val1, uint _val2) public view returns (uint answer) {\n\n        // https://medium.com/@blockchain101/calling-the-function-of-another-contract-in-solidity-f9edfa921f4c\n\n        //    dc = c;\n\n        bytes4 sig = bytes4(keccak256(_method));\n\n        assembly {\n\n        // move pointer to free memory spot\n\n            let ptr := mload(0x40)\n\n        // put function sig at memory spot\n\n            mstore(ptr,sig)\n\n        // append argument after function sig\n\n            mstore(add(ptr,0x04), _val1)\n\n            mstore(add(ptr,0x24), _val2)\n\n\n\n            let result := call(  // use WARNING because this should be staticcall BUT geth crash!\n\n            15000, // gas limit\n\n            c, // sload(dc_slot),  // to addr. append var to _slot to access storage variable\n\n            0, // not transfer any ether (comment if using staticcall)\n\n            ptr, // Inputs are stored at location ptr\n\n            0x44, // Inputs are 4 bytes for signature and 2 uint256\n\n            ptr,  //Store output over input\n\n            0x20) //Outputs are 1 uint long\n\n\n\n        // TODO cause revert\n\n        //            if eq(result, 0) {\n\n        //                revert(0, 0)\n\n        //            }\n\n\n\n            answer := mload(ptr) // Assign output to answer var\n\n            mstore(0x40,add(ptr,0x20)) // Set storage pointer to new space\n\n        }\n",
          "message": "Call.params2 uses assembly (TwoKeyPlasmaEvents.sol#64-94)\n\t- TwoKeyPlasmaEvents.sol#68-94\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 96,
          "vulnerability_to_line": 104,
          "vulnerability_code": "    function loadAddress(bytes sig, uint idx) public pure returns (address) {\n\n        address influencer;\n\n        idx += 20;\n\n        assembly\n\n        {\n\n            influencer := mload(add(sig, idx))\n\n        }\n\n        return influencer;\n",
          "message": "Call.loadAddress uses assembly (TwoKeyPlasmaEvents.sol#96-104)\n\t- TwoKeyPlasmaEvents.sol#99-103\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 106,
          "vulnerability_to_line": 114,
          "vulnerability_code": "    function loadUint8(bytes sig, uint idx) public pure returns (uint8) {\n\n        uint8 weight;\n\n        idx += 1;\n\n        assembly\n\n        {\n\n            weight := mload(add(sig, idx))\n\n        }\n\n        return weight;\n",
          "message": "Call.loadUint8 uses assembly (TwoKeyPlasmaEvents.sol#106-114)\n\t- TwoKeyPlasmaEvents.sol#109-113\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 117,
          "vulnerability_to_line": 152,
          "vulnerability_code": "    function recoverHash(bytes32 hash, bytes sig, uint idx) public pure returns (address) {\n\n        // same as recoverHash in utils/sign.js\n\n        // The signature format is a compact form of:\n\n        //   {bytes32 r}{bytes32 s}{uint8 v}\n\n        // Compact means, uint8 is not padded to 32 bytes.\n\n        require (sig.length >= 65+idx, 'bad signature length');\n\n        idx += 32;\n\n        bytes32 r;\n\n        assembly\n\n        {\n\n            r := mload(add(sig, idx))\n\n        }\n\n\n\n        idx += 32;\n\n        bytes32 s;\n\n        assembly\n\n        {\n\n            s := mload(add(sig, idx))\n\n        }\n\n\n\n        idx += 1;\n\n        uint8 v;\n\n        assembly\n\n        {\n\n            v := mload(add(sig, idx))\n\n        }\n\n        if (v >= 32) { // handle case when signature was made with ethereum web3.eth.sign or getSign which is for signing ethereum transactions\n\n            v -= 32;\n\n            bytes memory prefix = \"\\x19Ethereum Signed Message:\\n32\"; // 32 is the number of bytes in the following hash\n\n            hash = keccak256(abi.encodePacked(prefix, hash));\n\n        }\n\n        if (v <= 1) v += 27;\n\n        require(v==27 || v==28,'bad sig v');\n\n        return ecrecover(hash, v, r, s);\n\n\n",
          "message": "Call.recoverHash uses assembly (TwoKeyPlasmaEvents.sol#117-152)\n\t- TwoKeyPlasmaEvents.sol#125-130\n\t- TwoKeyPlasmaEvents.sol#132-137\n\t- TwoKeyPlasmaEvents.sol#139-143\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 626,
          "vulnerability_to_line": 651,
          "vulnerability_code": "    function joinCampaign(address campaignAddress, address contractor, bytes sig) public {\n\n        address old_address;\n\n        assembly\n\n        {\n\n            old_address := mload(add(sig, 21))\n\n        }\n\n        old_address = plasmaOf(old_address);\n\n        // validate an existing visit path from contractor address to the old_address\n\n        require(test_path(campaignAddress, contractor, old_address));\n\n        address old_key = publicLinkKeyOf(campaignAddress, contractor, old_address);\n\n        address[] memory influencers;\n\n        address[] memory keys;\n\n        uint8[] memory weights;\n\n        address last_address = msg.sender;\n\n        (influencers, keys, weights) = Call.recoverSig(sig, old_key, last_address);\n\n        address referrer = contractor;\n\n        require(influencers[influencers.length-1] == last_address);\n\n        if (influencers.length > 1) {\n\n            referrer = influencers[influencers.length - 2];\n\n        }\n\n        bytes32 keyJoins = keccak256(\"campaign2numberOfJoins\", campaignAddress);\n\n        PROXY_STORAGE_CONTRACT.setUint(keyJoins, PROXY_STORAGE_CONTRACT.getUint(keyJoins) + 1);\n\n        setJoinedFrom(campaignAddress, contractor, last_address, referrer);\n\n        setVisitedFrom(campaignAddress, contractor, last_address, referrer);\n\n        setVisitsList(campaignAddress, contractor, referrer, last_address);\n",
          "message": "TwoKeyPlasmaEvents.joinCampaign uses assembly (TwoKeyPlasmaEvents.sol#626-651)\n\t- TwoKeyPlasmaEvents.sol#628-632\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 654,
          "vulnerability_to_line": 730,
          "vulnerability_code": "    function visited(address c, address contractor, bytes sig) public {\n\n        // c - addresss of the contract on ethereum\n\n        // contractor - is the ethereum address of the contractor who created c. a dApp can read this information for free from ethereum.\n\n        // caller must use the 2key-link and put his plasma address at the end using free_take\n\n        // sig contains the \"from\" and at the end of sig you should put your own plasma address (msg.sender) or a signature of cut using it\n\n\n\n        address old_address;\n\n        assembly\n\n        {\n\n            old_address := mload(add(sig, 21))\n\n        }\n\n        old_address = plasmaOf(old_address);\n\n\n\n        // validate an existing visit path from contractor address to the old_address\n\n        require(test_path(c, contractor, old_address));\n\n\n\n        address old_key = publicLinkKeyOf(c, contractor, old_address);\n\n\n\n\n\n        address[] memory influencers;\n\n        address[] memory keys;\n\n        uint8[] memory weights;\n\n        address last_address = msg.sender;\n\n        (influencers, keys, weights) = Call.recoverSig(sig, old_key, last_address);\n\n        // check if we exactly reached the end of the signature. this can only happen if the signature\n\n        // was generated with free_join_take and in this case the last part of the signature must have been\n\n        // generated by the caller of this method\n\n        require(influencers[influencers.length-1] == last_address);\n\n        setVisitedSig(c, contractor, last_address, sig);\n\n\n\n        if(influencers.length > 1 && getCampaignToReferrerToCounted(c,influencers[influencers.length-2]) == false && influencers[influencers.length-2] != contractor) {\n\n            setCampaignToReferrerToCounted(c, influencers[influencers.length-2]);\n\n            bytes32 key = keccak256(\"campaign2numberOfForwarders\",c);\n\n            PROXY_STORAGE_CONTRACT.setUint(key, PROXY_STORAGE_CONTRACT.getUint(key) + 1);\n\n        }\n\n\n\n        uint i;\n\n        address new_address;\n\n        // move ARCs based on signature information\n\n        for (i = 0; i < influencers.length; i++) {\n\n            new_address = influencers[i];\n\n            require(new_address != plasmaOf(contractor));\n\n            // NOTE!!!! for the last user in the sig the  new_address can be a plasma_address\n\n            // as a result the same user with a plasma_address can appear later with an etherum address\n\n            if (!getVisits(c,contractor,old_address,new_address)) {  // generate event only once for each tripplet\n\n                setVisits(c,contractor,old_address,new_address);\n\n                incrementNumberOfVisitsPerCampaign(c);\n\n\n\n                if (getJoinedFrom(c, contractor, new_address) == address(0)) {\n\n                    setVisitedFrom(c, contractor, new_address, old_address);\n\n                    //TODO: Updating visited from time\n\n                    setVisitedFromTime(c,contractor,new_address,old_address);\n\n                }\n\n                setVisitsList(c, contractor, old_address, new_address);\n\n                setVisitsListTimestamps(c, contractor, old_address);\n\n                emit Visited(new_address, c, contractor, old_address);\n\n            } /* else {\n\n                require(visited_from[c][contractor][new_address] == old_address, 'User already visited from a different influencer');\n\n            }*/\n\n\n\n            old_address = new_address;\n\n        }\n\n\n\n        for (i = 0; i < keys.length; i++) {\n\n            // TODO Updating the public key of influencers may not a good idea because it will require the influencers to use\n\n            // a deterministic private/public key in the link and this might require user interaction (MetaMask signature)\n\n            // TODO a possible solution is change public_link_key to address=>address[]\n\n            // update (only once) the public address used by each influencer\n\n            // we will need this in case one of the influencers will want to start his own off-chain link\n\n            setPublicLinkKeyOf(c, contractor, influencers[i], keys[i]);\n\n        }\n\n\n\n        for (i = 0; i < weights.length; i++) {\n\n            setCutOf(c, contractor, influencers[i], weights[i]);\n\n        }\n\n\n",
          "message": "TwoKeyPlasmaEvents.visited uses assembly (TwoKeyPlasmaEvents.sol#654-730)\n\t- TwoKeyPlasmaEvents.sol#661-665\n"
        },
        {
          "name": "constable-states",
          "vulnerability_from_line": 317,
          "vulnerability_to_line": null,
          "vulnerability_code": "    address internal _implementation;\n",
          "message": "UpgradeabilityStorage._implementation should be constant (TwoKeyPlasmaEvents.sol#317)\n"
        },
        {
          "name": "pragma",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.24;\n",
          "message": "Different versions of Solidity is used in TwoKeyPlasmaEvents.sol:\n\t- Version used: ['^0.4.0', '^0.4.24']\n\t- TwoKeyPlasmaEvents.sol#3 declares pragma solidity^0.4.24\n\t- TwoKeyPlasmaEvents.sol#266 declares pragma solidity^0.4.24\n\t- TwoKeyPlasmaEvents.sol#306 declares pragma solidity^0.4.24\n\t- TwoKeyPlasmaEvents.sol#330 declares pragma solidity^0.4.24\n\t- TwoKeyPlasmaEvents.sol#344 declares pragma solidity^0.4.0\n\t- TwoKeyPlasmaEvents.sol#395 declares pragma solidity^0.4.24\n\t- TwoKeyPlasmaEvents.sol#403 declares pragma solidity^0.4.24\n\t- TwoKeyPlasmaEvents.sol#411 declares pragma solidity^0.4.24\n\t- TwoKeyPlasmaEvents.sol#424 declares pragma solidity^0.4.24\n\t- TwoKeyPlasmaEvents.sol#445 declares pragma solidity^0.4.24\n\t- TwoKeyPlasmaEvents.sol#871 declares pragma solidity^0.4.24\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 6,
          "vulnerability_to_line": 32,
          "vulnerability_code": "    function params0(address c, bytes _method) public view returns (uint answer) {\n\n        // https://medium.com/@blockchain101/calling-the-function-of-another-contract-in-solidity-f9edfa921f4c\n\n        //    dc = c;\n\n        bytes4 sig = bytes4(keccak256(_method));\n\n        assembly {\n\n        // move pointer to free memory spot\n\n            let ptr := mload(0x40)\n\n        // put function sig at memory spot\n\n            mstore(ptr,sig)\n\n\n\n            let result := call(  // use WARNING because this should be staticcall BUT geth crash!\n\n            15000, // gas limit\n\n            c, // sload(dc_slot),  // to addr. append var to _slot to access storage variable\n\n            0, // not transfer any ether (comment if using staticcall)\n\n            ptr, // Inputs are stored at location ptr\n\n            0x04, // Inputs are 0 bytes long\n\n            ptr,  //Store output over input\n\n            0x20) //Outputs are 1 bytes long\n\n\n\n            if eq(result, 0) {\n\n                revert(0, 0)\n\n            }\n\n\n\n            answer := mload(ptr) // Assign output to answer var\n\n            mstore(0x40,add(ptr,0x24)) // Set storage pointer to new space\n\n        }\n",
          "message": "Call.params0 (TwoKeyPlasmaEvents.sol#6-32) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 34,
          "vulnerability_to_line": 62,
          "vulnerability_code": "    function params1(address c, bytes _method, uint _val) public view returns (uint answer) {\n\n        // https://medium.com/@blockchain101/calling-the-function-of-another-contract-in-solidity-f9edfa921f4c\n\n        //    dc = c;\n\n        bytes4 sig = bytes4(keccak256(_method));\n\n        assembly {\n\n        // move pointer to free memory spot\n\n            let ptr := mload(0x40)\n\n        // put function sig at memory spot\n\n            mstore(ptr,sig)\n\n        // append argument after function sig\n\n            mstore(add(ptr,0x04), _val)\n\n\n\n            let result := call(  // use WARNING because this should be staticcall BUT geth crash!\n\n            15000, // gas limit\n\n            c, // sload(dc_slot),  // to addr. append var to _slot to access storage variable\n\n            0, // not transfer any ether (comment if using staticcall)\n\n            ptr, // Inputs are stored at location ptr\n\n            0x24, // Inputs are 0 bytes long\n\n            ptr,  //Store output over input\n\n            0x20) //Outputs are 1 bytes long\n\n\n\n            if eq(result, 0) {\n\n                revert(0, 0)\n\n            }\n\n\n\n            answer := mload(ptr) // Assign output to answer var\n\n            mstore(0x40,add(ptr,0x24)) // Set storage pointer to new space\n\n        }\n",
          "message": "Call.params1 (TwoKeyPlasmaEvents.sol#34-62) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 64,
          "vulnerability_to_line": 94,
          "vulnerability_code": "    function params2(address c, bytes _method, uint _val1, uint _val2) public view returns (uint answer) {\n\n        // https://medium.com/@blockchain101/calling-the-function-of-another-contract-in-solidity-f9edfa921f4c\n\n        //    dc = c;\n\n        bytes4 sig = bytes4(keccak256(_method));\n\n        assembly {\n\n        // move pointer to free memory spot\n\n            let ptr := mload(0x40)\n\n        // put function sig at memory spot\n\n            mstore(ptr,sig)\n\n        // append argument after function sig\n\n            mstore(add(ptr,0x04), _val1)\n\n            mstore(add(ptr,0x24), _val2)\n\n\n\n            let result := call(  // use WARNING because this should be staticcall BUT geth crash!\n\n            15000, // gas limit\n\n            c, // sload(dc_slot),  // to addr. append var to _slot to access storage variable\n\n            0, // not transfer any ether (comment if using staticcall)\n\n            ptr, // Inputs are stored at location ptr\n\n            0x44, // Inputs are 4 bytes for signature and 2 uint256\n\n            ptr,  //Store output over input\n\n            0x20) //Outputs are 1 uint long\n\n\n\n        // TODO cause revert\n\n        //            if eq(result, 0) {\n\n        //                revert(0, 0)\n\n        //            }\n\n\n\n            answer := mload(ptr) // Assign output to answer var\n\n            mstore(0x40,add(ptr,0x20)) // Set storage pointer to new space\n\n        }\n",
          "message": "Call.params2 (TwoKeyPlasmaEvents.sol#64-94) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 236,
          "vulnerability_to_line": 261,
          "vulnerability_code": "    function recoverSig(bytes sig, address old_key, address last_address) public pure returns (address[], address[], uint8[]) {\n\n        // validate sig AND\n\n        // recover the information from the signature: influencers, public_link_keys, weights/cuts\n\n        // influencers may have one more address than the keys and weights arrays\n\n        //\n\n        require(old_key != address(0),'no public link key');\n\n\n\n        address[] memory influencers;\n\n        address[] memory keys;\n\n        uint8[] memory weights;\n\n        uint[] memory offsets;\n\n        (influencers, keys, weights, offsets) = recoverSigParts(sig, last_address);\n\n\n\n        // check if we received a valid signature\n\n        for(uint i = 0; i < influencers.length; i++) {\n\n            if (i < weights.length) {\n\n                require (recoverHash(keccak256(abi.encodePacked(weights[i], keys[i], influencers[i])),sig,offsets[i]) == old_key, 'illegal signature');\n\n                old_key = keys[i];\n\n            } else {\n\n                // signed message for the last step is the address of the converter\n\n                require (recoverHash(keccak256(abi.encodePacked(influencers[i])),sig,offsets[i]) == old_key, 'illegal last signature');\n\n            }\n\n        }\n\n\n\n        return (influencers, keys, weights);\n",
          "message": "Call.recoverSig (TwoKeyPlasmaEvents.sol#236-261) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 293,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function addVersion(string _contractName, string version, address implementation) public;\n",
          "message": "ITwoKeySingletonesRegistry.addVersion (TwoKeyPlasmaEvents.sol#293) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 301,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getVersion(string _contractName, string version) public view returns (address);\n",
          "message": "ITwoKeySingletonesRegistry.getVersion (TwoKeyPlasmaEvents.sol#301) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 323,
          "vulnerability_to_line": 325,
          "vulnerability_code": "    function implementation() public view returns (address) {\n\n        return _implementation;\n",
          "message": "UpgradeabilityStorage.implementation (TwoKeyPlasmaEvents.sol#323-325) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 337,
          "vulnerability_to_line": 339,
          "vulnerability_code": "    function initialize(address sender) public payable {\n\n        require(msg.sender == address(registry));\n",
          "message": "Upgradeable.initialize (TwoKeyPlasmaEvents.sol#337-339) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 406,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function onlyMaintainer(address _sender) public view returns (bool);\n",
          "message": "ITwoKeyMaintainersRegistry.onlyMaintainer (TwoKeyPlasmaEvents.sol#406) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 417,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getContractProxyAddress(string _contractName) public view returns (address);\n",
          "message": "ITwoKeySingletoneRegistryFetchAddress.getContractProxyAddress (TwoKeyPlasmaEvents.sol#417) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 418,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getNonUpgradableContractAddress(string contractName) public view returns (address);\n",
          "message": "ITwoKeySingletoneRegistryFetchAddress.getNonUpgradableContractAddress (TwoKeyPlasmaEvents.sol#418) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 419,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getLatestContractVersion(string contractName) public view returns (string);\n",
          "message": "ITwoKeySingletoneRegistryFetchAddress.getLatestContractVersion (TwoKeyPlasmaEvents.sol#419) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 427,
          "vulnerability_to_line": 432,
          "vulnerability_code": "    function plasma2ethereum(\n\n        address _plasma\n\n    )\n\n    public\n\n    view\n",
          "message": "ITwoKeyPlasmaRegistry.plasma2ethereum (TwoKeyPlasmaEvents.sol#427-432) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 435,
          "vulnerability_to_line": 440,
          "vulnerability_code": "    function ethereum2plasma(\n\n        address _ethereum\n\n    )\n\n    public\n\n    view\n",
          "message": "ITwoKeyPlasmaRegistry.ethereum2plasma (TwoKeyPlasmaEvents.sol#435-440) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 491,
          "vulnerability_to_line": 503,
          "vulnerability_code": "    function setInitialParams(\n\n        address _twoKeyPlasmaSingletonRegistry,\n\n        address _proxyStorage\n\n    )\n\n    public\n\n    {\n\n        require(initialized == false);\n\n\n\n        TWO_KEY_PLASMA_SINGLETON_REGISTRY = _twoKeyPlasmaSingletonRegistry;\n\n        PROXY_STORAGE_CONTRACT = ITwoKeyPlasmaEventsStorage(_proxyStorage);\n\n        //Adding initial maintainers\n\n        initialized = true;\n",
          "message": "TwoKeyPlasmaEvents.setInitialParams (TwoKeyPlasmaEvents.sol#491-503) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 552,
          "vulnerability_to_line": 554,
          "vulnerability_code": "    function setPublicLinkKey(address c, address contractor, address new_public_key) public {\n\n        setPublicLinkKeyOf(c, contractor, msg.sender, new_public_key);\n",
          "message": "TwoKeyPlasmaEvents.setPublicLinkKey (TwoKeyPlasmaEvents.sol#552-554) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 576,
          "vulnerability_to_line": 578,
          "vulnerability_code": "    function setCut(address c, address contractor, uint256 cut) public {\n\n        setCutOf(c, contractor, msg.sender, cut);\n",
          "message": "TwoKeyPlasmaEvents.setCut (TwoKeyPlasmaEvents.sol#576-578) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 580,
          "vulnerability_to_line": 582,
          "vulnerability_code": "    function cutOf(address c, address contractor, address me) public view returns (uint256) {\n\n        return PROXY_STORAGE_CONTRACT.getUint(keccak256(\"influencer2cut\", c, contractor, plasmaOf(me)));\n",
          "message": "TwoKeyPlasmaEvents.cutOf (TwoKeyPlasmaEvents.sol#580-582) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 600,
          "vulnerability_to_line": 602,
          "vulnerability_code": "    function setNoteByUser(address c, bytes note) public {\n\n        PROXY_STORAGE_CONTRACT.setBytes(keccak256(\"notes\",c,msg.sender), note);\n",
          "message": "TwoKeyPlasmaEvents.setNoteByUser (TwoKeyPlasmaEvents.sol#600-602) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 604,
          "vulnerability_to_line": 606,
          "vulnerability_code": "    function notes(address c, address _plasma) public view returns (bytes) {\n\n        return PROXY_STORAGE_CONTRACT.getBytes(keccak256(\"notes\",c, _plasma));\n",
          "message": "TwoKeyPlasmaEvents.notes (TwoKeyPlasmaEvents.sol#604-606) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 626,
          "vulnerability_to_line": 651,
          "vulnerability_code": "    function joinCampaign(address campaignAddress, address contractor, bytes sig) public {\n\n        address old_address;\n\n        assembly\n\n        {\n\n            old_address := mload(add(sig, 21))\n\n        }\n\n        old_address = plasmaOf(old_address);\n\n        // validate an existing visit path from contractor address to the old_address\n\n        require(test_path(campaignAddress, contractor, old_address));\n\n        address old_key = publicLinkKeyOf(campaignAddress, contractor, old_address);\n\n        address[] memory influencers;\n\n        address[] memory keys;\n\n        uint8[] memory weights;\n\n        address last_address = msg.sender;\n\n        (influencers, keys, weights) = Call.recoverSig(sig, old_key, last_address);\n\n        address referrer = contractor;\n\n        require(influencers[influencers.length-1] == last_address);\n\n        if (influencers.length > 1) {\n\n            referrer = influencers[influencers.length - 2];\n\n        }\n\n        bytes32 keyJoins = keccak256(\"campaign2numberOfJoins\", campaignAddress);\n\n        PROXY_STORAGE_CONTRACT.setUint(keyJoins, PROXY_STORAGE_CONTRACT.getUint(keyJoins) + 1);\n\n        setJoinedFrom(campaignAddress, contractor, last_address, referrer);\n\n        setVisitedFrom(campaignAddress, contractor, last_address, referrer);\n\n        setVisitsList(campaignAddress, contractor, referrer, last_address);\n",
          "message": "TwoKeyPlasmaEvents.joinCampaign (TwoKeyPlasmaEvents.sol#626-651) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 654,
          "vulnerability_to_line": 730,
          "vulnerability_code": "    function visited(address c, address contractor, bytes sig) public {\n\n        // c - addresss of the contract on ethereum\n\n        // contractor - is the ethereum address of the contractor who created c. a dApp can read this information for free from ethereum.\n\n        // caller must use the 2key-link and put his plasma address at the end using free_take\n\n        // sig contains the \"from\" and at the end of sig you should put your own plasma address (msg.sender) or a signature of cut using it\n\n\n\n        address old_address;\n\n        assembly\n\n        {\n\n            old_address := mload(add(sig, 21))\n\n        }\n\n        old_address = plasmaOf(old_address);\n\n\n\n        // validate an existing visit path from contractor address to the old_address\n\n        require(test_path(c, contractor, old_address));\n\n\n\n        address old_key = publicLinkKeyOf(c, contractor, old_address);\n\n\n\n\n\n        address[] memory influencers;\n\n        address[] memory keys;\n\n        uint8[] memory weights;\n\n        address last_address = msg.sender;\n\n        (influencers, keys, weights) = Call.recoverSig(sig, old_key, last_address);\n\n        // check if we exactly reached the end of the signature. this can only happen if the signature\n\n        // was generated with free_join_take and in this case the last part of the signature must have been\n\n        // generated by the caller of this method\n\n        require(influencers[influencers.length-1] == last_address);\n\n        setVisitedSig(c, contractor, last_address, sig);\n\n\n\n        if(influencers.length > 1 && getCampaignToReferrerToCounted(c,influencers[influencers.length-2]) == false && influencers[influencers.length-2] != contractor) {\n\n            setCampaignToReferrerToCounted(c, influencers[influencers.length-2]);\n\n            bytes32 key = keccak256(\"campaign2numberOfForwarders\",c);\n\n            PROXY_STORAGE_CONTRACT.setUint(key, PROXY_STORAGE_CONTRACT.getUint(key) + 1);\n\n        }\n\n\n\n        uint i;\n\n        address new_address;\n\n        // move ARCs based on signature information\n\n        for (i = 0; i < influencers.length; i++) {\n\n            new_address = influencers[i];\n\n            require(new_address != plasmaOf(contractor));\n\n            // NOTE!!!! for the last user in the sig the  new_address can be a plasma_address\n\n            // as a result the same user with a plasma_address can appear later with an etherum address\n\n            if (!getVisits(c,contractor,old_address,new_address)) {  // generate event only once for each tripplet\n\n                setVisits(c,contractor,old_address,new_address);\n\n                incrementNumberOfVisitsPerCampaign(c);\n\n\n\n                if (getJoinedFrom(c, contractor, new_address) == address(0)) {\n\n                    setVisitedFrom(c, contractor, new_address, old_address);\n\n                    //TODO: Updating visited from time\n\n                    setVisitedFromTime(c,contractor,new_address,old_address);\n\n                }\n\n                setVisitsList(c, contractor, old_address, new_address);\n\n                setVisitsListTimestamps(c, contractor, old_address);\n\n                emit Visited(new_address, c, contractor, old_address);\n\n            } /* else {\n\n                require(visited_from[c][contractor][new_address] == old_address, 'User already visited from a different influencer');\n\n            }*/\n\n\n\n            old_address = new_address;\n\n        }\n\n\n\n        for (i = 0; i < keys.length; i++) {\n\n            // TODO Updating the public key of influencers may not a good idea because it will require the influencers to use\n\n            // a deterministic private/public key in the link and this might require user interaction (MetaMask signature)\n\n            // TODO a possible solution is change public_link_key to address=>address[]\n\n            // update (only once) the public address used by each influencer\n\n            // we will need this in case one of the influencers will want to start his own off-chain link\n\n            setPublicLinkKeyOf(c, contractor, influencers[i], keys[i]);\n\n        }\n\n\n\n        for (i = 0; i < weights.length; i++) {\n\n            setCutOf(c, contractor, influencers[i], weights[i]);\n\n        }\n\n\n",
          "message": "TwoKeyPlasmaEvents.visited (TwoKeyPlasmaEvents.sol#654-730) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 733,
          "vulnerability_to_line": 736,
          "vulnerability_code": "    function visitsListEx(address c, address contractor, address from) public view returns (address[], uint[]) {\n\n        from = plasmaOf(from);\n\n        return (getVisitsList(c, contractor, from), getVisitsListTimestamps(c, contractor, from));\n",
          "message": "TwoKeyPlasmaEvents.visitsListEx (TwoKeyPlasmaEvents.sol#733-736) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 747,
          "vulnerability_to_line": 759,
          "vulnerability_code": "    function getNumberOfVisitsAndJoinsAndForwarders(\n\n        address campaignAddress\n\n    )\n\n    public\n\n    view\n\n    returns (uint,uint,uint)\n\n    {\n\n        return (\n\n            PROXY_STORAGE_CONTRACT.getUint(keccak256(\"campaign2numberOfVisits\",campaignAddress)),\n\n            PROXY_STORAGE_CONTRACT.getUint(keccak256(\"campaign2numberOfJoins\",campaignAddress)),\n\n            PROXY_STORAGE_CONTRACT.getUint(keccak256(\"campaign2numberOfForwarders\", campaignAddress))\n\n        );\n",
          "message": "TwoKeyPlasmaEvents.getNumberOfVisitsAndJoinsAndForwarders (TwoKeyPlasmaEvents.sol#747-759) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 846,
          "vulnerability_to_line": 855,
          "vulnerability_code": "    function emitPlasma2EthereumEvent(\n\n        address _plasma,\n\n        address _ethereum\n\n    )\n\n    public\n\n    onlyTwoKeyPlasmaRegistry\n\n    {\n\n\n\n        emit Plasma2Ethereum(_plasma, _ethereum);\n",
          "message": "TwoKeyPlasmaEvents.emitPlasma2EthereumEvent (TwoKeyPlasmaEvents.sol#846-855) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 857,
          "vulnerability_to_line": 865,
          "vulnerability_code": "    function emitPlasma2HandleEvent(\n\n        address _plasma,\n\n        string _handle\n\n    )\n\n    public\n\n    onlyTwoKeyPlasmaRegistry\n\n    {\n\n        emit Plasma2Handle(_plasma, _handle);\n",
          "message": "TwoKeyPlasmaEvents.emitPlasma2HandleEvent (TwoKeyPlasmaEvents.sol#857-865) should be declared external\n"
        },
        {
          "name": "solc-version",
          "vulnerability_from_line": 344,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.0;\n",
          "message": "Detected issues with version pragma in TwoKeyPlasmaEvents.sol:\n\t- pragma solidity^0.4.0 (TwoKeyPlasmaEvents.sol#344): it allows old versions\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 6,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function params0(address c, bytes _method) public view returns (uint answer) {\n",
          "message": "Parameter '_method' of Call.params0 (TwoKeyPlasmaEvents.sol#6) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 34,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function params1(address c, bytes _method, uint _val) public view returns (uint answer) {\n",
          "message": "Parameter '_method' of Call.params1 (TwoKeyPlasmaEvents.sol#34) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 64,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function params2(address c, bytes _method, uint _val1, uint _val2) public view returns (uint answer) {\n",
          "message": "Parameter '_method' of Call.params2 (TwoKeyPlasmaEvents.sol#64) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 169,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function recoverSigParts(bytes sig, address last_address) private pure returns (address[], address[], uint8[], uint[]) {\n",
          "message": "Parameter 'last_address' of Call.recoverSigParts (TwoKeyPlasmaEvents.sol#169) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 236,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function recoverSig(bytes sig, address old_key, address last_address) public pure returns (address[], address[], uint8[]) {\n",
          "message": "Parameter 'old_key' of Call.recoverSig (TwoKeyPlasmaEvents.sol#236) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 236,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function recoverSig(bytes sig, address old_key, address last_address) public pure returns (address[], address[], uint8[]) {\n",
          "message": "Parameter 'last_address' of Call.recoverSig (TwoKeyPlasmaEvents.sol#236) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 317,
          "vulnerability_to_line": null,
          "vulnerability_code": "    address internal _implementation;\n",
          "message": "Variable 'UpgradeabilityStorage._implementation' (TwoKeyPlasmaEvents.sol#317) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 492,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address _twoKeyPlasmaSingletonRegistry,\n",
          "message": "Parameter '_twoKeyPlasmaSingletonRegistry' of TwoKeyPlasmaEvents.setInitialParams (TwoKeyPlasmaEvents.sol#492) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 493,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address _proxyStorage\n",
          "message": "Parameter '_proxyStorage' of TwoKeyPlasmaEvents.setInitialParams (TwoKeyPlasmaEvents.sol#493) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 536,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setPublicLinkKeyOf(address c, address contractor, address new_address, address new_public_key) private {\n",
          "message": "Parameter 'new_address' of TwoKeyPlasmaEvents.setPublicLinkKeyOf (TwoKeyPlasmaEvents.sol#536) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 536,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setPublicLinkKeyOf(address c, address contractor, address new_address, address new_public_key) private {\n",
          "message": "Parameter 'new_public_key' of TwoKeyPlasmaEvents.setPublicLinkKeyOf (TwoKeyPlasmaEvents.sol#536) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 552,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setPublicLinkKey(address c, address contractor, address new_public_key) public {\n",
          "message": "Parameter 'new_public_key' of TwoKeyPlasmaEvents.setPublicLinkKey (TwoKeyPlasmaEvents.sol#552) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 584,
          "vulnerability_to_line": 594,
          "vulnerability_code": "    function test_path(address c, address contractor, address to) private view returns (bool) {\n\n        contractor = plasmaOf(contractor);\n\n        to = plasmaOf(to);\n\n        while(to != contractor) {\n\n            if(to == address(0)) {\n\n                return false;\n\n            }\n\n            to = getVisitedFrom(c, contractor, to);\n\n        }\n\n        return true;\n",
          "message": "Function 'TwoKeyPlasmaEvents.test_path' (TwoKeyPlasmaEvents.sol#584-594) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 604,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function notes(address c, address _plasma) public view returns (bytes) {\n",
          "message": "Parameter '_plasma' of TwoKeyPlasmaEvents.notes (TwoKeyPlasmaEvents.sol#604) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 769,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getVisits(address campaign, address contractor, address old_address, address new_address) internal view returns (bool) {\n",
          "message": "Parameter 'old_address' of TwoKeyPlasmaEvents.getVisits (TwoKeyPlasmaEvents.sol#769) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 769,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getVisits(address campaign, address contractor, address old_address, address new_address) internal view returns (bool) {\n",
          "message": "Parameter 'new_address' of TwoKeyPlasmaEvents.getVisits (TwoKeyPlasmaEvents.sol#769) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 773,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setVisits(address campaign, address contractor, address old_address, address new_address) internal {\n",
          "message": "Parameter 'old_address' of TwoKeyPlasmaEvents.setVisits (TwoKeyPlasmaEvents.sol#773) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 773,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setVisits(address campaign, address contractor, address old_address, address new_address) internal {\n",
          "message": "Parameter 'new_address' of TwoKeyPlasmaEvents.setVisits (TwoKeyPlasmaEvents.sol#773) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 782,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setVisitedFromTime(address campaign, address contractor, address new_address, address old_address) internal {\n",
          "message": "Parameter 'new_address' of TwoKeyPlasmaEvents.setVisitedFromTime (TwoKeyPlasmaEvents.sol#782) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 782,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setVisitedFromTime(address campaign, address contractor, address new_address, address old_address) internal {\n",
          "message": "Parameter 'old_address' of TwoKeyPlasmaEvents.setVisitedFromTime (TwoKeyPlasmaEvents.sol#782) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 787,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setVisitedSig(address _campaign, address _contractor, address _last_address, bytes _sig) internal {\n",
          "message": "Parameter '_campaign' of TwoKeyPlasmaEvents.setVisitedSig (TwoKeyPlasmaEvents.sol#787) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 787,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setVisitedSig(address _campaign, address _contractor, address _last_address, bytes _sig) internal {\n",
          "message": "Parameter '_contractor' of TwoKeyPlasmaEvents.setVisitedSig (TwoKeyPlasmaEvents.sol#787) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 787,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setVisitedSig(address _campaign, address _contractor, address _last_address, bytes _sig) internal {\n",
          "message": "Parameter '_last_address' of TwoKeyPlasmaEvents.setVisitedSig (TwoKeyPlasmaEvents.sol#787) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 787,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setVisitedSig(address _campaign, address _contractor, address _last_address, bytes _sig) internal {\n",
          "message": "Parameter '_sig' of TwoKeyPlasmaEvents.setVisitedSig (TwoKeyPlasmaEvents.sol#787) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 792,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getVisitedFrom(address c, address contractor, address _address) public view returns (address) {\n",
          "message": "Parameter '_address' of TwoKeyPlasmaEvents.getVisitedFrom (TwoKeyPlasmaEvents.sol#792) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 797,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setVisitedFrom(address c, address contractor, address _oldAddress, address _newAddress) internal {\n",
          "message": "Parameter '_oldAddress' of TwoKeyPlasmaEvents.setVisitedFrom (TwoKeyPlasmaEvents.sol#797) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 797,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setVisitedFrom(address c, address contractor, address _oldAddress, address _newAddress) internal {\n",
          "message": "Parameter '_newAddress' of TwoKeyPlasmaEvents.setVisitedFrom (TwoKeyPlasmaEvents.sol#797) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 802,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setJoinedFrom(address _c, address _contractor, address _old_address, address _new_address) internal {\n",
          "message": "Parameter '_c' of TwoKeyPlasmaEvents.setJoinedFrom (TwoKeyPlasmaEvents.sol#802) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 802,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setJoinedFrom(address _c, address _contractor, address _old_address, address _new_address) internal {\n",
          "message": "Parameter '_contractor' of TwoKeyPlasmaEvents.setJoinedFrom (TwoKeyPlasmaEvents.sol#802) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 802,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setJoinedFrom(address _c, address _contractor, address _old_address, address _new_address) internal {\n",
          "message": "Parameter '_old_address' of TwoKeyPlasmaEvents.setJoinedFrom (TwoKeyPlasmaEvents.sol#802) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 802,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setJoinedFrom(address _c, address _contractor, address _old_address, address _new_address) internal {\n",
          "message": "Parameter '_new_address' of TwoKeyPlasmaEvents.setJoinedFrom (TwoKeyPlasmaEvents.sol#802) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 807,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getJoinedFrom(address _c, address _contractor, address _address) public view returns (address) {\n",
          "message": "Parameter '_c' of TwoKeyPlasmaEvents.getJoinedFrom (TwoKeyPlasmaEvents.sol#807) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 807,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getJoinedFrom(address _c, address _contractor, address _address) public view returns (address) {\n",
          "message": "Parameter '_contractor' of TwoKeyPlasmaEvents.getJoinedFrom (TwoKeyPlasmaEvents.sol#807) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 807,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getJoinedFrom(address _c, address _contractor, address _address) public view returns (address) {\n",
          "message": "Parameter '_address' of TwoKeyPlasmaEvents.getJoinedFrom (TwoKeyPlasmaEvents.sol#807) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 812,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getVisitsList(address _c, address _contractor, address _referrer) internal view returns (address[]) {\n",
          "message": "Parameter '_c' of TwoKeyPlasmaEvents.getVisitsList (TwoKeyPlasmaEvents.sol#812) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 812,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getVisitsList(address _c, address _contractor, address _referrer) internal view returns (address[]) {\n",
          "message": "Parameter '_contractor' of TwoKeyPlasmaEvents.getVisitsList (TwoKeyPlasmaEvents.sol#812) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 812,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getVisitsList(address _c, address _contractor, address _referrer) internal view returns (address[]) {\n",
          "message": "Parameter '_referrer' of TwoKeyPlasmaEvents.getVisitsList (TwoKeyPlasmaEvents.sol#812) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 817,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setVisitsList(address _c, address _contractor, address _referrer, address _visitor) internal {\n",
          "message": "Parameter '_c' of TwoKeyPlasmaEvents.setVisitsList (TwoKeyPlasmaEvents.sol#817) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 817,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setVisitsList(address _c, address _contractor, address _referrer, address _visitor) internal {\n",
          "message": "Parameter '_contractor' of TwoKeyPlasmaEvents.setVisitsList (TwoKeyPlasmaEvents.sol#817) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 817,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setVisitsList(address _c, address _contractor, address _referrer, address _visitor) internal {\n",
          "message": "Parameter '_referrer' of TwoKeyPlasmaEvents.setVisitsList (TwoKeyPlasmaEvents.sol#817) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 817,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setVisitsList(address _c, address _contractor, address _referrer, address _visitor) internal {\n",
          "message": "Parameter '_visitor' of TwoKeyPlasmaEvents.setVisitsList (TwoKeyPlasmaEvents.sol#817) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 829,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getVisitsListTimestamps(address _c, address _contractor, address _referrer) public view returns (uint[]) {\n",
          "message": "Parameter '_c' of TwoKeyPlasmaEvents.getVisitsListTimestamps (TwoKeyPlasmaEvents.sol#829) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 829,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getVisitsListTimestamps(address _c, address _contractor, address _referrer) public view returns (uint[]) {\n",
          "message": "Parameter '_contractor' of TwoKeyPlasmaEvents.getVisitsListTimestamps (TwoKeyPlasmaEvents.sol#829) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 829,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getVisitsListTimestamps(address _c, address _contractor, address _referrer) public view returns (uint[]) {\n",
          "message": "Parameter '_referrer' of TwoKeyPlasmaEvents.getVisitsListTimestamps (TwoKeyPlasmaEvents.sol#829) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 834,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setVisitsListTimestamps(address _c, address _contractor, address _referrer) internal {\n",
          "message": "Parameter '_c' of TwoKeyPlasmaEvents.setVisitsListTimestamps (TwoKeyPlasmaEvents.sol#834) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 834,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setVisitsListTimestamps(address _c, address _contractor, address _referrer) internal {\n",
          "message": "Parameter '_contractor' of TwoKeyPlasmaEvents.setVisitsListTimestamps (TwoKeyPlasmaEvents.sol#834) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 834,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setVisitsListTimestamps(address _c, address _contractor, address _referrer) internal {\n",
          "message": "Parameter '_referrer' of TwoKeyPlasmaEvents.setVisitsListTimestamps (TwoKeyPlasmaEvents.sol#834) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 847,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address _plasma,\n",
          "message": "Parameter '_plasma' of TwoKeyPlasmaEvents.emitPlasma2EthereumEvent (TwoKeyPlasmaEvents.sol#847) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 848,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address _ethereum\n",
          "message": "Parameter '_ethereum' of TwoKeyPlasmaEvents.emitPlasma2EthereumEvent (TwoKeyPlasmaEvents.sol#848) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 858,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address _plasma,\n",
          "message": "Parameter '_plasma' of TwoKeyPlasmaEvents.emitPlasma2HandleEvent (TwoKeyPlasmaEvents.sol#858) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 859,
          "vulnerability_to_line": null,
          "vulnerability_code": "        string _handle\n",
          "message": "Parameter '_handle' of TwoKeyPlasmaEvents.emitPlasma2HandleEvent (TwoKeyPlasmaEvents.sol#859) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 454,
          "vulnerability_to_line": null,
          "vulnerability_code": "    ITwoKeyPlasmaEventsStorage public PROXY_STORAGE_CONTRACT;\n",
          "message": "Variable 'TwoKeyPlasmaEvents.PROXY_STORAGE_CONTRACT' (TwoKeyPlasmaEvents.sol#454) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 456,
          "vulnerability_to_line": null,
          "vulnerability_code": "    address public TWO_KEY_PLASMA_SINGLETON_REGISTRY;\n",
          "message": "Variable 'TwoKeyPlasmaEvents.TWO_KEY_PLASMA_SINGLETON_REGISTRY' (TwoKeyPlasmaEvents.sol#456) is not in mixedCase\n"
        }
      ]
    },
    "smartcheck": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 250,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(uint i = 0; i < influencers.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 693,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (i = 0; i < influencers.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 717,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (i = 0; i < keys.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 726,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (i = 0; i < weights.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 820,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(uint i=0; i< visitsList.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 837,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(uint i=0; i< visitListTimestamps.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 195,
          "vulnerability_to_line": null,
          "vulnerability_code": "        while (idx + 65 <= sig.length) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
          "vulnerability_from_line": 6,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function params0(address c, bytes _method) public view returns (uint answer) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
          "vulnerability_from_line": 34,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function params1(address c, bytes _method, uint _val) public view returns (uint answer) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
          "vulnerability_from_line": 64,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function params2(address c, bytes _method, uint _val1, uint _val2) public view returns (uint answer) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 250,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(uint i = 0; i < influencers.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 693,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (i = 0; i < influencers.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 717,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (i = 0; i < keys.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 726,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (i = 0; i < weights.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 820,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(uint i=0; i< visitsList.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 837,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(uint i=0; i< visitListTimestamps.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 195,
          "vulnerability_to_line": null,
          "vulnerability_code": "        while (idx + 65 <= sig.length) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 587,
          "vulnerability_to_line": null,
          "vulnerability_code": "        while(to != contractor) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_LOCKED_MONEY",
          "vulnerability_from_line": 332,
          "vulnerability_to_line": null,
          "vulnerability_code": "contract Upgradeable is UpgradeabilityStorage {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.24;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 266,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.24;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 306,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.24;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 330,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.24;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 344,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 395,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.24;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 403,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.24;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 411,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.24;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 424,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.24;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 445,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.24; //We have to specify what version of compiler this code will use\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 871,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.24; //We have to specify what version of compiler this code will use\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 96,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function loadAddress(bytes sig, uint idx) public pure returns (address) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 106,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function loadUint8(bytes sig, uint idx) public pure returns (uint8) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 117,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function recoverHash(bytes32 hash, bytes sig, uint idx) public pure returns (address) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
          "vulnerability_from_line": 6,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function params0(address c, bytes _method) public view returns (uint answer) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
          "vulnerability_from_line": 34,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function params1(address c, bytes _method, uint _val) public view returns (uint answer) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
          "vulnerability_from_line": 64,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function params2(address c, bytes _method, uint _val1, uint _val2) public view returns (uint answer) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 154,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function recoverSigMemory(bytes sig) private pure returns (address[], address[], uint8[], uint[], uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 169,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function recoverSigParts(bytes sig, address last_address) private pure returns (address[], address[], uint8[], uint[]) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 542,
          "vulnerability_to_line": null,
          "vulnerability_code": "        bytes32 keyHashPublicLinkKey = keccak256(\"public_link_key\",c,contractor,new_address);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 561,
          "vulnerability_to_line": null,
          "vulnerability_code": "        bytes32 keyHashInfluencerToCut = keccak256(\"influencer2cut\", c, contractor, plasma);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 581,
          "vulnerability_to_line": null,
          "vulnerability_code": "        return PROXY_STORAGE_CONTRACT.getUint(keccak256(\"influencer2cut\", c, contractor, plasmaOf(me)));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 597,
          "vulnerability_to_line": null,
          "vulnerability_code": "        return PROXY_STORAGE_CONTRACT.getAddress(keccak256(\"public_link_key\",c,contractor,plasmaOf(me)));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 601,
          "vulnerability_to_line": null,
          "vulnerability_code": "        PROXY_STORAGE_CONTRACT.setBytes(keccak256(\"notes\",c,msg.sender), note);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 605,
          "vulnerability_to_line": null,
          "vulnerability_code": "        return PROXY_STORAGE_CONTRACT.getBytes(keccak256(\"notes\",c, _plasma));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 646,
          "vulnerability_to_line": null,
          "vulnerability_code": "        bytes32 keyJoins = keccak256(\"campaign2numberOfJoins\", campaignAddress);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 686,
          "vulnerability_to_line": null,
          "vulnerability_code": "            bytes32 key = keccak256(\"campaign2numberOfForwarders\",c);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 755,
          "vulnerability_to_line": null,
          "vulnerability_code": "            PROXY_STORAGE_CONTRACT.getUint(keccak256(\"campaign2numberOfVisits\",campaignAddress)),\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 756,
          "vulnerability_to_line": null,
          "vulnerability_code": "            PROXY_STORAGE_CONTRACT.getUint(keccak256(\"campaign2numberOfJoins\",campaignAddress)),\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 757,
          "vulnerability_to_line": null,
          "vulnerability_code": "            PROXY_STORAGE_CONTRACT.getUint(keccak256(\"campaign2numberOfForwarders\", campaignAddress))\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 762,
          "vulnerability_to_line": null,
          "vulnerability_code": "        return PROXY_STORAGE_CONTRACT.getBool(keccak256(\"campaignToReferrerToCounted\", campaign, influencer));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 766,
          "vulnerability_to_line": null,
          "vulnerability_code": "        PROXY_STORAGE_CONTRACT.setBool(keccak256(\"campaignToReferrerToCounted\", campaign, influencer), true);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 770,
          "vulnerability_to_line": null,
          "vulnerability_code": "        return PROXY_STORAGE_CONTRACT.getBool(keccak256(\"visits\",campaign,contractor,old_address,new_address));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 774,
          "vulnerability_to_line": null,
          "vulnerability_code": "        return PROXY_STORAGE_CONTRACT.setBool(keccak256(\"visits\",campaign,contractor,old_address,new_address), true);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 778,
          "vulnerability_to_line": null,
          "vulnerability_code": "        bytes32 key = keccak256(\"campaign2numberOfVisits\",campaign);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 783,
          "vulnerability_to_line": null,
          "vulnerability_code": "        bytes32 keyHash = keccak256(\"visited_from_time\", campaign, contractor, new_address, old_address);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 788,
          "vulnerability_to_line": null,
          "vulnerability_code": "        bytes32 keyHash = keccak256(\"visited_sig\", _campaign, _contractor, _last_address);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 793,
          "vulnerability_to_line": null,
          "vulnerability_code": "        bytes32 keyHash = keccak256(\"visited_from\", c, contractor, _address);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 798,
          "vulnerability_to_line": null,
          "vulnerability_code": "        bytes32 keyHash = keccak256(\"visited_from\", c, contractor, _oldAddress);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 803,
          "vulnerability_to_line": null,
          "vulnerability_code": "        bytes32 keyHash = keccak256(\"joined_from\", _c, _contractor, _old_address);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 808,
          "vulnerability_to_line": null,
          "vulnerability_code": "        bytes32 keyHash = keccak256(\"joined_from\", _c, _contractor, _address);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 813,
          "vulnerability_to_line": null,
          "vulnerability_code": "        bytes32 keyHash = keccak256(\"visits_list\", _c, _contractor, _referrer);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 825,
          "vulnerability_to_line": null,
          "vulnerability_code": "        bytes32 keyHash = keccak256(\"visits_list\", _c, _contractor, _referrer);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 830,
          "vulnerability_to_line": null,
          "vulnerability_code": "        bytes32 keyHash = keccak256(\"visits_list_timestamps\", _c, _contractor, _referrer);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 842,
          "vulnerability_to_line": null,
          "vulnerability_code": "        bytes32 keyHash = keccak256(\"visits_list_timestamps\", _c, _contractor, _referrer);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 6,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function params0(address c, bytes _method) public view returns (uint answer) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 34,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function params1(address c, bytes _method, uint _val) public view returns (uint answer) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 64,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function params2(address c, bytes _method, uint _val1, uint _val2) public view returns (uint answer) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 96,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function loadAddress(bytes sig, uint idx) public pure returns (address) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 106,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function loadUint8(bytes sig, uint idx) public pure returns (uint8) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 117,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function recoverHash(bytes32 hash, bytes sig, uint idx) public pure returns (address) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 154,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function recoverSigMemory(bytes sig) private pure returns (address[], address[], uint8[], uint[], uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 154,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function recoverSigMemory(bytes sig) private pure returns (address[], address[], uint8[], uint[], uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 154,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function recoverSigMemory(bytes sig) private pure returns (address[], address[], uint8[], uint[], uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 154,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function recoverSigMemory(bytes sig) private pure returns (address[], address[], uint8[], uint[], uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 154,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function recoverSigMemory(bytes sig) private pure returns (address[], address[], uint8[], uint[], uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 169,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function recoverSigParts(bytes sig, address last_address) private pure returns (address[], address[], uint8[], uint[]) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 169,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function recoverSigParts(bytes sig, address last_address) private pure returns (address[], address[], uint8[], uint[]) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 169,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function recoverSigParts(bytes sig, address last_address) private pure returns (address[], address[], uint8[], uint[]) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 169,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function recoverSigParts(bytes sig, address last_address) private pure returns (address[], address[], uint8[], uint[]) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 169,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function recoverSigParts(bytes sig, address last_address) private pure returns (address[], address[], uint8[], uint[]) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 236,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function recoverSig(bytes sig, address old_key, address last_address) public pure returns (address[], address[], uint8[]) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 236,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function recoverSig(bytes sig, address old_key, address last_address) public pure returns (address[], address[], uint8[]) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 236,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function recoverSig(bytes sig, address old_key, address last_address) public pure returns (address[], address[], uint8[]) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 236,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function recoverSig(bytes sig, address old_key, address last_address) public pure returns (address[], address[], uint8[]) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 293,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function addVersion(string _contractName, string version, address implementation) public;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 293,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function addVersion(string _contractName, string version, address implementation) public;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 301,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getVersion(string _contractName, string version) public view returns (address);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 301,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getVersion(string _contractName, string version) public view returns (address);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 417,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getContractProxyAddress(string _contractName) public view returns (address);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 418,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getNonUpgradableContractAddress(string contractName) public view returns (address);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 419,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getLatestContractVersion(string contractName) public view returns (string);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 419,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getLatestContractVersion(string contractName) public view returns (string);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 511,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getAddressFromTwoKeySingletonRegistry(string contractName) internal view returns (address) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 600,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setNoteByUser(address c, bytes note) public {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 604,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function notes(address c, address _plasma) public view returns (bytes) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 626,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function joinCampaign(address campaignAddress, address contractor, bytes sig) public {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 654,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function visited(address c, address contractor, bytes sig) public {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 733,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function visitsListEx(address c, address contractor, address from) public view returns (address[], uint[]) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 733,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function visitsListEx(address c, address contractor, address from) public view returns (address[], uint[]) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 787,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setVisitedSig(address _campaign, address _contractor, address _last_address, bytes _sig) internal {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 812,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getVisitsList(address _c, address _contractor, address _referrer) internal view returns (address[]) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 829,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getVisitsListTimestamps(address _c, address _contractor, address _referrer) public view returns (uint[]) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 859,
          "vulnerability_to_line": null,
          "vulnerability_code": "        string _handle\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 10,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 38,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 68,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 99,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 109,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 125,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 132,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 139,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 628,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 661,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 293,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function addVersion(string _contractName, string version, address implementation) public;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 301,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getVersion(string _contractName, string version) public view returns (address);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 458,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bool initialized;\n",
          "message": null
        }
      ]
    },
    "oyente": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "Integer Overflow",
          "vulnerability_from_line": 106,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function loadUint8(bytes sig, uint idx) public pure returns (uint8) {\n",
          "message": null
        },
        {
          "name": "Integer Overflow",
          "vulnerability_from_line": 626,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function joinCampaign(address campaignAddress, address contractor, bytes sig) public {\n",
          "message": null
        }
      ]
    },
    "mythril": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "Integer Arithmetic Bugs (SWC 101)",
          "vulnerability_from_line": 6,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function params0(address c, bytes _method) public view returns (uint answer) {\n",
          "message": "The arithmetic operator can overflow.\nIt is possible to cause an integer overflow or underflow in the arithmetic operation. \nClassification: SWC-101"
        },
        {
          "name": "Integer Arithmetic Bugs (SWC 101)",
          "vulnerability_from_line": 34,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function params1(address c, bytes _method, uint _val) public view returns (uint answer) {\n",
          "message": "The arithmetic operator can overflow.\nIt is possible to cause an integer overflow or underflow in the arithmetic operation. \nClassification: SWC-101"
        },
        {
          "name": "Integer Arithmetic Bugs (SWC 101)",
          "vulnerability_from_line": 64,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function params2(address c, bytes _method, uint _val1, uint _val2) public view returns (uint answer) {\n",
          "message": "The arithmetic operator can overflow.\nIt is possible to cause an integer overflow or underflow in the arithmetic operation. \nClassification: SWC-101"
        },
        {
          "name": "Integer Arithmetic Bugs (SWC 101)",
          "vulnerability_from_line": 236,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function recoverSig(bytes sig, address old_key, address last_address) public pure returns (address[], address[], uint8[]) {\n",
          "message": "The arithmetic operator can overflow.\nIt is possible to cause an integer overflow or underflow in the arithmetic operation. \nClassification: SWC-101"
        },
        {
          "name": "External Call To User-Supplied Address (SWC 107)",
          "vulnerability_from_line": 16,
          "vulnerability_to_line": null,
          "vulnerability_code": "            let result := call(  // use WARNING because this should be staticcall BUT geth crash!\n",
          "message": "A call to a user-supplied address is executed.\nAn external message call to an address specified by the caller is executed. Note that the callee account might contain arbitrary code and could re-enter any function within this contract. Reentering the contract in an intermediate state may lead to unexpected behaviour. Make sure that no state modifications are executed after this call and/or reentrancy guards are in place.\nClassification: SWC-107"
        },
        {
          "name": "External Call To User-Supplied Address (SWC 107)",
          "vulnerability_from_line": 46,
          "vulnerability_to_line": null,
          "vulnerability_code": "            let result := call(  // use WARNING because this should be staticcall BUT geth crash!\n",
          "message": "A call to a user-supplied address is executed.\nAn external message call to an address specified by the caller is executed. Note that the callee account might contain arbitrary code and could re-enter any function within this contract. Reentering the contract in an intermediate state may lead to unexpected behaviour. Make sure that no state modifications are executed after this call and/or reentrancy guards are in place.\nClassification: SWC-107"
        },
        {
          "name": "External Call To User-Supplied Address (SWC 107)",
          "vulnerability_from_line": 77,
          "vulnerability_to_line": null,
          "vulnerability_code": "            let result := call(  // use WARNING because this should be staticcall BUT geth crash!\n",
          "message": "A call to a user-supplied address is executed.\nAn external message call to an address specified by the caller is executed. Note that the callee account might contain arbitrary code and could re-enter any function within this contract. Reentering the contract in an intermediate state may lead to unexpected behaviour. Make sure that no state modifications are executed after this call and/or reentrancy guards are in place.\nClassification: SWC-107"
        },
        {
          "name": "Unchecked return value from external call. (SWC 104)",
          "vulnerability_from_line": 77,
          "vulnerability_to_line": null,
          "vulnerability_code": "            let result := call(  // use WARNING because this should be staticcall BUT geth crash!\n",
          "message": "The return value of a message call is not checked.\nExternal calls return a boolean value. If the callee halts with an exception, 'false' is returned and execution continues in the caller. The caller should check whether an exception happened and react accordingly to avoid unexpected behavior. For example it is often desirable to wrap external calls in require() so the transaction is reverted if the call fails.\nClassification: SWC-104"
        },
        {
          "name": "Jump to an arbitrary instruction (SWC 127)",
          "vulnerability_from_line": 117,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function recoverHash(bytes32 hash, bytes sig, uint idx) public pure returns (address) {\n",
          "message": "The caller can redirect execution to arbitrary bytecode locations.\nIt is possible to redirect the control flow to arbitrary locations in the code. This may allow an attacker to bypass security controls or manipulate the business logic of the smart contract. Avoid using low-level-operations and assembly to prevent this issue.\nClassification: SWC-127"
        },
        {
          "name": "Exception State (SWC 110)",
          "vulnerability_from_line": 195,
          "vulnerability_to_line": null,
          "vulnerability_code": "        while (idx + 65 <= sig.length) {\n",
          "message": "An assertion violation was triggered.\nIt is possible to trigger an assertion violation. Note that Solidity assert() statements should only be used to check invariants. Review the transaction trace generated for this issue and either make sure your program logic is correct, or use require() instead of assert() if your goal is to constrain user inputs or enforce preconditions. Remember to validate inputs from both callers (for instance, via passed arguments) and callees (for instance, via return values).\nClassification: SWC-110"
        }
      ]
    },
    "osiris": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "Overflow bugs",
          "vulnerability_from_line": 122,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require (sig.length >= 65+idx, 'bad signature length');\n",
          "message": null
        },
        {
          "name": "Underflow bugs",
          "vulnerability_from_line": 157,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint n_influencers = (sig.length-21) / (65+msg_len);\n",
          "message": null
        }
      ]
    }
  }
}