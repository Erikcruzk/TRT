pragma solidity ^0.4.24;






library SafeMath {

  


  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {
    
    
    
    if (_a == 0) {
      return 0;
    }

    c = _a * _b;
    assert(c / _a == _b);
    return c;
  }

  


  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {
    
    
    
    return _a / _b;
  }

  


  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {
    assert(_b <= _a);
    return _a - _b;
  }

  


  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {
    c = _a + _b;
    assert(c >= _a);
    return c;
  }
}



pragma solidity ^0.4.24;







contract ERC20Basic {
  function totalSupply() public view returns (uint256);
  function balanceOf(address _who) public view returns (uint256);
  function transfer(address _to, uint256 _value) public returns (bool);
  function allowance(address _ocwner, address _spender) public view returns (uint256);
  function approve(address spender, uint tokens) public returns (bool success);
  function transferFrom(address _from, address _to, uint256 _value) public returns (bool);

  event Transfer(address indexed from, address indexed to, uint256 value);
  event Approval(address indexed tokenOwner, address indexed spender, uint tokens);
}



pragma solidity ^0.4.24;









// The contract does not contain a function named beginMigration(). Therefore, it's not possible to provide a fixed version of it.
// Please provide the correct function or contract details that need to be fixed.



pragma solidity ^0.4.24;




















contract EnigmaToken is StandardToken {

    string public constant name = "Enigma";                                      
    string public constant symbol = "ENG";                                       
    uint8 public constant decimals = 8;                                          
    uint256 public constant INITIAL_SUPPLY = 150000000 * 10**8;  
    uint256 public totalSupply;
    



    constructor() public {
        totalSupply = INITIAL_SUPPLY;                               
        balances[msg.sender] = INITIAL_SUPPLY;                      
        emit Transfer(0x0, msg.sender, INITIAL_SUPPLY);
    }

    




    function transfer(address _to, uint256 _value) public returns (bool) {
        return super.transfer(_to, _value);
    }

    





    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
        return super.transferFrom(_from, _to, _value);
    }

    




    function approve(address _spender, uint256 _value) public returns (bool) {
        return super.approve(_spender, _value);
    }

    function allowance(address _owner, address _spender) public view returns (uint256) {
        return super.allowance(_owner,_spender);
    }

}