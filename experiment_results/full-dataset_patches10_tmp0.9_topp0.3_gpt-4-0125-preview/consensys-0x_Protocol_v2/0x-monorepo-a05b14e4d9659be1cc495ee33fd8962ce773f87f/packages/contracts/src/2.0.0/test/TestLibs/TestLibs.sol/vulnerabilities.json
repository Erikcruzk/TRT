{
  "smartbugs_completed": true,
  "analyzer_results": {
    "semgrep": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 211,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor ()\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 212,
          "vulnerability_to_line": null,
          "vulnerability_code": "        public\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 213,
          "vulnerability_to_line": null,
          "vulnerability_code": "    {\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 214,
          "vulnerability_to_line": null,
          "vulnerability_code": "        EIP712_DOMAIN_HASH = keccak256(abi.encode(\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 215,
          "vulnerability_to_line": null,
          "vulnerability_code": "            EIP712_DOMAIN_SEPARATOR_SCHEMA_HASH,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 216,
          "vulnerability_to_line": null,
          "vulnerability_code": "            keccak256(bytes(EIP712_DOMAIN_NAME)),\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 217,
          "vulnerability_to_line": null,
          "vulnerability_code": "            keccak256(bytes(EIP712_DOMAIN_VERSION)),\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 218,
          "vulnerability_to_line": null,
          "vulnerability_code": "            address(this)\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 219,
          "vulnerability_to_line": null,
          "vulnerability_code": "        ));\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 220,
          "vulnerability_to_line": null,
          "vulnerability_code": "    }\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 16,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 17,
          "vulnerability_to_line": null,
          "vulnerability_code": "            c / a == b,\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 18,
          "vulnerability_to_line": null,
          "vulnerability_code": "            \"UINT256_OVERFLOW\"\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 19,
          "vulnerability_to_line": null,
          "vulnerability_code": "        );\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 37,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 38,
          "vulnerability_to_line": null,
          "vulnerability_code": "            b <= a,\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 39,
          "vulnerability_to_line": null,
          "vulnerability_code": "            \"UINT256_UNDERFLOW\"\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 40,
          "vulnerability_to_line": null,
          "vulnerability_code": "        );\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 50,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 51,
          "vulnerability_to_line": null,
          "vulnerability_code": "            c >= a,\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 52,
          "vulnerability_to_line": null,
          "vulnerability_code": "            \"UINT256_OVERFLOW\"\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 53,
          "vulnerability_to_line": null,
          "vulnerability_code": "        );\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        }
      ]
    },
    "slither": {
      "successfull_analysis": true,
      "errors": [
        "EXIT_CODE_10"
      ],
      "vulnerability_findings": [
        {
          "name": "constant-function",
          "vulnerability_from_line": 328,
          "vulnerability_to_line": 374,
          "vulnerability_code": "    function hashOrder(Order memory order)\n\n        internal\n\n        pure\n\n        returns (bytes32 result)\n\n    {\n\n        bytes32 schemaHash = EIP712_ORDER_SCHEMA_HASH;\n\n        bytes32 makerAssetDataHash = keccak256(order.makerAssetData);\n\n        bytes32 takerAssetDataHash = keccak256(order.takerAssetData);\n\n\n\n        // Assembly for more efficiently computing:\n\n        // keccak256(abi.encode(\n\n        //     order.makerAddress,\n\n        //     order.takerAddress,\n\n        //     order.feeRecipientAddress,\n\n        //     order.senderAddress,\n\n        //     order.makerAssetAmount,\n\n        //     order.takerAssetAmount,\n\n        //     order.makerFee,\n\n        //     order.takerFee,\n\n        //     order.expirationTimeSeconds,\n\n        //     order.salt,\n\n        //     keccak256(order.makerAssetData),\n\n        //     keccak256(order.takerAssetData)\n\n        // ));\n\n\n\n        assembly {\n\n            // Backup\n\n            // solhint-disable-next-line space-after-comma\n\n            let temp1 := mload(sub(order,  32))\n\n            let temp2 := mload(add(order, 320))\n\n            let temp3 := mload(add(order, 352))\n\n            \n\n            // Hash in place\n\n            // solhint-disable-next-line space-after-comma\n\n            mstore(sub(order,  32), schemaHash)\n\n            mstore(add(order, 320), makerAssetDataHash)\n\n            mstore(add(order, 352), takerAssetDataHash)\n\n            result := keccak256(sub(order, 32), 416)\n\n            \n\n            // Restore\n\n            // solhint-disable-next-line space-after-comma\n\n            mstore(sub(order,  32), temp1)\n\n            mstore(add(order, 320), temp2)\n\n            mstore(add(order, 352), temp3)\n\n        }\n\n        return result;\n",
          "message": "LibOrder.hashOrder (TestLibs.sol#328-374) is declared view but contains assembly code\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 328,
          "vulnerability_to_line": 374,
          "vulnerability_code": "    function hashOrder(Order memory order)\n\n        internal\n\n        pure\n\n        returns (bytes32 result)\n\n    {\n\n        bytes32 schemaHash = EIP712_ORDER_SCHEMA_HASH;\n\n        bytes32 makerAssetDataHash = keccak256(order.makerAssetData);\n\n        bytes32 takerAssetDataHash = keccak256(order.takerAssetData);\n\n\n\n        // Assembly for more efficiently computing:\n\n        // keccak256(abi.encode(\n\n        //     order.makerAddress,\n\n        //     order.takerAddress,\n\n        //     order.feeRecipientAddress,\n\n        //     order.senderAddress,\n\n        //     order.makerAssetAmount,\n\n        //     order.takerAssetAmount,\n\n        //     order.makerFee,\n\n        //     order.takerFee,\n\n        //     order.expirationTimeSeconds,\n\n        //     order.salt,\n\n        //     keccak256(order.makerAssetData),\n\n        //     keccak256(order.takerAssetData)\n\n        // ));\n\n\n\n        assembly {\n\n            // Backup\n\n            // solhint-disable-next-line space-after-comma\n\n            let temp1 := mload(sub(order,  32))\n\n            let temp2 := mload(add(order, 320))\n\n            let temp3 := mload(add(order, 352))\n\n            \n\n            // Hash in place\n\n            // solhint-disable-next-line space-after-comma\n\n            mstore(sub(order,  32), schemaHash)\n\n            mstore(add(order, 320), makerAssetDataHash)\n\n            mstore(add(order, 352), takerAssetDataHash)\n\n            result := keccak256(sub(order, 32), 416)\n\n            \n\n            // Restore\n\n            // solhint-disable-next-line space-after-comma\n\n            mstore(sub(order,  32), temp1)\n\n            mstore(add(order, 320), temp2)\n\n            mstore(add(order, 352), temp3)\n\n        }\n\n        return result;\n",
          "message": "LibOrder.hashOrder uses assembly (TestLibs.sol#328-374)\n\t- TestLibs.sol#353-373\n"
        },
        {
          "name": "pragma",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity 0.4.24;\n",
          "message": "Different versions of Solidity is used in TestLibs.sol:\n\t- Version used: ['0.4.24', 'ABIEncoderV2']\n\t- TestLibs.sol#3 declares pragma solidity0.4.24\n\t- TestLibs.sol#110 declares pragma solidity0.4.24\n\t- TestLibs.sol#185 declares pragma solidity0.4.24\n\t- TestLibs.sol#254 declares pragma solidity0.4.24\n\t- TestLibs.sol#397 declares pragma solidity0.4.24\n\t- TestLibs.sol#451 declares pragma solidity0.4.24\n\t- TestLibs.sol#452 declares pragma experimentalABIEncoderV2\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 461,
          "vulnerability_to_line": 476,
          "vulnerability_code": "    function publicGetPartialAmount(\n\n        uint256 numerator,\n\n        uint256 denominator,\n\n        uint256 target\n\n    )\n\n        public\n\n        pure\n\n        returns (uint256 partialAmount)\n\n    {\n\n        partialAmount = getPartialAmount(\n\n            numerator,\n\n            denominator,\n\n            target\n\n        );\n\n        return partialAmount;\n",
          "message": "TestLibs.publicGetPartialAmount (TestLibs.sol#461-476) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 478,
          "vulnerability_to_line": 493,
          "vulnerability_code": "    function publicIsRoundingError(\n\n        uint256 numerator,\n\n        uint256 denominator,\n\n        uint256 target\n\n    )\n\n        public\n\n        pure\n\n        returns (bool isError)\n\n    {\n\n        isError = isRoundingError(\n\n            numerator,\n\n            denominator,\n\n            target\n\n        );\n\n        return isError;\n",
          "message": "TestLibs.publicIsRoundingError (TestLibs.sol#478-493) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 495,
          "vulnerability_to_line": 502,
          "vulnerability_code": "    function publicGetOrderHash(Order memory order)\n\n        public\n\n        view\n\n        returns (bytes32 orderHash)\n\n    {\n\n        orderHash = getOrderHash(order);\n\n        return orderHash;\n",
          "message": "TestLibs.publicGetOrderHash (TestLibs.sol#495-502) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 504,
          "vulnerability_to_line": 510,
          "vulnerability_code": "    function getOrderSchemaHash()\n\n        public\n\n        pure\n\n        returns (bytes32)\n\n    {\n\n        return EIP712_ORDER_SCHEMA_HASH;\n",
          "message": "TestLibs.getOrderSchemaHash (TestLibs.sol#504-510) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 512,
          "vulnerability_to_line": 518,
          "vulnerability_code": "    function getDomainSeparatorSchemaHash()\n\n        public\n\n        pure\n\n        returns (bytes32)\n\n    {\n\n        return EIP712_DOMAIN_SEPARATOR_SCHEMA_HASH;\n",
          "message": "TestLibs.getDomainSeparatorSchemaHash (TestLibs.sol#512-518) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 520,
          "vulnerability_to_line": 527,
          "vulnerability_code": "    function publicAddFillResults(FillResults memory totalFillResults, FillResults memory singleFillResults)\n\n        public\n\n        pure\n\n        returns (FillResults memory)\n\n    {\n\n        addFillResults(totalFillResults, singleFillResults);\n\n        return totalFillResults;\n",
          "message": "TestLibs.publicAddFillResults (TestLibs.sol#520-527) should be declared external\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 209,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bytes32 public EIP712_DOMAIN_HASH;\n",
          "message": "Variable 'LibEIP712.EIP712_DOMAIN_HASH' (TestLibs.sol#209) is not in mixedCase\n"
        }
      ]
    },
    "smartcheck": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 328,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function hashOrder(Order memory order)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 353,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        }
      ]
    },
    "oyente": {
      "successfull_analysis": true,
      "errors": [
        "exception (IndexError: pop from empty list)"
      ],
      "vulnerability_findings": [
        {
          "name": "Integer Underflow",
          "vulnerability_from_line": 199,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bytes32 public constant EIP712_DOMAIN_SEPARATOR_SCHEMA_HASH = keccak256(abi.encodePacked(\n",
          "message": null
        }
      ]
    },
    "mythril": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "Exception State (SWC 110)",
          "vulnerability_from_line": 487,
          "vulnerability_to_line": null,
          "vulnerability_code": "        isError = isRoundingError(\n",
          "message": "An assertion violation was triggered.\nIt is possible to trigger an assertion violation. Note that Solidity assert() statements should only be used to check invariants. Review the transaction trace generated for this issue and either make sure your program logic is correct, or use require() instead of assert() if your goal is to constrain user inputs or enforce preconditions. Remember to validate inputs from both callers (for instance, via passed arguments) and callees (for instance, via return values).\nClassification: SWC-110"
        },
        {
          "name": "Exception State (SWC 110)",
          "vulnerability_from_line": 130,
          "vulnerability_to_line": null,
          "vulnerability_code": "        partialAmount = safeDiv(\n",
          "message": "An assertion violation was triggered.\nIt is possible to trigger an assertion violation. Note that Solidity assert() statements should only be used to check invariants. Review the transaction trace generated for this issue and either make sure your program logic is correct, or use require() instead of assert() if your goal is to constrain user inputs or enforce preconditions. Remember to validate inputs from both callers (for instance, via passed arguments) and callees (for instance, via return values).\nClassification: SWC-110"
        }
      ]
    },
    "osiris": {
      "successfull_analysis": false,
      "errors": [
        "exception (IndexError: pop from empty list)"
      ],
      "vulnerability_findings": []
    }
  }
}