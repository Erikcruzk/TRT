{
  "smartbugs_completed": true,
  "analyzer_results": {
    "semgrep": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 1197,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor ()\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 1198,
          "vulnerability_to_line": null,
          "vulnerability_code": "        public\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 1199,
          "vulnerability_to_line": null,
          "vulnerability_code": "    {\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 1200,
          "vulnerability_to_line": null,
          "vulnerability_code": "        EIP712_DOMAIN_HASH = keccak256(abi.encode(\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 1201,
          "vulnerability_to_line": null,
          "vulnerability_code": "            EIP712_DOMAIN_SEPARATOR_SCHEMA_HASH,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 1202,
          "vulnerability_to_line": null,
          "vulnerability_code": "            keccak256(bytes(EIP712_DOMAIN_NAME)),\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 1203,
          "vulnerability_to_line": null,
          "vulnerability_code": "            keccak256(bytes(EIP712_DOMAIN_VERSION)),\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 1204,
          "vulnerability_to_line": null,
          "vulnerability_code": "            address(this)\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 1205,
          "vulnerability_to_line": null,
          "vulnerability_code": "        ));\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 1206,
          "vulnerability_to_line": null,
          "vulnerability_code": "    }\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 179,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 180,
          "vulnerability_to_line": null,
          "vulnerability_code": "            from <= to,\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 181,
          "vulnerability_to_line": null,
          "vulnerability_code": "            \"FROM_LESS_THAN_TO_REQUIRED\"\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 182,
          "vulnerability_to_line": null,
          "vulnerability_code": "        );\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 183,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 184,
          "vulnerability_to_line": null,
          "vulnerability_code": "            to < b.length,\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 185,
          "vulnerability_to_line": null,
          "vulnerability_code": "            \"TO_LESS_THAN_LENGTH_REQUIRED\"\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 186,
          "vulnerability_to_line": null,
          "vulnerability_code": "        );\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 212,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 213,
          "vulnerability_to_line": null,
          "vulnerability_code": "            from <= to,\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 214,
          "vulnerability_to_line": null,
          "vulnerability_code": "            \"FROM_LESS_THAN_TO_REQUIRED\"\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 215,
          "vulnerability_to_line": null,
          "vulnerability_code": "        );\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 216,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 217,
          "vulnerability_to_line": null,
          "vulnerability_code": "            to < b.length,\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 218,
          "vulnerability_to_line": null,
          "vulnerability_code": "            \"TO_LESS_THAN_LENGTH_REQUIRED\"\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 219,
          "vulnerability_to_line": null,
          "vulnerability_code": "        );\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 237,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 238,
          "vulnerability_to_line": null,
          "vulnerability_code": "            b.length > 0,\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 239,
          "vulnerability_to_line": null,
          "vulnerability_code": "            \"GREATER_THAN_ZERO_LENGTH_REQUIRED\"\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 240,
          "vulnerability_to_line": null,
          "vulnerability_code": "        );\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 261,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 262,
          "vulnerability_to_line": null,
          "vulnerability_code": "            b.length >= 20,\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 263,
          "vulnerability_to_line": null,
          "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 264,
          "vulnerability_to_line": null,
          "vulnerability_code": "        );\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 307,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 308,
          "vulnerability_to_line": null,
          "vulnerability_code": "            b.length >= index + 20,  // 20 is length of address\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 309,
          "vulnerability_to_line": null,
          "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 310,
          "vulnerability_to_line": null,
          "vulnerability_code": "        );\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 339,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 340,
          "vulnerability_to_line": null,
          "vulnerability_code": "            b.length >= index + 20,  // 20 is length of address\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 341,
          "vulnerability_to_line": null,
          "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 342,
          "vulnerability_to_line": null,
          "vulnerability_code": "        );\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 385,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 386,
          "vulnerability_to_line": null,
          "vulnerability_code": "            b.length >= index + 32,\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 387,
          "vulnerability_to_line": null,
          "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_32_LENGTH_REQUIRED\"\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 388,
          "vulnerability_to_line": null,
          "vulnerability_code": "        );\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 412,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 413,
          "vulnerability_to_line": null,
          "vulnerability_code": "            b.length >= index + 32,\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 414,
          "vulnerability_to_line": null,
          "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_32_LENGTH_REQUIRED\"\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 415,
          "vulnerability_to_line": null,
          "vulnerability_code": "        );\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 468,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 469,
          "vulnerability_to_line": null,
          "vulnerability_code": "            b.length >= index + 4,\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 470,
          "vulnerability_to_line": null,
          "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_4_LENGTH_REQUIRED\"\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 471,
          "vulnerability_to_line": null,
          "vulnerability_code": "        );\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 501,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 502,
          "vulnerability_to_line": null,
          "vulnerability_code": "            b.length >= index + nestedBytesLength,\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 503,
          "vulnerability_to_line": null,
          "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_NESTED_BYTES_LENGTH_REQUIRED\"\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 504,
          "vulnerability_to_line": null,
          "vulnerability_code": "        );\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 527,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 528,
          "vulnerability_to_line": null,
          "vulnerability_code": "            b.length >= index + 32 + input.length,  // 32 bytes to store length\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 529,
          "vulnerability_to_line": null,
          "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_NESTED_BYTES_LENGTH_REQUIRED\"\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 530,
          "vulnerability_to_line": null,
          "vulnerability_code": "        );\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 552,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 553,
          "vulnerability_to_line": null,
          "vulnerability_code": "            dest.length >= sourceLen,\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 554,
          "vulnerability_to_line": null,
          "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_SOURCE_BYTES_LENGTH_REQUIRED\"\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 555,
          "vulnerability_to_line": null,
          "vulnerability_code": "        );\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 872,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 873,
          "vulnerability_to_line": null,
          "vulnerability_code": "            isValidSignature(\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 874,
          "vulnerability_to_line": null,
          "vulnerability_code": "                hash,\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 875,
          "vulnerability_to_line": null,
          "vulnerability_code": "                signerAddress,\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 876,
          "vulnerability_to_line": null,
          "vulnerability_code": "                signature\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 877,
          "vulnerability_to_line": null,
          "vulnerability_code": "            ),\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 878,
          "vulnerability_to_line": null,
          "vulnerability_code": "            \"INVALID_SIGNATURE\"\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 879,
          "vulnerability_to_line": null,
          "vulnerability_code": "        );\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 915,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 916,
          "vulnerability_to_line": null,
          "vulnerability_code": "            signature.length > 0,\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 917,
          "vulnerability_to_line": null,
          "vulnerability_code": "            \"LENGTH_GREATER_THAN_0_REQUIRED\"\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 918,
          "vulnerability_to_line": null,
          "vulnerability_code": "        );\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 922,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 923,
          "vulnerability_to_line": null,
          "vulnerability_code": "            signatureTypeRaw < uint8(SignatureType.NSignatureTypes),\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 924,
          "vulnerability_to_line": null,
          "vulnerability_code": "            \"SIGNATURE_UNSUPPORTED\"\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 925,
          "vulnerability_to_line": null,
          "vulnerability_code": "        );\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 942,
          "vulnerability_to_line": null,
          "vulnerability_code": "            revert(\"SIGNATURE_ILLEGAL\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 949,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 950,
          "vulnerability_to_line": null,
          "vulnerability_code": "                signature.length == 0,\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 951,
          "vulnerability_to_line": null,
          "vulnerability_code": "                \"LENGTH_0_REQUIRED\"\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 952,
          "vulnerability_to_line": null,
          "vulnerability_code": "            );\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 958,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 959,
          "vulnerability_to_line": null,
          "vulnerability_code": "                signature.length == 65,\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 960,
          "vulnerability_to_line": null,
          "vulnerability_code": "                \"LENGTH_65_REQUIRED\"\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 961,
          "vulnerability_to_line": null,
          "vulnerability_code": "            );\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 971,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 972,
          "vulnerability_to_line": null,
          "vulnerability_code": "                signature.length == 65,\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 973,
          "vulnerability_to_line": null,
          "vulnerability_code": "                \"LENGTH_65_REQUIRED\"\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 974,
          "vulnerability_to_line": null,
          "vulnerability_code": "            );\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 999,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1000,
          "vulnerability_to_line": null,
          "vulnerability_code": "                signature.length == 0,\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1001,
          "vulnerability_to_line": null,
          "vulnerability_code": "                \"LENGTH_0_REQUIRED\"\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1002,
          "vulnerability_to_line": null,
          "vulnerability_code": "            );\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1049,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1050,
          "vulnerability_to_line": null,
          "vulnerability_code": "                signature.length == 65,\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1051,
          "vulnerability_to_line": null,
          "vulnerability_code": "                \"LENGTH_65_REQUIRED\"\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1052,
          "vulnerability_to_line": null,
          "vulnerability_code": "            );\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1074,
          "vulnerability_to_line": null,
          "vulnerability_code": "        revert(\"SIGNATURE_UNSUPPORTED\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1280,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1281,
          "vulnerability_to_line": null,
          "vulnerability_code": "            currentContextAddress == address(0),\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1282,
          "vulnerability_to_line": null,
          "vulnerability_code": "            \"REENTRANCY_ILLEGAL\"\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1283,
          "vulnerability_to_line": null,
          "vulnerability_code": "        );\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1292,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1293,
          "vulnerability_to_line": null,
          "vulnerability_code": "            !transactions[transactionHash],\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1294,
          "vulnerability_to_line": null,
          "vulnerability_code": "            \"INVALID_TX_HASH\"\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1295,
          "vulnerability_to_line": null,
          "vulnerability_code": "        );\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1300,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1301,
          "vulnerability_to_line": null,
          "vulnerability_code": "                isValidSignature(\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1302,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    transactionHash,\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1303,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    signerAddress,\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1304,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    signature\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1305,
          "vulnerability_to_line": null,
          "vulnerability_code": "                ),\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1306,
          "vulnerability_to_line": null,
          "vulnerability_code": "                \"INVALID_TX_SIGNATURE\"\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1307,
          "vulnerability_to_line": null,
          "vulnerability_code": "            );\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1315,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1316,
          "vulnerability_to_line": null,
          "vulnerability_code": "            address(this).delegatecall(data),\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1317,
          "vulnerability_to_line": null,
          "vulnerability_code": "            \"FAILED_EXECUTION\"\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1318,
          "vulnerability_to_line": null,
          "vulnerability_code": "        );\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 237,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 238,
          "vulnerability_to_line": null,
          "vulnerability_code": "            b.length > 0,\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 239,
          "vulnerability_to_line": null,
          "vulnerability_code": "            \"GREATER_THAN_ZERO_LENGTH_REQUIRED\"\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 240,
          "vulnerability_to_line": null,
          "vulnerability_code": "        );\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 261,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 262,
          "vulnerability_to_line": null,
          "vulnerability_code": "            b.length >= 20,\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 263,
          "vulnerability_to_line": null,
          "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 264,
          "vulnerability_to_line": null,
          "vulnerability_code": "        );\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 307,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 308,
          "vulnerability_to_line": null,
          "vulnerability_code": "            b.length >= index + 20,  // 20 is length of address\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 309,
          "vulnerability_to_line": null,
          "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 310,
          "vulnerability_to_line": null,
          "vulnerability_code": "        );\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 339,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 340,
          "vulnerability_to_line": null,
          "vulnerability_code": "            b.length >= index + 20,  // 20 is length of address\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 341,
          "vulnerability_to_line": null,
          "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 342,
          "vulnerability_to_line": null,
          "vulnerability_code": "        );\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 385,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 386,
          "vulnerability_to_line": null,
          "vulnerability_code": "            b.length >= index + 32,\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 387,
          "vulnerability_to_line": null,
          "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_32_LENGTH_REQUIRED\"\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 388,
          "vulnerability_to_line": null,
          "vulnerability_code": "        );\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 412,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 413,
          "vulnerability_to_line": null,
          "vulnerability_code": "            b.length >= index + 32,\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 414,
          "vulnerability_to_line": null,
          "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_32_LENGTH_REQUIRED\"\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 415,
          "vulnerability_to_line": null,
          "vulnerability_code": "        );\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 468,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 469,
          "vulnerability_to_line": null,
          "vulnerability_code": "            b.length >= index + 4,\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 470,
          "vulnerability_to_line": null,
          "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_4_LENGTH_REQUIRED\"\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 471,
          "vulnerability_to_line": null,
          "vulnerability_code": "        );\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 501,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 502,
          "vulnerability_to_line": null,
          "vulnerability_code": "            b.length >= index + nestedBytesLength,\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 503,
          "vulnerability_to_line": null,
          "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_NESTED_BYTES_LENGTH_REQUIRED\"\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 504,
          "vulnerability_to_line": null,
          "vulnerability_code": "        );\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 527,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 528,
          "vulnerability_to_line": null,
          "vulnerability_code": "            b.length >= index + 32 + input.length,  // 32 bytes to store length\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 529,
          "vulnerability_to_line": null,
          "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_NESTED_BYTES_LENGTH_REQUIRED\"\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 530,
          "vulnerability_to_line": null,
          "vulnerability_code": "        );\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 552,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 553,
          "vulnerability_to_line": null,
          "vulnerability_code": "            dest.length >= sourceLen,\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 554,
          "vulnerability_to_line": null,
          "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_SOURCE_BYTES_LENGTH_REQUIRED\"\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 555,
          "vulnerability_to_line": null,
          "vulnerability_code": "        );\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        }
      ]
    },
    "slither": {
      "successfull_analysis": true,
      "errors": [
        "EXIT_CODE_31"
      ],
      "vulnerability_findings": [
        {
          "name": "constant-function",
          "vulnerability_from_line": 33,
          "vulnerability_to_line": 42,
          "vulnerability_code": "    function rawAddress(bytes memory input)\n\n        internal\n\n        pure\n\n        returns (uint256 memoryAddress)\n\n    {\n\n        assembly {\n\n            memoryAddress := input\n\n        }\n\n        return memoryAddress;\n",
          "message": "LibBytes.rawAddress (TestSignatureValidator.sol#33-42) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 47,
          "vulnerability_to_line": 56,
          "vulnerability_code": "    function contentAddress(bytes memory input)\n\n        internal\n\n        pure\n\n        returns (uint256 memoryAddress)\n\n    {\n\n        assembly {\n\n            memoryAddress := add(input, 32)\n\n        }\n\n        return memoryAddress;\n",
          "message": "LibBytes.contentAddress (TestSignatureValidator.sol#47-56) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 62,
          "vulnerability_to_line": 163,
          "vulnerability_code": "    function memCopy(\n\n        uint256 dest,\n\n        uint256 source,\n\n        uint256 length\n\n    )\n\n        internal\n\n        pure\n\n    {\n\n        if (length < 32) {\n\n            // Handle a partial word by reading destination and masking\n\n            // off the bits we are interested in.\n\n            // This correctly handles overlap, zero lengths and source == dest\n\n            assembly {\n\n                let mask := sub(exp(256, sub(32, length)), 1)\n\n                let s := and(mload(source), not(mask))\n\n                let d := and(mload(dest), mask)\n\n                mstore(dest, or(s, d))\n\n            }\n\n        } else {\n\n            // Skip the O(length) loop when source == dest.\n\n            if (source == dest) {\n\n                return;\n\n            }\n\n\n\n            // For large copies we copy whole words at a time. The final\n\n            // word is aligned to the end of the range (instead of after the\n\n            // previous) to handle partial words. So a copy will look like this:\n\n            //\n\n            //  ####\n\n            //      ####\n\n            //          ####\n\n            //            ####\n\n            //\n\n            // We handle overlap in the source and destination range by\n\n            // changing the copying direction. This prevents us from\n\n            // overwriting parts of source that we still need to copy.\n\n            //\n\n            // This correctly handles source == dest\n\n            //\n\n            if (source > dest) {\n\n                assembly {\n\n                    // We subtract 32 from `sEnd` and `dEnd` because it\n\n                    // is easier to compare with in the loop, and these\n\n                    // are also the addresses we need for copying the\n\n                    // last bytes.\n\n                    length := sub(length, 32)\n\n                    let sEnd := add(source, length)\n\n                    let dEnd := add(dest, length)\n\n\n\n                    // Remember the last 32 bytes of source\n\n                    // This needs to be done here and not after the loop\n\n                    // because we may have overwritten the last bytes in\n\n                    // source already due to overlap.\n\n                    let last := mload(sEnd)\n\n\n\n                    // Copy whole words front to back\n\n                    // Note: the first check is always true,\n\n                    // this could have been a do-while loop.\n\n                    // solhint-disable-next-line no-empty-blocks\n\n                    for {} lt(source, sEnd) {} {\n\n                        mstore(dest, mload(source))\n\n                        source := add(source, 32)\n\n                        dest := add(dest, 32)\n\n                    }\n\n                    \n\n                    // Write the last 32 bytes\n\n                    mstore(dEnd, last)\n\n                }\n\n            } else {\n\n                assembly {\n\n                    // We subtract 32 from `sEnd` and `dEnd` because those\n\n                    // are the starting points when copying a word at the end.\n\n                    length := sub(length, 32)\n\n                    let sEnd := add(source, length)\n\n                    let dEnd := add(dest, length)\n\n\n\n                    // Remember the first 32 bytes of source\n\n                    // This needs to be done here and not after the loop\n\n                    // because we may have overwritten the first bytes in\n\n                    // source already due to overlap.\n\n                    let first := mload(source)\n\n\n\n                    // Copy whole words back to front\n\n                    // We use a signed comparisson here to allow dEnd to become\n\n                    // negative (happens when source and dest < 32). Valid\n\n                    // addresses in local memory will never be larger than\n\n                    // 2**255, so they can be safely re-interpreted as signed.\n\n                    // Note: the first check is always true,\n\n                    // this could have been a do-while loop.\n\n                    // solhint-disable-next-line no-empty-blocks\n\n                    for {} slt(dest, dEnd) {} {\n\n                        mstore(dEnd, mload(sEnd))\n\n                        sEnd := sub(sEnd, 32)\n\n                        dEnd := sub(dEnd, 32)\n\n                    }\n\n                    \n\n                    // Write the first 32 bytes\n\n                    mstore(dest, first)\n\n                }\n\n            }\n\n        }\n",
          "message": "LibBytes.memCopy (TestSignatureValidator.sol#62-163) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 203,
          "vulnerability_to_line": 227,
          "vulnerability_code": "    function sliceDestructive(\n\n        bytes memory b,\n\n        uint256 from,\n\n        uint256 to\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory result)\n\n    {\n\n        require(\n\n            from <= to,\n\n            \"FROM_LESS_THAN_TO_REQUIRED\"\n\n        );\n\n        require(\n\n            to < b.length,\n\n            \"TO_LESS_THAN_LENGTH_REQUIRED\"\n\n        );\n\n        \n\n        // Create a new bytes structure around [from, to) in-place.\n\n        assembly {\n\n            result := add(b, from)\n\n            mstore(result, sub(to, from))\n\n        }\n\n        return result;\n",
          "message": "LibBytes.sliceDestructive (TestSignatureValidator.sol#203-227) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 232,
          "vulnerability_to_line": 251,
          "vulnerability_code": "    function popLastByte(bytes memory b)\n\n        internal\n\n        pure\n\n        returns (bytes1 result)\n\n    {\n\n        require(\n\n            b.length > 0,\n\n            \"GREATER_THAN_ZERO_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Store last byte.\n\n        result = b[b.length - 1];\n\n\n\n        assembly {\n\n            // Decrement length of byte array.\n\n            let newLen := sub(mload(b), 1)\n\n            mstore(b, newLen)\n\n        }\n\n        return result;\n",
          "message": "LibBytes.popLastByte (TestSignatureValidator.sol#232-251) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 256,
          "vulnerability_to_line": 275,
          "vulnerability_code": "    function popLast20Bytes(bytes memory b)\n\n        internal\n\n        pure\n\n        returns (address result)\n\n    {\n\n        require(\n\n            b.length >= 20,\n\n            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Store last 20 bytes.\n\n        result = readAddress(b, b.length - 20);\n\n\n\n        assembly {\n\n            // Subtract 20 from byte array length.\n\n            let newLen := sub(mload(b), 20)\n\n            mstore(b, newLen)\n\n        }\n\n        return result;\n",
          "message": "LibBytes.popLast20Bytes (TestSignatureValidator.sol#256-275) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 299,
          "vulnerability_to_line": 325,
          "vulnerability_code": "    function readAddress(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (address result)\n\n    {\n\n        require(\n\n            b.length >= index + 20,  // 20 is length of address\n\n            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Add offset to index:\n\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\n\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\n\n        index += 20;\n\n\n\n        // Read address from array memory\n\n        assembly {\n\n            // 1. Add index to address of bytes array\n\n            // 2. Load 32-byte word from memory\n\n            // 3. Apply 20-byte mask to obtain address\n\n            result := and(mload(add(b, index)), 0xffffffffffffffffffffffffffffffffffffffff)\n\n        }\n\n        return result;\n",
          "message": "LibBytes.readAddress (TestSignatureValidator.sol#299-325) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 331,
          "vulnerability_to_line": 371,
          "vulnerability_code": "    function writeAddress(\n\n        bytes memory b,\n\n        uint256 index,\n\n        address input\n\n    )\n\n        internal\n\n        pure\n\n    {\n\n        require(\n\n            b.length >= index + 20,  // 20 is length of address\n\n            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Add offset to index:\n\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\n\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\n\n        index += 20;\n\n\n\n        // Store address into array memory\n\n        assembly {\n\n            // The address occupies 20 bytes and mstore stores 32 bytes.\n\n            // First fetch the 32-byte word where we'll be storing the address, then\n\n            // apply a mask so we have only the bytes in the word that the address will not occupy.\n\n            // Then combine these bytes with the address and store the 32 bytes back to memory with mstore.\n\n\n\n            // 1. Add index to address of bytes array\n\n            // 2. Load 32-byte word from memory\n\n            // 3. Apply 12-byte mask to obtain extra bytes occupying word of memory where we'll store the address\n\n            let neighbors := and(\n\n                mload(add(b, index)),\n\n                0xffffffffffffffffffffffff0000000000000000000000000000000000000000\n\n            )\n\n            \n\n            // Make sure input address is clean.\n\n            // (Solidity does not guarantee this)\n\n            input := and(input, 0xffffffffffffffffffffffffffffffffffffffff)\n\n\n\n            // Store the neighbors and address into memory\n\n            mstore(add(b, index), xor(input, neighbors))\n\n        }\n",
          "message": "LibBytes.writeAddress (TestSignatureValidator.sol#331-371) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 377,
          "vulnerability_to_line": 398,
          "vulnerability_code": "    function readBytes32(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes32 result)\n\n    {\n\n        require(\n\n            b.length >= index + 32,\n\n            \"GREATER_OR_EQUAL_TO_32_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Arrays are prefixed by a 256 bit length parameter\n\n        index += 32;\n\n\n\n        // Read the bytes32 from array memory\n\n        assembly {\n\n            result := mload(add(b, index))\n\n        }\n\n        return result;\n",
          "message": "LibBytes.readBytes32 (TestSignatureValidator.sol#377-398) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 404,
          "vulnerability_to_line": 424,
          "vulnerability_code": "    function writeBytes32(\n\n        bytes memory b,\n\n        uint256 index,\n\n        bytes32 input\n\n    )\n\n        internal\n\n        pure\n\n    {\n\n        require(\n\n            b.length >= index + 32,\n\n            \"GREATER_OR_EQUAL_TO_32_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Arrays are prefixed by a 256 bit length parameter\n\n        index += 32;\n\n\n\n        // Read the bytes32 from array memory\n\n        assembly {\n\n            mstore(add(b, index), input)\n\n        }\n",
          "message": "LibBytes.writeBytes32 (TestSignatureValidator.sol#404-424) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 460,
          "vulnerability_to_line": 479,
          "vulnerability_code": "    function readBytes4(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes4 result)\n\n    {\n\n        require(\n\n            b.length >= index + 4,\n\n            \"GREATER_OR_EQUAL_TO_4_LENGTH_REQUIRED\"\n\n        );\n\n        assembly {\n\n            result := mload(add(b, 32))\n\n            // Solidity does not require us to clean the trailing bytes.\n\n            // We do it anyway\n\n            result := and(result, 0xFFFFFFFF00000000000000000000000000000000000000000000000000000000)\n\n        }\n\n        return result;\n",
          "message": "LibBytes.readBytes4 (TestSignatureValidator.sol#460-479) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 487,
          "vulnerability_to_line": 511,
          "vulnerability_code": "    function readBytesWithLength(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory result)\n\n    {\n\n        // Read length of nested bytes\n\n        uint256 nestedBytesLength = readUint256(b, index);\n\n        index += 32;\n\n\n\n        // Assert length of <b> is valid, given\n\n        // length of nested bytes\n\n        require(\n\n            b.length >= index + nestedBytesLength,\n\n            \"GREATER_OR_EQUAL_TO_NESTED_BYTES_LENGTH_REQUIRED\"\n\n        );\n\n        \n\n        // Return a pointer to the byte array as it exists inside `b`\n\n        assembly {\n\n            result := add(b, index)\n\n        }\n\n        return result;\n",
          "message": "LibBytes.readBytesWithLength (TestSignatureValidator.sol#487-511) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 1331,
          "vulnerability_to_line": 1361,
          "vulnerability_code": "    function hashZeroExTransaction(\n\n        uint256 salt,\n\n        address signerAddress,\n\n        bytes memory data\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes32 result)\n\n    {\n\n        bytes32 schemaHash = EIP712_ZEROEX_TRANSACTION_SCHEMA_HASH;\n\n        bytes32 dataHash = keccak256(data);\n\n\n\n        // Assembly for more efficiently computing:\n\n        // keccak256(abi.encode(\n\n        //     EIP712_ZEROEX_TRANSACTION_SCHEMA_HASH,\n\n        //     salt,\n\n        //     signerAddress,\n\n        //     keccak256(data)\n\n        // ));\n\n\n\n        assembly {\n\n            let memPtr := mload(64)\n\n            mstore(memPtr, schemaHash)\n\n            mstore(add(memPtr, 32), salt)\n\n            mstore(add(memPtr, 64), and(signerAddress, 0xffffffffffffffffffffffffffffffffffffffff))\n\n            mstore(add(memPtr, 96), dataHash)\n\n            result := keccak256(memPtr, 128)\n\n        }\n\n\n\n        return result;\n",
          "message": "MixinTransactions.hashZeroExTransaction (TestSignatureValidator.sol#1331-1361) is declared view but contains assembly code\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 1271,
          "vulnerability_to_line": 1324,
          "vulnerability_code": "    function executeTransaction(\n\n        uint256 salt,\n\n        address signerAddress,\n\n        bytes data,\n\n        bytes signature\n\n    )\n\n        external\n\n    {\n\n        // Prevent reentrancy\n\n        require(\n\n            currentContextAddress == address(0),\n\n            \"REENTRANCY_ILLEGAL\"\n\n        );\n\n\n\n        bytes32 transactionHash = hashEIP712Message(hashZeroExTransaction(\n\n            salt,\n\n            signerAddress,\n\n            data\n\n        ));\n\n\n\n        // Validate transaction has not been executed\n\n        require(\n\n            !transactions[transactionHash],\n\n            \"INVALID_TX_HASH\"\n\n        );\n\n\n\n        // Transaction always valid if signer is sender of transaction\n\n        if (signerAddress != msg.sender) {\n\n            // Validate signature\n\n            require(\n\n                isValidSignature(\n\n                    transactionHash,\n\n                    signerAddress,\n\n                    signature\n\n                ),\n\n                \"INVALID_TX_SIGNATURE\"\n\n            );\n\n\n\n            // Set the current transaction signer\n\n            currentContextAddress = signerAddress;\n\n        }\n\n\n\n        // Execute transaction\n\n        transactions[transactionHash] = true;\n\n        require(\n\n            address(this).delegatecall(data),\n\n            \"FAILED_EXECUTION\"\n\n        );\n\n\n\n        // Reset current transaction signer if it was previously updated\n\n        if (signerAddress != msg.sender) {\n\n            currentContextAddress = address(0);\n\n        }\n",
          "message": "Reentrancy in MixinTransactions.executeTransaction (TestSignatureValidator.sol#1271-1324):\n\tExternal calls:\n\t- require(bool,string)(address(this).delegatecall(data),FAILED_EXECUTION) (TestSignatureValidator.sol#1315-1318)\n\tState variables written after the call(s):\n\t- currentContextAddress (TestSignatureValidator.sol#1322)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 864,
          "vulnerability_to_line": 881,
          "vulnerability_code": "    function preSign(\n\n        bytes32 hash,\n\n        address signerAddress,\n\n        bytes signature\n\n    )\n\n        external\n\n    {\n\n        // SWC-Lack of Proper Signature Verification: L52-L59\n\n        require(\n\n            isValidSignature(\n\n                hash,\n\n                signerAddress,\n\n                signature\n\n            ),\n\n            \"INVALID_SIGNATURE\"\n\n        );\n\n        preSigned[hash][signerAddress] = true;\n",
          "message": "Reentrancy in MixinSignatureValidator.preSign (TestSignatureValidator.sol#864-881):\n\tExternal calls:\n\t- require(bool,string)(isValidSignature(hash,signerAddress,signature),INVALID_SIGNATURE) (TestSignatureValidator.sol#872-879)\n\tState variables written after the call(s):\n\t- preSigned (TestSignatureValidator.sol#880)\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 33,
          "vulnerability_to_line": 42,
          "vulnerability_code": "    function rawAddress(bytes memory input)\n\n        internal\n\n        pure\n\n        returns (uint256 memoryAddress)\n\n    {\n\n        assembly {\n\n            memoryAddress := input\n\n        }\n\n        return memoryAddress;\n",
          "message": "LibBytes.rawAddress uses assembly (TestSignatureValidator.sol#33-42)\n\t- TestSignatureValidator.sol#38-41\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 47,
          "vulnerability_to_line": 56,
          "vulnerability_code": "    function contentAddress(bytes memory input)\n\n        internal\n\n        pure\n\n        returns (uint256 memoryAddress)\n\n    {\n\n        assembly {\n\n            memoryAddress := add(input, 32)\n\n        }\n\n        return memoryAddress;\n",
          "message": "LibBytes.contentAddress uses assembly (TestSignatureValidator.sol#47-56)\n\t- TestSignatureValidator.sol#52-55\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 62,
          "vulnerability_to_line": 163,
          "vulnerability_code": "    function memCopy(\n\n        uint256 dest,\n\n        uint256 source,\n\n        uint256 length\n\n    )\n\n        internal\n\n        pure\n\n    {\n\n        if (length < 32) {\n\n            // Handle a partial word by reading destination and masking\n\n            // off the bits we are interested in.\n\n            // This correctly handles overlap, zero lengths and source == dest\n\n            assembly {\n\n                let mask := sub(exp(256, sub(32, length)), 1)\n\n                let s := and(mload(source), not(mask))\n\n                let d := and(mload(dest), mask)\n\n                mstore(dest, or(s, d))\n\n            }\n\n        } else {\n\n            // Skip the O(length) loop when source == dest.\n\n            if (source == dest) {\n\n                return;\n\n            }\n\n\n\n            // For large copies we copy whole words at a time. The final\n\n            // word is aligned to the end of the range (instead of after the\n\n            // previous) to handle partial words. So a copy will look like this:\n\n            //\n\n            //  ####\n\n            //      ####\n\n            //          ####\n\n            //            ####\n\n            //\n\n            // We handle overlap in the source and destination range by\n\n            // changing the copying direction. This prevents us from\n\n            // overwriting parts of source that we still need to copy.\n\n            //\n\n            // This correctly handles source == dest\n\n            //\n\n            if (source > dest) {\n\n                assembly {\n\n                    // We subtract 32 from `sEnd` and `dEnd` because it\n\n                    // is easier to compare with in the loop, and these\n\n                    // are also the addresses we need for copying the\n\n                    // last bytes.\n\n                    length := sub(length, 32)\n\n                    let sEnd := add(source, length)\n\n                    let dEnd := add(dest, length)\n\n\n\n                    // Remember the last 32 bytes of source\n\n                    // This needs to be done here and not after the loop\n\n                    // because we may have overwritten the last bytes in\n\n                    // source already due to overlap.\n\n                    let last := mload(sEnd)\n\n\n\n                    // Copy whole words front to back\n\n                    // Note: the first check is always true,\n\n                    // this could have been a do-while loop.\n\n                    // solhint-disable-next-line no-empty-blocks\n\n                    for {} lt(source, sEnd) {} {\n\n                        mstore(dest, mload(source))\n\n                        source := add(source, 32)\n\n                        dest := add(dest, 32)\n\n                    }\n\n                    \n\n                    // Write the last 32 bytes\n\n                    mstore(dEnd, last)\n\n                }\n\n            } else {\n\n                assembly {\n\n                    // We subtract 32 from `sEnd` and `dEnd` because those\n\n                    // are the starting points when copying a word at the end.\n\n                    length := sub(length, 32)\n\n                    let sEnd := add(source, length)\n\n                    let dEnd := add(dest, length)\n\n\n\n                    // Remember the first 32 bytes of source\n\n                    // This needs to be done here and not after the loop\n\n                    // because we may have overwritten the first bytes in\n\n                    // source already due to overlap.\n\n                    let first := mload(source)\n\n\n\n                    // Copy whole words back to front\n\n                    // We use a signed comparisson here to allow dEnd to become\n\n                    // negative (happens when source and dest < 32). Valid\n\n                    // addresses in local memory will never be larger than\n\n                    // 2**255, so they can be safely re-interpreted as signed.\n\n                    // Note: the first check is always true,\n\n                    // this could have been a do-while loop.\n\n                    // solhint-disable-next-line no-empty-blocks\n\n                    for {} slt(dest, dEnd) {} {\n\n                        mstore(dEnd, mload(sEnd))\n\n                        sEnd := sub(sEnd, 32)\n\n                        dEnd := sub(dEnd, 32)\n\n                    }\n\n                    \n\n                    // Write the first 32 bytes\n\n                    mstore(dest, first)\n\n                }\n\n            }\n\n        }\n",
          "message": "LibBytes.memCopy uses assembly (TestSignatureValidator.sol#62-163)\n\t- TestSignatureValidator.sol#74-80\n\t- TestSignatureValidator.sol#102-130\n\t- TestSignatureValidator.sol#131-161\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 203,
          "vulnerability_to_line": 227,
          "vulnerability_code": "    function sliceDestructive(\n\n        bytes memory b,\n\n        uint256 from,\n\n        uint256 to\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory result)\n\n    {\n\n        require(\n\n            from <= to,\n\n            \"FROM_LESS_THAN_TO_REQUIRED\"\n\n        );\n\n        require(\n\n            to < b.length,\n\n            \"TO_LESS_THAN_LENGTH_REQUIRED\"\n\n        );\n\n        \n\n        // Create a new bytes structure around [from, to) in-place.\n\n        assembly {\n\n            result := add(b, from)\n\n            mstore(result, sub(to, from))\n\n        }\n\n        return result;\n",
          "message": "LibBytes.sliceDestructive uses assembly (TestSignatureValidator.sol#203-227)\n\t- TestSignatureValidator.sol#222-226\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 232,
          "vulnerability_to_line": 251,
          "vulnerability_code": "    function popLastByte(bytes memory b)\n\n        internal\n\n        pure\n\n        returns (bytes1 result)\n\n    {\n\n        require(\n\n            b.length > 0,\n\n            \"GREATER_THAN_ZERO_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Store last byte.\n\n        result = b[b.length - 1];\n\n\n\n        assembly {\n\n            // Decrement length of byte array.\n\n            let newLen := sub(mload(b), 1)\n\n            mstore(b, newLen)\n\n        }\n\n        return result;\n",
          "message": "LibBytes.popLastByte uses assembly (TestSignatureValidator.sol#232-251)\n\t- TestSignatureValidator.sol#245-250\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 256,
          "vulnerability_to_line": 275,
          "vulnerability_code": "    function popLast20Bytes(bytes memory b)\n\n        internal\n\n        pure\n\n        returns (address result)\n\n    {\n\n        require(\n\n            b.length >= 20,\n\n            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Store last 20 bytes.\n\n        result = readAddress(b, b.length - 20);\n\n\n\n        assembly {\n\n            // Subtract 20 from byte array length.\n\n            let newLen := sub(mload(b), 20)\n\n            mstore(b, newLen)\n\n        }\n\n        return result;\n",
          "message": "LibBytes.popLast20Bytes uses assembly (TestSignatureValidator.sol#256-275)\n\t- TestSignatureValidator.sol#269-274\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 299,
          "vulnerability_to_line": 325,
          "vulnerability_code": "    function readAddress(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (address result)\n\n    {\n\n        require(\n\n            b.length >= index + 20,  // 20 is length of address\n\n            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Add offset to index:\n\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\n\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\n\n        index += 20;\n\n\n\n        // Read address from array memory\n\n        assembly {\n\n            // 1. Add index to address of bytes array\n\n            // 2. Load 32-byte word from memory\n\n            // 3. Apply 20-byte mask to obtain address\n\n            result := and(mload(add(b, index)), 0xffffffffffffffffffffffffffffffffffffffff)\n\n        }\n\n        return result;\n",
          "message": "LibBytes.readAddress uses assembly (TestSignatureValidator.sol#299-325)\n\t- TestSignatureValidator.sol#318-324\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 331,
          "vulnerability_to_line": 371,
          "vulnerability_code": "    function writeAddress(\n\n        bytes memory b,\n\n        uint256 index,\n\n        address input\n\n    )\n\n        internal\n\n        pure\n\n    {\n\n        require(\n\n            b.length >= index + 20,  // 20 is length of address\n\n            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Add offset to index:\n\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\n\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\n\n        index += 20;\n\n\n\n        // Store address into array memory\n\n        assembly {\n\n            // The address occupies 20 bytes and mstore stores 32 bytes.\n\n            // First fetch the 32-byte word where we'll be storing the address, then\n\n            // apply a mask so we have only the bytes in the word that the address will not occupy.\n\n            // Then combine these bytes with the address and store the 32 bytes back to memory with mstore.\n\n\n\n            // 1. Add index to address of bytes array\n\n            // 2. Load 32-byte word from memory\n\n            // 3. Apply 12-byte mask to obtain extra bytes occupying word of memory where we'll store the address\n\n            let neighbors := and(\n\n                mload(add(b, index)),\n\n                0xffffffffffffffffffffffff0000000000000000000000000000000000000000\n\n            )\n\n            \n\n            // Make sure input address is clean.\n\n            // (Solidity does not guarantee this)\n\n            input := and(input, 0xffffffffffffffffffffffffffffffffffffffff)\n\n\n\n            // Store the neighbors and address into memory\n\n            mstore(add(b, index), xor(input, neighbors))\n\n        }\n",
          "message": "LibBytes.writeAddress uses assembly (TestSignatureValidator.sol#331-371)\n\t- TestSignatureValidator.sol#350-371\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 377,
          "vulnerability_to_line": 398,
          "vulnerability_code": "    function readBytes32(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes32 result)\n\n    {\n\n        require(\n\n            b.length >= index + 32,\n\n            \"GREATER_OR_EQUAL_TO_32_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Arrays are prefixed by a 256 bit length parameter\n\n        index += 32;\n\n\n\n        // Read the bytes32 from array memory\n\n        assembly {\n\n            result := mload(add(b, index))\n\n        }\n\n        return result;\n",
          "message": "LibBytes.readBytes32 uses assembly (TestSignatureValidator.sol#377-398)\n\t- TestSignatureValidator.sol#394-397\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 404,
          "vulnerability_to_line": 424,
          "vulnerability_code": "    function writeBytes32(\n\n        bytes memory b,\n\n        uint256 index,\n\n        bytes32 input\n\n    )\n\n        internal\n\n        pure\n\n    {\n\n        require(\n\n            b.length >= index + 32,\n\n            \"GREATER_OR_EQUAL_TO_32_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Arrays are prefixed by a 256 bit length parameter\n\n        index += 32;\n\n\n\n        // Read the bytes32 from array memory\n\n        assembly {\n\n            mstore(add(b, index), input)\n\n        }\n",
          "message": "LibBytes.writeBytes32 uses assembly (TestSignatureValidator.sol#404-424)\n\t- TestSignatureValidator.sol#421-424\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 460,
          "vulnerability_to_line": 479,
          "vulnerability_code": "    function readBytes4(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes4 result)\n\n    {\n\n        require(\n\n            b.length >= index + 4,\n\n            \"GREATER_OR_EQUAL_TO_4_LENGTH_REQUIRED\"\n\n        );\n\n        assembly {\n\n            result := mload(add(b, 32))\n\n            // Solidity does not require us to clean the trailing bytes.\n\n            // We do it anyway\n\n            result := and(result, 0xFFFFFFFF00000000000000000000000000000000000000000000000000000000)\n\n        }\n\n        return result;\n",
          "message": "LibBytes.readBytes4 uses assembly (TestSignatureValidator.sol#460-479)\n\t- TestSignatureValidator.sol#472-478\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 487,
          "vulnerability_to_line": 511,
          "vulnerability_code": "    function readBytesWithLength(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory result)\n\n    {\n\n        // Read length of nested bytes\n\n        uint256 nestedBytesLength = readUint256(b, index);\n\n        index += 32;\n\n\n\n        // Assert length of <b> is valid, given\n\n        // length of nested bytes\n\n        require(\n\n            b.length >= index + nestedBytesLength,\n\n            \"GREATER_OR_EQUAL_TO_NESTED_BYTES_LENGTH_REQUIRED\"\n\n        );\n\n        \n\n        // Return a pointer to the byte array as it exists inside `b`\n\n        assembly {\n\n            result := add(b, index)\n\n        }\n\n        return result;\n",
          "message": "LibBytes.readBytesWithLength uses assembly (TestSignatureValidator.sol#487-511)\n\t- TestSignatureValidator.sol#507-510\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 1331,
          "vulnerability_to_line": 1361,
          "vulnerability_code": "    function hashZeroExTransaction(\n\n        uint256 salt,\n\n        address signerAddress,\n\n        bytes memory data\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes32 result)\n\n    {\n\n        bytes32 schemaHash = EIP712_ZEROEX_TRANSACTION_SCHEMA_HASH;\n\n        bytes32 dataHash = keccak256(data);\n\n\n\n        // Assembly for more efficiently computing:\n\n        // keccak256(abi.encode(\n\n        //     EIP712_ZEROEX_TRANSACTION_SCHEMA_HASH,\n\n        //     salt,\n\n        //     signerAddress,\n\n        //     keccak256(data)\n\n        // ));\n\n\n\n        assembly {\n\n            let memPtr := mload(64)\n\n            mstore(memPtr, schemaHash)\n\n            mstore(add(memPtr, 32), salt)\n\n            mstore(add(memPtr, 64), and(signerAddress, 0xffffffffffffffffffffffffffffffffffffffff))\n\n            mstore(add(memPtr, 96), dataHash)\n\n            result := keccak256(memPtr, 128)\n\n        }\n\n\n\n        return result;\n",
          "message": "MixinTransactions.hashZeroExTransaction uses assembly (TestSignatureValidator.sol#1331-1361)\n\t- TestSignatureValidator.sol#1351-1360\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 1406,
          "vulnerability_to_line": 1421,
          "vulnerability_code": "    function publicIsValidSignature(\n\n        bytes32 hash,\n\n        address signer,\n\n        bytes memory signature\n\n    )\n\n        public\n\n        view\n\n        returns (bool isValid)\n\n    {\n\n        isValid = isValidSignature(\n\n            hash,\n\n            signer,\n\n            signature\n\n        );\n\n        return isValid;\n",
          "message": "TestSignatureValidator.publicIsValidSignature (TestSignatureValidator.sol#1406-1421) should be declared external\n"
        },
        {
          "name": "low-level-calls",
          "vulnerability_from_line": 1271,
          "vulnerability_to_line": 1324,
          "vulnerability_code": "    function executeTransaction(\n\n        uint256 salt,\n\n        address signerAddress,\n\n        bytes data,\n\n        bytes signature\n\n    )\n\n        external\n\n    {\n\n        // Prevent reentrancy\n\n        require(\n\n            currentContextAddress == address(0),\n\n            \"REENTRANCY_ILLEGAL\"\n\n        );\n\n\n\n        bytes32 transactionHash = hashEIP712Message(hashZeroExTransaction(\n\n            salt,\n\n            signerAddress,\n\n            data\n\n        ));\n\n\n\n        // Validate transaction has not been executed\n\n        require(\n\n            !transactions[transactionHash],\n\n            \"INVALID_TX_HASH\"\n\n        );\n\n\n\n        // Transaction always valid if signer is sender of transaction\n\n        if (signerAddress != msg.sender) {\n\n            // Validate signature\n\n            require(\n\n                isValidSignature(\n\n                    transactionHash,\n\n                    signerAddress,\n\n                    signature\n\n                ),\n\n                \"INVALID_TX_SIGNATURE\"\n\n            );\n\n\n\n            // Set the current transaction signer\n\n            currentContextAddress = signerAddress;\n\n        }\n\n\n\n        // Execute transaction\n\n        transactions[transactionHash] = true;\n\n        require(\n\n            address(this).delegatecall(data),\n\n            \"FAILED_EXECUTION\"\n\n        );\n\n\n\n        // Reset current transaction signer if it was previously updated\n\n        if (signerAddress != msg.sender) {\n\n            currentContextAddress = address(0);\n\n        }\n",
          "message": "Low level call in MixinTransactions.executeTransaction (TestSignatureValidator.sol#1271-1324):\n\t-require(bool,string)(address(this).delegatecall(data),FAILED_EXECUTION) TestSignatureValidator.sol#1315-1318\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1195,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bytes32 public EIP712_DOMAIN_HASH;\n",
          "message": "Variable 'LibEIP712.EIP712_DOMAIN_HASH' (TestSignatureValidator.sol#1195) is not in mixedCase\n"
        }
      ]
    },
    "smartcheck": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 1322,
          "vulnerability_to_line": null,
          "vulnerability_code": "            currentContextAddress = address(0);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_REVERT_REQUIRE",
          "vulnerability_from_line": 941,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (signatureType == SignatureType.Illegal) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 33,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function rawAddress(bytes memory input)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 47,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function contentAddress(bytes memory input)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 62,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function memCopy(\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 203,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function sliceDestructive(\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 232,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function popLastByte(bytes memory b)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 256,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function popLast20Bytes(bytes memory b)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 299,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function readAddress(\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 331,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function writeAddress(\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 377,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function readBytes32(\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 404,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function writeBytes32(\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 460,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function readBytes4(\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 487,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function readBytesWithLength(\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 1331,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function hashZeroExTransaction(\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 38,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 52,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 74,
          "vulnerability_to_line": null,
          "vulnerability_code": "            assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 102,
          "vulnerability_to_line": null,
          "vulnerability_code": "                assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 131,
          "vulnerability_to_line": null,
          "vulnerability_code": "                assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 222,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 245,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 269,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 318,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 350,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 394,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 421,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 472,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 507,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 1351,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1107,
          "vulnerability_to_line": null,
          "vulnerability_code": "    string constant ORDER_UNFILLABLE = \"ORDER_UNFILLABLE\";                              // Order cannot be filled.\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1108,
          "vulnerability_to_line": null,
          "vulnerability_code": "    string constant INVALID_MAKER = \"INVALID_MAKER\";                                    // Invalid makerAddress.\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1109,
          "vulnerability_to_line": null,
          "vulnerability_code": "    string constant INVALID_TAKER = \"INVALID_TAKER\";                                    // Invalid takerAddress.\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1110,
          "vulnerability_to_line": null,
          "vulnerability_code": "    string constant INVALID_SENDER = \"INVALID_SENDER\";                                  // Invalid `msg.sender`.\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1111,
          "vulnerability_to_line": null,
          "vulnerability_code": "    string constant INVALID_ORDER_SIGNATURE = \"INVALID_ORDER_SIGNATURE\";                // Signature validation failed. \n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1114,
          "vulnerability_to_line": null,
          "vulnerability_code": "    string constant INVALID_TAKER_AMOUNT = \"INVALID_TAKER_AMOUNT\";                      // takerAssetFillAmount cannot equal 0.\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1115,
          "vulnerability_to_line": null,
          "vulnerability_code": "    string constant ROUNDING_ERROR = \"ROUNDING_ERROR\";                                  // Rounding error greater than 0.1% of takerAssetFillAmount. \n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1118,
          "vulnerability_to_line": null,
          "vulnerability_code": "    string constant INVALID_SIGNATURE = \"INVALID_SIGNATURE\";                            // Signature validation failed. \n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1119,
          "vulnerability_to_line": null,
          "vulnerability_code": "    string constant SIGNATURE_ILLEGAL = \"SIGNATURE_ILLEGAL\";                            // Signature type is illegal.\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1120,
          "vulnerability_to_line": null,
          "vulnerability_code": "    string constant SIGNATURE_UNSUPPORTED = \"SIGNATURE_UNSUPPORTED\";                    // Signature type unsupported.\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1123,
          "vulnerability_to_line": null,
          "vulnerability_code": "    string constant INVALID_NEW_ORDER_EPOCH = \"INVALID_NEW_ORDER_EPOCH\";                // Specified salt must be greater than or equal to existing orderEpoch.\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1126,
          "vulnerability_to_line": null,
          "vulnerability_code": "    string constant COMPLETE_FILL_FAILED = \"COMPLETE_FILL_FAILED\";                      // Desired takerAssetFillAmount could not be completely filled. \n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1129,
          "vulnerability_to_line": null,
          "vulnerability_code": "    string constant NEGATIVE_SPREAD_REQUIRED = \"NEGATIVE_SPREAD_REQUIRED\";              // Matched orders must have a negative spread.\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1132,
          "vulnerability_to_line": null,
          "vulnerability_code": "    string constant REENTRANCY_ILLEGAL = \"REENTRANCY_ILLEGAL\";                          // Recursive reentrancy is not allowed. \n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1133,
          "vulnerability_to_line": null,
          "vulnerability_code": "    string constant INVALID_TX_HASH = \"INVALID_TX_HASH\";                                // Transaction has already been executed. \n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1134,
          "vulnerability_to_line": null,
          "vulnerability_code": "    string constant INVALID_TX_SIGNATURE = \"INVALID_TX_SIGNATURE\";                      // Signature validation failed. \n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1135,
          "vulnerability_to_line": null,
          "vulnerability_code": "    string constant FAILED_EXECUTION = \"FAILED_EXECUTION\";                              // Transaction execution failed. \n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1138,
          "vulnerability_to_line": null,
          "vulnerability_code": "    string constant ASSET_PROXY_ALREADY_EXISTS = \"ASSET_PROXY_ALREADY_EXISTS\";          // AssetProxy with same id already exists.\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1141,
          "vulnerability_to_line": null,
          "vulnerability_code": "    string constant ASSET_PROXY_DOES_NOT_EXIST = \"ASSET_PROXY_DOES_NOT_EXIST\";          // No assetProxy registered at given id.\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1142,
          "vulnerability_to_line": null,
          "vulnerability_code": "    string constant TRANSFER_FAILED = \"TRANSFER_FAILED\";                                // Asset transfer unsuccesful.\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1145,
          "vulnerability_to_line": null,
          "vulnerability_code": "    string constant LENGTH_GREATER_THAN_0_REQUIRED = \"LENGTH_GREATER_THAN_0_REQUIRED\";  // Byte array must have a length greater than 0.\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1146,
          "vulnerability_to_line": null,
          "vulnerability_code": "    string constant LENGTH_GREATER_THAN_3_REQUIRED = \"LENGTH_GREATER_THAN_3_REQUIRED\";  // Byte array must have a length greater than 3.\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1147,
          "vulnerability_to_line": null,
          "vulnerability_code": "    string constant LENGTH_0_REQUIRED = \"LENGTH_0_REQUIRED\";                            // Byte array must have a length of 0.\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1148,
          "vulnerability_to_line": null,
          "vulnerability_code": "    string constant LENGTH_65_REQUIRED = \"LENGTH_65_REQUIRED\";                          // Byte array must have a length of 65.\n",
          "message": null
        }
      ]
    },
    "oyente": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "Integer Overflow",
          "vulnerability_from_line": 1185,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bytes32 public constant EIP712_DOMAIN_SEPARATOR_SCHEMA_HASH = keccak256(abi.encodePacked(\n",
          "message": null
        },
        {
          "name": "Integer Underflow",
          "vulnerability_from_line": 1185,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bytes32 public constant EIP712_DOMAIN_SEPARATOR_SCHEMA_HASH = keccak256(abi.encodePacked(\n",
          "message": null
        },
        {
          "name": "Integer Overflow",
          "vulnerability_from_line": 1185,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bytes32 public constant EIP712_DOMAIN_SEPARATOR_SCHEMA_HASH = keccak256(abi.encodePacked(\n",
          "message": null
        },
        {
          "name": "Integer Underflow",
          "vulnerability_from_line": 1185,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bytes32 public constant EIP712_DOMAIN_SEPARATOR_SCHEMA_HASH = keccak256(abi.encodePacked(\n",
          "message": null
        }
      ]
    },
    "mythril": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": []
    },
    "osiris": {
      "successfull_analysis": true,
      "errors": [
        "SYMBOLIC EXECUTION TIMEOUT"
      ],
      "vulnerability_findings": [
        {
          "name": "Truncation bugs",
          "vulnerability_from_line": 1009,
          "vulnerability_to_line": null,
          "vulnerability_code": "            isValid = IWallet(signerAddress).isValidSignature(hash, signature);\n",
          "message": null
        },
        {
          "name": "Truncation bugs",
          "vulnerability_from_line": 1028,
          "vulnerability_to_line": null,
          "vulnerability_code": "            isValid = IValidator(validatorAddress).isValidSignature(\n",
          "message": null
        }
      ]
    }
  }
}