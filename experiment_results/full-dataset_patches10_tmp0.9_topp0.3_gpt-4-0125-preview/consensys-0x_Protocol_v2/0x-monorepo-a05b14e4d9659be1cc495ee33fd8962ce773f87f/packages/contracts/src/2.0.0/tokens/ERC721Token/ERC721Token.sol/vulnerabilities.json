{
  "smartbugs_completed": true,
  "analyzer_results": {
    "semgrep": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 349,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor (\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 350,
          "vulnerability_to_line": null,
          "vulnerability_code": "        string _name,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 351,
          "vulnerability_to_line": null,
          "vulnerability_code": "        string _symbol)\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 352,
          "vulnerability_to_line": null,
          "vulnerability_code": "        public\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 353,
          "vulnerability_to_line": null,
          "vulnerability_code": "    {\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 354,
          "vulnerability_to_line": null,
          "vulnerability_code": "        name_ = _name;\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 355,
          "vulnerability_to_line": null,
          "vulnerability_code": "        symbol_ = _symbol;\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 356,
          "vulnerability_to_line": null,
          "vulnerability_code": "    }\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 201,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 202,
          "vulnerability_to_line": null,
          "vulnerability_code": "            c / a == b,\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 203,
          "vulnerability_to_line": null,
          "vulnerability_code": "            \"UINT256_OVERFLOW\"\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 204,
          "vulnerability_to_line": null,
          "vulnerability_code": "        );\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 222,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 223,
          "vulnerability_to_line": null,
          "vulnerability_code": "            b <= a,\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 224,
          "vulnerability_to_line": null,
          "vulnerability_code": "            \"UINT256_UNDERFLOW\"\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 225,
          "vulnerability_to_line": null,
          "vulnerability_code": "        );\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 235,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 236,
          "vulnerability_to_line": null,
          "vulnerability_code": "            c >= a,\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 237,
          "vulnerability_to_line": null,
          "vulnerability_code": "            \"UINT256_OVERFLOW\"\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 238,
          "vulnerability_to_line": null,
          "vulnerability_code": "        );\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        }
      ]
    },
    "slither": {
      "successfull_analysis": true,
      "errors": [
        "EXIT_CODE_59"
      ],
      "vulnerability_findings": [
        {
          "name": "constant-function",
          "vulnerability_from_line": 665,
          "vulnerability_to_line": 679,
          "vulnerability_code": "    function isContract(address addr)\n\n        internal\n\n        view\n\n        returns (bool)\n\n    {\n\n        uint256 size;\n\n        // XXX Currently there is no better way to check if there is a contract in an address\n\n        // than to check the size of the code at that address.\n\n        // See https://ethereum.stackexchange.com/a/14016/36603\n\n        // for more details about how this works.\n\n        // TODO Check this again before the Serenity release, because all addresses will be\n\n        // contracts then.\n\n        assembly { size := extcodesize(addr) }  // solium-disable-line security/no-inline-assembly\n\n        return size > 0;\n",
          "message": "ERC721Token.isContract (ERC721Token.sol#665-679) is declared view but contains assembly code\n"
        },
        {
          "name": "erc20-interface",
          "vulnerability_from_line": 36,
          "vulnerability_to_line": 120,
          "vulnerability_code": "contract IERC721Token {\n\n    string internal name_;\n\n    string internal symbol_;\n\n\n\n    event Transfer(\n\n        address indexed _from,\n\n        address indexed _to,\n\n        uint256 _tokenId\n\n    );\n\n\n\n    event Approval(\n\n        address indexed _owner,\n\n        address indexed _approved,\n\n        uint256 _tokenId\n\n    );\n\n\n\n    event ApprovalForAll(\n\n        address indexed _owner,\n\n        address indexed _operator,\n\n        bool _approved\n\n    );\n\n\n\n    function name()\n\n        public\n\n        view\n\n        returns (string);\n\n\n\n    function symbol()\n\n        public\n\n        view\n\n        returns (string);\n\n\n\n    function balanceOf(address _owner)\n\n        public\n\n        view\n\n        returns (uint256 _balance);\n\n\n\n    function ownerOf(uint256 _tokenId)\n\n        public\n\n        view\n\n        returns (address _owner);\n\n\n\n    function exists(uint256 _tokenId)\n\n        public\n\n        view\n\n        returns (bool _exists);\n\n\n\n    function approve(address _to, uint256 _tokenId)\n\n        public;\n\n\n\n    function getApproved(uint256 _tokenId)\n\n        public\n\n        view\n\n        returns (address _operator);\n\n\n\n    function setApprovalForAll(address _operator, bool _approved)\n\n        public;\n\n\n\n    function isApprovedForAll(address _owner, address _operator)\n\n        public\n\n        view\n\n        returns (bool);\n\n\n\n    function transferFrom(\n\n        address _from,\n\n        address _to,\n\n        uint256 _tokenId\n\n    )\n\n        public;\n\n\n\n    function safeTransferFrom(\n\n        address _from,\n\n        address _to,\n\n        uint256 _tokenId\n\n    )\n\n        public;\n\n\n\n    function safeTransferFrom(\n\n        address _from,\n\n        address _to,\n\n        uint256 _tokenId,\n\n        bytes _data\n\n    )\n\n        public;\n",
          "message": "IERC721Token (ERC721Token.sol#36-120) has incorrect ERC20 function interface(s):\n\t-approve (ERC721Token.sol#83-84)\n\t-transferFrom (ERC721Token.sol#99-104)\n"
        },
        {
          "name": "erc20-interface",
          "vulnerability_from_line": 311,
          "vulnerability_to_line": 680,
          "vulnerability_code": "contract ERC721Token is\n\n    IERC721Token,\n\n    SafeMath\n\n{\n\n    // Equals to `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`\n\n    // which can be also obtained as `ERC721Receiver(0).onERC721Received.selector`\n\n    bytes4 constant internal ERC721_RECEIVED = 0xf0b9e5ba;\n\n\n\n    // Mapping from token ID to owner\n\n    mapping (uint256 => address) internal tokenOwner;\n\n\n\n    // Mapping from token ID to approved address\n\n    mapping (uint256 => address) internal tokenApprovals;\n\n\n\n    // Mapping from owner to number of owned token\n\n    mapping (address => uint256) internal ownedTokensCount;\n\n\n\n    // Mapping from owner to operator approvals\n\n    mapping (address => mapping (address => bool)) internal operatorApprovals;\n\n\n\n    /**\n\n    * @dev Guarantees msg.sender is owner of the given token\n\n    * @param _tokenId uint256 ID of the token to validate its ownership belongs to msg.sender\n\n    */\n\n    modifier onlyOwnerOf(uint256 _tokenId) {\n\n        require(ownerOf(_tokenId) == msg.sender);\n\n        _;\n\n    }\n\n\n\n    /**\n\n    * @dev Checks msg.sender can transfer a token, by being owner, approved, or operator\n\n    * @param _tokenId uint256 ID of the token to validate\n\n    */\n\n    modifier canTransfer(uint256 _tokenId) {\n\n        require(isApprovedOrOwner(msg.sender, _tokenId));\n\n        _;\n\n    }\n\n\n\n    constructor (\n\n        string _name,\n\n        string _symbol)\n\n        public\n\n    {\n\n        name_ = _name;\n\n        symbol_ = _symbol;\n\n    }\n\n\n\n    /**\n\n    * @dev Gets the token name\n\n    * @return string representing the token name\n\n    */\n\n    function name()\n\n        public\n\n        view\n\n        returns (string)\n\n    {\n\n        return name_;\n\n    }\n\n\n\n    /**\n\n    * @dev Gets the token symbol\n\n    * @return string representing the token symbol\n\n    */\n\n    function symbol()\n\n        public\n\n        view\n\n        returns (string)\n\n    {\n\n        return symbol_;\n\n    }\n\n\n\n    /**\n\n    * @dev Gets the balance of the specified address\n\n    * @param _owner address to query the balance of\n\n    * @return uint256 representing the amount owned by the passed address\n\n    */\n\n    function balanceOf(address _owner)\n\n        public\n\n        view\n\n        returns (uint256)\n\n    {\n\n        require(_owner != address(0));\n\n        return ownedTokensCount[_owner];\n\n    }\n\n\n\n    /**\n\n    * @dev Gets the owner of the specified token ID\n\n    * @param _tokenId uint256 ID of the token to query the owner of\n\n    * @return owner address currently marked as the owner of the given token ID\n\n    */\n\n    function ownerOf(uint256 _tokenId)\n\n        public\n\n        view\n\n        returns (address)\n\n    {\n\n        address owner = tokenOwner[_tokenId];\n\n        require(owner != address(0));\n\n        return owner;\n\n    }\n\n\n\n    /**\n\n    * @dev Returns whether the specified token exists\n\n    * @param _tokenId uint256 ID of the token to query the existance of\n\n    * @return whether the token exists\n\n    */\n\n    function exists(uint256 _tokenId)\n\n        public\n\n        view\n\n        returns (bool)\n\n    {\n\n        address owner = tokenOwner[_tokenId];\n\n        return owner != address(0);\n\n    }\n\n\n\n    /**\n\n    * @dev Approves another address to transfer the given token ID\n\n    * @dev The zero address indicates there is no approved address.\n\n    * @dev There can only be one approved address per token at a given time.\n\n    * @dev Can only be called by the token owner or an approved operator.\n\n    * @param _to address to be approved for the given token ID\n\n    * @param _tokenId uint256 ID of the token to be approved\n\n    */\n\n    function approve(address _to, uint256 _tokenId)\n\n        public\n\n    {\n\n        address owner = ownerOf(_tokenId);\n\n        require(_to != owner);\n\n        require(msg.sender == owner || isApprovedForAll(owner, msg.sender));\n\n\n\n        if (getApproved(_tokenId) != address(0) || _to != address(0)) {\n\n            tokenApprovals[_tokenId] = _to;\n\n            emit Approval(owner, _to, _tokenId);\n\n        }\n\n    }\n\n\n\n    /**\n\n    * @dev Gets the approved address for a token ID, or zero if no address set\n\n    * @param _tokenId uint256 ID of the token to query the approval of\n\n    * @return address currently approved for a the given token ID\n\n    */\n\n    function getApproved(uint256 _tokenId)\n\n        public\n\n        view\n\n        returns (address)\n\n    {\n\n        return tokenApprovals[_tokenId];\n\n    }\n\n\n\n    /**\n\n    * @dev Sets or unsets the approval of a given operator\n\n    * @dev An operator is allowed to transfer all tokens of the sender on their behalf\n\n    * @param _to operator address to set the approval\n\n    * @param _approved representing the status of the approval to be set\n\n    */\n\n    function setApprovalForAll(address _to, bool _approved)\n\n        public\n\n    {\n\n        require(_to != msg.sender);\n\n        operatorApprovals[msg.sender][_to] = _approved;\n\n        emit ApprovalForAll(msg.sender, _to, _approved);\n\n    }\n\n\n\n    /**\n\n    * @dev Tells whether an operator is approved by a given owner\n\n    * @param _owner owner address which you want to query the approval of\n\n    * @param _operator operator address which you want to query the approval of\n\n    * @return bool whether the given operator is approved by the given owner\n\n    */\n\n    function isApprovedForAll(address _owner, address _operator)\n\n        public\n\n        view\n\n        returns (bool)\n\n    {\n\n        return operatorApprovals[_owner][_operator];\n\n    }\n\n\n\n    /**\n\n    * @dev Transfers the ownership of a given token ID to another address\n\n    * @dev Usage of this method is discouraged, use `safeTransferFrom` whenever possible\n\n    * @dev Requires the msg sender to be the owner, approved, or operator\n\n    * @param _from current owner of the token\n\n    * @param _to address to receive the ownership of the given token ID\n\n    * @param _tokenId uint256 ID of the token to be transferred\n\n    */\n\n    function transferFrom(address _from, address _to, uint256 _tokenId)\n\n        public\n\n        canTransfer(_tokenId)\n\n    {\n\n        require(_from != address(0));\n\n        require(_to != address(0));\n\n\n\n        clearApproval(_from, _tokenId);\n\n        removeTokenFrom(_from, _tokenId);\n\n        addTokenTo(_to, _tokenId);\n\n\n\n        emit Transfer(_from, _to, _tokenId);\n\n    }\n\n\n\n    /**\n\n    * @dev Safely transfers the ownership of a given token ID to another address\n\n    * @dev If the target address is a contract, it must implement `onERC721Received`,\n\n    *  which is called upon a safe transfer, and return the magic value\n\n    *  `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`; otherwise,\n\n    *  the transfer is reverted.\n\n    * @dev Requires the msg sender to be the owner, approved, or operator\n\n    * @param _from current owner of the token\n\n    * @param _to address to receive the ownership of the given token ID\n\n    * @param _tokenId uint256 ID of the token to be transferred\n\n    */\n\n    function safeTransferFrom(\n\n        address _from,\n\n        address _to,\n\n        uint256 _tokenId)\n\n        public\n\n        canTransfer(_tokenId)\n\n    {\n\n        // solium-disable-next-line arg-overflow\n\n        safeTransferFrom(_from, _to, _tokenId, \"\");\n\n    }\n\n\n\n    /**\n\n    * @dev Safely transfers the ownership of a given token ID to another address\n\n    * @dev If the target address is a contract, it must implement `onERC721Received`,\n\n    *  which is called upon a safe transfer, and return the magic value\n\n    *  `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`; otherwise,\n\n    *  the transfer is reverted.\n\n    * @dev Requires the msg sender to be the owner, approved, or operator\n\n    * @param _from current owner of the token\n\n    * @param _to address to receive the ownership of the given token ID\n\n    * @param _tokenId uint256 ID of the token to be transferred\n\n    * @param _data bytes data to send along with a safe transfer check\n\n    */\n\n    function safeTransferFrom(\n\n        address _from,\n\n        address _to,\n\n        uint256 _tokenId,\n\n        bytes _data)\n\n        public\n\n        canTransfer(_tokenId)\n\n    {\n\n        transferFrom(_from, _to, _tokenId);\n\n        // solium-disable-next-line arg-overflow\n\n        require(checkAndCallSafeTransfer(_from, _to, _tokenId, _data));\n\n    }\n\n\n\n    /**\n\n    * @dev Returns whether the given spender can transfer a given token ID\n\n    * @param _spender address of the spender to query\n\n    * @param _tokenId uint256 ID of the token to be transferred\n\n    * @return bool whether the msg.sender is approved for the given token ID,\n\n    *  is an operator of the owner, or is the owner of the token\n\n    */\n\n    function isApprovedOrOwner(address _spender, uint256 _tokenId)\n\n        internal\n\n        view\n\n        returns (bool)\n\n    {\n\n        address owner = ownerOf(_tokenId);\n\n        return _spender == owner || getApproved(_tokenId) == _spender || isApprovedForAll(owner, _spender);\n\n    }\n\n\n\n    /**\n\n    * @dev Internal function to mint a new token\n\n    * @dev Reverts if the given token ID already exists\n\n    * @param _to The address that will own the minted token\n\n    * @param _tokenId uint256 ID of the token to be minted by the msg.sender\n\n    */\n\n    function _mint(address _to, uint256 _tokenId)\n\n        internal\n\n    {\n\n        require(_to != address(0));\n\n        addTokenTo(_to, _tokenId);\n\n        emit Transfer(address(0), _to, _tokenId);\n\n    }\n\n\n\n    /**\n\n    * @dev Internal function to burn a specific token\n\n    * @dev Reverts if the token does not exist\n\n    * @param _tokenId uint256 ID of the token being burned by the msg.sender\n\n    */\n\n    function _burn(address _owner, uint256 _tokenId)\n\n        internal\n\n    {\n\n        clearApproval(_owner, _tokenId);\n\n        removeTokenFrom(_owner, _tokenId);\n\n        emit Transfer(_owner, address(0), _tokenId);\n\n    }\n\n\n\n    /**\n\n    * @dev Internal function to clear current approval of a given token ID\n\n    * @dev Reverts if the given address is not indeed the owner of the token\n\n    * @param _owner owner of the token\n\n    * @param _tokenId uint256 ID of the token to be transferred\n\n    */\n\n    function clearApproval(address _owner, uint256 _tokenId)\n\n        internal\n\n    {\n\n        require(ownerOf(_tokenId) == _owner);\n\n        if (tokenApprovals[_tokenId] != address(0)) {\n\n            tokenApprovals[_tokenId] = address(0);\n\n            emit Approval(_owner, address(0), _tokenId);\n\n        }\n\n    }\n\n\n\n    /**\n\n    * @dev Internal function to add a token ID to the list of a given address\n\n    * @param _to address representing the new owner of the given token ID\n\n    * @param _tokenId uint256 ID of the token to be added to the tokens list of the given address\n\n    */\n\n    function addTokenTo(address _to, uint256 _tokenId)\n\n        internal\n\n    {\n\n        require(tokenOwner[_tokenId] == address(0));\n\n        tokenOwner[_tokenId] = _to;\n\n        ownedTokensCount[_to] = safeAdd(ownedTokensCount[_to], 1);\n\n    }\n\n\n\n    /**\n\n    * @dev Internal function to remove a token ID from the list of a given address\n\n    * @param _from address representing the previous owner of the given token ID\n\n    * @param _tokenId uint256 ID of the token to be removed from the tokens list of the given address\n\n    */\n\n    function removeTokenFrom(address _from, uint256 _tokenId)\n\n        internal\n\n    {\n\n        require(ownerOf(_tokenId) == _from);\n\n        ownedTokensCount[_from] = safeSub(ownedTokensCount[_from], 1);\n\n        tokenOwner[_tokenId] = address(0);\n\n    }\n\n\n\n    /**\n\n    * @dev Internal function to invoke `onERC721Received` on a target address\n\n    * @dev The call is not executed if the target address is not a contract\n\n    * @param _from address representing the previous owner of the given token ID\n\n    * @param _to target address that will receive the tokens\n\n    * @param _tokenId uint256 ID of the token to be transferred\n\n    * @param _data bytes optional data to send along with the call\n\n    * @return whether the call correctly returned the expected magic value\n\n    */\n\n    function checkAndCallSafeTransfer(\n\n        address _from,\n\n        address _to,\n\n        uint256 _tokenId,\n\n        bytes _data)\n\n        internal\n\n        returns (bool)\n\n    {\n\n        if (!isContract(_to)) {\n\n            return true;\n\n        }\n\n        bytes4 retval = IERC721Receiver(_to).onERC721Received(_from, _tokenId, _data);\n\n        return (retval == ERC721_RECEIVED);\n\n    }\n\n\n\n    function isContract(address addr)\n\n        internal\n\n        view\n\n        returns (bool)\n\n    {\n\n        uint256 size;\n\n        // XXX Currently there is no better way to check if there is a contract in an address\n\n        // than to check the size of the code at that address.\n\n        // See https://ethereum.stackexchange.com/a/14016/36603\n\n        // for more details about how this works.\n\n        // TODO Check this again before the Serenity release, because all addresses will be\n\n        // contracts then.\n\n        assembly { size := extcodesize(addr) }  // solium-disable-line security/no-inline-assembly\n\n        return size > 0;\n\n    }\n",
          "message": "ERC721Token (ERC721Token.sol#311-680) has incorrect ERC20 function interface(s):\n\t-approve (ERC721Token.sol#433-444)\n\t-transferFrom (ERC721Token.sol#495-507)\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 665,
          "vulnerability_to_line": 679,
          "vulnerability_code": "    function isContract(address addr)\n\n        internal\n\n        view\n\n        returns (bool)\n\n    {\n\n        uint256 size;\n\n        // XXX Currently there is no better way to check if there is a contract in an address\n\n        // than to check the size of the code at that address.\n\n        // See https://ethereum.stackexchange.com/a/14016/36603\n\n        // for more details about how this works.\n\n        // TODO Check this again before the Serenity release, because all addresses will be\n\n        // contracts then.\n\n        assembly { size := extcodesize(addr) }  // solium-disable-line security/no-inline-assembly\n\n        return size > 0;\n",
          "message": "ERC721Token.isContract uses assembly (ERC721Token.sol#665-679)\n\t- ERC721Token.sol#677-678\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 58,
          "vulnerability_to_line": 61,
          "vulnerability_code": "    function name()\n\n        public\n\n        view\n",
          "message": "IERC721Token.name (ERC721Token.sol#58-61) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 362,
          "vulnerability_to_line": 368,
          "vulnerability_code": "    function name()\n\n        public\n\n        view\n\n        returns (string)\n\n    {\n\n        return name_;\n",
          "message": "ERC721Token.name (ERC721Token.sol#362-368) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 374,
          "vulnerability_to_line": 380,
          "vulnerability_code": "    function symbol()\n\n        public\n\n        view\n\n        returns (string)\n\n    {\n\n        return symbol_;\n",
          "message": "ERC721Token.symbol (ERC721Token.sol#374-380) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 63,
          "vulnerability_to_line": 66,
          "vulnerability_code": "    function symbol()\n\n        public\n\n        view\n",
          "message": "IERC721Token.symbol (ERC721Token.sol#63-66) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 387,
          "vulnerability_to_line": 394,
          "vulnerability_code": "    function balanceOf(address _owner)\n\n        public\n\n        view\n\n        returns (uint256)\n\n    {\n\n        require(_owner != address(0));\n\n        return ownedTokensCount[_owner];\n",
          "message": "ERC721Token.balanceOf (ERC721Token.sol#387-394) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 68,
          "vulnerability_to_line": 71,
          "vulnerability_code": "    function balanceOf(address _owner)\n\n        public\n\n        view\n",
          "message": "IERC721Token.balanceOf (ERC721Token.sol#68-71) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 416,
          "vulnerability_to_line": 423,
          "vulnerability_code": "    function exists(uint256 _tokenId)\n\n        public\n\n        view\n\n        returns (bool)\n\n    {\n\n        address owner = tokenOwner[_tokenId];\n\n        return owner != address(0);\n",
          "message": "ERC721Token.exists (ERC721Token.sol#416-423) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 78,
          "vulnerability_to_line": 81,
          "vulnerability_code": "    function exists(uint256 _tokenId)\n\n        public\n\n        view\n",
          "message": "IERC721Token.exists (ERC721Token.sol#78-81) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 83,
          "vulnerability_to_line": 84,
          "vulnerability_code": "    function approve(address _to, uint256 _tokenId)\n",
          "message": "IERC721Token.approve (ERC721Token.sol#83-84) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 433,
          "vulnerability_to_line": 444,
          "vulnerability_code": "    function approve(address _to, uint256 _tokenId)\n\n        public\n\n    {\n\n        address owner = ownerOf(_tokenId);\n\n        require(_to != owner);\n\n        require(msg.sender == owner || isApprovedForAll(owner, msg.sender));\n\n\n\n        if (getApproved(_tokenId) != address(0) || _to != address(0)) {\n\n            tokenApprovals[_tokenId] = _to;\n\n            emit Approval(owner, _to, _tokenId);\n\n        }\n",
          "message": "ERC721Token.approve (ERC721Token.sol#433-444) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 91,
          "vulnerability_to_line": 92,
          "vulnerability_code": "    function setApprovalForAll(address _operator, bool _approved)\n",
          "message": "IERC721Token.setApprovalForAll (ERC721Token.sol#91-92) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 465,
          "vulnerability_to_line": 471,
          "vulnerability_code": "    function setApprovalForAll(address _to, bool _approved)\n\n        public\n\n    {\n\n        require(_to != msg.sender);\n\n        operatorApprovals[msg.sender][_to] = _approved;\n\n        emit ApprovalForAll(msg.sender, _to, _approved);\n",
          "message": "ERC721Token.setApprovalForAll (ERC721Token.sol#465-471) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 106,
          "vulnerability_to_line": 111,
          "vulnerability_code": "    function safeTransferFrom(\n\n        address _from,\n\n        address _to,\n\n        uint256 _tokenId\n\n    )\n",
          "message": "IERC721Token.safeTransferFrom (ERC721Token.sol#106-111) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 520,
          "vulnerability_to_line": 529,
          "vulnerability_code": "    function safeTransferFrom(\n\n        address _from,\n\n        address _to,\n\n        uint256 _tokenId)\n\n        public\n\n        canTransfer(_tokenId)\n\n    {\n\n        // solium-disable-next-line arg-overflow\n\n        safeTransferFrom(_from, _to, _tokenId, \"\");\n",
          "message": "ERC721Token.safeTransferFrom (ERC721Token.sol#520-529) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 178,
          "vulnerability_to_line": 183,
          "vulnerability_code": "    function onERC721Received(\n\n        address _from,\n\n        uint256 _tokenId,\n\n        bytes _data)\n\n        public\n",
          "message": "IERC721Receiver.onERC721Received (ERC721Token.sol#178-183) should be declared external\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 387,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function balanceOf(address _owner)\n",
          "message": "Parameter '_owner' of ERC721Token.balanceOf (ERC721Token.sol#387) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 401,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function ownerOf(uint256 _tokenId)\n",
          "message": "Parameter '_tokenId' of ERC721Token.ownerOf (ERC721Token.sol#401) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 416,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function exists(uint256 _tokenId)\n",
          "message": "Parameter '_tokenId' of ERC721Token.exists (ERC721Token.sol#416) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 433,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function approve(address _to, uint256 _tokenId)\n",
          "message": "Parameter '_to' of ERC721Token.approve (ERC721Token.sol#433) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 433,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function approve(address _to, uint256 _tokenId)\n",
          "message": "Parameter '_tokenId' of ERC721Token.approve (ERC721Token.sol#433) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 451,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getApproved(uint256 _tokenId)\n",
          "message": "Parameter '_tokenId' of ERC721Token.getApproved (ERC721Token.sol#451) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 465,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setApprovalForAll(address _to, bool _approved)\n",
          "message": "Parameter '_to' of ERC721Token.setApprovalForAll (ERC721Token.sol#465) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 465,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setApprovalForAll(address _to, bool _approved)\n",
          "message": "Parameter '_approved' of ERC721Token.setApprovalForAll (ERC721Token.sol#465) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 479,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function isApprovedForAll(address _owner, address _operator)\n",
          "message": "Parameter '_owner' of ERC721Token.isApprovedForAll (ERC721Token.sol#479) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 479,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function isApprovedForAll(address _owner, address _operator)\n",
          "message": "Parameter '_operator' of ERC721Token.isApprovedForAll (ERC721Token.sol#479) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 495,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function transferFrom(address _from, address _to, uint256 _tokenId)\n",
          "message": "Parameter '_from' of ERC721Token.transferFrom (ERC721Token.sol#495) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 495,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function transferFrom(address _from, address _to, uint256 _tokenId)\n",
          "message": "Parameter '_to' of ERC721Token.transferFrom (ERC721Token.sol#495) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 495,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function transferFrom(address _from, address _to, uint256 _tokenId)\n",
          "message": "Parameter '_tokenId' of ERC721Token.transferFrom (ERC721Token.sol#495) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 521,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address _from,\n",
          "message": "Parameter '_from' of ERC721Token.safeTransferFrom (ERC721Token.sol#521) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 522,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address _to,\n",
          "message": "Parameter '_to' of ERC721Token.safeTransferFrom (ERC721Token.sol#522) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 523,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint256 _tokenId)\n",
          "message": "Parameter '_tokenId' of ERC721Token.safeTransferFrom (ERC721Token.sol#523) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 544,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address _from,\n",
          "message": "Parameter '_from' of ERC721Token.safeTransferFrom (ERC721Token.sol#544) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 545,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address _to,\n",
          "message": "Parameter '_to' of ERC721Token.safeTransferFrom (ERC721Token.sol#545) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 546,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint256 _tokenId,\n",
          "message": "Parameter '_tokenId' of ERC721Token.safeTransferFrom (ERC721Token.sol#546) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 547,
          "vulnerability_to_line": null,
          "vulnerability_code": "        bytes _data)\n",
          "message": "Parameter '_data' of ERC721Token.safeTransferFrom (ERC721Token.sol#547) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 350,
          "vulnerability_to_line": null,
          "vulnerability_code": "        string _name,\n",
          "message": "Parameter '_name' of ERC721Token. (ERC721Token.sol#350) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 351,
          "vulnerability_to_line": null,
          "vulnerability_code": "        string _symbol)\n",
          "message": "Parameter '_symbol' of ERC721Token. (ERC721Token.sol#351) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 563,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function isApprovedOrOwner(address _spender, uint256 _tokenId)\n",
          "message": "Parameter '_spender' of ERC721Token.isApprovedOrOwner (ERC721Token.sol#563) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 563,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function isApprovedOrOwner(address _spender, uint256 _tokenId)\n",
          "message": "Parameter '_tokenId' of ERC721Token.isApprovedOrOwner (ERC721Token.sol#563) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 578,
          "vulnerability_to_line": 584,
          "vulnerability_code": "    function _mint(address _to, uint256 _tokenId)\n\n        internal\n\n    {\n\n        require(_to != address(0));\n\n        addTokenTo(_to, _tokenId);\n\n        emit Transfer(address(0), _to, _tokenId);\n",
          "message": "Function 'ERC721Token._mint' (ERC721Token.sol#578-584) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 578,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _mint(address _to, uint256 _tokenId)\n",
          "message": "Parameter '_to' of ERC721Token._mint (ERC721Token.sol#578) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 578,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _mint(address _to, uint256 _tokenId)\n",
          "message": "Parameter '_tokenId' of ERC721Token._mint (ERC721Token.sol#578) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 591,
          "vulnerability_to_line": 597,
          "vulnerability_code": "    function _burn(address _owner, uint256 _tokenId)\n\n        internal\n\n    {\n\n        clearApproval(_owner, _tokenId);\n\n        removeTokenFrom(_owner, _tokenId);\n\n        emit Transfer(_owner, address(0), _tokenId);\n",
          "message": "Function 'ERC721Token._burn' (ERC721Token.sol#591-597) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 591,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _burn(address _owner, uint256 _tokenId)\n",
          "message": "Parameter '_owner' of ERC721Token._burn (ERC721Token.sol#591) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 591,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _burn(address _owner, uint256 _tokenId)\n",
          "message": "Parameter '_tokenId' of ERC721Token._burn (ERC721Token.sol#591) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 605,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function clearApproval(address _owner, uint256 _tokenId)\n",
          "message": "Parameter '_owner' of ERC721Token.clearApproval (ERC721Token.sol#605) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 605,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function clearApproval(address _owner, uint256 _tokenId)\n",
          "message": "Parameter '_tokenId' of ERC721Token.clearApproval (ERC721Token.sol#605) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 620,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function addTokenTo(address _to, uint256 _tokenId)\n",
          "message": "Parameter '_to' of ERC721Token.addTokenTo (ERC721Token.sol#620) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 620,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function addTokenTo(address _to, uint256 _tokenId)\n",
          "message": "Parameter '_tokenId' of ERC721Token.addTokenTo (ERC721Token.sol#620) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 633,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function removeTokenFrom(address _from, uint256 _tokenId)\n",
          "message": "Parameter '_from' of ERC721Token.removeTokenFrom (ERC721Token.sol#633) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 633,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function removeTokenFrom(address _from, uint256 _tokenId)\n",
          "message": "Parameter '_tokenId' of ERC721Token.removeTokenFrom (ERC721Token.sol#633) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 651,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address _from,\n",
          "message": "Parameter '_from' of ERC721Token.checkAndCallSafeTransfer (ERC721Token.sol#651) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 652,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address _to,\n",
          "message": "Parameter '_to' of ERC721Token.checkAndCallSafeTransfer (ERC721Token.sol#652) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 653,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint256 _tokenId,\n",
          "message": "Parameter '_tokenId' of ERC721Token.checkAndCallSafeTransfer (ERC721Token.sol#653) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 654,
          "vulnerability_to_line": null,
          "vulnerability_code": "        bytes _data)\n",
          "message": "Parameter '_data' of ERC721Token.checkAndCallSafeTransfer (ERC721Token.sol#654) is not in mixedCase\n"
        }
      ]
    },
    "smartcheck": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 164,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bytes4 constant internal ERC721_RECEIVED = 0xf0b9e5ba;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 317,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bytes4 constant internal ERC721_RECEIVED = 0xf0b9e5ba;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 610,
          "vulnerability_to_line": null,
          "vulnerability_code": "            tokenApprovals[_tokenId] = address(0);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 638,
          "vulnerability_to_line": null,
          "vulnerability_code": "        tokenOwner[_tokenId] = address(0);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ERC20_APPROVE",
          "vulnerability_from_line": 433,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function approve(address _to, uint256 _tokenId)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
          "vulnerability_from_line": 665,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function isContract(address addr)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 61,
          "vulnerability_to_line": null,
          "vulnerability_code": "        returns (string);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 66,
          "vulnerability_to_line": null,
          "vulnerability_code": "        returns (string);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 117,
          "vulnerability_to_line": null,
          "vulnerability_code": "        bytes _data\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 181,
          "vulnerability_to_line": null,
          "vulnerability_code": "        bytes _data)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 350,
          "vulnerability_to_line": null,
          "vulnerability_code": "        string _name,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 351,
          "vulnerability_to_line": null,
          "vulnerability_code": "        string _symbol)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 365,
          "vulnerability_to_line": null,
          "vulnerability_code": "        returns (string)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 377,
          "vulnerability_to_line": null,
          "vulnerability_code": "        returns (string)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 547,
          "vulnerability_to_line": null,
          "vulnerability_code": "        bytes _data)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 654,
          "vulnerability_to_line": null,
          "vulnerability_code": "        bytes _data)\n",
          "message": null
        }
      ]
    },
    "oyente": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "Integer Overflow",
          "vulnerability_from_line": 543,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function safeTransferFrom(\n",
          "message": null
        },
        {
          "name": "Integer Underflow",
          "vulnerability_from_line": 367,
          "vulnerability_to_line": null,
          "vulnerability_code": "        return name_;\n",
          "message": null
        }
      ]
    },
    "mythril": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": []
    },
    "osiris": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": []
    }
  }
}