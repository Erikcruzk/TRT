{
  "smartbugs_completed": true,
  "analyzer_results": {
    "semgrep": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 179,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 180,
          "vulnerability_to_line": null,
          "vulnerability_code": "            from <= to,\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 181,
          "vulnerability_to_line": null,
          "vulnerability_code": "            \"FROM_LESS_THAN_TO_REQUIRED\"\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 182,
          "vulnerability_to_line": null,
          "vulnerability_code": "        );\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 183,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 184,
          "vulnerability_to_line": null,
          "vulnerability_code": "            to < b.length,\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 185,
          "vulnerability_to_line": null,
          "vulnerability_code": "            \"TO_LESS_THAN_LENGTH_REQUIRED\"\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 186,
          "vulnerability_to_line": null,
          "vulnerability_code": "        );\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 212,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 213,
          "vulnerability_to_line": null,
          "vulnerability_code": "            from <= to,\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 214,
          "vulnerability_to_line": null,
          "vulnerability_code": "            \"FROM_LESS_THAN_TO_REQUIRED\"\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 215,
          "vulnerability_to_line": null,
          "vulnerability_code": "        );\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 216,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 217,
          "vulnerability_to_line": null,
          "vulnerability_code": "            to < b.length,\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 218,
          "vulnerability_to_line": null,
          "vulnerability_code": "            \"TO_LESS_THAN_LENGTH_REQUIRED\"\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 219,
          "vulnerability_to_line": null,
          "vulnerability_code": "        );\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 237,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 238,
          "vulnerability_to_line": null,
          "vulnerability_code": "            b.length > 0,\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 239,
          "vulnerability_to_line": null,
          "vulnerability_code": "            \"GREATER_THAN_ZERO_LENGTH_REQUIRED\"\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 240,
          "vulnerability_to_line": null,
          "vulnerability_code": "        );\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 261,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 262,
          "vulnerability_to_line": null,
          "vulnerability_code": "            b.length >= 20,\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 263,
          "vulnerability_to_line": null,
          "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 264,
          "vulnerability_to_line": null,
          "vulnerability_code": "        );\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 307,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 308,
          "vulnerability_to_line": null,
          "vulnerability_code": "            b.length >= index + 20,  // 20 is length of address\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 309,
          "vulnerability_to_line": null,
          "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 310,
          "vulnerability_to_line": null,
          "vulnerability_code": "        );\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 339,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 340,
          "vulnerability_to_line": null,
          "vulnerability_code": "            b.length >= index + 20,  // 20 is length of address\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 341,
          "vulnerability_to_line": null,
          "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 342,
          "vulnerability_to_line": null,
          "vulnerability_code": "        );\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 385,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 386,
          "vulnerability_to_line": null,
          "vulnerability_code": "            b.length >= index + 32,\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 387,
          "vulnerability_to_line": null,
          "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_32_LENGTH_REQUIRED\"\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 388,
          "vulnerability_to_line": null,
          "vulnerability_code": "        );\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 412,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 413,
          "vulnerability_to_line": null,
          "vulnerability_code": "            b.length >= index + 32,\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 414,
          "vulnerability_to_line": null,
          "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_32_LENGTH_REQUIRED\"\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 415,
          "vulnerability_to_line": null,
          "vulnerability_code": "        );\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 468,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 469,
          "vulnerability_to_line": null,
          "vulnerability_code": "            b.length >= index + 4,\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 470,
          "vulnerability_to_line": null,
          "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_4_LENGTH_REQUIRED\"\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 471,
          "vulnerability_to_line": null,
          "vulnerability_code": "        );\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 501,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 502,
          "vulnerability_to_line": null,
          "vulnerability_code": "            b.length >= index + nestedBytesLength,\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 503,
          "vulnerability_to_line": null,
          "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_NESTED_BYTES_LENGTH_REQUIRED\"\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 504,
          "vulnerability_to_line": null,
          "vulnerability_code": "        );\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 527,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 528,
          "vulnerability_to_line": null,
          "vulnerability_code": "            b.length >= index + 32 + input.length,  // 32 bytes to store length\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 529,
          "vulnerability_to_line": null,
          "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_NESTED_BYTES_LENGTH_REQUIRED\"\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 530,
          "vulnerability_to_line": null,
          "vulnerability_code": "        );\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 552,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 553,
          "vulnerability_to_line": null,
          "vulnerability_code": "            dest.length >= sourceLen,\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 554,
          "vulnerability_to_line": null,
          "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_SOURCE_BYTES_LENGTH_REQUIRED\"\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 555,
          "vulnerability_to_line": null,
          "vulnerability_code": "        );\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 872,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 873,
          "vulnerability_to_line": null,
          "vulnerability_code": "            isValidSignature(\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 874,
          "vulnerability_to_line": null,
          "vulnerability_code": "                hash,\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 875,
          "vulnerability_to_line": null,
          "vulnerability_code": "                signerAddress,\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 876,
          "vulnerability_to_line": null,
          "vulnerability_code": "                signature\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 877,
          "vulnerability_to_line": null,
          "vulnerability_code": "            ),\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 878,
          "vulnerability_to_line": null,
          "vulnerability_code": "            \"INVALID_SIGNATURE\"\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 879,
          "vulnerability_to_line": null,
          "vulnerability_code": "        );\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 915,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 916,
          "vulnerability_to_line": null,
          "vulnerability_code": "            signature.length > 0,\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 917,
          "vulnerability_to_line": null,
          "vulnerability_code": "            \"LENGTH_GREATER_THAN_0_REQUIRED\"\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 918,
          "vulnerability_to_line": null,
          "vulnerability_code": "        );\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 922,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 923,
          "vulnerability_to_line": null,
          "vulnerability_code": "            signatureTypeRaw < uint8(SignatureType.NSignatureTypes),\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 924,
          "vulnerability_to_line": null,
          "vulnerability_code": "            \"SIGNATURE_UNSUPPORTED\"\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 925,
          "vulnerability_to_line": null,
          "vulnerability_code": "        );\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 942,
          "vulnerability_to_line": null,
          "vulnerability_code": "            revert(\"SIGNATURE_ILLEGAL\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 949,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 950,
          "vulnerability_to_line": null,
          "vulnerability_code": "                signature.length == 0,\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 951,
          "vulnerability_to_line": null,
          "vulnerability_code": "                \"LENGTH_0_REQUIRED\"\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 952,
          "vulnerability_to_line": null,
          "vulnerability_code": "            );\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 958,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 959,
          "vulnerability_to_line": null,
          "vulnerability_code": "                signature.length == 65,\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 960,
          "vulnerability_to_line": null,
          "vulnerability_code": "                \"LENGTH_65_REQUIRED\"\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 961,
          "vulnerability_to_line": null,
          "vulnerability_code": "            );\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 971,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 972,
          "vulnerability_to_line": null,
          "vulnerability_code": "                signature.length == 65,\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 973,
          "vulnerability_to_line": null,
          "vulnerability_code": "                \"LENGTH_65_REQUIRED\"\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 974,
          "vulnerability_to_line": null,
          "vulnerability_code": "            );\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 999,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1000,
          "vulnerability_to_line": null,
          "vulnerability_code": "                signature.length == 0,\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1001,
          "vulnerability_to_line": null,
          "vulnerability_code": "                \"LENGTH_0_REQUIRED\"\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1002,
          "vulnerability_to_line": null,
          "vulnerability_code": "            );\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1049,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1050,
          "vulnerability_to_line": null,
          "vulnerability_code": "                signature.length == 65,\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1051,
          "vulnerability_to_line": null,
          "vulnerability_code": "                \"LENGTH_65_REQUIRED\"\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1052,
          "vulnerability_to_line": null,
          "vulnerability_code": "            );\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1074,
          "vulnerability_to_line": null,
          "vulnerability_code": "        revert(\"SIGNATURE_UNSUPPORTED\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 237,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 238,
          "vulnerability_to_line": null,
          "vulnerability_code": "            b.length > 0,\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 239,
          "vulnerability_to_line": null,
          "vulnerability_code": "            \"GREATER_THAN_ZERO_LENGTH_REQUIRED\"\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 240,
          "vulnerability_to_line": null,
          "vulnerability_code": "        );\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 261,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 262,
          "vulnerability_to_line": null,
          "vulnerability_code": "            b.length >= 20,\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 263,
          "vulnerability_to_line": null,
          "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 264,
          "vulnerability_to_line": null,
          "vulnerability_code": "        );\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 307,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 308,
          "vulnerability_to_line": null,
          "vulnerability_code": "            b.length >= index + 20,  // 20 is length of address\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 309,
          "vulnerability_to_line": null,
          "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 310,
          "vulnerability_to_line": null,
          "vulnerability_code": "        );\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 339,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 340,
          "vulnerability_to_line": null,
          "vulnerability_code": "            b.length >= index + 20,  // 20 is length of address\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 341,
          "vulnerability_to_line": null,
          "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 342,
          "vulnerability_to_line": null,
          "vulnerability_code": "        );\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 385,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 386,
          "vulnerability_to_line": null,
          "vulnerability_code": "            b.length >= index + 32,\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 387,
          "vulnerability_to_line": null,
          "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_32_LENGTH_REQUIRED\"\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 388,
          "vulnerability_to_line": null,
          "vulnerability_code": "        );\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 412,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 413,
          "vulnerability_to_line": null,
          "vulnerability_code": "            b.length >= index + 32,\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 414,
          "vulnerability_to_line": null,
          "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_32_LENGTH_REQUIRED\"\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 415,
          "vulnerability_to_line": null,
          "vulnerability_code": "        );\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 468,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 469,
          "vulnerability_to_line": null,
          "vulnerability_code": "            b.length >= index + 4,\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 470,
          "vulnerability_to_line": null,
          "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_4_LENGTH_REQUIRED\"\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 471,
          "vulnerability_to_line": null,
          "vulnerability_code": "        );\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 501,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 502,
          "vulnerability_to_line": null,
          "vulnerability_code": "            b.length >= index + nestedBytesLength,\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 503,
          "vulnerability_to_line": null,
          "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_NESTED_BYTES_LENGTH_REQUIRED\"\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 504,
          "vulnerability_to_line": null,
          "vulnerability_code": "        );\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 527,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 528,
          "vulnerability_to_line": null,
          "vulnerability_code": "            b.length >= index + 32 + input.length,  // 32 bytes to store length\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 529,
          "vulnerability_to_line": null,
          "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_NESTED_BYTES_LENGTH_REQUIRED\"\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 530,
          "vulnerability_to_line": null,
          "vulnerability_code": "        );\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 552,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 553,
          "vulnerability_to_line": null,
          "vulnerability_code": "            dest.length >= sourceLen,\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 554,
          "vulnerability_to_line": null,
          "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_SOURCE_BYTES_LENGTH_REQUIRED\"\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 555,
          "vulnerability_to_line": null,
          "vulnerability_code": "        );\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        }
      ]
    },
    "slither": {
      "successfull_analysis": true,
      "errors": [
        "EXIT_CODE_25"
      ],
      "vulnerability_findings": [
        {
          "name": "constant-function",
          "vulnerability_from_line": 33,
          "vulnerability_to_line": 42,
          "vulnerability_code": "    function rawAddress(bytes memory input)\n\n        internal\n\n        pure\n\n        returns (uint256 memoryAddress)\n\n    {\n\n        assembly {\n\n            memoryAddress := input\n\n        }\n\n        return memoryAddress;\n",
          "message": "LibBytes.rawAddress (MixinSignatureValidator.sol#33-42) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 47,
          "vulnerability_to_line": 56,
          "vulnerability_code": "    function contentAddress(bytes memory input)\n\n        internal\n\n        pure\n\n        returns (uint256 memoryAddress)\n\n    {\n\n        assembly {\n\n            memoryAddress := add(input, 32)\n\n        }\n\n        return memoryAddress;\n",
          "message": "LibBytes.contentAddress (MixinSignatureValidator.sol#47-56) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 62,
          "vulnerability_to_line": 163,
          "vulnerability_code": "    function memCopy(\n\n        uint256 dest,\n\n        uint256 source,\n\n        uint256 length\n\n    )\n\n        internal\n\n        pure\n\n    {\n\n        if (length < 32) {\n\n            // Handle a partial word by reading destination and masking\n\n            // off the bits we are interested in.\n\n            // This correctly handles overlap, zero lengths and source == dest\n\n            assembly {\n\n                let mask := sub(exp(256, sub(32, length)), 1)\n\n                let s := and(mload(source), not(mask))\n\n                let d := and(mload(dest), mask)\n\n                mstore(dest, or(s, d))\n\n            }\n\n        } else {\n\n            // Skip the O(length) loop when source == dest.\n\n            if (source == dest) {\n\n                return;\n\n            }\n\n\n\n            // For large copies we copy whole words at a time. The final\n\n            // word is aligned to the end of the range (instead of after the\n\n            // previous) to handle partial words. So a copy will look like this:\n\n            //\n\n            //  ####\n\n            //      ####\n\n            //          ####\n\n            //            ####\n\n            //\n\n            // We handle overlap in the source and destination range by\n\n            // changing the copying direction. This prevents us from\n\n            // overwriting parts of source that we still need to copy.\n\n            //\n\n            // This correctly handles source == dest\n\n            //\n\n            if (source > dest) {\n\n                assembly {\n\n                    // We subtract 32 from `sEnd` and `dEnd` because it\n\n                    // is easier to compare with in the loop, and these\n\n                    // are also the addresses we need for copying the\n\n                    // last bytes.\n\n                    length := sub(length, 32)\n\n                    let sEnd := add(source, length)\n\n                    let dEnd := add(dest, length)\n\n\n\n                    // Remember the last 32 bytes of source\n\n                    // This needs to be done here and not after the loop\n\n                    // because we may have overwritten the last bytes in\n\n                    // source already due to overlap.\n\n                    let last := mload(sEnd)\n\n\n\n                    // Copy whole words front to back\n\n                    // Note: the first check is always true,\n\n                    // this could have been a do-while loop.\n\n                    // solhint-disable-next-line no-empty-blocks\n\n                    for {} lt(source, sEnd) {} {\n\n                        mstore(dest, mload(source))\n\n                        source := add(source, 32)\n\n                        dest := add(dest, 32)\n\n                    }\n\n                    \n\n                    // Write the last 32 bytes\n\n                    mstore(dEnd, last)\n\n                }\n\n            } else {\n\n                assembly {\n\n                    // We subtract 32 from `sEnd` and `dEnd` because those\n\n                    // are the starting points when copying a word at the end.\n\n                    length := sub(length, 32)\n\n                    let sEnd := add(source, length)\n\n                    let dEnd := add(dest, length)\n\n\n\n                    // Remember the first 32 bytes of source\n\n                    // This needs to be done here and not after the loop\n\n                    // because we may have overwritten the first bytes in\n\n                    // source already due to overlap.\n\n                    let first := mload(source)\n\n\n\n                    // Copy whole words back to front\n\n                    // We use a signed comparisson here to allow dEnd to become\n\n                    // negative (happens when source and dest < 32). Valid\n\n                    // addresses in local memory will never be larger than\n\n                    // 2**255, so they can be safely re-interpreted as signed.\n\n                    // Note: the first check is always true,\n\n                    // this could have been a do-while loop.\n\n                    // solhint-disable-next-line no-empty-blocks\n\n                    for {} slt(dest, dEnd) {} {\n\n                        mstore(dEnd, mload(sEnd))\n\n                        sEnd := sub(sEnd, 32)\n\n                        dEnd := sub(dEnd, 32)\n\n                    }\n\n                    \n\n                    // Write the first 32 bytes\n\n                    mstore(dest, first)\n\n                }\n\n            }\n\n        }\n",
          "message": "LibBytes.memCopy (MixinSignatureValidator.sol#62-163) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 203,
          "vulnerability_to_line": 227,
          "vulnerability_code": "    function sliceDestructive(\n\n        bytes memory b,\n\n        uint256 from,\n\n        uint256 to\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory result)\n\n    {\n\n        require(\n\n            from <= to,\n\n            \"FROM_LESS_THAN_TO_REQUIRED\"\n\n        );\n\n        require(\n\n            to < b.length,\n\n            \"TO_LESS_THAN_LENGTH_REQUIRED\"\n\n        );\n\n        \n\n        // Create a new bytes structure around [from, to) in-place.\n\n        assembly {\n\n            result := add(b, from)\n\n            mstore(result, sub(to, from))\n\n        }\n\n        return result;\n",
          "message": "LibBytes.sliceDestructive (MixinSignatureValidator.sol#203-227) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 232,
          "vulnerability_to_line": 251,
          "vulnerability_code": "    function popLastByte(bytes memory b)\n\n        internal\n\n        pure\n\n        returns (bytes1 result)\n\n    {\n\n        require(\n\n            b.length > 0,\n\n            \"GREATER_THAN_ZERO_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Store last byte.\n\n        result = b[b.length - 1];\n\n\n\n        assembly {\n\n            // Decrement length of byte array.\n\n            let newLen := sub(mload(b), 1)\n\n            mstore(b, newLen)\n\n        }\n\n        return result;\n",
          "message": "LibBytes.popLastByte (MixinSignatureValidator.sol#232-251) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 256,
          "vulnerability_to_line": 275,
          "vulnerability_code": "    function popLast20Bytes(bytes memory b)\n\n        internal\n\n        pure\n\n        returns (address result)\n\n    {\n\n        require(\n\n            b.length >= 20,\n\n            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Store last 20 bytes.\n\n        result = readAddress(b, b.length - 20);\n\n\n\n        assembly {\n\n            // Subtract 20 from byte array length.\n\n            let newLen := sub(mload(b), 20)\n\n            mstore(b, newLen)\n\n        }\n\n        return result;\n",
          "message": "LibBytes.popLast20Bytes (MixinSignatureValidator.sol#256-275) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 299,
          "vulnerability_to_line": 325,
          "vulnerability_code": "    function readAddress(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (address result)\n\n    {\n\n        require(\n\n            b.length >= index + 20,  // 20 is length of address\n\n            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Add offset to index:\n\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\n\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\n\n        index += 20;\n\n\n\n        // Read address from array memory\n\n        assembly {\n\n            // 1. Add index to address of bytes array\n\n            // 2. Load 32-byte word from memory\n\n            // 3. Apply 20-byte mask to obtain address\n\n            result := and(mload(add(b, index)), 0xffffffffffffffffffffffffffffffffffffffff)\n\n        }\n\n        return result;\n",
          "message": "LibBytes.readAddress (MixinSignatureValidator.sol#299-325) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 331,
          "vulnerability_to_line": 371,
          "vulnerability_code": "    function writeAddress(\n\n        bytes memory b,\n\n        uint256 index,\n\n        address input\n\n    )\n\n        internal\n\n        pure\n\n    {\n\n        require(\n\n            b.length >= index + 20,  // 20 is length of address\n\n            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Add offset to index:\n\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\n\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\n\n        index += 20;\n\n\n\n        // Store address into array memory\n\n        assembly {\n\n            // The address occupies 20 bytes and mstore stores 32 bytes.\n\n            // First fetch the 32-byte word where we'll be storing the address, then\n\n            // apply a mask so we have only the bytes in the word that the address will not occupy.\n\n            // Then combine these bytes with the address and store the 32 bytes back to memory with mstore.\n\n\n\n            // 1. Add index to address of bytes array\n\n            // 2. Load 32-byte word from memory\n\n            // 3. Apply 12-byte mask to obtain extra bytes occupying word of memory where we'll store the address\n\n            let neighbors := and(\n\n                mload(add(b, index)),\n\n                0xffffffffffffffffffffffff0000000000000000000000000000000000000000\n\n            )\n\n            \n\n            // Make sure input address is clean.\n\n            // (Solidity does not guarantee this)\n\n            input := and(input, 0xffffffffffffffffffffffffffffffffffffffff)\n\n\n\n            // Store the neighbors and address into memory\n\n            mstore(add(b, index), xor(input, neighbors))\n\n        }\n",
          "message": "LibBytes.writeAddress (MixinSignatureValidator.sol#331-371) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 377,
          "vulnerability_to_line": 398,
          "vulnerability_code": "    function readBytes32(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes32 result)\n\n    {\n\n        require(\n\n            b.length >= index + 32,\n\n            \"GREATER_OR_EQUAL_TO_32_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Arrays are prefixed by a 256 bit length parameter\n\n        index += 32;\n\n\n\n        // Read the bytes32 from array memory\n\n        assembly {\n\n            result := mload(add(b, index))\n\n        }\n\n        return result;\n",
          "message": "LibBytes.readBytes32 (MixinSignatureValidator.sol#377-398) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 404,
          "vulnerability_to_line": 424,
          "vulnerability_code": "    function writeBytes32(\n\n        bytes memory b,\n\n        uint256 index,\n\n        bytes32 input\n\n    )\n\n        internal\n\n        pure\n\n    {\n\n        require(\n\n            b.length >= index + 32,\n\n            \"GREATER_OR_EQUAL_TO_32_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Arrays are prefixed by a 256 bit length parameter\n\n        index += 32;\n\n\n\n        // Read the bytes32 from array memory\n\n        assembly {\n\n            mstore(add(b, index), input)\n\n        }\n",
          "message": "LibBytes.writeBytes32 (MixinSignatureValidator.sol#404-424) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 460,
          "vulnerability_to_line": 479,
          "vulnerability_code": "    function readBytes4(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes4 result)\n\n    {\n\n        require(\n\n            b.length >= index + 4,\n\n            \"GREATER_OR_EQUAL_TO_4_LENGTH_REQUIRED\"\n\n        );\n\n        assembly {\n\n            result := mload(add(b, 32))\n\n            // Solidity does not require us to clean the trailing bytes.\n\n            // We do it anyway\n\n            result := and(result, 0xFFFFFFFF00000000000000000000000000000000000000000000000000000000)\n\n        }\n\n        return result;\n",
          "message": "LibBytes.readBytes4 (MixinSignatureValidator.sol#460-479) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 487,
          "vulnerability_to_line": 511,
          "vulnerability_code": "    function readBytesWithLength(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory result)\n\n    {\n\n        // Read length of nested bytes\n\n        uint256 nestedBytesLength = readUint256(b, index);\n\n        index += 32;\n\n\n\n        // Assert length of <b> is valid, given\n\n        // length of nested bytes\n\n        require(\n\n            b.length >= index + nestedBytesLength,\n\n            \"GREATER_OR_EQUAL_TO_NESTED_BYTES_LENGTH_REQUIRED\"\n\n        );\n\n        \n\n        // Return a pointer to the byte array as it exists inside `b`\n\n        assembly {\n\n            result := add(b, index)\n\n        }\n\n        return result;\n",
          "message": "LibBytes.readBytesWithLength (MixinSignatureValidator.sol#487-511) is declared view but contains assembly code\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 864,
          "vulnerability_to_line": 881,
          "vulnerability_code": "    function preSign(\n\n        bytes32 hash,\n\n        address signerAddress,\n\n        bytes signature\n\n    )\n\n        external\n\n    {\n\n        // SWC-Lack of Proper Signature Verification: L52-L59\n\n        require(\n\n            isValidSignature(\n\n                hash,\n\n                signerAddress,\n\n                signature\n\n            ),\n\n            \"INVALID_SIGNATURE\"\n\n        );\n\n        preSigned[hash][signerAddress] = true;\n",
          "message": "Reentrancy in MixinSignatureValidator.preSign (MixinSignatureValidator.sol#864-881):\n\tExternal calls:\n\t- require(bool,string)(isValidSignature(hash,signerAddress,signature),INVALID_SIGNATURE) (MixinSignatureValidator.sol#872-879)\n\tState variables written after the call(s):\n\t- preSigned (MixinSignatureValidator.sol#880)\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 33,
          "vulnerability_to_line": 42,
          "vulnerability_code": "    function rawAddress(bytes memory input)\n\n        internal\n\n        pure\n\n        returns (uint256 memoryAddress)\n\n    {\n\n        assembly {\n\n            memoryAddress := input\n\n        }\n\n        return memoryAddress;\n",
          "message": "LibBytes.rawAddress uses assembly (MixinSignatureValidator.sol#33-42)\n\t- MixinSignatureValidator.sol#38-41\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 47,
          "vulnerability_to_line": 56,
          "vulnerability_code": "    function contentAddress(bytes memory input)\n\n        internal\n\n        pure\n\n        returns (uint256 memoryAddress)\n\n    {\n\n        assembly {\n\n            memoryAddress := add(input, 32)\n\n        }\n\n        return memoryAddress;\n",
          "message": "LibBytes.contentAddress uses assembly (MixinSignatureValidator.sol#47-56)\n\t- MixinSignatureValidator.sol#52-55\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 62,
          "vulnerability_to_line": 163,
          "vulnerability_code": "    function memCopy(\n\n        uint256 dest,\n\n        uint256 source,\n\n        uint256 length\n\n    )\n\n        internal\n\n        pure\n\n    {\n\n        if (length < 32) {\n\n            // Handle a partial word by reading destination and masking\n\n            // off the bits we are interested in.\n\n            // This correctly handles overlap, zero lengths and source == dest\n\n            assembly {\n\n                let mask := sub(exp(256, sub(32, length)), 1)\n\n                let s := and(mload(source), not(mask))\n\n                let d := and(mload(dest), mask)\n\n                mstore(dest, or(s, d))\n\n            }\n\n        } else {\n\n            // Skip the O(length) loop when source == dest.\n\n            if (source == dest) {\n\n                return;\n\n            }\n\n\n\n            // For large copies we copy whole words at a time. The final\n\n            // word is aligned to the end of the range (instead of after the\n\n            // previous) to handle partial words. So a copy will look like this:\n\n            //\n\n            //  ####\n\n            //      ####\n\n            //          ####\n\n            //            ####\n\n            //\n\n            // We handle overlap in the source and destination range by\n\n            // changing the copying direction. This prevents us from\n\n            // overwriting parts of source that we still need to copy.\n\n            //\n\n            // This correctly handles source == dest\n\n            //\n\n            if (source > dest) {\n\n                assembly {\n\n                    // We subtract 32 from `sEnd` and `dEnd` because it\n\n                    // is easier to compare with in the loop, and these\n\n                    // are also the addresses we need for copying the\n\n                    // last bytes.\n\n                    length := sub(length, 32)\n\n                    let sEnd := add(source, length)\n\n                    let dEnd := add(dest, length)\n\n\n\n                    // Remember the last 32 bytes of source\n\n                    // This needs to be done here and not after the loop\n\n                    // because we may have overwritten the last bytes in\n\n                    // source already due to overlap.\n\n                    let last := mload(sEnd)\n\n\n\n                    // Copy whole words front to back\n\n                    // Note: the first check is always true,\n\n                    // this could have been a do-while loop.\n\n                    // solhint-disable-next-line no-empty-blocks\n\n                    for {} lt(source, sEnd) {} {\n\n                        mstore(dest, mload(source))\n\n                        source := add(source, 32)\n\n                        dest := add(dest, 32)\n\n                    }\n\n                    \n\n                    // Write the last 32 bytes\n\n                    mstore(dEnd, last)\n\n                }\n\n            } else {\n\n                assembly {\n\n                    // We subtract 32 from `sEnd` and `dEnd` because those\n\n                    // are the starting points when copying a word at the end.\n\n                    length := sub(length, 32)\n\n                    let sEnd := add(source, length)\n\n                    let dEnd := add(dest, length)\n\n\n\n                    // Remember the first 32 bytes of source\n\n                    // This needs to be done here and not after the loop\n\n                    // because we may have overwritten the first bytes in\n\n                    // source already due to overlap.\n\n                    let first := mload(source)\n\n\n\n                    // Copy whole words back to front\n\n                    // We use a signed comparisson here to allow dEnd to become\n\n                    // negative (happens when source and dest < 32). Valid\n\n                    // addresses in local memory will never be larger than\n\n                    // 2**255, so they can be safely re-interpreted as signed.\n\n                    // Note: the first check is always true,\n\n                    // this could have been a do-while loop.\n\n                    // solhint-disable-next-line no-empty-blocks\n\n                    for {} slt(dest, dEnd) {} {\n\n                        mstore(dEnd, mload(sEnd))\n\n                        sEnd := sub(sEnd, 32)\n\n                        dEnd := sub(dEnd, 32)\n\n                    }\n\n                    \n\n                    // Write the first 32 bytes\n\n                    mstore(dest, first)\n\n                }\n\n            }\n\n        }\n",
          "message": "LibBytes.memCopy uses assembly (MixinSignatureValidator.sol#62-163)\n\t- MixinSignatureValidator.sol#74-80\n\t- MixinSignatureValidator.sol#102-130\n\t- MixinSignatureValidator.sol#131-161\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 203,
          "vulnerability_to_line": 227,
          "vulnerability_code": "    function sliceDestructive(\n\n        bytes memory b,\n\n        uint256 from,\n\n        uint256 to\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory result)\n\n    {\n\n        require(\n\n            from <= to,\n\n            \"FROM_LESS_THAN_TO_REQUIRED\"\n\n        );\n\n        require(\n\n            to < b.length,\n\n            \"TO_LESS_THAN_LENGTH_REQUIRED\"\n\n        );\n\n        \n\n        // Create a new bytes structure around [from, to) in-place.\n\n        assembly {\n\n            result := add(b, from)\n\n            mstore(result, sub(to, from))\n\n        }\n\n        return result;\n",
          "message": "LibBytes.sliceDestructive uses assembly (MixinSignatureValidator.sol#203-227)\n\t- MixinSignatureValidator.sol#222-226\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 232,
          "vulnerability_to_line": 251,
          "vulnerability_code": "    function popLastByte(bytes memory b)\n\n        internal\n\n        pure\n\n        returns (bytes1 result)\n\n    {\n\n        require(\n\n            b.length > 0,\n\n            \"GREATER_THAN_ZERO_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Store last byte.\n\n        result = b[b.length - 1];\n\n\n\n        assembly {\n\n            // Decrement length of byte array.\n\n            let newLen := sub(mload(b), 1)\n\n            mstore(b, newLen)\n\n        }\n\n        return result;\n",
          "message": "LibBytes.popLastByte uses assembly (MixinSignatureValidator.sol#232-251)\n\t- MixinSignatureValidator.sol#245-250\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 256,
          "vulnerability_to_line": 275,
          "vulnerability_code": "    function popLast20Bytes(bytes memory b)\n\n        internal\n\n        pure\n\n        returns (address result)\n\n    {\n\n        require(\n\n            b.length >= 20,\n\n            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Store last 20 bytes.\n\n        result = readAddress(b, b.length - 20);\n\n\n\n        assembly {\n\n            // Subtract 20 from byte array length.\n\n            let newLen := sub(mload(b), 20)\n\n            mstore(b, newLen)\n\n        }\n\n        return result;\n",
          "message": "LibBytes.popLast20Bytes uses assembly (MixinSignatureValidator.sol#256-275)\n\t- MixinSignatureValidator.sol#269-274\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 299,
          "vulnerability_to_line": 325,
          "vulnerability_code": "    function readAddress(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (address result)\n\n    {\n\n        require(\n\n            b.length >= index + 20,  // 20 is length of address\n\n            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Add offset to index:\n\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\n\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\n\n        index += 20;\n\n\n\n        // Read address from array memory\n\n        assembly {\n\n            // 1. Add index to address of bytes array\n\n            // 2. Load 32-byte word from memory\n\n            // 3. Apply 20-byte mask to obtain address\n\n            result := and(mload(add(b, index)), 0xffffffffffffffffffffffffffffffffffffffff)\n\n        }\n\n        return result;\n",
          "message": "LibBytes.readAddress uses assembly (MixinSignatureValidator.sol#299-325)\n\t- MixinSignatureValidator.sol#318-324\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 331,
          "vulnerability_to_line": 371,
          "vulnerability_code": "    function writeAddress(\n\n        bytes memory b,\n\n        uint256 index,\n\n        address input\n\n    )\n\n        internal\n\n        pure\n\n    {\n\n        require(\n\n            b.length >= index + 20,  // 20 is length of address\n\n            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Add offset to index:\n\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\n\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\n\n        index += 20;\n\n\n\n        // Store address into array memory\n\n        assembly {\n\n            // The address occupies 20 bytes and mstore stores 32 bytes.\n\n            // First fetch the 32-byte word where we'll be storing the address, then\n\n            // apply a mask so we have only the bytes in the word that the address will not occupy.\n\n            // Then combine these bytes with the address and store the 32 bytes back to memory with mstore.\n\n\n\n            // 1. Add index to address of bytes array\n\n            // 2. Load 32-byte word from memory\n\n            // 3. Apply 12-byte mask to obtain extra bytes occupying word of memory where we'll store the address\n\n            let neighbors := and(\n\n                mload(add(b, index)),\n\n                0xffffffffffffffffffffffff0000000000000000000000000000000000000000\n\n            )\n\n            \n\n            // Make sure input address is clean.\n\n            // (Solidity does not guarantee this)\n\n            input := and(input, 0xffffffffffffffffffffffffffffffffffffffff)\n\n\n\n            // Store the neighbors and address into memory\n\n            mstore(add(b, index), xor(input, neighbors))\n\n        }\n",
          "message": "LibBytes.writeAddress uses assembly (MixinSignatureValidator.sol#331-371)\n\t- MixinSignatureValidator.sol#350-371\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 377,
          "vulnerability_to_line": 398,
          "vulnerability_code": "    function readBytes32(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes32 result)\n\n    {\n\n        require(\n\n            b.length >= index + 32,\n\n            \"GREATER_OR_EQUAL_TO_32_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Arrays are prefixed by a 256 bit length parameter\n\n        index += 32;\n\n\n\n        // Read the bytes32 from array memory\n\n        assembly {\n\n            result := mload(add(b, index))\n\n        }\n\n        return result;\n",
          "message": "LibBytes.readBytes32 uses assembly (MixinSignatureValidator.sol#377-398)\n\t- MixinSignatureValidator.sol#394-397\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 404,
          "vulnerability_to_line": 424,
          "vulnerability_code": "    function writeBytes32(\n\n        bytes memory b,\n\n        uint256 index,\n\n        bytes32 input\n\n    )\n\n        internal\n\n        pure\n\n    {\n\n        require(\n\n            b.length >= index + 32,\n\n            \"GREATER_OR_EQUAL_TO_32_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Arrays are prefixed by a 256 bit length parameter\n\n        index += 32;\n\n\n\n        // Read the bytes32 from array memory\n\n        assembly {\n\n            mstore(add(b, index), input)\n\n        }\n",
          "message": "LibBytes.writeBytes32 uses assembly (MixinSignatureValidator.sol#404-424)\n\t- MixinSignatureValidator.sol#421-424\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 460,
          "vulnerability_to_line": 479,
          "vulnerability_code": "    function readBytes4(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes4 result)\n\n    {\n\n        require(\n\n            b.length >= index + 4,\n\n            \"GREATER_OR_EQUAL_TO_4_LENGTH_REQUIRED\"\n\n        );\n\n        assembly {\n\n            result := mload(add(b, 32))\n\n            // Solidity does not require us to clean the trailing bytes.\n\n            // We do it anyway\n\n            result := and(result, 0xFFFFFFFF00000000000000000000000000000000000000000000000000000000)\n\n        }\n\n        return result;\n",
          "message": "LibBytes.readBytes4 uses assembly (MixinSignatureValidator.sol#460-479)\n\t- MixinSignatureValidator.sol#472-478\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 487,
          "vulnerability_to_line": 511,
          "vulnerability_code": "    function readBytesWithLength(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory result)\n\n    {\n\n        // Read length of nested bytes\n\n        uint256 nestedBytesLength = readUint256(b, index);\n\n        index += 32;\n\n\n\n        // Assert length of <b> is valid, given\n\n        // length of nested bytes\n\n        require(\n\n            b.length >= index + nestedBytesLength,\n\n            \"GREATER_OR_EQUAL_TO_NESTED_BYTES_LENGTH_REQUIRED\"\n\n        );\n\n        \n\n        // Return a pointer to the byte array as it exists inside `b`\n\n        assembly {\n\n            result := add(b, index)\n\n        }\n\n        return result;\n",
          "message": "LibBytes.readBytesWithLength uses assembly (MixinSignatureValidator.sol#487-511)\n\t- MixinSignatureValidator.sol#507-510\n"
        }
      ]
    },
    "smartcheck": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "SOLIDITY_REVERT_REQUIRE",
          "vulnerability_from_line": 941,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (signatureType == SignatureType.Illegal) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 33,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function rawAddress(bytes memory input)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 47,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function contentAddress(bytes memory input)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 62,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function memCopy(\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 203,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function sliceDestructive(\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 232,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function popLastByte(bytes memory b)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 256,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function popLast20Bytes(bytes memory b)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 299,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function readAddress(\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 331,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function writeAddress(\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 377,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function readBytes32(\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 404,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function writeBytes32(\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 460,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function readBytes4(\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 487,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function readBytesWithLength(\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 38,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 52,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 74,
          "vulnerability_to_line": null,
          "vulnerability_code": "            assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 102,
          "vulnerability_to_line": null,
          "vulnerability_code": "                assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 131,
          "vulnerability_to_line": null,
          "vulnerability_code": "                assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 222,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 245,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 269,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 318,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 350,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 394,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 421,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 472,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 507,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        }
      ]
    },
    "oyente": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": []
    },
    "mythril": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": []
    },
    "osiris": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": []
    }
  }
}