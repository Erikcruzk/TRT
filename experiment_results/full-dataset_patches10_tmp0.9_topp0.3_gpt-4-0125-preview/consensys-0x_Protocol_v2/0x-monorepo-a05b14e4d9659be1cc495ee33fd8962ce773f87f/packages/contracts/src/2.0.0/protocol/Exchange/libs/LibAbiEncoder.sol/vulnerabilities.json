{
  "smartbugs_completed": true,
  "analyzer_results": {
    "semgrep": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 47,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor ()\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 48,
          "vulnerability_to_line": null,
          "vulnerability_code": "        public\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 49,
          "vulnerability_to_line": null,
          "vulnerability_code": "    {\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 50,
          "vulnerability_to_line": null,
          "vulnerability_code": "        EIP712_DOMAIN_HASH = keccak256(abi.encode(\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 51,
          "vulnerability_to_line": null,
          "vulnerability_code": "            EIP712_DOMAIN_SEPARATOR_SCHEMA_HASH,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 52,
          "vulnerability_to_line": null,
          "vulnerability_code": "            keccak256(bytes(EIP712_DOMAIN_NAME)),\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 53,
          "vulnerability_to_line": null,
          "vulnerability_code": "            keccak256(bytes(EIP712_DOMAIN_VERSION)),\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 54,
          "vulnerability_to_line": null,
          "vulnerability_code": "            address(this)\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 55,
          "vulnerability_to_line": null,
          "vulnerability_code": "        ));\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 56,
          "vulnerability_to_line": null,
          "vulnerability_code": "    }\n",
          "message": "Consider making costructor payable to save gas."
        }
      ]
    },
    "slither": {
      "successfull_analysis": true,
      "errors": [
        "EXIT_CODE_7"
      ],
      "vulnerability_findings": [
        {
          "name": "constant-function",
          "vulnerability_from_line": 164,
          "vulnerability_to_line": 210,
          "vulnerability_code": "    function hashOrder(Order memory order)\n\n        internal\n\n        pure\n\n        returns (bytes32 result)\n\n    {\n\n        bytes32 schemaHash = EIP712_ORDER_SCHEMA_HASH;\n\n        bytes32 makerAssetDataHash = keccak256(order.makerAssetData);\n\n        bytes32 takerAssetDataHash = keccak256(order.takerAssetData);\n\n\n\n        // Assembly for more efficiently computing:\n\n        // keccak256(abi.encode(\n\n        //     order.makerAddress,\n\n        //     order.takerAddress,\n\n        //     order.feeRecipientAddress,\n\n        //     order.senderAddress,\n\n        //     order.makerAssetAmount,\n\n        //     order.takerAssetAmount,\n\n        //     order.makerFee,\n\n        //     order.takerFee,\n\n        //     order.expirationTimeSeconds,\n\n        //     order.salt,\n\n        //     keccak256(order.makerAssetData),\n\n        //     keccak256(order.takerAssetData)\n\n        // ));\n\n\n\n        assembly {\n\n            // Backup\n\n            // solhint-disable-next-line space-after-comma\n\n            let temp1 := mload(sub(order,  32))\n\n            let temp2 := mload(add(order, 320))\n\n            let temp3 := mload(add(order, 352))\n\n            \n\n            // Hash in place\n\n            // solhint-disable-next-line space-after-comma\n\n            mstore(sub(order,  32), schemaHash)\n\n            mstore(add(order, 320), makerAssetDataHash)\n\n            mstore(add(order, 352), takerAssetDataHash)\n\n            result := keccak256(sub(order, 32), 416)\n\n            \n\n            // Restore\n\n            // solhint-disable-next-line space-after-comma\n\n            mstore(sub(order,  32), temp1)\n\n            mstore(add(order, 320), temp2)\n\n            mstore(add(order, 352), temp3)\n\n        }\n\n        return result;\n",
          "message": "LibOrder.hashOrder (LibAbiEncoder.sol#164-210) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 246,
          "vulnerability_to_line": 428,
          "vulnerability_code": "    function abiEncodeFillOrder(\n\n        LibOrder.Order memory order,\n\n        uint256 takerAssetFillAmount,\n\n        bytes memory signature\n\n    )\n\n        public\n\n        pure\n\n        returns (bytes memory fillOrderCalldata)\n\n    {\n\n        // We need to call MExchangeCore.fillOrder using a delegatecall in\n\n        // assembly so that we can intercept a call that throws. For this, we\n\n        // need the input encoded in memory in the Ethereum ABIv2 format [1].\n\n\n\n        // | Area     | Offset | Length  | Contents                                    |\n\n        // | -------- |--------|---------|-------------------------------------------- |\n\n        // | Header   | 0x00   | 4       | function selector                           |\n\n        // | Params   |        | 3 * 32  | function parameters:                        |\n\n        // |          | 0x00   |         |   1. offset to order (*)                    |\n\n        // |          | 0x20   |         |   2. takerAssetFillAmount                   |\n\n        // |          | 0x40   |         |   3. offset to signature (*)                |\n\n        // | Data     |        | 12 * 32 | order:                                      |\n\n        // |          | 0x000  |         |   1.  senderAddress                         |\n\n        // |          | 0x020  |         |   2.  makerAddress                          |\n\n        // |          | 0x040  |         |   3.  takerAddress                          |\n\n        // |          | 0x060  |         |   4.  feeRecipientAddress                   |\n\n        // |          | 0x080  |         |   5.  makerAssetAmount                      |\n\n        // |          | 0x0A0  |         |   6.  takerAssetAmount                      |\n\n        // |          | 0x0C0  |         |   7.  makerFeeAmount                        |\n\n        // |          | 0x0E0  |         |   8.  takerFeeAmount                        |\n\n        // |          | 0x100  |         |   9.  expirationTimeSeconds                 |\n\n        // |          | 0x120  |         |   10. salt                                  |\n\n        // |          | 0x140  |         |   11. Offset to makerAssetData (*)          |\n\n        // |          | 0x160  |         |   12. Offset to takerAssetData (*)          |\n\n        // |          | 0x180  | 32      | makerAssetData Length                       |\n\n        // |          | 0x1A0  | **      | makerAssetData Contents                     |\n\n        // |          | 0x1C0  | 32      | takerAssetData Length                       |\n\n        // |          | 0x1E0  | **      | takerAssetData Contents                     |\n\n        // |          | 0x200  | 32      | signature Length                            |\n\n        // |          | 0x220  | **      | signature Contents                          |\n\n\n\n        // * Offsets are calculated from the beginning of the current area: Header, Params, Data:\n\n        //     An offset stored in the Params area is calculated from the beginning of the Params section.\n\n        //     An offset stored in the Data area is calculated from the beginning of the Data section.\n\n\n\n        // ** The length of dynamic array contents are stored in the field immediately preceeding the contents.\n\n\n\n        // [1]: https://solidity.readthedocs.io/en/develop/abi-spec.html\n\n\n\n        assembly {\n\n\n\n            // Areas below may use the following variables:\n\n            //   1. <area>Start   -- Start of this area in memory\n\n            //   2. <area>End     -- End of this area in memory. This value may\n\n            //                       be precomputed (before writing contents),\n\n            //                       or it may be computed as contents are written.\n\n            //   3. <area>Offset  -- Current offset into area. If an area's End\n\n            //                       is precomputed, this variable tracks the\n\n            //                       offsets of contents as they are written.\n\n\n\n            /////// Setup Header Area ///////\n\n            // Load free memory pointer\n\n            fillOrderCalldata := mload(0x40)\n\n            // bytes4(keccak256(\"fillOrder((address,address,address,address,uint256,uint256,uint256,uint256,uint256,uint256,bytes,bytes),uint256,bytes)\"))\n\n            // = 0xb4be83d5\n\n            // Leave 0x20 bytes to store the length\n\n            mstore(add(fillOrderCalldata, 0x20), 0xb4be83d500000000000000000000000000000000000000000000000000000000)\n\n            let headerAreaEnd := add(fillOrderCalldata, 0x24)\n\n\n\n            /////// Setup Params Area ///////\n\n            // This area is preallocated and written to later.\n\n            // This is because we need to fill in offsets that have not yet been calculated.\n\n            let paramsAreaStart := headerAreaEnd\n\n            let paramsAreaEnd := add(paramsAreaStart, 0x60)\n\n            let paramsAreaOffset := paramsAreaStart\n\n\n\n            /////// Setup Data Area ///////\n\n            let dataAreaStart := paramsAreaEnd\n\n            let dataAreaEnd := dataAreaStart\n\n\n\n            // Offset from the source data we're reading from\n\n            let sourceOffset := order\n\n            // arrayLenBytes and arrayLenWords track the length of a dynamically-allocated bytes array.\n\n            let arrayLenBytes := 0\n\n            let arrayLenWords := 0\n\n\n\n            /////// Write order Struct ///////\n\n            // Write memory location of Order, relative to the start of the\n\n            // parameter list, then increment the paramsAreaOffset respectively.\n\n            mstore(paramsAreaOffset, sub(dataAreaEnd, paramsAreaStart))\n\n            paramsAreaOffset := add(paramsAreaOffset, 0x20)\n\n\n\n            // Write values for each field in the order\n\n            // It would be nice to use a loop, but we save on gas by writing\n\n            // the stores sequentially.\n\n            mstore(dataAreaEnd, mload(sourceOffset))                            // makerAddress\n\n            mstore(add(dataAreaEnd, 0x20), mload(add(sourceOffset, 0x20)))      // takerAddress\n\n            mstore(add(dataAreaEnd, 0x40), mload(add(sourceOffset, 0x40)))      // feeRecipientAddress\n\n            mstore(add(dataAreaEnd, 0x60), mload(add(sourceOffset, 0x60)))      // senderAddress\n\n            mstore(add(dataAreaEnd, 0x80), mload(add(sourceOffset, 0x80)))      // makerAssetAmount\n\n            mstore(add(dataAreaEnd, 0xA0), mload(add(sourceOffset, 0xA0)))      // takerAssetAmount\n\n            mstore(add(dataAreaEnd, 0xC0), mload(add(sourceOffset, 0xC0)))      // makerFeeAmount\n\n            mstore(add(dataAreaEnd, 0xE0), mload(add(sourceOffset, 0xE0)))      // takerFeeAmount\n\n            mstore(add(dataAreaEnd, 0x100), mload(add(sourceOffset, 0x100)))    // expirationTimeSeconds\n\n            mstore(add(dataAreaEnd, 0x120), mload(add(sourceOffset, 0x120)))    // salt\n\n            mstore(add(dataAreaEnd, 0x140), mload(add(sourceOffset, 0x140)))    // Offset to makerAssetData\n\n            mstore(add(dataAreaEnd, 0x160), mload(add(sourceOffset, 0x160)))    // Offset to takerAssetData\n\n            dataAreaEnd := add(dataAreaEnd, 0x180)\n\n            sourceOffset := add(sourceOffset, 0x180)\n\n\n\n            // Write offset to <order.makerAssetData>\n\n            mstore(add(dataAreaStart, mul(10, 0x20)), sub(dataAreaEnd, dataAreaStart))\n\n\n\n            // Calculate length of <order.makerAssetData>\n\n            sourceOffset := mload(add(order, 0x140)) // makerAssetData\n\n            arrayLenBytes := mload(sourceOffset)\n\n            sourceOffset := add(sourceOffset, 0x20)\n\n            arrayLenWords := div(add(arrayLenBytes, 0x1F), 0x20)\n\n\n\n            // Write length of <order.makerAssetData>\n\n            mstore(dataAreaEnd, arrayLenBytes)\n\n            dataAreaEnd := add(dataAreaEnd, 0x20)\n\n\n\n            // Write contents of <order.makerAssetData>\n\n            for {let i := 0} lt(i, arrayLenWords) {i := add(i, 1)} {\n\n                mstore(dataAreaEnd, mload(sourceOffset))\n\n                dataAreaEnd := add(dataAreaEnd, 0x20)\n\n                sourceOffset := add(sourceOffset, 0x20)\n\n            }\n\n\n\n            // Write offset to <order.takerAssetData>\n\n            mstore(add(dataAreaStart, mul(11, 0x20)), sub(dataAreaEnd, dataAreaStart))\n\n\n\n            // Calculate length of <order.takerAssetData>\n\n            sourceOffset := mload(add(order, 0x160)) // takerAssetData\n\n            arrayLenBytes := mload(sourceOffset)\n\n            sourceOffset := add(sourceOffset, 0x20)\n\n            arrayLenWords := div(add(arrayLenBytes, 0x1F), 0x20)\n\n\n\n            // Write length of <order.takerAssetData>\n\n            mstore(dataAreaEnd, arrayLenBytes)\n\n            dataAreaEnd := add(dataAreaEnd, 0x20)\n\n\n\n            // Write contents of  <order.takerAssetData>\n\n            for {let i := 0} lt(i, arrayLenWords) {i := add(i, 1)} {\n\n                mstore(dataAreaEnd, mload(sourceOffset))\n\n                dataAreaEnd := add(dataAreaEnd, 0x20)\n\n                sourceOffset := add(sourceOffset, 0x20)\n\n            }\n\n\n\n            /////// Write takerAssetFillAmount ///////\n\n            mstore(paramsAreaOffset, takerAssetFillAmount)\n\n            paramsAreaOffset := add(paramsAreaOffset, 0x20)\n\n\n\n            /////// Write signature ///////\n\n            // Write offset to paramsArea\n\n            mstore(paramsAreaOffset, sub(dataAreaEnd, paramsAreaStart))\n\n\n\n            // Calculate length of signature\n\n            sourceOffset := signature\n\n            arrayLenBytes := mload(sourceOffset)\n\n            sourceOffset := add(sourceOffset, 0x20)\n\n            arrayLenWords := div(add(arrayLenBytes, 0x1F), 0x20)\n\n\n\n            // Write length of signature\n\n            mstore(dataAreaEnd, arrayLenBytes)\n\n            dataAreaEnd := add(dataAreaEnd, 0x20)\n\n\n\n            // Write contents of signature\n\n            for {let i := 0} lt(i, arrayLenWords) {i := add(i, 1)} {\n\n                mstore(dataAreaEnd, mload(sourceOffset))\n\n                dataAreaEnd := add(dataAreaEnd, 0x20)\n\n                sourceOffset := add(sourceOffset, 0x20)\n\n            }\n\n\n\n            // Set length of calldata\n\n            mstore(\n\n                fillOrderCalldata,\n\n                sub(dataAreaEnd, add(fillOrderCalldata, 0x20))\n\n            )\n\n        }\n\n\n\n        return fillOrderCalldata;\n",
          "message": "LibAbiEncoder.abiEncodeFillOrder (LibAbiEncoder.sol#246-428) is declared view but contains assembly code\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 164,
          "vulnerability_to_line": 210,
          "vulnerability_code": "    function hashOrder(Order memory order)\n\n        internal\n\n        pure\n\n        returns (bytes32 result)\n\n    {\n\n        bytes32 schemaHash = EIP712_ORDER_SCHEMA_HASH;\n\n        bytes32 makerAssetDataHash = keccak256(order.makerAssetData);\n\n        bytes32 takerAssetDataHash = keccak256(order.takerAssetData);\n\n\n\n        // Assembly for more efficiently computing:\n\n        // keccak256(abi.encode(\n\n        //     order.makerAddress,\n\n        //     order.takerAddress,\n\n        //     order.feeRecipientAddress,\n\n        //     order.senderAddress,\n\n        //     order.makerAssetAmount,\n\n        //     order.takerAssetAmount,\n\n        //     order.makerFee,\n\n        //     order.takerFee,\n\n        //     order.expirationTimeSeconds,\n\n        //     order.salt,\n\n        //     keccak256(order.makerAssetData),\n\n        //     keccak256(order.takerAssetData)\n\n        // ));\n\n\n\n        assembly {\n\n            // Backup\n\n            // solhint-disable-next-line space-after-comma\n\n            let temp1 := mload(sub(order,  32))\n\n            let temp2 := mload(add(order, 320))\n\n            let temp3 := mload(add(order, 352))\n\n            \n\n            // Hash in place\n\n            // solhint-disable-next-line space-after-comma\n\n            mstore(sub(order,  32), schemaHash)\n\n            mstore(add(order, 320), makerAssetDataHash)\n\n            mstore(add(order, 352), takerAssetDataHash)\n\n            result := keccak256(sub(order, 32), 416)\n\n            \n\n            // Restore\n\n            // solhint-disable-next-line space-after-comma\n\n            mstore(sub(order,  32), temp1)\n\n            mstore(add(order, 320), temp2)\n\n            mstore(add(order, 352), temp3)\n\n        }\n\n        return result;\n",
          "message": "LibOrder.hashOrder uses assembly (LibAbiEncoder.sol#164-210)\n\t- LibAbiEncoder.sol#189-209\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 246,
          "vulnerability_to_line": 428,
          "vulnerability_code": "    function abiEncodeFillOrder(\n\n        LibOrder.Order memory order,\n\n        uint256 takerAssetFillAmount,\n\n        bytes memory signature\n\n    )\n\n        public\n\n        pure\n\n        returns (bytes memory fillOrderCalldata)\n\n    {\n\n        // We need to call MExchangeCore.fillOrder using a delegatecall in\n\n        // assembly so that we can intercept a call that throws. For this, we\n\n        // need the input encoded in memory in the Ethereum ABIv2 format [1].\n\n\n\n        // | Area     | Offset | Length  | Contents                                    |\n\n        // | -------- |--------|---------|-------------------------------------------- |\n\n        // | Header   | 0x00   | 4       | function selector                           |\n\n        // | Params   |        | 3 * 32  | function parameters:                        |\n\n        // |          | 0x00   |         |   1. offset to order (*)                    |\n\n        // |          | 0x20   |         |   2. takerAssetFillAmount                   |\n\n        // |          | 0x40   |         |   3. offset to signature (*)                |\n\n        // | Data     |        | 12 * 32 | order:                                      |\n\n        // |          | 0x000  |         |   1.  senderAddress                         |\n\n        // |          | 0x020  |         |   2.  makerAddress                          |\n\n        // |          | 0x040  |         |   3.  takerAddress                          |\n\n        // |          | 0x060  |         |   4.  feeRecipientAddress                   |\n\n        // |          | 0x080  |         |   5.  makerAssetAmount                      |\n\n        // |          | 0x0A0  |         |   6.  takerAssetAmount                      |\n\n        // |          | 0x0C0  |         |   7.  makerFeeAmount                        |\n\n        // |          | 0x0E0  |         |   8.  takerFeeAmount                        |\n\n        // |          | 0x100  |         |   9.  expirationTimeSeconds                 |\n\n        // |          | 0x120  |         |   10. salt                                  |\n\n        // |          | 0x140  |         |   11. Offset to makerAssetData (*)          |\n\n        // |          | 0x160  |         |   12. Offset to takerAssetData (*)          |\n\n        // |          | 0x180  | 32      | makerAssetData Length                       |\n\n        // |          | 0x1A0  | **      | makerAssetData Contents                     |\n\n        // |          | 0x1C0  | 32      | takerAssetData Length                       |\n\n        // |          | 0x1E0  | **      | takerAssetData Contents                     |\n\n        // |          | 0x200  | 32      | signature Length                            |\n\n        // |          | 0x220  | **      | signature Contents                          |\n\n\n\n        // * Offsets are calculated from the beginning of the current area: Header, Params, Data:\n\n        //     An offset stored in the Params area is calculated from the beginning of the Params section.\n\n        //     An offset stored in the Data area is calculated from the beginning of the Data section.\n\n\n\n        // ** The length of dynamic array contents are stored in the field immediately preceeding the contents.\n\n\n\n        // [1]: https://solidity.readthedocs.io/en/develop/abi-spec.html\n\n\n\n        assembly {\n\n\n\n            // Areas below may use the following variables:\n\n            //   1. <area>Start   -- Start of this area in memory\n\n            //   2. <area>End     -- End of this area in memory. This value may\n\n            //                       be precomputed (before writing contents),\n\n            //                       or it may be computed as contents are written.\n\n            //   3. <area>Offset  -- Current offset into area. If an area's End\n\n            //                       is precomputed, this variable tracks the\n\n            //                       offsets of contents as they are written.\n\n\n\n            /////// Setup Header Area ///////\n\n            // Load free memory pointer\n\n            fillOrderCalldata := mload(0x40)\n\n            // bytes4(keccak256(\"fillOrder((address,address,address,address,uint256,uint256,uint256,uint256,uint256,uint256,bytes,bytes),uint256,bytes)\"))\n\n            // = 0xb4be83d5\n\n            // Leave 0x20 bytes to store the length\n\n            mstore(add(fillOrderCalldata, 0x20), 0xb4be83d500000000000000000000000000000000000000000000000000000000)\n\n            let headerAreaEnd := add(fillOrderCalldata, 0x24)\n\n\n\n            /////// Setup Params Area ///////\n\n            // This area is preallocated and written to later.\n\n            // This is because we need to fill in offsets that have not yet been calculated.\n\n            let paramsAreaStart := headerAreaEnd\n\n            let paramsAreaEnd := add(paramsAreaStart, 0x60)\n\n            let paramsAreaOffset := paramsAreaStart\n\n\n\n            /////// Setup Data Area ///////\n\n            let dataAreaStart := paramsAreaEnd\n\n            let dataAreaEnd := dataAreaStart\n\n\n\n            // Offset from the source data we're reading from\n\n            let sourceOffset := order\n\n            // arrayLenBytes and arrayLenWords track the length of a dynamically-allocated bytes array.\n\n            let arrayLenBytes := 0\n\n            let arrayLenWords := 0\n\n\n\n            /////// Write order Struct ///////\n\n            // Write memory location of Order, relative to the start of the\n\n            // parameter list, then increment the paramsAreaOffset respectively.\n\n            mstore(paramsAreaOffset, sub(dataAreaEnd, paramsAreaStart))\n\n            paramsAreaOffset := add(paramsAreaOffset, 0x20)\n\n\n\n            // Write values for each field in the order\n\n            // It would be nice to use a loop, but we save on gas by writing\n\n            // the stores sequentially.\n\n            mstore(dataAreaEnd, mload(sourceOffset))                            // makerAddress\n\n            mstore(add(dataAreaEnd, 0x20), mload(add(sourceOffset, 0x20)))      // takerAddress\n\n            mstore(add(dataAreaEnd, 0x40), mload(add(sourceOffset, 0x40)))      // feeRecipientAddress\n\n            mstore(add(dataAreaEnd, 0x60), mload(add(sourceOffset, 0x60)))      // senderAddress\n\n            mstore(add(dataAreaEnd, 0x80), mload(add(sourceOffset, 0x80)))      // makerAssetAmount\n\n            mstore(add(dataAreaEnd, 0xA0), mload(add(sourceOffset, 0xA0)))      // takerAssetAmount\n\n            mstore(add(dataAreaEnd, 0xC0), mload(add(sourceOffset, 0xC0)))      // makerFeeAmount\n\n            mstore(add(dataAreaEnd, 0xE0), mload(add(sourceOffset, 0xE0)))      // takerFeeAmount\n\n            mstore(add(dataAreaEnd, 0x100), mload(add(sourceOffset, 0x100)))    // expirationTimeSeconds\n\n            mstore(add(dataAreaEnd, 0x120), mload(add(sourceOffset, 0x120)))    // salt\n\n            mstore(add(dataAreaEnd, 0x140), mload(add(sourceOffset, 0x140)))    // Offset to makerAssetData\n\n            mstore(add(dataAreaEnd, 0x160), mload(add(sourceOffset, 0x160)))    // Offset to takerAssetData\n\n            dataAreaEnd := add(dataAreaEnd, 0x180)\n\n            sourceOffset := add(sourceOffset, 0x180)\n\n\n\n            // Write offset to <order.makerAssetData>\n\n            mstore(add(dataAreaStart, mul(10, 0x20)), sub(dataAreaEnd, dataAreaStart))\n\n\n\n            // Calculate length of <order.makerAssetData>\n\n            sourceOffset := mload(add(order, 0x140)) // makerAssetData\n\n            arrayLenBytes := mload(sourceOffset)\n\n            sourceOffset := add(sourceOffset, 0x20)\n\n            arrayLenWords := div(add(arrayLenBytes, 0x1F), 0x20)\n\n\n\n            // Write length of <order.makerAssetData>\n\n            mstore(dataAreaEnd, arrayLenBytes)\n\n            dataAreaEnd := add(dataAreaEnd, 0x20)\n\n\n\n            // Write contents of <order.makerAssetData>\n\n            for {let i := 0} lt(i, arrayLenWords) {i := add(i, 1)} {\n\n                mstore(dataAreaEnd, mload(sourceOffset))\n\n                dataAreaEnd := add(dataAreaEnd, 0x20)\n\n                sourceOffset := add(sourceOffset, 0x20)\n\n            }\n\n\n\n            // Write offset to <order.takerAssetData>\n\n            mstore(add(dataAreaStart, mul(11, 0x20)), sub(dataAreaEnd, dataAreaStart))\n\n\n\n            // Calculate length of <order.takerAssetData>\n\n            sourceOffset := mload(add(order, 0x160)) // takerAssetData\n\n            arrayLenBytes := mload(sourceOffset)\n\n            sourceOffset := add(sourceOffset, 0x20)\n\n            arrayLenWords := div(add(arrayLenBytes, 0x1F), 0x20)\n\n\n\n            // Write length of <order.takerAssetData>\n\n            mstore(dataAreaEnd, arrayLenBytes)\n\n            dataAreaEnd := add(dataAreaEnd, 0x20)\n\n\n\n            // Write contents of  <order.takerAssetData>\n\n            for {let i := 0} lt(i, arrayLenWords) {i := add(i, 1)} {\n\n                mstore(dataAreaEnd, mload(sourceOffset))\n\n                dataAreaEnd := add(dataAreaEnd, 0x20)\n\n                sourceOffset := add(sourceOffset, 0x20)\n\n            }\n\n\n\n            /////// Write takerAssetFillAmount ///////\n\n            mstore(paramsAreaOffset, takerAssetFillAmount)\n\n            paramsAreaOffset := add(paramsAreaOffset, 0x20)\n\n\n\n            /////// Write signature ///////\n\n            // Write offset to paramsArea\n\n            mstore(paramsAreaOffset, sub(dataAreaEnd, paramsAreaStart))\n\n\n\n            // Calculate length of signature\n\n            sourceOffset := signature\n\n            arrayLenBytes := mload(sourceOffset)\n\n            sourceOffset := add(sourceOffset, 0x20)\n\n            arrayLenWords := div(add(arrayLenBytes, 0x1F), 0x20)\n\n\n\n            // Write length of signature\n\n            mstore(dataAreaEnd, arrayLenBytes)\n\n            dataAreaEnd := add(dataAreaEnd, 0x20)\n\n\n\n            // Write contents of signature\n\n            for {let i := 0} lt(i, arrayLenWords) {i := add(i, 1)} {\n\n                mstore(dataAreaEnd, mload(sourceOffset))\n\n                dataAreaEnd := add(dataAreaEnd, 0x20)\n\n                sourceOffset := add(sourceOffset, 0x20)\n\n            }\n\n\n\n            // Set length of calldata\n\n            mstore(\n\n                fillOrderCalldata,\n\n                sub(dataAreaEnd, add(fillOrderCalldata, 0x20))\n\n            )\n\n        }\n\n\n\n        return fillOrderCalldata;\n",
          "message": "LibAbiEncoder.abiEncodeFillOrder uses assembly (LibAbiEncoder.sol#246-428)\n\t- LibAbiEncoder.sol#294-427\n"
        },
        {
          "name": "pragma",
          "vulnerability_from_line": 21,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity 0.4.24;\n",
          "message": "Different versions of Solidity is used in LibAbiEncoder.sol:\n\t- Version used: ['0.4.24', 'ABIEncoderV2']\n\t- LibAbiEncoder.sol#21 declares pragma solidity0.4.24\n\t- LibAbiEncoder.sol#90 declares pragma solidity0.4.24\n\t- LibAbiEncoder.sol#233 declares pragma solidity0.4.24\n\t- LibAbiEncoder.sol#234 declares pragma experimentalABIEncoderV2\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 246,
          "vulnerability_to_line": 428,
          "vulnerability_code": "    function abiEncodeFillOrder(\n\n        LibOrder.Order memory order,\n\n        uint256 takerAssetFillAmount,\n\n        bytes memory signature\n\n    )\n\n        public\n\n        pure\n\n        returns (bytes memory fillOrderCalldata)\n\n    {\n\n        // We need to call MExchangeCore.fillOrder using a delegatecall in\n\n        // assembly so that we can intercept a call that throws. For this, we\n\n        // need the input encoded in memory in the Ethereum ABIv2 format [1].\n\n\n\n        // | Area     | Offset | Length  | Contents                                    |\n\n        // | -------- |--------|---------|-------------------------------------------- |\n\n        // | Header   | 0x00   | 4       | function selector                           |\n\n        // | Params   |        | 3 * 32  | function parameters:                        |\n\n        // |          | 0x00   |         |   1. offset to order (*)                    |\n\n        // |          | 0x20   |         |   2. takerAssetFillAmount                   |\n\n        // |          | 0x40   |         |   3. offset to signature (*)                |\n\n        // | Data     |        | 12 * 32 | order:                                      |\n\n        // |          | 0x000  |         |   1.  senderAddress                         |\n\n        // |          | 0x020  |         |   2.  makerAddress                          |\n\n        // |          | 0x040  |         |   3.  takerAddress                          |\n\n        // |          | 0x060  |         |   4.  feeRecipientAddress                   |\n\n        // |          | 0x080  |         |   5.  makerAssetAmount                      |\n\n        // |          | 0x0A0  |         |   6.  takerAssetAmount                      |\n\n        // |          | 0x0C0  |         |   7.  makerFeeAmount                        |\n\n        // |          | 0x0E0  |         |   8.  takerFeeAmount                        |\n\n        // |          | 0x100  |         |   9.  expirationTimeSeconds                 |\n\n        // |          | 0x120  |         |   10. salt                                  |\n\n        // |          | 0x140  |         |   11. Offset to makerAssetData (*)          |\n\n        // |          | 0x160  |         |   12. Offset to takerAssetData (*)          |\n\n        // |          | 0x180  | 32      | makerAssetData Length                       |\n\n        // |          | 0x1A0  | **      | makerAssetData Contents                     |\n\n        // |          | 0x1C0  | 32      | takerAssetData Length                       |\n\n        // |          | 0x1E0  | **      | takerAssetData Contents                     |\n\n        // |          | 0x200  | 32      | signature Length                            |\n\n        // |          | 0x220  | **      | signature Contents                          |\n\n\n\n        // * Offsets are calculated from the beginning of the current area: Header, Params, Data:\n\n        //     An offset stored in the Params area is calculated from the beginning of the Params section.\n\n        //     An offset stored in the Data area is calculated from the beginning of the Data section.\n\n\n\n        // ** The length of dynamic array contents are stored in the field immediately preceeding the contents.\n\n\n\n        // [1]: https://solidity.readthedocs.io/en/develop/abi-spec.html\n\n\n\n        assembly {\n\n\n\n            // Areas below may use the following variables:\n\n            //   1. <area>Start   -- Start of this area in memory\n\n            //   2. <area>End     -- End of this area in memory. This value may\n\n            //                       be precomputed (before writing contents),\n\n            //                       or it may be computed as contents are written.\n\n            //   3. <area>Offset  -- Current offset into area. If an area's End\n\n            //                       is precomputed, this variable tracks the\n\n            //                       offsets of contents as they are written.\n\n\n\n            /////// Setup Header Area ///////\n\n            // Load free memory pointer\n\n            fillOrderCalldata := mload(0x40)\n\n            // bytes4(keccak256(\"fillOrder((address,address,address,address,uint256,uint256,uint256,uint256,uint256,uint256,bytes,bytes),uint256,bytes)\"))\n\n            // = 0xb4be83d5\n\n            // Leave 0x20 bytes to store the length\n\n            mstore(add(fillOrderCalldata, 0x20), 0xb4be83d500000000000000000000000000000000000000000000000000000000)\n\n            let headerAreaEnd := add(fillOrderCalldata, 0x24)\n\n\n\n            /////// Setup Params Area ///////\n\n            // This area is preallocated and written to later.\n\n            // This is because we need to fill in offsets that have not yet been calculated.\n\n            let paramsAreaStart := headerAreaEnd\n\n            let paramsAreaEnd := add(paramsAreaStart, 0x60)\n\n            let paramsAreaOffset := paramsAreaStart\n\n\n\n            /////// Setup Data Area ///////\n\n            let dataAreaStart := paramsAreaEnd\n\n            let dataAreaEnd := dataAreaStart\n\n\n\n            // Offset from the source data we're reading from\n\n            let sourceOffset := order\n\n            // arrayLenBytes and arrayLenWords track the length of a dynamically-allocated bytes array.\n\n            let arrayLenBytes := 0\n\n            let arrayLenWords := 0\n\n\n\n            /////// Write order Struct ///////\n\n            // Write memory location of Order, relative to the start of the\n\n            // parameter list, then increment the paramsAreaOffset respectively.\n\n            mstore(paramsAreaOffset, sub(dataAreaEnd, paramsAreaStart))\n\n            paramsAreaOffset := add(paramsAreaOffset, 0x20)\n\n\n\n            // Write values for each field in the order\n\n            // It would be nice to use a loop, but we save on gas by writing\n\n            // the stores sequentially.\n\n            mstore(dataAreaEnd, mload(sourceOffset))                            // makerAddress\n\n            mstore(add(dataAreaEnd, 0x20), mload(add(sourceOffset, 0x20)))      // takerAddress\n\n            mstore(add(dataAreaEnd, 0x40), mload(add(sourceOffset, 0x40)))      // feeRecipientAddress\n\n            mstore(add(dataAreaEnd, 0x60), mload(add(sourceOffset, 0x60)))      // senderAddress\n\n            mstore(add(dataAreaEnd, 0x80), mload(add(sourceOffset, 0x80)))      // makerAssetAmount\n\n            mstore(add(dataAreaEnd, 0xA0), mload(add(sourceOffset, 0xA0)))      // takerAssetAmount\n\n            mstore(add(dataAreaEnd, 0xC0), mload(add(sourceOffset, 0xC0)))      // makerFeeAmount\n\n            mstore(add(dataAreaEnd, 0xE0), mload(add(sourceOffset, 0xE0)))      // takerFeeAmount\n\n            mstore(add(dataAreaEnd, 0x100), mload(add(sourceOffset, 0x100)))    // expirationTimeSeconds\n\n            mstore(add(dataAreaEnd, 0x120), mload(add(sourceOffset, 0x120)))    // salt\n\n            mstore(add(dataAreaEnd, 0x140), mload(add(sourceOffset, 0x140)))    // Offset to makerAssetData\n\n            mstore(add(dataAreaEnd, 0x160), mload(add(sourceOffset, 0x160)))    // Offset to takerAssetData\n\n            dataAreaEnd := add(dataAreaEnd, 0x180)\n\n            sourceOffset := add(sourceOffset, 0x180)\n\n\n\n            // Write offset to <order.makerAssetData>\n\n            mstore(add(dataAreaStart, mul(10, 0x20)), sub(dataAreaEnd, dataAreaStart))\n\n\n\n            // Calculate length of <order.makerAssetData>\n\n            sourceOffset := mload(add(order, 0x140)) // makerAssetData\n\n            arrayLenBytes := mload(sourceOffset)\n\n            sourceOffset := add(sourceOffset, 0x20)\n\n            arrayLenWords := div(add(arrayLenBytes, 0x1F), 0x20)\n\n\n\n            // Write length of <order.makerAssetData>\n\n            mstore(dataAreaEnd, arrayLenBytes)\n\n            dataAreaEnd := add(dataAreaEnd, 0x20)\n\n\n\n            // Write contents of <order.makerAssetData>\n\n            for {let i := 0} lt(i, arrayLenWords) {i := add(i, 1)} {\n\n                mstore(dataAreaEnd, mload(sourceOffset))\n\n                dataAreaEnd := add(dataAreaEnd, 0x20)\n\n                sourceOffset := add(sourceOffset, 0x20)\n\n            }\n\n\n\n            // Write offset to <order.takerAssetData>\n\n            mstore(add(dataAreaStart, mul(11, 0x20)), sub(dataAreaEnd, dataAreaStart))\n\n\n\n            // Calculate length of <order.takerAssetData>\n\n            sourceOffset := mload(add(order, 0x160)) // takerAssetData\n\n            arrayLenBytes := mload(sourceOffset)\n\n            sourceOffset := add(sourceOffset, 0x20)\n\n            arrayLenWords := div(add(arrayLenBytes, 0x1F), 0x20)\n\n\n\n            // Write length of <order.takerAssetData>\n\n            mstore(dataAreaEnd, arrayLenBytes)\n\n            dataAreaEnd := add(dataAreaEnd, 0x20)\n\n\n\n            // Write contents of  <order.takerAssetData>\n\n            for {let i := 0} lt(i, arrayLenWords) {i := add(i, 1)} {\n\n                mstore(dataAreaEnd, mload(sourceOffset))\n\n                dataAreaEnd := add(dataAreaEnd, 0x20)\n\n                sourceOffset := add(sourceOffset, 0x20)\n\n            }\n\n\n\n            /////// Write takerAssetFillAmount ///////\n\n            mstore(paramsAreaOffset, takerAssetFillAmount)\n\n            paramsAreaOffset := add(paramsAreaOffset, 0x20)\n\n\n\n            /////// Write signature ///////\n\n            // Write offset to paramsArea\n\n            mstore(paramsAreaOffset, sub(dataAreaEnd, paramsAreaStart))\n\n\n\n            // Calculate length of signature\n\n            sourceOffset := signature\n\n            arrayLenBytes := mload(sourceOffset)\n\n            sourceOffset := add(sourceOffset, 0x20)\n\n            arrayLenWords := div(add(arrayLenBytes, 0x1F), 0x20)\n\n\n\n            // Write length of signature\n\n            mstore(dataAreaEnd, arrayLenBytes)\n\n            dataAreaEnd := add(dataAreaEnd, 0x20)\n\n\n\n            // Write contents of signature\n\n            for {let i := 0} lt(i, arrayLenWords) {i := add(i, 1)} {\n\n                mstore(dataAreaEnd, mload(sourceOffset))\n\n                dataAreaEnd := add(dataAreaEnd, 0x20)\n\n                sourceOffset := add(sourceOffset, 0x20)\n\n            }\n\n\n\n            // Set length of calldata\n\n            mstore(\n\n                fillOrderCalldata,\n\n                sub(dataAreaEnd, add(fillOrderCalldata, 0x20))\n\n            )\n\n        }\n\n\n\n        return fillOrderCalldata;\n",
          "message": "LibAbiEncoder.abiEncodeFillOrder (LibAbiEncoder.sol#246-428) should be declared external\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 45,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bytes32 public EIP712_DOMAIN_HASH;\n",
          "message": "Variable 'LibEIP712.EIP712_DOMAIN_HASH' (LibAbiEncoder.sol#45) is not in mixedCase\n"
        }
      ]
    },
    "smartcheck": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 164,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function hashOrder(Order memory order)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 246,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function abiEncodeFillOrder(\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 189,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 294,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        }
      ]
    },
    "oyente": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "Integer Underflow",
          "vulnerability_from_line": 35,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bytes32 public constant EIP712_DOMAIN_SEPARATOR_SCHEMA_HASH = keccak256(abi.encodePacked(\n",
          "message": null
        },
        {
          "name": "Integer Underflow",
          "vulnerability_from_line": 35,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bytes32 public constant EIP712_DOMAIN_SEPARATOR_SCHEMA_HASH = keccak256(abi.encodePacked(\n",
          "message": null
        }
      ]
    },
    "mythril": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": []
    },
    "osiris": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "Signedness bugs",
          "vulnerability_from_line": 34,
          "vulnerability_to_line": null,
          "vulnerability_code": "    // Hash of the EIP712 Domain Separator Schema\n",
          "message": null
        },
        {
          "name": "Signedness bugs",
          "vulnerability_from_line": 109,
          "vulnerability_to_line": null,
          "vulnerability_code": "        \"bytes makerAssetData,\",\n",
          "message": null
        },
        {
          "name": "Underflow bugs",
          "vulnerability_from_line": 34,
          "vulnerability_to_line": null,
          "vulnerability_code": "    // Hash of the EIP712 Domain Separator Schema\n",
          "message": null
        }
      ]
    }
  }
}