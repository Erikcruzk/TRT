{
  "smartbugs_completed": true,
  "analyzer_results": {
    "semgrep": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 24,
          "vulnerability_to_line": null,
          "vulnerability_code": "\tconstructor(\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 25,
          "vulnerability_to_line": null,
          "vulnerability_code": "\t\tstring memory name_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 26,
          "vulnerability_to_line": null,
          "vulnerability_code": "\t\tstring memory symbol_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 27,
          "vulnerability_to_line": null,
          "vulnerability_code": "\t\tuint256 supply\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 28,
          "vulnerability_to_line": null,
          "vulnerability_code": "\t) public {\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 29,
          "vulnerability_to_line": null,
          "vulnerability_code": "\t\tname = name_;\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 30,
          "vulnerability_to_line": null,
          "vulnerability_code": "\t\tsymbol = symbol_;\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 31,
          "vulnerability_to_line": null,
          "vulnerability_code": "\t\ttotalSupply = supply;\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 32,
          "vulnerability_to_line": null,
          "vulnerability_code": "\t\tbalanceOf[msg.sender] = supply;\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 33,
          "vulnerability_to_line": null,
          "vulnerability_code": "\t}\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 85,
          "vulnerability_to_line": null,
          "vulnerability_code": "\t\trequire(block.timestamp < deadline, \"ReturnFalseERC20: Expired\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 104,
          "vulnerability_to_line": null,
          "vulnerability_code": "\t\trequire(recoveredAddress == owner, \"ReturnFalseERC20: Invalid Sig\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 36,
          "vulnerability_to_line": null,
          "vulnerability_code": "\t\tif (balanceOf[msg.sender] >= amount && balanceOf[to] + amount >= balanceOf[to]) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 37,
          "vulnerability_to_line": null,
          "vulnerability_code": "\t\t\tbalanceOf[msg.sender] -= amount;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 38,
          "vulnerability_to_line": null,
          "vulnerability_code": "\t\t\tbalanceOf[to] += amount;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 39,
          "vulnerability_to_line": null,
          "vulnerability_code": "\t\t\temit Transfer(msg.sender, to, amount);\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 40,
          "vulnerability_to_line": null,
          "vulnerability_code": "\t\t\treturn true;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 41,
          "vulnerability_to_line": null,
          "vulnerability_code": "\t\t} else {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 42,
          "vulnerability_to_line": null,
          "vulnerability_code": "\t\t\treturn false;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 43,
          "vulnerability_to_line": null,
          "vulnerability_code": "\t\t}\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 47,
          "vulnerability_to_line": null,
          "vulnerability_code": "\t\tif (balanceOf[from] >= amount && allowance[from][msg.sender] >= amount && balanceOf[to] + amount >= balanceOf[to]) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 48,
          "vulnerability_to_line": null,
          "vulnerability_code": "\t\t\tbalanceOf[from] -= amount;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 49,
          "vulnerability_to_line": null,
          "vulnerability_code": "\t\t\tallowance[from][msg.sender] -= amount;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 50,
          "vulnerability_to_line": null,
          "vulnerability_code": "\t\t\tbalanceOf[to] += amount;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 51,
          "vulnerability_to_line": null,
          "vulnerability_code": "\t\t\temit Transfer(from, to, amount);\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 52,
          "vulnerability_to_line": null,
          "vulnerability_code": "\t\t\treturn true;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 53,
          "vulnerability_to_line": null,
          "vulnerability_code": "\t\t} else {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 54,
          "vulnerability_to_line": null,
          "vulnerability_code": "\t\t\treturn false;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 55,
          "vulnerability_to_line": null,
          "vulnerability_code": "\t\t}\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        }
      ]
    },
    "slither": {
      "successfull_analysis": true,
      "errors": [
        "EXIT_CODE_8"
      ],
      "vulnerability_findings": [
        {
          "name": "constant-function",
          "vulnerability_from_line": 65,
          "vulnerability_to_line": 74,
          "vulnerability_code": "\tfunction DOMAIN_SEPARATOR() public view returns (bytes32) {\n\n\t\tuint256 chainId;\n\n\t\tassembly {\n\n\t\t\tchainId := chainid()\n\n\t\t}\n\n\t\treturn\n\n\t\t\tkeccak256(\n\n\t\t\t\tabi.encode(keccak256(\"EIP712Domain(uint256 chainId,address verifyingContract)\"), chainId, address(this))\n\n\t\t\t);\n",
          "message": "ReturnFalseERC20Mock.DOMAIN_SEPARATOR (ReturnFalseERC20Mock.sol#65-74) is declared view but contains assembly code\n"
        },
        {
          "name": "timestamp",
          "vulnerability_from_line": 76,
          "vulnerability_to_line": 107,
          "vulnerability_code": "\tfunction permit(\n\n\t\taddress owner,\n\n\t\taddress spender,\n\n\t\tuint256 value,\n\n\t\tuint256 deadline,\n\n\t\tuint8 v,\n\n\t\tbytes32 r,\n\n\t\tbytes32 s\n\n\t) external {\n\n\t\trequire(block.timestamp < deadline, \"ReturnFalseERC20: Expired\");\n\n\t\tbytes32 digest =\n\n\t\t\tkeccak256(\n\n\t\t\t\tabi.encodePacked(\n\n\t\t\t\t\t\"\\x19\\x01\",\n\n\t\t\t\t\tDOMAIN_SEPARATOR(),\n\n\t\t\t\t\tkeccak256(\n\n\t\t\t\t\t\tabi.encode(\n\n\t\t\t\t\t\t\t0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9,\n\n\t\t\t\t\t\t\towner,\n\n\t\t\t\t\t\t\tspender,\n\n\t\t\t\t\t\t\tvalue,\n\n\t\t\t\t\t\t\tnonces[owner]++,\n\n\t\t\t\t\t\t\tdeadline\n\n\t\t\t\t\t\t)\n\n\t\t\t\t\t)\n\n\t\t\t\t)\n\n\t\t\t);\n\n\t\taddress recoveredAddress = ecrecover(digest, v, r, s);\n\n\t\trequire(recoveredAddress == owner, \"ReturnFalseERC20: Invalid Sig\");\n\n\t\tallowance[owner][spender] = value;\n\n\t\temit Approval(owner, spender, value);\n",
          "message": "ReturnFalseERC20Mock.permit (ReturnFalseERC20Mock.sol#76-107) uses timestamp for comparisons\n\tDangerous comparisons:\n\t- require(bool,string)(block.timestamp < deadline,ReturnFalseERC20: Expired) (ReturnFalseERC20Mock.sol#85)\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 65,
          "vulnerability_to_line": 74,
          "vulnerability_code": "\tfunction DOMAIN_SEPARATOR() public view returns (bytes32) {\n\n\t\tuint256 chainId;\n\n\t\tassembly {\n\n\t\t\tchainId := chainid()\n\n\t\t}\n\n\t\treturn\n\n\t\t\tkeccak256(\n\n\t\t\t\tabi.encode(keccak256(\"EIP712Domain(uint256 chainId,address verifyingContract)\"), chainId, address(this))\n\n\t\t\t);\n",
          "message": "ReturnFalseERC20Mock.DOMAIN_SEPARATOR uses assembly (ReturnFalseERC20Mock.sol#65-74)\n\t- ReturnFalseERC20Mock.sol#67-69\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 35,
          "vulnerability_to_line": 44,
          "vulnerability_code": "\tfunction transfer(address to, uint256 amount) public returns (bool success) {\n\n\t\tif (balanceOf[msg.sender] >= amount && balanceOf[to] + amount >= balanceOf[to]) {\n\n\t\t\tbalanceOf[msg.sender] -= amount;\n\n\t\t\tbalanceOf[to] += amount;\n\n\t\t\temit Transfer(msg.sender, to, amount);\n\n\t\t\treturn true;\n\n\t\t} else {\n\n\t\t\treturn false;\n\n\t\t}\n",
          "message": "ReturnFalseERC20Mock.transfer (ReturnFalseERC20Mock.sol#35-44) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 46,
          "vulnerability_to_line": 56,
          "vulnerability_code": "\tfunction transferFrom(address from, address to, uint256 amount) public returns (bool success) {\n\n\t\tif (balanceOf[from] >= amount && allowance[from][msg.sender] >= amount && balanceOf[to] + amount >= balanceOf[to]) {\n\n\t\t\tbalanceOf[from] -= amount;\n\n\t\t\tallowance[from][msg.sender] -= amount;\n\n\t\t\tbalanceOf[to] += amount;\n\n\t\t\temit Transfer(from, to, amount);\n\n\t\t\treturn true;\n\n\t\t} else {\n\n\t\t\treturn false;\n\n\t\t}\n",
          "message": "ReturnFalseERC20Mock.transferFrom (ReturnFalseERC20Mock.sol#46-56) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 58,
          "vulnerability_to_line": 62,
          "vulnerability_code": "\tfunction approve(address spender, uint256 amount) public returns (bool success) {\n\n\t\tallowance[msg.sender][spender] = amount;\n\n\t\temit Approval(msg.sender, spender, amount);\n\n\t\treturn true;\n",
          "message": "ReturnFalseERC20Mock.approve (ReturnFalseERC20Mock.sol#58-62) should be declared external\n"
        },
        {
          "name": "solc-version",
          "vulnerability_from_line": 9,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity 0.6.12;\n",
          "message": "Detected issues with version pragma in ReturnFalseERC20Mock.sol:\n\t- pragma solidity0.6.12 (ReturnFalseERC20Mock.sol#9): it allows old versions\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 65,
          "vulnerability_to_line": 74,
          "vulnerability_code": "\tfunction DOMAIN_SEPARATOR() public view returns (bytes32) {\n\n\t\tuint256 chainId;\n\n\t\tassembly {\n\n\t\t\tchainId := chainid()\n\n\t\t}\n\n\t\treturn\n\n\t\t\tkeccak256(\n\n\t\t\t\tabi.encode(keccak256(\"EIP712Domain(uint256 chainId,address verifyingContract)\"), chainId, address(this))\n\n\t\t\t);\n",
          "message": "Function 'ReturnFalseERC20Mock.DOMAIN_SEPARATOR' (ReturnFalseERC20Mock.sol#65-74) is not in mixedCase\n"
        }
      ]
    },
    "smartcheck": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "SOLIDITY_ERC20_APPROVE",
          "vulnerability_from_line": 58,
          "vulnerability_to_line": null,
          "vulnerability_code": "\tfunction approve(address spender, uint256 amount) public returns (bool success) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ERC20_TRANSFER_SHOULD_THROW",
          "vulnerability_from_line": 35,
          "vulnerability_to_line": null,
          "vulnerability_code": "\tfunction transfer(address to, uint256 amount) public returns (bool success) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ERC20_TRANSFER_SHOULD_THROW",
          "vulnerability_from_line": 46,
          "vulnerability_to_line": null,
          "vulnerability_code": "\tfunction transferFrom(address from, address to, uint256 amount) public returns (bool success) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
          "vulnerability_from_line": 65,
          "vulnerability_to_line": null,
          "vulnerability_code": "\tfunction DOMAIN_SEPARATOR() public view returns (bytes32) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 67,
          "vulnerability_to_line": null,
          "vulnerability_code": "\t\tassembly {\n",
          "message": null
        }
      ]
    },
    "oyente": {
      "successfull_analysis": false,
      "errors": [
        "exception (RuntimeError: Source map error, unknown name(SHR) or instr_name(INVALID))"
      ],
      "vulnerability_findings": []
    },
    "mythril": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": []
    },
    "osiris": {
      "successfull_analysis": false,
      "errors": [
        "Solidity compilation failed"
      ],
      "vulnerability_findings": []
    }
  }
}