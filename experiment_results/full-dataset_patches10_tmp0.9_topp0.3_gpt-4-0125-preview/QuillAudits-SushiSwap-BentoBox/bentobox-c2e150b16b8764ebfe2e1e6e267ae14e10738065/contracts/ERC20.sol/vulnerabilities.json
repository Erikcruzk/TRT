{
  "smartbugs_completed": true,
  "analyzer_results": {
    "semgrep": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 21,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(balanceOf[msg.sender] >= amount, \"ERC20: balance too low\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 22,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(balanceOf[to] + amount >= balanceOf[to], \"ERC20: overflow detected\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 30,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(balanceOf[from] >= amount, \"ERC20: balance too low\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 31,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(allowance[from][msg.sender] >= amount, \"ERC20: allowance too low\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 32,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(balanceOf[to] + amount >= balanceOf[to], \"ERC20: overflow detected\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 54,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(owner_ != address(0), \"ERC20: Owner cannot be 0\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 55,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(block.timestamp < deadline, \"ERC20: Expired\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 64,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(recoveredAddress == owner_, \"ERC20: Invalid Signature\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        }
      ]
    },
    "slither": {
      "successfull_analysis": true,
      "errors": [
        "EXIT_CODE_8"
      ],
      "vulnerability_findings": [
        {
          "name": "constant-function",
          "vulnerability_from_line": 47,
          "vulnerability_to_line": 51,
          "vulnerability_code": "    function DOMAIN_SEPARATOR() public view returns (bytes32){\n\n      uint256 chainId;\n\n      assembly {chainId := chainid()}\n\n      return keccak256(abi.encode(keccak256(\"EIP712Domain(uint256 chainId,address verifyingContract)\"), chainId, address(this)));\n",
          "message": "ERC20.DOMAIN_SEPARATOR (ERC20.sol#47-51) is declared view but contains assembly code\n"
        },
        {
          "name": "timestamp",
          "vulnerability_from_line": 53,
          "vulnerability_to_line": 67,
          "vulnerability_code": "    function permit(address owner_, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external {\n\n        require(owner_ != address(0), \"ERC20: Owner cannot be 0\");\n\n        require(block.timestamp < deadline, \"ERC20: Expired\");\n\n        bytes32 digest = keccak256(abi.encodePacked(\n\n            \"\\x19\\x01\", DOMAIN_SEPARATOR(),\n\n            keccak256(abi.encode(\n\n                0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9,\n\n                owner_, spender, value, nonces[owner_]++, deadline\n\n            ))\n\n        ));\n\n        address recoveredAddress = ecrecover(digest, v, r, s);\n\n        require(recoveredAddress == owner_, \"ERC20: Invalid Signature\");\n\n        allowance[owner_][spender] = value;\n\n        emit Approval(owner_, spender, value);\n",
          "message": "ERC20.permit (ERC20.sol#53-67) uses timestamp for comparisons\n\tDangerous comparisons:\n\t- require(bool,string)(block.timestamp < deadline,ERC20: Expired) (ERC20.sol#55)\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 47,
          "vulnerability_to_line": 51,
          "vulnerability_code": "    function DOMAIN_SEPARATOR() public view returns (bytes32){\n\n      uint256 chainId;\n\n      assembly {chainId := chainid()}\n\n      return keccak256(abi.encode(keccak256(\"EIP712Domain(uint256 chainId,address verifyingContract)\"), chainId, address(this)));\n",
          "message": "ERC20.DOMAIN_SEPARATOR uses assembly (ERC20.sol#47-51)\n\t- ERC20.sol#49\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 20,
          "vulnerability_to_line": 27,
          "vulnerability_code": "    function transfer(address to, uint256 amount) public returns (bool success) {\n\n        require(balanceOf[msg.sender] >= amount, \"ERC20: balance too low\");\n\n        require(balanceOf[to] + amount >= balanceOf[to], \"ERC20: overflow detected\");\n\n        balanceOf[msg.sender] -= amount;\n\n        balanceOf[to] += amount;\n\n        emit Transfer(msg.sender, to, amount);\n\n        return true;\n",
          "message": "ERC20.transfer (ERC20.sol#20-27) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 29,
          "vulnerability_to_line": 38,
          "vulnerability_code": "    function transferFrom(address from, address to, uint256 amount) public returns (bool success) {\n\n        require(balanceOf[from] >= amount, \"ERC20: balance too low\");\n\n        require(allowance[from][msg.sender] >= amount, \"ERC20: allowance too low\");\n\n        require(balanceOf[to] + amount >= balanceOf[to], \"ERC20: overflow detected\");\n\n        balanceOf[from] -= amount;\n\n        allowance[from][msg.sender] -= amount;\n\n        balanceOf[to] += amount;\n\n        emit Transfer(from, to, amount);\n\n        return true;\n",
          "message": "ERC20.transferFrom (ERC20.sol#29-38) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 40,
          "vulnerability_to_line": 44,
          "vulnerability_code": "    function approve(address spender, uint256 amount) public returns (bool success) {\n\n        allowance[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n\n        return true;\n",
          "message": "ERC20.approve (ERC20.sol#40-44) should be declared external\n"
        },
        {
          "name": "solc-version",
          "vulnerability_from_line": 7,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity 0.6.12;\n",
          "message": "Detected issues with version pragma in ERC20.sol:\n\t- pragma solidity0.6.12 (ERC20.sol#7): it allows old versions\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 47,
          "vulnerability_to_line": 51,
          "vulnerability_code": "    function DOMAIN_SEPARATOR() public view returns (bytes32){\n\n      uint256 chainId;\n\n      assembly {chainId := chainid()}\n\n      return keccak256(abi.encode(keccak256(\"EIP712Domain(uint256 chainId,address verifyingContract)\"), chainId, address(this)));\n",
          "message": "Function 'ERC20.DOMAIN_SEPARATOR' (ERC20.sol#47-51) is not in mixedCase\n"
        }
      ]
    },
    "smartcheck": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "SOLIDITY_ERC20_APPROVE",
          "vulnerability_from_line": 40,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function approve(address spender, uint256 amount) public returns (bool success) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
          "vulnerability_from_line": 47,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function DOMAIN_SEPARATOR() public view returns (bytes32){\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 49,
          "vulnerability_to_line": null,
          "vulnerability_code": "      assembly {chainId := chainid()}\n",
          "message": null
        }
      ]
    },
    "oyente": {
      "successfull_analysis": false,
      "errors": [
        "exception (RuntimeError: Source map error, unknown name(SHR) or instr_name(INVALID))"
      ],
      "vulnerability_findings": []
    },
    "mythril": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "Dependence on predictable environment variable (SWC 116)",
          "vulnerability_from_line": 55,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(block.timestamp < deadline, \"ERC20: Expired\");\n",
          "message": "A control flow decision is made based on The block.timestamp environment variable.\nThe block.timestamp environment variable is used to determine a control flow decision. Note that the values of variables like coinbase, gaslimit, block number and timestamp are predictable and can be manipulated by a malicious miner. Also keep in mind that attackers know hashes of earlier blocks. Don't use any of those environment variables as sources of randomness and be aware that use of these variables introduces a certain level of trust into miners.\nClassification: SWC-116"
        }
      ]
    },
    "osiris": {
      "successfull_analysis": false,
      "errors": [
        "Solidity compilation failed"
      ],
      "vulnerability_findings": []
    }
  }
}