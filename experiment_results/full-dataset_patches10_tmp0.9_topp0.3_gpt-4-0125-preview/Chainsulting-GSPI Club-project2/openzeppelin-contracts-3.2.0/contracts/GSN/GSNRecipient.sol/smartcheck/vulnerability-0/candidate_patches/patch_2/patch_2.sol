pragma solidity ^0.6.0;






interface IRelayRecipient {
    


    function getHubAddr() external view returns (address);

    
















    function acceptRelayedCall(
        address relay,
        address from,
        bytes calldata encodedFunction,
        uint256 transactionFee,
        uint256 gasPrice,
        uint256 gasLimit,
        uint256 nonce,
        bytes calldata approvalData,
        uint256 maxPossibleCharge
    )
        external
        view
        returns (uint256, bytes memory);

    










    function preRelayedCall(bytes calldata context) external returns (bytes32);

    













    function postRelayedCall(bytes calldata context, bool success, uint256 actualCharge, bytes32 preRetVal) external;
}





pragma solidity ^0.6.0;








interface IRelayHub {
    

    









    function stake(address relayaddr, uint256 unstakeDelay) external payable;

    


    event Staked(address indexed relay, uint256 stake, uint256 unstakeDelay);

    








    function registerRelay(uint256 transactionFee, string calldata url) external;

    



    event RelayAdded(address indexed relay, address indexed owner, uint256 transactionFee, uint256 stake, uint256 unstakeDelay, string url);

    







    function removeRelayByOwner(address relay) external;

    


    event RelayRemoved(address indexed relay, uint256 unstakeTime);

    





    function unstake(address relay) external;

    


    event Unstaked(address indexed relay, uint256 stake);

    
    enum RelayState {
        Unknown, 
        Staked, 
        Registered, 
        Removed    
    }

    



    function getRelay(address relay) external view returns (uint256 totalStake, uint256 unstakeDelay, uint256 unstakeTime, address payable owner, RelayState state);

    

    






    function depositFor(address target) external payable;

    


    event Deposited(address indexed recipient, address indexed from, uint256 amount);

    


    function balanceOf(address target) external view returns (uint256);

    





    function withdraw(uint256 amount, address payable dest) external;

    


    event Withdrawn(address indexed account, address indexed dest, uint256 amount);

    

    









    function canRelay(
        address relay,
        address from,
        address to,
        bytes calldata encodedFunction,
        uint256 transactionFee,
        uint256 gasPrice,
        uint256 gasLimit,
        uint256 nonce,
        bytes calldata signature,
        bytes calldata approvalData
    ) external view returns (uint256 status, bytes memory recipientContext);

    
    enum PreconditionCheck {
        OK,                         
        WrongSignature,             
        WrongNonce,                 
        AcceptRelayedCallReverted,  
        InvalidRecipientStatusCode  
    }

    




























    function relayCall(
        address from,
        address to,
        bytes calldata encodedFunction,
        uint256 transactionFee,
        uint256 gasPrice,
        uint256 gasLimit,
        uint256 nonce,
        bytes calldata signature,
        bytes calldata approvalData
    ) external;

    








    event CanRelayFailed(address indexed relay, address indexed from, address indexed to, bytes4 selector, uint256 reason);

    







    event TransactionRelayed(address indexed relay, address indexed from, address indexed to, bytes4 selector, RelayCallStatus status, uint256 charge);

    
    enum RelayCallStatus {
        OK,                      
        RelayedCallFailed,       
        PreRelayedFailed,        
        PostRelayedFailed,       
        RecipientBalanceChanged  
    }

    



    function requiredGas(uint256 relayedCallStipend) external view returns (uint256);

    


    function maxPossibleCharge(uint256 relayedCallStipend, uint256 gasPrice, uint256 transactionFee) external view returns (uint256);

     
     
    
    

    





    function penalizeRepeatedNonce(bytes calldata unsignedTx1, bytes calldata signature1, bytes calldata unsignedTx2, bytes calldata signature2) external;

    


    function penalizeIllegalTransaction(bytes calldata unsignedTx, bytes calldata signature) external;

    


    event Penalized(address indexed relay, address sender, uint256 amount);

    


    function getNonce(address from) external view returns (uint256);
}





pragma solidity ^0.6.0;











abstract contract Context {
    function _msgSender() internal view virtual returns (address payable) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes memory) {
        this; 
        return msg.data;
    }
}





pragma solidity ^0.6.0;














function beginMigration() public onlyOwner {
    require(!_migrationStarted);
    _migrationStarted = true;
    emit MigrationStarted();
}