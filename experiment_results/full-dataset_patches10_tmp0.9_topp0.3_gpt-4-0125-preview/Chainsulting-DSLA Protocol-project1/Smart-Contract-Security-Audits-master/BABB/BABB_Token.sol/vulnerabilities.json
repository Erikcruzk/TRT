{
  "smartbugs_completed": true,
  "analyzer_results": {
    "semgrep": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "use-ownable2step",
          "vulnerability_from_line": 102,
          "vulnerability_to_line": null,
          "vulnerability_code": "contract BasicToken is Ownable, ERC20Basic {\n",
          "message": "By demanding that the receiver of the owner permissions actively accept via a contract call of its own,  `Ownable2Step` and `Ownable2StepUpgradeable` prevent the contract ownership from accidentally being transferred  to an address that cannot handle it."
        },
        {
          "name": "use-ownable2step",
          "vulnerability_from_line": 227,
          "vulnerability_to_line": null,
          "vulnerability_code": "contract Pausable is Ownable {\n",
          "message": "By demanding that the receiver of the owner permissions actively accept via a contract call of its own,  `Ownable2Step` and `Ownable2StepUpgradeable` prevent the contract ownership from accidentally being transferred  to an address that cannot handle it."
        },
        {
          "name": "use-ownable2step",
          "vulnerability_from_line": 267,
          "vulnerability_to_line": null,
          "vulnerability_code": "contract BlackList is Ownable, BasicToken {\n",
          "message": "By demanding that the receiver of the owner permissions actively accept via a contract call of its own,  `Ownable2Step` and `Ownable2StepUpgradeable` prevent the contract ownership from accidentally being transferred  to an address that cannot handle it."
        },
        {
          "name": "init-variables-with-default-value",
          "vulnerability_from_line": 108,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint public feeRate = 0;\n",
          "message": "Uninitialized variables are assigned with the types default value. Explicitly initializing a variable with its default value costs unnecessary gas."
        },
        {
          "name": "init-variables-with-default-value",
          "vulnerability_from_line": 109,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint public feeLimit = 0;\n",
          "message": "Uninitialized variables are assigned with the types default value. Explicitly initializing a variable with its default value costs unnecessary gas."
        },
        {
          "name": "init-variables-with-default-value",
          "vulnerability_from_line": 231,
          "vulnerability_to_line": null,
          "vulnerability_code": "  bool public contractPaused = false;\n",
          "message": "Uninitialized variables are assigned with the types default value. Explicitly initializing a variable with its default value costs unnecessary gas."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 204,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(!((_value != 0) && (allowed[msg.sender][_spender] != 0)));\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        }
      ]
    },
    "slither": {
      "successfull_analysis": true,
      "errors": [
        "EXIT_CODE_52"
      ],
      "vulnerability_findings": [
        {
          "name": "erc20-interface",
          "vulnerability_from_line": 79,
          "vulnerability_to_line": 85,
          "vulnerability_code": "contract ERC20Basic {\n\n    uint public totalSupplyAlt;\n\n    function totalSupply() public constant returns (uint);\n\n    function balanceOf(address who) public constant returns (uint);\n\n    function transfer(address to, uint value) public;\n\n    event Transfer(address indexed from, address indexed to, uint value);\n",
          "message": "ERC20Basic (BABB_Token.sol#79-85) has incorrect ERC20 function interface(s):\n\t-transfer (BABB_Token.sol#83)\n"
        },
        {
          "name": "erc20-interface",
          "vulnerability_from_line": 91,
          "vulnerability_to_line": 96,
          "vulnerability_code": "contract ERC20 is ERC20Basic {\n\n    function allowance(address owner, address spender) public constant returns (uint);\n\n    function transferFrom(address from, address to, uint value) public;\n\n    function approve(address spender, uint value) public;\n\n    event Approval(address indexed owner, address indexed spender, uint value);\n",
          "message": "ERC20 (BABB_Token.sol#91-96) has incorrect ERC20 function interface(s):\n\t-transferFrom (BABB_Token.sol#93)\n\t-approve (BABB_Token.sol#94)\n"
        },
        {
          "name": "erc20-interface",
          "vulnerability_from_line": 102,
          "vulnerability_to_line": 148,
          "vulnerability_code": "contract BasicToken is Ownable, ERC20Basic {\n\n    using SafeMath for uint;\n\n\n\n    mapping(address => uint) public balances;\n\n\n\n    // additional variables for use if transaction fees ever became necessary\n\n    uint public feeRate = 0;\n\n    uint public feeLimit = 0;\n\n\n\n    /**\n\n    * @dev Fix for the ERC20 short address attack.\n\n    */\n\n    modifier onlyPayloadSize(uint size) {\n\n        require(!(msg.data.length < size + 4));\n\n        _;\n\n    }\n\n\n\n    /**\n\n    * @dev transfer token for a specified address\n\n    * @param _to The address to transfer to.\n\n    * @param _value The amount to be transferred.\n\n    */\n\n    function transfer(address _to, uint _value) public onlyPayloadSize(2 * 32) {\n\n        uint fee = (_value.mul(feeRate)).div(10000);\n\n        if (fee > feeLimit) {\n\n            fee = feeLimit;\n\n        }\n\n        uint sendAmount = _value.sub(fee);\n\n        balances[msg.sender] = balances[msg.sender].sub(_value);\n\n        balances[_to] = balances[_to].add(sendAmount);\n\n        if (fee > 0) {\n\n            balances[owner] = balances[owner].add(fee);\n\n            Transfer(msg.sender, owner, fee);\n\n        }\n\n        Transfer(msg.sender, _to, sendAmount);\n\n    }\n\n\n\n    /**\n\n    * @dev Gets the balance of the specified address.\n\n    * @param _owner The address to query the the balance of.\n\n    * @return An uint representing the amount owned by the passed address.\n\n    */\n\n    function balanceOf(address _owner) public constant returns (uint balance) {\n\n        return balances[_owner];\n\n    }\n\n\n",
          "message": "BasicToken (BABB_Token.sol#102-148) has incorrect ERC20 function interface(s):\n\t-transfer (BABB_Token.sol#124-137)\n"
        },
        {
          "name": "erc20-interface",
          "vulnerability_from_line": 157,
          "vulnerability_to_line": 220,
          "vulnerability_code": "contract StandardToken is BasicToken, ERC20 {\n\n\n\n    mapping (address => mapping (address => uint)) public allowed;\n\n\n\n    uint public constant MAX_UINT = 2**256 - 1;\n\n    uint public constant MAX_CAP = 100000000000 * 10**18;\n\n\n\n    /**\n\n    * @dev Transfer tokens from one address to another\n\n    * @param _from address The address which you want to send tokens from\n\n    * @param _to address The address which you want to transfer to\n\n    * @param _value uint the amount of tokens to be transferred\n\n    */\n\n    function transferFrom(address _from, address _to, uint _value) public onlyPayloadSize(3 * 32) {\n\n        var _allowance = allowed[_from][msg.sender];\n\n\n\n        // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met\n\n        // if (_value > _allowance) throw;\n\n\n\n        uint fee = (_value.mul(feeRate)).div(10000);\n\n        if (fee > feeLimit) {\n\n            fee = feeLimit;\n\n        }\n\n        if (_allowance < MAX_UINT) {\n\n            allowed[_from][msg.sender] = _allowance.sub(_value);\n\n        }\n\n        uint sendAmount = _value.sub(fee);\n\n        balances[_from] = balances[_from].sub(_value);\n\n        balances[_to] = balances[_to].add(sendAmount);\n\n        if (fee > 0) {\n\n            balances[owner] = balances[owner].add(fee);\n\n            Transfer(_from, owner, fee);\n\n        }\n\n        Transfer(_from, _to, sendAmount);\n\n    }\n\n\n\n    /**\n\n    * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n\n    * @param _spender The address which will spend the funds.\n\n    * @param _value The amount of tokens to be spent.\n\n    */\n\n    function approve(address _spender, uint _value) public onlyPayloadSize(2 * 32) {\n\n\n\n        // To change the approve amount you first have to reduce the addresses`\n\n        //  allowance to zero by calling `approve(_spender, 0)` if it is not\n\n        //  already 0 to mitigate the race condition described here:\n\n        //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n\n        require(!((_value != 0) && (allowed[msg.sender][_spender] != 0)));\n\n\n\n        allowed[msg.sender][_spender] = _value;\n\n        Approval(msg.sender, _spender, _value);\n\n    }\n\n\n\n    /**\n\n    * @dev Function to check the amount of tokens than an owner allowed to a spender.\n\n    * @param _owner address The address which owns the funds.\n\n    * @param _spender address The address which will spend the funds.\n\n    * @return A uint specifying the amount of tokens still available for the spender.\n\n    */\n\n    function allowance(address _owner, address _spender) public constant returns (uint remaining) {\n\n        return allowed[_owner][_spender];\n\n    }\n\n\n",
          "message": "StandardToken (BABB_Token.sol#157-220) has incorrect ERC20 function interface(s):\n\t-transferFrom (BABB_Token.sol#170-191)\n\t-approve (BABB_Token.sol#198-208)\n"
        },
        {
          "name": "erc20-interface",
          "vulnerability_from_line": 314,
          "vulnerability_to_line": 450,
          "vulnerability_code": "contract BAX_Token_2022 is Pausable, StandardToken, BlackList {\n\n\n\n    string public name;\n\n    string public symbol;\n\n    uint public decimals;\n\n    address public upgradeContract;\n\n    bool public upgradeApplied;\n\n\n\n    //  The contract can be initialized with a number of tokens\n\n    //  All the tokens are deposited to the owner address\n\n    //\n\n    // @param _balance Initial supply of the contract\n\n    // @param _name Token Name\n\n    // @param _symbol Token symbol\n\n    // @param _decimals Token decimals\n\n    function BAX_Token_2022(uint _initialSupply, string _name, string _symbol, uint _decimals) public {\n\n        totalSupplyAlt = _initialSupply;\n\n        name = _name;\n\n        symbol = _symbol;\n\n        decimals = _decimals;\n\n        balances[owner] = _initialSupply;\n\n        upgradeApplied = false;\n\n    }\n\n\n\n    // Forward ERC20 methods to upgraded contract if this one is deprecated\n\n    function transfer(address _to, uint _value) public whenNotPaused {\n\n        require(!checkFrozenAlt[msg.sender]);\n\n        if (upgradeApplied) {\n\n            return UpgradedStandardToken(upgradeContract).transferByLegacy(msg.sender, _to, _value);\n\n        } else {\n\n            return super.transfer(_to, _value);\n\n        }\n\n    }\n\n\n\n    // Forward ERC20 methods to upgraded contract if this one is deprecated\n\n    function transferFrom(address _from, address _to, uint _value) public whenNotPaused {\n\n        require(!checkFrozenAlt[_from]);\n\n        if (upgradeApplied) {\n\n            return UpgradedStandardToken(upgradeContract).transferFromByLegacy(msg.sender, _from, _to, _value);\n\n        } else {\n\n            return super.transferFrom(_from, _to, _value);\n\n        }\n\n    }\n\n\n\n    // Forward ERC20 methods to upgraded contract if this one is deprecated\n\n    function balanceOf(address who) public constant returns (uint) {\n\n        if (upgradeApplied) {\n\n            return UpgradedStandardToken(upgradeContract).balanceOf(who);\n\n        } else {\n\n            return super.balanceOf(who);\n\n        }\n\n    }\n\n\n\n    // Forward ERC20 methods to upgraded contract if this one is deprecated\n\n    function approve(address _spender, uint _value) public onlyPayloadSize(2 * 32) {\n\n        if (upgradeApplied) {\n\n            return UpgradedStandardToken(upgradeContract).approveByLegacy(msg.sender, _spender, _value);\n\n        } else {\n\n            return super.approve(_spender, _value);\n\n        }\n\n    }\n\n\n\n    // Forward ERC20 methods to upgraded contract if this one is deprecated\n\n    function allowance(address _owner, address _spender) public constant returns (uint remaining) {\n\n        if (upgradeApplied) {\n\n            return StandardToken(upgradeContract).allowance(_owner, _spender);\n\n        } else {\n\n            return super.allowance(_owner, _spender);\n\n        }\n\n    }\n\n\n\n    // deprecate current contract in favour of a new one\n\n    function upgrade(address _upgradeContract) public onlyOwner {\n\n        upgradeApplied = true;\n\n        upgradeContract = _upgradeContract;\n\n        Upgrade(_upgradeContract);\n\n    }\n\n\n\n    // deprecate current contract if favour of a new one\n\n    function totalSupply() public constant returns (uint) {\n\n        if (upgradeApplied) {\n\n            return StandardToken(upgradeContract).totalSupply();\n\n        } else {\n\n            return totalSupplyAlt;\n\n        }\n\n    }\n\n\n\n    // Issue a new amount of tokens\n\n    // these tokens are deposited into the owner address\n\n    //\n\n    // @param _amount Number of tokens to be issued\n\n    function mint(uint amount) public onlyOwner {\n\n        require(totalSupplyAlt + amount > totalSupplyAlt);\n\n        require(balances[owner] + amount > balances[owner]);\n\n        require(totalSupplyAlt + amount  <= MAX_CAP);\n\n        balances[owner] += amount;\n\n        totalSupplyAlt += amount;\n\n        Mint(amount);\n\n    }\n\n\n\n    // Redeem tokens.\n\n    // These tokens are withdrawn from the owner address\n\n    // if the balance must be enough to cover the redeem\n\n    // or the call will fail.\n\n    // @param _amount Number of tokens to be issued\n\n    function burn(uint amount) public onlyOwner {\n\n        require(totalSupplyAlt >= amount);\n\n        require(balances[owner] >= amount);\n\n\n\n        totalSupplyAlt -= amount;\n\n        balances[owner] -= amount;\n\n        Burn(amount);\n\n    }\n\n\n\n    function setFee(uint newBasisPoints, uint newMaxFee) public onlyOwner {\n\n        // Ensure transparency by hardcoding limit beyond which fees can never be added\n\n        require(newBasisPoints < 20);\n\n //       require(newMaxFee < 50);\n\n\n\n        feeRate = newBasisPoints;\n\n        feeLimit = newMaxFee.mul(10**decimals);\n\n\n\n        Params(feeRate, feeLimit);\n\n    }\n\n\n\n    // Called when new token are issued\n\n    event Mint(uint amount);\n\n\n\n    // Called when tokens are redeemed\n\n    event Burn(uint amount);\n\n\n\n    // Called when contract is deprecated\n\n    event Upgrade(address newAddress);\n\n\n\n    // Called if contract ever adds fees\n\n    event Params(uint feeBasisPoints, uint maxFee);\n",
          "message": "BAX_Token_2022 (BABB_Token.sol#314-450) has incorrect ERC20 function interface(s):\n\t-transfer (BABB_Token.sol#339-346)\n\t-transferFrom (BABB_Token.sol#349-356)\n\t-approve (BABB_Token.sol#368-374)\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 66,
          "vulnerability_to_line": 70,
          "vulnerability_code": "    function transferOwnership(address newOwner) public onlyOwner {\n\n        if (newOwner != address(0)) {\n\n            owner = newOwner;\n\n        }\n",
          "message": "Ownable.transferOwnership (BABB_Token.sol#66-70) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 393,
          "vulnerability_to_line": 399,
          "vulnerability_code": "    function totalSupply() public constant returns (uint) {\n\n        if (upgradeApplied) {\n\n            return StandardToken(upgradeContract).totalSupply();\n\n        } else {\n\n            return totalSupplyAlt;\n\n        }\n",
          "message": "BAX_Token_2022.totalSupply (BABB_Token.sol#393-399) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 81,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function totalSupply() public constant returns (uint);\n",
          "message": "ERC20Basic.totalSupply (BABB_Token.sol#81) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 253,
          "vulnerability_to_line": 256,
          "vulnerability_code": "  function pause() onlyOwner whenNotPaused public {\n\n    contractPaused = true;\n\n    Pause();\n",
          "message": "Pausable.pause (BABB_Token.sol#253-256) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 261,
          "vulnerability_to_line": 264,
          "vulnerability_code": "  function unpause() onlyOwner whenPaused public {\n\n    contractPaused = false;\n\n    Unpause();\n",
          "message": "Pausable.unpause (BABB_Token.sol#261-264) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 280,
          "vulnerability_to_line": 283,
          "vulnerability_code": "    function freezeWallet (address _evilUser) public onlyOwner {\n\n        checkFrozenAlt[_evilUser] = true;\n\n        WalletFrozen(_evilUser);\n",
          "message": "BlackList.freezeWallet (BABB_Token.sol#280-283) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 285,
          "vulnerability_to_line": 288,
          "vulnerability_code": "    function unfreezeWallet (address _clearedUser) public onlyOwner {\n\n        checkFrozenAlt[_clearedUser] = false;\n\n        WalletUnfrozen(_clearedUser);\n",
          "message": "BlackList.unfreezeWallet (BABB_Token.sol#285-288) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 290,
          "vulnerability_to_line": 296,
          "vulnerability_code": "    function destroyFrozenFunds (address _blackListedUser) public onlyOwner {\n\n        require(checkFrozenAlt[_blackListedUser]);\n\n        uint dirtyFunds = balanceOf(_blackListedUser);\n\n        balances[_blackListedUser] = 0;\n\n        totalSupplyAlt -= dirtyFunds;\n\n        DestroyedFrozenFunds(_blackListedUser, dirtyFunds);\n",
          "message": "BlackList.destroyFrozenFunds (BABB_Token.sol#290-296) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 309,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function transferByLegacy(address from, address to, uint value) public;\n",
          "message": "UpgradedStandardToken.transferByLegacy (BABB_Token.sol#309) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 310,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function transferFromByLegacy(address sender, address from, address spender, uint value) public;\n",
          "message": "UpgradedStandardToken.transferFromByLegacy (BABB_Token.sol#310) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 311,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function approveByLegacy(address from, address spender, uint value) public;\n",
          "message": "UpgradedStandardToken.approveByLegacy (BABB_Token.sol#311) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 386,
          "vulnerability_to_line": 390,
          "vulnerability_code": "    function upgrade(address _upgradeContract) public onlyOwner {\n\n        upgradeApplied = true;\n\n        upgradeContract = _upgradeContract;\n\n        Upgrade(_upgradeContract);\n",
          "message": "BAX_Token_2022.upgrade (BABB_Token.sol#386-390) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 405,
          "vulnerability_to_line": 412,
          "vulnerability_code": "    function mint(uint amount) public onlyOwner {\n\n        require(totalSupplyAlt + amount > totalSupplyAlt);\n\n        require(balances[owner] + amount > balances[owner]);\n\n        require(totalSupplyAlt + amount  <= MAX_CAP);\n\n        balances[owner] += amount;\n\n        totalSupplyAlt += amount;\n\n        Mint(amount);\n",
          "message": "BAX_Token_2022.mint (BABB_Token.sol#405-412) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 419,
          "vulnerability_to_line": 426,
          "vulnerability_code": "    function burn(uint amount) public onlyOwner {\n\n        require(totalSupplyAlt >= amount);\n\n        require(balances[owner] >= amount);\n\n\n\n        totalSupplyAlt -= amount;\n\n        balances[owner] -= amount;\n\n        Burn(amount);\n",
          "message": "BAX_Token_2022.burn (BABB_Token.sol#419-426) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 428,
          "vulnerability_to_line": 437,
          "vulnerability_code": "    function setFee(uint newBasisPoints, uint newMaxFee) public onlyOwner {\n\n        // Ensure transparency by hardcoding limit beyond which fees can never be added\n\n        require(newBasisPoints < 20);\n\n //       require(newMaxFee < 50);\n\n\n\n        feeRate = newBasisPoints;\n\n        feeLimit = newMaxFee.mul(10**decimals);\n\n\n\n        Params(feeRate, feeLimit);\n",
          "message": "BAX_Token_2022.setFee (BABB_Token.sol#428-437) should be declared external\n"
        },
        {
          "name": "solc-version",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.17;\n",
          "message": "Detected issues with version pragma in BABB_Token.sol:\n\t- pragma solidity^0.4.17 (BABB_Token.sol#3): it allows old versions\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 50,
          "vulnerability_to_line": 52,
          "vulnerability_code": "    function Ownable() public {\n\n        owner = msg.sender;\n",
          "message": "Function 'Ownable.Ownable' (BABB_Token.sol#50-52) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 144,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function balanceOf(address _owner) public constant returns (uint balance) {\n",
          "message": "Parameter '_owner' of BasicToken.balanceOf (BABB_Token.sol#144) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 124,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function transfer(address _to, uint _value) public onlyPayloadSize(2 * 32) {\n",
          "message": "Parameter '_to' of BasicToken.transfer (BABB_Token.sol#124) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 124,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function transfer(address _to, uint _value) public onlyPayloadSize(2 * 32) {\n",
          "message": "Parameter '_value' of BasicToken.transfer (BABB_Token.sol#124) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 216,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function allowance(address _owner, address _spender) public constant returns (uint remaining) {\n",
          "message": "Parameter '_owner' of StandardToken.allowance (BABB_Token.sol#216) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 216,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function allowance(address _owner, address _spender) public constant returns (uint remaining) {\n",
          "message": "Parameter '_spender' of StandardToken.allowance (BABB_Token.sol#216) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 170,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function transferFrom(address _from, address _to, uint _value) public onlyPayloadSize(3 * 32) {\n",
          "message": "Parameter '_from' of StandardToken.transferFrom (BABB_Token.sol#170) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 170,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function transferFrom(address _from, address _to, uint _value) public onlyPayloadSize(3 * 32) {\n",
          "message": "Parameter '_to' of StandardToken.transferFrom (BABB_Token.sol#170) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 170,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function transferFrom(address _from, address _to, uint _value) public onlyPayloadSize(3 * 32) {\n",
          "message": "Parameter '_value' of StandardToken.transferFrom (BABB_Token.sol#170) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 198,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function approve(address _spender, uint _value) public onlyPayloadSize(2 * 32) {\n",
          "message": "Parameter '_spender' of StandardToken.approve (BABB_Token.sol#198) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 198,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function approve(address _spender, uint _value) public onlyPayloadSize(2 * 32) {\n",
          "message": "Parameter '_value' of StandardToken.approve (BABB_Token.sol#198) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 270,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function checkFrozen(address _maker) external constant returns (bool) {\n",
          "message": "Parameter '_maker' of BlackList.checkFrozen (BABB_Token.sol#270) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 280,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function freezeWallet (address _evilUser) public onlyOwner {\n",
          "message": "Parameter '_evilUser' of BlackList.freezeWallet (BABB_Token.sol#280) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 285,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function unfreezeWallet (address _clearedUser) public onlyOwner {\n",
          "message": "Parameter '_clearedUser' of BlackList.unfreezeWallet (BABB_Token.sol#285) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 290,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function destroyFrozenFunds (address _blackListedUser) public onlyOwner {\n",
          "message": "Parameter '_blackListedUser' of BlackList.destroyFrozenFunds (BABB_Token.sol#290) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 314,
          "vulnerability_to_line": 450,
          "vulnerability_code": "contract BAX_Token_2022 is Pausable, StandardToken, BlackList {\n\n\n\n    string public name;\n\n    string public symbol;\n\n    uint public decimals;\n\n    address public upgradeContract;\n\n    bool public upgradeApplied;\n\n\n\n    //  The contract can be initialized with a number of tokens\n\n    //  All the tokens are deposited to the owner address\n\n    //\n\n    // @param _balance Initial supply of the contract\n\n    // @param _name Token Name\n\n    // @param _symbol Token symbol\n\n    // @param _decimals Token decimals\n\n    function BAX_Token_2022(uint _initialSupply, string _name, string _symbol, uint _decimals) public {\n\n        totalSupplyAlt = _initialSupply;\n\n        name = _name;\n\n        symbol = _symbol;\n\n        decimals = _decimals;\n\n        balances[owner] = _initialSupply;\n\n        upgradeApplied = false;\n\n    }\n\n\n\n    // Forward ERC20 methods to upgraded contract if this one is deprecated\n\n    function transfer(address _to, uint _value) public whenNotPaused {\n\n        require(!checkFrozenAlt[msg.sender]);\n\n        if (upgradeApplied) {\n\n            return UpgradedStandardToken(upgradeContract).transferByLegacy(msg.sender, _to, _value);\n\n        } else {\n\n            return super.transfer(_to, _value);\n\n        }\n\n    }\n\n\n\n    // Forward ERC20 methods to upgraded contract if this one is deprecated\n\n    function transferFrom(address _from, address _to, uint _value) public whenNotPaused {\n\n        require(!checkFrozenAlt[_from]);\n\n        if (upgradeApplied) {\n\n            return UpgradedStandardToken(upgradeContract).transferFromByLegacy(msg.sender, _from, _to, _value);\n\n        } else {\n\n            return super.transferFrom(_from, _to, _value);\n\n        }\n\n    }\n\n\n\n    // Forward ERC20 methods to upgraded contract if this one is deprecated\n\n    function balanceOf(address who) public constant returns (uint) {\n\n        if (upgradeApplied) {\n\n            return UpgradedStandardToken(upgradeContract).balanceOf(who);\n\n        } else {\n\n            return super.balanceOf(who);\n\n        }\n\n    }\n\n\n\n    // Forward ERC20 methods to upgraded contract if this one is deprecated\n\n    function approve(address _spender, uint _value) public onlyPayloadSize(2 * 32) {\n\n        if (upgradeApplied) {\n\n            return UpgradedStandardToken(upgradeContract).approveByLegacy(msg.sender, _spender, _value);\n\n        } else {\n\n            return super.approve(_spender, _value);\n\n        }\n\n    }\n\n\n\n    // Forward ERC20 methods to upgraded contract if this one is deprecated\n\n    function allowance(address _owner, address _spender) public constant returns (uint remaining) {\n\n        if (upgradeApplied) {\n\n            return StandardToken(upgradeContract).allowance(_owner, _spender);\n\n        } else {\n\n            return super.allowance(_owner, _spender);\n\n        }\n\n    }\n\n\n\n    // deprecate current contract in favour of a new one\n\n    function upgrade(address _upgradeContract) public onlyOwner {\n\n        upgradeApplied = true;\n\n        upgradeContract = _upgradeContract;\n\n        Upgrade(_upgradeContract);\n\n    }\n\n\n\n    // deprecate current contract if favour of a new one\n\n    function totalSupply() public constant returns (uint) {\n\n        if (upgradeApplied) {\n\n            return StandardToken(upgradeContract).totalSupply();\n\n        } else {\n\n            return totalSupplyAlt;\n\n        }\n\n    }\n\n\n\n    // Issue a new amount of tokens\n\n    // these tokens are deposited into the owner address\n\n    //\n\n    // @param _amount Number of tokens to be issued\n\n    function mint(uint amount) public onlyOwner {\n\n        require(totalSupplyAlt + amount > totalSupplyAlt);\n\n        require(balances[owner] + amount > balances[owner]);\n\n        require(totalSupplyAlt + amount  <= MAX_CAP);\n\n        balances[owner] += amount;\n\n        totalSupplyAlt += amount;\n\n        Mint(amount);\n\n    }\n\n\n\n    // Redeem tokens.\n\n    // These tokens are withdrawn from the owner address\n\n    // if the balance must be enough to cover the redeem\n\n    // or the call will fail.\n\n    // @param _amount Number of tokens to be issued\n\n    function burn(uint amount) public onlyOwner {\n\n        require(totalSupplyAlt >= amount);\n\n        require(balances[owner] >= amount);\n\n\n\n        totalSupplyAlt -= amount;\n\n        balances[owner] -= amount;\n\n        Burn(amount);\n\n    }\n\n\n\n    function setFee(uint newBasisPoints, uint newMaxFee) public onlyOwner {\n\n        // Ensure transparency by hardcoding limit beyond which fees can never be added\n\n        require(newBasisPoints < 20);\n\n //       require(newMaxFee < 50);\n\n\n\n        feeRate = newBasisPoints;\n\n        feeLimit = newMaxFee.mul(10**decimals);\n\n\n\n        Params(feeRate, feeLimit);\n\n    }\n\n\n\n    // Called when new token are issued\n\n    event Mint(uint amount);\n\n\n\n    // Called when tokens are redeemed\n\n    event Burn(uint amount);\n\n\n\n    // Called when contract is deprecated\n\n    event Upgrade(address newAddress);\n\n\n\n    // Called if contract ever adds fees\n\n    event Params(uint feeBasisPoints, uint maxFee);\n",
          "message": "Contract 'BAX_Token_2022' (BABB_Token.sol#314-450) is not in CapWords\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 339,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function transfer(address _to, uint _value) public whenNotPaused {\n",
          "message": "Parameter '_to' of BAX_Token_2022.transfer (BABB_Token.sol#339) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 339,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function transfer(address _to, uint _value) public whenNotPaused {\n",
          "message": "Parameter '_value' of BAX_Token_2022.transfer (BABB_Token.sol#339) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 377,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function allowance(address _owner, address _spender) public constant returns (uint remaining) {\n",
          "message": "Parameter '_owner' of BAX_Token_2022.allowance (BABB_Token.sol#377) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 377,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function allowance(address _owner, address _spender) public constant returns (uint remaining) {\n",
          "message": "Parameter '_spender' of BAX_Token_2022.allowance (BABB_Token.sol#377) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 349,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function transferFrom(address _from, address _to, uint _value) public whenNotPaused {\n",
          "message": "Parameter '_from' of BAX_Token_2022.transferFrom (BABB_Token.sol#349) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 349,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function transferFrom(address _from, address _to, uint _value) public whenNotPaused {\n",
          "message": "Parameter '_to' of BAX_Token_2022.transferFrom (BABB_Token.sol#349) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 349,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function transferFrom(address _from, address _to, uint _value) public whenNotPaused {\n",
          "message": "Parameter '_value' of BAX_Token_2022.transferFrom (BABB_Token.sol#349) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 368,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function approve(address _spender, uint _value) public onlyPayloadSize(2 * 32) {\n",
          "message": "Parameter '_spender' of BAX_Token_2022.approve (BABB_Token.sol#368) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 368,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function approve(address _spender, uint _value) public onlyPayloadSize(2 * 32) {\n",
          "message": "Parameter '_value' of BAX_Token_2022.approve (BABB_Token.sol#368) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 329,
          "vulnerability_to_line": 336,
          "vulnerability_code": "    function BAX_Token_2022(uint _initialSupply, string _name, string _symbol, uint _decimals) public {\n\n        totalSupplyAlt = _initialSupply;\n\n        name = _name;\n\n        symbol = _symbol;\n\n        decimals = _decimals;\n\n        balances[owner] = _initialSupply;\n\n        upgradeApplied = false;\n",
          "message": "Function 'BAX_Token_2022.BAX_Token_2022' (BABB_Token.sol#329-336) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 329,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function BAX_Token_2022(uint _initialSupply, string _name, string _symbol, uint _decimals) public {\n",
          "message": "Parameter '_initialSupply' of BAX_Token_2022.BAX_Token_2022 (BABB_Token.sol#329) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 329,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function BAX_Token_2022(uint _initialSupply, string _name, string _symbol, uint _decimals) public {\n",
          "message": "Parameter '_name' of BAX_Token_2022.BAX_Token_2022 (BABB_Token.sol#329) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 329,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function BAX_Token_2022(uint _initialSupply, string _name, string _symbol, uint _decimals) public {\n",
          "message": "Parameter '_symbol' of BAX_Token_2022.BAX_Token_2022 (BABB_Token.sol#329) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 329,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function BAX_Token_2022(uint _initialSupply, string _name, string _symbol, uint _decimals) public {\n",
          "message": "Parameter '_decimals' of BAX_Token_2022.BAX_Token_2022 (BABB_Token.sol#329) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 386,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function upgrade(address _upgradeContract) public onlyOwner {\n",
          "message": "Parameter '_upgradeContract' of BAX_Token_2022.upgrade (BABB_Token.sol#386) is not in mixedCase\n"
        }
      ]
    },
    "smartcheck": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
          "vulnerability_from_line": 81,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function totalSupply() public constant returns (uint);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
          "vulnerability_from_line": 82,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function balanceOf(address who) public constant returns (uint);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
          "vulnerability_from_line": 92,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function allowance(address owner, address spender) public constant returns (uint);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
          "vulnerability_from_line": 144,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function balanceOf(address _owner) public constant returns (uint balance) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
          "vulnerability_from_line": 216,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function allowance(address _owner, address _spender) public constant returns (uint remaining) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
          "vulnerability_from_line": 270,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function checkFrozen(address _maker) external constant returns (bool) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
          "vulnerability_from_line": 274,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function ownerAlt() external constant returns (address) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
          "vulnerability_from_line": 359,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function balanceOf(address who) public constant returns (uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
          "vulnerability_from_line": 377,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function allowance(address _owner, address _spender) public constant returns (uint remaining) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
          "vulnerability_from_line": 393,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function totalSupply() public constant returns (uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ERC20_APPROVE",
          "vulnerability_from_line": 198,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function approve(address _spender, uint _value) public onlyPayloadSize(2 * 32) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ERC20_APPROVE",
          "vulnerability_from_line": 368,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function approve(address _spender, uint _value) public onlyPayloadSize(2 * 32) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_OVERPOWERED_ROLE",
          "vulnerability_from_line": 428,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setFee(uint newBasisPoints, uint newMaxFee) public onlyOwner {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.17;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SAFEMATH",
          "vulnerability_from_line": 103,
          "vulnerability_to_line": null,
          "vulnerability_code": "    using SafeMath for uint;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 329,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function BAX_Token_2022(uint _initialSupply, string _name, string _symbol, uint _decimals) public {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 329,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function BAX_Token_2022(uint _initialSupply, string _name, string _symbol, uint _decimals) public {\n",
          "message": null
        }
      ]
    },
    "oyente": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "Integer Underflow",
          "vulnerability_from_line": 294,
          "vulnerability_to_line": null,
          "vulnerability_code": "        totalSupplyAlt -= dirtyFunds;\n",
          "message": null
        }
      ]
    },
    "mythril": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": []
    },
    "osiris": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "Underflow bugs",
          "vulnerability_from_line": 294,
          "vulnerability_to_line": null,
          "vulnerability_code": "        totalSupplyAlt -= dirtyFunds;\n",
          "message": null
        }
      ]
    }
  }
}