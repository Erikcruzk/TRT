{
  "smartbugs_completed": true,
  "analyzer_results": {
    "semgrep": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 540,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor(address _proxyRegistryAddress) public {\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 541,
          "vulnerability_to_line": null,
          "vulnerability_code": "        proxyRegistryAddress = _proxyRegistryAddress;\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 542,
          "vulnerability_to_line": null,
          "vulnerability_code": "        _owner = msg.sender;\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 543,
          "vulnerability_to_line": null,
          "vulnerability_code": "        initialize();\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 544,
          "vulnerability_to_line": null,
          "vulnerability_code": "    }\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 390,
          "vulnerability_to_line": null,
          "vulnerability_code": "            balances[id][_from] = balances[id][_from].sub(value);\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 390,
          "vulnerability_to_line": null,
          "vulnerability_code": "            balances[id][_from] = balances[id][_from].sub(value);\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 391,
          "vulnerability_to_line": null,
          "vulnerability_code": "            balances[id][_to]   = value.add(balances[id][_to]);\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 391,
          "vulnerability_to_line": null,
          "vulnerability_code": "            balances[id][_to]   = value.add(balances[id][_to]);\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 436,
          "vulnerability_to_line": null,
          "vulnerability_code": "            balances_[i] = balances[_ids[i]][_owners[i]];\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 643,
          "vulnerability_to_line": null,
          "vulnerability_code": "            address tokenContract = contracts[_id];\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 692,
          "vulnerability_to_line": null,
          "vulnerability_code": "            address tokenContract = contracts[_id];\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 384,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 i = 0; i < _ids.length; ++i) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 435,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 i = 0; i < _owners.length; ++i) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 639,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 i=0; i < _ids.length; ++i) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 688,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 i=0; i < _ids.length; ++i) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 343,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_to != address(0x0), \"_to must be non-zero.\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 344,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_from == msg.sender || operatorApproval[_from][msg.sender] == true, \"Need operator approval for 3rd party transfers.\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 380,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_to != address(0x0), \"destination address must be non-zero.\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 381,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_ids.length == _values.length, \"_ids and _values array length must match.\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 382,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_from == msg.sender || operatorApproval[_from][msg.sender] == true, \"Need operator approval for 3rd party transfers.\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 473,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(ERC1155TokenReceiver(_to).onERC1155Received(_operator, _from, _id, _value, _data) == ERC1155_ACCEPTED, \"contract returned an unknown value from onERC1155Received\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 483,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(ERC1155TokenReceiver(_to).onERC1155BatchReceived(_operator, _from, _ids, _values, _data) == ERC1155_BATCH_ACCEPTED, \"contract returned an unknown value from onERC1155BatchReceived\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 530,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(contracts[_id] == address(0), \"id already exists\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 557,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(isOwner(), \"Not owner\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 611,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(tokenContract != address(0), \"invalid id\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 615,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(curio.balanceOf(msg.sender) >= _quantity, \"insufficient curio balance\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 616,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(curio.allowance(msg.sender, address(this)) >= _quantity, \"insufficient curio allowance\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 635,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_ids.length == _quantities.length, \"ids and quantities must match\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 644,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(tokenContract != address(0), \"invalid id\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 647,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(curio.balanceOf(msg.sender) >= _quantity, \"insufficient curio balance\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 648,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(curio.allowance(msg.sender, address(this)) >= _quantity, \"insufficient curio allowance\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 670,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(tokenContract != address(0), \"invalid id\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 673,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(balances[_id][msg.sender] >= _quantity, \"insufficient balance\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 686,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_ids.length == _quantities.length, \"ids and quantities must match\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 693,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(tokenContract != address(0), \"invalid id\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 696,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(balances[_id][msg.sender] >= _quantity, \"insufficient balance\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 344,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_from == msg.sender || operatorApproval[_from][msg.sender] == true, \"Need operator approval for 3rd party transfers.\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 380,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_to != address(0x0), \"destination address must be non-zero.\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 381,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_ids.length == _values.length, \"_ids and _values array length must match.\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 382,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_from == msg.sender || operatorApproval[_from][msg.sender] == true, \"Need operator approval for 3rd party transfers.\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 473,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(ERC1155TokenReceiver(_to).onERC1155Received(_operator, _from, _id, _value, _data) == ERC1155_ACCEPTED, \"contract returned an unknown value from onERC1155Received\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 483,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(ERC1155TokenReceiver(_to).onERC1155BatchReceived(_operator, _from, _ids, _values, _data) == ERC1155_BATCH_ACCEPTED, \"contract returned an unknown value from onERC1155BatchReceived\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        }
      ]
    },
    "slither": {
      "successfull_analysis": true,
      "errors": [
        "EXIT_CODE_66"
      ],
      "vulnerability_findings": [
        {
          "name": "constant-function",
          "vulnerability_from_line": 73,
          "vulnerability_to_line": 84,
          "vulnerability_code": "    function isContract(address account) internal view returns (bool) {\n\n        uint256 size;\n\n        // XXX Currently there is no better way to check if there is a contract in an address\n\n        // than to check the size of the code at that address.\n\n        // See https://ethereum.stackexchange.com/a/14016/36603\n\n        // for more details about how this works.\n\n        // TODO Check this again before the Serenity release, because all addresses will be\n\n        // contracts then.\n\n        // solium-disable-next-line security/no-inline-assembly\n\n        assembly { size := extcodesize(account) }\n\n        return size > 0;\n",
          "message": "Address.isContract (AbstractWrapper.sol#73-84) is declared view but contains assembly code\n"
        },
        {
          "name": "erc20-interface",
          "vulnerability_from_line": 492,
          "vulnerability_to_line": 498,
          "vulnerability_code": "interface ICurio {\n\n  function balanceOf(address account) external view returns (uint256);\n\n  function allowance(address owner, address spender) external view returns (uint256);\n\n  function transferFrom(address _from, address _to, uint256 _value) external;\n\n  function transfer(address _to, uint256 _value) external;\n\n  function ipfs_hash() external view returns (string memory);\n",
          "message": "ICurio (AbstractWrapper.sol#492-498) has incorrect ERC20 function interface(s):\n\t-transferFrom (AbstractWrapper.sol#495)\n\t-transfer (AbstractWrapper.sol#496)\n"
        },
        {
          "name": "calls-loop",
          "vulnerability_from_line": 647,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(curio.balanceOf(msg.sender) >= _quantity, \"insufficient curio balance\");\n",
          "message": "AbstractWrapper.wrapBatch has external calls inside a loop:\n\t- require(bool,string)(curio.balanceOf(msg.sender) >= _quantity,insufficient curio balance) (AbstractWrapper.sol#647)\n"
        },
        {
          "name": "calls-loop",
          "vulnerability_from_line": 648,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(curio.allowance(msg.sender, address(this)) >= _quantity, \"insufficient curio allowance\");\n",
          "message": "AbstractWrapper.wrapBatch has external calls inside a loop:\n\t- require(bool,string)(curio.allowance(msg.sender,address(this)) >= _quantity,insufficient curio allowance) (AbstractWrapper.sol#648)\n"
        },
        {
          "name": "calls-loop",
          "vulnerability_from_line": 650,
          "vulnerability_to_line": null,
          "vulnerability_code": "            curio.transferFrom(msg.sender, address(this), _quantity);\n",
          "message": "AbstractWrapper.wrapBatch has external calls inside a loop:\n\t- curio.transferFrom(msg.sender,address(this),_quantity) (AbstractWrapper.sol#650)\n"
        },
        {
          "name": "calls-loop",
          "vulnerability_from_line": 699,
          "vulnerability_to_line": null,
          "vulnerability_code": "            curio.transfer(msg.sender, _quantity);\n",
          "message": "AbstractWrapper.unwrapBatch has external calls inside a loop:\n\t- curio.transfer(msg.sender,_quantity) (AbstractWrapper.sol#699)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 609,
          "vulnerability_to_line": 629,
          "vulnerability_code": "    function wrap(uint256 _id, uint256 _quantity) external {\n\n        address tokenContract = contracts[_id];\n\n        require(tokenContract != address(0), \"invalid id\");\n\n        ICurio curio = ICurio(tokenContract);\n\n\n\n        // these are here for convenience because curio contract doesn't throw meaningful exceptions\n\n        require(curio.balanceOf(msg.sender) >= _quantity, \"insufficient curio balance\");\n\n        require(curio.allowance(msg.sender, address(this)) >= _quantity, \"insufficient curio allowance\");\n\n        \n\n        curio.transferFrom(msg.sender, address(this), _quantity);\n\n\n\n        balances[_id][msg.sender] = balances[_id][msg.sender].add(_quantity);\n\n\n\n        // mint\n\n        emit TransferSingle(msg.sender, address(0), msg.sender, _id, _quantity);\n\n\n\n        address _to = msg.sender;\n\n        if (_to.isContract()) {\n\n           _doSafeTransferAcceptanceCheck(msg.sender, msg.sender, msg.sender, _id, _quantity, '');\n\n        }\n",
          "message": "Reentrancy in AbstractWrapper.wrap (AbstractWrapper.sol#609-629):\n\tExternal calls:\n\t- require(bool,string)(curio.balanceOf(msg.sender) >= _quantity,insufficient curio balance) (AbstractWrapper.sol#615)\n\t- require(bool,string)(curio.allowance(msg.sender,address(this)) >= _quantity,insufficient curio allowance) (AbstractWrapper.sol#616)\n\t- curio.transferFrom(msg.sender,address(this),_quantity) (AbstractWrapper.sol#618)\n\tState variables written after the call(s):\n\t- balances (AbstractWrapper.sol#620)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 634,
          "vulnerability_to_line": 662,
          "vulnerability_code": "    function wrapBatch(uint256[] calldata _ids, uint256[] calldata _quantities) external {\n\n        require(_ids.length == _quantities.length, \"ids and quantities must match\");\n\n\n\n        address _to = msg.sender;\n\n\n\n        for (uint256 i=0; i < _ids.length; ++i) {\n\n            uint256 _id = _ids[i];\n\n            uint256 _quantity = _quantities[i];\n\n\n\n            address tokenContract = contracts[_id];\n\n            require(tokenContract != address(0), \"invalid id\");\n\n            ICurio curio = ICurio(tokenContract);\n\n\n\n            require(curio.balanceOf(msg.sender) >= _quantity, \"insufficient curio balance\");\n\n            require(curio.allowance(msg.sender, address(this)) >= _quantity, \"insufficient curio allowance\");\n\n\n\n            curio.transferFrom(msg.sender, address(this), _quantity);\n\n\n\n            balances[_id][msg.sender] = balances[_id][msg.sender].add(_quantity);\n\n\n\n            // mint\n\n            // we are not doing a batch event because testnet opensea didn't recognize it\n\n            emit TransferSingle(msg.sender, address(0), msg.sender, _id, _quantity);\n\n\n\n            if (_to.isContract()) {\n\n                _doSafeTransferAcceptanceCheck(msg.sender, msg.sender, msg.sender, _id, _quantity, '');\n\n            }\n\n        }\n",
          "message": "Reentrancy in AbstractWrapper.wrapBatch (AbstractWrapper.sol#634-662):\n\tExternal calls:\n\t- require(bool,string)(curio.balanceOf(msg.sender) >= _quantity,insufficient curio balance) (AbstractWrapper.sol#647)\n\t- require(bool,string)(curio.allowance(msg.sender,address(this)) >= _quantity,insufficient curio allowance) (AbstractWrapper.sol#648)\n\t- curio.transferFrom(msg.sender,address(this),_quantity) (AbstractWrapper.sol#650)\n\tState variables written after the call(s):\n\t- balances (AbstractWrapper.sol#652)\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 73,
          "vulnerability_to_line": 84,
          "vulnerability_code": "    function isContract(address account) internal view returns (bool) {\n\n        uint256 size;\n\n        // XXX Currently there is no better way to check if there is a contract in an address\n\n        // than to check the size of the code at that address.\n\n        // See https://ethereum.stackexchange.com/a/14016/36603\n\n        // for more details about how this works.\n\n        // TODO Check this again before the Serenity release, because all addresses will be\n\n        // contracts then.\n\n        // solium-disable-next-line security/no-inline-assembly\n\n        assembly { size := extcodesize(account) }\n\n        return size > 0;\n",
          "message": "Address.isContract uses assembly (AbstractWrapper.sol#73-84)\n\t- AbstractWrapper.sol#82\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 459,
          "vulnerability_to_line": 461,
          "vulnerability_code": "    function isApprovedForAll(address _owner, address _operator) public view returns (bool) {\n\n        return operatorApproval[_owner][_operator];\n",
          "message": "ERC1155.isApprovedForAll (AbstractWrapper.sol#459-461) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 273,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function isApprovedForAll(address _owner, address _operator) external view returns (bool);\n",
          "message": "IERC1155.isApprovedForAll (AbstractWrapper.sol#273) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 157,
          "vulnerability_to_line": 160,
          "vulnerability_code": "    function supportsInterface(bytes4 _interfaceId)\n\n    external\n\n    view\n",
          "message": "ERC165.supportsInterface (AbstractWrapper.sol#157-160) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 313,
          "vulnerability_to_line": 323,
          "vulnerability_code": "    function supportsInterface(bytes4 _interfaceId)\n\n    public\n\n    view\n\n    returns (bool) {\n\n         if (_interfaceId == INTERFACE_SIGNATURE_ERC165 ||\n\n             _interfaceId == INTERFACE_SIGNATURE_ERC1155) {\n\n            return true;\n\n         }\n\n\n\n         return false;\n",
          "message": "ERC1155.supportsInterface (AbstractWrapper.sol#313-323) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 549,
          "vulnerability_to_line": 551,
          "vulnerability_code": "    function owner() public view returns (address) {\n\n        return _owner;\n",
          "message": "AbstractWrapper.owner (AbstractWrapper.sol#549-551) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 572,
          "vulnerability_to_line": 574,
          "vulnerability_code": "    function transferOwnership(address newOwner) public onlyOwner {\n\n        _transferOwnership(newOwner);\n",
          "message": "AbstractWrapper.transferOwnership (AbstractWrapper.sol#572-574) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 591,
          "vulnerability_to_line": 593,
          "vulnerability_code": "    function uri(uint256 _id) public view returns (string memory) {\n\n        return metadatas[_id];\n",
          "message": "AbstractWrapper.uri (AbstractWrapper.sol#591-593) should be declared external\n"
        },
        {
          "name": "solc-version",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.0;\n",
          "message": "Detected issues with version pragma in AbstractWrapper.sol:\n\t- pragma solidity^0.5.0 (AbstractWrapper.sol#3): it allows old versions\n\t- pragma solidity^0.5.0 (AbstractWrapper.sol#58): it allows old versions\n\t- pragma solidity^0.5.0 (AbstractWrapper.sol#90): it allows old versions\n\t- pragma solidity^0.5.0 (AbstractWrapper.sol#103): it allows old versions\n\t- pragma solidity^0.5.0 (AbstractWrapper.sol#142): it allows old versions\n\t- pragma solidity^0.5.0 (AbstractWrapper.sol#165): it allows old versions\n\t- pragma solidity^0.5.0 (AbstractWrapper.sol#278): it allows old versions\n\t- pragma solidity^0.5.0 (AbstractWrapper.sol#489): it allows old versions\n\t- pragma solidity^0.5.0 (AbstractWrapper.sol#502): it allows old versions\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 341,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function safeTransferFrom(address _from, address _to, uint256 _id, uint256 _value, bytes calldata _data) external {\n",
          "message": "Parameter '_from' of ERC1155.safeTransferFrom (AbstractWrapper.sol#341) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 341,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function safeTransferFrom(address _from, address _to, uint256 _id, uint256 _value, bytes calldata _data) external {\n",
          "message": "Parameter '_to' of ERC1155.safeTransferFrom (AbstractWrapper.sol#341) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 341,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function safeTransferFrom(address _from, address _to, uint256 _id, uint256 _value, bytes calldata _data) external {\n",
          "message": "Parameter '_id' of ERC1155.safeTransferFrom (AbstractWrapper.sol#341) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 341,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function safeTransferFrom(address _from, address _to, uint256 _id, uint256 _value, bytes calldata _data) external {\n",
          "message": "Parameter '_value' of ERC1155.safeTransferFrom (AbstractWrapper.sol#341) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 341,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function safeTransferFrom(address _from, address _to, uint256 _id, uint256 _value, bytes calldata _data) external {\n",
          "message": "Parameter '_data' of ERC1155.safeTransferFrom (AbstractWrapper.sol#341) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 377,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function safeBatchTransferFrom(address _from, address _to, uint256[] calldata _ids, uint256[] calldata _values, bytes calldata _data) external {\n",
          "message": "Parameter '_from' of ERC1155.safeBatchTransferFrom (AbstractWrapper.sol#377) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 377,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function safeBatchTransferFrom(address _from, address _to, uint256[] calldata _ids, uint256[] calldata _values, bytes calldata _data) external {\n",
          "message": "Parameter '_to' of ERC1155.safeBatchTransferFrom (AbstractWrapper.sol#377) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 377,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function safeBatchTransferFrom(address _from, address _to, uint256[] calldata _ids, uint256[] calldata _values, bytes calldata _data) external {\n",
          "message": "Parameter '_ids' of ERC1155.safeBatchTransferFrom (AbstractWrapper.sol#377) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 377,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function safeBatchTransferFrom(address _from, address _to, uint256[] calldata _ids, uint256[] calldata _values, bytes calldata _data) external {\n",
          "message": "Parameter '_values' of ERC1155.safeBatchTransferFrom (AbstractWrapper.sol#377) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 377,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function safeBatchTransferFrom(address _from, address _to, uint256[] calldata _ids, uint256[] calldata _values, bytes calldata _data) external {\n",
          "message": "Parameter '_data' of ERC1155.safeBatchTransferFrom (AbstractWrapper.sol#377) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 415,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function balanceOf(address _owner, uint256 _id) external view returns (uint256) {\n",
          "message": "Parameter '_owner' of ERC1155.balanceOf (AbstractWrapper.sol#415) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 415,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function balanceOf(address _owner, uint256 _id) external view returns (uint256) {\n",
          "message": "Parameter '_id' of ERC1155.balanceOf (AbstractWrapper.sol#415) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 429,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function balanceOfBatch(address[] calldata _owners, uint256[] calldata _ids) external view returns (uint256[] memory) {\n",
          "message": "Parameter '_owners' of ERC1155.balanceOfBatch (AbstractWrapper.sol#429) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 429,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function balanceOfBatch(address[] calldata _owners, uint256[] calldata _ids) external view returns (uint256[] memory) {\n",
          "message": "Parameter '_ids' of ERC1155.balanceOfBatch (AbstractWrapper.sol#429) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 448,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setApprovalForAll(address _operator, bool _approved) external {\n",
          "message": "Parameter '_operator' of ERC1155.setApprovalForAll (AbstractWrapper.sol#448) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 448,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setApprovalForAll(address _operator, bool _approved) external {\n",
          "message": "Parameter '_approved' of ERC1155.setApprovalForAll (AbstractWrapper.sol#448) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 459,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function isApprovedForAll(address _owner, address _operator) public view returns (bool) {\n",
          "message": "Parameter '_owner' of ERC1155.isApprovedForAll (AbstractWrapper.sol#459) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 459,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function isApprovedForAll(address _owner, address _operator) public view returns (bool) {\n",
          "message": "Parameter '_operator' of ERC1155.isApprovedForAll (AbstractWrapper.sol#459) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 313,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function supportsInterface(bytes4 _interfaceId)\n",
          "message": "Parameter '_interfaceId' of ERC1155.supportsInterface (AbstractWrapper.sol#313) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 465,
          "vulnerability_to_line": 474,
          "vulnerability_code": "    function _doSafeTransferAcceptanceCheck(address _operator, address _from, address _to, uint256 _id, uint256 _value, bytes memory _data) internal {\n\n\n\n        // If this was a hybrid standards solution you would have to check ERC165(_to).supportsInterface(0x4e2312e0) here but as this is a pure implementation of an ERC-1155 token set as recommended by\n\n        // the standard, it is not necessary. The below should revert in all failure cases i.e. _to isn't a receiver, or it is and either returns an unknown value or it reverts in the call to indicate non-acceptance.\n\n\n\n\n\n        // Note: if the below reverts in the onERC1155Received function of the _to address you will have an undefined revert reason returned rather than the one in the require test.\n\n        // If you want predictable revert reasons consider using low level _to.call() style instead so the revert does not bubble up and you can revert yourself on the ERC1155_ACCEPTED test.\n\n        require(ERC1155TokenReceiver(_to).onERC1155Received(_operator, _from, _id, _value, _data) == ERC1155_ACCEPTED, \"contract returned an unknown value from onERC1155Received\");\n",
          "message": "Function 'ERC1155._doSafeTransferAcceptanceCheck' (AbstractWrapper.sol#465-474) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 465,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _doSafeTransferAcceptanceCheck(address _operator, address _from, address _to, uint256 _id, uint256 _value, bytes memory _data) internal {\n",
          "message": "Parameter '_operator' of ERC1155._doSafeTransferAcceptanceCheck (AbstractWrapper.sol#465) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 465,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _doSafeTransferAcceptanceCheck(address _operator, address _from, address _to, uint256 _id, uint256 _value, bytes memory _data) internal {\n",
          "message": "Parameter '_from' of ERC1155._doSafeTransferAcceptanceCheck (AbstractWrapper.sol#465) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 465,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _doSafeTransferAcceptanceCheck(address _operator, address _from, address _to, uint256 _id, uint256 _value, bytes memory _data) internal {\n",
          "message": "Parameter '_to' of ERC1155._doSafeTransferAcceptanceCheck (AbstractWrapper.sol#465) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 465,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _doSafeTransferAcceptanceCheck(address _operator, address _from, address _to, uint256 _id, uint256 _value, bytes memory _data) internal {\n",
          "message": "Parameter '_id' of ERC1155._doSafeTransferAcceptanceCheck (AbstractWrapper.sol#465) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 465,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _doSafeTransferAcceptanceCheck(address _operator, address _from, address _to, uint256 _id, uint256 _value, bytes memory _data) internal {\n",
          "message": "Parameter '_value' of ERC1155._doSafeTransferAcceptanceCheck (AbstractWrapper.sol#465) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 465,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _doSafeTransferAcceptanceCheck(address _operator, address _from, address _to, uint256 _id, uint256 _value, bytes memory _data) internal {\n",
          "message": "Parameter '_data' of ERC1155._doSafeTransferAcceptanceCheck (AbstractWrapper.sol#465) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 476,
          "vulnerability_to_line": 484,
          "vulnerability_code": "    function _doSafeBatchTransferAcceptanceCheck(address _operator, address _from, address _to, uint256[] memory _ids, uint256[] memory _values, bytes memory _data) internal {\n\n\n\n        // If this was a hybrid standards solution you would have to check ERC165(_to).supportsInterface(0x4e2312e0) here but as this is a pure implementation of an ERC-1155 token set as recommended by\n\n        // the standard, it is not necessary. The below should revert in all failure cases i.e. _to isn't a receiver, or it is and either returns an unknown value or it reverts in the call to indicate non-acceptance.\n\n\n\n        // Note: if the below reverts in the onERC1155BatchReceived function of the _to address you will have an undefined revert reason returned rather than the one in the require test.\n\n        // If you want predictable revert reasons consider using low level _to.call() style instead so the revert does not bubble up and you can revert yourself on the ERC1155_BATCH_ACCEPTED test.\n\n        require(ERC1155TokenReceiver(_to).onERC1155BatchReceived(_operator, _from, _ids, _values, _data) == ERC1155_BATCH_ACCEPTED, \"contract returned an unknown value from onERC1155BatchReceived\");\n",
          "message": "Function 'ERC1155._doSafeBatchTransferAcceptanceCheck' (AbstractWrapper.sol#476-484) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 476,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _doSafeBatchTransferAcceptanceCheck(address _operator, address _from, address _to, uint256[] memory _ids, uint256[] memory _values, bytes memory _data) internal {\n",
          "message": "Parameter '_operator' of ERC1155._doSafeBatchTransferAcceptanceCheck (AbstractWrapper.sol#476) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 476,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _doSafeBatchTransferAcceptanceCheck(address _operator, address _from, address _to, uint256[] memory _ids, uint256[] memory _values, bytes memory _data) internal {\n",
          "message": "Parameter '_from' of ERC1155._doSafeBatchTransferAcceptanceCheck (AbstractWrapper.sol#476) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 476,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _doSafeBatchTransferAcceptanceCheck(address _operator, address _from, address _to, uint256[] memory _ids, uint256[] memory _values, bytes memory _data) internal {\n",
          "message": "Parameter '_to' of ERC1155._doSafeBatchTransferAcceptanceCheck (AbstractWrapper.sol#476) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 476,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _doSafeBatchTransferAcceptanceCheck(address _operator, address _from, address _to, uint256[] memory _ids, uint256[] memory _values, bytes memory _data) internal {\n",
          "message": "Parameter '_ids' of ERC1155._doSafeBatchTransferAcceptanceCheck (AbstractWrapper.sol#476) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 476,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _doSafeBatchTransferAcceptanceCheck(address _operator, address _from, address _to, uint256[] memory _ids, uint256[] memory _values, bytes memory _data) internal {\n",
          "message": "Parameter '_values' of ERC1155._doSafeBatchTransferAcceptanceCheck (AbstractWrapper.sol#476) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 476,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _doSafeBatchTransferAcceptanceCheck(address _operator, address _from, address _to, uint256[] memory _ids, uint256[] memory _values, bytes memory _data) internal {\n",
          "message": "Parameter '_data' of ERC1155._doSafeBatchTransferAcceptanceCheck (AbstractWrapper.sol#476) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 497,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function ipfs_hash() external view returns (string memory);\n",
          "message": "Function 'ICurio.ipfs_hash' (AbstractWrapper.sol#497) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 528,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function create(uint256 _id, address _contract, string memory _uri) internal {\n",
          "message": "Parameter '_id' of AbstractWrapper.create (AbstractWrapper.sol#528) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 528,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function create(uint256 _id, address _contract, string memory _uri) internal {\n",
          "message": "Parameter '_contract' of AbstractWrapper.create (AbstractWrapper.sol#528) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 528,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function create(uint256 _id, address _contract, string memory _uri) internal {\n",
          "message": "Parameter '_uri' of AbstractWrapper.create (AbstractWrapper.sol#528) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 540,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor(address _proxyRegistryAddress) public {\n",
          "message": "Parameter '_proxyRegistryAddress' of AbstractWrapper. (AbstractWrapper.sol#540) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 580,
          "vulnerability_to_line": 584,
          "vulnerability_code": "    function _transferOwnership(address newOwner) internal {\n\n        require(newOwner != address(0));\n\n        emit OwnershipTransferred(_owner, newOwner);\n\n        _owner = newOwner;\n",
          "message": "Function 'AbstractWrapper._transferOwnership' (AbstractWrapper.sol#580-584) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 591,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function uri(uint256 _id) public view returns (string memory) {\n",
          "message": "Parameter '_id' of AbstractWrapper.uri (AbstractWrapper.sol#591) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 600,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function exists(uint256 _id) external view returns(bool) {\n",
          "message": "Parameter '_id' of AbstractWrapper.exists (AbstractWrapper.sol#600) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 609,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function wrap(uint256 _id, uint256 _quantity) external {\n",
          "message": "Parameter '_id' of AbstractWrapper.wrap (AbstractWrapper.sol#609) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 609,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function wrap(uint256 _id, uint256 _quantity) external {\n",
          "message": "Parameter '_quantity' of AbstractWrapper.wrap (AbstractWrapper.sol#609) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 634,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function wrapBatch(uint256[] calldata _ids, uint256[] calldata _quantities) external {\n",
          "message": "Parameter '_ids' of AbstractWrapper.wrapBatch (AbstractWrapper.sol#634) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 634,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function wrapBatch(uint256[] calldata _ids, uint256[] calldata _quantities) external {\n",
          "message": "Parameter '_quantities' of AbstractWrapper.wrapBatch (AbstractWrapper.sol#634) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 668,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function unwrap(uint256 _id, uint256 _quantity) external {\n",
          "message": "Parameter '_id' of AbstractWrapper.unwrap (AbstractWrapper.sol#668) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 668,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function unwrap(uint256 _id, uint256 _quantity) external {\n",
          "message": "Parameter '_quantity' of AbstractWrapper.unwrap (AbstractWrapper.sol#668) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 685,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function unwrapBatch(uint256[] calldata _ids, uint256[] calldata _quantities) external {\n",
          "message": "Parameter '_ids' of AbstractWrapper.unwrapBatch (AbstractWrapper.sol#685) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 685,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function unwrapBatch(uint256[] calldata _ids, uint256[] calldata _quantities) external {\n",
          "message": "Parameter '_quantities' of AbstractWrapper.unwrapBatch (AbstractWrapper.sol#685) is not in mixedCase\n"
        }
      ]
    },
    "smartcheck": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 97,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bytes4 constant internal ERC1155_ACCEPTED = 0xf23a6e61; // bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 98,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bytes4 constant internal ERC1155_BATCH_ACCEPTED = 0xbc197c81; // bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 301,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bytes4 constant private INTERFACE_SIGNATURE_ERC165 = 0x01ffc9a7;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 311,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bytes4 constant private INTERFACE_SIGNATURE_ERC1155 = 0xd9b67a26;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 343,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_to != address(0x0), \"_to must be non-zero.\");\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 639,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 i=0; i < _ids.length; ++i) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 688,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 i=0; i < _ids.length; ++i) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 639,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 i=0; i < _ids.length; ++i) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 688,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 i=0; i < _ids.length; ++i) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 58,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 90,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 103,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 142,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 165,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 278,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 489,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 502,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 301,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bytes4 constant private INTERFACE_SIGNATURE_ERC165 = 0x01ffc9a7;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 311,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bytes4 constant private INTERFACE_SIGNATURE_ERC1155 = 0xd9b67a26;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 511,
          "vulnerability_to_line": null,
          "vulnerability_code": "    address private _owner;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SAFEMATH",
          "vulnerability_from_line": 287,
          "vulnerability_to_line": null,
          "vulnerability_code": "    using SafeMath for uint256;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SAFEMATH",
          "vulnerability_from_line": 508,
          "vulnerability_to_line": null,
          "vulnerability_code": "    using SafeMath for uint256;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
          "vulnerability_from_line": 73,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function isContract(address account) internal view returns (bool) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 137,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function onERC1155BatchReceived(address _operator, address _from, uint256[] calldata _ids, uint256[] calldata _values, bytes calldata _data) external returns(bytes4);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 241,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function safeBatchTransferFrom(address _from, address _to, uint256[] calldata _ids, uint256[] calldata _values, bytes calldata _data) external;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 377,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function safeBatchTransferFrom(address _from, address _to, uint256[] calldata _ids, uint256[] calldata _values, bytes calldata _data) external {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 137,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function onERC1155BatchReceived(address _operator, address _from, uint256[] calldata _ids, uint256[] calldata _values, bytes calldata _data) external returns(bytes4);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 137,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function onERC1155BatchReceived(address _operator, address _from, uint256[] calldata _ids, uint256[] calldata _values, bytes calldata _data) external returns(bytes4);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 137,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function onERC1155BatchReceived(address _operator, address _from, uint256[] calldata _ids, uint256[] calldata _values, bytes calldata _data) external returns(bytes4);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 137,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function onERC1155BatchReceived(address _operator, address _from, uint256[] calldata _ids, uint256[] calldata _values, bytes calldata _data) external returns(bytes4);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 137,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function onERC1155BatchReceived(address _operator, address _from, uint256[] calldata _ids, uint256[] calldata _values, bytes calldata _data) external returns(bytes4);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 241,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function safeBatchTransferFrom(address _from, address _to, uint256[] calldata _ids, uint256[] calldata _values, bytes calldata _data) external;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 241,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function safeBatchTransferFrom(address _from, address _to, uint256[] calldata _ids, uint256[] calldata _values, bytes calldata _data) external;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 241,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function safeBatchTransferFrom(address _from, address _to, uint256[] calldata _ids, uint256[] calldata _values, bytes calldata _data) external;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 241,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function safeBatchTransferFrom(address _from, address _to, uint256[] calldata _ids, uint256[] calldata _values, bytes calldata _data) external;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 377,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function safeBatchTransferFrom(address _from, address _to, uint256[] calldata _ids, uint256[] calldata _values, bytes calldata _data) external {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 377,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function safeBatchTransferFrom(address _from, address _to, uint256[] calldata _ids, uint256[] calldata _values, bytes calldata _data) external {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 377,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function safeBatchTransferFrom(address _from, address _to, uint256[] calldata _ids, uint256[] calldata _values, bytes calldata _data) external {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 377,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function safeBatchTransferFrom(address _from, address _to, uint256[] calldata _ids, uint256[] calldata _values, bytes calldata _data) external {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 380,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_to != address(0x0), \"destination address must be non-zero.\");\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 380,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_to != address(0x0), \"destination address must be non-zero.\");\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 380,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_to != address(0x0), \"destination address must be non-zero.\");\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 381,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_ids.length == _values.length, \"_ids and _values array length must match.\");\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 381,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_ids.length == _values.length, \"_ids and _values array length must match.\");\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 381,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_ids.length == _values.length, \"_ids and _values array length must match.\");\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 382,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_from == msg.sender || operatorApproval[_from][msg.sender] == true, \"Need operator approval for 3rd party transfers.\");\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 382,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_from == msg.sender || operatorApproval[_from][msg.sender] == true, \"Need operator approval for 3rd party transfers.\");\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 382,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_from == msg.sender || operatorApproval[_from][msg.sender] == true, \"Need operator approval for 3rd party transfers.\");\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 382,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_from == msg.sender || operatorApproval[_from][msg.sender] == true, \"Need operator approval for 3rd party transfers.\");\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 384,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 i = 0; i < _ids.length; ++i) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 384,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 i = 0; i < _ids.length; ++i) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 384,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 i = 0; i < _ids.length; ++i) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 384,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 i = 0; i < _ids.length; ++i) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 385,
          "vulnerability_to_line": null,
          "vulnerability_code": "            uint256 id = _ids[i];\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 386,
          "vulnerability_to_line": null,
          "vulnerability_code": "            uint256 value = _values[i];\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 390,
          "vulnerability_to_line": null,
          "vulnerability_code": "            balances[id][_from] = balances[id][_from].sub(value);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 390,
          "vulnerability_to_line": null,
          "vulnerability_code": "            balances[id][_from] = balances[id][_from].sub(value);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 390,
          "vulnerability_to_line": null,
          "vulnerability_code": "            balances[id][_from] = balances[id][_from].sub(value);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 390,
          "vulnerability_to_line": null,
          "vulnerability_code": "            balances[id][_from] = balances[id][_from].sub(value);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 391,
          "vulnerability_to_line": null,
          "vulnerability_code": "            balances[id][_to]   = value.add(balances[id][_to]);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 391,
          "vulnerability_to_line": null,
          "vulnerability_code": "            balances[id][_to]   = value.add(balances[id][_to]);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 391,
          "vulnerability_to_line": null,
          "vulnerability_code": "            balances[id][_to]   = value.add(balances[id][_to]);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 391,
          "vulnerability_to_line": null,
          "vulnerability_code": "            balances[id][_to]   = value.add(balances[id][_to]);\n",
          "message": null
        }
      ]
    },
    "oyente": {
      "successfull_analysis": false,
      "errors": [
        "exception (RuntimeError: Source map error, unknown name(SHR) or instr_name(INVALID))"
      ],
      "vulnerability_findings": []
    },
    "mythril": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "Exception State (SWC 110)",
          "vulnerability_from_line": 348,
          "vulnerability_to_line": null,
          "vulnerability_code": "        balances[_id][_from] = balances[_id][_from].sub(_value);\n",
          "message": "An assertion violation was triggered.\nIt is possible to trigger an assertion violation. Note that Solidity assert() statements should only be used to check invariants. Review the transaction trace generated for this issue and either make sure your program logic is correct, or use require() instead of assert() if your goal is to constrain user inputs or enforce preconditions. Remember to validate inputs from both callers (for instance, via passed arguments) and callees (for instance, via return values).\nClassification: SWC-110"
        }
      ]
    },
    "osiris": {
      "successfull_analysis": false,
      "errors": [
        "Solidity compilation failed"
      ],
      "vulnerability_findings": []
    }
  }
}