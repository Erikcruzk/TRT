{
  "smartbugs_completed": "No vulnerabilities found",
  "analyzer_results": {
    "semgrep": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 49,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 i = 0; i < _owners.length; i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 54,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(owners[owner] == address(0), \"Duplicate owner address provided\");\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 55,
          "vulnerability_to_line": null,
          "vulnerability_code": "            owners[currentOwner] = owner;\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 175,
          "vulnerability_to_line": null,
          "vulnerability_code": "            currentOwner = owners[currentOwner];\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 49,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 i = 0; i < _owners.length; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 10,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == address(this), \"Method can only be called from this contract\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 42,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(threshold == 0, \"Owners have already been setup\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 44,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_threshold <= _owners.length, \"Threshold cannot exceed owner count\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 46,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_threshold >= 1, \"Threshold needs to be greater than 0\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 52,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(owner != address(0) && owner != SENTINEL_OWNERS, \"Invalid owner address provided\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 54,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(owners[owner] == address(0), \"Duplicate owner address provided\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 72,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(owner != address(0) && owner != SENTINEL_OWNERS, \"Invalid owner address provided\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 74,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(owners[owner] == address(0), \"Address is already an owner\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 94,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(ownerCount - 1 >= _threshold, \"New owner count needs to be larger than new threshold\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 96,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(owner != address(0) && owner != SENTINEL_OWNERS, \"Invalid owner address provided\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 97,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(owners[prevOwner] == owner, \"Invalid prevOwner, owner pair provided\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 117,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(newOwner != address(0) && newOwner != SENTINEL_OWNERS, \"Invalid owner address provided\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 119,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(owners[newOwner] == address(0), \"Address is already an owner\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 121,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(oldOwner != address(0) && oldOwner != SENTINEL_OWNERS, \"Invalid owner address provided\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 122,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(owners[prevOwner] == oldOwner, \"Invalid prevOwner, owner pair provided\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 138,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_threshold <= ownerCount, \"Threshold cannot exceed owner count\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 140,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_threshold >= 1, \"Threshold needs to be greater than 0\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 52,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(owner != address(0) && owner != SENTINEL_OWNERS, \"Invalid owner address provided\");\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 72,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(owner != address(0) && owner != SENTINEL_OWNERS, \"Invalid owner address provided\");\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 96,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(owner != address(0) && owner != SENTINEL_OWNERS, \"Invalid owner address provided\");\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 117,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(newOwner != address(0) && newOwner != SENTINEL_OWNERS, \"Invalid owner address provided\");\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 121,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(oldOwner != address(0) && oldOwner != SENTINEL_OWNERS, \"Invalid owner address provided\");\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-prefix-decrement-not-postfix",
          "vulnerability_from_line": 100,
          "vulnerability_to_line": null,
          "vulnerability_code": "        ownerCount--;\n",
          "message": "Consider using the prefix decrement expression whenever the return value is not needed. The prefix decrement expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 49,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 i = 0; i < _owners.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 77,
          "vulnerability_to_line": null,
          "vulnerability_code": "        ownerCount++;\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 176,
          "vulnerability_to_line": null,
          "vulnerability_code": "            index ++;\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 10,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == address(this), \"Method can only be called from this contract\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 44,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_threshold <= _owners.length, \"Threshold cannot exceed owner count\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 46,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_threshold >= 1, \"Threshold needs to be greater than 0\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 94,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(ownerCount - 1 >= _threshold, \"New owner count needs to be larger than new threshold\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 97,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(owners[prevOwner] == owner, \"Invalid prevOwner, owner pair provided\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 122,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(owners[prevOwner] == oldOwner, \"Invalid prevOwner, owner pair provided\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 138,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_threshold <= ownerCount, \"Threshold cannot exceed owner count\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 140,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_threshold >= 1, \"Threshold needs to be greater than 0\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        }
      ]
    },
    "slither": {
      "successfull_analysis": true,
      "errors": [
        "EXIT_CODE_12"
      ],
      "vulnerability_findings": [
        {
          "name": "external-function",
          "vulnerability_from_line": 67,
          "vulnerability_to_line": 82,
          "vulnerability_code": "    function addOwnerWithThreshold(address owner, uint256 _threshold)\n\n        public\n\n        authorized\n\n    {\n\n        // Owner address cannot be null.\n\n        require(owner != address(0) && owner != SENTINEL_OWNERS, \"Invalid owner address provided\");\n\n        // No duplicate owners allowed.\n\n        require(owners[owner] == address(0), \"Address is already an owner\");\n\n        owners[owner] = owners[SENTINEL_OWNERS];\n\n        owners[SENTINEL_OWNERS] = owner;\n\n        ownerCount++;\n\n        emit AddedOwner(owner);\n\n        // Change threshold if threshold was changed.\n\n        if (threshold != _threshold)\n\n            changeThreshold(_threshold);\n",
          "message": "OwnerManager.addOwnerWithThreshold (OwnerManager.sol#67-82) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 89,
          "vulnerability_to_line": 105,
          "vulnerability_code": "    function removeOwner(address prevOwner, address owner, uint256 _threshold)\n\n        public\n\n        authorized\n\n    {\n\n        // Only allow to remove an owner, if threshold can still be reached.\n\n        require(ownerCount - 1 >= _threshold, \"New owner count needs to be larger than new threshold\");\n\n        // Validate owner address and check that it corresponds to owner index.\n\n        require(owner != address(0) && owner != SENTINEL_OWNERS, \"Invalid owner address provided\");\n\n        require(owners[prevOwner] == owner, \"Invalid prevOwner, owner pair provided\");\n\n        owners[prevOwner] = owners[owner];\n\n        owners[owner] = address(0);\n\n        ownerCount--;\n\n        emit RemovedOwner(owner);\n\n        // Change threshold if threshold was changed.\n\n        if (threshold != _threshold)\n\n            changeThreshold(_threshold);\n",
          "message": "OwnerManager.removeOwner (OwnerManager.sol#89-105) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 112,
          "vulnerability_to_line": 128,
          "vulnerability_code": "    function swapOwner(address prevOwner, address oldOwner, address newOwner)\n\n        public\n\n        authorized\n\n    {\n\n        // Owner address cannot be null.\n\n        require(newOwner != address(0) && newOwner != SENTINEL_OWNERS, \"Invalid owner address provided\");\n\n        // No duplicate owners allowed.\n\n        require(owners[newOwner] == address(0), \"Address is already an owner\");\n\n        // Validate oldOwner address and check that it corresponds to owner index.\n\n        require(oldOwner != address(0) && oldOwner != SENTINEL_OWNERS, \"Invalid owner address provided\");\n\n        require(owners[prevOwner] == oldOwner, \"Invalid prevOwner, owner pair provided\");\n\n        owners[newOwner] = owners[oldOwner];\n\n        owners[prevOwner] = newOwner;\n\n        owners[oldOwner] = address(0);\n\n        emit RemovedOwner(oldOwner);\n\n        emit AddedOwner(newOwner);\n",
          "message": "OwnerManager.swapOwner (OwnerManager.sol#112-128) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 145,
          "vulnerability_to_line": 151,
          "vulnerability_code": "    function getThreshold()\n\n        public\n\n        view\n\n        returns (uint256)\n\n    {\n\n        return threshold;\n",
          "message": "OwnerManager.getThreshold (OwnerManager.sol#145-151) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 153,
          "vulnerability_to_line": 159,
          "vulnerability_code": "    function isOwner(address owner)\n\n        public\n\n        view\n\n        returns (bool)\n\n    {\n\n        return owner != SENTINEL_OWNERS && owners[owner] != address(0);\n",
          "message": "OwnerManager.isOwner (OwnerManager.sol#153-159) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 163,
          "vulnerability_to_line": 179,
          "vulnerability_code": "    function getOwners()\n\n        public\n\n        view\n\n        returns (address[] memory)\n\n    {\n\n        address[] memory array = new address[](ownerCount);\n\n\n\n        // populate return array\n\n        uint256 index = 0;\n\n        address currentOwner = owners[SENTINEL_OWNERS];\n\n        while(currentOwner != SENTINEL_OWNERS) {\n\n            array[index] = currentOwner;\n\n            currentOwner = owners[currentOwner];\n\n            index ++;\n\n        }\n\n        return array;\n",
          "message": "OwnerManager.getOwners (OwnerManager.sol#163-179) should be declared external\n"
        },
        {
          "name": "solc-version",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.0;\n",
          "message": "Detected issues with version pragma in OwnerManager.sol:\n\t- pragma solidity^0.5.0 (OwnerManager.sol#3): it allows old versions\n\t- pragma solidity^0.5.0 (OwnerManager.sol#17): it allows old versions\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 37,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setupOwners(address[] memory _owners, uint256 _threshold)\n",
          "message": "Parameter '_owners' of OwnerManager.setupOwners (OwnerManager.sol#37) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 37,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setupOwners(address[] memory _owners, uint256 _threshold)\n",
          "message": "Parameter '_threshold' of OwnerManager.setupOwners (OwnerManager.sol#37) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 67,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function addOwnerWithThreshold(address owner, uint256 _threshold)\n",
          "message": "Parameter '_threshold' of OwnerManager.addOwnerWithThreshold (OwnerManager.sol#67) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 89,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function removeOwner(address prevOwner, address owner, uint256 _threshold)\n",
          "message": "Parameter '_threshold' of OwnerManager.removeOwner (OwnerManager.sol#89) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 133,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function changeThreshold(uint256 _threshold)\n",
          "message": "Parameter '_threshold' of OwnerManager.changeThreshold (OwnerManager.sol#133) is not in mixedCase\n"
        }
      ]
    },
    "smartcheck": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 28,
          "vulnerability_to_line": null,
          "vulnerability_code": "    address public constant SENTINEL_OWNERS = address(0x1);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 99,
          "vulnerability_to_line": null,
          "vulnerability_code": "        owners[owner] = address(0);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 125,
          "vulnerability_to_line": null,
          "vulnerability_code": "        owners[oldOwner] = address(0);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 49,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 i = 0; i < _owners.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 173,
          "vulnerability_to_line": null,
          "vulnerability_code": "        while(currentOwner != SENTINEL_OWNERS) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 49,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 i = 0; i < _owners.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 173,
          "vulnerability_to_line": null,
          "vulnerability_code": "        while(currentOwner != SENTINEL_OWNERS) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 17,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 31,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint256 ownerCount;\n",
          "message": null
        }
      ]
    },
    "oyente": {
      "successfull_analysis": false,
      "errors": [
        "exception (RuntimeError: Source map error, unknown name(SHR) or instr_name(INVALID))"
      ],
      "vulnerability_findings": []
    },
    "mythril": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "Exception State (SWC 110)",
          "vulnerability_from_line": 163,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getOwners()\n",
          "message": "An assertion violation was triggered.\nIt is possible to trigger an assertion violation. Note that Solidity assert() statements should only be used to check invariants. Review the transaction trace generated for this issue and either make sure your program logic is correct, or use require() instead of assert() if your goal is to constrain user inputs or enforce preconditions. Remember to validate inputs from both callers (for instance, via passed arguments) and callees (for instance, via return values).\nClassification: SWC-110"
        }
      ]
    },
    "osiris": {
      "successfull_analysis": false,
      "errors": [
        "Solidity compilation failed"
      ],
      "vulnerability_findings": []
    }
  }
}