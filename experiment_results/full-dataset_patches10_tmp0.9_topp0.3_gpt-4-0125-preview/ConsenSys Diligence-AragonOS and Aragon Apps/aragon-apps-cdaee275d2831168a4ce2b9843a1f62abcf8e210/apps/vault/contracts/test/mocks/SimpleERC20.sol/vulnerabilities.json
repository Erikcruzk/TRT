{
  "smartbugs_completed": true,
  "analyzer_results": {
    "semgrep": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 17,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor() public {\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 18,
          "vulnerability_to_line": null,
          "vulnerability_code": "        balances[msg.sender] = _totalSupply;\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 19,
          "vulnerability_to_line": null,
          "vulnerability_code": "    }\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 33,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (balances[msg.sender] >= _amount\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 34,
          "vulnerability_to_line": null,
          "vulnerability_code": "            && _amount > 0\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 35,
          "vulnerability_to_line": null,
          "vulnerability_code": "            && balances[_to] + _amount > balances[_to]) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 36,
          "vulnerability_to_line": null,
          "vulnerability_code": "            balances[msg.sender] -= _amount;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 37,
          "vulnerability_to_line": null,
          "vulnerability_code": "            balances[_to] += _amount;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 38,
          "vulnerability_to_line": null,
          "vulnerability_code": "            return true;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 39,
          "vulnerability_to_line": null,
          "vulnerability_code": "        } else {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 40,
          "vulnerability_to_line": null,
          "vulnerability_code": "            return false;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 41,
          "vulnerability_to_line": null,
          "vulnerability_code": "        }\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 59,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (balances[_from] >= _amount\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 60,
          "vulnerability_to_line": null,
          "vulnerability_code": "            && allowed[_from][msg.sender] >= _amount\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 61,
          "vulnerability_to_line": null,
          "vulnerability_code": "            && _amount > 0\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 62,
          "vulnerability_to_line": null,
          "vulnerability_code": "            && balances[_to] + _amount > balances[_to]) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 63,
          "vulnerability_to_line": null,
          "vulnerability_code": "            balances[_from] -= _amount;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 64,
          "vulnerability_to_line": null,
          "vulnerability_code": "            allowed[_from][msg.sender] -= _amount;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 65,
          "vulnerability_to_line": null,
          "vulnerability_code": "            balances[_to] += _amount;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 66,
          "vulnerability_to_line": null,
          "vulnerability_code": "            return true;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 67,
          "vulnerability_to_line": null,
          "vulnerability_code": "        } else {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 68,
          "vulnerability_to_line": null,
          "vulnerability_code": "            return false;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        }
      ]
    },
    "slither": {
      "successfull_analysis": true,
      "errors": [
        "EXIT_CODE_18"
      ],
      "vulnerability_findings": [
        {
          "name": "constable-states",
          "vulnerability_from_line": 10,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint256 public _totalSupply = 10**9 * 10**18;\n",
          "message": "SimpleERC20._totalSupply should be constant (SimpleERC20.sol#10)\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 21,
          "vulnerability_to_line": 23,
          "vulnerability_code": "    function totalSupply() public view returns (uint ts) {\n\n        ts = _totalSupply;\n",
          "message": "SimpleERC20.totalSupply (SimpleERC20.sol#21-23) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 26,
          "vulnerability_to_line": 28,
          "vulnerability_code": "    function balanceOf(address _owner) public view returns (uint256 balance) {\n\n        return balances[_owner];\n",
          "message": "SimpleERC20.balanceOf (SimpleERC20.sol#26-28) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 31,
          "vulnerability_to_line": 42,
          "vulnerability_code": "    function transfer(address _to, uint256 _amount) public returns (bool success) {\n\n        /* solium-disable-next-line */\n\n        if (balances[msg.sender] >= _amount\n\n            && _amount > 0\n\n            && balances[_to] + _amount > balances[_to]) {\n\n            balances[msg.sender] -= _amount;\n\n            balances[_to] += _amount;\n\n            return true;\n\n        } else {\n\n            return false;\n\n        }\n",
          "message": "SimpleERC20.transfer (SimpleERC20.sol#31-42) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 50,
          "vulnerability_to_line": 70,
          "vulnerability_code": "    function transferFrom(\n\n        address _from,\n\n        address _to,\n\n        uint256 _amount\n\n    )\n\n        public\n\n        returns (bool success)\n\n    {\n\n        /* solium-disable-next-line */\n\n        if (balances[_from] >= _amount\n\n            && allowed[_from][msg.sender] >= _amount\n\n            && _amount > 0\n\n            && balances[_to] + _amount > balances[_to]) {\n\n            balances[_from] -= _amount;\n\n            allowed[_from][msg.sender] -= _amount;\n\n            balances[_to] += _amount;\n\n            return true;\n\n        } else {\n\n            return false;\n\n        }\n",
          "message": "SimpleERC20.transferFrom (SimpleERC20.sol#50-70) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 74,
          "vulnerability_to_line": 77,
          "vulnerability_code": "    function approve(address _spender, uint256 _amount) public returns (bool success) {\n\n        allowed[msg.sender][_spender] = _amount;\n\n        return true;\n",
          "message": "SimpleERC20.approve (SimpleERC20.sol#74-77) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 80,
          "vulnerability_to_line": 82,
          "vulnerability_code": "    function allowance(address _owner, address _spender) public view returns (uint remaining) {\n\n        remaining = allowed[_owner][_spender];\n",
          "message": "SimpleERC20.allowance (SimpleERC20.sol#80-82) should be declared external\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 26,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function balanceOf(address _owner) public view returns (uint256 balance) {\n",
          "message": "Parameter '_owner' of SimpleERC20.balanceOf (SimpleERC20.sol#26) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 31,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function transfer(address _to, uint256 _amount) public returns (bool success) {\n",
          "message": "Parameter '_to' of SimpleERC20.transfer (SimpleERC20.sol#31) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 31,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function transfer(address _to, uint256 _amount) public returns (bool success) {\n",
          "message": "Parameter '_amount' of SimpleERC20.transfer (SimpleERC20.sol#31) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 51,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address _from,\n",
          "message": "Parameter '_from' of SimpleERC20.transferFrom (SimpleERC20.sol#51) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 52,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address _to,\n",
          "message": "Parameter '_to' of SimpleERC20.transferFrom (SimpleERC20.sol#52) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 53,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint256 _amount\n",
          "message": "Parameter '_amount' of SimpleERC20.transferFrom (SimpleERC20.sol#53) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 74,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function approve(address _spender, uint256 _amount) public returns (bool success) {\n",
          "message": "Parameter '_spender' of SimpleERC20.approve (SimpleERC20.sol#74) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 74,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function approve(address _spender, uint256 _amount) public returns (bool success) {\n",
          "message": "Parameter '_amount' of SimpleERC20.approve (SimpleERC20.sol#74) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 80,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function allowance(address _owner, address _spender) public view returns (uint remaining) {\n",
          "message": "Parameter '_owner' of SimpleERC20.allowance (SimpleERC20.sol#80) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 80,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function allowance(address _owner, address _spender) public view returns (uint remaining) {\n",
          "message": "Parameter '_spender' of SimpleERC20.allowance (SimpleERC20.sol#80) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 10,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint256 public _totalSupply = 10**9 * 10**18;\n",
          "message": "Variable 'SimpleERC20._totalSupply' (SimpleERC20.sol#10) is not in mixedCase\n"
        }
      ]
    },
    "smartcheck": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "SOLIDITY_ERC20_APPROVE",
          "vulnerability_from_line": 74,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function approve(address _spender, uint256 _amount) public returns (bool success) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ERC20_TRANSFER_SHOULD_THROW",
          "vulnerability_from_line": 31,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function transfer(address _to, uint256 _amount) public returns (bool success) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ERC20_TRANSFER_SHOULD_THROW",
          "vulnerability_from_line": 50,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function transferFrom(\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 12,
          "vulnerability_to_line": null,
          "vulnerability_code": "    mapping(address => uint256) private balances;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 14,
          "vulnerability_to_line": null,
          "vulnerability_code": "    mapping(address => mapping (address => uint256)) private allowed;\n",
          "message": null
        }
      ]
    },
    "oyente": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "Integer Overflow",
          "vulnerability_from_line": 62,
          "vulnerability_to_line": null,
          "vulnerability_code": "            && balances[_to] + _amount > balances[_to]) {\n",
          "message": null
        }
      ]
    },
    "mythril": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": []
    },
    "osiris": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": []
    }
  }
}