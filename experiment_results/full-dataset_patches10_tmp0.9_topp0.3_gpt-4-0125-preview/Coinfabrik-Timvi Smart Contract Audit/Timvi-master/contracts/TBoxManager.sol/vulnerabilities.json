{
  "smartbugs_completed": true,
  "analyzer_results": {
    "semgrep": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 196,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor () internal {\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 197,
          "vulnerability_to_line": null,
          "vulnerability_code": "        _registerInterface(_InterfaceId_ERC165);\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 198,
          "vulnerability_to_line": null,
          "vulnerability_code": "    }\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 262,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor () public {\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 263,
          "vulnerability_to_line": null,
          "vulnerability_code": "        // register the supported interfaces to conform to ERC721 via ERC165\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 264,
          "vulnerability_to_line": null,
          "vulnerability_code": "        _registerInterface(_InterfaceId_ERC721);\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 265,
          "vulnerability_to_line": null,
          "vulnerability_code": "    }\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 548,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor () public {\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 549,
          "vulnerability_to_line": null,
          "vulnerability_code": "        // register the supported interface to conform to ERC721 via ERC165\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 550,
          "vulnerability_to_line": null,
          "vulnerability_code": "        _registerInterface(_InterfaceId_ERC721Enumerable);\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 551,
          "vulnerability_to_line": null,
          "vulnerability_code": "    }\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 703,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor (string memory name, string memory symbol) public {\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 704,
          "vulnerability_to_line": null,
          "vulnerability_code": "        _name = name;\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 705,
          "vulnerability_to_line": null,
          "vulnerability_code": "        _symbol = symbol;\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 706,
          "vulnerability_to_line": null,
          "vulnerability_code": "\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 707,
          "vulnerability_to_line": null,
          "vulnerability_code": "        // register the supported interfaces to conform to ERC721 via ERC165\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 708,
          "vulnerability_to_line": null,
          "vulnerability_code": "        _registerInterface(InterfaceId_ERC721Metadata);\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 709,
          "vulnerability_to_line": null,
          "vulnerability_code": "    }\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 777,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor (string memory name, string memory symbol) ERC721Metadata(name, symbol) public {}\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 916,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor(address _settings) TBoxToken(\"TBoxToken\", \"TBX\") public {\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 917,
          "vulnerability_to_line": null,
          "vulnerability_code": "        settings = ISettings(_settings);\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 918,
          "vulnerability_to_line": null,
          "vulnerability_code": "    }\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 95,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(c / a == b, 'mul');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 105,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(b > 0, 'div');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 116,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(b <= a, 'sub');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 127,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(c >= a, 'add');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 892,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(tx.gasprice <= settings.gasPriceLimit(), \"Gas price is greater than allowed\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 898,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(settings.isFeeManager(msg.sender), \"You have no access\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 904,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_exists(_id), \"Box does not exist\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 910,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_isApprovedOrOwner(msg.sender, _id), \"Box isn't your\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 929,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_beneficiary != address(0), \"Zero address, be careful\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 936,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_fees > 0, \"There is no available fees\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 948,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.value >= settings.minDeposit(), \"Deposit is very small\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 973,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(_tokensToWithdraw <= _tokenLimit, \"Token amount is more than available\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1042,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_tmv <= _maxCapAmount && _tmv >= 10 ** 17, \"Tokens amount out of range\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1086,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_amount > 0, \"Withdrawing zero\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1088,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_amount <= withdrawableEth(_id), \"You can't withdraw so much\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1116,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_amount > 0, \"Withdrawing zero\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1119,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_amount <= boxWithdrawableTmv(_id), \"You can't withdraw so much\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1134,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.value > 0, \"Don't add 0\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1150,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_amount > 0, \"Don't add 0\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1153,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_amount <= boxes[_id].tmvReleased, \"Too much tokens\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1168,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(collateralPercent(_id) >= settings.minStability(), \"This Box isn't collapsable\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1171,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(boxes[_id].collateral.mul(rate()) < precision.mul(3).mul(10 ** 18), \"It's only possible to collapse dust\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1208,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(IToken(settings.tmvAddress()).balanceOf(_from) >= _amount, \"You don't have enough tokens\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1373,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_colP >= settings.minStability() && _colP < settings.maxStability(), \"It's only possible to capitalize toxic Boxes\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 1042,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_tmv <= _maxCapAmount && _tmv >= 10 ** 17, \"Tokens amount out of range\");\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 1373,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_colP >= settings.minStability() && _colP < settings.maxStability(), \"It's only possible to capitalize toxic Boxes\");\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-prefix-decrement-not-postfix",
          "vulnerability_from_line": 616,
          "vulnerability_to_line": null,
          "vulnerability_code": "        _ownedTokens[from].length--;\n",
          "message": "Consider using the prefix decrement expression whenever the return value is not needed. The prefix decrement expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-decrement-not-postfix",
          "vulnerability_from_line": 656,
          "vulnerability_to_line": null,
          "vulnerability_code": "        _allTokens.length--;\n",
          "message": "Consider using the prefix decrement expression whenever the return value is not needed. The prefix decrement expression is cheaper in terms of gas."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 892,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(tx.gasprice <= settings.gasPriceLimit(), \"Gas price is greater than allowed\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 973,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(_tokensToWithdraw <= _tokenLimit, \"Token amount is more than available\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 1171,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(boxes[_id].collateral.mul(rate()) < precision.mul(3).mul(10 ** 18), \"It's only possible to collapse dust\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 1373,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_colP >= settings.minStability() && _colP < settings.maxStability(), \"It's only possible to capitalize toxic Boxes\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "erc721-reentrancy",
          "vulnerability_from_line": 389,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_checkOnERC721Received(from, to, tokenId, _data));\n",
          "message": "ERC721 onERC721Received() reentrancy"
        }
      ]
    },
    "slither": {
      "successfull_analysis": true,
      "errors": [
        "EXIT_CODE_95"
      ],
      "vulnerability_findings": [
        {
          "name": "constant-function",
          "vulnerability_from_line": 157,
          "vulnerability_to_line": 168,
          "vulnerability_code": "    function isContract(address account) internal view returns (bool) {\n\n        uint256 size;\n\n        // XXX Currently there is no better way to check if there is a contract in an address\n\n        // than to check the size of the code at that address.\n\n        // See https://ethereum.stackexchange.com/a/14016/36603\n\n        // for more details about how this works.\n\n        // TODO Check this again before the Serenity release, because all addresses will be\n\n        // contracts then.\n\n        // solium-disable-next-line security/no-inline-assembly\n\n        assembly { size := extcodesize(account) }\n\n        return size > 0;\n",
          "message": "Address.isContract (TBoxManager.sol#157-168) is declared view but contains assembly code\n"
        },
        {
          "name": "erc20-interface",
          "vulnerability_from_line": 27,
          "vulnerability_to_line": 45,
          "vulnerability_code": "contract IERC721 is IERC165 {\n\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n\n\n    function balanceOf(address owner) public view returns (uint256 balance);\n\n    function ownerOf(uint256 tokenId) public view returns (address owner);\n\n\n\n    function approve(address to, uint256 tokenId) public;\n\n    function getApproved(uint256 tokenId) public view returns (address operator);\n\n\n\n    function setApprovalForAll(address operator, bool _approved) public;\n\n    function isApprovedForAll(address owner, address operator) public view returns (bool);\n\n\n\n    function transferFrom(address from, address to, uint256 tokenId) public;\n\n    function safeTransferFrom(address from, address to, uint256 tokenId) public;\n\n\n\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public;\n",
          "message": "IERC721 (TBoxManager.sol#27-45) has incorrect ERC20 function interface(s):\n\t-approve (TBoxManager.sol#35)\n\t-transferFrom (TBoxManager.sol#41)\n"
        },
        {
          "name": "erc20-interface",
          "vulnerability_from_line": 228,
          "vulnerability_to_line": 497,
          "vulnerability_code": "contract ERC721 is ERC165, IERC721 {\n\n    using SafeMath for uint256;\n\n    using Address for address;\n\n\n\n    // Equals to `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n\n    // which can be also obtained as `IERC721Receiver(0).onERC721Received.selector`\n\n    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\n\n\n\n    // Mapping from token ID to owner\n\n    mapping (uint256 => address) internal _tokenOwner;\n\n\n\n    // Mapping from token ID to approved address\n\n    mapping (uint256 => address) private _tokenApprovals;\n\n\n\n    // Mapping from owner to number of owned token\n\n    mapping (address => uint256) private _ownedTokensCount;\n\n\n\n    // Mapping from owner to operator approvals\n\n    mapping (address => mapping (address => bool)) private _operatorApprovals;\n\n\n\n    bytes4 private constant _InterfaceId_ERC721 = 0x80ac58cd;\n\n    /*\n\n     * 0x80ac58cd ===\n\n     *     bytes4(keccak256('balanceOf(address)')) ^\n\n     *     bytes4(keccak256('ownerOf(uint256)')) ^\n\n     *     bytes4(keccak256('approve(address,uint256)')) ^\n\n     *     bytes4(keccak256('getApproved(uint256)')) ^\n\n     *     bytes4(keccak256('setApprovalForAll(address,bool)')) ^\n\n     *     bytes4(keccak256('isApprovedForAll(address,address)')) ^\n\n     *     bytes4(keccak256('transferFrom(address,address,uint256)')) ^\n\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256)')) ^\n\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)'))\n\n     */\n\n\n\n    constructor () public {\n\n        // register the supported interfaces to conform to ERC721 via ERC165\n\n        _registerInterface(_InterfaceId_ERC721);\n\n    }\n\n\n\n    /**\n\n     * @dev Gets the balance of the specified address\n\n     * @param owner address to query the balance of\n\n     * @return uint256 representing the amount owned by the passed address\n\n     */\n\n    function balanceOf(address owner) public view returns (uint256) {\n\n        require(owner != address(0));\n\n        return _ownedTokensCount[owner];\n\n    }\n\n\n\n    /**\n\n     * @dev Gets the owner of the specified token ID\n\n     * @param tokenId uint256 ID of the token to query the owner of\n\n     * @return owner address currently marked as the owner of the given token ID\n\n     */\n\n    function ownerOf(uint256 tokenId) public view returns (address) {\n\n        address owner = _tokenOwner[tokenId];\n\n        require(owner != address(0));\n\n        return owner;\n\n    }\n\n\n\n    /**\n\n     * @dev Approves another address to transfer the given token ID\n\n     * The zero address indicates there is no approved address.\n\n     * There can only be one approved address per token at a given time.\n\n     * Can only be called by the token owner or an approved operator.\n\n     * @param to address to be approved for the given token ID\n\n     * @param tokenId uint256 ID of the token to be approved\n\n     */\n\n    function approve(address to, uint256 tokenId) public {\n\n        address owner = ownerOf(tokenId);\n\n        require(to != owner);\n\n        require(msg.sender == owner || isApprovedForAll(owner, msg.sender));\n\n\n\n        _tokenApprovals[tokenId] = to;\n\n        emit Approval(owner, to, tokenId);\n\n    }\n\n\n\n    /**\n\n     * @dev Gets the approved address for a token ID, or zero if no address set\n\n     * Reverts if the token ID does not exist.\n\n     * @param tokenId uint256 ID of the token to query the approval of\n\n     * @return address currently approved for the given token ID\n\n     */\n\n    function getApproved(uint256 tokenId) public view returns (address) {\n\n        require(_exists(tokenId));\n\n        return _tokenApprovals[tokenId];\n\n    }\n\n\n\n    /**\n\n     * @dev Sets or unsets the approval of a given operator\n\n     * An operator is allowed to transfer all tokens of the sender on their behalf\n\n     * @param to operator address to set the approval\n\n     * @param approved representing the status of the approval to be set\n\n     */\n\n    function setApprovalForAll(address to, bool approved) public {\n\n        require(to != msg.sender);\n\n        _operatorApprovals[msg.sender][to] = approved;\n\n        emit ApprovalForAll(msg.sender, to, approved);\n\n    }\n\n\n\n    /**\n\n     * @dev Tells whether an operator is approved by a given owner\n\n     * @param owner owner address which you want to query the approval of\n\n     * @param operator operator address which you want to query the approval of\n\n     * @return bool whether the given operator is approved by the given owner\n\n     */\n\n    function isApprovedForAll(address owner, address operator) public view returns (bool) {\n\n        return _operatorApprovals[owner][operator];\n\n    }\n\n\n\n    /**\n\n     * @dev Transfers the ownership of a given token ID to another address\n\n     * Usage of this method is discouraged, use `safeTransferFrom` whenever possible\n\n     * Requires the msg sender to be the owner, approved, or operator\n\n     * @param from current owner of the token\n\n     * @param to address to receive the ownership of the given token ID\n\n     * @param tokenId uint256 ID of the token to be transferred\n\n    */\n\n    function transferFrom(address from, address to, uint256 tokenId) public {\n\n        require(_isApprovedOrOwner(msg.sender, tokenId));\n\n        require(to != address(0));\n\n\n\n        _clearApproval(from, tokenId);\n\n        _removeTokenFrom(from, tokenId);\n\n        _addTokenTo(to, tokenId);\n\n\n\n        emit Transfer(from, to, tokenId);\n\n    }\n\n\n\n    /**\n\n     * @dev Safely transfers the ownership of a given token ID to another address\n\n     * If the target address is a contract, it must implement `onERC721Received`,\n\n     * which is called upon a safe transfer, and return the magic value\n\n     * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\n\n     * the transfer is reverted.\n\n     *\n\n     * Requires the msg sender to be the owner, approved, or operator\n\n     * @param from current owner of the token\n\n     * @param to address to receive the ownership of the given token ID\n\n     * @param tokenId uint256 ID of the token to be transferred\n\n    */\n\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n\n        // solium-disable-next-line arg-overflow\n\n        safeTransferFrom(from, to, tokenId, \"\");\n\n    }\n\n\n\n    /**\n\n     * @dev Safely transfers the ownership of a given token ID to another address\n\n     * If the target address is a contract, it must implement `onERC721Received`,\n\n     * which is called upon a safe transfer, and return the magic value\n\n     * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\n\n     * the transfer is reverted.\n\n     * Requires the msg sender to be the owner, approved, or operator\n\n     * @param from current owner of the token\n\n     * @param to address to receive the ownership of the given token ID\n\n     * @param tokenId uint256 ID of the token to be transferred\n\n     * @param _data bytes data to send along with a safe transfer check\n\n     */\n\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public {\n\n        transferFrom(from, to, tokenId);\n\n        // solium-disable-next-line arg-overflow\n\n        require(_checkOnERC721Received(from, to, tokenId, _data));\n\n    }\n\n\n\n    /**\n\n     * @dev Returns whether the specified token exists\n\n     * @param tokenId uint256 ID of the token to query the existence of\n\n     * @return whether the token exists\n\n     */\n\n    function _exists(uint256 tokenId) internal view returns (bool) {\n\n        address owner = _tokenOwner[tokenId];\n\n        return owner != address(0);\n\n    }\n\n\n\n    /**\n\n     * @dev Returns whether the given spender can transfer a given token ID\n\n     * @param spender address of the spender to query\n\n     * @param tokenId uint256 ID of the token to be transferred\n\n     * @return bool whether the msg.sender is approved for the given token ID,\n\n     *    is an operator of the owner, or is the owner of the token\n\n     */\n\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {\n\n        address owner = ownerOf(tokenId);\n\n        // Disable solium check because of\n\n        // https://github.com/duaraghav8/Solium/issues/175\n\n        // solium-disable-next-line operator-whitespace\n\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\n\n    }\n\n\n\n    /**\n\n     * @dev Internal function to mint a new token\n\n     * Reverts if the given token ID already exists\n\n     * @param to The address that will own the minted token\n\n     * @param tokenId uint256 ID of the token to be minted by the msg.sender\n\n     */\n\n    function _mint(address to, uint256 tokenId) internal {\n\n        require(to != address(0));\n\n        _addTokenTo(to, tokenId);\n\n        emit Transfer(address(0), to, tokenId);\n\n    }\n\n\n\n    /**\n\n     * @dev Internal function to burn a specific token\n\n     * Reverts if the token does not exist\n\n     * @param tokenId uint256 ID of the token being burned by the msg.sender\n\n     */\n\n    function _burn(address owner, uint256 tokenId) internal {\n\n        _clearApproval(owner, tokenId);\n\n        _removeTokenFrom(owner, tokenId);\n\n        emit Transfer(owner, address(0), tokenId);\n\n    }\n\n\n\n    /**\n\n     * @dev Internal function to add a token ID to the list of a given address\n\n     * Note that this function is left internal to make ERC721Enumerable possible, but is not\n\n     * intended to be called by custom derived contracts: in particular, it emits no Transfer event.\n\n     * @param to address representing the new owner of the given token ID\n\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\n\n     */\n\n    function _addTokenTo(address to, uint256 tokenId) internal {\n\n        require(_tokenOwner[tokenId] == address(0));\n\n        _tokenOwner[tokenId] = to;\n\n        _ownedTokensCount[to] = _ownedTokensCount[to].add(1);\n\n    }\n\n\n\n    /**\n\n     * @dev Internal function to remove a token ID from the list of a given address\n\n     * Note that this function is left internal to make ERC721Enumerable possible, but is not\n\n     * intended to be called by custom derived contracts: in particular, it emits no Transfer event,\n\n     * and doesn't clear approvals.\n\n     * @param from address representing the previous owner of the given token ID\n\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\n\n     */\n\n    function _removeTokenFrom(address from, uint256 tokenId) internal {\n\n        require(ownerOf(tokenId) == from);\n\n        _ownedTokensCount[from] = _ownedTokensCount[from].sub(1);\n\n        _tokenOwner[tokenId] = address(0);\n\n    }\n\n\n\n    /**\n\n     * @dev Internal function to invoke `onERC721Received` on a target address\n\n     * The call is not executed if the target address is not a contract\n\n     * @param from address representing the previous owner of the given token ID\n\n     * @param to target address that will receive the tokens\n\n     * @param tokenId uint256 ID of the token to be transferred\n\n     * @param _data bytes optional data to send along with the call\n\n     * @return whether the call correctly returned the expected magic value\n\n     */\n\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data) internal returns (bool) {\n\n        if (!to.isContract()) {\n\n            return true;\n\n        }\n\n\n\n        bytes4 retval = IERC721Receiver(to).onERC721Received(msg.sender, from, tokenId, _data);\n\n        return (retval == _ERC721_RECEIVED);\n\n    }\n\n\n\n    /**\n\n     * @dev Private function to clear current approval of a given token ID\n\n     * Reverts if the given address is not indeed the owner of the token\n\n     * @param owner owner of the token\n\n     * @param tokenId uint256 ID of the token to be transferred\n\n     */\n\n    function _clearApproval(address owner, uint256 tokenId) private {\n\n        require(ownerOf(tokenId) == owner);\n\n        if (_tokenApprovals[tokenId] != address(0)) {\n\n            _tokenApprovals[tokenId] = address(0);\n\n        }\n\n    }\n",
          "message": "ERC721 (TBoxManager.sol#228-497) has incorrect ERC20 function interface(s):\n\t-approve (TBoxManager.sol#296-303)\n\t-transferFrom (TBoxManager.sol#346-355)\n"
        },
        {
          "name": "erc20-interface",
          "vulnerability_from_line": 809,
          "vulnerability_to_line": 817,
          "vulnerability_code": "interface IToken {\n\n    function burnLogic(address from, uint256 value) external;\n\n    function balanceOf(address who) external view returns (uint256);\n\n    function mint(address to, uint256 value) external returns (bool);\n\n    function totalSupply() external view returns (uint256);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function transferFrom(address from, address to, uint256 tokenId) external;\n",
          "message": "IToken (TBoxManager.sol#809-817) has incorrect ERC20 function interface(s):\n\t-transferFrom (TBoxManager.sol#816)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 1149,
          "vulnerability_to_line": 1161,
          "vulnerability_code": "    function addTmv(uint256 _id, uint256 _amount) external onlyExists(_id) {\n\n        require(_amount > 0, \"Don't add 0\");\n\n\n\n        // Check the number of tokens\n\n        require(_amount <= boxes[_id].tmvReleased, \"Too much tokens\");\n\n\n\n        // Removes added tokens from the collateralization\n\n        _burnTMV(msg.sender, _amount);\n\n        boxes[_id].tmvReleased = boxes[_id].tmvReleased.sub(_amount);\n\n\n\n        // Fire the event\n\n        emit TmvAdded(_id, _amount, msg.sender);\n",
          "message": "Reentrancy in TBoxManager.addTmv (TBoxManager.sol#1149-1161):\n\tExternal calls:\n\t- _burnTMV(msg.sender,_amount) (TBoxManager.sol#1156)\n\tState variables written after the call(s):\n\t- boxes (TBoxManager.sol#1157)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 1036,
          "vulnerability_to_line": 1071,
          "vulnerability_code": "    function capitalize(uint256 _id, uint256 _tmv) public validTx {\n\n\n\n        // The maximum number of tokens for which Box can be capitalized\n\n        uint256 _maxCapAmount = maxCapAmount(_id);\n\n\n\n        // Check the number of tokens\n\n        require(_tmv <= _maxCapAmount && _tmv >= 10 ** 17, \"Tokens amount out of range\");\n\n\n\n        // Decrease Box TMV withdrawn counter\n\n        boxes[_id].tmvReleased = boxes[_id].tmvReleased.sub(_tmv);\n\n\n\n        // Calculate the Ether equivalent of tokens according to the logic\n\n        // where 1 TMV is equal to 1 USD\n\n        uint256 _equivalentETH = _tmv.mul(precision).div(rate());\n\n\n\n        // Calculate system fee\n\n        uint256 _fee = _tmv.mul(settings.sysFee()).div(rate());\n\n\n\n        // Calculate user bonus\n\n        uint256 _userReward = _tmv.mul(settings.userFee()).div(rate());\n\n\n\n        // Decrease Box's collateral amount\n\n        boxes[_id].collateral = boxes[_id].collateral.sub(_fee.add(_userReward).add(_equivalentETH));\n\n\n\n        // Decrease global Ether counter\n\n        globalETH = globalETH.sub(_fee.add(_userReward).add(_equivalentETH));\n\n\n\n        // burn Box token\n\n        _burnTMV(msg.sender, _tmv);\n\n\n\n        // Send the Ether equivalent & user benefit to the person who made capitalization happen.\n\n        msg.sender.transfer(_equivalentETH.add(_userReward));\n\n\n\n        // Fire the event\n\n        emit Capitalized(_id, ownerOf(_id), msg.sender, _tmv, _equivalentETH.add(_userReward).add(_fee), _equivalentETH.add(_userReward));\n",
          "message": "Reentrancy in TBoxManager.capitalize (TBoxManager.sol#1036-1071):\n\tExternal calls:\n\t- _maxCapAmount = maxCapAmount(_id) (TBoxManager.sol#1039)\n\tState variables written after the call(s):\n\t- boxes (TBoxManager.sol#1045)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 1036,
          "vulnerability_to_line": 1071,
          "vulnerability_code": "    function capitalize(uint256 _id, uint256 _tmv) public validTx {\n\n\n\n        // The maximum number of tokens for which Box can be capitalized\n\n        uint256 _maxCapAmount = maxCapAmount(_id);\n\n\n\n        // Check the number of tokens\n\n        require(_tmv <= _maxCapAmount && _tmv >= 10 ** 17, \"Tokens amount out of range\");\n\n\n\n        // Decrease Box TMV withdrawn counter\n\n        boxes[_id].tmvReleased = boxes[_id].tmvReleased.sub(_tmv);\n\n\n\n        // Calculate the Ether equivalent of tokens according to the logic\n\n        // where 1 TMV is equal to 1 USD\n\n        uint256 _equivalentETH = _tmv.mul(precision).div(rate());\n\n\n\n        // Calculate system fee\n\n        uint256 _fee = _tmv.mul(settings.sysFee()).div(rate());\n\n\n\n        // Calculate user bonus\n\n        uint256 _userReward = _tmv.mul(settings.userFee()).div(rate());\n\n\n\n        // Decrease Box's collateral amount\n\n        boxes[_id].collateral = boxes[_id].collateral.sub(_fee.add(_userReward).add(_equivalentETH));\n\n\n\n        // Decrease global Ether counter\n\n        globalETH = globalETH.sub(_fee.add(_userReward).add(_equivalentETH));\n\n\n\n        // burn Box token\n\n        _burnTMV(msg.sender, _tmv);\n\n\n\n        // Send the Ether equivalent & user benefit to the person who made capitalization happen.\n\n        msg.sender.transfer(_equivalentETH.add(_userReward));\n\n\n\n        // Fire the event\n\n        emit Capitalized(_id, ownerOf(_id), msg.sender, _tmv, _equivalentETH.add(_userReward).add(_fee), _equivalentETH.add(_userReward));\n",
          "message": "Reentrancy in TBoxManager.capitalize (TBoxManager.sol#1036-1071):\n\tExternal calls:\n\t- _maxCapAmount = maxCapAmount(_id) (TBoxManager.sol#1039)\n\t- _equivalentETH = _tmv.mul(precision).div(rate()) (TBoxManager.sol#1049)\n\t- _fee = _tmv.mul(settings.sysFee()).div(rate()) (TBoxManager.sol#1052)\n\t- _userReward = _tmv.mul(settings.userFee()).div(rate()) (TBoxManager.sol#1055)\n\tState variables written after the call(s):\n\t- boxes (TBoxManager.sol#1058)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 998,
          "vulnerability_to_line": 1024,
          "vulnerability_code": "    function close(uint256 _id) external onlyApprovedOrOwner(_id) {\n\n\n\n        // Address of the owner of the Box\n\n        address _owner = _tokenOwner[_id];\n\n\n\n        // Burn needed number of tokens\n\n        uint256 _tokensNeed = boxes[_id].tmvReleased;\n\n        _burnTMV(msg.sender, _tokensNeed);\n\n\n\n        // Grab a reference to the Box's collateral in storage\n\n        uint256 _collateral = boxes[_id].collateral;\n\n\n\n        // burn Box token\n\n        _burn(_owner, _id);\n\n\n\n        // Removes Box\n\n        delete boxes[_id];\n\n\n\n        // Send the Box's collateral to the person who made closing happen\n\n        msg.sender.transfer(_collateral);\n\n\n\n        // Decrease global Ether counter\n\n        globalETH = globalETH.sub(_collateral);\n\n\n\n        // Fire the event\n\n        emit Closed(_id, _owner, msg.sender);\n",
          "message": "Reentrancy in TBoxManager.close (TBoxManager.sol#998-1024):\n\tExternal calls:\n\t- _burnTMV(msg.sender,_tokensNeed) (TBoxManager.sol#1005)\n\tState variables written after the call(s):\n\t- _tokenOwner (TBoxManager.sol#1011)\n\t- boxes (TBoxManager.sol#1014)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 1166,
          "vulnerability_to_line": 1203,
          "vulnerability_code": "    function closeDust(uint256 _id) external onlyExists(_id) validTx {\n\n        // Check collateral percent of the Box\n\n        require(collateralPercent(_id) >= settings.minStability(), \"This Box isn't collapsable\");\n\n\n\n        // Check collateral amount of the Box\n\n        require(boxes[_id].collateral.mul(rate()) < precision.mul(3).mul(10 ** 18), \"It's only possible to collapse dust\");\n\n\n\n        // Burn needed TMV amount to close\n\n        uint256 _tmvReleased = boxes[_id].tmvReleased;\n\n        _burnTMV(msg.sender, _tmvReleased);\n\n\n\n        uint256 _collateral = boxes[_id].collateral;\n\n\n\n        // Calculate the Ether equivalent of tokens according to the logic\n\n        // where 1 TMV is equal to 1 USD\n\n        uint256 _eth = _tmvReleased.mul(precision).div(rate());\n\n\n\n        // Calculate user bonus\n\n        uint256 _userReward = _tmvReleased.mul(settings.userFee()).div(rate());\n\n\n\n        // The owner of the Box\n\n        address _owner = ownerOf(_id);\n\n\n\n        // Remove a Box\n\n        delete boxes[_id];\n\n\n\n        // Burn Box token\n\n        _burn(_owner, _id);\n\n\n\n        // Send the Ether equivalent & user benefit to the person who made closing happen\n\n        msg.sender.transfer(_eth.add(_userReward));\n\n\n\n        // Decrease global Ether counter\n\n        globalETH = globalETH.sub(_collateral);\n\n\n\n        // Fire the event\n\n        emit Closed(_id, _owner, msg.sender);\n",
          "message": "Reentrancy in TBoxManager.closeDust (TBoxManager.sol#1166-1203):\n\tExternal calls:\n\t- require(bool,string)(collateralPercent(_id) >= settings.minStability(),This Box isn't collapsable) (TBoxManager.sol#1168)\n\t- require(bool,string)(boxes[_id].collateral.mul(rate()) < precision.mul(3).mul(10 ** 18),It's only possible to collapse dust) (TBoxManager.sol#1171)\n\t- _burnTMV(msg.sender,_tmvReleased) (TBoxManager.sol#1175)\n\t- _eth = _tmvReleased.mul(precision).div(rate()) (TBoxManager.sol#1181)\n\t- _userReward = _tmvReleased.mul(settings.userFee()).div(rate()) (TBoxManager.sol#1184)\n\tState variables written after the call(s):\n\t- _tokenOwner (TBoxManager.sol#1193)\n\t- boxes (TBoxManager.sol#1190)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 946,
          "vulnerability_to_line": 993,
          "vulnerability_code": "    function create(uint256 _tokensToWithdraw) public payable validTx returns (uint256) {\n\n        // Check that msg.value isn't smaller than minimum deposit\n\n        require(msg.value >= settings.minDeposit(), \"Deposit is very small\");\n\n\n\n        // Calculate collateralization when tokens are needed\n\n        if (_tokensToWithdraw > 0) {\n\n\n\n            // The number of tokens when collateralization is high\n\n            uint256 _tokenLimit = overCapWithdrawableTmv(msg.value);\n\n\n\n            // The number of tokens that can be safely withdrawn from the system\n\n            uint256 _maxGlobal = globalWithdrawableTmv(msg.value);\n\n\n\n            // Determine the higher number of tokens\n\n            if (_tokenLimit > _maxGlobal) {\n\n                _tokenLimit = _maxGlobal;\n\n            }\n\n\n\n            // The number of tokens that can be withdrawn anyway\n\n            uint256 _local = defaultWithdrawableTmv(msg.value);\n\n\n\n            // Determine the higher number of tokens\n\n            if (_tokenLimit < _local) {\n\n                _tokenLimit = _local;\n\n            }\n\n\n\n            // You can only withdraw available amount\n\n            require(_tokensToWithdraw <= _tokenLimit, \"Token amount is more than available\");\n\n\n\n            // Mint TMV tokens to the Box creator\n\n            IToken(settings.tmvAddress()).mint(msg.sender, _tokensToWithdraw);\n\n        }\n\n\n\n        // The id of the new Box\n\n        uint256 _id = boxes.push(Box(msg.value, _tokensToWithdraw)).sub(1);\n\n\n\n        // Increase global Ether counter\n\n        globalETH = globalETH.add(msg.value);\n\n\n\n        // Mint TBX token to the Box creator\n\n        _mint(msg.sender, _id);\n\n\n\n        // Fire the event\n\n        emit Created(_id, msg.sender, msg.value, _tokensToWithdraw);\n\n\n\n        // return the new Box's ID\n\n        return _id;\n",
          "message": "Reentrancy in TBoxManager.create (TBoxManager.sol#946-993):\n\tExternal calls:\n\t- require(bool,string)(msg.value >= settings.minDeposit(),Deposit is very small) (TBoxManager.sol#948)\n\t- _tokenLimit = overCapWithdrawableTmv(msg.value) (TBoxManager.sol#954)\n\t- _maxGlobal = globalWithdrawableTmv(msg.value) (TBoxManager.sol#957)\n\t- _local = defaultWithdrawableTmv(msg.value) (TBoxManager.sol#965)\n\t- IToken(settings.tmvAddress()).mint(msg.sender,_tokensToWithdraw) (TBoxManager.sol#976)\n\tState variables written after the call(s):\n\t- globalETH (TBoxManager.sol#983)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 1085,
          "vulnerability_to_line": 1101,
          "vulnerability_code": "    function withdrawEth(uint256 _id, uint256 _amount) public onlyApprovedOrOwner(_id) validTx {\n\n        require(_amount > 0, \"Withdrawing zero\");\n\n\n\n        require(_amount <= withdrawableEth(_id), \"You can't withdraw so much\");\n\n\n\n        // Decrease Box's collateral amount\n\n        boxes[_id].collateral = boxes[_id].collateral.sub(_amount);\n\n\n\n        // Decrease global Ether counter\n\n        globalETH = globalETH.sub(_amount);\n\n\n\n        // Send the Ether to the person who made capitalization happen\n\n        msg.sender.transfer(_amount);\n\n\n\n        // Fire the event\n\n        emit EthWithdrawn(_id, _amount, msg.sender);\n",
          "message": "Reentrancy in TBoxManager.withdrawEth (TBoxManager.sol#1085-1101):\n\tExternal calls:\n\t- require(bool,string)(_amount <= withdrawableEth(_id),You can't withdraw so much) (TBoxManager.sol#1088)\n\tState variables written after the call(s):\n\t- boxes (TBoxManager.sol#1091)\n\t- globalETH (TBoxManager.sol#1094)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 1115,
          "vulnerability_to_line": 1129,
          "vulnerability_code": "    function withdrawTmv(uint256 _id, uint256 _amount) public onlyApprovedOrOwner(_id) validTx {\n\n        require(_amount > 0, \"Withdrawing zero\");\n\n\n\n        // Check the number of tokens\n\n        require(_amount <= boxWithdrawableTmv(_id), \"You can't withdraw so much\");\n\n\n\n        // Increase Box TMV withdrawn counter\n\n        boxes[_id].tmvReleased = boxes[_id].tmvReleased.add(_amount);\n\n\n\n        // Mints tokens to the person who made withdrawing\n\n        IToken(settings.tmvAddress()).mint(msg.sender, _amount);\n\n\n\n        // Fire the event\n\n        emit TmvWithdrawn(_id, _amount, msg.sender);\n",
          "message": "Reentrancy in TBoxManager.withdrawTmv (TBoxManager.sol#1115-1129):\n\tExternal calls:\n\t- require(bool,string)(_amount <= boxWithdrawableTmv(_id),You can't withdraw so much) (TBoxManager.sol#1119)\n\tState variables written after the call(s):\n\t- boxes (TBoxManager.sol#1122)\n"
        },
        {
          "name": "uninitialized-local",
          "vulnerability_from_line": 1261,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint256 _globalAvailable;\n",
          "message": "_globalAvailable in TBoxManager._freeEth (TBoxManager.sol#1261) is a local variable never initialiazed\n"
        },
        {
          "name": "unused-return",
          "vulnerability_from_line": 946,
          "vulnerability_to_line": 993,
          "vulnerability_code": "    function create(uint256 _tokensToWithdraw) public payable validTx returns (uint256) {\n\n        // Check that msg.value isn't smaller than minimum deposit\n\n        require(msg.value >= settings.minDeposit(), \"Deposit is very small\");\n\n\n\n        // Calculate collateralization when tokens are needed\n\n        if (_tokensToWithdraw > 0) {\n\n\n\n            // The number of tokens when collateralization is high\n\n            uint256 _tokenLimit = overCapWithdrawableTmv(msg.value);\n\n\n\n            // The number of tokens that can be safely withdrawn from the system\n\n            uint256 _maxGlobal = globalWithdrawableTmv(msg.value);\n\n\n\n            // Determine the higher number of tokens\n\n            if (_tokenLimit > _maxGlobal) {\n\n                _tokenLimit = _maxGlobal;\n\n            }\n\n\n\n            // The number of tokens that can be withdrawn anyway\n\n            uint256 _local = defaultWithdrawableTmv(msg.value);\n\n\n\n            // Determine the higher number of tokens\n\n            if (_tokenLimit < _local) {\n\n                _tokenLimit = _local;\n\n            }\n\n\n\n            // You can only withdraw available amount\n\n            require(_tokensToWithdraw <= _tokenLimit, \"Token amount is more than available\");\n\n\n\n            // Mint TMV tokens to the Box creator\n\n            IToken(settings.tmvAddress()).mint(msg.sender, _tokensToWithdraw);\n\n        }\n\n\n\n        // The id of the new Box\n\n        uint256 _id = boxes.push(Box(msg.value, _tokensToWithdraw)).sub(1);\n\n\n\n        // Increase global Ether counter\n\n        globalETH = globalETH.add(msg.value);\n\n\n\n        // Mint TBX token to the Box creator\n\n        _mint(msg.sender, _id);\n\n\n\n        // Fire the event\n\n        emit Created(_id, msg.sender, msg.value, _tokensToWithdraw);\n\n\n\n        // return the new Box's ID\n\n        return _id;\n",
          "message": "TBoxManager.create (TBoxManager.sol#946-993) does not use the value returned by external calls:\n\t-IToken(settings.tmvAddress()).mint(msg.sender,_tokensToWithdraw) (TBoxManager.sol#976)\n"
        },
        {
          "name": "unused-return",
          "vulnerability_from_line": 1115,
          "vulnerability_to_line": 1129,
          "vulnerability_code": "    function withdrawTmv(uint256 _id, uint256 _amount) public onlyApprovedOrOwner(_id) validTx {\n\n        require(_amount > 0, \"Withdrawing zero\");\n\n\n\n        // Check the number of tokens\n\n        require(_amount <= boxWithdrawableTmv(_id), \"You can't withdraw so much\");\n\n\n\n        // Increase Box TMV withdrawn counter\n\n        boxes[_id].tmvReleased = boxes[_id].tmvReleased.add(_amount);\n\n\n\n        // Mints tokens to the person who made withdrawing\n\n        IToken(settings.tmvAddress()).mint(msg.sender, _amount);\n\n\n\n        // Fire the event\n\n        emit TmvWithdrawn(_id, _amount, msg.sender);\n",
          "message": "TBoxManager.withdrawTmv (TBoxManager.sol#1115-1129) does not use the value returned by external calls:\n\t-IToken(settings.tmvAddress()).mint(msg.sender,_amount) (TBoxManager.sol#1125)\n"
        },
        {
          "name": "shadowing-local",
          "vulnerability_from_line": 703,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor (string memory name, string memory symbol) public {\n",
          "message": "ERC721Metadata.constructor.name (local variable @ TBoxManager.sol#703) shadows:\n\t- ERC721Metadata.name (function @ TBoxManager.sol#715-717)\n\t- IERC721Metadata.name (function @ TBoxManager.sol#671)\n"
        },
        {
          "name": "shadowing-local",
          "vulnerability_from_line": 703,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor (string memory name, string memory symbol) public {\n",
          "message": "ERC721Metadata.constructor.symbol (local variable @ TBoxManager.sol#703) shadows:\n\t- ERC721Metadata.symbol (function @ TBoxManager.sol#723-725)\n\t- IERC721Metadata.symbol (function @ TBoxManager.sol#672)\n"
        },
        {
          "name": "shadowing-local",
          "vulnerability_from_line": 777,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor (string memory name, string memory symbol) ERC721Metadata(name, symbol) public {}\n",
          "message": "TBoxToken.constructor.name (local variable @ TBoxManager.sol#777) shadows:\n\t- ERC721Metadata.name (function @ TBoxManager.sol#715-717)\n\t- IERC721Metadata.name (function @ TBoxManager.sol#671)\n"
        },
        {
          "name": "shadowing-local",
          "vulnerability_from_line": 777,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor (string memory name, string memory symbol) ERC721Metadata(name, symbol) public {}\n",
          "message": "TBoxToken.constructor.symbol (local variable @ TBoxManager.sol#777) shadows:\n\t- ERC721Metadata.symbol (function @ TBoxManager.sol#723-725)\n\t- IERC721Metadata.symbol (function @ TBoxManager.sol#672)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 1036,
          "vulnerability_to_line": 1071,
          "vulnerability_code": "    function capitalize(uint256 _id, uint256 _tmv) public validTx {\n\n\n\n        // The maximum number of tokens for which Box can be capitalized\n\n        uint256 _maxCapAmount = maxCapAmount(_id);\n\n\n\n        // Check the number of tokens\n\n        require(_tmv <= _maxCapAmount && _tmv >= 10 ** 17, \"Tokens amount out of range\");\n\n\n\n        // Decrease Box TMV withdrawn counter\n\n        boxes[_id].tmvReleased = boxes[_id].tmvReleased.sub(_tmv);\n\n\n\n        // Calculate the Ether equivalent of tokens according to the logic\n\n        // where 1 TMV is equal to 1 USD\n\n        uint256 _equivalentETH = _tmv.mul(precision).div(rate());\n\n\n\n        // Calculate system fee\n\n        uint256 _fee = _tmv.mul(settings.sysFee()).div(rate());\n\n\n\n        // Calculate user bonus\n\n        uint256 _userReward = _tmv.mul(settings.userFee()).div(rate());\n\n\n\n        // Decrease Box's collateral amount\n\n        boxes[_id].collateral = boxes[_id].collateral.sub(_fee.add(_userReward).add(_equivalentETH));\n\n\n\n        // Decrease global Ether counter\n\n        globalETH = globalETH.sub(_fee.add(_userReward).add(_equivalentETH));\n\n\n\n        // burn Box token\n\n        _burnTMV(msg.sender, _tmv);\n\n\n\n        // Send the Ether equivalent & user benefit to the person who made capitalization happen.\n\n        msg.sender.transfer(_equivalentETH.add(_userReward));\n\n\n\n        // Fire the event\n\n        emit Capitalized(_id, ownerOf(_id), msg.sender, _tmv, _equivalentETH.add(_userReward).add(_fee), _equivalentETH.add(_userReward));\n",
          "message": "Reentrancy in TBoxManager.capitalize (TBoxManager.sol#1036-1071):\n\tExternal calls:\n\t- _maxCapAmount = maxCapAmount(_id) (TBoxManager.sol#1039)\n\t- _equivalentETH = _tmv.mul(precision).div(rate()) (TBoxManager.sol#1049)\n\t- _fee = _tmv.mul(settings.sysFee()).div(rate()) (TBoxManager.sol#1052)\n\t- _userReward = _tmv.mul(settings.userFee()).div(rate()) (TBoxManager.sol#1055)\n\tState variables written after the call(s):\n\t- globalETH (TBoxManager.sol#1061)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 998,
          "vulnerability_to_line": 1024,
          "vulnerability_code": "    function close(uint256 _id) external onlyApprovedOrOwner(_id) {\n\n\n\n        // Address of the owner of the Box\n\n        address _owner = _tokenOwner[_id];\n\n\n\n        // Burn needed number of tokens\n\n        uint256 _tokensNeed = boxes[_id].tmvReleased;\n\n        _burnTMV(msg.sender, _tokensNeed);\n\n\n\n        // Grab a reference to the Box's collateral in storage\n\n        uint256 _collateral = boxes[_id].collateral;\n\n\n\n        // burn Box token\n\n        _burn(_owner, _id);\n\n\n\n        // Removes Box\n\n        delete boxes[_id];\n\n\n\n        // Send the Box's collateral to the person who made closing happen\n\n        msg.sender.transfer(_collateral);\n\n\n\n        // Decrease global Ether counter\n\n        globalETH = globalETH.sub(_collateral);\n\n\n\n        // Fire the event\n\n        emit Closed(_id, _owner, msg.sender);\n",
          "message": "Reentrancy in TBoxManager.close (TBoxManager.sol#998-1024):\n\tExternal calls:\n\t- _burnTMV(msg.sender,_tokensNeed) (TBoxManager.sol#1005)\n\tState variables written after the call(s):\n\t- _ownedTokensCount (TBoxManager.sol#1011)\n\t- _tokenApprovals (TBoxManager.sol#1011)\n\t- _tokenURIs (TBoxManager.sol#1011)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 998,
          "vulnerability_to_line": 1024,
          "vulnerability_code": "    function close(uint256 _id) external onlyApprovedOrOwner(_id) {\n\n\n\n        // Address of the owner of the Box\n\n        address _owner = _tokenOwner[_id];\n\n\n\n        // Burn needed number of tokens\n\n        uint256 _tokensNeed = boxes[_id].tmvReleased;\n\n        _burnTMV(msg.sender, _tokensNeed);\n\n\n\n        // Grab a reference to the Box's collateral in storage\n\n        uint256 _collateral = boxes[_id].collateral;\n\n\n\n        // burn Box token\n\n        _burn(_owner, _id);\n\n\n\n        // Removes Box\n\n        delete boxes[_id];\n\n\n\n        // Send the Box's collateral to the person who made closing happen\n\n        msg.sender.transfer(_collateral);\n\n\n\n        // Decrease global Ether counter\n\n        globalETH = globalETH.sub(_collateral);\n\n\n\n        // Fire the event\n\n        emit Closed(_id, _owner, msg.sender);\n",
          "message": "Reentrancy in TBoxManager.close (TBoxManager.sol#998-1024):\n\tExternal calls:\n\t- _burnTMV(msg.sender,_tokensNeed) (TBoxManager.sol#1005)\n\tExternal calls sending eth:\n\t- msg.sender.transfer(_collateral) (TBoxManager.sol#1017)\n\tState variables written after the call(s):\n\t- globalETH (TBoxManager.sol#1020)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 1166,
          "vulnerability_to_line": 1203,
          "vulnerability_code": "    function closeDust(uint256 _id) external onlyExists(_id) validTx {\n\n        // Check collateral percent of the Box\n\n        require(collateralPercent(_id) >= settings.minStability(), \"This Box isn't collapsable\");\n\n\n\n        // Check collateral amount of the Box\n\n        require(boxes[_id].collateral.mul(rate()) < precision.mul(3).mul(10 ** 18), \"It's only possible to collapse dust\");\n\n\n\n        // Burn needed TMV amount to close\n\n        uint256 _tmvReleased = boxes[_id].tmvReleased;\n\n        _burnTMV(msg.sender, _tmvReleased);\n\n\n\n        uint256 _collateral = boxes[_id].collateral;\n\n\n\n        // Calculate the Ether equivalent of tokens according to the logic\n\n        // where 1 TMV is equal to 1 USD\n\n        uint256 _eth = _tmvReleased.mul(precision).div(rate());\n\n\n\n        // Calculate user bonus\n\n        uint256 _userReward = _tmvReleased.mul(settings.userFee()).div(rate());\n\n\n\n        // The owner of the Box\n\n        address _owner = ownerOf(_id);\n\n\n\n        // Remove a Box\n\n        delete boxes[_id];\n\n\n\n        // Burn Box token\n\n        _burn(_owner, _id);\n\n\n\n        // Send the Ether equivalent & user benefit to the person who made closing happen\n\n        msg.sender.transfer(_eth.add(_userReward));\n\n\n\n        // Decrease global Ether counter\n\n        globalETH = globalETH.sub(_collateral);\n\n\n\n        // Fire the event\n\n        emit Closed(_id, _owner, msg.sender);\n",
          "message": "Reentrancy in TBoxManager.closeDust (TBoxManager.sol#1166-1203):\n\tExternal calls:\n\t- require(bool,string)(collateralPercent(_id) >= settings.minStability(),This Box isn't collapsable) (TBoxManager.sol#1168)\n\t- require(bool,string)(boxes[_id].collateral.mul(rate()) < precision.mul(3).mul(10 ** 18),It's only possible to collapse dust) (TBoxManager.sol#1171)\n\t- _burnTMV(msg.sender,_tmvReleased) (TBoxManager.sol#1175)\n\t- _eth = _tmvReleased.mul(precision).div(rate()) (TBoxManager.sol#1181)\n\t- _userReward = _tmvReleased.mul(settings.userFee()).div(rate()) (TBoxManager.sol#1184)\n\tState variables written after the call(s):\n\t- _ownedTokensCount (TBoxManager.sol#1193)\n\t- _tokenApprovals (TBoxManager.sol#1193)\n\t- _tokenURIs (TBoxManager.sol#1193)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 1166,
          "vulnerability_to_line": 1203,
          "vulnerability_code": "    function closeDust(uint256 _id) external onlyExists(_id) validTx {\n\n        // Check collateral percent of the Box\n\n        require(collateralPercent(_id) >= settings.minStability(), \"This Box isn't collapsable\");\n\n\n\n        // Check collateral amount of the Box\n\n        require(boxes[_id].collateral.mul(rate()) < precision.mul(3).mul(10 ** 18), \"It's only possible to collapse dust\");\n\n\n\n        // Burn needed TMV amount to close\n\n        uint256 _tmvReleased = boxes[_id].tmvReleased;\n\n        _burnTMV(msg.sender, _tmvReleased);\n\n\n\n        uint256 _collateral = boxes[_id].collateral;\n\n\n\n        // Calculate the Ether equivalent of tokens according to the logic\n\n        // where 1 TMV is equal to 1 USD\n\n        uint256 _eth = _tmvReleased.mul(precision).div(rate());\n\n\n\n        // Calculate user bonus\n\n        uint256 _userReward = _tmvReleased.mul(settings.userFee()).div(rate());\n\n\n\n        // The owner of the Box\n\n        address _owner = ownerOf(_id);\n\n\n\n        // Remove a Box\n\n        delete boxes[_id];\n\n\n\n        // Burn Box token\n\n        _burn(_owner, _id);\n\n\n\n        // Send the Ether equivalent & user benefit to the person who made closing happen\n\n        msg.sender.transfer(_eth.add(_userReward));\n\n\n\n        // Decrease global Ether counter\n\n        globalETH = globalETH.sub(_collateral);\n\n\n\n        // Fire the event\n\n        emit Closed(_id, _owner, msg.sender);\n",
          "message": "Reentrancy in TBoxManager.closeDust (TBoxManager.sol#1166-1203):\n\tExternal calls:\n\t- require(bool,string)(collateralPercent(_id) >= settings.minStability(),This Box isn't collapsable) (TBoxManager.sol#1168)\n\t- require(bool,string)(boxes[_id].collateral.mul(rate()) < precision.mul(3).mul(10 ** 18),It's only possible to collapse dust) (TBoxManager.sol#1171)\n\t- _burnTMV(msg.sender,_tmvReleased) (TBoxManager.sol#1175)\n\t- _eth = _tmvReleased.mul(precision).div(rate()) (TBoxManager.sol#1181)\n\t- _userReward = _tmvReleased.mul(settings.userFee()).div(rate()) (TBoxManager.sol#1184)\n\tExternal calls sending eth:\n\t- msg.sender.transfer(_eth.add(_userReward)) (TBoxManager.sol#1196)\n\tState variables written after the call(s):\n\t- globalETH (TBoxManager.sol#1199)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 946,
          "vulnerability_to_line": 993,
          "vulnerability_code": "    function create(uint256 _tokensToWithdraw) public payable validTx returns (uint256) {\n\n        // Check that msg.value isn't smaller than minimum deposit\n\n        require(msg.value >= settings.minDeposit(), \"Deposit is very small\");\n\n\n\n        // Calculate collateralization when tokens are needed\n\n        if (_tokensToWithdraw > 0) {\n\n\n\n            // The number of tokens when collateralization is high\n\n            uint256 _tokenLimit = overCapWithdrawableTmv(msg.value);\n\n\n\n            // The number of tokens that can be safely withdrawn from the system\n\n            uint256 _maxGlobal = globalWithdrawableTmv(msg.value);\n\n\n\n            // Determine the higher number of tokens\n\n            if (_tokenLimit > _maxGlobal) {\n\n                _tokenLimit = _maxGlobal;\n\n            }\n\n\n\n            // The number of tokens that can be withdrawn anyway\n\n            uint256 _local = defaultWithdrawableTmv(msg.value);\n\n\n\n            // Determine the higher number of tokens\n\n            if (_tokenLimit < _local) {\n\n                _tokenLimit = _local;\n\n            }\n\n\n\n            // You can only withdraw available amount\n\n            require(_tokensToWithdraw <= _tokenLimit, \"Token amount is more than available\");\n\n\n\n            // Mint TMV tokens to the Box creator\n\n            IToken(settings.tmvAddress()).mint(msg.sender, _tokensToWithdraw);\n\n        }\n\n\n\n        // The id of the new Box\n\n        uint256 _id = boxes.push(Box(msg.value, _tokensToWithdraw)).sub(1);\n\n\n\n        // Increase global Ether counter\n\n        globalETH = globalETH.add(msg.value);\n\n\n\n        // Mint TBX token to the Box creator\n\n        _mint(msg.sender, _id);\n\n\n\n        // Fire the event\n\n        emit Created(_id, msg.sender, msg.value, _tokensToWithdraw);\n\n\n\n        // return the new Box's ID\n\n        return _id;\n",
          "message": "Reentrancy in TBoxManager.create (TBoxManager.sol#946-993):\n\tExternal calls:\n\t- require(bool,string)(msg.value >= settings.minDeposit(),Deposit is very small) (TBoxManager.sol#948)\n\t- _tokenLimit = overCapWithdrawableTmv(msg.value) (TBoxManager.sol#954)\n\t- _maxGlobal = globalWithdrawableTmv(msg.value) (TBoxManager.sol#957)\n\t- _local = defaultWithdrawableTmv(msg.value) (TBoxManager.sol#965)\n\t- IToken(settings.tmvAddress()).mint(msg.sender,_tokensToWithdraw) (TBoxManager.sol#976)\n\tState variables written after the call(s):\n\t- _allTokens (TBoxManager.sol#986)\n\t- _allTokensIndex (TBoxManager.sol#986)\n\t- _ownedTokensCount (TBoxManager.sol#986)\n\t- _tokenOwner (TBoxManager.sol#986)\n\t- boxes (TBoxManager.sol#980)\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 157,
          "vulnerability_to_line": 168,
          "vulnerability_code": "    function isContract(address account) internal view returns (bool) {\n\n        uint256 size;\n\n        // XXX Currently there is no better way to check if there is a contract in an address\n\n        // than to check the size of the code at that address.\n\n        // See https://ethereum.stackexchange.com/a/14016/36603\n\n        // for more details about how this works.\n\n        // TODO Check this again before the Serenity release, because all addresses will be\n\n        // contracts then.\n\n        // solium-disable-next-line security/no-inline-assembly\n\n        assembly { size := extcodesize(account) }\n\n        return size > 0;\n",
          "message": "Address.isContract uses assembly (TBoxManager.sol#157-168)\n\t- TBoxManager.sol#166-167\n"
        },
        {
          "name": "constable-states",
          "vulnerability_from_line": 844,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint256 public precision = 100000;\n",
          "message": "TBoxManager.precision should be constant (TBoxManager.sol#844)\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 296,
          "vulnerability_to_line": 303,
          "vulnerability_code": "    function approve(address to, uint256 tokenId) public {\n\n        address owner = ownerOf(tokenId);\n\n        require(to != owner);\n\n        require(msg.sender == owner || isApprovedForAll(owner, msg.sender));\n\n\n\n        _tokenApprovals[tokenId] = to;\n\n        emit Approval(owner, to, tokenId);\n",
          "message": "ERC721.approve (TBoxManager.sol#296-303) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 35,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function approve(address to, uint256 tokenId) public;\n",
          "message": "IERC721.approve (TBoxManager.sol#35) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 322,
          "vulnerability_to_line": 326,
          "vulnerability_code": "    function setApprovalForAll(address to, bool approved) public {\n\n        require(to != msg.sender);\n\n        _operatorApprovals[msg.sender][to] = approved;\n\n        emit ApprovalForAll(msg.sender, to, approved);\n",
          "message": "ERC721.setApprovalForAll (TBoxManager.sol#322-326) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 38,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setApprovalForAll(address operator, bool _approved) public;\n",
          "message": "IERC721.setApprovalForAll (TBoxManager.sol#38) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 42,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function safeTransferFrom(address from, address to, uint256 tokenId) public;\n",
          "message": "IERC721.safeTransferFrom (TBoxManager.sol#42) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 369,
          "vulnerability_to_line": 372,
          "vulnerability_code": "    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n\n        // solium-disable-next-line arg-overflow\n\n        safeTransferFrom(from, to, tokenId, \"\");\n",
          "message": "ERC721.safeTransferFrom (TBoxManager.sol#369-372) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 71,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function onERC721Received(address operator, address from, uint256 tokenId, bytes memory data) public returns (bytes4);\n",
          "message": "IERC721Receiver.onERC721Received (TBoxManager.sol#71) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 509,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function tokenOfOwnerByIndex(address owner, uint256 index) public view returns (uint256 tokenId);\n",
          "message": "IERC721Enumerable.tokenOfOwnerByIndex (TBoxManager.sol#509) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 559,
          "vulnerability_to_line": 562,
          "vulnerability_code": "    function tokenOfOwnerByIndex(address owner, uint256 index) public view returns (uint256) {\n\n        require(index < balanceOf(owner));\n\n        return _ownedTokens[owner][index];\n",
          "message": "ERC721Enumerable.tokenOfOwnerByIndex (TBoxManager.sol#559-562) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 511,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function tokenByIndex(uint256 index) public view returns (uint256);\n",
          "message": "IERC721Enumerable.tokenByIndex (TBoxManager.sol#511) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 578,
          "vulnerability_to_line": 581,
          "vulnerability_code": "    function tokenByIndex(uint256 index) public view returns (uint256) {\n\n        require(index < totalSupply());\n\n        return _allTokens[index];\n",
          "message": "ERC721Enumerable.tokenByIndex (TBoxManager.sol#578-581) should be declared external\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 210,
          "vulnerability_to_line": 213,
          "vulnerability_code": "    function _registerInterface(bytes4 interfaceId) internal {\n\n        require(interfaceId != 0xffffffff);\n\n        _supportedInterfaces[interfaceId] = true;\n",
          "message": "Function 'ERC165._registerInterface' (TBoxManager.sol#210-213) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 181,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bytes4 private constant _InterfaceId_ERC165 = 0x01ffc9a7;\n",
          "message": "Constant 'ERC165._InterfaceId_ERC165' (TBoxManager.sol#181) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 386,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public {\n",
          "message": "Parameter '_data' of ERC721.safeTransferFrom (TBoxManager.sol#386) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 397,
          "vulnerability_to_line": 400,
          "vulnerability_code": "    function _exists(uint256 tokenId) internal view returns (bool) {\n\n        address owner = _tokenOwner[tokenId];\n\n        return owner != address(0);\n",
          "message": "Function 'ERC721._exists' (TBoxManager.sol#397-400) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 409,
          "vulnerability_to_line": 415,
          "vulnerability_code": "    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {\n\n        address owner = ownerOf(tokenId);\n\n        // Disable solium check because of\n\n        // https://github.com/duaraghav8/Solium/issues/175\n\n        // solium-disable-next-line operator-whitespace\n\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\n",
          "message": "Function 'ERC721._isApprovedOrOwner' (TBoxManager.sol#409-415) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 423,
          "vulnerability_to_line": 427,
          "vulnerability_code": "    function _mint(address to, uint256 tokenId) internal {\n\n        require(to != address(0));\n\n        _addTokenTo(to, tokenId);\n\n        emit Transfer(address(0), to, tokenId);\n",
          "message": "Function 'ERC721._mint' (TBoxManager.sol#423-427) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 434,
          "vulnerability_to_line": 438,
          "vulnerability_code": "    function _burn(address owner, uint256 tokenId) internal {\n\n        _clearApproval(owner, tokenId);\n\n        _removeTokenFrom(owner, tokenId);\n\n        emit Transfer(owner, address(0), tokenId);\n",
          "message": "Function 'ERC721._burn' (TBoxManager.sol#434-438) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 447,
          "vulnerability_to_line": 451,
          "vulnerability_code": "    function _addTokenTo(address to, uint256 tokenId) internal {\n\n        require(_tokenOwner[tokenId] == address(0));\n\n        _tokenOwner[tokenId] = to;\n\n        _ownedTokensCount[to] = _ownedTokensCount[to].add(1);\n",
          "message": "Function 'ERC721._addTokenTo' (TBoxManager.sol#447-451) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 461,
          "vulnerability_to_line": 465,
          "vulnerability_code": "    function _removeTokenFrom(address from, uint256 tokenId) internal {\n\n        require(ownerOf(tokenId) == from);\n\n        _ownedTokensCount[from] = _ownedTokensCount[from].sub(1);\n\n        _tokenOwner[tokenId] = address(0);\n",
          "message": "Function 'ERC721._removeTokenFrom' (TBoxManager.sol#461-465) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 476,
          "vulnerability_to_line": 483,
          "vulnerability_code": "    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data) internal returns (bool) {\n\n        if (!to.isContract()) {\n\n            return true;\n\n        }\n\n\n\n        bytes4 retval = IERC721Receiver(to).onERC721Received(msg.sender, from, tokenId, _data);\n\n        return (retval == _ERC721_RECEIVED);\n",
          "message": "Function 'ERC721._checkOnERC721Received' (TBoxManager.sol#476-483) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 476,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data) internal returns (bool) {\n",
          "message": "Parameter '_data' of ERC721._checkOnERC721Received (TBoxManager.sol#476) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 491,
          "vulnerability_to_line": 496,
          "vulnerability_code": "    function _clearApproval(address owner, uint256 tokenId) private {\n\n        require(ownerOf(tokenId) == owner);\n\n        if (_tokenApprovals[tokenId] != address(0)) {\n\n            _tokenApprovals[tokenId] = address(0);\n\n        }\n",
          "message": "Function 'ERC721._clearApproval' (TBoxManager.sol#491-496) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 237,
          "vulnerability_to_line": null,
          "vulnerability_code": "    mapping (uint256 => address) internal _tokenOwner;\n",
          "message": "Variable 'ERC721._tokenOwner' (TBoxManager.sol#237) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 248,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bytes4 private constant _InterfaceId_ERC721 = 0x80ac58cd;\n",
          "message": "Constant 'ERC721._InterfaceId_ERC721' (TBoxManager.sol#248) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 632,
          "vulnerability_to_line": 637,
          "vulnerability_code": "    function _mint(address to, uint256 tokenId) internal {\n\n        super._mint(to, tokenId);\n\n\n\n        _allTokensIndex[tokenId] = _allTokens.length;\n\n        _allTokens.push(tokenId);\n",
          "message": "Function 'ERC721Enumerable._mint' (TBoxManager.sol#632-637) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 645,
          "vulnerability_to_line": 659,
          "vulnerability_code": "    function _burn(address owner, uint256 tokenId) internal {\n\n        super._burn(owner, tokenId);\n\n\n\n        // Reorg all tokens array\n\n        uint256 tokenIndex = _allTokensIndex[tokenId];\n\n        uint256 lastTokenIndex = _allTokens.length.sub(1);\n\n        uint256 lastToken = _allTokens[lastTokenIndex];\n\n\n\n        _allTokens[tokenIndex] = lastToken;\n\n        _allTokens[lastTokenIndex] = 0;\n\n\n\n        _allTokens.length--;\n\n        _allTokensIndex[tokenId] = 0;\n\n        _allTokensIndex[lastToken] = tokenIndex;\n",
          "message": "Function 'ERC721Enumerable._burn' (TBoxManager.sol#645-659) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 590,
          "vulnerability_to_line": 595,
          "vulnerability_code": "    function _addTokenTo(address to, uint256 tokenId) internal {\n\n        super._addTokenTo(to, tokenId);\n\n        uint256 length = _ownedTokens[to].length;\n\n        _ownedTokens[to].push(tokenId);\n\n        _ownedTokensIndex[tokenId] = length;\n",
          "message": "Function 'ERC721Enumerable._addTokenTo' (TBoxManager.sol#590-595) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 605,
          "vulnerability_to_line": 624,
          "vulnerability_code": "    function _removeTokenFrom(address from, uint256 tokenId) internal {\n\n        super._removeTokenFrom(from, tokenId);\n\n\n\n        // To prevent a gap in the array, we store the last token in the index of the token to delete, and\n\n        // then delete the last slot.\n\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\n\n        uint256 lastTokenIndex = _ownedTokens[from].length.sub(1);\n\n        uint256 lastToken = _ownedTokens[from][lastTokenIndex];\n\n\n\n        _ownedTokens[from][tokenIndex] = lastToken;\n\n        // This also deletes the contents at the last position of the array\n\n        _ownedTokens[from].length--;\n\n\n\n        // Note that this will handle single-element arrays. In that case, both tokenIndex and lastTokenIndex are going to\n\n        // be zero. Then we can make sure that we will remove tokenId from the ownedTokens list since we are first swapping\n\n        // the lastToken to the first position, and then dropping the element placed in the last position of the list\n\n\n\n        _ownedTokensIndex[tokenId] = 0;\n\n        _ownedTokensIndex[lastToken] = tokenIndex;\n",
          "message": "Function 'ERC721Enumerable._removeTokenFrom' (TBoxManager.sol#605-624) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 537,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bytes4 private constant _InterfaceId_ERC721Enumerable = 0x780e9d63;\n",
          "message": "Constant 'ERC721Enumerable._InterfaceId_ERC721Enumerable' (TBoxManager.sol#537) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 754,
          "vulnerability_to_line": 761,
          "vulnerability_code": "    function _burn(address owner, uint256 tokenId) internal {\n\n        super._burn(owner, tokenId);\n\n\n\n        // Clear metadata (if any)\n\n        if (bytes(_tokenURIs[tokenId]).length != 0) {\n\n            delete _tokenURIs[tokenId];\n\n        }\n",
          "message": "Function 'ERC721Metadata._burn' (TBoxManager.sol#754-761) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 743,
          "vulnerability_to_line": 746,
          "vulnerability_code": "    function _setTokenURI(uint256 tokenId, string memory uri) internal {\n\n        require(_exists(tokenId));\n\n        _tokenURIs[tokenId] = uri;\n",
          "message": "Function 'ERC721Metadata._setTokenURI' (TBoxManager.sol#743-746) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 692,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bytes4 private constant InterfaceId_ERC721Metadata = 0x5b5e139f;\n",
          "message": "Constant 'ERC721Metadata.InterfaceId_ERC721Metadata' (TBoxManager.sol#692) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 916,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor(address _settings) TBoxToken(\"TBoxToken\", \"TBX\") public {\n",
          "message": "Parameter '_settings' of TBoxManager. (TBoxManager.sol#916) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 928,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function withdrawFee(address _beneficiary) external onlyAdmin {\n",
          "message": "Parameter '_beneficiary' of TBoxManager.withdrawFee (TBoxManager.sol#928) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 946,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function create(uint256 _tokensToWithdraw) public payable validTx returns (uint256) {\n",
          "message": "Parameter '_tokensToWithdraw' of TBoxManager.create (TBoxManager.sol#946) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 998,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function close(uint256 _id) external onlyApprovedOrOwner(_id) {\n",
          "message": "Parameter '_id' of TBoxManager.close (TBoxManager.sol#998) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1029,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function capitalizeMax(uint256 _id) external {\n",
          "message": "Parameter '_id' of TBoxManager.capitalizeMax (TBoxManager.sol#1029) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1036,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function capitalize(uint256 _id, uint256 _tmv) public validTx {\n",
          "message": "Parameter '_id' of TBoxManager.capitalize (TBoxManager.sol#1036) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1036,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function capitalize(uint256 _id, uint256 _tmv) public validTx {\n",
          "message": "Parameter '_tmv' of TBoxManager.capitalize (TBoxManager.sol#1036) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1077,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function withdrawEthMax(uint256 _id) external {\n",
          "message": "Parameter '_id' of TBoxManager.withdrawEthMax (TBoxManager.sol#1077) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1085,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function withdrawEth(uint256 _id, uint256 _amount) public onlyApprovedOrOwner(_id) validTx {\n",
          "message": "Parameter '_id' of TBoxManager.withdrawEth (TBoxManager.sol#1085) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1085,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function withdrawEth(uint256 _id, uint256 _amount) public onlyApprovedOrOwner(_id) validTx {\n",
          "message": "Parameter '_amount' of TBoxManager.withdrawEth (TBoxManager.sol#1085) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1107,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function withdrawTmvMax(uint256 _id) external onlyApprovedOrOwner(_id) {\n",
          "message": "Parameter '_id' of TBoxManager.withdrawTmvMax (TBoxManager.sol#1107) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1115,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function withdrawTmv(uint256 _id, uint256 _amount) public onlyApprovedOrOwner(_id) validTx {\n",
          "message": "Parameter '_id' of TBoxManager.withdrawTmv (TBoxManager.sol#1115) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1115,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function withdrawTmv(uint256 _id, uint256 _amount) public onlyApprovedOrOwner(_id) validTx {\n",
          "message": "Parameter '_amount' of TBoxManager.withdrawTmv (TBoxManager.sol#1115) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1133,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function addEth(uint256 _id) external payable onlyExists(_id) {\n",
          "message": "Parameter '_id' of TBoxManager.addEth (TBoxManager.sol#1133) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1149,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function addTmv(uint256 _id, uint256 _amount) external onlyExists(_id) {\n",
          "message": "Parameter '_id' of TBoxManager.addTmv (TBoxManager.sol#1149) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1149,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function addTmv(uint256 _id, uint256 _amount) external onlyExists(_id) {\n",
          "message": "Parameter '_amount' of TBoxManager.addTmv (TBoxManager.sol#1149) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1166,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function closeDust(uint256 _id) external onlyExists(_id) validTx {\n",
          "message": "Parameter '_id' of TBoxManager.closeDust (TBoxManager.sol#1166) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1206,
          "vulnerability_to_line": 1211,
          "vulnerability_code": "    function _burnTMV(address _from, uint256 _amount) internal {\n\n        if (_amount > 0) {\n\n            require(IToken(settings.tmvAddress()).balanceOf(_from) >= _amount, \"You don't have enough tokens\");\n\n            IToken(settings.tmvAddress()).burnLogic(_from, _amount);\n\n        }\n",
          "message": "Function 'TBoxManager._burnTMV' (TBoxManager.sol#1206-1211) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1206,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _burnTMV(address _from, uint256 _amount) internal {\n",
          "message": "Parameter '_from' of TBoxManager._burnTMV (TBoxManager.sol#1206) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1206,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _burnTMV(address _from, uint256 _amount) internal {\n",
          "message": "Parameter '_amount' of TBoxManager._burnTMV (TBoxManager.sol#1206) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1219,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function boxWithdrawableTmv(uint256 _id) public view onlyExists(_id) returns(uint256) {\n",
          "message": "Parameter '_id' of TBoxManager.boxWithdrawableTmv (TBoxManager.sol#1219) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1234,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function withdrawableEth(uint256 _id) public view onlyExists(_id) returns(uint256) {\n",
          "message": "Parameter '_id' of TBoxManager.withdrawableEth (TBoxManager.sol#1234) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1250,
          "vulnerability_to_line": 1292,
          "vulnerability_code": "    function _freeEth(uint256 _id) internal view returns(uint256) {\n\n        // Grab a reference to the Box\n\n        Box memory box = boxes[_id];\n\n\n\n        // When there are no tokens withdrawn\n\n        if (box.tmvReleased == 0) {\n\n            return box.collateral;\n\n        }\n\n\n\n        // The amount of Ether that can be safely withdrawn from the system\n\n        uint256 _maxGlobal = globalWithdrawableEth();\n\n        uint256 _globalAvailable;\n\n\n\n        if (_maxGlobal > 0) {\n\n            // The amount of Ether backing the tokens when the system is overcapitalized\n\n            uint256 _need = overCapFrozenEth(box.tmvReleased);\n\n            if (box.collateral > _need) {\n\n                // Free Ether amount when the system is overcapitalized\n\n                uint256 _free = box.collateral.sub(_need);\n\n                if (_free > _maxGlobal) {\n\n                    // Store available amount when Box available Ether amount\n\n                    // is more than global available\n\n                    _globalAvailable = _maxGlobal;\n\n                }\n\n\n\n                // Return available amount of Ether to withdraw when the Box withdrawable\n\n                // amount of Ether is smaller than global withdrawable amount of Ether\n\n                else return _free;\n\n            }\n\n        }\n\n\n\n        // The amount of Ether backing the tokens by default\n\n        uint256 _frozen = defaultFrozenEth(box.tmvReleased);\n\n        if (box.collateral > _frozen) {\n\n            // Define the biggest number and return available Ether amount\n\n            uint256 _localAvailable = box.collateral.sub(_frozen);\n\n            return (_localAvailable > _globalAvailable) ? _localAvailable : _globalAvailable;\n\n        } else {\n\n            // Return available Ether amount\n\n            return _globalAvailable;\n\n        }\n\n\n",
          "message": "Function 'TBoxManager._freeEth' (TBoxManager.sol#1250-1292) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1250,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _freeEth(uint256 _id) internal view returns(uint256) {\n",
          "message": "Parameter '_id' of TBoxManager._freeEth (TBoxManager.sol#1250) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1295,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function collateralPercent(uint256 _id) public view onlyExists(_id) returns(uint256) {\n",
          "message": "Parameter '_id' of TBoxManager.collateralPercent (TBoxManager.sol#1295) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1308,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function isApprovedOrOwner(address _spender, uint256 _tokenId) external view returns (bool) {\n",
          "message": "Parameter '_spender' of TBoxManager.isApprovedOrOwner (TBoxManager.sol#1308) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1308,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function isApprovedOrOwner(address _spender, uint256 _tokenId) external view returns (bool) {\n",
          "message": "Parameter '_tokenId' of TBoxManager.isApprovedOrOwner (TBoxManager.sol#1308) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1322,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function globalWithdrawableTmv(uint256 _value) public view returns (uint256) {\n",
          "message": "Parameter '_value' of TBoxManager.globalWithdrawableTmv (TBoxManager.sol#1322) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1343,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function defaultWithdrawableTmv(uint256 _collateral) public view returns (uint256) {\n",
          "message": "Parameter '_collateral' of TBoxManager.defaultWithdrawableTmv (TBoxManager.sol#1343) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1351,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function overCapWithdrawableTmv(uint256 _collateral) public view returns (uint256) {\n",
          "message": "Parameter '_collateral' of TBoxManager.overCapWithdrawableTmv (TBoxManager.sol#1351) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1358,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function defaultFrozenEth(uint256 _supply) public view returns (uint256) {\n",
          "message": "Parameter '_supply' of TBoxManager.defaultFrozenEth (TBoxManager.sol#1358) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1365,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function overCapFrozenEth(uint256 _supply) public view returns (uint256) {\n",
          "message": "Parameter '_supply' of TBoxManager.overCapFrozenEth (TBoxManager.sol#1365) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1371,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function maxCapAmount(uint256 _id) public view onlyExists(_id) returns (uint256) {\n",
          "message": "Parameter '_id' of TBoxManager.maxCapAmount (TBoxManager.sol#1371) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1384,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function withdrawableTmv(uint256 _collateral) public view returns(uint256) {\n",
          "message": "Parameter '_collateral' of TBoxManager.withdrawableTmv (TBoxManager.sol#1384) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1399,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function withdrawPercent(uint256 _collateral) external view returns(uint256) {\n",
          "message": "Parameter '_collateral' of TBoxManager.withdrawPercent (TBoxManager.sol#1399) is not in mixedCase\n"
        }
      ]
    },
    "smartcheck": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 181,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bytes4 private constant _InterfaceId_ERC165 = 0x01ffc9a7;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 211,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(interfaceId != 0xffffffff);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 234,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 248,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bytes4 private constant _InterfaceId_ERC721 = 0x80ac58cd;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 537,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bytes4 private constant _InterfaceId_ERC721Enumerable = 0x780e9d63;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 692,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bytes4 private constant InterfaceId_ERC721Metadata = 0x5b5e139f;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 464,
          "vulnerability_to_line": null,
          "vulnerability_code": "        _tokenOwner[tokenId] = address(0);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 494,
          "vulnerability_to_line": null,
          "vulnerability_code": "            _tokenApprovals[tokenId] = address(0);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ARRAY_LENGTH_MANIPULATION",
          "vulnerability_from_line": 616,
          "vulnerability_to_line": null,
          "vulnerability_code": "        _ownedTokens[from].length--;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ARRAY_LENGTH_MANIPULATION",
          "vulnerability_from_line": 656,
          "vulnerability_to_line": null,
          "vulnerability_code": "        _allTokens.length--;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 181,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bytes4 private constant _InterfaceId_ERC165 = 0x01ffc9a7;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 190,
          "vulnerability_to_line": null,
          "vulnerability_code": "    mapping(bytes4 => bool) private _supportedInterfaces;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 234,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 240,
          "vulnerability_to_line": null,
          "vulnerability_code": "    mapping (uint256 => address) private _tokenApprovals;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 243,
          "vulnerability_to_line": null,
          "vulnerability_code": "    mapping (address => uint256) private _ownedTokensCount;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 246,
          "vulnerability_to_line": null,
          "vulnerability_code": "    mapping (address => mapping (address => bool)) private _operatorApprovals;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 248,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bytes4 private constant _InterfaceId_ERC721 = 0x80ac58cd;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 526,
          "vulnerability_to_line": null,
          "vulnerability_code": "    mapping(address => uint256[]) private _ownedTokens;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 529,
          "vulnerability_to_line": null,
          "vulnerability_code": "    mapping(uint256 => uint256) private _ownedTokensIndex;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 532,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint256[] private _allTokens;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 535,
          "vulnerability_to_line": null,
          "vulnerability_code": "    mapping(uint256 => uint256) private _allTokensIndex;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 537,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bytes4 private constant _InterfaceId_ERC721Enumerable = 0x780e9d63;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 684,
          "vulnerability_to_line": null,
          "vulnerability_code": "    string private _name;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 687,
          "vulnerability_to_line": null,
          "vulnerability_code": "    string private _symbol;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 690,
          "vulnerability_to_line": null,
          "vulnerability_code": "    mapping(uint256 => string) private _tokenURIs;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 692,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bytes4 private constant InterfaceId_ERC721Metadata = 0x5b5e139f;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SAFEMATH",
          "vulnerability_from_line": 229,
          "vulnerability_to_line": null,
          "vulnerability_code": "    using SafeMath for uint256;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
          "vulnerability_from_line": 157,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function isContract(address account) internal view returns (bool) {\n",
          "message": null
        }
      ]
    },
    "oyente": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "Integer Overflow",
          "vulnerability_from_line": 386,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public {\n",
          "message": null
        },
        {
          "name": "Integer Overflow",
          "vulnerability_from_line": 561,
          "vulnerability_to_line": null,
          "vulnerability_code": "        return _ownedTokens[owner][index];\n",
          "message": null
        },
        {
          "name": "Integer Overflow",
          "vulnerability_from_line": 386,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public {\n",
          "message": null
        },
        {
          "name": "Integer Underflow",
          "vulnerability_from_line": 716,
          "vulnerability_to_line": null,
          "vulnerability_code": "        return _name;\n",
          "message": null
        },
        {
          "name": "Integer Overflow",
          "vulnerability_from_line": 1296,
          "vulnerability_to_line": null,
          "vulnerability_code": "        Box memory box = boxes[_id];\n",
          "message": null
        },
        {
          "name": "Integer Underflow",
          "vulnerability_from_line": 716,
          "vulnerability_to_line": null,
          "vulnerability_code": "        return _name;\n",
          "message": null
        },
        {
          "name": "Integer Overflow",
          "vulnerability_from_line": 561,
          "vulnerability_to_line": null,
          "vulnerability_code": "        return _ownedTokens[owner][index];\n",
          "message": null
        },
        {
          "name": "Integer Underflow",
          "vulnerability_from_line": 716,
          "vulnerability_to_line": null,
          "vulnerability_code": "        return _name;\n",
          "message": null
        }
      ]
    },
    "mythril": {
      "successfull_analysis": false,
      "errors": [
        "DOCKER_TIMEOUT"
      ],
      "vulnerability_findings": []
    },
    "osiris": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "Overflow bugs",
          "vulnerability_from_line": 1,
          "vulnerability_to_line": null,
          "vulnerability_code": "// File: ../sc_datasets/DAppSCAN/Coinfabrik-Timvi Smart Contract Audit/Timvi-master/contracts/helpers/IERC165.sol\n",
          "message": null
        }
      ]
    }
  }
}