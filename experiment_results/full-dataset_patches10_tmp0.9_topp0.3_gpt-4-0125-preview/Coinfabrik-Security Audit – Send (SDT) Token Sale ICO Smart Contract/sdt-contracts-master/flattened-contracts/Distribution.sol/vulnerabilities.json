{
  "smartbugs_completed": true,
  "analyzer_results": {
    "semgrep": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "use-ownable2step",
          "vulnerability_from_line": 168,
          "vulnerability_to_line": null,
          "vulnerability_code": "contract Distribution is Ownable {\n",
          "message": "By demanding that the receiver of the owner permissions actively accept via a contract call of its own,  `Ownable2Step` and `Ownable2StepUpgradeable` prevent the contract ownership from accidentally being transferred  to an address that cannot handle it."
        }
      ]
    },
    "slither": {
      "successfull_analysis": true,
      "errors": [
        "EXIT_CODE_42"
      ],
      "vulnerability_findings": [
        {
          "name": "incorrect-equality",
          "vulnerability_from_line": 244,
          "vulnerability_to_line": 255,
          "vulnerability_code": "  function init(uint256 _cap, uint256 _startTime) public onlyOwner {\n\n    require(!isActive);\n\n    require(token.balanceOf(this) == _cap);\n\n    require(_startTime > block.timestamp);\n\n\n\n    startTime = _startTime;\n\n    cap = _cap;\n\n    stageCap = cap / stages;\n\n    isActive = true;\n\n  }\n\n\n",
          "message": "Distribution.init (Distribution.sol#244-255) uses a dangerous strict equality:\n\t- require(bool)(token.balanceOf(this) == _cap)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 259,
          "vulnerability_to_line": 276,
          "vulnerability_code": "  function claimBonus(uint16 _stage) public {\n\n    require(!claimed[msg.sender][_stage]);\n\n    require(getStage() > _stage);\n\n\n\n    if (!burned[_stage]) {\n\n      token.burn(stageCap.sub(sold[_stage]).sub(sold[_stage].mul(computeBonus(_stage)).div(1 ether)));\n\n      burned[_stage] = true;\n\n    }\n\n\n\n    uint256 tokens = computeAddressBonus(_stage);\n\n    token.transfer(msg.sender, tokens);\n\n    bonusClaimedTokens = bonusClaimedTokens.add(tokens);\n\n    claimed[msg.sender][_stage] = true;\n\n\n\n    NewBonusClaim(msg.sender, tokens);\n\n  }\n\n\n",
          "message": "Reentrancy in Distribution.claimBonus (Distribution.sol#259-276):\n\tExternal calls:\n\t- token.burn(stageCap.sub(sold[_stage]).sub(sold[_stage].mul(computeBonus(_stage)).div(1000000000000000000))) (Distribution.sol#264-265)\n\tState variables written after the call(s):\n\t- burned (Distribution.sol#265-266)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 259,
          "vulnerability_to_line": 276,
          "vulnerability_code": "  function claimBonus(uint16 _stage) public {\n\n    require(!claimed[msg.sender][_stage]);\n\n    require(getStage() > _stage);\n\n\n\n    if (!burned[_stage]) {\n\n      token.burn(stageCap.sub(sold[_stage]).sub(sold[_stage].mul(computeBonus(_stage)).div(1 ether)));\n\n      burned[_stage] = true;\n\n    }\n\n\n\n    uint256 tokens = computeAddressBonus(_stage);\n\n    token.transfer(msg.sender, tokens);\n\n    bonusClaimedTokens = bonusClaimedTokens.add(tokens);\n\n    claimed[msg.sender][_stage] = true;\n\n\n\n    NewBonusClaim(msg.sender, tokens);\n\n  }\n\n\n",
          "message": "Reentrancy in Distribution.claimBonus (Distribution.sol#259-276):\n\tExternal calls:\n\t- token.burn(stageCap.sub(sold[_stage]).sub(sold[_stage].mul(computeBonus(_stage)).div(1000000000000000000))) (Distribution.sol#264-265)\n\t- token.transfer(msg.sender,tokens) (Distribution.sol#269-270)\n\tState variables written after the call(s):\n\t- claimed (Distribution.sol#271-272)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 244,
          "vulnerability_to_line": 255,
          "vulnerability_code": "  function init(uint256 _cap, uint256 _startTime) public onlyOwner {\n\n    require(!isActive);\n\n    require(token.balanceOf(this) == _cap);\n\n    require(_startTime > block.timestamp);\n\n\n\n    startTime = _startTime;\n\n    cap = _cap;\n\n    stageCap = cap / stages;\n\n    isActive = true;\n\n  }\n\n\n",
          "message": "Reentrancy in Distribution.init (Distribution.sol#244-255):\n\tExternal calls:\n\t- require(bool)(token.balanceOf(this) == _cap) (Distribution.sol#246-247)\n\tState variables written after the call(s):\n\t- isActive (Distribution.sol#252-253)\n"
        },
        {
          "name": "unused-return",
          "vulnerability_from_line": 219,
          "vulnerability_to_line": 240,
          "vulnerability_code": "  function () external payable {\n\n    require(isActive);\n\n    require(weiUsdRate > 0);\n\n    require(getStage() < stages);\n\n\n\n    uint256 usd = msg.value / weiUsdRate;\n\n    uint256 tokens = computeTokens(usd);\n\n    uint16 stage = getStage();\n\n\n\n    sold[stage] = sold[stage].add(tokens);\n\n    require(sold[stage] < stageCap);\n\n\n\n    contributions[msg.sender][stage] = contributions[msg.sender][stage].add(tokens);\n\n    soldTokens = soldTokens.add(tokens);\n\n    raisedETH = raisedETH.add(msg.value);\n\n    raisedUSD = raisedUSD.add(usd);\n\n\n\n    NewPurchase(msg.sender, tokens, usd, msg.value);\n\n    token.transfer(msg.sender, tokens);\n\n  }\n\n\n",
          "message": "Distribution.fallback (Distribution.sol#219-240) does not use the value returned by external calls:\n\t-token.transfer(msg.sender,tokens) (Distribution.sol#237-238)\n"
        },
        {
          "name": "unused-return",
          "vulnerability_from_line": 259,
          "vulnerability_to_line": 276,
          "vulnerability_code": "  function claimBonus(uint16 _stage) public {\n\n    require(!claimed[msg.sender][_stage]);\n\n    require(getStage() > _stage);\n\n\n\n    if (!burned[_stage]) {\n\n      token.burn(stageCap.sub(sold[_stage]).sub(sold[_stage].mul(computeBonus(_stage)).div(1 ether)));\n\n      burned[_stage] = true;\n\n    }\n\n\n\n    uint256 tokens = computeAddressBonus(_stage);\n\n    token.transfer(msg.sender, tokens);\n\n    bonusClaimedTokens = bonusClaimedTokens.add(tokens);\n\n    claimed[msg.sender][_stage] = true;\n\n\n\n    NewBonusClaim(msg.sender, tokens);\n\n  }\n\n\n",
          "message": "Distribution.claimBonus (Distribution.sol#259-276) does not use the value returned by external calls:\n\t-token.transfer(msg.sender,tokens) (Distribution.sol#269-270)\n"
        },
        {
          "name": "unused-return",
          "vulnerability_from_line": 335,
          "vulnerability_to_line": 349,
          "vulnerability_code": "  function claimTokens(address _token) public onlyOwner {\n\n    // owner can claim any token but SDT\n\n    require(_token != address(token));\n\n    if (_token == 0x0) {\n\n      owner.transfer(this.balance);\n\n      return;\n\n    }\n\n\n\n    ERC20Basic erc20token = ERC20Basic(_token);\n\n    uint256 balance = erc20token.balanceOf(this);\n\n    erc20token.transfer(owner, balance);\n\n    ClaimedTokens(_token, owner, balance);\n\n  }\n\n\n",
          "message": "Distribution.claimTokens (Distribution.sol#335-349) does not use the value returned by external calls:\n\t-erc20token.transfer(owner,balance) (Distribution.sol#345-346)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 259,
          "vulnerability_to_line": 276,
          "vulnerability_code": "  function claimBonus(uint16 _stage) public {\n\n    require(!claimed[msg.sender][_stage]);\n\n    require(getStage() > _stage);\n\n\n\n    if (!burned[_stage]) {\n\n      token.burn(stageCap.sub(sold[_stage]).sub(sold[_stage].mul(computeBonus(_stage)).div(1 ether)));\n\n      burned[_stage] = true;\n\n    }\n\n\n\n    uint256 tokens = computeAddressBonus(_stage);\n\n    token.transfer(msg.sender, tokens);\n\n    bonusClaimedTokens = bonusClaimedTokens.add(tokens);\n\n    claimed[msg.sender][_stage] = true;\n\n\n\n    NewBonusClaim(msg.sender, tokens);\n\n  }\n\n\n",
          "message": "Reentrancy in Distribution.claimBonus (Distribution.sol#259-276):\n\tExternal calls:\n\t- token.burn(stageCap.sub(sold[_stage]).sub(sold[_stage].mul(computeBonus(_stage)).div(1000000000000000000))) (Distribution.sol#264-265)\n\t- token.transfer(msg.sender,tokens) (Distribution.sol#269-270)\n\tState variables written after the call(s):\n\t- bonusClaimedTokens (Distribution.sol#270-271)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 244,
          "vulnerability_to_line": 255,
          "vulnerability_code": "  function init(uint256 _cap, uint256 _startTime) public onlyOwner {\n\n    require(!isActive);\n\n    require(token.balanceOf(this) == _cap);\n\n    require(_startTime > block.timestamp);\n\n\n\n    startTime = _startTime;\n\n    cap = _cap;\n\n    stageCap = cap / stages;\n\n    isActive = true;\n\n  }\n\n\n",
          "message": "Reentrancy in Distribution.init (Distribution.sol#244-255):\n\tExternal calls:\n\t- require(bool)(token.balanceOf(this) == _cap) (Distribution.sol#246-247)\n\tState variables written after the call(s):\n\t- cap (Distribution.sol#250-251)\n\t- stageCap (Distribution.sol#251-252)\n\t- startTime (Distribution.sol#249-250)\n"
        },
        {
          "name": "timestamp",
          "vulnerability_from_line": 244,
          "vulnerability_to_line": 255,
          "vulnerability_code": "  function init(uint256 _cap, uint256 _startTime) public onlyOwner {\n\n    require(!isActive);\n\n    require(token.balanceOf(this) == _cap);\n\n    require(_startTime > block.timestamp);\n\n\n\n    startTime = _startTime;\n\n    cap = _cap;\n\n    stageCap = cap / stages;\n\n    isActive = true;\n\n  }\n\n\n",
          "message": "Distribution.init (Distribution.sol#244-255) uses timestamp for comparisons\n\tDangerous comparisons:\n\t- require(bool)(_startTime > block.timestamp) (Distribution.sol#247-248)\n"
        },
        {
          "name": "timestamp",
          "vulnerability_from_line": 307,
          "vulnerability_to_line": 312,
          "vulnerability_code": "  function getStage() public view returns(uint16) {\n\n    require(block.timestamp >= startTime);\n\n    return uint16(uint256(block.timestamp).sub(startTime).div(stageDuration));\n\n  }\n\n\n",
          "message": "Distribution.getStage (Distribution.sol#307-312) uses timestamp for comparisons\n\tDangerous comparisons:\n\t- require(bool)(block.timestamp >= startTime) (Distribution.sol#308-309)\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 76,
          "vulnerability_to_line": 82,
          "vulnerability_code": "  function transferOwnership(address newOwner) public onlyOwner {\n\n    require(newOwner != address(0));\n\n    OwnershipTransferred(owner, newOwner);\n\n    owner = newOwner;\n\n  }\n\n\n",
          "message": "Ownable.transferOwnership (Distribution.sol#76-82) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 130,
          "vulnerability_to_line": 134,
          "vulnerability_code": "  function balanceOf(address _owner) public view returns (uint256 balance) {\n\n    return balances[_owner];\n\n  }\n\n\n",
          "message": "BasicToken.balanceOf (Distribution.sol#130-134) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 93,
          "vulnerability_to_line": 94,
          "vulnerability_code": "  function balanceOf(address who) public view returns (uint256);\n",
          "message": "ERC20Basic.balanceOf (Distribution.sol#93-94) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 114,
          "vulnerability_to_line": 125,
          "vulnerability_code": "  function transfer(address _to, uint256 _value) public returns (bool) {\n\n    require(_to != address(0));\n\n    require(_value <= balances[msg.sender]);\n\n\n\n    // SafeMath.sub will throw if there is not enough balance.\n\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n\n    balances[_to] = balances[_to].add(_value);\n\n    Transfer(msg.sender, _to, _value);\n\n    return true;\n\n  }\n\n\n",
          "message": "BasicToken.transfer (Distribution.sol#114-125) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 94,
          "vulnerability_to_line": 95,
          "vulnerability_code": "  function transfer(address to, uint256 value) public returns (bool);\n",
          "message": "ERC20Basic.transfer (Distribution.sol#94-95) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 150,
          "vulnerability_to_line": 160,
          "vulnerability_code": "    function burn(uint256 _value) public {\n\n        require(_value <= balances[msg.sender]);\n\n        // no need to require value <= totalSupply, since that would imply the\n\n        // sender's balance is greater than the totalSupply, which *should* be an assertion failure\n\n\n\n        address burner = msg.sender;\n\n        balances[burner] = balances[burner].sub(_value);\n\n        totalSupply = totalSupply.sub(_value);\n\n        Burn(burner, _value);\n\n    }\n",
          "message": "BurnableToken.burn (Distribution.sol#150-160) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 244,
          "vulnerability_to_line": 255,
          "vulnerability_code": "  function init(uint256 _cap, uint256 _startTime) public onlyOwner {\n\n    require(!isActive);\n\n    require(token.balanceOf(this) == _cap);\n\n    require(_startTime > block.timestamp);\n\n\n\n    startTime = _startTime;\n\n    cap = _cap;\n\n    stageCap = cap / stages;\n\n    isActive = true;\n\n  }\n\n\n",
          "message": "Distribution.init (Distribution.sol#244-255) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 259,
          "vulnerability_to_line": 276,
          "vulnerability_code": "  function claimBonus(uint16 _stage) public {\n\n    require(!claimed[msg.sender][_stage]);\n\n    require(getStage() > _stage);\n\n\n\n    if (!burned[_stage]) {\n\n      token.burn(stageCap.sub(sold[_stage]).sub(sold[_stage].mul(computeBonus(_stage)).div(1 ether)));\n\n      burned[_stage] = true;\n\n    }\n\n\n\n    uint256 tokens = computeAddressBonus(_stage);\n\n    token.transfer(msg.sender, tokens);\n\n    bonusClaimedTokens = bonusClaimedTokens.add(tokens);\n\n    claimed[msg.sender][_stage] = true;\n\n\n\n    NewBonusClaim(msg.sender, tokens);\n\n  }\n\n\n",
          "message": "Distribution.claimBonus (Distribution.sol#259-276) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 280,
          "vulnerability_to_line": 285,
          "vulnerability_code": "  function setWeiUsdRate(uint256 _rate) public onlyOwner {\n\n    require(_rate > 0);\n\n    weiUsdRate = _rate;\n\n  }\n\n\n",
          "message": "Distribution.setWeiUsdRate (Distribution.sol#280-285) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 290,
          "vulnerability_to_line": 294,
          "vulnerability_code": "  function forwardFunds(uint256 _amount, address _address) public onlyOwner {\n\n    _address.transfer(_amount);\n\n  }\n\n\n",
          "message": "Distribution.forwardFunds (Distribution.sol#290-294) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 335,
          "vulnerability_to_line": 349,
          "vulnerability_code": "  function claimTokens(address _token) public onlyOwner {\n\n    // owner can claim any token but SDT\n\n    require(_token != address(token));\n\n    if (_token == 0x0) {\n\n      owner.transfer(this.balance);\n\n      return;\n\n    }\n\n\n\n    ERC20Basic erc20token = ERC20Basic(_token);\n\n    uint256 balance = erc20token.balanceOf(this);\n\n    erc20token.transfer(owner, balance);\n\n    ClaimedTokens(_token, owner, balance);\n\n  }\n\n\n",
          "message": "Distribution.claimTokens (Distribution.sol#335-349) should be declared external\n"
        },
        {
          "name": "solc-version",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": 5,
          "vulnerability_code": "pragma solidity ^0.4.18;\n\n\n",
          "message": "Detected issues with version pragma in Distribution.sol:\n\t- pragma solidity^0.4.18 (Distribution.sol#3-5): it allows old versions\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 58,
          "vulnerability_to_line": 62,
          "vulnerability_code": "  function Ownable() public {\n\n    owner = msg.sender;\n\n  }\n\n\n",
          "message": "Function 'Ownable.Ownable' (Distribution.sol#58-62) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 130,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function balanceOf(address _owner) public view returns (uint256 balance) {\n",
          "message": "Parameter '_owner' of BasicToken.balanceOf (Distribution.sol#130) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 114,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function transfer(address _to, uint256 _value) public returns (bool) {\n",
          "message": "Parameter '_to' of BasicToken.transfer (Distribution.sol#114) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 114,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function transfer(address _to, uint256 _value) public returns (bool) {\n",
          "message": "Parameter '_value' of BasicToken.transfer (Distribution.sol#114) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 150,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function burn(uint256 _value) public {\n",
          "message": "Parameter '_value' of BurnableToken.burn (Distribution.sol#150) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 205,
          "vulnerability_to_line": 216,
          "vulnerability_code": "  function Distribution(\n\n      uint16 _stages,\n\n      uint256 _stageDuration,\n\n      address _token\n\n  ) public {\n\n    stages = _stages;\n\n    stageDuration = _stageDuration;\n\n    isActive = false;\n\n    token = BurnableToken(_token);\n\n  }\n\n\n",
          "message": "Function 'Distribution.Distribution' (Distribution.sol#205-216) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 206,
          "vulnerability_to_line": 207,
          "vulnerability_code": "      uint16 _stages,\n",
          "message": "Parameter '_stages' of Distribution.Distribution (Distribution.sol#206-207) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 207,
          "vulnerability_to_line": 208,
          "vulnerability_code": "      uint256 _stageDuration,\n",
          "message": "Parameter '_stageDuration' of Distribution.Distribution (Distribution.sol#207-208) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 208,
          "vulnerability_to_line": 209,
          "vulnerability_code": "      address _token\n",
          "message": "Parameter '_token' of Distribution.Distribution (Distribution.sol#208-209) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 244,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function init(uint256 _cap, uint256 _startTime) public onlyOwner {\n",
          "message": "Parameter '_cap' of Distribution.init (Distribution.sol#244) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 244,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function init(uint256 _cap, uint256 _startTime) public onlyOwner {\n",
          "message": "Parameter '_startTime' of Distribution.init (Distribution.sol#244) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 259,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function claimBonus(uint16 _stage) public {\n",
          "message": "Parameter '_stage' of Distribution.claimBonus (Distribution.sol#259) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 280,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function setWeiUsdRate(uint256 _rate) public onlyOwner {\n",
          "message": "Parameter '_rate' of Distribution.setWeiUsdRate (Distribution.sol#280) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 290,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function forwardFunds(uint256 _amount, address _address) public onlyOwner {\n",
          "message": "Parameter '_amount' of Distribution.forwardFunds (Distribution.sol#290) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 290,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function forwardFunds(uint256 _amount, address _address) public onlyOwner {\n",
          "message": "Parameter '_address' of Distribution.forwardFunds (Distribution.sol#290) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 298,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function computeTokens(uint256 _usd) public view returns(uint256) {\n",
          "message": "Parameter '_usd' of Distribution.computeTokens (Distribution.sol#298) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 316,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function computeBonus(uint16 _stage) public view returns(uint256) {\n",
          "message": "Parameter '_stage' of Distribution.computeBonus (Distribution.sol#316) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 324,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function computeAddressBonus(uint16 _stage) public view returns(uint256) {\n",
          "message": "Parameter '_stage' of Distribution.computeAddressBonus (Distribution.sol#324) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 335,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function claimTokens(address _token) public onlyOwner {\n",
          "message": "Parameter '_token' of Distribution.claimTokens (Distribution.sol#335) is not in mixedCase\n"
        }
      ]
    },
    "smartcheck": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "SOLIDITY_OVERPOWERED_ROLE",
          "vulnerability_from_line": 244,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function init(uint256 _cap, uint256 _startTime) public onlyOwner {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_OVERPOWERED_ROLE",
          "vulnerability_from_line": 280,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function setWeiUsdRate(uint256 _rate) public onlyOwner {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.18;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SAFEMATH",
          "vulnerability_from_line": 105,
          "vulnerability_to_line": null,
          "vulnerability_code": "  using SafeMath for uint256;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SAFEMATH",
          "vulnerability_from_line": 169,
          "vulnerability_to_line": null,
          "vulnerability_code": "  using SafeMath for uint256;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 107,
          "vulnerability_to_line": null,
          "vulnerability_code": "  mapping(address => uint256) balances;\n",
          "message": null
        }
      ]
    },
    "oyente": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "Integer Overflow",
          "vulnerability_from_line": 34,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint256 c = a + b;\n",
          "message": null
        },
        {
          "name": "Integer Overflow",
          "vulnerability_from_line": 34,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint256 c = a + b;\n",
          "message": null
        }
      ]
    },
    "mythril": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "Dependence on predictable environment variable (SWC 116)",
          "vulnerability_from_line": 308,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require(block.timestamp >= startTime);\n",
          "message": "A control flow decision is made based on The block.timestamp environment variable.\nThe block.timestamp environment variable is used to determine a control flow decision. Note that the values of variables like coinbase, gaslimit, block number and timestamp are predictable and can be manipulated by a malicious miner. Also keep in mind that attackers know hashes of earlier blocks. Don't use any of those environment variables as sources of randomness and be aware that use of these variables introduces a certain level of trust into miners.\nClassification: SWC-116"
        },
        {
          "name": "Dependence on predictable environment variable (SWC 116)",
          "vulnerability_from_line": 261,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require(getStage() > _stage);\n",
          "message": "A control flow decision is made based on The block.timestamp environment variable.\nThe block.timestamp environment variable is used to determine a control flow decision. Note that the values of variables like coinbase, gaslimit, block number and timestamp are predictable and can be manipulated by a malicious miner. Also keep in mind that attackers know hashes of earlier blocks. Don't use any of those environment variables as sources of randomness and be aware that use of these variables introduces a certain level of trust into miners.\nClassification: SWC-116"
        },
        {
          "name": "External Call To User-Supplied Address (SWC 107)",
          "vulnerability_from_line": 246,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require(token.balanceOf(this) == _cap);\n",
          "message": "A call to a user-supplied address is executed.\nAn external message call to an address specified by the caller is executed. Note that the callee account might contain arbitrary code and could re-enter any function within this contract. Reentering the contract in an intermediate state may lead to unexpected behaviour. Make sure that no state modifications are executed after this call and/or reentrancy guards are in place.\nClassification: SWC-107"
        },
        {
          "name": "Dependence on predictable environment variable (SWC 116)",
          "vulnerability_from_line": 247,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require(_startTime > block.timestamp);\n",
          "message": "A control flow decision is made based on The block.timestamp environment variable.\nThe block.timestamp environment variable is used to determine a control flow decision. Note that the values of variables like coinbase, gaslimit, block number and timestamp are predictable and can be manipulated by a malicious miner. Also keep in mind that attackers know hashes of earlier blocks. Don't use any of those environment variables as sources of randomness and be aware that use of these variables introduces a certain level of trust into miners.\nClassification: SWC-116"
        },
        {
          "name": "State access after external call (SWC 107)",
          "vulnerability_from_line": 249,
          "vulnerability_to_line": null,
          "vulnerability_code": "    startTime = _startTime;\n",
          "message": "Write to persistent state following external call\nThe contract account state is accessed after an external call to a user defined address. To prevent reentrancy issues, consider accessing the state only before the call, especially if the callee is untrusted. Alternatively, a reentrancy lock can be used to prevent untrusted callees from re-entering the contract in an intermediate state.\nClassification: SWC-107"
        },
        {
          "name": "State access after external call (SWC 107)",
          "vulnerability_from_line": 250,
          "vulnerability_to_line": null,
          "vulnerability_code": "    cap = _cap;\n",
          "message": "Write to persistent state following external call\nThe contract account state is accessed after an external call to a user defined address. To prevent reentrancy issues, consider accessing the state only before the call, especially if the callee is untrusted. Alternatively, a reentrancy lock can be used to prevent untrusted callees from re-entering the contract in an intermediate state.\nClassification: SWC-107"
        },
        {
          "name": "State access after external call (SWC 107)",
          "vulnerability_from_line": 251,
          "vulnerability_to_line": null,
          "vulnerability_code": "    stageCap = cap / stages;\n",
          "message": "Read of persistent state following external call\nThe contract account state is accessed after an external call to a user defined address. To prevent reentrancy issues, consider accessing the state only before the call, especially if the callee is untrusted. Alternatively, a reentrancy lock can be used to prevent untrusted callees from re-entering the contract in an intermediate state.\nClassification: SWC-107"
        },
        {
          "name": "State access after external call (SWC 107)",
          "vulnerability_from_line": 251,
          "vulnerability_to_line": null,
          "vulnerability_code": "    stageCap = cap / stages;\n",
          "message": "Read of persistent state following external call\nThe contract account state is accessed after an external call to a user defined address. To prevent reentrancy issues, consider accessing the state only before the call, especially if the callee is untrusted. Alternatively, a reentrancy lock can be used to prevent untrusted callees from re-entering the contract in an intermediate state.\nClassification: SWC-107"
        },
        {
          "name": "Exception State (SWC 110)",
          "vulnerability_from_line": 244,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function init(uint256 _cap, uint256 _startTime) public onlyOwner {\n",
          "message": "An assertion violation was triggered.\nIt is possible to trigger an assertion violation. Note that Solidity assert() statements should only be used to check invariants. Review the transaction trace generated for this issue and either make sure your program logic is correct, or use require() instead of assert() if your goal is to constrain user inputs or enforce preconditions. Remember to validate inputs from both callers (for instance, via passed arguments) and callees (for instance, via return values).\nClassification: SWC-110"
        },
        {
          "name": "State access after external call (SWC 107)",
          "vulnerability_from_line": 251,
          "vulnerability_to_line": null,
          "vulnerability_code": "    stageCap = cap / stages;\n",
          "message": "Write to persistent state following external call\nThe contract account state is accessed after an external call to a user defined address. To prevent reentrancy issues, consider accessing the state only before the call, especially if the callee is untrusted. Alternatively, a reentrancy lock can be used to prevent untrusted callees from re-entering the contract in an intermediate state.\nClassification: SWC-107"
        },
        {
          "name": "State access after external call (SWC 107)",
          "vulnerability_from_line": 252,
          "vulnerability_to_line": null,
          "vulnerability_code": "    isActive = true;\n",
          "message": "Read of persistent state following external call\nThe contract account state is accessed after an external call to a user defined address. To prevent reentrancy issues, consider accessing the state only before the call, especially if the callee is untrusted. Alternatively, a reentrancy lock can be used to prevent untrusted callees from re-entering the contract in an intermediate state.\nClassification: SWC-107"
        },
        {
          "name": "State access after external call (SWC 107)",
          "vulnerability_from_line": 252,
          "vulnerability_to_line": null,
          "vulnerability_code": "    isActive = true;\n",
          "message": "Write to persistent state following external call\nThe contract account state is accessed after an external call to a user defined address. To prevent reentrancy issues, consider accessing the state only before the call, especially if the callee is untrusted. Alternatively, a reentrancy lock can be used to prevent untrusted callees from re-entering the contract in an intermediate state.\nClassification: SWC-107"
        },
        {
          "name": "External Call To User-Supplied Address (SWC 107)",
          "vulnerability_from_line": 344,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint256 balance = erc20token.balanceOf(this);\n",
          "message": "A call to a user-supplied address is executed.\nAn external message call to an address specified by the caller is executed. Note that the callee account might contain arbitrary code and could re-enter any function within this contract. Reentering the contract in an intermediate state may lead to unexpected behaviour. Make sure that no state modifications are executed after this call and/or reentrancy guards are in place.\nClassification: SWC-107"
        },
        {
          "name": "State access after external call (SWC 107)",
          "vulnerability_from_line": 345,
          "vulnerability_to_line": null,
          "vulnerability_code": "    erc20token.transfer(owner, balance);\n",
          "message": "Read of persistent state following external call\nThe contract account state is accessed after an external call to a user defined address. To prevent reentrancy issues, consider accessing the state only before the call, especially if the callee is untrusted. Alternatively, a reentrancy lock can be used to prevent untrusted callees from re-entering the contract in an intermediate state.\nClassification: SWC-107"
        },
        {
          "name": "External Call To User-Supplied Address (SWC 107)",
          "vulnerability_from_line": 345,
          "vulnerability_to_line": null,
          "vulnerability_code": "    erc20token.transfer(owner, balance);\n",
          "message": "A call to a user-supplied address is executed.\nAn external message call to an address specified by the caller is executed. Note that the callee account might contain arbitrary code and could re-enter any function within this contract. Reentering the contract in an intermediate state may lead to unexpected behaviour. Make sure that no state modifications are executed after this call and/or reentrancy guards are in place.\nClassification: SWC-107"
        },
        {
          "name": "Multiple Calls in a Single Transaction (SWC 113)",
          "vulnerability_from_line": 345,
          "vulnerability_to_line": null,
          "vulnerability_code": "    erc20token.transfer(owner, balance);\n",
          "message": "Multiple calls are executed in the same transaction.\nThis call is executed following another call within the same transaction. It is possible that the call never gets executed if a prior call fails permanently. This might be caused intentionally by a malicious callee. If possible, refactor the code such that each transaction only executes one external call or make sure that all callees can be trusted (i.e. they\u2019re part of your own codebase).\nClassification: SWC-113"
        },
        {
          "name": "State access after external call (SWC 107)",
          "vulnerability_from_line": 345,
          "vulnerability_to_line": null,
          "vulnerability_code": "    erc20token.transfer(owner, balance);\n",
          "message": "Write to persistent state following external call\nThe contract account state is accessed after an external call to a user defined address. To prevent reentrancy issues, consider accessing the state only before the call, especially if the callee is untrusted. Alternatively, a reentrancy lock can be used to prevent untrusted callees from re-entering the contract in an intermediate state.\nClassification: SWC-107"
        },
        {
          "name": "State access after external call (SWC 107)",
          "vulnerability_from_line": 346,
          "vulnerability_to_line": null,
          "vulnerability_code": "    ClaimedTokens(_token, owner, balance);\n",
          "message": "Read of persistent state following external call\nThe contract account state is accessed after an external call to a user defined address. To prevent reentrancy issues, consider accessing the state only before the call, especially if the callee is untrusted. Alternatively, a reentrancy lock can be used to prevent untrusted callees from re-entering the contract in an intermediate state.\nClassification: SWC-107"
        },
        {
          "name": "Dependence on predictable environment variable (SWC 116)",
          "vulnerability_from_line": 29,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assert(b <= a);\n",
          "message": "A control flow decision is made based on The block.timestamp environment variable.\nThe block.timestamp environment variable is used to determine a control flow decision. Note that the values of variables like coinbase, gaslimit, block number and timestamp are predictable and can be manipulated by a malicious miner. Also keep in mind that attackers know hashes of earlier blocks. Don't use any of those environment variables as sources of randomness and be aware that use of these variables introduces a certain level of trust into miners.\nClassification: SWC-116"
        },
        {
          "name": "Exception State (SWC 110)",
          "vulnerability_from_line": 300,
          "vulnerability_to_line": null,
          "vulnerability_code": "      soldTokens.mul(19800000000000000000).div(cap).add(200000000000000000)\n",
          "message": "An assertion violation was triggered.\nIt is possible to trigger an assertion violation. Note that Solidity assert() statements should only be used to check invariants. Review the transaction trace generated for this issue and either make sure your program logic is correct, or use require() instead of assert() if your goal is to constrain user inputs or enforce preconditions. Remember to validate inputs from both callers (for instance, via passed arguments) and callees (for instance, via return values).\nClassification: SWC-110"
        },
        {
          "name": "Exception State (SWC 110)",
          "vulnerability_from_line": 309,
          "vulnerability_to_line": null,
          "vulnerability_code": "    return uint16(uint256(block.timestamp).sub(startTime).div(stageDuration));\n",
          "message": "An assertion violation was triggered.\nIt is possible to trigger an assertion violation. Note that Solidity assert() statements should only be used to check invariants. Review the transaction trace generated for this issue and either make sure your program logic is correct, or use require() instead of assert() if your goal is to constrain user inputs or enforce preconditions. Remember to validate inputs from both callers (for instance, via passed arguments) and callees (for instance, via return values).\nClassification: SWC-110"
        }
      ]
    },
    "osiris": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "Concurrency bug",
          "vulnerability_from_line": 291,
          "vulnerability_to_line": null,
          "vulnerability_code": "    _address.transfer(_amount);\n",
          "message": null
        },
        {
          "name": "Concurrency bug",
          "vulnerability_from_line": 339,
          "vulnerability_to_line": null,
          "vulnerability_code": "      owner.transfer(this.balance);\n",
          "message": null
        }
      ]
    }
  }
}