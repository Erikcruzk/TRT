{
  "smartbugs_completed": true,
  "analyzer_results": {
    "semgrep": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "use-ownable2step",
          "vulnerability_from_line": 104,
          "vulnerability_to_line": null,
          "vulnerability_code": "contract TokenVesting is Ownable {\n",
          "message": "By demanding that the receiver of the owner permissions actively accept via a contract call of its own,  `Ownable2Step` and `Ownable2StepUpgradeable` prevent the contract ownership from accidentally being transferred  to an address that cannot handle it."
        },
        {
          "name": "use-ownable2step",
          "vulnerability_from_line": 379,
          "vulnerability_to_line": null,
          "vulnerability_code": "contract TokenSale is Ownable {\n",
          "message": "By demanding that the receiver of the owner permissions actively accept via a contract call of its own,  `Ownable2Step` and `Ownable2StepUpgradeable` prevent the contract ownership from accidentally being transferred  to an address that cannot handle it."
        },
        {
          "name": "inefficient-state-variable-increment",
          "vulnerability_from_line": 303,
          "vulnerability_to_line": null,
          "vulnerability_code": "    circulatingSupply += claimable;\n",
          "message": "<x> += <y> costs more gas than <x> = <x> + <y> for state variables."
        },
        {
          "name": "init-variables-with-default-value",
          "vulnerability_from_line": 113,
          "vulnerability_to_line": null,
          "vulnerability_code": "  uint256 public circulatingSupply = 0;\n",
          "message": "Uninitialized variables are assigned with the types default value. Explicitly initializing a variable with its default value costs unnecessary gas."
        },
        {
          "name": "init-variables-with-default-value",
          "vulnerability_from_line": 399,
          "vulnerability_to_line": null,
          "vulnerability_code": "  bool public activated = false;\n",
          "message": "Uninitialized variables are assigned with the types default value. Explicitly initializing a variable with its default value costs unnecessary gas."
        },
        {
          "name": "init-variables-with-default-value",
          "vulnerability_from_line": 400,
          "vulnerability_to_line": null,
          "vulnerability_code": "  bool public isStopped = false;\n",
          "message": "Uninitialized variables are assigned with the types default value. Explicitly initializing a variable with its default value costs unnecessary gas."
        },
        {
          "name": "init-variables-with-default-value",
          "vulnerability_from_line": 401,
          "vulnerability_to_line": null,
          "vulnerability_code": "  bool public isFinalized = false;\n",
          "message": "Uninitialized variables are assigned with the types default value. Explicitly initializing a variable with its default value costs unnecessary gas."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 219,
          "vulnerability_to_line": null,
          "vulnerability_code": "        grants[_to][i].value,\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 220,
          "vulnerability_to_line": null,
          "vulnerability_code": "        grants[_to][i].vesting,\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 221,
          "vulnerability_to_line": null,
          "vulnerability_code": "        grants[_to][i].start,\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 222,
          "vulnerability_to_line": null,
          "vulnerability_code": "        grants[_to][i].claimed\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 243,
          "vulnerability_to_line": null,
          "vulnerability_code": "        grants[_to][i].value.sub(grants[_to][i].claimed)\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 243,
          "vulnerability_to_line": null,
          "vulnerability_code": "        grants[_to][i].value.sub(grants[_to][i].claimed)\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 293,
          "vulnerability_to_line": null,
          "vulnerability_code": "        grants[_to][i].value,\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 294,
          "vulnerability_to_line": null,
          "vulnerability_code": "        grants[_to][i].vesting,\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 295,
          "vulnerability_to_line": null,
          "vulnerability_code": "        grants[_to][i].start,\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 296,
          "vulnerability_to_line": null,
          "vulnerability_code": "        grants[_to][i].claimed\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 299,
          "vulnerability_to_line": null,
          "vulnerability_code": "      grants[_to][i].claimed = grants[_to][i].claimed.add(claimableFor);\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 299,
          "vulnerability_to_line": null,
          "vulnerability_code": "      grants[_to][i].claimed = grants[_to][i].claimed.add(claimableFor);\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 217,
          "vulnerability_to_line": null,
          "vulnerability_code": "    for (uint256 i = 0; i < numberOfGrants; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 241,
          "vulnerability_to_line": null,
          "vulnerability_code": "    for (uint256 i = 0; i < numberOfGrants; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 291,
          "vulnerability_to_line": null,
          "vulnerability_code": "    for (uint256 i = 0; i < numberOfGrants; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 217,
          "vulnerability_to_line": null,
          "vulnerability_code": "    for (uint256 i = 0; i < numberOfGrants; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 241,
          "vulnerability_to_line": null,
          "vulnerability_code": "    for (uint256 i = 0; i < numberOfGrants; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 291,
          "vulnerability_to_line": null,
          "vulnerability_code": "    for (uint256 i = 0; i < numberOfGrants; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        }
      ]
    },
    "slither": {
      "successfull_analysis": true,
      "errors": [
        "EXIT_CODE_79"
      ],
      "vulnerability_findings": [
        {
          "name": "unused-return",
          "vulnerability_from_line": 282,
          "vulnerability_to_line": 307,
          "vulnerability_code": "  function claim(address _to) internal {\n\n    uint256 numberOfGrants = grants[_to].length;\n\n\n\n    if (numberOfGrants == 0) {\n\n      return;\n\n    }\n\n\n\n    uint256 claimable = 0;\n\n    uint256 claimableFor = 0;\n\n    for (uint256 i = 0; i < numberOfGrants; i++) {\n\n      claimableFor = calculateVestedTokens(\n\n        grants[_to][i].value,\n\n        grants[_to][i].vesting,\n\n        grants[_to][i].start,\n\n        grants[_to][i].claimed\n\n      );\n\n      claimable = claimable.add(claimableFor);\n\n      grants[_to][i].claimed = grants[_to][i].claimed.add(claimableFor);\n\n    }\n\n\n\n    token.transfer(_to, claimable);\n\n    circulatingSupply += claimable;\n\n\n\n    NewTokenClaim(_to, claimable);\n\n  }\n",
          "message": "TokenVesting.claim (TokenSale.sol#282-307) does not use the value returned by external calls:\n\t-token.transfer(_to,claimable) (TokenSale.sol#302-303)\n"
        },
        {
          "name": "unused-return",
          "vulnerability_from_line": 472,
          "vulnerability_to_line": 507,
          "vulnerability_code": "  function initialize(\n\n      address _sdt,\n\n      address _vestingContract,\n\n      address _icoCostsPool,\n\n      address _distributionContract\n\n  ) public validAddress(_sdt) validAddress(_vestingContract) onlyOwner {\n\n    require(!activated);\n\n    activated = true;\n\n\n\n    token = BurnableToken(_sdt);\n\n    vesting = TokenVesting(_vestingContract);\n\n\n\n    // 1% reserve is released on deploy\n\n    token.transfer(_icoCostsPool, 7000000 ether);\n\n    token.transfer(_distributionContract, 161000000 ether);\n\n\n\n    //early backers allocation\n\n    uint256 threeMonths = vestingStarts.add(90 days);\n\n\n\n    updateStats(0, 43387693 ether);\n\n    grantVestedTokens(0x02f807E6a1a59F8714180B301Cba84E76d3B4d06, 22572063 ether, vestingStarts, threeMonths);\n\n    grantVestedTokens(0x3A1e89dD9baDe5985E7Eb36E9AFd200dD0E20613, 15280000 ether, vestingStarts, threeMonths);\n\n    grantVestedTokens(0xA61c9A0E96eC7Ceb67586fC8BFDCE009395D9b21, 250000 ether, vestingStarts, threeMonths);\n\n    grantVestedTokens(0x26C9899eA2F8940726BbCC79483F2ce07989314E, 100000 ether, vestingStarts, threeMonths);\n\n    grantVestedTokens(0xC88d5031e00BC316bE181F0e60971e8fEdB9223b, 1360000 ether, vestingStarts, threeMonths);\n\n    grantVestedTokens(0x38f4cAD7997907741FA0D912422Ae59aC6b83dD1, 250000 ether, vestingStarts, threeMonths);\n\n    grantVestedTokens(0x2b2992e51E86980966c42736C458e2232376a044, 105000 ether, vestingStarts, threeMonths);\n\n    grantVestedTokens(0xdD0F60610052bE0976Cf8BEE576Dbb3a1621a309, 140000 ether, vestingStarts, threeMonths);\n\n    grantVestedTokens(0xd61B4F33D3413827baa1425E2FDa485913C9625B, 740000 ether, vestingStarts, threeMonths);\n\n    grantVestedTokens(0xE6D4a77D01C680Ebbc0c84393ca598984b3F45e3, 505630 ether, vestingStarts, threeMonths);\n\n    grantVestedTokens(0x35D3648c29Ac180D5C7Ef386D52de9539c9c487a, 150000 ether, vestingStarts, threeMonths);\n\n    grantVestedTokens(0x344a6130d187f51ef0DAb785e10FaEA0FeE4b5dE, 967500 ether, vestingStarts, threeMonths);\n\n    grantVestedTokens(0x026cC76a245987f3420D0FE30070B568b4b46F68, 967500 ether, vestingStarts, threeMonths);\n\n  }\n\n\n",
          "message": "TokenSale.initialize (TokenSale.sol#472-507) does not use the value returned by external calls:\n\t-token.transfer(_icoCostsPool,7000000000000000419430400) (TokenSale.sol#485-486)\n\t-token.transfer(_distributionContract,160999999999999990319546368) (TokenSale.sol#486-487)\n"
        },
        {
          "name": "unused-return",
          "vulnerability_from_line": 568,
          "vulnerability_to_line": 581,
          "vulnerability_code": "  function claimTokens(address _token) public onlyOwner {\n\n    require(_token != address(token));\n\n    if (_token == 0x0) {\n\n      owner.transfer(this.balance);\n\n      return;\n\n    }\n\n\n\n    ERC20Basic erc20token = ERC20Basic(_token);\n\n    uint256 balance = erc20token.balanceOf(this);\n\n    erc20token.transfer(owner, balance);\n\n    ClaimedTokens(_token, owner, balance);\n\n  }\n\n\n",
          "message": "TokenSale.claimTokens (TokenSale.sol#568-581) does not use the value returned by external calls:\n\t-erc20token.transfer(owner,balance) (TokenSale.sol#577-578)\n"
        },
        {
          "name": "unused-return",
          "vulnerability_from_line": 632,
          "vulnerability_to_line": 641,
          "vulnerability_code": "  function grantVestedTokens(\n\n      address _to,\n\n      uint256 _value,\n\n      uint256 _start,\n\n      uint256 _vesting\n\n  ) internal {\n\n    token.transfer(vesting, _value);\n\n    vesting.grantVestedTokens(_to, _value, _start, _vesting);\n\n  }\n",
          "message": "TokenSale.grantVestedTokens (TokenSale.sol#632-641) does not use the value returned by external calls:\n\t-token.transfer(vesting,_value) (TokenSale.sol#638-639)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 282,
          "vulnerability_to_line": 307,
          "vulnerability_code": "  function claim(address _to) internal {\n\n    uint256 numberOfGrants = grants[_to].length;\n\n\n\n    if (numberOfGrants == 0) {\n\n      return;\n\n    }\n\n\n\n    uint256 claimable = 0;\n\n    uint256 claimableFor = 0;\n\n    for (uint256 i = 0; i < numberOfGrants; i++) {\n\n      claimableFor = calculateVestedTokens(\n\n        grants[_to][i].value,\n\n        grants[_to][i].vesting,\n\n        grants[_to][i].start,\n\n        grants[_to][i].claimed\n\n      );\n\n      claimable = claimable.add(claimableFor);\n\n      grants[_to][i].claimed = grants[_to][i].claimed.add(claimableFor);\n\n    }\n\n\n\n    token.transfer(_to, claimable);\n\n    circulatingSupply += claimable;\n\n\n\n    NewTokenClaim(_to, claimable);\n\n  }\n",
          "message": "Reentrancy in TokenVesting.claim (TokenSale.sol#282-307):\n\tExternal calls:\n\t- token.transfer(_to,claimable) (TokenSale.sol#302-303)\n\tState variables written after the call(s):\n\t- circulatingSupply (TokenSale.sol#303-304)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 472,
          "vulnerability_to_line": 507,
          "vulnerability_code": "  function initialize(\n\n      address _sdt,\n\n      address _vestingContract,\n\n      address _icoCostsPool,\n\n      address _distributionContract\n\n  ) public validAddress(_sdt) validAddress(_vestingContract) onlyOwner {\n\n    require(!activated);\n\n    activated = true;\n\n\n\n    token = BurnableToken(_sdt);\n\n    vesting = TokenVesting(_vestingContract);\n\n\n\n    // 1% reserve is released on deploy\n\n    token.transfer(_icoCostsPool, 7000000 ether);\n\n    token.transfer(_distributionContract, 161000000 ether);\n\n\n\n    //early backers allocation\n\n    uint256 threeMonths = vestingStarts.add(90 days);\n\n\n\n    updateStats(0, 43387693 ether);\n\n    grantVestedTokens(0x02f807E6a1a59F8714180B301Cba84E76d3B4d06, 22572063 ether, vestingStarts, threeMonths);\n\n    grantVestedTokens(0x3A1e89dD9baDe5985E7Eb36E9AFd200dD0E20613, 15280000 ether, vestingStarts, threeMonths);\n\n    grantVestedTokens(0xA61c9A0E96eC7Ceb67586fC8BFDCE009395D9b21, 250000 ether, vestingStarts, threeMonths);\n\n    grantVestedTokens(0x26C9899eA2F8940726BbCC79483F2ce07989314E, 100000 ether, vestingStarts, threeMonths);\n\n    grantVestedTokens(0xC88d5031e00BC316bE181F0e60971e8fEdB9223b, 1360000 ether, vestingStarts, threeMonths);\n\n    grantVestedTokens(0x38f4cAD7997907741FA0D912422Ae59aC6b83dD1, 250000 ether, vestingStarts, threeMonths);\n\n    grantVestedTokens(0x2b2992e51E86980966c42736C458e2232376a044, 105000 ether, vestingStarts, threeMonths);\n\n    grantVestedTokens(0xdD0F60610052bE0976Cf8BEE576Dbb3a1621a309, 140000 ether, vestingStarts, threeMonths);\n\n    grantVestedTokens(0xd61B4F33D3413827baa1425E2FDa485913C9625B, 740000 ether, vestingStarts, threeMonths);\n\n    grantVestedTokens(0xE6D4a77D01C680Ebbc0c84393ca598984b3F45e3, 505630 ether, vestingStarts, threeMonths);\n\n    grantVestedTokens(0x35D3648c29Ac180D5C7Ef386D52de9539c9c487a, 150000 ether, vestingStarts, threeMonths);\n\n    grantVestedTokens(0x344a6130d187f51ef0DAb785e10FaEA0FeE4b5dE, 967500 ether, vestingStarts, threeMonths);\n\n    grantVestedTokens(0x026cC76a245987f3420D0FE30070B568b4b46F68, 967500 ether, vestingStarts, threeMonths);\n\n  }\n\n\n",
          "message": "Reentrancy in TokenSale.initialize (TokenSale.sol#472-507):\n\tExternal calls:\n\t- token.transfer(_icoCostsPool,7000000000000000419430400) (TokenSale.sol#485-486)\n\t- token.transfer(_distributionContract,160999999999999990319546368) (TokenSale.sol#486-487)\n\tState variables written after the call(s):\n\t- raised (TokenSale.sol#491-492)\n\t- soldTokens (TokenSale.sol#491-492)\n"
        },
        {
          "name": "timestamp",
          "vulnerability_from_line": 256,
          "vulnerability_to_line": 279,
          "vulnerability_code": "  function calculateVestedTokens(\n\n      uint256 _tokens,\n\n      uint256 _vesting,\n\n      uint256 _start,\n\n      uint256 _claimed\n\n  ) internal constant returns (uint256) {\n\n    uint256 time = block.timestamp;\n\n\n\n    if (time < _start) {\n\n      return 0;\n\n    }\n\n\n\n    if (time >= _vesting) {\n\n      return _tokens.sub(_claimed);\n\n    }\n\n\n\n    uint256 vestedTokens = _tokens.mul(time.sub(_start)).div(\n\n      _vesting.sub(_start)\n\n    );\n\n\n\n    return vestedTokens.sub(_claimed);\n\n  }\n\n\n",
          "message": "TokenVesting.calculateVestedTokens (TokenSale.sol#256-279) uses timestamp for comparisons\n\tDangerous comparisons:\n\t- time < _start (TokenSale.sol#264-268)\n\t- time >= _vesting (TokenSale.sol#268-272)\n"
        },
        {
          "name": "timestamp",
          "vulnerability_from_line": 434,
          "vulnerability_to_line": 451,
          "vulnerability_code": "  function TokenSale(\n\n      uint256 _startTime,\n\n      uint256 _endTime,\n\n      address _wallet,\n\n      uint256 _vestingStarts\n\n  ) public validAddress(_wallet) {\n\n    require(_startTime > block.timestamp - 60);\n\n    require(_endTime > startTime);\n\n    require(_vestingStarts > startTime);\n\n\n\n    vestingStarts = _vestingStarts;\n\n    vestingEnds = vestingStarts.add(VESTING_TIME);\n\n    startTime = _startTime;\n\n    endTime = _endTime;\n\n    wallet = _wallet;\n\n  }\n\n\n",
          "message": "TokenSale.TokenSale (TokenSale.sol#434-451) uses timestamp for comparisons\n\tDangerous comparisons:\n\t- require(bool)(_startTime > block.timestamp - 60) (TokenSale.sol#440-441)\n"
        },
        {
          "name": "constable-states",
          "vulnerability_from_line": 401,
          "vulnerability_to_line": 402,
          "vulnerability_code": "  bool public isFinalized = false;\n",
          "message": "TokenSale.isFinalized should be constant (TokenSale.sol#401-402)\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 76,
          "vulnerability_to_line": 82,
          "vulnerability_code": "  function transferOwnership(address newOwner) public onlyOwner {\n\n    require(newOwner != address(0));\n\n    OwnershipTransferred(owner, newOwner);\n\n    owner = newOwner;\n\n  }\n\n\n",
          "message": "Ownable.transferOwnership (TokenSale.sol#76-82) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 341,
          "vulnerability_to_line": 345,
          "vulnerability_code": "  function balanceOf(address _owner) public view returns (uint256 balance) {\n\n    return balances[_owner];\n\n  }\n\n\n",
          "message": "BasicToken.balanceOf (TokenSale.sol#341-345) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 93,
          "vulnerability_to_line": 94,
          "vulnerability_code": "  function balanceOf(address who) public view returns (uint256);\n",
          "message": "ERC20Basic.balanceOf (TokenSale.sol#93-94) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 325,
          "vulnerability_to_line": 336,
          "vulnerability_code": "  function transfer(address _to, uint256 _value) public returns (bool) {\n\n    require(_to != address(0));\n\n    require(_value <= balances[msg.sender]);\n\n\n\n    // SafeMath.sub will throw if there is not enough balance.\n\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n\n    balances[_to] = balances[_to].add(_value);\n\n    Transfer(msg.sender, _to, _value);\n\n    return true;\n\n  }\n\n\n",
          "message": "BasicToken.transfer (TokenSale.sol#325-336) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 94,
          "vulnerability_to_line": 95,
          "vulnerability_code": "  function transfer(address to, uint256 value) public returns (bool);\n",
          "message": "ERC20Basic.transfer (TokenSale.sol#94-95) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 148,
          "vulnerability_to_line": 155,
          "vulnerability_code": "  function init(address _token, address _ico) public onlyOwner {\n\n    token = ERC20Basic(_token);\n\n    ico = _ico;\n\n    initialized = true;\n\n    active = true;\n\n  }\n\n\n",
          "message": "TokenVesting.init (TokenSale.sol#148-155) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 155,
          "vulnerability_to_line": 159,
          "vulnerability_code": "  function stop() public isActive onlyOwner {\n\n    active = false;\n\n  }\n\n\n",
          "message": "TokenVesting.stop (TokenSale.sol#155-159) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 159,
          "vulnerability_to_line": 165,
          "vulnerability_code": "  function resume() public onlyOwner {\n\n    require(!active);\n\n    require(initialized);\n\n    active = true;\n\n  }\n\n\n",
          "message": "TokenVesting.resume (TokenSale.sol#159-165) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 173,
          "vulnerability_to_line": 189,
          "vulnerability_code": "  function grantVestedTokens(\n\n      address _to,\n\n      uint256 _value,\n\n      uint256 _start,\n\n      uint256 _vesting\n\n  ) public icoResticted isActive {\n\n    require(_value > 0);\n\n    require(_vesting > _start);\n\n    require(grants[_to].length < 10);\n\n\n\n    TokenGrant memory grant = TokenGrant(_value, 0, _vesting, _start);\n\n    grants[_to].push(grant);\n\n\n\n    NewTokenGrant(_to, _value, _start, _vesting);\n\n  }\n\n\n",
          "message": "TokenVesting.grantVestedTokens (TokenSale.sol#173-189) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 192,
          "vulnerability_to_line": 196,
          "vulnerability_code": "  function claimTokens() public {\n\n    claim(msg.sender);\n\n  }\n\n\n",
          "message": "TokenVesting.claimTokens (TokenSale.sol#192-196) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 200,
          "vulnerability_to_line": 204,
          "vulnerability_code": "  function claimTokensFor(address _to) public onlyOwner {\n\n    claim(_to);\n\n  }\n\n\n",
          "message": "TokenVesting.claimTokensFor (TokenSale.sol#200-204) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 207,
          "vulnerability_to_line": 229,
          "vulnerability_code": "  function claimableTokens() public constant returns (uint256) {\n\n    address _to = msg.sender;\n\n    uint256 numberOfGrants = grants[_to].length;\n\n\n\n    if (numberOfGrants == 0) {\n\n      return 0;\n\n    }\n\n\n\n    uint256 claimable = 0;\n\n    uint256 claimableFor = 0;\n\n    for (uint256 i = 0; i < numberOfGrants; i++) {\n\n      claimableFor = calculateVestedTokens(\n\n        grants[_to][i].value,\n\n        grants[_to][i].vesting,\n\n        grants[_to][i].start,\n\n        grants[_to][i].claimed\n\n      );\n\n      claimable = claimable.add(claimableFor);\n\n    }\n\n    return claimable;\n\n  }\n\n\n",
          "message": "TokenVesting.claimableTokens (TokenSale.sol#207-229) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 232,
          "vulnerability_to_line": 249,
          "vulnerability_code": "  function totalVestedTokens() public constant returns (uint256) {\n\n    address _to = msg.sender;\n\n    uint256 numberOfGrants = grants[_to].length;\n\n\n\n    if (numberOfGrants == 0) {\n\n      return 0;\n\n    }\n\n\n\n    uint256 claimable = 0;\n\n    for (uint256 i = 0; i < numberOfGrants; i++) {\n\n      claimable = claimable.add(\n\n        grants[_to][i].value.sub(grants[_to][i].claimed)\n\n      );\n\n    }\n\n    return claimable;\n\n  }\n\n\n",
          "message": "TokenVesting.totalVestedTokens (TokenSale.sol#232-249) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 361,
          "vulnerability_to_line": 371,
          "vulnerability_code": "    function burn(uint256 _value) public {\n\n        require(_value <= balances[msg.sender]);\n\n        // no need to require value <= totalSupply, since that would imply the\n\n        // sender's balance is greater than the totalSupply, which *should* be an assertion failure\n\n\n\n        address burner = msg.sender;\n\n        balances[burner] = balances[burner].sub(_value);\n\n        totalSupply = totalSupply.sub(_value);\n\n        Burn(burner, _value);\n\n    }\n",
          "message": "BurnableToken.burn (TokenSale.sol#361-371) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 455,
          "vulnerability_to_line": 460,
          "vulnerability_code": "  function setWeiUsdRate(uint256 _rate) public onlyOwner {\n\n    require(_rate > 0);\n\n    weiUsdRate = _rate;\n\n  }\n\n\n",
          "message": "TokenSale.setWeiUsdRate (TokenSale.sol#455-460) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 464,
          "vulnerability_to_line": 469,
          "vulnerability_code": "  function setBtcUsdRate(uint256 _rate) public onlyOwner {\n\n    require(_rate > 0);\n\n    btcUsdRate = _rate;\n\n  }\n\n\n",
          "message": "TokenSale.setBtcUsdRate (TokenSale.sol#464-469) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 472,
          "vulnerability_to_line": 507,
          "vulnerability_code": "  function initialize(\n\n      address _sdt,\n\n      address _vestingContract,\n\n      address _icoCostsPool,\n\n      address _distributionContract\n\n  ) public validAddress(_sdt) validAddress(_vestingContract) onlyOwner {\n\n    require(!activated);\n\n    activated = true;\n\n\n\n    token = BurnableToken(_sdt);\n\n    vesting = TokenVesting(_vestingContract);\n\n\n\n    // 1% reserve is released on deploy\n\n    token.transfer(_icoCostsPool, 7000000 ether);\n\n    token.transfer(_distributionContract, 161000000 ether);\n\n\n\n    //early backers allocation\n\n    uint256 threeMonths = vestingStarts.add(90 days);\n\n\n\n    updateStats(0, 43387693 ether);\n\n    grantVestedTokens(0x02f807E6a1a59F8714180B301Cba84E76d3B4d06, 22572063 ether, vestingStarts, threeMonths);\n\n    grantVestedTokens(0x3A1e89dD9baDe5985E7Eb36E9AFd200dD0E20613, 15280000 ether, vestingStarts, threeMonths);\n\n    grantVestedTokens(0xA61c9A0E96eC7Ceb67586fC8BFDCE009395D9b21, 250000 ether, vestingStarts, threeMonths);\n\n    grantVestedTokens(0x26C9899eA2F8940726BbCC79483F2ce07989314E, 100000 ether, vestingStarts, threeMonths);\n\n    grantVestedTokens(0xC88d5031e00BC316bE181F0e60971e8fEdB9223b, 1360000 ether, vestingStarts, threeMonths);\n\n    grantVestedTokens(0x38f4cAD7997907741FA0D912422Ae59aC6b83dD1, 250000 ether, vestingStarts, threeMonths);\n\n    grantVestedTokens(0x2b2992e51E86980966c42736C458e2232376a044, 105000 ether, vestingStarts, threeMonths);\n\n    grantVestedTokens(0xdD0F60610052bE0976Cf8BEE576Dbb3a1621a309, 140000 ether, vestingStarts, threeMonths);\n\n    grantVestedTokens(0xd61B4F33D3413827baa1425E2FDa485913C9625B, 740000 ether, vestingStarts, threeMonths);\n\n    grantVestedTokens(0xE6D4a77D01C680Ebbc0c84393ca598984b3F45e3, 505630 ether, vestingStarts, threeMonths);\n\n    grantVestedTokens(0x35D3648c29Ac180D5C7Ef386D52de9539c9c487a, 150000 ether, vestingStarts, threeMonths);\n\n    grantVestedTokens(0x344a6130d187f51ef0DAb785e10FaEA0FeE4b5dE, 967500 ether, vestingStarts, threeMonths);\n\n    grantVestedTokens(0x026cC76a245987f3420D0FE30070B568b4b46F68, 967500 ether, vestingStarts, threeMonths);\n\n  }\n\n\n",
          "message": "TokenSale.initialize (TokenSale.sol#472-507) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 507,
          "vulnerability_to_line": 528,
          "vulnerability_code": "  function finalize(\n\n      address _poolA,\n\n      address _poolB,\n\n      address _poolC,\n\n      address _poolD\n\n  )\n\n      public\n\n      validAddress(_poolA)\n\n      validAddress(_poolB)\n\n      validAddress(_poolC)\n\n      validAddress(_poolD)\n\n      onlyOwner\n\n  {\n\n    grantVestedTokens(_poolA, 175000000 ether, vestingStarts, vestingStarts.add(7 years));\n\n    grantVestedTokens(_poolB, 168000000 ether, vestingStarts, vestingStarts.add(7 years));\n\n    grantVestedTokens(_poolC, 70000000 ether, vestingStarts, vestingStarts.add(7 years));\n\n    grantVestedTokens(_poolD, 48999990 ether, vestingStarts, vestingStarts.add(4 years));\n\n\n\n    token.burn(token.balanceOf(this));\n\n  }\n\n\n",
          "message": "TokenSale.finalize (TokenSale.sol#507-528) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 528,
          "vulnerability_to_line": 533,
          "vulnerability_code": "  function stop() public onlyOwner isActive returns(bool) {\n\n    isStopped = true;\n\n    return true;\n\n  }\n\n\n",
          "message": "TokenSale.stop (TokenSale.sol#528-533) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 533,
          "vulnerability_to_line": 539,
          "vulnerability_code": "  function resume() public onlyOwner returns(bool) {\n\n    require(isStopped);\n\n    isStopped = false;\n\n    return true;\n\n  }\n\n\n",
          "message": "TokenSale.resume (TokenSale.sol#533-539) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 539,
          "vulnerability_to_line": 545,
          "vulnerability_code": "  function () public payable {\n\n    uint256 usd = msg.value.div(weiUsdRate);\n\n    doPurchase(usd, msg.value, 0, msg.sender, vestingEnds);\n\n    forwardFunds();\n\n  }\n\n\n",
          "message": "TokenSale.fallback (TokenSale.sol#539-545) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 545,
          "vulnerability_to_line": 553,
          "vulnerability_code": "  function btcPurchase(\n\n      address _beneficiary,\n\n      uint256 _btcValue\n\n  ) public onlyOwner validAddress(_beneficiary) {\n\n    uint256 usd = _btcValue.div(btcUsdRate);\n\n    doPurchase(usd, 0, _btcValue, _beneficiary, vestingEnds);\n\n  }\n\n\n",
          "message": "TokenSale.btcPurchase (TokenSale.sol#545-553) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 568,
          "vulnerability_to_line": 581,
          "vulnerability_code": "  function claimTokens(address _token) public onlyOwner {\n\n    require(_token != address(token));\n\n    if (_token == 0x0) {\n\n      owner.transfer(this.balance);\n\n      return;\n\n    }\n\n\n\n    ERC20Basic erc20token = ERC20Basic(_token);\n\n    uint256 balance = erc20token.balanceOf(this);\n\n    erc20token.transfer(owner, balance);\n\n    ClaimedTokens(_token, owner, balance);\n\n  }\n\n\n",
          "message": "TokenSale.claimTokens (TokenSale.sol#568-581) should be declared external\n"
        },
        {
          "name": "solc-version",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": 5,
          "vulnerability_code": "pragma solidity ^0.4.18;\n\n\n",
          "message": "Detected issues with version pragma in TokenSale.sol:\n\t- pragma solidity^0.4.18 (TokenSale.sol#3-5): it allows old versions\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 58,
          "vulnerability_to_line": 62,
          "vulnerability_code": "  function Ownable() public {\n\n    owner = msg.sender;\n\n  }\n\n\n",
          "message": "Function 'Ownable.Ownable' (TokenSale.sol#58-62) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 144,
          "vulnerability_to_line": 148,
          "vulnerability_code": "  function TokenVesting() public {\n\n    active = false;\n\n  }\n\n\n",
          "message": "Function 'TokenVesting.TokenVesting' (TokenSale.sol#144-148) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 148,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function init(address _token, address _ico) public onlyOwner {\n",
          "message": "Parameter '_token' of TokenVesting.init (TokenSale.sol#148) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 148,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function init(address _token, address _ico) public onlyOwner {\n",
          "message": "Parameter '_ico' of TokenVesting.init (TokenSale.sol#148) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 174,
          "vulnerability_to_line": 175,
          "vulnerability_code": "      address _to,\n",
          "message": "Parameter '_to' of TokenVesting.grantVestedTokens (TokenSale.sol#174-175) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 175,
          "vulnerability_to_line": 176,
          "vulnerability_code": "      uint256 _value,\n",
          "message": "Parameter '_value' of TokenVesting.grantVestedTokens (TokenSale.sol#175-176) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 176,
          "vulnerability_to_line": 177,
          "vulnerability_code": "      uint256 _start,\n",
          "message": "Parameter '_start' of TokenVesting.grantVestedTokens (TokenSale.sol#176-177) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 177,
          "vulnerability_to_line": 178,
          "vulnerability_code": "      uint256 _vesting\n",
          "message": "Parameter '_vesting' of TokenVesting.grantVestedTokens (TokenSale.sol#177-178) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 200,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function claimTokensFor(address _to) public onlyOwner {\n",
          "message": "Parameter '_to' of TokenVesting.claimTokensFor (TokenSale.sol#200) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 257,
          "vulnerability_to_line": 258,
          "vulnerability_code": "      uint256 _tokens,\n",
          "message": "Parameter '_tokens' of TokenVesting.calculateVestedTokens (TokenSale.sol#257-258) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 258,
          "vulnerability_to_line": 259,
          "vulnerability_code": "      uint256 _vesting,\n",
          "message": "Parameter '_vesting' of TokenVesting.calculateVestedTokens (TokenSale.sol#258-259) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 259,
          "vulnerability_to_line": 260,
          "vulnerability_code": "      uint256 _start,\n",
          "message": "Parameter '_start' of TokenVesting.calculateVestedTokens (TokenSale.sol#259-260) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 260,
          "vulnerability_to_line": 261,
          "vulnerability_code": "      uint256 _claimed\n",
          "message": "Parameter '_claimed' of TokenVesting.calculateVestedTokens (TokenSale.sol#260-261) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 282,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function claim(address _to) internal {\n",
          "message": "Parameter '_to' of TokenVesting.claim (TokenSale.sol#282) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 341,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function balanceOf(address _owner) public view returns (uint256 balance) {\n",
          "message": "Parameter '_owner' of BasicToken.balanceOf (TokenSale.sol#341) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 325,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function transfer(address _to, uint256 _value) public returns (bool) {\n",
          "message": "Parameter '_to' of BasicToken.transfer (TokenSale.sol#325) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 325,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function transfer(address _to, uint256 _value) public returns (bool) {\n",
          "message": "Parameter '_value' of BasicToken.transfer (TokenSale.sol#325) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 361,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function burn(uint256 _value) public {\n",
          "message": "Parameter '_value' of BurnableToken.burn (TokenSale.sol#361) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 434,
          "vulnerability_to_line": 451,
          "vulnerability_code": "  function TokenSale(\n\n      uint256 _startTime,\n\n      uint256 _endTime,\n\n      address _wallet,\n\n      uint256 _vestingStarts\n\n  ) public validAddress(_wallet) {\n\n    require(_startTime > block.timestamp - 60);\n\n    require(_endTime > startTime);\n\n    require(_vestingStarts > startTime);\n\n\n\n    vestingStarts = _vestingStarts;\n\n    vestingEnds = vestingStarts.add(VESTING_TIME);\n\n    startTime = _startTime;\n\n    endTime = _endTime;\n\n    wallet = _wallet;\n\n  }\n\n\n",
          "message": "Function 'TokenSale.TokenSale' (TokenSale.sol#434-451) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 435,
          "vulnerability_to_line": 436,
          "vulnerability_code": "      uint256 _startTime,\n",
          "message": "Parameter '_startTime' of TokenSale.TokenSale (TokenSale.sol#435-436) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 436,
          "vulnerability_to_line": 437,
          "vulnerability_code": "      uint256 _endTime,\n",
          "message": "Parameter '_endTime' of TokenSale.TokenSale (TokenSale.sol#436-437) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 437,
          "vulnerability_to_line": 438,
          "vulnerability_code": "      address _wallet,\n",
          "message": "Parameter '_wallet' of TokenSale.TokenSale (TokenSale.sol#437-438) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 438,
          "vulnerability_to_line": 439,
          "vulnerability_code": "      uint256 _vestingStarts\n",
          "message": "Parameter '_vestingStarts' of TokenSale.TokenSale (TokenSale.sol#438-439) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 455,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function setWeiUsdRate(uint256 _rate) public onlyOwner {\n",
          "message": "Parameter '_rate' of TokenSale.setWeiUsdRate (TokenSale.sol#455) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 464,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function setBtcUsdRate(uint256 _rate) public onlyOwner {\n",
          "message": "Parameter '_rate' of TokenSale.setBtcUsdRate (TokenSale.sol#464) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 473,
          "vulnerability_to_line": 474,
          "vulnerability_code": "      address _sdt,\n",
          "message": "Parameter '_sdt' of TokenSale.initialize (TokenSale.sol#473-474) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 474,
          "vulnerability_to_line": 475,
          "vulnerability_code": "      address _vestingContract,\n",
          "message": "Parameter '_vestingContract' of TokenSale.initialize (TokenSale.sol#474-475) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 475,
          "vulnerability_to_line": 476,
          "vulnerability_code": "      address _icoCostsPool,\n",
          "message": "Parameter '_icoCostsPool' of TokenSale.initialize (TokenSale.sol#475-476) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 476,
          "vulnerability_to_line": 477,
          "vulnerability_code": "      address _distributionContract\n",
          "message": "Parameter '_distributionContract' of TokenSale.initialize (TokenSale.sol#476-477) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 508,
          "vulnerability_to_line": 509,
          "vulnerability_code": "      address _poolA,\n",
          "message": "Parameter '_poolA' of TokenSale.finalize (TokenSale.sol#508-509) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 509,
          "vulnerability_to_line": 510,
          "vulnerability_code": "      address _poolB,\n",
          "message": "Parameter '_poolB' of TokenSale.finalize (TokenSale.sol#509-510) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 510,
          "vulnerability_to_line": 511,
          "vulnerability_code": "      address _poolC,\n",
          "message": "Parameter '_poolC' of TokenSale.finalize (TokenSale.sol#510-511) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 511,
          "vulnerability_to_line": 512,
          "vulnerability_code": "      address _poolD\n",
          "message": "Parameter '_poolD' of TokenSale.finalize (TokenSale.sol#511-512) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 546,
          "vulnerability_to_line": 547,
          "vulnerability_code": "      address _beneficiary,\n",
          "message": "Parameter '_beneficiary' of TokenSale.btcPurchase (TokenSale.sol#546-547) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 547,
          "vulnerability_to_line": 548,
          "vulnerability_code": "      uint256 _btcValue\n",
          "message": "Parameter '_btcValue' of TokenSale.btcPurchase (TokenSale.sol#547-548) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 557,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function computeTokens(uint256 _usd) public pure returns(uint256) {\n",
          "message": "Parameter '_usd' of TokenSale.computeTokens (TokenSale.sol#557) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 568,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function claimTokens(address _token) public onlyOwner {\n",
          "message": "Parameter '_token' of TokenSale.claimTokens (TokenSale.sol#568) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 594,
          "vulnerability_to_line": 595,
          "vulnerability_code": "      uint256 _usd,\n",
          "message": "Parameter '_usd' of TokenSale.doPurchase (TokenSale.sol#594-595) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 595,
          "vulnerability_to_line": 596,
          "vulnerability_code": "      uint256 _eth,\n",
          "message": "Parameter '_eth' of TokenSale.doPurchase (TokenSale.sol#595-596) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 596,
          "vulnerability_to_line": 597,
          "vulnerability_code": "      uint256 _btc,\n",
          "message": "Parameter '_btc' of TokenSale.doPurchase (TokenSale.sol#596-597) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 597,
          "vulnerability_to_line": 598,
          "vulnerability_code": "      address _address,\n",
          "message": "Parameter '_address' of TokenSale.doPurchase (TokenSale.sol#597-598) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 598,
          "vulnerability_to_line": 599,
          "vulnerability_code": "      uint256 _vestingEnds\n",
          "message": "Parameter '_vestingEnds' of TokenSale.doPurchase (TokenSale.sol#598-599) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 633,
          "vulnerability_to_line": 634,
          "vulnerability_code": "      address _to,\n",
          "message": "Parameter '_to' of TokenSale.grantVestedTokens (TokenSale.sol#633-634) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 634,
          "vulnerability_to_line": 635,
          "vulnerability_code": "      uint256 _value,\n",
          "message": "Parameter '_value' of TokenSale.grantVestedTokens (TokenSale.sol#634-635) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 635,
          "vulnerability_to_line": 636,
          "vulnerability_code": "      uint256 _start,\n",
          "message": "Parameter '_start' of TokenSale.grantVestedTokens (TokenSale.sol#635-636) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 636,
          "vulnerability_to_line": 637,
          "vulnerability_code": "      uint256 _vesting\n",
          "message": "Parameter '_vesting' of TokenSale.grantVestedTokens (TokenSale.sol#636-637) is not in mixedCase\n"
        }
      ]
    },
    "smartcheck": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 492,
          "vulnerability_to_line": null,
          "vulnerability_code": "    grantVestedTokens(0x02f807E6a1a59F8714180B301Cba84E76d3B4d06, 22572063 ether, vestingStarts, threeMonths);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 493,
          "vulnerability_to_line": null,
          "vulnerability_code": "    grantVestedTokens(0x3A1e89dD9baDe5985E7Eb36E9AFd200dD0E20613, 15280000 ether, vestingStarts, threeMonths);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 494,
          "vulnerability_to_line": null,
          "vulnerability_code": "    grantVestedTokens(0xA61c9A0E96eC7Ceb67586fC8BFDCE009395D9b21, 250000 ether, vestingStarts, threeMonths);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 495,
          "vulnerability_to_line": null,
          "vulnerability_code": "    grantVestedTokens(0x26C9899eA2F8940726BbCC79483F2ce07989314E, 100000 ether, vestingStarts, threeMonths);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 496,
          "vulnerability_to_line": null,
          "vulnerability_code": "    grantVestedTokens(0xC88d5031e00BC316bE181F0e60971e8fEdB9223b, 1360000 ether, vestingStarts, threeMonths);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 497,
          "vulnerability_to_line": null,
          "vulnerability_code": "    grantVestedTokens(0x38f4cAD7997907741FA0D912422Ae59aC6b83dD1, 250000 ether, vestingStarts, threeMonths);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 498,
          "vulnerability_to_line": null,
          "vulnerability_code": "    grantVestedTokens(0x2b2992e51E86980966c42736C458e2232376a044, 105000 ether, vestingStarts, threeMonths);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 499,
          "vulnerability_to_line": null,
          "vulnerability_code": "    grantVestedTokens(0xdD0F60610052bE0976Cf8BEE576Dbb3a1621a309, 140000 ether, vestingStarts, threeMonths);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 500,
          "vulnerability_to_line": null,
          "vulnerability_code": "    grantVestedTokens(0xd61B4F33D3413827baa1425E2FDa485913C9625B, 740000 ether, vestingStarts, threeMonths);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 501,
          "vulnerability_to_line": null,
          "vulnerability_code": "    grantVestedTokens(0xE6D4a77D01C680Ebbc0c84393ca598984b3F45e3, 505630 ether, vestingStarts, threeMonths);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 502,
          "vulnerability_to_line": null,
          "vulnerability_code": "    grantVestedTokens(0x35D3648c29Ac180D5C7Ef386D52de9539c9c487a, 150000 ether, vestingStarts, threeMonths);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 503,
          "vulnerability_to_line": null,
          "vulnerability_code": "    grantVestedTokens(0x344a6130d187f51ef0DAb785e10FaEA0FeE4b5dE, 967500 ether, vestingStarts, threeMonths);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 504,
          "vulnerability_to_line": null,
          "vulnerability_code": "    grantVestedTokens(0x026cC76a245987f3420D0FE30070B568b4b46F68, 967500 ether, vestingStarts, threeMonths);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 421,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require(_address != address(0x0));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
          "vulnerability_from_line": 207,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function claimableTokens() public constant returns (uint256) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
          "vulnerability_from_line": 232,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function totalVestedTokens() public constant returns (uint256) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
          "vulnerability_from_line": 256,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function calculateVestedTokens(\n",
          "message": null
        },
        {
          "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
          "vulnerability_from_line": 520,
          "vulnerability_to_line": null,
          "vulnerability_code": "    grantVestedTokens(_poolA, 175000000 ether, vestingStarts, vestingStarts.add(7 years));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
          "vulnerability_from_line": 521,
          "vulnerability_to_line": null,
          "vulnerability_code": "    grantVestedTokens(_poolB, 168000000 ether, vestingStarts, vestingStarts.add(7 years));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
          "vulnerability_from_line": 522,
          "vulnerability_to_line": null,
          "vulnerability_code": "    grantVestedTokens(_poolC, 70000000 ether, vestingStarts, vestingStarts.add(7 years));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
          "vulnerability_from_line": 523,
          "vulnerability_to_line": null,
          "vulnerability_code": "    grantVestedTokens(_poolD, 48999990 ether, vestingStarts, vestingStarts.add(4 years));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 217,
          "vulnerability_to_line": null,
          "vulnerability_code": "    for (uint256 i = 0; i < numberOfGrants; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 241,
          "vulnerability_to_line": null,
          "vulnerability_code": "    for (uint256 i = 0; i < numberOfGrants; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 291,
          "vulnerability_to_line": null,
          "vulnerability_code": "    for (uint256 i = 0; i < numberOfGrants; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_OVERPOWERED_ROLE",
          "vulnerability_from_line": 148,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function init(address _token, address _ico) public onlyOwner {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_OVERPOWERED_ROLE",
          "vulnerability_from_line": 455,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function setWeiUsdRate(uint256 _rate) public onlyOwner {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_OVERPOWERED_ROLE",
          "vulnerability_from_line": 464,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function setBtcUsdRate(uint256 _rate) public onlyOwner {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_OVERPOWERED_ROLE",
          "vulnerability_from_line": 472,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function initialize(\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.18;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SAFEMATH",
          "vulnerability_from_line": 105,
          "vulnerability_to_line": null,
          "vulnerability_code": "  using SafeMath for uint256;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SAFEMATH",
          "vulnerability_from_line": 316,
          "vulnerability_to_line": null,
          "vulnerability_code": "  using SafeMath for uint256;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SAFEMATH",
          "vulnerability_from_line": 380,
          "vulnerability_to_line": null,
          "vulnerability_code": "  using SafeMath for uint256;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 539,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function () public payable {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 318,
          "vulnerability_to_line": null,
          "vulnerability_code": "  mapping(address => uint256) balances;\n",
          "message": null
        }
      ]
    },
    "oyente": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "Integer Overflow",
          "vulnerability_from_line": 34,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint256 c = a + b;\n",
          "message": null
        },
        {
          "name": "Integer Overflow",
          "vulnerability_from_line": 34,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint256 c = a + b;\n",
          "message": null
        },
        {
          "name": "Integer Overflow",
          "vulnerability_from_line": 111,
          "vulnerability_to_line": null,
          "vulnerability_code": "  mapping (address => TokenGrant[]) public grants;\n",
          "message": null
        }
      ]
    },
    "mythril": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "Integer Arithmetic Bugs (SWC 101)",
          "vulnerability_from_line": 440,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require(_startTime > block.timestamp - 60);\n",
          "message": "The arithmetic operator can underflow.\nIt is possible to cause an integer overflow or underflow in the arithmetic operation. \nClassification: SWC-101"
        },
        {
          "name": "Dependence on predictable environment variable (SWC 116)",
          "vulnerability_from_line": 440,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require(_startTime > block.timestamp - 60);\n",
          "message": "A control flow decision is made based on The block.timestamp environment variable.\nThe block.timestamp environment variable is used to determine a control flow decision. Note that the values of variables like coinbase, gaslimit, block number and timestamp are predictable and can be manipulated by a malicious miner. Also keep in mind that attackers know hashes of earlier blocks. Don't use any of those environment variables as sources of randomness and be aware that use of these variables introduces a certain level of trust into miners.\nClassification: SWC-116"
        },
        {
          "name": "Exception State (SWC 110)",
          "vulnerability_from_line": 445,
          "vulnerability_to_line": null,
          "vulnerability_code": "    vestingEnds = vestingStarts.add(VESTING_TIME);\n",
          "message": "An assertion violation was triggered.\nIt is possible to trigger an assertion violation. Note that Solidity assert() statements should only be used to check invariants. Review the transaction trace generated for this issue and either make sure your program logic is correct, or use require() instead of assert() if your goal is to constrain user inputs or enforce preconditions. Remember to validate inputs from both callers (for instance, via passed arguments) and callees (for instance, via return values).\nClassification: SWC-110"
        },
        {
          "name": "Exception State (SWC 110)",
          "vulnerability_from_line": 111,
          "vulnerability_to_line": null,
          "vulnerability_code": "  mapping (address => TokenGrant[]) public grants;\n",
          "message": "An assertion violation was triggered.\nIt is possible to trigger an assertion violation. Note that Solidity assert() statements should only be used to check invariants. Review the transaction trace generated for this issue and either make sure your program logic is correct, or use require() instead of assert() if your goal is to constrain user inputs or enforce preconditions. Remember to validate inputs from both callers (for instance, via passed arguments) and callees (for instance, via return values).\nClassification: SWC-110"
        },
        {
          "name": "Dependence on predictable environment variable (SWC 116)",
          "vulnerability_from_line": 429,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require(block.timestamp >= startTime);\n",
          "message": "A control flow decision is made based on The block.timestamp environment variable.\nThe block.timestamp environment variable is used to determine a control flow decision. Note that the values of variables like coinbase, gaslimit, block number and timestamp are predictable and can be manipulated by a malicious miner. Also keep in mind that attackers know hashes of earlier blocks. Don't use any of those environment variables as sources of randomness and be aware that use of these variables introduces a certain level of trust into miners.\nClassification: SWC-116"
        },
        {
          "name": "Dependence on predictable environment variable (SWC 116)",
          "vulnerability_from_line": 430,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require(block.timestamp <= endTime);\n",
          "message": "A control flow decision is made based on The block.timestamp environment variable.\nThe block.timestamp environment variable is used to determine a control flow decision. Note that the values of variables like coinbase, gaslimit, block number and timestamp are predictable and can be manipulated by a malicious miner. Also keep in mind that attackers know hashes of earlier blocks. Don't use any of those environment variables as sources of randomness and be aware that use of these variables introduces a certain level of trust into miners.\nClassification: SWC-116"
        },
        {
          "name": "Dependence on predictable environment variable (SWC 116)",
          "vulnerability_from_line": 429,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require(block.timestamp >= startTime);\n",
          "message": "A control flow decision is made based on The block.timestamp environment variable.\nThe block.timestamp environment variable is used to determine a control flow decision. Note that the values of variables like coinbase, gaslimit, block number and timestamp are predictable and can be manipulated by a malicious miner. Also keep in mind that attackers know hashes of earlier blocks. Don't use any of those environment variables as sources of randomness and be aware that use of these variables introduces a certain level of trust into miners.\nClassification: SWC-116"
        },
        {
          "name": "Dependence on predictable environment variable (SWC 116)",
          "vulnerability_from_line": 430,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require(block.timestamp <= endTime);\n",
          "message": "A control flow decision is made based on The block.timestamp environment variable.\nThe block.timestamp environment variable is used to determine a control flow decision. Note that the values of variables like coinbase, gaslimit, block number and timestamp are predictable and can be manipulated by a malicious miner. Also keep in mind that attackers know hashes of earlier blocks. Don't use any of those environment variables as sources of randomness and be aware that use of these variables introduces a certain level of trust into miners.\nClassification: SWC-116"
        },
        {
          "name": "External Call To User-Supplied Address (SWC 107)",
          "vulnerability_from_line": 576,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint256 balance = erc20token.balanceOf(this);\n",
          "message": "A call to a user-supplied address is executed.\nAn external message call to an address specified by the caller is executed. Note that the callee account might contain arbitrary code and could re-enter any function within this contract. Reentering the contract in an intermediate state may lead to unexpected behaviour. Make sure that no state modifications are executed after this call and/or reentrancy guards are in place.\nClassification: SWC-107"
        },
        {
          "name": "State access after external call (SWC 107)",
          "vulnerability_from_line": 577,
          "vulnerability_to_line": null,
          "vulnerability_code": "    erc20token.transfer(owner, balance);\n",
          "message": "Read of persistent state following external call\nThe contract account state is accessed after an external call to a user defined address. To prevent reentrancy issues, consider accessing the state only before the call, especially if the callee is untrusted. Alternatively, a reentrancy lock can be used to prevent untrusted callees from re-entering the contract in an intermediate state.\nClassification: SWC-107"
        },
        {
          "name": "External Call To User-Supplied Address (SWC 107)",
          "vulnerability_from_line": 577,
          "vulnerability_to_line": null,
          "vulnerability_code": "    erc20token.transfer(owner, balance);\n",
          "message": "A call to a user-supplied address is executed.\nAn external message call to an address specified by the caller is executed. Note that the callee account might contain arbitrary code and could re-enter any function within this contract. Reentering the contract in an intermediate state may lead to unexpected behaviour. Make sure that no state modifications are executed after this call and/or reentrancy guards are in place.\nClassification: SWC-107"
        },
        {
          "name": "Multiple Calls in a Single Transaction (SWC 113)",
          "vulnerability_from_line": 577,
          "vulnerability_to_line": null,
          "vulnerability_code": "    erc20token.transfer(owner, balance);\n",
          "message": "Multiple calls are executed in the same transaction.\nThis call is executed following another call within the same transaction. It is possible that the call never gets executed if a prior call fails permanently. This might be caused intentionally by a malicious callee. If possible, refactor the code such that each transaction only executes one external call or make sure that all callees can be trusted (i.e. they\u2019re part of your own codebase).\nClassification: SWC-113"
        },
        {
          "name": "State access after external call (SWC 107)",
          "vulnerability_from_line": 577,
          "vulnerability_to_line": null,
          "vulnerability_code": "    erc20token.transfer(owner, balance);\n",
          "message": "Write to persistent state following external call\nThe contract account state is accessed after an external call to a user defined address. To prevent reentrancy issues, consider accessing the state only before the call, especially if the callee is untrusted. Alternatively, a reentrancy lock can be used to prevent untrusted callees from re-entering the contract in an intermediate state.\nClassification: SWC-107"
        },
        {
          "name": "State access after external call (SWC 107)",
          "vulnerability_from_line": 578,
          "vulnerability_to_line": null,
          "vulnerability_code": "    ClaimedTokens(_token, owner, balance);\n",
          "message": "Read of persistent state following external call\nThe contract account state is accessed after an external call to a user defined address. To prevent reentrancy issues, consider accessing the state only before the call, especially if the callee is untrusted. Alternatively, a reentrancy lock can be used to prevent untrusted callees from re-entering the contract in an intermediate state.\nClassification: SWC-107"
        },
        {
          "name": "External Call To User-Supplied Address (SWC 107)",
          "vulnerability_from_line": 485,
          "vulnerability_to_line": null,
          "vulnerability_code": "    token.transfer(_icoCostsPool, 7000000 ether);\n",
          "message": "A call to a user-supplied address is executed.\nAn external message call to an address specified by the caller is executed. Note that the callee account might contain arbitrary code and could re-enter any function within this contract. Reentering the contract in an intermediate state may lead to unexpected behaviour. Make sure that no state modifications are executed after this call and/or reentrancy guards are in place.\nClassification: SWC-107"
        },
        {
          "name": "State access after external call (SWC 107)",
          "vulnerability_from_line": 486,
          "vulnerability_to_line": null,
          "vulnerability_code": "    token.transfer(_distributionContract, 161000000 ether);\n",
          "message": "Read of persistent state following external call\nThe contract account state is accessed after an external call to a user defined address. To prevent reentrancy issues, consider accessing the state only before the call, especially if the callee is untrusted. Alternatively, a reentrancy lock can be used to prevent untrusted callees from re-entering the contract in an intermediate state.\nClassification: SWC-107"
        },
        {
          "name": "External Call To User-Supplied Address (SWC 107)",
          "vulnerability_from_line": 486,
          "vulnerability_to_line": null,
          "vulnerability_code": "    token.transfer(_distributionContract, 161000000 ether);\n",
          "message": "A call to a user-supplied address is executed.\nAn external message call to an address specified by the caller is executed. Note that the callee account might contain arbitrary code and could re-enter any function within this contract. Reentering the contract in an intermediate state may lead to unexpected behaviour. Make sure that no state modifications are executed after this call and/or reentrancy guards are in place.\nClassification: SWC-107"
        },
        {
          "name": "Multiple Calls in a Single Transaction (SWC 113)",
          "vulnerability_from_line": 486,
          "vulnerability_to_line": null,
          "vulnerability_code": "    token.transfer(_distributionContract, 161000000 ether);\n",
          "message": "Multiple calls are executed in the same transaction.\nThis call is executed following another call within the same transaction. It is possible that the call never gets executed if a prior call fails permanently. This might be caused intentionally by a malicious callee. If possible, refactor the code such that each transaction only executes one external call or make sure that all callees can be trusted (i.e. they\u2019re part of your own codebase).\nClassification: SWC-113"
        },
        {
          "name": "State access after external call (SWC 107)",
          "vulnerability_from_line": 486,
          "vulnerability_to_line": null,
          "vulnerability_code": "    token.transfer(_distributionContract, 161000000 ether);\n",
          "message": "Write to persistent state following external call\nThe contract account state is accessed after an external call to a user defined address. To prevent reentrancy issues, consider accessing the state only before the call, especially if the callee is untrusted. Alternatively, a reentrancy lock can be used to prevent untrusted callees from re-entering the contract in an intermediate state.\nClassification: SWC-107"
        },
        {
          "name": "State access after external call (SWC 107)",
          "vulnerability_from_line": 489,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint256 threeMonths = vestingStarts.add(90 days);\n",
          "message": "Read of persistent state following external call\nThe contract account state is accessed after an external call to a user defined address. To prevent reentrancy issues, consider accessing the state only before the call, especially if the callee is untrusted. Alternatively, a reentrancy lock can be used to prevent untrusted callees from re-entering the contract in an intermediate state.\nClassification: SWC-107"
        },
        {
          "name": "State access after external call (SWC 107)",
          "vulnerability_from_line": 492,
          "vulnerability_to_line": null,
          "vulnerability_code": "    grantVestedTokens(0x02f807E6a1a59F8714180B301Cba84E76d3B4d06, 22572063 ether, vestingStarts, threeMonths);\n",
          "message": "Read of persistent state following external call\nThe contract account state is accessed after an external call to a user defined address. To prevent reentrancy issues, consider accessing the state only before the call, especially if the callee is untrusted. Alternatively, a reentrancy lock can be used to prevent untrusted callees from re-entering the contract in an intermediate state.\nClassification: SWC-107"
        },
        {
          "name": "State access after external call (SWC 107)",
          "vulnerability_from_line": 493,
          "vulnerability_to_line": null,
          "vulnerability_code": "    grantVestedTokens(0x3A1e89dD9baDe5985E7Eb36E9AFd200dD0E20613, 15280000 ether, vestingStarts, threeMonths);\n",
          "message": "Read of persistent state following external call\nThe contract account state is accessed after an external call to a user defined address. To prevent reentrancy issues, consider accessing the state only before the call, especially if the callee is untrusted. Alternatively, a reentrancy lock can be used to prevent untrusted callees from re-entering the contract in an intermediate state.\nClassification: SWC-107"
        },
        {
          "name": "State access after external call (SWC 107)",
          "vulnerability_from_line": 494,
          "vulnerability_to_line": null,
          "vulnerability_code": "    grantVestedTokens(0xA61c9A0E96eC7Ceb67586fC8BFDCE009395D9b21, 250000 ether, vestingStarts, threeMonths);\n",
          "message": "Read of persistent state following external call\nThe contract account state is accessed after an external call to a user defined address. To prevent reentrancy issues, consider accessing the state only before the call, especially if the callee is untrusted. Alternatively, a reentrancy lock can be used to prevent untrusted callees from re-entering the contract in an intermediate state.\nClassification: SWC-107"
        },
        {
          "name": "State access after external call (SWC 107)",
          "vulnerability_from_line": 495,
          "vulnerability_to_line": null,
          "vulnerability_code": "    grantVestedTokens(0x26C9899eA2F8940726BbCC79483F2ce07989314E, 100000 ether, vestingStarts, threeMonths);\n",
          "message": "Read of persistent state following external call\nThe contract account state is accessed after an external call to a user defined address. To prevent reentrancy issues, consider accessing the state only before the call, especially if the callee is untrusted. Alternatively, a reentrancy lock can be used to prevent untrusted callees from re-entering the contract in an intermediate state.\nClassification: SWC-107"
        },
        {
          "name": "State access after external call (SWC 107)",
          "vulnerability_from_line": 496,
          "vulnerability_to_line": null,
          "vulnerability_code": "    grantVestedTokens(0xC88d5031e00BC316bE181F0e60971e8fEdB9223b, 1360000 ether, vestingStarts, threeMonths);\n",
          "message": "Read of persistent state following external call\nThe contract account state is accessed after an external call to a user defined address. To prevent reentrancy issues, consider accessing the state only before the call, especially if the callee is untrusted. Alternatively, a reentrancy lock can be used to prevent untrusted callees from re-entering the contract in an intermediate state.\nClassification: SWC-107"
        },
        {
          "name": "State access after external call (SWC 107)",
          "vulnerability_from_line": 497,
          "vulnerability_to_line": null,
          "vulnerability_code": "    grantVestedTokens(0x38f4cAD7997907741FA0D912422Ae59aC6b83dD1, 250000 ether, vestingStarts, threeMonths);\n",
          "message": "Read of persistent state following external call\nThe contract account state is accessed after an external call to a user defined address. To prevent reentrancy issues, consider accessing the state only before the call, especially if the callee is untrusted. Alternatively, a reentrancy lock can be used to prevent untrusted callees from re-entering the contract in an intermediate state.\nClassification: SWC-107"
        },
        {
          "name": "State access after external call (SWC 107)",
          "vulnerability_from_line": 498,
          "vulnerability_to_line": null,
          "vulnerability_code": "    grantVestedTokens(0x2b2992e51E86980966c42736C458e2232376a044, 105000 ether, vestingStarts, threeMonths);\n",
          "message": "Read of persistent state following external call\nThe contract account state is accessed after an external call to a user defined address. To prevent reentrancy issues, consider accessing the state only before the call, especially if the callee is untrusted. Alternatively, a reentrancy lock can be used to prevent untrusted callees from re-entering the contract in an intermediate state.\nClassification: SWC-107"
        },
        {
          "name": "State access after external call (SWC 107)",
          "vulnerability_from_line": 499,
          "vulnerability_to_line": null,
          "vulnerability_code": "    grantVestedTokens(0xdD0F60610052bE0976Cf8BEE576Dbb3a1621a309, 140000 ether, vestingStarts, threeMonths);\n",
          "message": "Read of persistent state following external call\nThe contract account state is accessed after an external call to a user defined address. To prevent reentrancy issues, consider accessing the state only before the call, especially if the callee is untrusted. Alternatively, a reentrancy lock can be used to prevent untrusted callees from re-entering the contract in an intermediate state.\nClassification: SWC-107"
        },
        {
          "name": "State access after external call (SWC 107)",
          "vulnerability_from_line": 500,
          "vulnerability_to_line": null,
          "vulnerability_code": "    grantVestedTokens(0xd61B4F33D3413827baa1425E2FDa485913C9625B, 740000 ether, vestingStarts, threeMonths);\n",
          "message": "Read of persistent state following external call\nThe contract account state is accessed after an external call to a user defined address. To prevent reentrancy issues, consider accessing the state only before the call, especially if the callee is untrusted. Alternatively, a reentrancy lock can be used to prevent untrusted callees from re-entering the contract in an intermediate state.\nClassification: SWC-107"
        },
        {
          "name": "State access after external call (SWC 107)",
          "vulnerability_from_line": 501,
          "vulnerability_to_line": null,
          "vulnerability_code": "    grantVestedTokens(0xE6D4a77D01C680Ebbc0c84393ca598984b3F45e3, 505630 ether, vestingStarts, threeMonths);\n",
          "message": "Read of persistent state following external call\nThe contract account state is accessed after an external call to a user defined address. To prevent reentrancy issues, consider accessing the state only before the call, especially if the callee is untrusted. Alternatively, a reentrancy lock can be used to prevent untrusted callees from re-entering the contract in an intermediate state.\nClassification: SWC-107"
        },
        {
          "name": "State access after external call (SWC 107)",
          "vulnerability_from_line": 502,
          "vulnerability_to_line": null,
          "vulnerability_code": "    grantVestedTokens(0x35D3648c29Ac180D5C7Ef386D52de9539c9c487a, 150000 ether, vestingStarts, threeMonths);\n",
          "message": "Read of persistent state following external call\nThe contract account state is accessed after an external call to a user defined address. To prevent reentrancy issues, consider accessing the state only before the call, especially if the callee is untrusted. Alternatively, a reentrancy lock can be used to prevent untrusted callees from re-entering the contract in an intermediate state.\nClassification: SWC-107"
        },
        {
          "name": "State access after external call (SWC 107)",
          "vulnerability_from_line": 503,
          "vulnerability_to_line": null,
          "vulnerability_code": "    grantVestedTokens(0x344a6130d187f51ef0DAb785e10FaEA0FeE4b5dE, 967500 ether, vestingStarts, threeMonths);\n",
          "message": "Read of persistent state following external call\nThe contract account state is accessed after an external call to a user defined address. To prevent reentrancy issues, consider accessing the state only before the call, especially if the callee is untrusted. Alternatively, a reentrancy lock can be used to prevent untrusted callees from re-entering the contract in an intermediate state.\nClassification: SWC-107"
        },
        {
          "name": "State access after external call (SWC 107)",
          "vulnerability_from_line": 504,
          "vulnerability_to_line": null,
          "vulnerability_code": "    grantVestedTokens(0x026cC76a245987f3420D0FE30070B568b4b46F68, 967500 ether, vestingStarts, threeMonths);\n",
          "message": "Read of persistent state following external call\nThe contract account state is accessed after an external call to a user defined address. To prevent reentrancy issues, consider accessing the state only before the call, especially if the callee is untrusted. Alternatively, a reentrancy lock can be used to prevent untrusted callees from re-entering the contract in an intermediate state.\nClassification: SWC-107"
        },
        {
          "name": "State access after external call (SWC 107)",
          "vulnerability_from_line": 619,
          "vulnerability_to_line": null,
          "vulnerability_code": "    raised = raised.add(usd);\n",
          "message": "Read of persistent state following external call\nThe contract account state is accessed after an external call to a user defined address. To prevent reentrancy issues, consider accessing the state only before the call, especially if the callee is untrusted. Alternatively, a reentrancy lock can be used to prevent untrusted callees from re-entering the contract in an intermediate state.\nClassification: SWC-107"
        },
        {
          "name": "State access after external call (SWC 107)",
          "vulnerability_from_line": 619,
          "vulnerability_to_line": null,
          "vulnerability_code": "    raised = raised.add(usd);\n",
          "message": "Write to persistent state following external call\nThe contract account state is accessed after an external call to a user defined address. To prevent reentrancy issues, consider accessing the state only before the call, especially if the callee is untrusted. Alternatively, a reentrancy lock can be used to prevent untrusted callees from re-entering the contract in an intermediate state.\nClassification: SWC-107"
        },
        {
          "name": "State access after external call (SWC 107)",
          "vulnerability_from_line": 620,
          "vulnerability_to_line": null,
          "vulnerability_code": "    soldTokens = soldTokens.add(tokens);\n",
          "message": "Read of persistent state following external call\nThe contract account state is accessed after an external call to a user defined address. To prevent reentrancy issues, consider accessing the state only before the call, especially if the callee is untrusted. Alternatively, a reentrancy lock can be used to prevent untrusted callees from re-entering the contract in an intermediate state.\nClassification: SWC-107"
        },
        {
          "name": "State access after external call (SWC 107)",
          "vulnerability_from_line": 620,
          "vulnerability_to_line": null,
          "vulnerability_code": "    soldTokens = soldTokens.add(tokens);\n",
          "message": "Write to persistent state following external call\nThe contract account state is accessed after an external call to a user defined address. To prevent reentrancy issues, consider accessing the state only before the call, especially if the callee is untrusted. Alternatively, a reentrancy lock can be used to prevent untrusted callees from re-entering the contract in an intermediate state.\nClassification: SWC-107"
        },
        {
          "name": "State access after external call (SWC 107)",
          "vulnerability_from_line": 622,
          "vulnerability_to_line": null,
          "vulnerability_code": "    require(soldTokens <= HARD_CAP);\n",
          "message": "Read of persistent state following external call\nThe contract account state is accessed after an external call to a user defined address. To prevent reentrancy issues, consider accessing the state only before the call, especially if the callee is untrusted. Alternatively, a reentrancy lock can be used to prevent untrusted callees from re-entering the contract in an intermediate state.\nClassification: SWC-107"
        },
        {
          "name": "State access after external call (SWC 107)",
          "vulnerability_from_line": 638,
          "vulnerability_to_line": null,
          "vulnerability_code": "    token.transfer(vesting, _value);\n",
          "message": "Read of persistent state following external call\nThe contract account state is accessed after an external call to a user defined address. To prevent reentrancy issues, consider accessing the state only before the call, especially if the callee is untrusted. Alternatively, a reentrancy lock can be used to prevent untrusted callees from re-entering the contract in an intermediate state.\nClassification: SWC-107"
        },
        {
          "name": "State access after external call (SWC 107)",
          "vulnerability_from_line": 638,
          "vulnerability_to_line": null,
          "vulnerability_code": "    token.transfer(vesting, _value);\n",
          "message": "Read of persistent state following external call\nThe contract account state is accessed after an external call to a user defined address. To prevent reentrancy issues, consider accessing the state only before the call, especially if the callee is untrusted. Alternatively, a reentrancy lock can be used to prevent untrusted callees from re-entering the contract in an intermediate state.\nClassification: SWC-107"
        },
        {
          "name": "External Call To User-Supplied Address (SWC 107)",
          "vulnerability_from_line": 638,
          "vulnerability_to_line": null,
          "vulnerability_code": "    token.transfer(vesting, _value);\n",
          "message": "A call to a user-supplied address is executed.\nAn external message call to an address specified by the caller is executed. Note that the callee account might contain arbitrary code and could re-enter any function within this contract. Reentering the contract in an intermediate state may lead to unexpected behaviour. Make sure that no state modifications are executed after this call and/or reentrancy guards are in place.\nClassification: SWC-107"
        },
        {
          "name": "State access after external call (SWC 107)",
          "vulnerability_from_line": 638,
          "vulnerability_to_line": null,
          "vulnerability_code": "    token.transfer(vesting, _value);\n",
          "message": "Write to persistent state following external call\nThe contract account state is accessed after an external call to a user defined address. To prevent reentrancy issues, consider accessing the state only before the call, especially if the callee is untrusted. Alternatively, a reentrancy lock can be used to prevent untrusted callees from re-entering the contract in an intermediate state.\nClassification: SWC-107"
        },
        {
          "name": "State access after external call (SWC 107)",
          "vulnerability_from_line": 639,
          "vulnerability_to_line": null,
          "vulnerability_code": "    vesting.grantVestedTokens(_to, _value, _start, _vesting);\n",
          "message": "Read of persistent state following external call\nThe contract account state is accessed after an external call to a user defined address. To prevent reentrancy issues, consider accessing the state only before the call, especially if the callee is untrusted. Alternatively, a reentrancy lock can be used to prevent untrusted callees from re-entering the contract in an intermediate state.\nClassification: SWC-107"
        },
        {
          "name": "External Call To User-Supplied Address (SWC 107)",
          "vulnerability_from_line": 639,
          "vulnerability_to_line": null,
          "vulnerability_code": "    vesting.grantVestedTokens(_to, _value, _start, _vesting);\n",
          "message": "A call to a user-supplied address is executed.\nAn external message call to an address specified by the caller is executed. Note that the callee account might contain arbitrary code and could re-enter any function within this contract. Reentering the contract in an intermediate state may lead to unexpected behaviour. Make sure that no state modifications are executed after this call and/or reentrancy guards are in place.\nClassification: SWC-107"
        },
        {
          "name": "State access after external call (SWC 107)",
          "vulnerability_from_line": 639,
          "vulnerability_to_line": null,
          "vulnerability_code": "    vesting.grantVestedTokens(_to, _value, _start, _vesting);\n",
          "message": "Write to persistent state following external call\nThe contract account state is accessed after an external call to a user defined address. To prevent reentrancy issues, consider accessing the state only before the call, especially if the callee is untrusted. Alternatively, a reentrancy lock can be used to prevent untrusted callees from re-entering the contract in an intermediate state.\nClassification: SWC-107"
        },
        {
          "name": "Exception State (SWC 110)",
          "vulnerability_from_line": 520,
          "vulnerability_to_line": null,
          "vulnerability_code": "    grantVestedTokens(_poolA, 175000000 ether, vestingStarts, vestingStarts.add(7 years));\n",
          "message": "An assertion violation was triggered.\nIt is possible to trigger an assertion violation. Note that Solidity assert() statements should only be used to check invariants. Review the transaction trace generated for this issue and either make sure your program logic is correct, or use require() instead of assert() if your goal is to constrain user inputs or enforce preconditions. Remember to validate inputs from both callers (for instance, via passed arguments) and callees (for instance, via return values).\nClassification: SWC-110"
        }
      ]
    },
    "osiris": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": []
    }
  }
}