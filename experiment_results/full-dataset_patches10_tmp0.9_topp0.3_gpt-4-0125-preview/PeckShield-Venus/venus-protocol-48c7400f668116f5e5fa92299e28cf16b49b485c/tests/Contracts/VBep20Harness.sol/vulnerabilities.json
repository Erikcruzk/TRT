{
  "smartbugs_completed": true,
  "analyzer_results": {
    "semgrep": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 4885,
          "vulnerability_to_line": null,
          "vulnerability_code": "                userAssetList.length--;\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 5386,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < assets.length; i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 5644,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < allMarkets.length; i ++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 5969,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (j = 0; j < holders.length; j++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 5973,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < vTokens.length; i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 5979,
          "vulnerability_to_line": null,
          "vulnerability_code": "                for (j = 0; j < holders.length; j++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 5986,
          "vulnerability_to_line": null,
          "vulnerability_code": "                for (j = 0; j < holders.length; j++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 6211,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < allMarkets_.length; i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 6220,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < allMarkets_.length; i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 6230,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < allMarkets_.length; i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "inefficient-state-variable-increment",
          "vulnerability_from_line": 6169,
          "vulnerability_to_line": null,
          "vulnerability_code": "        blockNumber += blocks;\n",
          "message": "<x> += <y> costs more gas than <x> = <x> + <y> for state variables."
        },
        {
          "name": "inefficient-state-variable-increment",
          "vulnerability_from_line": 6300,
          "vulnerability_to_line": null,
          "vulnerability_code": "        blockNumber += blocks;\n",
          "message": "<x> += <y> costs more gas than <x> = <x> + <y> for state variables."
        },
        {
          "name": "inefficient-state-variable-increment",
          "vulnerability_from_line": 6515,
          "vulnerability_to_line": null,
          "vulnerability_code": "        blockNumber += blocks;\n",
          "message": "<x> += <y> costs more gas than <x> = <x> + <y> for state variables."
        },
        {
          "name": "inefficient-state-variable-increment",
          "vulnerability_from_line": 6651,
          "vulnerability_to_line": null,
          "vulnerability_code": "        blockNumber += blocks;\n",
          "message": "<x> += <y> costs more gas than <x> = <x> + <y> for state variables."
        },
        {
          "name": "init-variables-with-default-value",
          "vulnerability_from_line": 4131,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint8 isLocked = 0;\n",
          "message": "Uninitialized variables are assigned with the types default value. Explicitly initializing a variable with its default value costs unnecessary gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 3001,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor(address underlying_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 3002,
          "vulnerability_to_line": null,
          "vulnerability_code": "                ComptrollerInterface comptroller_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 3003,
          "vulnerability_to_line": null,
          "vulnerability_code": "                InterestRateModel interestRateModel_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 3004,
          "vulnerability_to_line": null,
          "vulnerability_code": "                uint initialExchangeRateMantissa_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 3005,
          "vulnerability_to_line": null,
          "vulnerability_code": "                string memory name_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 3006,
          "vulnerability_to_line": null,
          "vulnerability_code": "                string memory symbol_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 3007,
          "vulnerability_to_line": null,
          "vulnerability_code": "                uint8 decimals_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 3008,
          "vulnerability_to_line": null,
          "vulnerability_code": "                address payable admin_) public {\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 3009,
          "vulnerability_to_line": null,
          "vulnerability_code": "        // Creator of the contract is admin during initialization\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 3010,
          "vulnerability_to_line": null,
          "vulnerability_code": "        admin = msg.sender;\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 3043,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor(address underlying_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 3044,
          "vulnerability_to_line": null,
          "vulnerability_code": "                ComptrollerInterface comptroller_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 3045,
          "vulnerability_to_line": null,
          "vulnerability_code": "                InterestRateModel interestRateModel_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 3046,
          "vulnerability_to_line": null,
          "vulnerability_code": "                uint initialExchangeRateMantissa_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 3047,
          "vulnerability_to_line": null,
          "vulnerability_code": "                string memory name_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 3048,
          "vulnerability_to_line": null,
          "vulnerability_code": "                string memory symbol_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 3049,
          "vulnerability_to_line": null,
          "vulnerability_code": "                uint8 decimals_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 3050,
          "vulnerability_to_line": null,
          "vulnerability_code": "                address payable admin_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 3051,
          "vulnerability_to_line": null,
          "vulnerability_code": "                address implementation_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 3052,
          "vulnerability_to_line": null,
          "vulnerability_code": "                bytes memory becomeImplementationData) public {\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 3501,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor() public {}\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 3986,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor() public {\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 3987,
          "vulnerability_to_line": null,
          "vulnerability_code": "        // Set admin to caller\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 3988,
          "vulnerability_to_line": null,
          "vulnerability_code": "        admin = msg.sender;\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 3989,
          "vulnerability_to_line": null,
          "vulnerability_code": "    }\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 4114,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor() public {\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 4115,
          "vulnerability_to_line": null,
          "vulnerability_code": "        owner = msg.sender;\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 4116,
          "vulnerability_to_line": null,
          "vulnerability_code": "    }\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 4213,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor(address account) public {\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 4214,
          "vulnerability_to_line": null,
          "vulnerability_code": "        balances[account] = uint96(totalSupply);\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 4215,
          "vulnerability_to_line": null,
          "vulnerability_code": "        emit Transfer(address(0), account, totalSupply);\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 4216,
          "vulnerability_to_line": null,
          "vulnerability_code": "    }\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 4558,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor(uint256 chainId_) public {\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 4559,
          "vulnerability_to_line": null,
          "vulnerability_code": "        wards[msg.sender] = 1;\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 4560,
          "vulnerability_to_line": null,
          "vulnerability_code": "        DOMAIN_SEPARATOR = keccak256(abi.encode(\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 4561,
          "vulnerability_to_line": null,
          "vulnerability_code": "            keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 4562,
          "vulnerability_to_line": null,
          "vulnerability_code": "            keccak256(bytes(name)),\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 4563,
          "vulnerability_to_line": null,
          "vulnerability_code": "            keccak256(bytes(version)),\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 4564,
          "vulnerability_to_line": null,
          "vulnerability_code": "            chainId_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 4565,
          "vulnerability_to_line": null,
          "vulnerability_code": "            address(this)\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 4566,
          "vulnerability_to_line": null,
          "vulnerability_code": "        ));\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 4567,
          "vulnerability_to_line": null,
          "vulnerability_code": "    }\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 4749,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor() public {\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 4750,
          "vulnerability_to_line": null,
          "vulnerability_code": "        admin = msg.sender;\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 4751,
          "vulnerability_to_line": null,
          "vulnerability_code": "    }\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 6146,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor() Comptroller() public {}\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 6253,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor(address underlying_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 6254,
          "vulnerability_to_line": null,
          "vulnerability_code": "                ComptrollerInterface comptroller_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 6255,
          "vulnerability_to_line": null,
          "vulnerability_code": "                InterestRateModel interestRateModel_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 6256,
          "vulnerability_to_line": null,
          "vulnerability_code": "                uint initialExchangeRateMantissa_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 6257,
          "vulnerability_to_line": null,
          "vulnerability_code": "                string memory name_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 6258,
          "vulnerability_to_line": null,
          "vulnerability_code": "                string memory symbol_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 6259,
          "vulnerability_to_line": null,
          "vulnerability_code": "                uint8 decimals_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 6260,
          "vulnerability_to_line": null,
          "vulnerability_code": "                address payable admin_)\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 6261,
          "vulnerability_to_line": null,
          "vulnerability_code": "    VBep20Immutable(\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 6262,
          "vulnerability_to_line": null,
          "vulnerability_code": "    underlying_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 6392,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor(address underlying_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 6393,
          "vulnerability_to_line": null,
          "vulnerability_code": "                ComptrollerInterface comptroller_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 6394,
          "vulnerability_to_line": null,
          "vulnerability_code": "                InterestRateModel interestRateModel_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 6395,
          "vulnerability_to_line": null,
          "vulnerability_code": "                uint initialExchangeRateMantissa_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 6396,
          "vulnerability_to_line": null,
          "vulnerability_code": "                string memory name_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 6397,
          "vulnerability_to_line": null,
          "vulnerability_code": "                string memory symbol_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 6398,
          "vulnerability_to_line": null,
          "vulnerability_code": "                uint8 decimals_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 6399,
          "vulnerability_to_line": null,
          "vulnerability_code": "                address payable admin_)\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 6400,
          "vulnerability_to_line": null,
          "vulnerability_code": "    VBep20Immutable(\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 6401,
          "vulnerability_to_line": null,
          "vulnerability_code": "    underlying_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 6425,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor(address underlying_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 6426,
          "vulnerability_to_line": null,
          "vulnerability_code": "                ComptrollerInterface comptroller_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 6427,
          "vulnerability_to_line": null,
          "vulnerability_code": "                InterestRateModel interestRateModel_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 6428,
          "vulnerability_to_line": null,
          "vulnerability_code": "                uint initialExchangeRateMantissa_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 6429,
          "vulnerability_to_line": null,
          "vulnerability_code": "                string memory name_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 6430,
          "vulnerability_to_line": null,
          "vulnerability_code": "                string memory symbol_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 6431,
          "vulnerability_to_line": null,
          "vulnerability_code": "                uint8 decimals_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 6432,
          "vulnerability_to_line": null,
          "vulnerability_code": "                address payable admin_)\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 6433,
          "vulnerability_to_line": null,
          "vulnerability_code": "    VBep20Scenario(\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 6434,
          "vulnerability_to_line": null,
          "vulnerability_code": "    underlying_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 6449,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor(address underlying_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 6450,
          "vulnerability_to_line": null,
          "vulnerability_code": "                ComptrollerInterface comptroller_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 6451,
          "vulnerability_to_line": null,
          "vulnerability_code": "                InterestRateModel interestRateModel_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 6452,
          "vulnerability_to_line": null,
          "vulnerability_code": "                uint initialExchangeRateMantissa_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 6453,
          "vulnerability_to_line": null,
          "vulnerability_code": "                string memory name_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 6454,
          "vulnerability_to_line": null,
          "vulnerability_code": "                string memory symbol_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 6455,
          "vulnerability_to_line": null,
          "vulnerability_code": "                uint8 decimals_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 6456,
          "vulnerability_to_line": null,
          "vulnerability_code": "                address payable admin_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 6457,
          "vulnerability_to_line": null,
          "vulnerability_code": "                address implementation_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 6458,
          "vulnerability_to_line": null,
          "vulnerability_code": "                bytes memory becomeImplementationData)\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 6615,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor() public {}\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 4360,
          "vulnerability_to_line": null,
          "vulnerability_code": "            Checkpoint memory cp = checkpoints[account][center];\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 4804,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < len; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 5386,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < assets.length; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 5644,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < allMarkets.length; i ++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 5686,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(uint i = 0; i < numMarkets; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 5973,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < vTokens.length; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 6185,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < m; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 6193,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < m; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 6211,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < allMarkets_.length; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 6220,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < allMarkets_.length; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 6230,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < allMarkets_.length; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1357,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == admin, \"only admin may initialize the market\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1358,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(accrualBlockNumber == 0 && borrowIndex == 0, \"market may only be initialized once\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1362,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(initialExchangeRateMantissa > 0, \"initial exchange rate must be greater than zero.\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1366,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(err == uint(Error.NO_ERROR), \"setting comptroller failed\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1374,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(err == uint(Error.NO_ERROR), \"setting interest rate model failed\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1518,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(mErr == MathError.NO_ERROR, \"balance could not be calculated\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1577,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1587,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1598,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(err == MathError.NO_ERROR, \"borrowBalanceStored: borrowBalanceStoredInternal failed\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1644,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1655,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(err == MathError.NO_ERROR, \"exchangeRateStored: exchangeRateStoredInternal failed\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1727,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1731,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(mathErr == MathError.NO_ERROR, \"could not calculate block delta\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1861,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(vars.mathErr == MathError.NO_ERROR, \"MINT_EXCHANGE_CALCULATION_FAILED\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1869,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(vars.mathErr == MathError.NO_ERROR, \"MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1872,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(vars.mathErr == MathError.NO_ERROR, \"MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1939,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 2250,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(vars.mathErr == MathError.NO_ERROR, \"REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 2253,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(vars.mathErr == MathError.NO_ERROR, \"REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 2348,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(amountSeizeError == uint(Error.NO_ERROR), \"LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 2351,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(vTokenCollateral.balanceOf(borrower) >= seizeTokens, \"LIQUIDATE_SEIZE_TOO_MUCH\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 2362,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(seizeError == uint(Error.NO_ERROR), \"token seizure failed\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 2511,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(newComptroller.isComptroller(), \"marker method returned false\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 2616,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(totalReservesNew >= totalReserves, \"add reserves unexpected overflow\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 2680,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(totalReservesNew <= totalReserves, \"reduce reserves unexpected underflow\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 2734,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 2774,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_notEntered, \"re-entered\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 2941,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(success, \"TOKEN_TRANSFER_IN_FAILED\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 2945,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(balanceAfter >= balanceBefore, \"TOKEN_TRANSFER_IN_OVERFLOW\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 2976,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(success, \"TOKEN_TRANSFER_OUT_FAILED\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 3080,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == admin, \"VBep20Delegator::_setImplementation: Caller must be admin\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 3472,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.value == 0,\"VBep20Delegator:fallback: cannot send value to fallback\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 3516,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == admin, \"only the admin may call _becomeImplementation\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 3528,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == admin, \"only the admin may call _resignImplementation\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 3562,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == admin, \"only the admin may initialize the implementation\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 3579,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(address(dai) == underlying, \"DAI must be the same as underlying\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 3604,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == admin, \"only the admin may abandon the implementation\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 3662,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(token.transferFrom(from, address(this), amount), \"unexpected EIP-20 transfer in return\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 3705,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require((z = x + y) >= x, \"add-overflow\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 3709,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(y == 0 || (z = x * y) / y == x, \"mul-overflow\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 4119,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == owner, \"Should be owner\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 4137,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(isLocked == 0, \"Token is locked\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 4315,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(signatory != address(0), \"XVS::delegateBySig: invalid signature\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 4316,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(nonce == nonces[signatory]++, \"XVS::delegateBySig: invalid nonce\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 4317,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(now <= expiry, \"XVS::delegateBySig: signature expired\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 4339,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(blockNumber < block.number, \"XVS::getPriorVotes: not yet determined\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 4383,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(src != address(0), \"XVS::_transferTokens: cannot transfer from the zero address\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 4384,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(dst != address(0), \"XVS::_transferTokens: cannot transfer to the zero address\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 4527,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(wards[msg.sender] == 1, \"VAI/not-authorized\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 4547,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require((z = x + y) >= x, \"VAI math error\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 4550,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require((z = x - y) <= x, \"VAI math error\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 4576,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(balanceOf[src] >= wad, \"VAI/insufficient-balance\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 4578,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(allowance[src][msg.sender] >= wad, \"VAI/insufficient-allowance\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 4592,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(balanceOf[usr] >= wad, \"VAI/insufficient-balance\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 4594,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(allowance[usr][msg.sender] >= wad, \"VAI/insufficient-allowance\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 4633,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(holder != address(0), \"VAI/invalid-address-0\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 4634,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(holder == ecrecover(digest, v, r, s), \"VAI/invalid-permit\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 4635,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(expiry == 0 || now <= expiry, \"VAI/permit-expired\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 4636,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(nonce == nonces[holder]++, \"VAI/invalid-nonce\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 4754,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(!protocolPaused, \"protocol is paused\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 4759,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == admin, \"only admin can\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 4764,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(markets[address(vToken)].isListed, \"venus market is not listed\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 4769,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == pauseGuardian || msg.sender == admin, \"only pause guardian and admin can\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 4770,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == admin || state == true, \"only admin can unpause\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 4854,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(oErr == 0, \"getAccountSnapshot failed\"); // semi-opaque error code\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 4909,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(!mintGuardianPaused[vToken], \"mint is paused\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 4995,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(redeemTokens != 0 || redeemAmount == 0, \"redeemTokens zero\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 5007,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(!borrowGuardianPaused[vToken], \"borrow is paused\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 5015,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(msg.sender == vToken, \"sender must be vToken\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 5033,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(nextTotalBorrows < borrowCap, \"market borrow cap reached\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 5216,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(!seizeGuardianPaused, \"seize is paused\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 5275,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(!transferGuardianPaused, \"transfer is paused\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 5541,
          "vulnerability_to_line": null,
          "vulnerability_code": "    \trequire(msg.sender == admin, \"only admin can set close factor\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 5645,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(allMarkets[i] != vToken, \"market already added\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 5679,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == admin || msg.sender == borrowCapGuardian, \"only admin or borrow cap guardian can set borrow caps\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 5684,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(numMarkets != 0 && numMarkets == numBorrowCaps, \"invalid input\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 5751,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(newTreasuryPercent < 1e18, \"treasury percent cap overflow\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 5769,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == unitroller.admin(), \"only unitroller admin can\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 5770,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(unitroller._acceptImplementation() == 0, \"not authorized\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 5792,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(market.isListed == true, \"venus market is not listed\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 5975,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(markets[address(vToken)].isListed, \"not listed market\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 6052,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(adminOrInitializing(), \"only admin can set venus speed\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 6087,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(!mintVAIGuardianPaused && !repayVAIGuardianPaused, \"VAI is paused\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 6272,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(failTransferToAddresses[to] == false, \"TOKEN_TRANSFER_OUT_FAILED\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 6498,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(failTransferToAddresses[to] == false, \"TOKEN_TRANSFER_OUT_FAILED\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 6641,
          "vulnerability_to_line": null,
          "vulnerability_code": "      revert(\"protect the baby\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 1358,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(accrualBlockNumber == 0 && borrowIndex == 0, \"market may only be initialized once\");\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 5684,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(numMarkets != 0 && numMarkets == numBorrowCaps, \"invalid input\");\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 6087,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(!mintVAIGuardianPaused && !repayVAIGuardianPaused, \"VAI is paused\");\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4282,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (spender != src && spenderAllowance != uint96(-1)) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4283,
          "vulnerability_to_line": null,
          "vulnerability_code": "            uint96 newAllowance = sub96(spenderAllowance, amount, \"XVS::transferFrom: transfer amount exceeds spender allowance\");\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4284,
          "vulnerability_to_line": null,
          "vulnerability_code": "            allowances[src][spender] = newAllowance;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4285,
          "vulnerability_to_line": null,
          "vulnerability_code": "\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4286,
          "vulnerability_to_line": null,
          "vulnerability_code": "            emit Approval(src, spender, newAllowance);\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4287,
          "vulnerability_to_line": null,
          "vulnerability_code": "        }\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4394,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (srcRep != dstRep && amount > 0) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4395,
          "vulnerability_to_line": null,
          "vulnerability_code": "            if (srcRep != address(0)) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4396,
          "vulnerability_to_line": null,
          "vulnerability_code": "                uint32 srcRepNum = numCheckpoints[srcRep];\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4397,
          "vulnerability_to_line": null,
          "vulnerability_code": "                uint96 srcRepOld = srcRepNum > 0 ? checkpoints[srcRep][srcRepNum - 1].votes : 0;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4398,
          "vulnerability_to_line": null,
          "vulnerability_code": "                uint96 srcRepNew = sub96(srcRepOld, amount, \"XVS::_moveVotes: vote amount underflows\");\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4399,
          "vulnerability_to_line": null,
          "vulnerability_code": "                _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4400,
          "vulnerability_to_line": null,
          "vulnerability_code": "            }\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4401,
          "vulnerability_to_line": null,
          "vulnerability_code": "\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4402,
          "vulnerability_to_line": null,
          "vulnerability_code": "            if (dstRep != address(0)) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4403,
          "vulnerability_to_line": null,
          "vulnerability_code": "                uint32 dstRepNum = numCheckpoints[dstRep];\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4414,
          "vulnerability_to_line": null,
          "vulnerability_code": "      if (nCheckpoints > 0 && checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4415,
          "vulnerability_to_line": null,
          "vulnerability_code": "          checkpoints[delegatee][nCheckpoints - 1].votes = newVotes;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4416,
          "vulnerability_to_line": null,
          "vulnerability_code": "      } else {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4417,
          "vulnerability_to_line": null,
          "vulnerability_code": "          checkpoints[delegatee][nCheckpoints] = Checkpoint(blockNumber, newVotes);\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4418,
          "vulnerability_to_line": null,
          "vulnerability_code": "          numCheckpoints[delegatee] = nCheckpoints + 1;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4419,
          "vulnerability_to_line": null,
          "vulnerability_code": "      }\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4577,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (src != msg.sender && allowance[src][msg.sender] != uint(-1)) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4578,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(allowance[src][msg.sender] >= wad, \"VAI/insufficient-allowance\");\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4579,
          "vulnerability_to_line": null,
          "vulnerability_code": "            allowance[src][msg.sender] = sub(allowance[src][msg.sender], wad);\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4580,
          "vulnerability_to_line": null,
          "vulnerability_code": "        }\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4593,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (usr != msg.sender && allowance[usr][msg.sender] != uint(-1)) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4594,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(allowance[usr][msg.sender] >= wad, \"VAI/insufficient-allowance\");\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4595,
          "vulnerability_to_line": null,
          "vulnerability_code": "            allowance[usr][msg.sender] = sub(allowance[usr][msg.sender], wad);\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4596,
          "vulnerability_to_line": null,
          "vulnerability_code": "        }\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 5578,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (newCollateralFactorMantissa != 0 && oracle.getUnderlyingPrice(vToken) == 0) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 5579,
          "vulnerability_to_line": null,
          "vulnerability_code": "            return fail(Error.PRICE_ERROR, FailureInfo.SET_COLLATERAL_FACTOR_WITHOUT_PRICE);\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 5580,
          "vulnerability_to_line": null,
          "vulnerability_code": "        }\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 5794,
          "vulnerability_to_line": null,
          "vulnerability_code": "            if (venusSupplyState[address(vToken)].index == 0 && venusSupplyState[address(vToken)].block == 0) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 5795,
          "vulnerability_to_line": null,
          "vulnerability_code": "                venusSupplyState[address(vToken)] = VenusMarketState({\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 5796,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    index: venusInitialIndex,\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 5797,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    block: safe32(getBlockNumber(), \"block number exceeds 32 bits\")\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 5798,
          "vulnerability_to_line": null,
          "vulnerability_code": "                });\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 5799,
          "vulnerability_to_line": null,
          "vulnerability_code": "            }\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 5802,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (venusBorrowState[address(vToken)].index == 0 && venusBorrowState[address(vToken)].block == 0) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 5803,
          "vulnerability_to_line": null,
          "vulnerability_code": "                venusBorrowState[address(vToken)] = VenusMarketState({\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 5804,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    index: venusInitialIndex,\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 5805,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    block: safe32(getBlockNumber(), \"block number exceeds 32 bits\")\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 5806,
          "vulnerability_to_line": null,
          "vulnerability_code": "                });\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 5807,
          "vulnerability_to_line": null,
          "vulnerability_code": "            }\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 5825,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (deltaBlocks > 0 && supplySpeed > 0) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 5826,
          "vulnerability_to_line": null,
          "vulnerability_code": "            uint supplyTokens = VToken(vToken).totalSupply();\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 5827,
          "vulnerability_to_line": null,
          "vulnerability_code": "            uint venusAccrued = mul_(deltaBlocks, supplySpeed);\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 5828,
          "vulnerability_to_line": null,
          "vulnerability_code": "            Double memory ratio = supplyTokens > 0 ? fraction(venusAccrued, supplyTokens) : Double({mantissa: 0});\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 5829,
          "vulnerability_to_line": null,
          "vulnerability_code": "            Double memory index = add_(Double({mantissa: supplyState.index}), ratio);\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 5830,
          "vulnerability_to_line": null,
          "vulnerability_code": "            venusSupplyState[vToken] = VenusMarketState({\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 5831,
          "vulnerability_to_line": null,
          "vulnerability_code": "                index: safe224(index.mantissa, \"new index overflows\"),\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 5832,
          "vulnerability_to_line": null,
          "vulnerability_code": "                block: safe32(blockNumber, \"block number overflows\")\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 5833,
          "vulnerability_to_line": null,
          "vulnerability_code": "            });\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 5834,
          "vulnerability_to_line": null,
          "vulnerability_code": "        } else if (deltaBlocks > 0) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 5848,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (deltaBlocks > 0 && borrowSpeed > 0) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 5849,
          "vulnerability_to_line": null,
          "vulnerability_code": "            uint borrowAmount = div_(VToken(vToken).totalBorrows(), marketBorrowIndex);\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 5850,
          "vulnerability_to_line": null,
          "vulnerability_code": "            uint venusAccrued = mul_(deltaBlocks, borrowSpeed);\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 5851,
          "vulnerability_to_line": null,
          "vulnerability_code": "            Double memory ratio = borrowAmount > 0 ? fraction(venusAccrued, borrowAmount) : Double({mantissa: 0});\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 5852,
          "vulnerability_to_line": null,
          "vulnerability_code": "            Double memory index = add_(Double({mantissa: borrowState.index}), ratio);\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 5853,
          "vulnerability_to_line": null,
          "vulnerability_code": "            venusBorrowState[vToken] = VenusMarketState({\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 5854,
          "vulnerability_to_line": null,
          "vulnerability_code": "                index: safe224(index.mantissa, \"new index overflows\"),\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 5855,
          "vulnerability_to_line": null,
          "vulnerability_code": "                block: safe32(blockNumber, \"block number overflows\")\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 5856,
          "vulnerability_to_line": null,
          "vulnerability_code": "            });\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 5857,
          "vulnerability_to_line": null,
          "vulnerability_code": "        } else if (deltaBlocks > 0) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 5877,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (supplierIndex.mantissa == 0 && supplyIndex.mantissa > 0) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 5878,
          "vulnerability_to_line": null,
          "vulnerability_code": "            supplierIndex.mantissa = venusInitialIndex;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 5879,
          "vulnerability_to_line": null,
          "vulnerability_code": "        }\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 6004,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (amount > 0 && amount <= venusRemaining) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 6005,
          "vulnerability_to_line": null,
          "vulnerability_code": "            xvs.transfer(user, amount);\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 6006,
          "vulnerability_to_line": null,
          "vulnerability_code": "            return 0;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 6007,
          "vulnerability_to_line": null,
          "vulnerability_code": "        }\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-prefix-decrement-not-postfix",
          "vulnerability_from_line": 4885,
          "vulnerability_to_line": null,
          "vulnerability_code": "                userAssetList.length--;\n",
          "message": "Consider using the prefix decrement expression whenever the return value is not needed. The prefix decrement expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 4316,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(nonce == nonces[signatory]++, \"XVS::delegateBySig: invalid nonce\");\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 4636,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(nonce == nonces[holder]++, \"VAI/invalid-nonce\");\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 4804,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < len; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 4882,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (; i < len; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 5386,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < assets.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 5644,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < allMarkets.length; i ++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 5686,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(uint i = 0; i < numMarkets; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 5969,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (j = 0; j < holders.length; j++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 5973,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < vTokens.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 5979,
          "vulnerability_to_line": null,
          "vulnerability_code": "                for (j = 0; j < holders.length; j++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 5986,
          "vulnerability_to_line": null,
          "vulnerability_code": "                for (j = 0; j < holders.length; j++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 6185,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < m; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 6187,
          "vulnerability_to_line": null,
          "vulnerability_code": "                n++;\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 6193,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < m; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 6211,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < allMarkets_.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 6220,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < allMarkets_.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 6230,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < allMarkets_.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 1357,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == admin, \"only admin may initialize the market\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 1358,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(accrualBlockNumber == 0 && borrowIndex == 0, \"market may only be initialized once\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 1362,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(initialExchangeRateMantissa > 0, \"initial exchange rate must be greater than zero.\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 1374,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(err == uint(Error.NO_ERROR), \"setting interest rate model failed\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 1598,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(err == MathError.NO_ERROR, \"borrowBalanceStored: borrowBalanceStoredInternal failed\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 1655,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(err == MathError.NO_ERROR, \"exchangeRateStored: exchangeRateStoredInternal failed\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 1869,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(vars.mathErr == MathError.NO_ERROR, \"MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 1872,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(vars.mathErr == MathError.NO_ERROR, \"MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 1939,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 2250,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(vars.mathErr == MathError.NO_ERROR, \"REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 2253,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(vars.mathErr == MathError.NO_ERROR, \"REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 2348,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(amountSeizeError == uint(Error.NO_ERROR), \"LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 2680,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(totalReservesNew <= totalReserves, \"reduce reserves unexpected underflow\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 3080,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == admin, \"VBep20Delegator::_setImplementation: Caller must be admin\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 3472,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.value == 0,\"VBep20Delegator:fallback: cannot send value to fallback\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 3516,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == admin, \"only the admin may call _becomeImplementation\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 3528,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == admin, \"only the admin may call _resignImplementation\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 3562,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == admin, \"only the admin may initialize the implementation\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 3579,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(address(dai) == underlying, \"DAI must be the same as underlying\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 3604,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == admin, \"only the admin may abandon the implementation\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 3662,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(token.transferFrom(from, address(this), amount), \"unexpected EIP-20 transfer in return\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 4315,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(signatory != address(0), \"XVS::delegateBySig: invalid signature\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 4316,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(nonce == nonces[signatory]++, \"XVS::delegateBySig: invalid nonce\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 4317,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(now <= expiry, \"XVS::delegateBySig: signature expired\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 4339,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(blockNumber < block.number, \"XVS::getPriorVotes: not yet determined\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 4383,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(src != address(0), \"XVS::_transferTokens: cannot transfer from the zero address\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 4384,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(dst != address(0), \"XVS::_transferTokens: cannot transfer to the zero address\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 4769,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == pauseGuardian || msg.sender == admin, \"only pause guardian and admin can\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 5679,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == admin || msg.sender == borrowCapGuardian, \"only admin or borrow cap guardian can set borrow caps\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "compound-borrowfresh-reentrancy",
          "vulnerability_from_line": 2136,
          "vulnerability_to_line": null,
          "vulnerability_code": "        doTransferOut(borrower, borrowAmount);\n",
          "message": "Function borrowFresh() in Compound performs state update after doTransferOut()"
        }
      ]
    },
    "slither": {
      "successfull_analysis": true,
      "errors": [
        "EXIT_CODE_64"
      ],
      "vulnerability_findings": [
        {
          "name": "controlled-delegatecall",
          "vulnerability_from_line": 3430,
          "vulnerability_to_line": 3440,
          "vulnerability_code": "    function delegateTo(address callee, bytes memory data) internal returns (bytes memory) {\n\n        (bool success, bytes memory returnData) = callee.delegatecall(data);\n\n        assembly {\n\n            if eq(success, 0) {\n\n                revert(add(returnData, 0x20), returndatasize)\n\n            }\n\n        }\n\n        return returnData;\n\n    }\n\n\n",
          "message": "VBep20Delegator.delegateTo (VBep20Harness.sol#3430-3440) uses delegatecall to a input-controlled function id\n\t(success,returnData) = callee.delegatecall(data) (VBep20Harness.sol#3431-3432)\n"
        },
        {
          "name": "controlled-delegatecall",
          "vulnerability_from_line": 3471,
          "vulnerability_to_line": 3488,
          "vulnerability_code": "    function () external payable {\n\n        require(msg.value == 0,\"VBep20Delegator:fallback: cannot send value to fallback\");\n\n\n\n        // delegate all other functions to current implementation\n\n        (bool success, ) = implementation.delegatecall(msg.data);\n\n\n\n        assembly {\n\n            let free_mem_ptr := mload(0x40)\n\n            returndatacopy(free_mem_ptr, 0, returndatasize)\n\n\n\n            switch success\n\n            case 0 { revert(free_mem_ptr, returndatasize) }\n\n            default { return(free_mem_ptr, returndatasize) }\n\n        }\n\n    }\n\n}\n\n\n",
          "message": "VBep20Delegator.fallback (VBep20Harness.sol#3471-3488) uses delegatecall to a input-controlled function id\n\t(success) = implementation.delegatecall(msg.data) (VBep20Harness.sol#3475-3477)\n"
        },
        {
          "name": "controlled-delegatecall",
          "vulnerability_from_line": 4089,
          "vulnerability_to_line": 4104,
          "vulnerability_code": "    function () external payable {\n\n        // delegate all other functions to current implementation\n\n        (bool success, ) = comptrollerImplementation.delegatecall(msg.data);\n\n\n\n        assembly {\n\n              let free_mem_ptr := mload(0x40)\n\n              returndatacopy(free_mem_ptr, 0, returndatasize)\n\n\n\n              switch success\n\n              case 0 { revert(free_mem_ptr, returndatasize) }\n\n              default { return(free_mem_ptr, returndatasize) }\n\n        }\n\n    }\n\n}\n\n\n",
          "message": "Unitroller.fallback (VBep20Harness.sol#4089-4104) uses delegatecall to a input-controlled function id\n\t(success) = comptrollerImplementation.delegatecall(msg.data) (VBep20Harness.sol#4091-4093)\n"
        },
        {
          "name": "uninitialized-state",
          "vulnerability_from_line": 3793,
          "vulnerability_to_line": 3795,
          "vulnerability_code": "    address public comptrollerImplementation;\n\n\n",
          "message": "UnitrollerAdminStorage.comptrollerImplementation (VBep20Harness.sol#3793-3795) is never initialized. It is used in:\n\t- adminOrInitializing (VBep20Harness.sol#5776-5780)\n"
        },
        {
          "name": "uninitialized-state",
          "vulnerability_from_line": 3860,
          "vulnerability_to_line": 3861,
          "vulnerability_code": "    bool public transferGuardianPaused;\n",
          "message": "ComptrollerV1Storage.transferGuardianPaused (VBep20Harness.sol#3860-3861) is never initialized. It is used in:\n\t- transferAllowed (VBep20Harness.sol#5273-5293)\n"
        },
        {
          "name": "uninitialized-state",
          "vulnerability_from_line": 3861,
          "vulnerability_to_line": 3862,
          "vulnerability_code": "    bool public seizeGuardianPaused;\n",
          "message": "ComptrollerV1Storage.seizeGuardianPaused (VBep20Harness.sol#3861-3862) is never initialized. It is used in:\n\t- seizeAllowed (VBep20Harness.sol#5209-5239)\n"
        },
        {
          "name": "uninitialized-state",
          "vulnerability_from_line": 3862,
          "vulnerability_to_line": 3863,
          "vulnerability_code": "    mapping(address => bool) public mintGuardianPaused;\n",
          "message": "ComptrollerV1Storage.mintGuardianPaused (VBep20Harness.sol#3862-3863) is never initialized. It is used in:\n\t- mintAllowed (VBep20Harness.sol#4907-4926)\n"
        },
        {
          "name": "uninitialized-state",
          "vulnerability_from_line": 3863,
          "vulnerability_to_line": 3865,
          "vulnerability_code": "    mapping(address => bool) public borrowGuardianPaused;\n\n\n",
          "message": "ComptrollerV1Storage.borrowGuardianPaused (VBep20Harness.sol#3863-3865) is never initialized. It is used in:\n\t- borrowAllowed (VBep20Harness.sol#5005-5053)\n"
        },
        {
          "name": "uninitialized-state",
          "vulnerability_from_line": 3877,
          "vulnerability_to_line": 3879,
          "vulnerability_code": "    uint public venusRate;\n\n\n",
          "message": "ComptrollerV1Storage.venusRate (VBep20Harness.sol#3877-3879) is never initialized. It is used in:\n\t- refreshVenusSpeeds (VBep20Harness.sol#6208-6238)\n"
        },
        {
          "name": "uninitialized-state",
          "vulnerability_from_line": 3909,
          "vulnerability_to_line": 3910,
          "vulnerability_code": "    bool public mintVAIGuardianPaused;\n",
          "message": "ComptrollerV1Storage.mintVAIGuardianPaused (VBep20Harness.sol#3909-3910) is never initialized. It is used in:\n\t- setMintedVAIOf (VBep20Harness.sol#6085-6098)\n"
        },
        {
          "name": "uninitialized-state",
          "vulnerability_from_line": 3910,
          "vulnerability_to_line": 3912,
          "vulnerability_code": "    bool public repayVAIGuardianPaused;\n\n\n",
          "message": "ComptrollerV1Storage.repayVAIGuardianPaused (VBep20Harness.sol#3910-3912) is never initialized. It is used in:\n\t- setMintedVAIOf (VBep20Harness.sol#6085-6098)\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 3457,
          "vulnerability_to_line": 3467,
          "vulnerability_code": "    function delegateToViewImplementation(bytes memory data) public view returns (bytes memory) {\n\n        (bool success, bytes memory returnData) = address(this).staticcall(abi.encodeWithSignature(\"delegateToImplementation(bytes)\", data));\n\n        assembly {\n\n            if eq(success, 0) {\n\n                revert(add(returnData, 0x20), returndatasize)\n\n            }\n\n        }\n\n        return abi.decode(returnData, (bytes));\n\n    }\n\n\n",
          "message": "VBep20Delegator.delegateToViewImplementation (VBep20Harness.sol#3457-3467) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 4445,
          "vulnerability_to_line": 4452,
          "vulnerability_code": "    function getChainId() internal pure returns (uint) {\n\n        uint256 chainId;\n\n        assembly { chainId := chainid() }\n\n        return chainId;\n\n    }\n\n}\n\n\n",
          "message": "XVS.getChainId (VBep20Harness.sol#4445-4452) is declared view but contains assembly code\n"
        },
        {
          "name": "erc20-interface",
          "vulnerability_from_line": 1263,
          "vulnerability_to_line": 1324,
          "vulnerability_code": "interface EIP20NonStandardInterface {\n\n\n\n    /**\n\n     * @notice Get the total number of tokens in circulation\n\n     * @return The supply of tokens\n\n     */\n\n    function totalSupply() external view returns (uint256);\n\n\n\n    /**\n\n     * @notice Gets the balance of the specified address\n\n     * @param owner The address from which the balance will be retrieved\n\n     * @return The balance\n\n     */\n\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n\n\n    ///\n\n    /// !!!!!!!!!!!!!!\n\n    /// !!! NOTICE !!! `transfer` does not return a value, in violation of the BEP-20 specification\n\n    /// !!!!!!!!!!!!!!\n\n    ///\n\n\n\n    /**\n\n      * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n\n      * @param dst The address of the destination account\n\n      * @param amount The number of tokens to transfer\n\n      */\n\n    function transfer(address dst, uint256 amount) external;\n\n\n\n    ///\n\n    /// !!!!!!!!!!!!!!\n\n    /// !!! NOTICE !!! `transferFrom` does not return a value, in violation of the BEP-20 specification\n\n    /// !!!!!!!!!!!!!!\n\n    ///\n\n\n\n    /**\n\n      * @notice Transfer `amount` tokens from `src` to `dst`\n\n      * @param src The address of the source account\n\n      * @param dst The address of the destination account\n\n      * @param amount The number of tokens to transfer\n\n      */\n\n    function transferFrom(address src, address dst, uint256 amount) external;\n\n\n\n    /**\n\n      * @notice Approve `spender` to transfer up to `amount` from `src`\n\n      * @dev This will overwrite the approval amount for `spender`\n\n      * @param spender The address of the account which may transfer tokens\n\n      * @param amount The number of tokens that are approved\n\n      * @return Whether or not the approval succeeded\n\n      */\n\n    function approve(address spender, uint256 amount) external returns (bool success);\n\n\n\n    /**\n\n      * @notice Get the current allowance from `owner` for `spender`\n\n      * @param owner The address of the account which owns the tokens to be spent\n\n      * @param spender The address of the account which may transfer tokens\n\n      * @return The number of tokens allowed to be spent\n\n      */\n\n    function allowance(address owner, address spender) external view returns (uint256 remaining);\n\n\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n",
          "message": "EIP20NonStandardInterface (VBep20Harness.sol#1263-1324) has incorrect ERC20 function interface(s):\n\t-transfer (VBep20Harness.sol#1289)\n\t-transferFrom (VBep20Harness.sol#1303)\n"
        },
        {
          "name": "erc20-interface",
          "vulnerability_from_line": 3723,
          "vulnerability_to_line": 3729,
          "vulnerability_code": "interface GemLike {\n\n    function approve(address, uint) external;\n\n    function balanceOf(address) external view returns (uint);\n\n    function transferFrom(address, address, uint) external returns (bool);\n\n}\n\n\n",
          "message": "GemLike (VBep20Harness.sol#3723-3729) has incorrect ERC20 function interface(s):\n\t-approve (VBep20Harness.sol#3724-3725)\n"
        },
        {
          "name": "erc20-interface",
          "vulnerability_from_line": 6695,
          "vulnerability_to_line": 6750,
          "vulnerability_code": "contract VDaiDelegateMakerHarness is PotLike, VatLike, GemLike, DaiJoinLike {\n\n    /* Pot */\n\n\n\n    // exchangeRate\n\n    function chi() external view returns (uint) { return 1; }\n\n\n\n    // totalSupply\n\n    function pie(address) external view returns (uint) { return 0; }\n\n\n\n    // accrueInterest -> new exchangeRate\n\n    function drip() external returns (uint) { return 0; }\n\n\n\n    // mint\n\n    function join(uint) external {}\n\n\n\n    // redeem\n\n    function exit(uint) external {}\n\n\n\n    /* Vat */\n\n\n\n    // internal dai balance\n\n    function dai(address) external view returns (uint) { return 0; }\n\n\n\n    // approve pot transfer\n\n    function hope(address) external {}\n\n\n\n    /* Gem (Dai) */\n\n\n\n    uint public totalSupply;\n\n    mapping (address => mapping (address => uint)) public allowance;\n\n    mapping (address => uint) public balanceOf;\n\n    function approve(address, uint) external {}\n\n    function transferFrom(address src, address dst, uint amount) external returns (bool) {\n\n        balanceOf[src] -= amount;\n\n        balanceOf[dst] += amount;\n\n        return true;\n\n    }\n\n\n\n    function harnessSetBalance(address account, uint amount) external {\n\n        balanceOf[account] = amount;\n\n    }\n\n\n\n    /* DaiJoin */\n\n\n\n    // vat contract\n\n    function vat() external returns (VatLike) { return this; }\n\n\n\n    // dai contract\n\n    function dai() external returns (GemLike) { return this; }\n\n\n\n    // dai -> internal dai\n\n    function join(address, uint) external payable {}\n\n\n\n    // internal dai transfer out\n\n    function exit(address, uint) external {}\n",
          "message": "VDaiDelegateMakerHarness (VBep20Harness.sol#6695-6750) has incorrect ERC20 function interface(s):\n\t-approve (VBep20Harness.sol#6726-6727)\n"
        },
        {
          "name": "incorrect-equality",
          "vulnerability_from_line": 4411,
          "vulnerability_to_line": 4424,
          "vulnerability_code": "    function _writeCheckpoint(address delegatee, uint32 nCheckpoints, uint96 oldVotes, uint96 newVotes) internal {\n\n      uint32 blockNumber = safe32(block.number, \"XVS::_writeCheckpoint: block number exceeds 32 bits\");\n\n\n\n      if (nCheckpoints > 0 && checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber) {\n\n          checkpoints[delegatee][nCheckpoints - 1].votes = newVotes;\n\n      } else {\n\n          checkpoints[delegatee][nCheckpoints] = Checkpoint(blockNumber, newVotes);\n\n          numCheckpoints[delegatee] = nCheckpoints + 1;\n\n      }\n\n\n\n      emit DelegateVotesChanged(delegatee, oldVotes, newVotes);\n\n    }\n\n\n",
          "message": "XVS._writeCheckpoint (VBep20Harness.sol#4411-4424) uses a dangerous strict equality:\n\t- nCheckpoints > 0 && checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber\n"
        },
        {
          "name": "incorrect-equality",
          "vulnerability_from_line": 6100,
          "vulnerability_to_line": 6137,
          "vulnerability_code": "    function releaseToVault() public {\n\n        if(releaseStartBlock == 0 || getBlockNumber() < releaseStartBlock) {\n\n            return;\n\n        }\n\n\n\n        XVS xvs = XVS(getXVSAddress());\n\n\n\n        uint256 xvsBalance = xvs.balanceOf(address(this));\n\n        if(xvsBalance == 0) {\n\n            return;\n\n        }\n\n\n\n\n\n        uint256 actualAmount;\n\n        uint256 deltaBlocks = sub_(getBlockNumber(), releaseStartBlock);\n\n        // releaseAmount = venusVAIVaultRate * deltaBlocks\n\n        uint256 _releaseAmount = mul_(venusVAIVaultRate, deltaBlocks);\n\n\n\n        if (_releaseAmount < minReleaseAmount) {\n\n            return;\n\n        }\n\n\n\n        if (xvsBalance >= _releaseAmount) {\n\n            actualAmount = _releaseAmount;\n\n        } else {\n\n            actualAmount = xvsBalance;\n\n        }\n\n\n\n        releaseStartBlock = getBlockNumber();\n\n\n\n        xvs.transfer(vaiVaultAddress, actualAmount);\n\n        emit DistributedVAIVaultVenus(actualAmount);\n\n\n\n        IVAIVault(vaiVaultAddress).updatePendingRewards();\n\n    }\n\n}\n\n\n",
          "message": "Comptroller.releaseToVault (VBep20Harness.sol#6100-6137) uses a dangerous strict equality:\n\t- xvsBalance == 0\n"
        },
        {
          "name": "locked-ether",
          "vulnerability_from_line": 6746,
          "vulnerability_to_line": 6748,
          "vulnerability_code": "    function join(address, uint) external payable {}\n\n\n",
          "message": "Contract locking ether found in VBep20Harness.sol:\n\tContract VDaiDelegateMakerHarness has payable functions:\n\t - join (VBep20Harness.sol#6746-6748)\n\tBut does not have a function to withdraw the ether\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 2571,
          "vulnerability_to_line": 2583,
          "vulnerability_code": "    function _addReservesInternal(uint addAmount) internal nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n\n            return fail(Error(error), FailureInfo.ADD_RESERVES_ACCRUE_INTEREST_FAILED);\n\n        }\n\n\n\n        // _addReservesFresh emits reserve-addition-specific logs on errors, so we don't need to.\n\n        (error, ) = _addReservesFresh(addAmount);\n\n        return error;\n\n    }\n\n\n",
          "message": "Reentrancy in VToken._addReservesInternal (VBep20Harness.sol#2571-2583):\n\tExternal calls:\n\t- error = accrueInterest() (VBep20Harness.sol#2572-2573)\n\tState variables written after the call(s):\n\t- totalReserves (VBep20Harness.sol#2579-2580)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 2634,
          "vulnerability_to_line": 2644,
          "vulnerability_code": "    function _reduceReserves(uint reduceAmount) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n\n            return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.\n\n        return _reduceReservesFresh(reduceAmount);\n\n    }\n\n\n",
          "message": "Reentrancy in VToken._reduceReserves (VBep20Harness.sol#2634-2644):\n\tExternal calls:\n\t- error = accrueInterest() (VBep20Harness.sol#2635-2636)\n\tState variables written after the call(s):\n\t- totalReserves (VBep20Harness.sol#2641-2642)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 2503,
          "vulnerability_to_line": 2522,
          "vulnerability_code": "    function _setComptroller(ComptrollerInterface newComptroller) public returns (uint) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COMPTROLLER_OWNER_CHECK);\n\n        }\n\n\n\n        ComptrollerInterface oldComptroller = comptroller;\n\n        // Ensure invoke comptroller.isComptroller() returns true\n\n        require(newComptroller.isComptroller(), \"marker method returned false\");\n\n\n\n        // Set market's comptroller to newComptroller\n\n        comptroller = newComptroller;\n\n\n\n        // Emit NewComptroller(oldComptroller, newComptroller)\n\n        emit NewComptroller(oldComptroller, newComptroller);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Reentrancy in VToken._setComptroller (VBep20Harness.sol#2503-2522):\n\tExternal calls:\n\t- require(bool,string)(newComptroller.isComptroller(),marker method returned false) (VBep20Harness.sol#2511-2512)\n\tState variables written after the call(s):\n\t- comptroller (VBep20Harness.sol#2514-2515)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 3079,
          "vulnerability_to_line": 3094,
          "vulnerability_code": "    function _setImplementation(address implementation_, bool allowResign, bytes memory becomeImplementationData) public {\n\n        require(msg.sender == admin, \"VBep20Delegator::_setImplementation: Caller must be admin\");\n\n\n\n        if (allowResign) {\n\n            delegateToImplementation(abi.encodeWithSignature(\"_resignImplementation()\"));\n\n        }\n\n\n\n        address oldImplementation = implementation;\n\n        implementation = implementation_;\n\n\n\n        delegateToImplementation(abi.encodeWithSignature(\"_becomeImplementation(bytes)\", becomeImplementationData));\n\n\n\n        emit NewImplementation(oldImplementation, implementation);\n\n    }\n\n\n",
          "message": "Reentrancy in VBep20Delegator._setImplementation (VBep20Harness.sol#3079-3094):\n\tExternal calls:\n\t- delegateToImplementation(abi.encodeWithSignature(_resignImplementation())) (VBep20Harness.sol#3083-3084)\n\tState variables written after the call(s):\n\t- implementation (VBep20Harness.sol#3087-3089)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 2699,
          "vulnerability_to_line": 2709,
          "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n\n        return _setInterestRateModelFresh(newInterestRateModel);\n\n    }\n\n\n",
          "message": "Reentrancy in VToken._setInterestRateModel (VBep20Harness.sol#2699-2709):\n\tExternal calls:\n\t- error = accrueInterest() (VBep20Harness.sol#2700-2701)\n\t- _setInterestRateModelFresh(newInterestRateModel) (VBep20Harness.sol#2706-2707)\n\tState variables written after the call(s):\n\t- interestRateModel (VBep20Harness.sol#2706-2707)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 2715,
          "vulnerability_to_line": 2745,
          "vulnerability_code": "    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {\n\n\n\n        // Used to store old model for use in the event that is emitted on success\n\n        InterestRateModel oldInterestRateModel;\n\n\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);\n\n        }\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);\n\n        }\n\n\n\n        // Track the market's current interest rate model\n\n        oldInterestRateModel = interestRateModel;\n\n\n\n        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true\n\n        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n\n\n\n        // Set the interest rate model to newInterestRateModel\n\n        interestRateModel = newInterestRateModel;\n\n\n\n        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)\n\n        emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Reentrancy in VToken._setInterestRateModelFresh (VBep20Harness.sol#2715-2745):\n\tExternal calls:\n\t- require(bool,string)(newInterestRateModel.isInterestRateModel(),marker method returned false) (VBep20Harness.sol#2734-2736)\n\tState variables written after the call(s):\n\t- interestRateModel (VBep20Harness.sol#2737-2739)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 2527,
          "vulnerability_to_line": 2537,
          "vulnerability_code": "    function _setReserveFactor(uint newReserveFactorMantissa) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.\n\n            return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.\n\n        return _setReserveFactorFresh(newReserveFactorMantissa);\n\n    }\n\n\n",
          "message": "Reentrancy in VToken._setReserveFactor (VBep20Harness.sol#2527-2537):\n\tExternal calls:\n\t- error = accrueInterest() (VBep20Harness.sol#2528-2529)\n\tState variables written after the call(s):\n\t- reserveFactorMantissa (VBep20Harness.sol#2534-2535)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 5622,
          "vulnerability_to_line": 5643,
          "vulnerability_code": "    function _supportMarket(VToken vToken) external returns (uint) {\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SUPPORT_MARKET_OWNER_CHECK);\n\n        }\n\n\n\n        if (markets[address(vToken)].isListed) {\n\n            return fail(Error.MARKET_ALREADY_LISTED, FailureInfo.SUPPORT_MARKET_EXISTS);\n\n        }\n\n\n\n        vToken.isVToken(); // Sanity check to make sure its really a VToken\n\n\n\n        // Note that isVenus is not in active use anymore\n\n        markets[address(vToken)] = Market({isListed: true, isVenus: false, collateralFactorMantissa: 0});\n\n\n\n        _addMarketInternal(vToken);\n\n\n\n        emit MarketListed(vToken);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Reentrancy in Comptroller._supportMarket (VBep20Harness.sol#5622-5643):\n\tExternal calls:\n\t- vToken.isVToken() (VBep20Harness.sol#5631)\n\tState variables written after the call(s):\n\t- markets (VBep20Harness.sol#5634-5636)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 1709,
          "vulnerability_to_line": 1787,
          "vulnerability_code": "    function accrueInterest() public returns (uint) {\n\n        /* Remember the initial block number */\n\n        uint currentBlockNumber = getBlockNumber();\n\n        uint accrualBlockNumberPrior = accrualBlockNumber;\n\n\n\n        /* Short-circuit accumulating 0 interest */\n\n        if (accrualBlockNumberPrior == currentBlockNumber) {\n\n            return uint(Error.NO_ERROR);\n\n        }\n\n\n\n        /* Read the previous values out of storage */\n\n        uint cashPrior = getCashPrior();\n\n        uint borrowsPrior = totalBorrows;\n\n        uint reservesPrior = totalReserves;\n\n        uint borrowIndexPrior = borrowIndex;\n\n\n\n        /* Calculate the current borrow interest rate */\n\n        uint borrowRateMantissa = interestRateModel.getBorrowRate(cashPrior, borrowsPrior, reservesPrior);\n\n        require(borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n\n\n\n        /* Calculate the number of blocks elapsed since the last accrual */\n\n        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);\n\n        require(mathErr == MathError.NO_ERROR, \"could not calculate block delta\");\n\n\n\n        /*\n\n         * Calculate the interest accumulated into borrows and reserves and the new index:\n\n         *  simpleInterestFactor = borrowRate * blockDelta\n\n         *  interestAccumulated = simpleInterestFactor * totalBorrows\n\n         *  totalBorrowsNew = interestAccumulated + totalBorrows\n\n         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves\n\n         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\n\n         */\n\n\n\n        Exp memory simpleInterestFactor;\n\n        uint interestAccumulated;\n\n        uint totalBorrowsNew;\n\n        uint totalReservesNew;\n\n        uint borrowIndexNew;\n\n\n\n        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa: borrowRateMantissa}), blockDelta);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED, uint(mathErr));\n\n        }\n\n\n\n        (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED, uint(mathErr));\n\n        }\n\n\n\n        (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED, uint(mathErr));\n\n        }\n\n\n\n        (mathErr, totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa: reserveFactorMantissa}), interestAccumulated, reservesPrior);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED, uint(mathErr));\n\n        }\n\n\n\n        (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndexPrior, borrowIndexPrior);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED, uint(mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accrualBlockNumber = currentBlockNumber;\n\n        borrowIndex = borrowIndexNew;\n\n        totalBorrows = totalBorrowsNew;\n\n        totalReserves = totalReservesNew;\n\n\n\n        /* We emit an AccrueInterest event */\n\n        emit AccrueInterest(cashPrior, interestAccumulated, borrowIndexNew, totalBorrowsNew);\n\n\n\n        return uint(Error.NO_ERROR);\n",
          "message": "Reentrancy in VToken.accrueInterest (VBep20Harness.sol#1709-1787):\n\tExternal calls:\n\t- borrowRateMantissa = interestRateModel.getBorrowRate(cashPrior,borrowsPrior,reservesPrior) (VBep20Harness.sol#1726)\n\tState variables written after the call(s):\n\t- accrualBlockNumber (VBep20Harness.sol#1778)\n\t- borrowIndex (VBep20Harness.sol#1779)\n\t- totalBorrows (VBep20Harness.sol#1780)\n\t- totalReserves (VBep20Harness.sol#1781)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 2065,
          "vulnerability_to_line": 2073,
          "vulnerability_code": "    function borrowInternal(uint borrowAmount) internal nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n\n            return fail(Error(error), FailureInfo.BORROW_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // borrowFresh emits borrow-specific logs on errors, so we don't need to\n\n        return borrowFresh(msg.sender, borrowAmount);\n",
          "message": "Reentrancy in VToken.borrowInternal (VBep20Harness.sol#2065-2073):\n\tExternal calls:\n\t- error = accrueInterest() (VBep20Harness.sol#2066)\n\t- borrowFresh(msg.sender,borrowAmount) (VBep20Harness.sol#2072)\n\tState variables written after the call(s):\n\t- totalBorrows (VBep20Harness.sol#2072)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 5964,
          "vulnerability_to_line": 5995,
          "vulnerability_code": "    function claimVenus(address[] memory holders, VToken[] memory vTokens, bool borrowers, bool suppliers) public {\n\n        uint j;\n\n        if(address(vaiController) != address(0)) {\n\n            vaiController.updateVenusVAIMintIndex();\n\n        }\n\n        for (j = 0; j < holders.length; j++) {\n\n            distributeVAIMinterVenus(holders[j]);\n\n            venusAccrued[holders[j]] = grantXVSInternal(holders[j], venusAccrued[holders[j]]);\n\n        }\n\n        for (uint i = 0; i < vTokens.length; i++) {\n\n            VToken vToken = vTokens[i];\n\n            require(markets[address(vToken)].isListed, \"not listed market\");\n\n            if (borrowers) {\n\n                Exp memory borrowIndex = Exp({mantissa: vToken.borrowIndex()});\n\n                updateVenusBorrowIndex(address(vToken), borrowIndex);\n\n                for (j = 0; j < holders.length; j++) {\n\n                    distributeBorrowerVenus(address(vToken), holders[j], borrowIndex);\n\n                    venusAccrued[holders[j]] = grantXVSInternal(holders[j], venusAccrued[holders[j]]);\n\n                }\n\n            }\n\n            if (suppliers) {\n\n                updateVenusSupplyIndex(address(vToken));\n\n                for (j = 0; j < holders.length; j++) {\n\n                    distributeSupplierVenus(address(vToken), holders[j]);\n\n                    venusAccrued[holders[j]] = grantXVSInternal(holders[j], venusAccrued[holders[j]]);\n\n                }\n\n            }\n\n        }\n\n    }\n\n\n\n    /**\n",
          "message": "Reentrancy in Comptroller.claimVenus (VBep20Harness.sol#5964-5995):\n\tExternal calls:\n\t- vaiController.updateVenusVAIMintIndex() (VBep20Harness.sol#5967-5969)\n\t- borrowIndex = Exp(vToken.borrowIndex()) (VBep20Harness.sol#5977-5978)\n\t- updateVenusBorrowIndex(address(vToken),borrowIndex) (VBep20Harness.sol#5978-5979)\n\t- distributeBorrowerVenus(address(vToken),holders[j],borrowIndex) (VBep20Harness.sol#5980-5981)\n\t- venusAccrued[holders[j]] = grantXVSInternal(holders[j],venusAccrued[holders[j]]) (VBep20Harness.sol#5981-5982)\n\tState variables written after the call(s):\n\t- venusAccrued (VBep20Harness.sol#5981-5982)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 5964,
          "vulnerability_to_line": 5995,
          "vulnerability_code": "    function claimVenus(address[] memory holders, VToken[] memory vTokens, bool borrowers, bool suppliers) public {\n\n        uint j;\n\n        if(address(vaiController) != address(0)) {\n\n            vaiController.updateVenusVAIMintIndex();\n\n        }\n\n        for (j = 0; j < holders.length; j++) {\n\n            distributeVAIMinterVenus(holders[j]);\n\n            venusAccrued[holders[j]] = grantXVSInternal(holders[j], venusAccrued[holders[j]]);\n\n        }\n\n        for (uint i = 0; i < vTokens.length; i++) {\n\n            VToken vToken = vTokens[i];\n\n            require(markets[address(vToken)].isListed, \"not listed market\");\n\n            if (borrowers) {\n\n                Exp memory borrowIndex = Exp({mantissa: vToken.borrowIndex()});\n\n                updateVenusBorrowIndex(address(vToken), borrowIndex);\n\n                for (j = 0; j < holders.length; j++) {\n\n                    distributeBorrowerVenus(address(vToken), holders[j], borrowIndex);\n\n                    venusAccrued[holders[j]] = grantXVSInternal(holders[j], venusAccrued[holders[j]]);\n\n                }\n\n            }\n\n            if (suppliers) {\n\n                updateVenusSupplyIndex(address(vToken));\n\n                for (j = 0; j < holders.length; j++) {\n\n                    distributeSupplierVenus(address(vToken), holders[j]);\n\n                    venusAccrued[holders[j]] = grantXVSInternal(holders[j], venusAccrued[holders[j]]);\n\n                }\n\n            }\n\n        }\n\n    }\n\n\n\n    /**\n",
          "message": "Reentrancy in Comptroller.claimVenus (VBep20Harness.sol#5964-5995):\n\tExternal calls:\n\t- vaiController.updateVenusVAIMintIndex() (VBep20Harness.sol#5967-5969)\n\t- borrowIndex = Exp(vToken.borrowIndex()) (VBep20Harness.sol#5977-5978)\n\t- updateVenusBorrowIndex(address(vToken),borrowIndex) (VBep20Harness.sol#5978-5979)\n\t- updateVenusSupplyIndex(address(vToken)) (VBep20Harness.sol#5985-5986)\n\t- distributeSupplierVenus(address(vToken),holders[j]) (VBep20Harness.sol#5987-5988)\n\t- venusAccrued[holders[j]] = grantXVSInternal(holders[j],venusAccrued[holders[j]]) (VBep20Harness.sol#5988-5989)\n\tState variables written after the call(s):\n\t- venusAccrued (VBep20Harness.sol#5988-5989)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 3001,
          "vulnerability_to_line": 3020,
          "vulnerability_code": "    constructor(address underlying_,\n\n                ComptrollerInterface comptroller_,\n\n                InterestRateModel interestRateModel_,\n\n                uint initialExchangeRateMantissa_,\n\n                string memory name_,\n\n                string memory symbol_,\n\n                uint8 decimals_,\n\n                address payable admin_) public {\n\n        // Creator of the contract is admin during initialization\n\n        admin = msg.sender;\n\n\n\n        // Initialize the market\n\n        initialize(underlying_, comptroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_);\n\n\n\n        // Set the proper admin now that initialization is done\n\n        admin = admin_;\n\n    }\n\n}\n\n\n",
          "message": "Reentrancy in VBep20Immutable.constructor (VBep20Harness.sol#3001-3020):\n\tExternal calls:\n\t- initialize(underlying_,comptroller_,interestRateModel_,initialExchangeRateMantissa_,name_,symbol_,decimals_) (VBep20Harness.sol#3013-3015)\n\tState variables written after the call(s):\n\t- admin (VBep20Harness.sol#3016-3017)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 3043,
          "vulnerability_to_line": 3073,
          "vulnerability_code": "    constructor(address underlying_,\n\n                ComptrollerInterface comptroller_,\n\n                InterestRateModel interestRateModel_,\n\n                uint initialExchangeRateMantissa_,\n\n                string memory name_,\n\n                string memory symbol_,\n\n                uint8 decimals_,\n\n                address payable admin_,\n\n                address implementation_,\n\n                bytes memory becomeImplementationData) public {\n\n        // Creator of the contract is admin during initialization\n\n        admin = msg.sender;\n\n\n\n        // First delegate gets to initialize the delegator (i.e. storage contract)\n\n        delegateTo(implementation_, abi.encodeWithSignature(\"initialize(address,address,address,uint256,string,string,uint8)\",\n\n                                                            underlying_,\n\n                                                            comptroller_,\n\n                                                            interestRateModel_,\n\n                                                            initialExchangeRateMantissa_,\n\n                                                            name_,\n\n                                                            symbol_,\n\n                                                            decimals_));\n\n\n\n        // New implementations always get set via the settor (post-initialize)\n\n        _setImplementation(implementation_, false, becomeImplementationData);\n\n\n\n        // Set the proper admin now that initialization is done\n\n        admin = admin_;\n\n    }\n\n\n",
          "message": "Reentrancy in VBep20Delegator.constructor (VBep20Harness.sol#3043-3073):\n\tExternal calls:\n\t- delegateTo(implementation_,abi.encodeWithSignature(initialize(address,address,address,uint256,string,string,uint8),underlying_,comptroller_,interestRateModel_,initialExchangeRateMantissa_,name_,symbol_,decimals_)) (VBep20Harness.sol#3057-3066)\n\t- _setImplementation(implementation_,false,becomeImplementationData) (VBep20Harness.sol#3067-3069)\n\tState variables written after the call(s):\n\t- admin (VBep20Harness.sol#3070-3071)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 4850,
          "vulnerability_to_line": 4898,
          "vulnerability_code": "    function exitMarket(address vTokenAddress) external returns (uint) {\n\n        VToken vToken = VToken(vTokenAddress);\n\n        /* Get sender tokensHeld and amountOwed underlying from the vToken */\n\n        (uint oErr, uint tokensHeld, uint amountOwed, ) = vToken.getAccountSnapshot(msg.sender);\n\n        require(oErr == 0, \"getAccountSnapshot failed\"); // semi-opaque error code\n\n\n\n        /* Fail if the sender has a borrow balance */\n\n        if (amountOwed != 0) {\n\n            return fail(Error.NONZERO_BORROW_BALANCE, FailureInfo.EXIT_MARKET_BALANCE_OWED);\n\n        }\n\n\n\n        /* Fail if the sender is not permitted to redeem all of their tokens */\n\n        uint allowed = redeemAllowedInternal(vTokenAddress, msg.sender, tokensHeld);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.REJECTION, FailureInfo.EXIT_MARKET_REJECTION, allowed);\n\n        }\n\n\n\n        Market storage marketToExit = markets[address(vToken)];\n\n\n\n        /* Return true if the sender is not already \u2018in\u2019 the market */\n\n        if (!marketToExit.accountMembership[msg.sender]) {\n\n            return uint(Error.NO_ERROR);\n\n        }\n\n\n\n        /* Set vToken account membership to false */\n\n        delete marketToExit.accountMembership[msg.sender];\n\n\n\n        /* Delete vToken from the account\u2019s list of assets */\n\n        // In order to delete vToken, copy last item in list to location of item to be removed, reduce length by 1\n\n        VToken[] storage userAssetList = accountAssets[msg.sender];\n\n        uint len = userAssetList.length;\n\n        uint i;\n\n        for (; i < len; i++) {\n\n            if (userAssetList[i] == vToken) {\n\n                userAssetList[i] = userAssetList[len - 1];\n\n                userAssetList.length--;\n\n                break;\n\n            }\n\n        }\n\n\n\n        // We *must* have found the asset in the list or our redundant data structure is broken\n\n        assert(i < len);\n\n\n\n        emit MarketExited(vToken, msg.sender);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Reentrancy in Comptroller.exitMarket (VBep20Harness.sol#4850-4898):\n\tExternal calls:\n\t- (oErr,tokensHeld,amountOwed) = vToken.getAccountSnapshot(msg.sender) (VBep20Harness.sol#4853-4854)\n\t- allowed = redeemAllowedInternal(vTokenAddress,msg.sender,tokensHeld) (VBep20Harness.sol#4862-4863)\n\tState variables written after the call(s):\n\t- accountAssets (VBep20Harness.sol#4884-4885)\n\t- accountAssets (VBep20Harness.sol#4885-4886)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 1351,
          "vulnerability_to_line": 1382,
          "vulnerability_code": "    function initialize(ComptrollerInterface comptroller_,\n\n                        InterestRateModel interestRateModel_,\n\n                        uint initialExchangeRateMantissa_,\n\n                        string memory name_,\n\n                        string memory symbol_,\n\n                        uint8 decimals_) public {\n\n        require(msg.sender == admin, \"only admin may initialize the market\");\n\n        require(accrualBlockNumber == 0 && borrowIndex == 0, \"market may only be initialized once\");\n\n\n\n        // Set initial exchange rate\n\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n\n        require(initialExchangeRateMantissa > 0, \"initial exchange rate must be greater than zero.\");\n\n\n\n        // Set the comptroller\n\n        uint err = _setComptroller(comptroller_);\n\n        require(err == uint(Error.NO_ERROR), \"setting comptroller failed\");\n\n\n\n        // Initialize block number and borrow index (block number mocks depend on comptroller being set)\n\n        accrualBlockNumber = getBlockNumber();\n\n        borrowIndex = mantissaOne;\n\n\n\n        // Set the interest rate model (depends on block number / borrow index)\n\n        err = _setInterestRateModelFresh(interestRateModel_);\n\n        require(err == uint(Error.NO_ERROR), \"setting interest rate model failed\");\n\n\n\n        name = name_;\n\n        symbol = symbol_;\n\n        decimals = decimals_;\n\n\n\n        // The counter starts true to prevent changing it from zero to non-zero (i.e. smaller cost/refund)\n\n        _notEntered = true;\n",
          "message": "Reentrancy in VToken.initialize (VBep20Harness.sol#1351-1382):\n\tExternal calls:\n\t- err = _setComptroller(comptroller_) (VBep20Harness.sol#1365)\n\tState variables written after the call(s):\n\t- accrualBlockNumber (VBep20Harness.sol#1369)\n\t- borrowIndex (VBep20Harness.sol#1370)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 2277,
          "vulnerability_to_line": 2292,
          "vulnerability_code": "    function liquidateBorrowInternal(address borrower, uint repayAmount, VTokenInterface vTokenCollateral) internal nonReentrant returns (uint, uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\n\n            return (fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED), 0);\n\n        }\n\n\n\n        error = vTokenCollateral.accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\n\n            return (fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED), 0);\n\n        }\n\n\n\n        // liquidateBorrowFresh emits borrow-specific logs on errors, so we don't need to\n\n        return liquidateBorrowFresh(msg.sender, borrower, repayAmount, vTokenCollateral);\n",
          "message": "Reentrancy in VToken.liquidateBorrowInternal (VBep20Harness.sol#2277-2292):\n\tExternal calls:\n\t- error = accrueInterest() (VBep20Harness.sol#2278)\n\t- error = vTokenCollateral.accrueInterest() (VBep20Harness.sol#2284)\n\t- liquidateBorrowFresh(msg.sender,borrower,repayAmount,vTokenCollateral) (VBep20Harness.sol#2291)\n\tState variables written after the call(s):\n\t- totalBorrows (VBep20Harness.sol#2291)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 1938,
          "vulnerability_to_line": 2058,
          "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n\n\n\n        RedeemLocalVars memory vars;\n\n\n\n        /* exchangeRate = invoke Exchange Rate Stored() */\n\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* If redeemTokensIn > 0: */\n\n        if (redeemTokensIn > 0) {\n\n            /*\n\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\n\n             *  redeemTokens = redeemTokensIn\n\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n\n             */\n\n            vars.redeemTokens = redeemTokensIn;\n\n\n\n            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED, uint(vars.mathErr));\n\n            }\n\n        } else {\n\n            /*\n\n             * We get the current exchange rate and calculate the amount to be redeemed:\n\n             *  redeemTokens = redeemAmountIn / exchangeRate\n\n             *  redeemAmount = redeemAmountIn\n\n             */\n\n\n\n            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED, uint(vars.mathErr));\n\n            }\n\n\n\n            vars.redeemAmount = redeemAmountIn;\n\n        }\n\n\n\n        /* Fail if redeem not allowed */\n\n        uint allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);\n\n        }\n\n\n\n        /*\n\n         * We calculate the new total supply and redeemer balance, checking for underflow:\n\n         *  totalSupplyNew = totalSupply - redeemTokens\n\n         *  accountTokensNew = accountTokens[redeemer] - redeemTokens\n\n         */\n\n        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* Fail gracefully if protocol has insufficient cash */\n\n        if (getCashPrior() < vars.redeemAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We invoke doTransferOut for the redeemer and the redeemAmount.\n\n         *  Note: The vToken must handle variations between BEP-20 and BNB underlying.\n\n         *  On success, the vToken has redeemAmount less of cash.\n\n         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n\n         */\n\n\n\n        uint feeAmount;\n\n        uint remainedAmount;\n\n        if (IComptroller(address(comptroller)).treasuryPercent() != 0) {\n\n            (vars.mathErr, feeAmount) = mulUInt(vars.redeemAmount, IComptroller(address(comptroller)).treasuryPercent());\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_FEE_CALCULATION_FAILED, uint(vars.mathErr));\n\n            }\n\n\n\n            (vars.mathErr, feeAmount) = divUInt(feeAmount, 1e18);\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_FEE_CALCULATION_FAILED, uint(vars.mathErr));\n\n            }\n\n\n\n            (vars.mathErr, remainedAmount) = subUInt(vars.redeemAmount, feeAmount);\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_FEE_CALCULATION_FAILED, uint(vars.mathErr));\n\n            }\n\n\n\n            doTransferOut(address(uint160(IComptroller(address(comptroller)).treasuryAddress())), feeAmount);\n\n\n\n            emit RedeemFee(redeemer, feeAmount, vars.redeemTokens);\n\n        } else {\n\n            remainedAmount = vars.redeemAmount;\n\n        }\n\n\n\n        doTransferOut(redeemer, remainedAmount);\n\n\n\n        /* We write previously calculated values into storage */\n\n        totalSupply = vars.totalSupplyNew;\n\n        accountTokens[redeemer] = vars.accountTokensNew;\n\n\n\n        /* We emit a Transfer event, and a Redeem event */\n\n        emit Transfer(redeemer, address(this), vars.redeemTokens);\n\n        emit Redeem(redeemer, remainedAmount, vars.redeemTokens);\n\n\n\n        /* We call the defense hook */\n\n        comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        return uint(Error.NO_ERROR);\n",
          "message": "Reentrancy in VToken.redeemFresh (VBep20Harness.sol#1938-2058):\n\tExternal calls:\n\t- allowed = comptroller.redeemAllowed(address(this),redeemer,vars.redeemTokens) (VBep20Harness.sol#1978)\n\t- IComptroller(address(comptroller)).treasuryPercent() != 0 (VBep20Harness.sol#2021-2042)\n\t- (vars.mathErr,feeAmount) = mulUInt(vars.redeemAmount,IComptroller(address(comptroller)).treasuryPercent()) (VBep20Harness.sol#2022)\n\t- doTransferOut(address(uint160(IComptroller(address(comptroller)).treasuryAddress())),feeAmount) (VBep20Harness.sol#2037)\n\tState variables written after the call(s):\n\t- accountTokens (VBep20Harness.sol#2048)\n\t- totalSupply (VBep20Harness.sol#2047)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 6100,
          "vulnerability_to_line": 6137,
          "vulnerability_code": "    function releaseToVault() public {\n\n        if(releaseStartBlock == 0 || getBlockNumber() < releaseStartBlock) {\n\n            return;\n\n        }\n\n\n\n        XVS xvs = XVS(getXVSAddress());\n\n\n\n        uint256 xvsBalance = xvs.balanceOf(address(this));\n\n        if(xvsBalance == 0) {\n\n            return;\n\n        }\n\n\n\n\n\n        uint256 actualAmount;\n\n        uint256 deltaBlocks = sub_(getBlockNumber(), releaseStartBlock);\n\n        // releaseAmount = venusVAIVaultRate * deltaBlocks\n\n        uint256 _releaseAmount = mul_(venusVAIVaultRate, deltaBlocks);\n\n\n\n        if (_releaseAmount < minReleaseAmount) {\n\n            return;\n\n        }\n\n\n\n        if (xvsBalance >= _releaseAmount) {\n\n            actualAmount = _releaseAmount;\n\n        } else {\n\n            actualAmount = xvsBalance;\n\n        }\n\n\n\n        releaseStartBlock = getBlockNumber();\n\n\n\n        xvs.transfer(vaiVaultAddress, actualAmount);\n\n        emit DistributedVAIVaultVenus(actualAmount);\n\n\n\n        IVAIVault(vaiVaultAddress).updatePendingRewards();\n\n    }\n\n}\n\n\n",
          "message": "Reentrancy in Comptroller.releaseToVault (VBep20Harness.sol#6100-6137):\n\tExternal calls:\n\t- xvsBalance = xvs.balanceOf(address(this)) (VBep20Harness.sol#6107-6108)\n\tState variables written after the call(s):\n\t- releaseStartBlock (VBep20Harness.sol#6128-6130)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 2173,
          "vulnerability_to_line": 2181,
          "vulnerability_code": "    function repayBorrowBehalfInternal(address borrower, uint repayAmount) internal nonReentrant returns (uint, uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n\n            return (fail(Error(error), FailureInfo.REPAY_BEHALF_ACCRUE_INTEREST_FAILED), 0);\n\n        }\n\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n\n        return repayBorrowFresh(msg.sender, borrower, repayAmount);\n",
          "message": "Reentrancy in VToken.repayBorrowBehalfInternal (VBep20Harness.sol#2173-2181):\n\tExternal calls:\n\t- error = accrueInterest() (VBep20Harness.sol#2174)\n\t- repayBorrowFresh(msg.sender,borrower,repayAmount) (VBep20Harness.sol#2180)\n\tState variables written after the call(s):\n\t- totalBorrows (VBep20Harness.sol#2180)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 2157,
          "vulnerability_to_line": 2165,
          "vulnerability_code": "    function repayBorrowInternal(uint repayAmount) internal nonReentrant returns (uint, uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n\n            return (fail(Error(error), FailureInfo.REPAY_BORROW_ACCRUE_INTEREST_FAILED), 0);\n\n        }\n\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n\n        return repayBorrowFresh(msg.sender, msg.sender, repayAmount);\n",
          "message": "Reentrancy in VToken.repayBorrowInternal (VBep20Harness.sol#2157-2165):\n\tExternal calls:\n\t- error = accrueInterest() (VBep20Harness.sol#2158)\n\t- repayBorrowFresh(msg.sender,msg.sender,repayAmount) (VBep20Harness.sol#2164)\n\tState variables written after the call(s):\n\t- totalBorrows (VBep20Harness.sol#2164)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 5209,
          "vulnerability_to_line": 5239,
          "vulnerability_code": "    function seizeAllowed(\n\n        address vTokenCollateral,\n\n        address vTokenBorrowed,\n\n        address liquidator,\n\n        address borrower,\n\n        uint seizeTokens) external onlyProtocolAllowed returns (uint) {\n\n        // Pausing is a very serious situation - we revert to sound the alarms\n\n        require(!seizeGuardianPaused, \"seize is paused\");\n\n\n\n        // Shh - currently unused\n\n        seizeTokens;\n\n\n\n        // We've added VAIController as a borrowed token list check for seize\n\n        if (!markets[vTokenCollateral].isListed || !(markets[vTokenBorrowed].isListed || address(vTokenBorrowed) == address(vaiController))) {\n\n            return uint(Error.MARKET_NOT_LISTED);\n\n        }\n\n\n\n        if (VToken(vTokenCollateral).comptroller() != VToken(vTokenBorrowed).comptroller()) {\n\n            return uint(Error.COMPTROLLER_MISMATCH);\n\n        }\n\n\n\n        // Keep the flywheel moving\n\n        updateVenusSupplyIndex(vTokenCollateral);\n\n        distributeSupplierVenus(vTokenCollateral, borrower);\n\n        distributeSupplierVenus(vTokenCollateral, liquidator);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
          "message": "Reentrancy in Comptroller.seizeAllowed (VBep20Harness.sol#5209-5239):\n\tExternal calls:\n\t- updateVenusSupplyIndex(vTokenCollateral) (VBep20Harness.sol#5231-5232)\n\t- distributeSupplierVenus(vTokenCollateral,borrower) (VBep20Harness.sol#5232-5233)\n\t- distributeSupplierVenus(vTokenCollateral,liquidator) (VBep20Harness.sol#5233-5235)\n\tState variables written after the call(s):\n\t- releaseStartBlock (VBep20Harness.sol#5233-5235)\n\t- venusAccrued (VBep20Harness.sol#5233-5235)\n\t- venusSupplierIndex (VBep20Harness.sol#5233-5235)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 5782,
          "vulnerability_to_line": 5817,
          "vulnerability_code": "    function setVenusSpeedInternal(VToken vToken, uint venusSpeed) internal {\n\n        uint currentVenusSpeed = venusSpeeds[address(vToken)];\n\n        if (currentVenusSpeed != 0) {\n\n            // note that XVS speed could be set to 0 to halt liquidity rewards for a market\n\n            Exp memory borrowIndex = Exp({mantissa: vToken.borrowIndex()});\n\n            updateVenusSupplyIndex(address(vToken));\n\n            updateVenusBorrowIndex(address(vToken), borrowIndex);\n\n        } else if (venusSpeed != 0) {\n\n            // Add the XVS market\n\n            Market storage market = markets[address(vToken)];\n\n            require(market.isListed == true, \"venus market is not listed\");\n\n\n\n            if (venusSupplyState[address(vToken)].index == 0 && venusSupplyState[address(vToken)].block == 0) {\n\n                venusSupplyState[address(vToken)] = VenusMarketState({\n\n                    index: venusInitialIndex,\n\n                    block: safe32(getBlockNumber(), \"block number exceeds 32 bits\")\n\n                });\n\n            }\n\n\n\n\n\n        if (venusBorrowState[address(vToken)].index == 0 && venusBorrowState[address(vToken)].block == 0) {\n\n                venusBorrowState[address(vToken)] = VenusMarketState({\n\n                    index: venusInitialIndex,\n\n                    block: safe32(getBlockNumber(), \"block number exceeds 32 bits\")\n\n                });\n\n            }\n\n        }\n\n\n\n        if (currentVenusSpeed != venusSpeed) {\n\n            venusSpeeds[address(vToken)] = venusSpeed;\n\n            emit VenusSpeedUpdated(vToken, venusSpeed);\n\n        }\n\n    }\n\n\n\n    /**\n",
          "message": "Reentrancy in Comptroller.setVenusSpeedInternal (VBep20Harness.sol#5782-5817):\n\tExternal calls:\n\t- borrowIndex = Exp(vToken.borrowIndex()) (VBep20Harness.sol#5786-5787)\n\t- updateVenusSupplyIndex(address(vToken)) (VBep20Harness.sol#5787-5788)\n\t- updateVenusBorrowIndex(address(vToken),borrowIndex) (VBep20Harness.sol#5788-5789)\n\tState variables written after the call(s):\n\t- venusSpeeds (VBep20Harness.sol#5811-5812)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 5273,
          "vulnerability_to_line": 5293,
          "vulnerability_code": "    function transferAllowed(address vToken, address src, address dst, uint transferTokens) external onlyProtocolAllowed returns (uint) {\n\n        // Pausing is a very serious situation - we revert to sound the alarms\n\n        require(!transferGuardianPaused, \"transfer is paused\");\n\n\n\n        // Currently the only consideration is whether or not\n\n        //  the src is allowed to redeem this many tokens\n\n        uint allowed = redeemAllowedInternal(vToken, src, transferTokens);\n\n        if (allowed != uint(Error.NO_ERROR)) {\n\n            return allowed;\n\n        }\n\n\n\n        // Keep the flywheel moving\n\n        updateVenusSupplyIndex(vToken);\n\n        distributeSupplierVenus(vToken, src);\n\n        distributeSupplierVenus(vToken, dst);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
          "message": "Reentrancy in Comptroller.transferAllowed (VBep20Harness.sol#5273-5293):\n\tExternal calls:\n\t- allowed = redeemAllowedInternal(vToken,src,transferTokens) (VBep20Harness.sol#5279-5280)\n\t- updateVenusSupplyIndex(vToken) (VBep20Harness.sol#5285-5286)\n\t- distributeSupplierVenus(vToken,src) (VBep20Harness.sol#5286-5287)\n\t- distributeSupplierVenus(vToken,dst) (VBep20Harness.sol#5287-5289)\n\tState variables written after the call(s):\n\t- releaseStartBlock (VBep20Harness.sol#5287-5289)\n\t- venusAccrued (VBep20Harness.sol#5287-5289)\n\t- venusSupplierIndex (VBep20Harness.sol#5287-5289)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 5843,
          "vulnerability_to_line": 5863,
          "vulnerability_code": "    function updateVenusBorrowIndex(address vToken, Exp memory marketBorrowIndex) internal {\n\n        VenusMarketState storage borrowState = venusBorrowState[vToken];\n\n        uint borrowSpeed = venusSpeeds[vToken];\n\n        uint blockNumber = getBlockNumber();\n\n        uint deltaBlocks = sub_(blockNumber, uint(borrowState.block));\n\n        if (deltaBlocks > 0 && borrowSpeed > 0) {\n\n            uint borrowAmount = div_(VToken(vToken).totalBorrows(), marketBorrowIndex);\n\n            uint venusAccrued = mul_(deltaBlocks, borrowSpeed);\n\n            Double memory ratio = borrowAmount > 0 ? fraction(venusAccrued, borrowAmount) : Double({mantissa: 0});\n\n            Double memory index = add_(Double({mantissa: borrowState.index}), ratio);\n\n            venusBorrowState[vToken] = VenusMarketState({\n\n                index: safe224(index.mantissa, \"new index overflows\"),\n\n                block: safe32(blockNumber, \"block number overflows\")\n\n            });\n\n        } else if (deltaBlocks > 0) {\n\n            borrowState.block = safe32(blockNumber, \"block number overflows\");\n\n        }\n\n    }\n\n\n\n    /**\n",
          "message": "Reentrancy in Comptroller.updateVenusBorrowIndex (VBep20Harness.sol#5843-5863):\n\tExternal calls:\n\t- borrowAmount = div_(VToken(vToken).totalBorrows(),marketBorrowIndex) (VBep20Harness.sol#5849-5850)\n\tState variables written after the call(s):\n\t- venusBorrowState (VBep20Harness.sol#5853-5857)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 5820,
          "vulnerability_to_line": 5840,
          "vulnerability_code": "    function updateVenusSupplyIndex(address vToken) internal {\n\n        VenusMarketState storage supplyState = venusSupplyState[vToken];\n\n        uint supplySpeed = venusSpeeds[vToken];\n\n        uint blockNumber = getBlockNumber();\n\n        uint deltaBlocks = sub_(blockNumber, uint(supplyState.block));\n\n        if (deltaBlocks > 0 && supplySpeed > 0) {\n\n            uint supplyTokens = VToken(vToken).totalSupply();\n\n            uint venusAccrued = mul_(deltaBlocks, supplySpeed);\n\n            Double memory ratio = supplyTokens > 0 ? fraction(venusAccrued, supplyTokens) : Double({mantissa: 0});\n\n            Double memory index = add_(Double({mantissa: supplyState.index}), ratio);\n\n            venusSupplyState[vToken] = VenusMarketState({\n\n                index: safe224(index.mantissa, \"new index overflows\"),\n\n                block: safe32(blockNumber, \"block number overflows\")\n\n            });\n\n        } else if (deltaBlocks > 0) {\n\n            supplyState.block = safe32(blockNumber, \"block number overflows\");\n\n        }\n\n    }\n\n\n\n    /**\n",
          "message": "Reentrancy in Comptroller.updateVenusSupplyIndex (VBep20Harness.sol#5820-5840):\n\tExternal calls:\n\t- supplyTokens = VToken(vToken).totalSupply() (VBep20Harness.sol#5826-5827)\n\tState variables written after the call(s):\n\t- venusSupplyState (VBep20Harness.sol#5830-5834)\n"
        },
        {
          "name": "uninitialized-local",
          "vulnerability_from_line": 2592,
          "vulnerability_to_line": 2594,
          "vulnerability_code": "        uint actualAddAmount;\n\n\n",
          "message": "actualAddAmount in VToken._addReservesFresh (VBep20Harness.sol#2592-2594) is a local variable never initialiazed\n"
        },
        {
          "name": "uninitialized-local",
          "vulnerability_from_line": 2104,
          "vulnerability_to_line": null,
          "vulnerability_code": "        BorrowLocalVars memory vars;\n",
          "message": "vars in VToken.borrowFresh (VBep20Harness.sol#2104) is a local variable never initialiazed\n"
        },
        {
          "name": "uninitialized-local",
          "vulnerability_from_line": 1941,
          "vulnerability_to_line": null,
          "vulnerability_code": "        RedeemLocalVars memory vars;\n",
          "message": "vars in VToken.redeemFresh (VBep20Harness.sol#1941) is a local variable never initialiazed\n"
        },
        {
          "name": "uninitialized-local",
          "vulnerability_from_line": 2213,
          "vulnerability_to_line": null,
          "vulnerability_code": "        RepayBorrowLocalVars memory vars;\n",
          "message": "vars in VToken.repayBorrowFresh (VBep20Harness.sol#2213) is a local variable never initialiazed\n"
        },
        {
          "name": "uninitialized-local",
          "vulnerability_from_line": 1834,
          "vulnerability_to_line": null,
          "vulnerability_code": "        MintLocalVars memory vars;\n",
          "message": "vars in VToken.mintFresh (VBep20Harness.sol#1834) is a local variable never initialiazed\n"
        },
        {
          "name": "uninitialized-local",
          "vulnerability_from_line": 4882,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (; i < len; i++) {\n",
          "message": "i in Comptroller.exitMarket (VBep20Harness.sol#4882) is a local variable never initialiazed\n"
        },
        {
          "name": "uninitialized-local",
          "vulnerability_from_line": 5036,
          "vulnerability_to_line": null,
          "vulnerability_code": "        (Error err, , uint shortfall) = getHypotheticalAccountLiquidityInternal(borrower, VToken(vToken), 0, borrowAmount);\n",
          "message": "err_scope_0 in Comptroller.borrowAllowed (VBep20Harness.sol#5036) is a local variable never initialiazed\n"
        },
        {
          "name": "unused-return",
          "vulnerability_from_line": 2801,
          "vulnerability_to_line": 2816,
          "vulnerability_code": "    function initialize(address underlying_,\n\n                        ComptrollerInterface comptroller_,\n\n                        InterestRateModel interestRateModel_,\n\n                        uint initialExchangeRateMantissa_,\n\n                        string memory name_,\n\n                        string memory symbol_,\n\n                        uint8 decimals_) public {\n\n        // VToken initialize does the bulk of the work\n\n        super.initialize(comptroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_);\n\n\n\n        // Set underlying and sanity check it\n\n        underlying = underlying_;\n\n        EIP20Interface(underlying).totalSupply();\n\n    }\n\n\n",
          "message": "VBep20.initialize (VBep20Harness.sol#2801-2816) does not use the value returned by external calls:\n\t-EIP20Interface(underlying).totalSupply() (VBep20Harness.sol#2813-2814)\n"
        },
        {
          "name": "unused-return",
          "vulnerability_from_line": 3632,
          "vulnerability_to_line": 3640,
          "vulnerability_code": "    function accrueInterest() public returns (uint) {\n\n        // Accumulate DSR interest\n\n        PotLike(potAddress).drip();\n\n\n\n        // Accumulate VToken interest\n\n        return super.accrueInterest();\n\n    }\n\n\n",
          "message": "VDaiDelegate.accrueInterest (VBep20Harness.sol#3632-3640) does not use the value returned by external calls:\n\t-PotLike(potAddress).drip() (VBep20Harness.sol#3634-3636)\n"
        },
        {
          "name": "unused-return",
          "vulnerability_from_line": 3603,
          "vulnerability_to_line": 3625,
          "vulnerability_code": "    function _resignImplementation() public {\n\n        require(msg.sender == admin, \"only the admin may abandon the implementation\");\n\n\n\n        // Transfer all cash out of the DSR - note that this relies on self-transfer\n\n        DaiJoinLike daiJoin = DaiJoinLike(daiJoinAddress);\n\n        PotLike pot = PotLike(potAddress);\n\n        VatLike vat = VatLike(vatAddress);\n\n\n\n        // Accumulate interest\n\n        pot.drip();\n\n\n\n        // Calculate the total amount in the pot, and move it out\n\n        uint pie = pot.pie(address(this));\n\n        pot.exit(pie);\n\n\n\n        // Checks the actual balance of DAI in the vat after the pot exit\n\n        uint bal = vat.dai(address(this));\n\n\n\n        // Remove our whole balance\n\n        daiJoin.exit(address(this), bal / RAY);\n\n    }\n\n\n",
          "message": "VDaiDelegate._resignImplementation (VBep20Harness.sol#3603-3625) does not use the value returned by external calls:\n\t-pot.drip() (VBep20Harness.sol#3612-3614)\n"
        },
        {
          "name": "unused-return",
          "vulnerability_from_line": 3573,
          "vulnerability_to_line": 3600,
          "vulnerability_code": "    function _becomeImplementation(address daiJoinAddress_, address potAddress_) internal {\n\n        // Get dai and vat and sanity check the underlying\n\n        DaiJoinLike daiJoin = DaiJoinLike(daiJoinAddress_);\n\n        PotLike pot = PotLike(potAddress_);\n\n        GemLike dai = daiJoin.dai();\n\n        VatLike vat = daiJoin.vat();\n\n        require(address(dai) == underlying, \"DAI must be the same as underlying\");\n\n\n\n        // Remember the relevant addresses\n\n        daiJoinAddress = daiJoinAddress_;\n\n        potAddress = potAddress_;\n\n        vatAddress = address(vat);\n\n\n\n        // Approve moving our DAI into the vat through daiJoin\n\n        dai.approve(daiJoinAddress, uint(-1));\n\n\n\n        // Approve the pot to transfer our funds within the vat\n\n        vat.hope(potAddress);\n\n        vat.hope(daiJoinAddress);\n\n\n\n        // Accumulate DSR interest -- must do this in order to doTransferIn\n\n        pot.drip();\n\n\n\n        // Transfer all cash in (doTransferIn does this regardless of amount)\n\n        doTransferIn(address(this), 0);\n\n    }\n\n\n",
          "message": "VDaiDelegate._becomeImplementation (VBep20Harness.sol#3573-3600) does not use the value returned by external calls:\n\t-pot.drip() (VBep20Harness.sol#3594-3596)\n"
        },
        {
          "name": "unused-return",
          "vulnerability_from_line": 5622,
          "vulnerability_to_line": 5643,
          "vulnerability_code": "    function _supportMarket(VToken vToken) external returns (uint) {\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SUPPORT_MARKET_OWNER_CHECK);\n\n        }\n\n\n\n        if (markets[address(vToken)].isListed) {\n\n            return fail(Error.MARKET_ALREADY_LISTED, FailureInfo.SUPPORT_MARKET_EXISTS);\n\n        }\n\n\n\n        vToken.isVToken(); // Sanity check to make sure its really a VToken\n\n\n\n        // Note that isVenus is not in active use anymore\n\n        markets[address(vToken)] = Market({isListed: true, isVenus: false, collateralFactorMantissa: 0});\n\n\n\n        _addMarketInternal(vToken);\n\n\n\n        emit MarketListed(vToken);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Comptroller._supportMarket (VBep20Harness.sol#5622-5643) does not use the value returned by external calls:\n\t-vToken.isVToken() (VBep20Harness.sol#5631)\n"
        },
        {
          "name": "unused-return",
          "vulnerability_from_line": 5964,
          "vulnerability_to_line": 5995,
          "vulnerability_code": "    function claimVenus(address[] memory holders, VToken[] memory vTokens, bool borrowers, bool suppliers) public {\n\n        uint j;\n\n        if(address(vaiController) != address(0)) {\n\n            vaiController.updateVenusVAIMintIndex();\n\n        }\n\n        for (j = 0; j < holders.length; j++) {\n\n            distributeVAIMinterVenus(holders[j]);\n\n            venusAccrued[holders[j]] = grantXVSInternal(holders[j], venusAccrued[holders[j]]);\n\n        }\n\n        for (uint i = 0; i < vTokens.length; i++) {\n\n            VToken vToken = vTokens[i];\n\n            require(markets[address(vToken)].isListed, \"not listed market\");\n\n            if (borrowers) {\n\n                Exp memory borrowIndex = Exp({mantissa: vToken.borrowIndex()});\n\n                updateVenusBorrowIndex(address(vToken), borrowIndex);\n\n                for (j = 0; j < holders.length; j++) {\n\n                    distributeBorrowerVenus(address(vToken), holders[j], borrowIndex);\n\n                    venusAccrued[holders[j]] = grantXVSInternal(holders[j], venusAccrued[holders[j]]);\n\n                }\n\n            }\n\n            if (suppliers) {\n\n                updateVenusSupplyIndex(address(vToken));\n\n                for (j = 0; j < holders.length; j++) {\n\n                    distributeSupplierVenus(address(vToken), holders[j]);\n\n                    venusAccrued[holders[j]] = grantXVSInternal(holders[j], venusAccrued[holders[j]]);\n\n                }\n\n            }\n\n        }\n\n    }\n\n\n\n    /**\n",
          "message": "Comptroller.claimVenus (VBep20Harness.sol#5964-5995) does not use the value returned by external calls:\n\t-vaiController.updateVenusVAIMintIndex() (VBep20Harness.sol#5967-5969)\n"
        },
        {
          "name": "unused-return",
          "vulnerability_from_line": 6001,
          "vulnerability_to_line": 6011,
          "vulnerability_code": "    function grantXVSInternal(address user, uint amount) internal returns (uint) {\n\n        XVS xvs = XVS(getXVSAddress());\n\n        uint venusRemaining = xvs.balanceOf(address(this));\n\n        if (amount > 0 && amount <= venusRemaining) {\n\n            xvs.transfer(user, amount);\n\n            return 0;\n\n        }\n\n        return amount;\n\n    }\n\n\n",
          "message": "Comptroller.grantXVSInternal (VBep20Harness.sol#6001-6011) does not use the value returned by external calls:\n\t-xvs.transfer(user,amount) (VBep20Harness.sol#6005-6006)\n"
        },
        {
          "name": "unused-return",
          "vulnerability_from_line": 6100,
          "vulnerability_to_line": 6137,
          "vulnerability_code": "    function releaseToVault() public {\n\n        if(releaseStartBlock == 0 || getBlockNumber() < releaseStartBlock) {\n\n            return;\n\n        }\n\n\n\n        XVS xvs = XVS(getXVSAddress());\n\n\n\n        uint256 xvsBalance = xvs.balanceOf(address(this));\n\n        if(xvsBalance == 0) {\n\n            return;\n\n        }\n\n\n\n\n\n        uint256 actualAmount;\n\n        uint256 deltaBlocks = sub_(getBlockNumber(), releaseStartBlock);\n\n        // releaseAmount = venusVAIVaultRate * deltaBlocks\n\n        uint256 _releaseAmount = mul_(venusVAIVaultRate, deltaBlocks);\n\n\n\n        if (_releaseAmount < minReleaseAmount) {\n\n            return;\n\n        }\n\n\n\n        if (xvsBalance >= _releaseAmount) {\n\n            actualAmount = _releaseAmount;\n\n        } else {\n\n            actualAmount = xvsBalance;\n\n        }\n\n\n\n        releaseStartBlock = getBlockNumber();\n\n\n\n        xvs.transfer(vaiVaultAddress, actualAmount);\n\n        emit DistributedVAIVaultVenus(actualAmount);\n\n\n\n        IVAIVault(vaiVaultAddress).updatePendingRewards();\n\n    }\n\n}\n\n\n",
          "message": "Comptroller.releaseToVault (VBep20Harness.sol#6100-6137) does not use the value returned by external calls:\n\t-xvs.transfer(vaiVaultAddress,actualAmount) (VBep20Harness.sol#6130-6131)\n"
        },
        {
          "name": "shadowing-local",
          "vulnerability_from_line": 1129,
          "vulnerability_to_line": null,
          "vulnerability_code": "        (MathError err, Exp memory fraction) = divScalarByExp(scalar, divisor);\n",
          "message": "Exponential.divScalarByExpTruncate.fraction (local variable @ VBep20Harness.sol#1129) shadows:\n\t- ExponentialNoError.fraction (function @ VBep20Harness.sol#1002-1004)\n"
        },
        {
          "name": "shadowing-local",
          "vulnerability_from_line": 5827,
          "vulnerability_to_line": 5828,
          "vulnerability_code": "            uint venusAccrued = mul_(deltaBlocks, supplySpeed);\n",
          "message": "Comptroller.updateVenusSupplyIndex.venusAccrued (local variable @ VBep20Harness.sol#5827-5828) shadows:\n\t- ComptrollerV1Storage.venusAccrued (state variable @ VBep20Harness.sol#3895-3897)\n"
        },
        {
          "name": "shadowing-local",
          "vulnerability_from_line": 5850,
          "vulnerability_to_line": 5851,
          "vulnerability_code": "            uint venusAccrued = mul_(deltaBlocks, borrowSpeed);\n",
          "message": "Comptroller.updateVenusBorrowIndex.venusAccrued (local variable @ VBep20Harness.sol#5850-5851) shadows:\n\t- ComptrollerV1Storage.venusAccrued (state variable @ VBep20Harness.sol#3895-3897)\n"
        },
        {
          "name": "calls-loop",
          "vulnerability_from_line": 6223,
          "vulnerability_to_line": 6224,
          "vulnerability_code": "                Exp memory assetPrice = Exp({mantissa: oracle.getUnderlyingPrice(vToken)});\n",
          "message": "ComptrollerScenario.refreshVenusSpeeds has external calls inside a loop:\n\t- assetPrice = Exp(oracle.getUnderlyingPrice(vToken_scope_1)) (VBep20Harness.sol#6223-6224)\n"
        },
        {
          "name": "calls-loop",
          "vulnerability_from_line": 6224,
          "vulnerability_to_line": 6225,
          "vulnerability_code": "                Exp memory utility = mul_(assetPrice, vToken.totalBorrows());\n",
          "message": "ComptrollerScenario.refreshVenusSpeeds has external calls inside a loop:\n\t- utility = mul_(assetPrice,vToken_scope_1.totalBorrows()) (VBep20Harness.sol#6224-6225)\n"
        },
        {
          "name": "calls-loop",
          "vulnerability_from_line": 6213,
          "vulnerability_to_line": 6214,
          "vulnerability_code": "            Exp memory borrowIndex = Exp({mantissa: vToken.borrowIndex()});\n",
          "message": "ComptrollerScenario.refreshVenusSpeeds has external calls inside a loop:\n\t- borrowIndex = Exp(vToken.borrowIndex()) (VBep20Harness.sol#6213-6214)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 3573,
          "vulnerability_to_line": 3600,
          "vulnerability_code": "    function _becomeImplementation(address daiJoinAddress_, address potAddress_) internal {\n\n        // Get dai and vat and sanity check the underlying\n\n        DaiJoinLike daiJoin = DaiJoinLike(daiJoinAddress_);\n\n        PotLike pot = PotLike(potAddress_);\n\n        GemLike dai = daiJoin.dai();\n\n        VatLike vat = daiJoin.vat();\n\n        require(address(dai) == underlying, \"DAI must be the same as underlying\");\n\n\n\n        // Remember the relevant addresses\n\n        daiJoinAddress = daiJoinAddress_;\n\n        potAddress = potAddress_;\n\n        vatAddress = address(vat);\n\n\n\n        // Approve moving our DAI into the vat through daiJoin\n\n        dai.approve(daiJoinAddress, uint(-1));\n\n\n\n        // Approve the pot to transfer our funds within the vat\n\n        vat.hope(potAddress);\n\n        vat.hope(daiJoinAddress);\n\n\n\n        // Accumulate DSR interest -- must do this in order to doTransferIn\n\n        pot.drip();\n\n\n\n        // Transfer all cash in (doTransferIn does this regardless of amount)\n\n        doTransferIn(address(this), 0);\n\n    }\n\n\n",
          "message": "Reentrancy in VDaiDelegate._becomeImplementation (VBep20Harness.sol#3573-3600):\n\tExternal calls:\n\t- dai = daiJoin.dai() (VBep20Harness.sol#3577-3578)\n\t- vat = daiJoin.vat() (VBep20Harness.sol#3578-3579)\n\tState variables written after the call(s):\n\t- daiJoinAddress (VBep20Harness.sol#3582-3583)\n\t- potAddress (VBep20Harness.sol#3583-3584)\n\t- vatAddress (VBep20Harness.sol#3584-3586)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 5622,
          "vulnerability_to_line": 5643,
          "vulnerability_code": "    function _supportMarket(VToken vToken) external returns (uint) {\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SUPPORT_MARKET_OWNER_CHECK);\n\n        }\n\n\n\n        if (markets[address(vToken)].isListed) {\n\n            return fail(Error.MARKET_ALREADY_LISTED, FailureInfo.SUPPORT_MARKET_EXISTS);\n\n        }\n\n\n\n        vToken.isVToken(); // Sanity check to make sure its really a VToken\n\n\n\n        // Note that isVenus is not in active use anymore\n\n        markets[address(vToken)] = Market({isListed: true, isVenus: false, collateralFactorMantissa: 0});\n\n\n\n        _addMarketInternal(vToken);\n\n\n\n        emit MarketListed(vToken);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Reentrancy in Comptroller._supportMarket (VBep20Harness.sol#5622-5643):\n\tExternal calls:\n\t- vToken.isVToken() (VBep20Harness.sol#5631)\n\tState variables written after the call(s):\n\t- allMarkets (VBep20Harness.sol#5636-5638)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 2087,
          "vulnerability_to_line": 2150,
          "vulnerability_code": "    function borrowFresh(address payable borrower, uint borrowAmount) internal returns (uint) {\n\n        /* Fail if borrow not allowed */\n\n        uint allowed = comptroller.borrowAllowed(address(this), borrower, borrowAmount);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.BORROW_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.BORROW_FRESHNESS_CHECK);\n\n        }\n\n\n\n        /* Fail gracefully if protocol has insufficient underlying cash */\n\n        if (getCashPrior() < borrowAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.BORROW_CASH_NOT_AVAILABLE);\n\n        }\n\n\n\n        BorrowLocalVars memory vars;\n\n\n\n        /*\n\n         * We calculate the new borrower and total borrow balances, failing on overflow:\n\n         *  accountBorrowsNew = accountBorrows + borrowAmount\n\n         *  totalBorrowsNew = totalBorrows + borrowAmount\n\n         */\n\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We invoke doTransferOut for the borrower and the borrowAmount.\n\n         *  Note: The vToken must handle variations between BEP-20 and BNB underlying.\n\n         *  On success, the vToken borrowAmount less of cash.\n\n         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n\n         */\n\n        doTransferOut(borrower, borrowAmount);\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n\n        accountBorrows[borrower].interestIndex = borrowIndex;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n\n\n        /* We emit a Borrow event */\n\n        emit Borrow(borrower, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n\n\n        /* We call the defense hook */\n\n        comptroller.borrowVerify(address(this), borrower, borrowAmount);\n\n\n\n        return uint(Error.NO_ERROR);\n",
          "message": "Reentrancy in VToken.borrowFresh (VBep20Harness.sol#2087-2150):\n\tExternal calls:\n\t- allowed = comptroller.borrowAllowed(address(this),borrower,borrowAmount) (VBep20Harness.sol#2089)\n\tState variables written after the call(s):\n\t- accountBorrows (VBep20Harness.sol#2139)\n\t- accountBorrows (VBep20Harness.sol#2140)\n\t- totalBorrows (VBep20Harness.sol#2141)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 5964,
          "vulnerability_to_line": 5995,
          "vulnerability_code": "    function claimVenus(address[] memory holders, VToken[] memory vTokens, bool borrowers, bool suppliers) public {\n\n        uint j;\n\n        if(address(vaiController) != address(0)) {\n\n            vaiController.updateVenusVAIMintIndex();\n\n        }\n\n        for (j = 0; j < holders.length; j++) {\n\n            distributeVAIMinterVenus(holders[j]);\n\n            venusAccrued[holders[j]] = grantXVSInternal(holders[j], venusAccrued[holders[j]]);\n\n        }\n\n        for (uint i = 0; i < vTokens.length; i++) {\n\n            VToken vToken = vTokens[i];\n\n            require(markets[address(vToken)].isListed, \"not listed market\");\n\n            if (borrowers) {\n\n                Exp memory borrowIndex = Exp({mantissa: vToken.borrowIndex()});\n\n                updateVenusBorrowIndex(address(vToken), borrowIndex);\n\n                for (j = 0; j < holders.length; j++) {\n\n                    distributeBorrowerVenus(address(vToken), holders[j], borrowIndex);\n\n                    venusAccrued[holders[j]] = grantXVSInternal(holders[j], venusAccrued[holders[j]]);\n\n                }\n\n            }\n\n            if (suppliers) {\n\n                updateVenusSupplyIndex(address(vToken));\n\n                for (j = 0; j < holders.length; j++) {\n\n                    distributeSupplierVenus(address(vToken), holders[j]);\n\n                    venusAccrued[holders[j]] = grantXVSInternal(holders[j], venusAccrued[holders[j]]);\n\n                }\n\n            }\n\n        }\n\n    }\n\n\n\n    /**\n",
          "message": "Reentrancy in Comptroller.claimVenus (VBep20Harness.sol#5964-5995):\n\tExternal calls:\n\t- vaiController.updateVenusVAIMintIndex() (VBep20Harness.sol#5967-5969)\n\t- distributeVAIMinterVenus(holders[j]) (VBep20Harness.sol#5970-5971)\n\tState variables written after the call(s):\n\t- venusAccrued (VBep20Harness.sol#5970-5971)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 5895,
          "vulnerability_to_line": 5916,
          "vulnerability_code": "    function distributeBorrowerVenus(address vToken, address borrower, Exp memory marketBorrowIndex) internal {\n\n        if (address(vaiVaultAddress) != address(0)) {\n\n            releaseToVault();\n\n        }\n\n\n\n        VenusMarketState storage borrowState = venusBorrowState[vToken];\n\n        Double memory borrowIndex = Double({mantissa: borrowState.index});\n\n        Double memory borrowerIndex = Double({mantissa: venusBorrowerIndex[vToken][borrower]});\n\n        venusBorrowerIndex[vToken][borrower] = borrowIndex.mantissa;\n\n\n\n        if (borrowerIndex.mantissa > 0) {\n\n            Double memory deltaIndex = sub_(borrowIndex, borrowerIndex);\n\n            uint borrowerAmount = div_(VToken(vToken).borrowBalanceStored(borrower), marketBorrowIndex);\n\n            uint borrowerDelta = mul_(borrowerAmount, deltaIndex);\n\n            uint borrowerAccrued = add_(venusAccrued[borrower], borrowerDelta);\n\n            venusAccrued[borrower] = borrowerAccrued;\n\n            emit DistributedBorrowerVenus(VToken(vToken), borrower, borrowerDelta, borrowIndex.mantissa);\n\n        }\n\n    }\n\n\n\n    /**\n",
          "message": "Reentrancy in Comptroller.distributeBorrowerVenus (VBep20Harness.sol#5895-5916):\n\tExternal calls:\n\t- releaseToVault() (VBep20Harness.sol#5897-5900)\n\tState variables written after the call(s):\n\t- venusBorrowerIndex (VBep20Harness.sol#5903-5905)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 5895,
          "vulnerability_to_line": 5916,
          "vulnerability_code": "    function distributeBorrowerVenus(address vToken, address borrower, Exp memory marketBorrowIndex) internal {\n\n        if (address(vaiVaultAddress) != address(0)) {\n\n            releaseToVault();\n\n        }\n\n\n\n        VenusMarketState storage borrowState = venusBorrowState[vToken];\n\n        Double memory borrowIndex = Double({mantissa: borrowState.index});\n\n        Double memory borrowerIndex = Double({mantissa: venusBorrowerIndex[vToken][borrower]});\n\n        venusBorrowerIndex[vToken][borrower] = borrowIndex.mantissa;\n\n\n\n        if (borrowerIndex.mantissa > 0) {\n\n            Double memory deltaIndex = sub_(borrowIndex, borrowerIndex);\n\n            uint borrowerAmount = div_(VToken(vToken).borrowBalanceStored(borrower), marketBorrowIndex);\n\n            uint borrowerDelta = mul_(borrowerAmount, deltaIndex);\n\n            uint borrowerAccrued = add_(venusAccrued[borrower], borrowerDelta);\n\n            venusAccrued[borrower] = borrowerAccrued;\n\n            emit DistributedBorrowerVenus(VToken(vToken), borrower, borrowerDelta, borrowIndex.mantissa);\n\n        }\n\n    }\n\n\n\n    /**\n",
          "message": "Reentrancy in Comptroller.distributeBorrowerVenus (VBep20Harness.sol#5895-5916):\n\tExternal calls:\n\t- releaseToVault() (VBep20Harness.sol#5897-5900)\n\t- borrowerAmount = div_(VToken(vToken).borrowBalanceStored(borrower),marketBorrowIndex) (VBep20Harness.sol#5907-5908)\n\tState variables written after the call(s):\n\t- venusAccrued (VBep20Harness.sol#5910-5911)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 5867,
          "vulnerability_to_line": 5890,
          "vulnerability_code": "    function distributeSupplierVenus(address vToken, address supplier) internal {\n\n        if (address(vaiVaultAddress) != address(0)) {\n\n            releaseToVault();\n\n        }\n\n\n\n        VenusMarketState storage supplyState = venusSupplyState[vToken];\n\n        Double memory supplyIndex = Double({mantissa: supplyState.index});\n\n        Double memory supplierIndex = Double({mantissa: venusSupplierIndex[vToken][supplier]});\n\n        venusSupplierIndex[vToken][supplier] = supplyIndex.mantissa;\n\n\n\n        if (supplierIndex.mantissa == 0 && supplyIndex.mantissa > 0) {\n\n            supplierIndex.mantissa = venusInitialIndex;\n\n        }\n\n\n\n        Double memory deltaIndex = sub_(supplyIndex, supplierIndex);\n\n        uint supplierTokens = VToken(vToken).balanceOf(supplier);\n\n        uint supplierDelta = mul_(supplierTokens, deltaIndex);\n\n        uint supplierAccrued = add_(venusAccrued[supplier], supplierDelta);\n\n        venusAccrued[supplier] = supplierAccrued;\n\n        emit DistributedSupplierVenus(VToken(vToken), supplier, supplierDelta, supplyIndex.mantissa);\n\n    }\n\n\n\n    /**\n",
          "message": "Reentrancy in Comptroller.distributeSupplierVenus (VBep20Harness.sol#5867-5890):\n\tExternal calls:\n\t- releaseToVault() (VBep20Harness.sol#5869-5872)\n\tState variables written after the call(s):\n\t- venusSupplierIndex (VBep20Harness.sol#5875-5877)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 5867,
          "vulnerability_to_line": 5890,
          "vulnerability_code": "    function distributeSupplierVenus(address vToken, address supplier) internal {\n\n        if (address(vaiVaultAddress) != address(0)) {\n\n            releaseToVault();\n\n        }\n\n\n\n        VenusMarketState storage supplyState = venusSupplyState[vToken];\n\n        Double memory supplyIndex = Double({mantissa: supplyState.index});\n\n        Double memory supplierIndex = Double({mantissa: venusSupplierIndex[vToken][supplier]});\n\n        venusSupplierIndex[vToken][supplier] = supplyIndex.mantissa;\n\n\n\n        if (supplierIndex.mantissa == 0 && supplyIndex.mantissa > 0) {\n\n            supplierIndex.mantissa = venusInitialIndex;\n\n        }\n\n\n\n        Double memory deltaIndex = sub_(supplyIndex, supplierIndex);\n\n        uint supplierTokens = VToken(vToken).balanceOf(supplier);\n\n        uint supplierDelta = mul_(supplierTokens, deltaIndex);\n\n        uint supplierAccrued = add_(venusAccrued[supplier], supplierDelta);\n\n        venusAccrued[supplier] = supplierAccrued;\n\n        emit DistributedSupplierVenus(VToken(vToken), supplier, supplierDelta, supplyIndex.mantissa);\n\n    }\n\n\n\n    /**\n",
          "message": "Reentrancy in Comptroller.distributeSupplierVenus (VBep20Harness.sol#5867-5890):\n\tExternal calls:\n\t- releaseToVault() (VBep20Harness.sol#5869-5872)\n\t- supplierTokens = VToken(vToken).balanceOf(supplier) (VBep20Harness.sol#5882-5883)\n\tState variables written after the call(s):\n\t- venusAccrued (VBep20Harness.sol#5885-5886)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 5920,
          "vulnerability_to_line": 5939,
          "vulnerability_code": "    function distributeVAIMinterVenus(address vaiMinter) public {\n\n        if (address(vaiVaultAddress) != address(0)) {\n\n            releaseToVault();\n\n        }\n\n\n\n        if (address(vaiController) != address(0)) {\n\n            uint vaiMinterAccrued;\n\n            uint vaiMinterDelta;\n\n            uint vaiMintIndexMantissa;\n\n            uint err;\n\n            (err, vaiMinterAccrued, vaiMinterDelta, vaiMintIndexMantissa) = vaiController.calcDistributeVAIMinterVenus(vaiMinter);\n\n            if (err == uint(Error.NO_ERROR)) {\n\n                venusAccrued[vaiMinter] = vaiMinterAccrued;\n\n                emit DistributedVAIMinterVenus(vaiMinter, vaiMinterDelta, vaiMintIndexMantissa);\n\n            }\n\n        }\n\n    }\n\n\n\n    /**\n",
          "message": "Reentrancy in Comptroller.distributeVAIMinterVenus (VBep20Harness.sol#5920-5939):\n\tExternal calls:\n\t- releaseToVault() (VBep20Harness.sol#5922-5925)\n\t- (err,vaiMinterAccrued,vaiMinterDelta,vaiMintIndexMantissa) = vaiController.calcDistributeVAIMinterVenus(vaiMinter) (VBep20Harness.sol#5930-5931)\n\tState variables written after the call(s):\n\t- venusAccrued (VBep20Harness.sol#5932-5933)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 1351,
          "vulnerability_to_line": 1382,
          "vulnerability_code": "    function initialize(ComptrollerInterface comptroller_,\n\n                        InterestRateModel interestRateModel_,\n\n                        uint initialExchangeRateMantissa_,\n\n                        string memory name_,\n\n                        string memory symbol_,\n\n                        uint8 decimals_) public {\n\n        require(msg.sender == admin, \"only admin may initialize the market\");\n\n        require(accrualBlockNumber == 0 && borrowIndex == 0, \"market may only be initialized once\");\n\n\n\n        // Set initial exchange rate\n\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n\n        require(initialExchangeRateMantissa > 0, \"initial exchange rate must be greater than zero.\");\n\n\n\n        // Set the comptroller\n\n        uint err = _setComptroller(comptroller_);\n\n        require(err == uint(Error.NO_ERROR), \"setting comptroller failed\");\n\n\n\n        // Initialize block number and borrow index (block number mocks depend on comptroller being set)\n\n        accrualBlockNumber = getBlockNumber();\n\n        borrowIndex = mantissaOne;\n\n\n\n        // Set the interest rate model (depends on block number / borrow index)\n\n        err = _setInterestRateModelFresh(interestRateModel_);\n\n        require(err == uint(Error.NO_ERROR), \"setting interest rate model failed\");\n\n\n\n        name = name_;\n\n        symbol = symbol_;\n\n        decimals = decimals_;\n\n\n\n        // The counter starts true to prevent changing it from zero to non-zero (i.e. smaller cost/refund)\n\n        _notEntered = true;\n",
          "message": "Reentrancy in VToken.initialize (VBep20Harness.sol#1351-1382):\n\tExternal calls:\n\t- err = _setComptroller(comptroller_) (VBep20Harness.sol#1365)\n\t- err = _setInterestRateModelFresh(interestRateModel_) (VBep20Harness.sol#1373)\n\tState variables written after the call(s):\n\t- _notEntered (VBep20Harness.sol#1381)\n\t- decimals (VBep20Harness.sol#1378)\n\t- name (VBep20Harness.sol#1376)\n\t- symbol (VBep20Harness.sol#1377)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 2801,
          "vulnerability_to_line": 2816,
          "vulnerability_code": "    function initialize(address underlying_,\n\n                        ComptrollerInterface comptroller_,\n\n                        InterestRateModel interestRateModel_,\n\n                        uint initialExchangeRateMantissa_,\n\n                        string memory name_,\n\n                        string memory symbol_,\n\n                        uint8 decimals_) public {\n\n        // VToken initialize does the bulk of the work\n\n        super.initialize(comptroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_);\n\n\n\n        // Set underlying and sanity check it\n\n        underlying = underlying_;\n\n        EIP20Interface(underlying).totalSupply();\n\n    }\n\n\n",
          "message": "Reentrancy in VBep20.initialize (VBep20Harness.sol#2801-2816):\n\tExternal calls:\n\t- super.initialize(comptroller_,interestRateModel_,initialExchangeRateMantissa_,name_,symbol_,decimals_) (VBep20Harness.sol#2809-2811)\n\tState variables written after the call(s):\n\t- underlying (VBep20Harness.sol#2812-2813)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 1822,
          "vulnerability_to_line": 1886,
          "vulnerability_code": "    function mintFresh(address minter, uint mintAmount) internal returns (uint, uint) {\n\n        /* Fail if mint not allowed */\n\n        uint allowed = comptroller.mintAllowed(address(this), minter, mintAmount);\n\n        if (allowed != 0) {\n\n            return (failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.MINT_COMPTROLLER_REJECTION, allowed), 0);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return (fail(Error.MARKET_NOT_FRESH, FailureInfo.MINT_FRESHNESS_CHECK), 0);\n\n        }\n\n\n\n        MintLocalVars memory vars;\n\n\n\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return (failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr)), 0);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         *  We call `doTransferIn` for the minter and the mintAmount.\n\n         *  Note: The vToken must handle variations between BEP-20 and BNB underlying.\n\n         *  `doTransferIn` reverts if anything goes wrong, since we can't be sure if\n\n         *  side-effects occurred. The function returns the amount actually transferred,\n\n         *  in case of a fee. On success, the vToken holds an additional `actualMintAmount`\n\n         *  of cash.\n\n         */\n\n        vars.actualMintAmount = doTransferIn(minter, mintAmount);\n\n\n\n        /*\n\n         * We get the current exchange rate and calculate the number of vTokens to be minted:\n\n         *  mintTokens = actualMintAmount / exchangeRate\n\n         */\n\n\n\n        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(vars.actualMintAmount, Exp({mantissa: vars.exchangeRateMantissa}));\n\n        require(vars.mathErr == MathError.NO_ERROR, \"MINT_EXCHANGE_CALCULATION_FAILED\");\n\n\n\n        /*\n\n         * We calculate the new total supply of vTokens and minter token balance, checking for overflow:\n\n         *  totalSupplyNew = totalSupply + mintTokens\n\n         *  accountTokensNew = accountTokens[minter] + mintTokens\n\n         */\n\n        (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);\n\n        require(vars.mathErr == MathError.NO_ERROR, \"MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED\");\n\n\n\n        (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);\n\n        require(vars.mathErr == MathError.NO_ERROR, \"MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED\");\n\n\n\n        /* We write previously calculated values into storage */\n\n        totalSupply = vars.totalSupplyNew;\n\n        accountTokens[minter] = vars.accountTokensNew;\n\n\n\n        /* We emit a Mint event, and a Transfer event */\n\n        emit Mint(minter, vars.actualMintAmount, vars.mintTokens);\n\n        emit Transfer(address(this), minter, vars.mintTokens);\n\n\n\n        /* We call the defense hook */\n\n        comptroller.mintVerify(address(this), minter, vars.actualMintAmount, vars.mintTokens);\n\n\n\n        return (uint(Error.NO_ERROR), vars.actualMintAmount);\n",
          "message": "Reentrancy in VToken.mintFresh (VBep20Harness.sol#1822-1886):\n\tExternal calls:\n\t- allowed = comptroller.mintAllowed(address(this),minter,mintAmount) (VBep20Harness.sol#1824)\n\tState variables written after the call(s):\n\t- accountTokens (VBep20Harness.sol#1876)\n\t- totalSupply (VBep20Harness.sol#1875)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 2201,
          "vulnerability_to_line": 2267,
          "vulnerability_code": "    function repayBorrowFresh(address payer, address borrower, uint repayAmount) internal returns (uint, uint) {\n\n        /* Fail if repayBorrow not allowed */\n\n        uint allowed = comptroller.repayBorrowAllowed(address(this), payer, borrower, repayAmount);\n\n        if (allowed != 0) {\n\n            return (failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REPAY_BORROW_COMPTROLLER_REJECTION, allowed), 0);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return (fail(Error.MARKET_NOT_FRESH, FailureInfo.REPAY_BORROW_FRESHNESS_CHECK), 0);\n\n        }\n\n\n\n        RepayBorrowLocalVars memory vars;\n\n\n\n        /* We remember the original borrowerIndex for verification purposes */\n\n        vars.borrowerIndex = accountBorrows[borrower].interestIndex;\n\n\n\n        /* We fetch the amount the borrower owes, with accumulated interest */\n\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return (failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr)), 0);\n\n        }\n\n\n\n        /* If repayAmount == -1, repayAmount = accountBorrows */\n\n        if (repayAmount == uint(-1)) {\n\n            vars.repayAmount = vars.accountBorrows;\n\n        } else {\n\n            vars.repayAmount = repayAmount;\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We call doTransferIn for the payer and the repayAmount\n\n         *  Note: The vToken must handle variations between BEP-20 and BNB underlying.\n\n         *  On success, the vToken holds an additional repayAmount of cash.\n\n         *  doTransferIn reverts if anything goes wrong, since we can't be sure if side effects occurred.\n\n         *   it returns the amount actually transferred, in case of a fee.\n\n         */\n\n        vars.actualRepayAmount = doTransferIn(payer, vars.repayAmount);\n\n\n\n        /*\n\n         * We calculate the new borrower and total borrow balances, failing on underflow:\n\n         *  accountBorrowsNew = accountBorrows - actualRepayAmount\n\n         *  totalBorrowsNew = totalBorrows - actualRepayAmount\n\n         */\n\n        (vars.mathErr, vars.accountBorrowsNew) = subUInt(vars.accountBorrows, vars.actualRepayAmount);\n\n        require(vars.mathErr == MathError.NO_ERROR, \"REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED\");\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = subUInt(totalBorrows, vars.actualRepayAmount);\n\n        require(vars.mathErr == MathError.NO_ERROR, \"REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED\");\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n\n        accountBorrows[borrower].interestIndex = borrowIndex;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n\n\n        /* We emit a RepayBorrow event */\n\n        emit RepayBorrow(payer, borrower, vars.actualRepayAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n\n\n        /* We call the defense hook */\n\n        comptroller.repayBorrowVerify(address(this), payer, borrower, vars.actualRepayAmount, vars.borrowerIndex);\n\n\n\n        return (uint(Error.NO_ERROR), vars.actualRepayAmount);\n",
          "message": "Reentrancy in VToken.repayBorrowFresh (VBep20Harness.sol#2201-2267):\n\tExternal calls:\n\t- allowed = comptroller.repayBorrowAllowed(address(this),payer,borrower,repayAmount) (VBep20Harness.sol#2203)\n\tState variables written after the call(s):\n\t- accountBorrows (VBep20Harness.sol#2256)\n\t- accountBorrows (VBep20Harness.sol#2257)\n\t- totalBorrows (VBep20Harness.sol#2258)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 2396,
          "vulnerability_to_line": 2442,
          "vulnerability_code": "    function seizeInternal(address seizerToken, address liquidator, address borrower, uint seizeTokens) internal returns (uint) {\n\n        /* Fail if seize not allowed */\n\n        uint allowed = comptroller.seizeAllowed(address(this), seizerToken, liquidator, borrower, seizeTokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_SEIZE_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Fail if borrower = liquidator */\n\n        if (borrower == liquidator) {\n\n            return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER);\n\n        }\n\n\n\n        MathError mathErr;\n\n        uint borrowerTokensNew;\n\n        uint liquidatorTokensNew;\n\n\n\n        /*\n\n         * We calculate the new borrower and liquidator token balances, failing on underflow/overflow:\n\n         *  borrowerTokensNew = accountTokens[borrower] - seizeTokens\n\n         *  liquidatorTokensNew = accountTokens[liquidator] + seizeTokens\n\n         */\n\n        (mathErr, borrowerTokensNew) = subUInt(accountTokens[borrower], seizeTokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED, uint(mathErr));\n\n        }\n\n\n\n        (mathErr, liquidatorTokensNew) = addUInt(accountTokens[liquidator], seizeTokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED, uint(mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accountTokens[borrower] = borrowerTokensNew;\n\n        accountTokens[liquidator] = liquidatorTokensNew;\n\n\n\n        /* Emit a Transfer event */\n\n        emit Transfer(borrower, liquidator, seizeTokens);\n\n\n\n        /* We call the defense hook */\n\n        comptroller.seizeVerify(address(this), seizerToken, liquidator, borrower, seizeTokens);\n\n\n\n        return uint(Error.NO_ERROR);\n",
          "message": "Reentrancy in VToken.seizeInternal (VBep20Harness.sol#2396-2442):\n\tExternal calls:\n\t- allowed = comptroller.seizeAllowed(address(this),seizerToken,liquidator,borrower,seizeTokens) (VBep20Harness.sol#2398)\n\tState variables written after the call(s):\n\t- accountTokens (VBep20Harness.sol#2432)\n\t- accountTokens (VBep20Harness.sol#2433)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 1393,
          "vulnerability_to_line": 1452,
          "vulnerability_code": "    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (uint) {\n\n        /* Fail if transfer not allowed */\n\n        uint allowed = comptroller.transferAllowed(address(this), src, dst, tokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.TRANSFER_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Do not allow self-transfers */\n\n        if (src == dst) {\n\n            return fail(Error.BAD_INPUT, FailureInfo.TRANSFER_NOT_ALLOWED);\n\n        }\n\n\n\n        /* Get the allowance, infinite for the account owner */\n\n        uint startingAllowance = 0;\n\n        if (spender == src) {\n\n            startingAllowance = uint(-1);\n\n        } else {\n\n            startingAllowance = transferAllowances[src][spender];\n\n        }\n\n\n\n        /* Do the calculations, checking for {under,over}flow */\n\n        MathError mathErr;\n\n        uint allowanceNew;\n\n        uint srvTokensNew;\n\n        uint dstTokensNew;\n\n\n\n        (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ALLOWED);\n\n        }\n\n\n\n        (mathErr, srvTokensNew) = subUInt(accountTokens[src], tokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ENOUGH);\n\n        }\n\n\n\n        (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_TOO_MUCH);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        accountTokens[src] = srvTokensNew;\n\n        accountTokens[dst] = dstTokensNew;\n\n\n\n        /* Eat some of the allowance (if necessary) */\n\n        if (startingAllowance != uint(-1)) {\n\n            transferAllowances[src][spender] = allowanceNew;\n\n        }\n\n\n\n        /* We emit a Transfer event */\n\n        emit Transfer(src, dst, tokens);\n\n\n\n        comptroller.transferVerify(address(this), src, dst, tokens);\n\n\n\n        return uint(Error.NO_ERROR);\n",
          "message": "Reentrancy in VToken.transferTokens (VBep20Harness.sol#1393-1452):\n\tExternal calls:\n\t- allowed = comptroller.transferAllowed(address(this),src,dst,tokens) (VBep20Harness.sol#1395)\n\tState variables written after the call(s):\n\t- accountTokens (VBep20Harness.sol#1438)\n\t- accountTokens (VBep20Harness.sol#1439)\n\t- transferAllowances (VBep20Harness.sol#1443)\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 2922,
          "vulnerability_to_line": 2949,
          "vulnerability_code": "    function doTransferIn(address from, uint amount) internal returns (uint) {\n\n        EIP20NonStandardInterface token = EIP20NonStandardInterface(underlying);\n\n        uint balanceBefore = EIP20Interface(underlying).balanceOf(address(this));\n\n        token.transferFrom(from, address(this), amount);\n\n\n\n        bool success;\n\n        assembly {\n\n            switch returndatasize()\n\n                case 0 {                       // This is a non-standard BEP-20\n\n                    success := not(0)          // set success to true\n\n                }\n\n                case 32 {                      // This is a compliant BEP-20\n\n                    returndatacopy(0, 0, 32)\n\n                    success := mload(0)        // Set `success = returndata` of external call\n\n                }\n\n                default {                      // This is an excessively non-compliant BEP-20, revert.\n\n                    revert(0, 0)\n\n                }\n\n        }\n\n        require(success, \"TOKEN_TRANSFER_IN_FAILED\");\n\n\n\n        // Calculate the amount that was *actually* transferred\n\n        uint balanceAfter = EIP20Interface(underlying).balanceOf(address(this));\n\n        require(balanceAfter >= balanceBefore, \"TOKEN_TRANSFER_IN_OVERFLOW\");\n\n        return balanceAfter - balanceBefore;   // underflow already checked above, just subtract\n\n    }\n\n\n",
          "message": "VBep20.doTransferIn uses assembly (VBep20Harness.sol#2922-2949)\n\t- VBep20Harness.sol#2928-2941\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 2958,
          "vulnerability_to_line": 2980,
          "vulnerability_code": "    function doTransferOut(address payable to, uint amount) internal {\n\n        EIP20NonStandardInterface token = EIP20NonStandardInterface(underlying);\n\n        token.transfer(to, amount);\n\n\n\n        bool success;\n\n        assembly {\n\n            switch returndatasize()\n\n                case 0 {                      // This is a non-standard BEP-20\n\n                    success := not(0)          // set success to true\n\n                }\n\n                case 32 {                     // This is a complaint BEP-20\n\n                    returndatacopy(0, 0, 32)\n\n                    success := mload(0)        // Set `success = returndata` of external call\n\n                }\n\n                default {                     // This is an excessively non-compliant BEP-20, revert.\n\n                    revert(0, 0)\n\n                }\n\n        }\n\n        require(success, \"TOKEN_TRANSFER_OUT_FAILED\");\n\n    }\n\n}\n\n\n",
          "message": "VBep20.doTransferOut uses assembly (VBep20Harness.sol#2958-2980)\n\t- VBep20Harness.sol#2963-2976\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 3430,
          "vulnerability_to_line": 3440,
          "vulnerability_code": "    function delegateTo(address callee, bytes memory data) internal returns (bytes memory) {\n\n        (bool success, bytes memory returnData) = callee.delegatecall(data);\n\n        assembly {\n\n            if eq(success, 0) {\n\n                revert(add(returnData, 0x20), returndatasize)\n\n            }\n\n        }\n\n        return returnData;\n\n    }\n\n\n",
          "message": "VBep20Delegator.delegateTo uses assembly (VBep20Harness.sol#3430-3440)\n\t- VBep20Harness.sol#3432-3437\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 3457,
          "vulnerability_to_line": 3467,
          "vulnerability_code": "    function delegateToViewImplementation(bytes memory data) public view returns (bytes memory) {\n\n        (bool success, bytes memory returnData) = address(this).staticcall(abi.encodeWithSignature(\"delegateToImplementation(bytes)\", data));\n\n        assembly {\n\n            if eq(success, 0) {\n\n                revert(add(returnData, 0x20), returndatasize)\n\n            }\n\n        }\n\n        return abi.decode(returnData, (bytes));\n\n    }\n\n\n",
          "message": "VBep20Delegator.delegateToViewImplementation uses assembly (VBep20Harness.sol#3457-3467)\n\t- VBep20Harness.sol#3459-3464\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 3471,
          "vulnerability_to_line": 3488,
          "vulnerability_code": "    function () external payable {\n\n        require(msg.value == 0,\"VBep20Delegator:fallback: cannot send value to fallback\");\n\n\n\n        // delegate all other functions to current implementation\n\n        (bool success, ) = implementation.delegatecall(msg.data);\n\n\n\n        assembly {\n\n            let free_mem_ptr := mload(0x40)\n\n            returndatacopy(free_mem_ptr, 0, returndatasize)\n\n\n\n            switch success\n\n            case 0 { revert(free_mem_ptr, returndatasize) }\n\n            default { return(free_mem_ptr, returndatasize) }\n\n        }\n\n    }\n\n}\n\n\n",
          "message": "VBep20Delegator.fallback uses assembly (VBep20Harness.sol#3471-3488)\n\t- VBep20Harness.sol#3477-3485\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 4089,
          "vulnerability_to_line": 4104,
          "vulnerability_code": "    function () external payable {\n\n        // delegate all other functions to current implementation\n\n        (bool success, ) = comptrollerImplementation.delegatecall(msg.data);\n\n\n\n        assembly {\n\n              let free_mem_ptr := mload(0x40)\n\n              returndatacopy(free_mem_ptr, 0, returndatasize)\n\n\n\n              switch success\n\n              case 0 { revert(free_mem_ptr, returndatasize) }\n\n              default { return(free_mem_ptr, returndatasize) }\n\n        }\n\n    }\n\n}\n\n\n",
          "message": "Unitroller.fallback uses assembly (VBep20Harness.sol#4089-4104)\n\t- VBep20Harness.sol#4093-4104\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 4445,
          "vulnerability_to_line": 4452,
          "vulnerability_code": "    function getChainId() internal pure returns (uint) {\n\n        uint256 chainId;\n\n        assembly { chainId := chainid() }\n\n        return chainId;\n\n    }\n\n}\n\n\n",
          "message": "XVS.getChainId uses assembly (VBep20Harness.sol#4445-4452)\n\t- VBep20Harness.sol#4447-4448\n"
        },
        {
          "name": "constable-states",
          "vulnerability_from_line": 3859,
          "vulnerability_to_line": 3860,
          "vulnerability_code": "    bool public _borrowGuardianPaused;\n",
          "message": "ComptrollerV1Storage._borrowGuardianPaused should be constant (VBep20Harness.sol#3859-3860)\nComptrollerV1Storage._mintGuardianPaused should be constant (VBep20Harness.sol#3858-3859)\nComptrollerV1Storage.mintVAIGuardianPaused should be constant (VBep20Harness.sol#3909-3910)\nComptrollerV1Storage.repayVAIGuardianPaused should be constant (VBep20Harness.sol#3910-3912)\nComptrollerV1Storage.seizeGuardianPaused should be constant (VBep20Harness.sol#3861-3862)\nComptrollerV1Storage.transferGuardianPaused should be constant (VBep20Harness.sol#3860-3861)\nComptrollerV1Storage.venusRate should be constant (VBep20Harness.sol#3877-3879)\nVDaiDelegateMakerHarness.totalSupply should be constant (VBep20Harness.sol#6723-6724)\n"
        },
        {
          "name": "pragma",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": "Different versions of Solidity is used in VBep20Harness.sol:\n\t- Version used: ['>=0.5.16', '^0.5.16']\n\t- VBep20Harness.sol#3 declares pragma solidity^0.5.16\n\t- VBep20Harness.sol#97 declares pragma solidity^0.5.16\n\t- VBep20Harness.sol#130 declares pragma solidity^0.5.16\n\t- VBep20Harness.sol#438 declares pragma solidity^0.5.16\n\t- VBep20Harness.sol#723 declares pragma solidity^0.5.16\n\t- VBep20Harness.sol#811 declares pragma solidity^0.5.16\n\t- VBep20Harness.sol#1009 declares pragma solidity^0.5.16\n\t- VBep20Harness.sol#1192 declares pragma solidity^0.5.16\n\t- VBep20Harness.sol#1256 declares pragma solidity^0.5.16\n\t- VBep20Harness.sol#1328 declares pragma solidity^0.5.16\n\t- VBep20Harness.sol#2783-2786 declares pragma solidity^0.5.16\n\t- VBep20Harness.sol#2982-2985 declares pragma solidity^0.5.16\n\t- VBep20Harness.sol#3022-3025 declares pragma solidity^0.5.16\n\t- VBep20Harness.sol#3490-3493 declares pragma solidity^0.5.16\n\t- VBep20Harness.sol#3534-3537 declares pragma solidity^0.5.16\n\t- VBep20Harness.sol#3743-3745 declares pragma solidity^0.5.16\n\t- VBep20Harness.sol#3760-3762 declares pragma solidity^0.5.16\n\t- VBep20Harness.sol#3775-3779 declares pragma solidity^0.5.16\n\t- VBep20Harness.sol#3956-3959 declares pragma solidity^0.5.16\n\t- VBep20Harness.sol#4106-4108 declares pragma solidity^0.5.16\n\t- VBep20Harness.sol#4469-4471 declares pragma solidity>=0.5.16\n\t- VBep20Harness.sol#4519-4521 declares pragma solidity>=0.5.16\n\t- VBep20Harness.sol#4645-4654 declares pragma solidity^0.5.16\n\t- VBep20Harness.sol#6139-6141 declares pragma solidity^0.5.16\n\t- VBep20Harness.sol#6240-6246 declares pragma solidity^0.5.16\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 3418,
          "vulnerability_to_line": 3423,
          "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {\n\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"_setInterestRateModel(address)\", newInterestRateModel));\n\n        return abi.decode(data, (uint));\n\n    }\n\n\n",
          "message": "VBep20Delegator._setInterestRateModel (VBep20Harness.sol#3418-3423) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 372,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint);\n",
          "message": "VTokenInterface._setInterestRateModel (VBep20Harness.sol#372) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 2699,
          "vulnerability_to_line": 2709,
          "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n\n        return _setInterestRateModelFresh(newInterestRateModel);\n\n    }\n\n\n",
          "message": "VToken._setInterestRateModel (VBep20Harness.sol#2699-2709) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 3561,
          "vulnerability_to_line": 3568,
          "vulnerability_code": "    function _becomeImplementation(bytes memory data) public {\n\n        require(msg.sender == admin, \"only the admin may initialize the implementation\");\n\n\n\n        (address daiJoinAddress_, address potAddress_) = abi.decode(data, (address, address));\n\n        return _becomeImplementation(daiJoinAddress_, potAddress_);\n\n    }\n\n\n",
          "message": "VDaiDelegate._becomeImplementation (VBep20Harness.sol#3561-3568) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 428,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _becomeImplementation(bytes memory data) public;\n",
          "message": "VDelegateInterface._becomeImplementation (VBep20Harness.sol#428) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 3507,
          "vulnerability_to_line": 3519,
          "vulnerability_code": "    function _becomeImplementation(bytes memory data) public {\n\n        // Shh -- currently unused\n\n        data;\n\n\n\n        // Shh -- we don't ever want this hook to be marked pure\n\n        if (false) {\n\n            implementation = address(0);\n\n        }\n\n\n\n        require(msg.sender == admin, \"only the admin may call _becomeImplementation\");\n\n    }\n\n\n",
          "message": "VBep20Delegate._becomeImplementation (VBep20Harness.sol#3507-3519) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 433,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _resignImplementation() public;\n",
          "message": "VDelegateInterface._resignImplementation (VBep20Harness.sol#433) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 3522,
          "vulnerability_to_line": 3532,
          "vulnerability_code": "    function _resignImplementation() public {\n\n        // Shh -- we don't ever want this hook to be marked pure\n\n        if (false) {\n\n            implementation = address(0);\n\n        }\n\n\n\n        require(msg.sender == admin, \"only the admin may call _resignImplementation\");\n\n    }\n\n}\n\n\n",
          "message": "VBep20Delegate._resignImplementation (VBep20Harness.sol#3522-3532) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 3603,
          "vulnerability_to_line": 3625,
          "vulnerability_code": "    function _resignImplementation() public {\n\n        require(msg.sender == admin, \"only the admin may abandon the implementation\");\n\n\n\n        // Transfer all cash out of the DSR - note that this relies on self-transfer\n\n        DaiJoinLike daiJoin = DaiJoinLike(daiJoinAddress);\n\n        PotLike pot = PotLike(potAddress);\n\n        VatLike vat = VatLike(vatAddress);\n\n\n\n        // Accumulate interest\n\n        pot.drip();\n\n\n\n        // Calculate the total amount in the pot, and move it out\n\n        uint pie = pot.pie(address(this));\n\n        pot.exit(pie);\n\n\n\n        // Checks the actual balance of DAI in the vat after the pot exit\n\n        uint bal = vat.dai(address(this));\n\n\n\n        // Remove our whole balance\n\n        daiJoin.exit(address(this), bal / RAY);\n\n    }\n\n\n",
          "message": "VDaiDelegate._resignImplementation (VBep20Harness.sol#3603-3625) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 3763,
          "vulnerability_to_line": 3764,
          "vulnerability_code": "    function getVAIAddress() public view returns (address);\n",
          "message": "VAIControllerInterface.getVAIAddress (VBep20Harness.sol#3763-3764) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 3764,
          "vulnerability_to_line": 3765,
          "vulnerability_code": "    function getMintableVAI(address minter) public view returns (uint, uint);\n",
          "message": "VAIControllerInterface.getMintableVAI (VBep20Harness.sol#3764-3765) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 3992,
          "vulnerability_to_line": 4007,
          "vulnerability_code": "    function _setPendingImplementation(address newPendingImplementation) public returns (uint) {\n\n\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_IMPLEMENTATION_OWNER_CHECK);\n\n        }\n\n\n\n        address oldPendingImplementation = pendingComptrollerImplementation;\n\n\n\n        pendingComptrollerImplementation = newPendingImplementation;\n\n\n\n        emit NewPendingImplementation(oldPendingImplementation, pendingComptrollerImplementation);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Unitroller._setPendingImplementation (VBep20Harness.sol#3992-4007) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 4012,
          "vulnerability_to_line": 4033,
          "vulnerability_code": "    function _acceptImplementation() public returns (uint) {\n\n        // Check caller is pendingImplementation and pendingImplementation \u2260 address(0)\n\n        if (msg.sender != pendingComptrollerImplementation || pendingComptrollerImplementation == address(0)) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_PENDING_IMPLEMENTATION_ADDRESS_CHECK);\n\n        }\n\n\n\n        // Save current values for inclusion in log\n\n        address oldImplementation = comptrollerImplementation;\n\n        address oldPendingImplementation = pendingComptrollerImplementation;\n\n\n\n        comptrollerImplementation = pendingComptrollerImplementation;\n\n\n\n        pendingComptrollerImplementation = address(0);\n\n\n\n        emit NewImplementation(oldImplementation, comptrollerImplementation);\n\n        emit NewPendingImplementation(oldPendingImplementation, pendingComptrollerImplementation);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n\n",
          "message": "Unitroller._acceptImplementation (VBep20Harness.sol#4012-4033) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 4039,
          "vulnerability_to_line": 4057,
          "vulnerability_code": "    function _setPendingAdmin(address newPendingAdmin) public returns (uint) {\n\n        // Check caller = admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);\n\n        }\n\n\n\n        // Save current value, if any, for inclusion in log\n\n        address oldPendingAdmin = pendingAdmin;\n\n\n\n        // Store pendingAdmin with value newPendingAdmin\n\n        pendingAdmin = newPendingAdmin;\n\n\n\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\n\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Unitroller._setPendingAdmin (VBep20Harness.sol#4039-4057) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 4062,
          "vulnerability_to_line": 4085,
          "vulnerability_code": "    function _acceptAdmin() public returns (uint) {\n\n        // Check caller is pendingAdmin and pendingAdmin \u2260 address(0)\n\n        if (msg.sender != pendingAdmin || msg.sender == address(0)) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);\n\n        }\n\n\n\n        // Save current values for inclusion in log\n\n        address oldAdmin = admin;\n\n        address oldPendingAdmin = pendingAdmin;\n\n\n\n        // Store admin with value pendingAdmin\n\n        admin = pendingAdmin;\n\n\n\n        // Clear the pending value\n\n        pendingAdmin = address(0);\n\n\n\n        emit NewAdmin(oldAdmin, admin);\n\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
          "message": "Unitroller._acceptAdmin (VBep20Harness.sol#4062-4085) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 4123,
          "vulnerability_to_line": 4129,
          "vulnerability_code": "    function transferOwnership(address newOwner) public onlyOwner {\n\n        owner = newOwner;\n\n        emit OwnershipTransferred(owner, newOwner);\n\n    }\n\n}\n\n\n",
          "message": "Owned.transferOwnership (VBep20Harness.sol#4123-4129) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 4141,
          "vulnerability_to_line": 4147,
          "vulnerability_code": "    function freeze() public onlyOwner {\n\n        isLocked = 1;\n\n\n\n        emit Freezed();\n\n    }\n\n\n",
          "message": "Tokenlock.freeze (VBep20Harness.sol#4141-4147) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 4147,
          "vulnerability_to_line": 4154,
          "vulnerability_code": "    function unfreeze() public onlyOwner {\n\n        isLocked = 0;\n\n\n\n        emit UnFreezed();\n\n    }\n\n}\n\n\n",
          "message": "Tokenlock.unfreeze (VBep20Harness.sol#4147-4154) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 4297,
          "vulnerability_to_line": 4302,
          "vulnerability_code": "    function delegate(address delegatee) public validLock {\n\n        return _delegate(msg.sender, delegatee);\n\n    }\n\n\n\n    /**\n",
          "message": "XVS.delegate (VBep20Harness.sol#4297-4302) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 4310,
          "vulnerability_to_line": 4322,
          "vulnerability_code": "    function delegateBySig(address delegatee, uint nonce, uint expiry, uint8 v, bytes32 r, bytes32 s) public validLock {\n\n        bytes32 domainSeparator = keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), getChainId(), address(this)));\n\n        bytes32 structHash = keccak256(abi.encode(DELEGATION_TYPEHASH, delegatee, nonce, expiry));\n\n        bytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n\n        address signatory = ecrecover(digest, v, r, s);\n\n        require(signatory != address(0), \"XVS::delegateBySig: invalid signature\");\n\n        require(nonce == nonces[signatory]++, \"XVS::delegateBySig: invalid nonce\");\n\n        require(now <= expiry, \"XVS::delegateBySig: signature expired\");\n\n        return _delegate(signatory, delegatee);\n\n    }\n\n\n\n    /**\n",
          "message": "XVS.delegateBySig (VBep20Harness.sol#4310-4322) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 4338,
          "vulnerability_to_line": 4372,
          "vulnerability_code": "    function getPriorVotes(address account, uint blockNumber) public view returns (uint96) {\n\n        require(blockNumber < block.number, \"XVS::getPriorVotes: not yet determined\");\n\n\n\n        uint32 nCheckpoints = numCheckpoints[account];\n\n        if (nCheckpoints == 0) {\n\n            return 0;\n\n        }\n\n\n\n        // First check most recent balance\n\n        if (checkpoints[account][nCheckpoints - 1].fromBlock <= blockNumber) {\n\n            return checkpoints[account][nCheckpoints - 1].votes;\n\n        }\n\n\n\n        // Next check implicit zero balance\n\n        if (checkpoints[account][0].fromBlock > blockNumber) {\n\n            return 0;\n\n        }\n\n\n\n        uint32 lower = 0;\n\n        uint32 upper = nCheckpoints - 1;\n\n        while (upper > lower) {\n\n            uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\n\n            Checkpoint memory cp = checkpoints[account][center];\n\n            if (cp.fromBlock == blockNumber) {\n\n                return cp.votes;\n\n            } else if (cp.fromBlock < blockNumber) {\n\n                lower = center;\n\n            } else {\n\n                upper = center - 1;\n\n            }\n\n        }\n\n        return checkpoints[account][lower].votes;\n\n    }\n\n\n",
          "message": "XVS.getPriorVotes (VBep20Harness.sol#4338-4372) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 5338,
          "vulnerability_to_line": 5345,
          "vulnerability_code": "    function getAccountLiquidity(address account) public view returns (uint, uint, uint) {\n\n        (Error err, uint liquidity, uint shortfall) = getHypotheticalAccountLiquidityInternal(account, VToken(0), 0, 0);\n\n\n\n        return (uint(err), liquidity, shortfall);\n\n    }\n\n\n\n    /**\n",
          "message": "Comptroller.getAccountLiquidity (VBep20Harness.sol#5338-5345) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 5354,
          "vulnerability_to_line": 5364,
          "vulnerability_code": "    function getHypotheticalAccountLiquidity(\n\n        address account,\n\n        address vTokenModify,\n\n        uint redeemTokens,\n\n        uint borrowAmount) public view returns (uint, uint, uint) {\n\n        (Error err, uint liquidity, uint shortfall) = getHypotheticalAccountLiquidityInternal(account, VToken(vTokenModify), redeemTokens, borrowAmount);\n\n        return (uint(err), liquidity, shortfall);\n\n    }\n\n\n\n    /**\n",
          "message": "Comptroller.getHypotheticalAccountLiquidity (VBep20Harness.sol#5354-5364) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 5515,
          "vulnerability_to_line": 5534,
          "vulnerability_code": "    function _setPriceOracle(PriceOracle newOracle) public returns (uint) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PRICE_ORACLE_OWNER_CHECK);\n\n        }\n\n\n\n        // Track the old oracle for the comptroller\n\n        PriceOracle oldOracle = oracle;\n\n\n\n        // Set comptroller's oracle to newOracle\n\n        oracle = newOracle;\n\n\n\n        // Emit NewPriceOracle(oldOracle, newOracle)\n\n        emit NewPriceOracle(oldOracle, newOracle);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
          "message": "Comptroller._setPriceOracle (VBep20Harness.sol#5515-5534) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 5655,
          "vulnerability_to_line": 5673,
          "vulnerability_code": "    function _setPauseGuardian(address newPauseGuardian) public returns (uint) {\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PAUSE_GUARDIAN_OWNER_CHECK);\n\n        }\n\n\n\n        // Save current value for inclusion in log\n\n        address oldPauseGuardian = pauseGuardian;\n\n\n\n        // Store pauseGuardian with value newPauseGuardian\n\n        pauseGuardian = newPauseGuardian;\n\n\n\n        // Emit NewPauseGuardian(OldPauseGuardian, NewPauseGuardian)\n\n        emit NewPauseGuardian(oldPauseGuardian, newPauseGuardian);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
          "message": "Comptroller._setPauseGuardian (VBep20Harness.sol#5655-5673) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 5710,
          "vulnerability_to_line": 5717,
          "vulnerability_code": "    function _setProtocolPaused(bool state) public validPauseState(state) returns(bool) {\n\n        protocolPaused = state;\n\n        emit ActionProtocolPaused(state);\n\n        return state;\n\n    }\n\n\n\n    /**\n",
          "message": "Comptroller._setProtocolPaused (VBep20Harness.sol#5710-5717) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 5768,
          "vulnerability_to_line": 5774,
          "vulnerability_code": "    function _become(Unitroller unitroller) public {\n\n        require(msg.sender == unitroller.admin(), \"only unitroller admin can\");\n\n        require(unitroller._acceptImplementation() == 0, \"not authorized\");\n\n    }\n\n\n\n    /**\n",
          "message": "Comptroller._become (VBep20Harness.sol#5768-5774) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 5942,
          "vulnerability_to_line": 5947,
          "vulnerability_code": "    function claimVenus(address holder) public {\n\n        return claimVenus(holder, allMarkets);\n\n    }\n\n\n\n    /**\n",
          "message": "Comptroller.claimVenus (VBep20Harness.sol#5942-5947) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 6017,
          "vulnerability_to_line": 6024,
          "vulnerability_code": "    function _setVenusVAIRate(uint venusVAIRate_) public onlyAdmin {\n\n        uint oldVAIRate = venusVAIRate;\n\n        venusVAIRate = venusVAIRate_;\n\n        emit NewVenusVAIRate(oldVAIRate, venusVAIRate_);\n\n    }\n\n\n\n    /**\n",
          "message": "Comptroller._setVenusVAIRate (VBep20Harness.sol#6017-6024) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 6027,
          "vulnerability_to_line": 6034,
          "vulnerability_code": "    function _setVenusVAIVaultRate(uint venusVAIVaultRate_) public onlyAdmin {\n\n        uint oldVenusVAIVaultRate = venusVAIVaultRate;\n\n        venusVAIVaultRate = venusVAIVaultRate_;\n\n        emit NewVenusVAIVaultRate(oldVenusVAIVaultRate, venusVAIVaultRate_);\n\n    }\n\n\n\n    /**\n",
          "message": "Comptroller._setVenusVAIVaultRate (VBep20Harness.sol#6027-6034) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 6039,
          "vulnerability_to_line": 6047,
          "vulnerability_code": "    function _setVAIVaultInfo(address vault_, uint256 releaseStartBlock_, uint256 minReleaseAmount_) public onlyAdmin {\n\n        vaiVaultAddress = vault_;\n\n        releaseStartBlock = releaseStartBlock_;\n\n        minReleaseAmount = minReleaseAmount_;\n\n        emit NewVAIVaultInfo(vault_, releaseStartBlock_, minReleaseAmount_);\n\n    }\n\n\n\n    /**\n",
          "message": "Comptroller._setVAIVaultInfo (VBep20Harness.sol#6039-6047) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 6051,
          "vulnerability_to_line": 6057,
          "vulnerability_code": "    function _setVenusSpeed(VToken vToken, uint venusSpeed) public {\n\n        require(adminOrInitializing(), \"only admin can set venus speed\");\n\n        setVenusSpeedInternal(vToken, venusSpeed);\n\n    }\n\n\n\n    /**\n",
          "message": "Comptroller._setVenusSpeed (VBep20Harness.sol#6051-6057) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 6061,
          "vulnerability_to_line": 6065,
          "vulnerability_code": "    function getAllMarkets() public view returns (VToken[] memory) {\n\n        return allMarkets;\n\n    }\n\n\n",
          "message": "Comptroller.getAllMarkets (VBep20Harness.sol#6061-6065) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 6148,
          "vulnerability_to_line": 6152,
          "vulnerability_code": "    function setXVSAddress(address xvsAddress_) public {\n\n        xvsAddress = xvsAddress_;\n\n    }\n\n\n",
          "message": "ComptrollerScenario.setXVSAddress (VBep20Harness.sol#6148-6152) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 6156,
          "vulnerability_to_line": 6160,
          "vulnerability_code": "    function setVAIAddress(address vaiAddress_) public {\n\n        vaiAddress = vaiAddress_;\n\n    }\n\n\n",
          "message": "ComptrollerScenario.setVAIAddress (VBep20Harness.sol#6156-6160) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 6160,
          "vulnerability_to_line": 6164,
          "vulnerability_code": "    function getVAIAddress() public view returns (address) {\n\n        return vaiAddress;\n\n    }\n\n\n",
          "message": "ComptrollerScenario.getVAIAddress (VBep20Harness.sol#6160-6164) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 6164,
          "vulnerability_to_line": 6168,
          "vulnerability_code": "    function membershipLength(VToken vToken) public view returns (uint) {\n\n        return accountAssets[address(vToken)].length;\n\n    }\n\n\n",
          "message": "ComptrollerScenario.membershipLength (VBep20Harness.sol#6164-6168) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 6168,
          "vulnerability_to_line": 6174,
          "vulnerability_code": "    function fastForward(uint blocks) public returns (uint) {\n\n        blockNumber += blocks;\n\n\n\n        return blockNumber;\n\n    }\n\n\n",
          "message": "ComptrollerScenario.fastForward (VBep20Harness.sol#6168-6174) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 6174,
          "vulnerability_to_line": 6178,
          "vulnerability_code": "    function setBlockNumber(uint number) public {\n\n        blockNumber = number;\n\n    }\n\n\n",
          "message": "ComptrollerScenario.setBlockNumber (VBep20Harness.sol#6174-6178) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 6182,
          "vulnerability_to_line": 6201,
          "vulnerability_code": "    function getVenusMarkets() public view returns (address[] memory) {\n\n        uint m = allMarkets.length;\n\n        uint n = 0;\n\n        for (uint i = 0; i < m; i++) {\n\n            if (markets[address(allMarkets[i])].isVenus) {\n\n                n++;\n\n            }\n\n        }\n\n\n\n        address[] memory venusMarkets = new address[](n);\n\n        uint k = 0;\n\n        for (uint i = 0; i < m; i++) {\n\n            if (markets[address(allMarkets[i])].isVenus) {\n\n                venusMarkets[k++] = address(allMarkets[i]);\n\n            }\n\n        }\n\n        return venusMarkets;\n\n    }\n\n\n",
          "message": "ComptrollerScenario.getVenusMarkets (VBep20Harness.sol#6182-6201) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 6201,
          "vulnerability_to_line": 6206,
          "vulnerability_code": "    function unlist(VToken vToken) public {\n\n        markets[address(vToken)].isListed = false;\n\n    }\n\n\n\n    /**\n",
          "message": "ComptrollerScenario.unlist (VBep20Harness.sol#6201-6206) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 6208,
          "vulnerability_to_line": 6238,
          "vulnerability_code": "    function refreshVenusSpeeds() public {\n\n        VToken[] memory allMarkets_ = allMarkets;\n\n\n\n        for (uint i = 0; i < allMarkets_.length; i++) {\n\n            VToken vToken = allMarkets_[i];\n\n            Exp memory borrowIndex = Exp({mantissa: vToken.borrowIndex()});\n\n            updateVenusSupplyIndex(address(vToken));\n\n            updateVenusBorrowIndex(address(vToken), borrowIndex);\n\n        }\n\n\n\n        Exp memory totalUtility = Exp({mantissa: 0});\n\n        Exp[] memory utilities = new Exp[](allMarkets_.length);\n\n        for (uint i = 0; i < allMarkets_.length; i++) {\n\n            VToken vToken = allMarkets_[i];\n\n            if (venusSpeeds[address(vToken)] > 0) {\n\n                Exp memory assetPrice = Exp({mantissa: oracle.getUnderlyingPrice(vToken)});\n\n                Exp memory utility = mul_(assetPrice, vToken.totalBorrows());\n\n                utilities[i] = utility;\n\n                totalUtility = add_(totalUtility, utility);\n\n            }\n\n        }\n\n\n\n        for (uint i = 0; i < allMarkets_.length; i++) {\n\n            VToken vToken = allMarkets[i];\n\n            uint newSpeed = totalUtility.mantissa > 0 ? mul_(venusRate, div_(utilities[i], totalUtility)) : 0;\n\n            setVenusSpeedInternal(vToken, newSpeed);\n\n        }\n\n    }\n\n}\n\n\n",
          "message": "ComptrollerScenario.refreshVenusSpeeds (VBep20Harness.sol#6208-6238) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 6287,
          "vulnerability_to_line": 6291,
          "vulnerability_code": "    function getBorrowRateMaxMantissa() public pure returns (uint) {\n\n        return borrowRateMaxMantissa;\n\n    }\n\n\n",
          "message": "VBep20Harness.getBorrowRateMaxMantissa (VBep20Harness.sol#6287-6291) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 6291,
          "vulnerability_to_line": 6295,
          "vulnerability_code": "    function harnessSetAccrualBlockNumber(uint _accrualblockNumber) public {\n\n        accrualBlockNumber = _accrualblockNumber;\n\n    }\n\n\n",
          "message": "VBep20Harness.harnessSetAccrualBlockNumber (VBep20Harness.sol#6291-6295) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 6295,
          "vulnerability_to_line": 6299,
          "vulnerability_code": "    function harnessSetBlockNumber(uint newBlockNumber) public {\n\n        blockNumber = newBlockNumber;\n\n    }\n\n\n",
          "message": "VBep20Harness.harnessSetBlockNumber (VBep20Harness.sol#6295-6299) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 6299,
          "vulnerability_to_line": 6303,
          "vulnerability_code": "    function harnessFastForward(uint blocks) public {\n\n        blockNumber += blocks;\n\n    }\n\n\n",
          "message": "VBep20Harness.harnessFastForward (VBep20Harness.sol#6299-6303) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 6307,
          "vulnerability_to_line": 6311,
          "vulnerability_code": "    function harnessSetTotalSupply(uint totalSupply_) public {\n\n        totalSupply = totalSupply_;\n\n    }\n\n\n",
          "message": "VBep20Harness.harnessSetTotalSupply (VBep20Harness.sol#6307-6311) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 6311,
          "vulnerability_to_line": 6315,
          "vulnerability_code": "    function harnessSetTotalBorrows(uint totalBorrows_) public {\n\n        totalBorrows = totalBorrows_;\n\n    }\n\n\n",
          "message": "VBep20Harness.harnessSetTotalBorrows (VBep20Harness.sol#6311-6315) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 6315,
          "vulnerability_to_line": 6319,
          "vulnerability_code": "    function harnessSetTotalReserves(uint totalReserves_) public {\n\n        totalReserves = totalReserves_;\n\n    }\n\n\n",
          "message": "VBep20Harness.harnessSetTotalReserves (VBep20Harness.sol#6315-6319) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 6319,
          "vulnerability_to_line": 6325,
          "vulnerability_code": "    function harnessExchangeRateDetails(uint totalSupply_, uint totalBorrows_, uint totalReserves_) public {\n\n        totalSupply = totalSupply_;\n\n        totalBorrows = totalBorrows_;\n\n        totalReserves = totalReserves_;\n\n    }\n\n\n",
          "message": "VBep20Harness.harnessExchangeRateDetails (VBep20Harness.sol#6319-6325) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 6325,
          "vulnerability_to_line": 6330,
          "vulnerability_code": "    function harnessSetExchangeRate(uint exchangeRate) public {\n\n        harnessExchangeRate = exchangeRate;\n\n        harnessExchangeRateStored = true;\n\n    }\n\n\n",
          "message": "VBep20Harness.harnessSetExchangeRate (VBep20Harness.sol#6325-6330) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 6330,
          "vulnerability_to_line": 6334,
          "vulnerability_code": "    function harnessSetFailTransferToAddress(address _to, bool _fail) public {\n\n        failTransferToAddresses[_to] = _fail;\n\n    }\n\n\n",
          "message": "VBep20Harness.harnessSetFailTransferToAddress (VBep20Harness.sol#6330-6334) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 6334,
          "vulnerability_to_line": 6339,
          "vulnerability_code": "    function harnessMintFresh(address account, uint mintAmount) public returns (uint) {\n\n        (uint err,) = super.mintFresh(account, mintAmount);\n\n        return err;\n\n    }\n\n\n",
          "message": "VBep20Harness.harnessMintFresh (VBep20Harness.sol#6334-6339) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 6339,
          "vulnerability_to_line": 6343,
          "vulnerability_code": "    function harnessRedeemFresh(address payable account, uint vTokenAmount, uint underlyingAmount) public returns (uint) {\n\n        return super.redeemFresh(account, vTokenAmount, underlyingAmount);\n\n    }\n\n\n",
          "message": "VBep20Harness.harnessRedeemFresh (VBep20Harness.sol#6339-6343) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 6343,
          "vulnerability_to_line": 6348,
          "vulnerability_code": "    function harnessAccountBorrows(address account) public view returns (uint principal, uint interestIndex) {\n\n        BorrowSnapshot memory snapshot = accountBorrows[account];\n\n        return (snapshot.principal, snapshot.interestIndex);\n\n    }\n\n\n",
          "message": "VBep20Harness.harnessAccountBorrows (VBep20Harness.sol#6343-6348) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 6348,
          "vulnerability_to_line": 6352,
          "vulnerability_code": "    function harnessSetAccountBorrows(address account, uint principal, uint interestIndex) public {\n\n        accountBorrows[account] = BorrowSnapshot({principal: principal, interestIndex: interestIndex});\n\n    }\n\n\n",
          "message": "VBep20Harness.harnessSetAccountBorrows (VBep20Harness.sol#6348-6352) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 6352,
          "vulnerability_to_line": 6356,
          "vulnerability_code": "    function harnessSetBorrowIndex(uint borrowIndex_) public {\n\n        borrowIndex = borrowIndex_;\n\n    }\n\n\n",
          "message": "VBep20Harness.harnessSetBorrowIndex (VBep20Harness.sol#6352-6356) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 6356,
          "vulnerability_to_line": 6360,
          "vulnerability_code": "    function harnessBorrowFresh(address payable account, uint borrowAmount) public returns (uint) {\n\n        return borrowFresh(account, borrowAmount);\n\n    }\n\n\n",
          "message": "VBep20Harness.harnessBorrowFresh (VBep20Harness.sol#6356-6360) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 6360,
          "vulnerability_to_line": 6365,
          "vulnerability_code": "    function harnessRepayBorrowFresh(address payer, address account, uint repayAmount) public returns (uint) {\n\n        (uint err,) = repayBorrowFresh(payer, account, repayAmount);\n\n        return err;\n\n    }\n\n\n",
          "message": "VBep20Harness.harnessRepayBorrowFresh (VBep20Harness.sol#6360-6365) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 6365,
          "vulnerability_to_line": 6370,
          "vulnerability_code": "    function harnessLiquidateBorrowFresh(address liquidator, address borrower, uint repayAmount, VToken vTokenCollateral) public returns (uint) {\n\n        (uint err,) = liquidateBorrowFresh(liquidator, borrower, repayAmount, vTokenCollateral);\n\n        return err;\n\n    }\n\n\n",
          "message": "VBep20Harness.harnessLiquidateBorrowFresh (VBep20Harness.sol#6365-6370) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 6370,
          "vulnerability_to_line": 6374,
          "vulnerability_code": "    function harnessReduceReservesFresh(uint amount) public returns (uint) {\n\n        return _reduceReservesFresh(amount);\n\n    }\n\n\n",
          "message": "VBep20Harness.harnessReduceReservesFresh (VBep20Harness.sol#6370-6374) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 6374,
          "vulnerability_to_line": 6378,
          "vulnerability_code": "    function harnessSetReserveFactorFresh(uint newReserveFactorMantissa) public returns (uint) {\n\n        return _setReserveFactorFresh(newReserveFactorMantissa);\n\n    }\n\n\n",
          "message": "VBep20Harness.harnessSetReserveFactorFresh (VBep20Harness.sol#6374-6378) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 6378,
          "vulnerability_to_line": 6382,
          "vulnerability_code": "    function harnessSetInterestRateModelFresh(InterestRateModel newInterestRateModel) public returns (uint) {\n\n        return _setInterestRateModelFresh(newInterestRateModel);\n\n    }\n\n\n",
          "message": "VBep20Harness.harnessSetInterestRateModelFresh (VBep20Harness.sol#6378-6382) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 6382,
          "vulnerability_to_line": 6386,
          "vulnerability_code": "    function harnessSetInterestRateModel(address newInterestRateModelAddress) public {\n\n        interestRateModel = InterestRateModel(newInterestRateModelAddress);\n\n    }\n\n\n",
          "message": "VBep20Harness.harnessSetInterestRateModel (VBep20Harness.sol#6382-6386) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 6386,
          "vulnerability_to_line": 6391,
          "vulnerability_code": "    function harnessCallBorrowAllowed(uint amount) public returns (uint) {\n\n        return comptroller.borrowAllowed(address(this), msg.sender, amount);\n\n    }\n\n}\n\n\n",
          "message": "VBep20Harness.harnessCallBorrowAllowed (VBep20Harness.sol#6386-6391) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 6410,
          "vulnerability_to_line": 6414,
          "vulnerability_code": "    function setTotalBorrows(uint totalBorrows_) public {\n\n        totalBorrows = totalBorrows_;\n\n    }\n\n\n",
          "message": "VBep20Scenario.setTotalBorrows (VBep20Harness.sol#6410-6414) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 6414,
          "vulnerability_to_line": 6418,
          "vulnerability_code": "    function setTotalReserves(uint totalReserves_) public {\n\n        totalReserves = totalReserves_;\n\n    }\n\n\n",
          "message": "VBep20Scenario.setTotalReserves (VBep20Harness.sol#6414-6418) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 6443,
          "vulnerability_to_line": 6448,
          "vulnerability_code": "    function evilSeize(VToken treasure, address liquidator, address borrower, uint seizeTokens) public returns (uint) {\n\n        return treasure.seize(liquidator, borrower, seizeTokens);\n\n    }\n\n}\n\n\n",
          "message": "VEvil.evilSeize (VBep20Harness.sol#6443-6448) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 6471,
          "vulnerability_to_line": 6475,
          "vulnerability_code": "    function setTotalBorrows(uint totalBorrows_) public {\n\n        totalBorrows = totalBorrows_;\n\n    }\n\n\n",
          "message": "VBep20DelegatorScenario.setTotalBorrows (VBep20Harness.sol#6471-6475) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 6475,
          "vulnerability_to_line": 6480,
          "vulnerability_code": "    function setTotalReserves(uint totalReserves_) public {\n\n        totalReserves = totalReserves_;\n\n    }\n\n}\n\n\n",
          "message": "VBep20DelegatorScenario.setTotalReserves (VBep20Harness.sol#6475-6480) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 6506,
          "vulnerability_to_line": 6510,
          "vulnerability_code": "    function getBorrowRateMaxMantissa() public pure returns (uint) {\n\n        return borrowRateMaxMantissa;\n\n    }\n\n\n",
          "message": "VBep20DelegateHarness.getBorrowRateMaxMantissa (VBep20Harness.sol#6506-6510) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 6510,
          "vulnerability_to_line": 6514,
          "vulnerability_code": "    function harnessSetBlockNumber(uint newBlockNumber) public {\n\n        blockNumber = newBlockNumber;\n\n    }\n\n\n",
          "message": "VBep20DelegateHarness.harnessSetBlockNumber (VBep20Harness.sol#6510-6514) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 6514,
          "vulnerability_to_line": 6518,
          "vulnerability_code": "    function harnessFastForward(uint blocks) public {\n\n        blockNumber += blocks;\n\n    }\n\n\n",
          "message": "VBep20DelegateHarness.harnessFastForward (VBep20Harness.sol#6514-6518) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 6522,
          "vulnerability_to_line": 6526,
          "vulnerability_code": "    function harnessSetAccrualBlockNumber(uint _accrualblockNumber) public {\n\n        accrualBlockNumber = _accrualblockNumber;\n\n    }\n\n\n",
          "message": "VBep20DelegateHarness.harnessSetAccrualBlockNumber (VBep20Harness.sol#6522-6526) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 6526,
          "vulnerability_to_line": 6530,
          "vulnerability_code": "    function harnessSetTotalSupply(uint totalSupply_) public {\n\n        totalSupply = totalSupply_;\n\n    }\n\n\n",
          "message": "VBep20DelegateHarness.harnessSetTotalSupply (VBep20Harness.sol#6526-6530) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 6530,
          "vulnerability_to_line": 6534,
          "vulnerability_code": "    function harnessSetTotalBorrows(uint totalBorrows_) public {\n\n        totalBorrows = totalBorrows_;\n\n    }\n\n\n",
          "message": "VBep20DelegateHarness.harnessSetTotalBorrows (VBep20Harness.sol#6530-6534) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 6534,
          "vulnerability_to_line": 6538,
          "vulnerability_code": "    function harnessIncrementTotalBorrows(uint addtlBorrow_) public {\n\n        totalBorrows = totalBorrows + addtlBorrow_;\n\n    }\n\n\n",
          "message": "VBep20DelegateHarness.harnessIncrementTotalBorrows (VBep20Harness.sol#6534-6538) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 6538,
          "vulnerability_to_line": 6542,
          "vulnerability_code": "    function harnessSetTotalReserves(uint totalReserves_) public {\n\n        totalReserves = totalReserves_;\n\n    }\n\n\n",
          "message": "VBep20DelegateHarness.harnessSetTotalReserves (VBep20Harness.sol#6538-6542) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 6542,
          "vulnerability_to_line": 6548,
          "vulnerability_code": "    function harnessExchangeRateDetails(uint totalSupply_, uint totalBorrows_, uint totalReserves_) public {\n\n        totalSupply = totalSupply_;\n\n        totalBorrows = totalBorrows_;\n\n        totalReserves = totalReserves_;\n\n    }\n\n\n",
          "message": "VBep20DelegateHarness.harnessExchangeRateDetails (VBep20Harness.sol#6542-6548) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 6548,
          "vulnerability_to_line": 6553,
          "vulnerability_code": "    function harnessSetExchangeRate(uint exchangeRate) public {\n\n        harnessExchangeRate = exchangeRate;\n\n        harnessExchangeRateStored = true;\n\n    }\n\n\n",
          "message": "VBep20DelegateHarness.harnessSetExchangeRate (VBep20Harness.sol#6548-6553) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 6553,
          "vulnerability_to_line": 6557,
          "vulnerability_code": "    function harnessSetFailTransferToAddress(address _to, bool _fail) public {\n\n        failTransferToAddresses[_to] = _fail;\n\n    }\n\n\n",
          "message": "VBep20DelegateHarness.harnessSetFailTransferToAddress (VBep20Harness.sol#6553-6557) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 6557,
          "vulnerability_to_line": 6562,
          "vulnerability_code": "    function harnessMintFresh(address account, uint mintAmount) public returns (uint) {\n\n        (uint err,) = super.mintFresh(account, mintAmount);\n\n        return err;\n\n    }\n\n\n",
          "message": "VBep20DelegateHarness.harnessMintFresh (VBep20Harness.sol#6557-6562) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 6562,
          "vulnerability_to_line": 6566,
          "vulnerability_code": "    function harnessRedeemFresh(address payable account, uint vTokenAmount, uint underlyingAmount) public returns (uint) {\n\n        return super.redeemFresh(account, vTokenAmount, underlyingAmount);\n\n    }\n\n\n",
          "message": "VBep20DelegateHarness.harnessRedeemFresh (VBep20Harness.sol#6562-6566) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 6566,
          "vulnerability_to_line": 6571,
          "vulnerability_code": "    function harnessAccountBorrows(address account) public view returns (uint principal, uint interestIndex) {\n\n        BorrowSnapshot memory snapshot = accountBorrows[account];\n\n        return (snapshot.principal, snapshot.interestIndex);\n\n    }\n\n\n",
          "message": "VBep20DelegateHarness.harnessAccountBorrows (VBep20Harness.sol#6566-6571) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 6571,
          "vulnerability_to_line": 6575,
          "vulnerability_code": "    function harnessSetAccountBorrows(address account, uint principal, uint interestIndex) public {\n\n        accountBorrows[account] = BorrowSnapshot({principal: principal, interestIndex: interestIndex});\n\n    }\n\n\n",
          "message": "VBep20DelegateHarness.harnessSetAccountBorrows (VBep20Harness.sol#6571-6575) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 6575,
          "vulnerability_to_line": 6579,
          "vulnerability_code": "    function harnessSetBorrowIndex(uint borrowIndex_) public {\n\n        borrowIndex = borrowIndex_;\n\n    }\n\n\n",
          "message": "VBep20DelegateHarness.harnessSetBorrowIndex (VBep20Harness.sol#6575-6579) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 6579,
          "vulnerability_to_line": 6583,
          "vulnerability_code": "    function harnessBorrowFresh(address payable account, uint borrowAmount) public returns (uint) {\n\n        return borrowFresh(account, borrowAmount);\n\n    }\n\n\n",
          "message": "VBep20DelegateHarness.harnessBorrowFresh (VBep20Harness.sol#6579-6583) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 6583,
          "vulnerability_to_line": 6588,
          "vulnerability_code": "    function harnessRepayBorrowFresh(address payer, address account, uint repayAmount) public returns (uint) {\n\n        (uint err,) = repayBorrowFresh(payer, account, repayAmount);\n\n        return err;\n\n    }\n\n\n",
          "message": "VBep20DelegateHarness.harnessRepayBorrowFresh (VBep20Harness.sol#6583-6588) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 6588,
          "vulnerability_to_line": 6593,
          "vulnerability_code": "    function harnessLiquidateBorrowFresh(address liquidator, address borrower, uint repayAmount, VToken vTokenCollateral) public returns (uint) {\n\n        (uint err,) = liquidateBorrowFresh(liquidator, borrower, repayAmount, vTokenCollateral);\n\n        return err;\n\n    }\n\n\n",
          "message": "VBep20DelegateHarness.harnessLiquidateBorrowFresh (VBep20Harness.sol#6588-6593) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 6593,
          "vulnerability_to_line": 6597,
          "vulnerability_code": "    function harnessReduceReservesFresh(uint amount) public returns (uint) {\n\n        return _reduceReservesFresh(amount);\n\n    }\n\n\n",
          "message": "VBep20DelegateHarness.harnessReduceReservesFresh (VBep20Harness.sol#6593-6597) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 6597,
          "vulnerability_to_line": 6601,
          "vulnerability_code": "    function harnessSetReserveFactorFresh(uint newReserveFactorMantissa) public returns (uint) {\n\n        return _setReserveFactorFresh(newReserveFactorMantissa);\n\n    }\n\n\n",
          "message": "VBep20DelegateHarness.harnessSetReserveFactorFresh (VBep20Harness.sol#6597-6601) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 6601,
          "vulnerability_to_line": 6605,
          "vulnerability_code": "    function harnessSetInterestRateModelFresh(InterestRateModel newInterestRateModel) public returns (uint) {\n\n        return _setInterestRateModelFresh(newInterestRateModel);\n\n    }\n\n\n",
          "message": "VBep20DelegateHarness.harnessSetInterestRateModelFresh (VBep20Harness.sol#6601-6605) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 6605,
          "vulnerability_to_line": 6609,
          "vulnerability_code": "    function harnessSetInterestRateModel(address newInterestRateModelAddress) public {\n\n        interestRateModel = InterestRateModel(newInterestRateModelAddress);\n\n    }\n\n\n",
          "message": "VBep20DelegateHarness.harnessSetInterestRateModel (VBep20Harness.sol#6605-6609) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 6609,
          "vulnerability_to_line": 6614,
          "vulnerability_code": "    function harnessCallBorrowAllowed(uint amount) public returns (uint) {\n\n        return comptroller.borrowAllowed(address(this), msg.sender, amount);\n\n    }\n\n}\n\n\n",
          "message": "VBep20DelegateHarness.harnessCallBorrowAllowed (VBep20Harness.sol#6609-6614) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 6617,
          "vulnerability_to_line": 6621,
          "vulnerability_code": "    function setTotalBorrows(uint totalBorrows_) public {\n\n        totalBorrows = totalBorrows_;\n\n    }\n\n\n",
          "message": "VBep20DelegateScenario.setTotalBorrows (VBep20Harness.sol#6617-6621) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 6621,
          "vulnerability_to_line": 6625,
          "vulnerability_code": "    function setTotalReserves(uint totalReserves_) public {\n\n        totalReserves = totalReserves_;\n\n    }\n\n\n",
          "message": "VBep20DelegateScenario.setTotalReserves (VBep20Harness.sol#6621-6625) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 6632,
          "vulnerability_to_line": 6636,
          "vulnerability_code": "    function iHaveSpoken() public pure returns (string memory) {\n\n      return \"i have spoken\";\n\n    }\n\n\n",
          "message": "VBep20DelegateScenarioExtra.iHaveSpoken (VBep20Harness.sol#6632-6636) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 6636,
          "vulnerability_to_line": 6640,
          "vulnerability_code": "    function itIsTheWay() public {\n\n      admin = address(1); // make a change to test effect\n\n    }\n\n\n",
          "message": "VBep20DelegateScenarioExtra.itIsTheWay (VBep20Harness.sol#6636-6640) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 6640,
          "vulnerability_to_line": 6645,
          "vulnerability_code": "    function babyYoda() public pure {\n\n      revert(\"protect the baby\");\n\n    }\n\n}\n\n\n",
          "message": "VBep20DelegateScenarioExtra.babyYoda (VBep20Harness.sol#6640-6645) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 6650,
          "vulnerability_to_line": 6654,
          "vulnerability_code": "    function harnessFastForward(uint blocks) public {\n\n        blockNumber += blocks;\n\n    }\n\n\n",
          "message": "VDaiDelegateHarness.harnessFastForward (VBep20Harness.sol#6650-6654) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 6654,
          "vulnerability_to_line": 6658,
          "vulnerability_code": "    function harnessSetAccrualBlockNumber(uint _accrualblockNumber) public {\n\n        accrualBlockNumber = _accrualblockNumber;\n\n    }\n\n\n",
          "message": "VDaiDelegateHarness.harnessSetAccrualBlockNumber (VBep20Harness.sol#6654-6658) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 6662,
          "vulnerability_to_line": 6666,
          "vulnerability_code": "    function harnessSetBlockNumber(uint newBlockNumber) public {\n\n        blockNumber = newBlockNumber;\n\n    }\n\n\n",
          "message": "VDaiDelegateHarness.harnessSetBlockNumber (VBep20Harness.sol#6662-6666) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 6666,
          "vulnerability_to_line": 6671,
          "vulnerability_code": "    function harnessSetExchangeRate(uint exchangeRate) public {\n\n        harnessExchangeRate = exchangeRate;\n\n        harnessExchangeRateStored = true;\n\n    }\n\n\n",
          "message": "VDaiDelegateHarness.harnessSetExchangeRate (VBep20Harness.sol#6666-6671) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 6671,
          "vulnerability_to_line": 6675,
          "vulnerability_code": "    function harnessSetTotalSupply(uint totalSupply_) public {\n\n        totalSupply = totalSupply_;\n\n    }\n\n\n",
          "message": "VDaiDelegateHarness.harnessSetTotalSupply (VBep20Harness.sol#6671-6675) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 6681,
          "vulnerability_to_line": 6685,
          "vulnerability_code": "    function setTotalBorrows(uint totalBorrows_) public {\n\n        totalBorrows = totalBorrows_;\n\n    }\n\n\n",
          "message": "VDaiDelegateScenario.setTotalBorrows (VBep20Harness.sol#6681-6685) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 6685,
          "vulnerability_to_line": 6689,
          "vulnerability_code": "    function setTotalReserves(uint totalReserves_) public {\n\n        totalReserves = totalReserves_;\n\n    }\n\n\n",
          "message": "VDaiDelegateScenario.setTotalReserves (VBep20Harness.sol#6685-6689) should be declared external\n"
        },
        {
          "name": "solc-version",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": "Detected issues with version pragma in VBep20Harness.sol:\n\t- pragma solidity^0.5.16 (VBep20Harness.sol#3): it allows old versions\n\t- pragma solidity^0.5.16 (VBep20Harness.sol#97): it allows old versions\n\t- pragma solidity^0.5.16 (VBep20Harness.sol#130): it allows old versions\n\t- pragma solidity^0.5.16 (VBep20Harness.sol#438): it allows old versions\n\t- pragma solidity^0.5.16 (VBep20Harness.sol#723): it allows old versions\n\t- pragma solidity^0.5.16 (VBep20Harness.sol#811): it allows old versions\n\t- pragma solidity^0.5.16 (VBep20Harness.sol#1009): it allows old versions\n\t- pragma solidity^0.5.16 (VBep20Harness.sol#1192): it allows old versions\n\t- pragma solidity^0.5.16 (VBep20Harness.sol#1256): it allows old versions\n\t- pragma solidity^0.5.16 (VBep20Harness.sol#1328): it allows old versions\n\t- pragma solidity^0.5.16 (VBep20Harness.sol#2783-2786): it allows old versions\n\t- pragma solidity^0.5.16 (VBep20Harness.sol#2982-2985): it allows old versions\n\t- pragma solidity^0.5.16 (VBep20Harness.sol#3022-3025): it allows old versions\n\t- pragma solidity^0.5.16 (VBep20Harness.sol#3490-3493): it allows old versions\n\t- pragma solidity^0.5.16 (VBep20Harness.sol#3534-3537): it allows old versions\n\t- pragma solidity^0.5.16 (VBep20Harness.sol#3743-3745): it allows old versions\n\t- pragma solidity^0.5.16 (VBep20Harness.sol#3760-3762): it allows old versions\n\t- pragma solidity^0.5.16 (VBep20Harness.sol#3775-3779): it allows old versions\n\t- pragma solidity^0.5.16 (VBep20Harness.sol#3956-3959): it allows old versions\n\t- pragma solidity^0.5.16 (VBep20Harness.sol#4106-4108): it allows old versions\n\t- pragma solidity>=0.5.16 (VBep20Harness.sol#4469-4471): it allows old versions\n\t- pragma solidity>=0.5.16 (VBep20Harness.sol#4519-4521): it allows old versions\n\t- pragma solidity^0.5.16 (VBep20Harness.sol#4645-4654): it allows old versions\n\t- pragma solidity^0.5.16 (VBep20Harness.sol#6139-6141): it allows old versions\n\t- pragma solidity^0.5.16 (VBep20Harness.sol#6240-6246): it allows old versions\n"
        },
        {
          "name": "low-level-calls",
          "vulnerability_from_line": 3430,
          "vulnerability_to_line": 3440,
          "vulnerability_code": "    function delegateTo(address callee, bytes memory data) internal returns (bytes memory) {\n\n        (bool success, bytes memory returnData) = callee.delegatecall(data);\n\n        assembly {\n\n            if eq(success, 0) {\n\n                revert(add(returnData, 0x20), returndatasize)\n\n            }\n\n        }\n\n        return returnData;\n\n    }\n\n\n",
          "message": "Low level call in VBep20Delegator.delegateTo (VBep20Harness.sol#3430-3440):\n\t-(success,returnData) = callee.delegatecall(data) VBep20Harness.sol#3431-3432\n"
        },
        {
          "name": "low-level-calls",
          "vulnerability_from_line": 3457,
          "vulnerability_to_line": 3467,
          "vulnerability_code": "    function delegateToViewImplementation(bytes memory data) public view returns (bytes memory) {\n\n        (bool success, bytes memory returnData) = address(this).staticcall(abi.encodeWithSignature(\"delegateToImplementation(bytes)\", data));\n\n        assembly {\n\n            if eq(success, 0) {\n\n                revert(add(returnData, 0x20), returndatasize)\n\n            }\n\n        }\n\n        return abi.decode(returnData, (bytes));\n\n    }\n\n\n",
          "message": "Low level call in VBep20Delegator.delegateToViewImplementation (VBep20Harness.sol#3457-3467):\n\t-(success,returnData) = address(this).staticcall(abi.encodeWithSignature(delegateToImplementation(bytes),data)) VBep20Harness.sol#3458-3459\n"
        },
        {
          "name": "low-level-calls",
          "vulnerability_from_line": 3471,
          "vulnerability_to_line": 3488,
          "vulnerability_code": "    function () external payable {\n\n        require(msg.value == 0,\"VBep20Delegator:fallback: cannot send value to fallback\");\n\n\n\n        // delegate all other functions to current implementation\n\n        (bool success, ) = implementation.delegatecall(msg.data);\n\n\n\n        assembly {\n\n            let free_mem_ptr := mload(0x40)\n\n            returndatacopy(free_mem_ptr, 0, returndatasize)\n\n\n\n            switch success\n\n            case 0 { revert(free_mem_ptr, returndatasize) }\n\n            default { return(free_mem_ptr, returndatasize) }\n\n        }\n\n    }\n\n}\n\n\n",
          "message": "Low level call in VBep20Delegator.fallback (VBep20Harness.sol#3471-3488):\n\t-(success) = implementation.delegatecall(msg.data) VBep20Harness.sol#3475-3477\n"
        },
        {
          "name": "low-level-calls",
          "vulnerability_from_line": 4089,
          "vulnerability_to_line": 4104,
          "vulnerability_code": "    function () external payable {\n\n        // delegate all other functions to current implementation\n\n        (bool success, ) = comptrollerImplementation.delegatecall(msg.data);\n\n\n\n        assembly {\n\n              let free_mem_ptr := mload(0x40)\n\n              returndatacopy(free_mem_ptr, 0, returndatasize)\n\n\n\n              switch success\n\n              case 0 { revert(free_mem_ptr, returndatasize) }\n\n              default { return(free_mem_ptr, returndatasize) }\n\n        }\n\n    }\n\n}\n\n\n",
          "message": "Low level call in Unitroller.fallback (VBep20Harness.sol#4089-4104):\n\t-(success) = comptrollerImplementation.delegatecall(msg.data) VBep20Harness.sol#4091-4093\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 7,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bool public constant isComptroller = true;\n",
          "message": "Constant 'ComptrollerInterfaceG1.isComptroller' (VBep20Harness.sol#7) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 105,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bool public constant isInterestRateModel = true;\n",
          "message": "Constant 'InterestRateModel.isInterestRateModel' (VBep20Harness.sol#105) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 137,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bool internal _notEntered;\n",
          "message": "Variable 'VTokenStorage._notEntered' (VBep20Harness.sol#137) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 158,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint internal constant borrowRateMaxMantissa = 0.0005e16;\n",
          "message": "Constant 'VTokenStorage.borrowRateMaxMantissa' (VBep20Harness.sol#158) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 163,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint internal constant reserveFactorMaxMantissa = 1e18;\n",
          "message": "Constant 'VTokenStorage.reserveFactorMaxMantissa' (VBep20Harness.sol#163) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 367,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint);\n",
          "message": "Function 'VTokenInterface._setPendingAdmin' (VBep20Harness.sol#367) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 368,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _acceptAdmin() external returns (uint);\n",
          "message": "Function 'VTokenInterface._acceptAdmin' (VBep20Harness.sol#368) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 369,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setComptroller(ComptrollerInterface newComptroller) public returns (uint);\n",
          "message": "Function 'VTokenInterface._setComptroller' (VBep20Harness.sol#369) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 370,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setReserveFactor(uint newReserveFactorMantissa) external returns (uint);\n",
          "message": "Function 'VTokenInterface._setReserveFactor' (VBep20Harness.sol#370) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 371,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _reduceReserves(uint reduceAmount) external returns (uint);\n",
          "message": "Function 'VTokenInterface._reduceReserves' (VBep20Harness.sol#371) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 372,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint);\n",
          "message": "Function 'VTokenInterface._setInterestRateModel' (VBep20Harness.sol#372) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 250,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bool public constant isVToken = true;\n",
          "message": "Constant 'VTokenInterface.isVToken' (VBep20Harness.sol#250) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 397,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _addReserves(uint addAmount) external returns (uint);\n",
          "message": "Function 'VBep20Interface._addReserves' (VBep20Harness.sol#397) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 419,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setImplementation(address implementation_, bool allowResign, bytes memory becomeImplementationData) public;\n",
          "message": "Function 'VDelegatorInterface._setImplementation' (VBep20Harness.sol#419) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 428,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _becomeImplementation(bytes memory data) public;\n",
          "message": "Function 'VDelegateInterface._becomeImplementation' (VBep20Harness.sol#428) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 433,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _resignImplementation() public;\n",
          "message": "Function 'VDelegateInterface._resignImplementation' (VBep20Harness.sol#433) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 846,
          "vulnerability_to_line": 849,
          "vulnerability_code": "    function mul_ScalarTruncate(Exp memory a, uint scalar) pure internal returns (uint) {\n\n        Exp memory product = mul_(a, scalar);\n\n        return truncate(product);\n",
          "message": "Function 'ExponentialNoError.mul_ScalarTruncate' (VBep20Harness.sol#846-849) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 854,
          "vulnerability_to_line": 857,
          "vulnerability_code": "    function mul_ScalarTruncateAddUInt(Exp memory a, uint scalar, uint addend) pure internal returns (uint) {\n\n        Exp memory product = mul_(a, scalar);\n\n        return add_(truncate(product), addend);\n",
          "message": "Function 'ExponentialNoError.mul_ScalarTruncateAddUInt' (VBep20Harness.sol#854-857) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 821,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint constant expScale = 1e18;\n",
          "message": "Constant 'ExponentialNoError.expScale' (VBep20Harness.sol#821) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 822,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint constant doubleScale = 1e36;\n",
          "message": "Constant 'ExponentialNoError.doubleScale' (VBep20Harness.sol#822) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 823,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint constant halfExpScale = expScale/2;\n",
          "message": "Constant 'ExponentialNoError.halfExpScale' (VBep20Harness.sol#823) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 824,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint constant mantissaOne = expScale;\n",
          "message": "Constant 'ExponentialNoError.mantissaOne' (VBep20Harness.sol#824) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 2453,
          "vulnerability_to_line": 2469,
          "vulnerability_code": "    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint) {\n\n        // Check caller = admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);\n\n        }\n\n\n\n        // Save current value, if any, for inclusion in log\n\n        address oldPendingAdmin = pendingAdmin;\n\n\n\n        // Store pendingAdmin with value newPendingAdmin\n\n        pendingAdmin = newPendingAdmin;\n\n\n\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\n\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n\n\n\n        return uint(Error.NO_ERROR);\n",
          "message": "Function 'VToken._setPendingAdmin' (VBep20Harness.sol#2453-2469) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 2476,
          "vulnerability_to_line": 2498,
          "vulnerability_code": "    function _acceptAdmin() external returns (uint) {\n\n        // Check caller is pendingAdmin and pendingAdmin \u2260 address(0)\n\n        if (msg.sender != pendingAdmin || msg.sender == address(0)) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);\n\n        }\n\n\n\n        // Save current values for inclusion in log\n\n        address oldAdmin = admin;\n\n        address oldPendingAdmin = pendingAdmin;\n\n\n\n        // Store admin with value pendingAdmin\n\n        admin = pendingAdmin;\n\n\n\n        // Clear the pending value\n\n        pendingAdmin = address(0);\n\n\n\n        emit NewAdmin(oldAdmin, admin);\n\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Function 'VToken._acceptAdmin' (VBep20Harness.sol#2476-2498) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 2503,
          "vulnerability_to_line": 2522,
          "vulnerability_code": "    function _setComptroller(ComptrollerInterface newComptroller) public returns (uint) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COMPTROLLER_OWNER_CHECK);\n\n        }\n\n\n\n        ComptrollerInterface oldComptroller = comptroller;\n\n        // Ensure invoke comptroller.isComptroller() returns true\n\n        require(newComptroller.isComptroller(), \"marker method returned false\");\n\n\n\n        // Set market's comptroller to newComptroller\n\n        comptroller = newComptroller;\n\n\n\n        // Emit NewComptroller(oldComptroller, newComptroller)\n\n        emit NewComptroller(oldComptroller, newComptroller);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Function 'VToken._setComptroller' (VBep20Harness.sol#2503-2522) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 2527,
          "vulnerability_to_line": 2537,
          "vulnerability_code": "    function _setReserveFactor(uint newReserveFactorMantissa) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.\n\n            return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.\n\n        return _setReserveFactorFresh(newReserveFactorMantissa);\n\n    }\n\n\n",
          "message": "Function 'VToken._setReserveFactor' (VBep20Harness.sol#2527-2537) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 2634,
          "vulnerability_to_line": 2644,
          "vulnerability_code": "    function _reduceReserves(uint reduceAmount) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n\n            return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.\n\n        return _reduceReservesFresh(reduceAmount);\n\n    }\n\n\n",
          "message": "Function 'VToken._reduceReserves' (VBep20Harness.sol#2634-2644) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 2699,
          "vulnerability_to_line": 2709,
          "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n\n        return _setInterestRateModelFresh(newInterestRateModel);\n\n    }\n\n\n",
          "message": "Function 'VToken._setInterestRateModel' (VBep20Harness.sol#2699-2709) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 2542,
          "vulnerability_to_line": 2566,
          "vulnerability_code": "    function _setReserveFactorFresh(uint newReserveFactorMantissa) internal returns (uint) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_RESERVE_FACTOR_ADMIN_CHECK);\n\n        }\n\n\n\n        // Verify market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_RESERVE_FACTOR_FRESH_CHECK);\n\n        }\n\n\n\n        // Check newReserveFactor \u2264 maxReserveFactor\n\n        if (newReserveFactorMantissa > reserveFactorMaxMantissa) {\n\n            return fail(Error.BAD_INPUT, FailureInfo.SET_RESERVE_FACTOR_BOUNDS_CHECK);\n\n        }\n\n\n\n        uint oldReserveFactorMantissa = reserveFactorMantissa;\n\n        reserveFactorMantissa = newReserveFactorMantissa;\n\n\n\n        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Function 'VToken._setReserveFactorFresh' (VBep20Harness.sol#2542-2566) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 2571,
          "vulnerability_to_line": 2583,
          "vulnerability_code": "    function _addReservesInternal(uint addAmount) internal nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n\n            return fail(Error(error), FailureInfo.ADD_RESERVES_ACCRUE_INTEREST_FAILED);\n\n        }\n\n\n\n        // _addReservesFresh emits reserve-addition-specific logs on errors, so we don't need to.\n\n        (error, ) = _addReservesFresh(addAmount);\n\n        return error;\n\n    }\n\n\n",
          "message": "Function 'VToken._addReservesInternal' (VBep20Harness.sol#2571-2583) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 2589,
          "vulnerability_to_line": 2629,
          "vulnerability_code": "    function _addReservesFresh(uint addAmount) internal returns (uint, uint) {\n\n        // totalReserves + actualAddAmount\n\n        uint totalReservesNew;\n\n        uint actualAddAmount;\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return (fail(Error.MARKET_NOT_FRESH, FailureInfo.ADD_RESERVES_FRESH_CHECK), actualAddAmount);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We call doTransferIn for the caller and the addAmount\n\n         *  Note: The vToken must handle variations between BEP-20 and BNB underlying.\n\n         *  On success, the vToken holds an additional addAmount of cash.\n\n         *  doTransferIn reverts if anything goes wrong, since we can't be sure if side effects occurred.\n\n         *  it returns the amount actually transferred, in case of a fee.\n\n         */\n\n\n\n        actualAddAmount = doTransferIn(msg.sender, addAmount);\n\n\n\n        totalReservesNew = totalReserves + actualAddAmount;\n\n\n\n        /* Revert on overflow */\n\n        require(totalReservesNew >= totalReserves, \"add reserves unexpected overflow\");\n\n\n\n        // Store reserves[n+1] = reserves[n] + actualAddAmount\n\n        totalReserves = totalReservesNew;\n\n\n\n        /* Emit NewReserves(admin, actualAddAmount, reserves[n+1]) */\n\n        emit ReservesAdded(msg.sender, actualAddAmount, totalReservesNew);\n\n\n\n        /* Return (NO_ERROR, actualAddAmount) */\n\n        return (uint(Error.NO_ERROR), actualAddAmount);\n\n    }\n\n\n\n\n",
          "message": "Function 'VToken._addReservesFresh' (VBep20Harness.sol#2589-2629) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 2650,
          "vulnerability_to_line": 2693,
          "vulnerability_code": "    function _reduceReservesFresh(uint reduceAmount) internal returns (uint) {\n\n        // totalReserves - reduceAmount\n\n        uint totalReservesNew;\n\n\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.REDUCE_RESERVES_ADMIN_CHECK);\n\n        }\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDUCE_RESERVES_FRESH_CHECK);\n\n        }\n\n\n\n        // Fail gracefully if protocol has insufficient underlying cash\n\n        if (getCashPrior() < reduceAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDUCE_RESERVES_CASH_NOT_AVAILABLE);\n\n        }\n\n\n\n        // Check reduceAmount \u2264 reserves[n] (totalReserves)\n\n        if (reduceAmount > totalReserves) {\n\n            return fail(Error.BAD_INPUT, FailureInfo.REDUCE_RESERVES_VALIDATION);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        totalReservesNew = totalReserves - reduceAmount;\n\n        // We checked reduceAmount <= totalReserves above, so this should never revert.\n\n        require(totalReservesNew <= totalReserves, \"reduce reserves unexpected underflow\");\n\n\n\n        // Store reserves[n+1] = reserves[n] - reduceAmount\n\n        totalReserves = totalReservesNew;\n\n\n\n        // doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n\n        doTransferOut(admin, reduceAmount);\n\n\n\n        emit ReservesReduced(admin, reduceAmount, totalReservesNew);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Function 'VToken._reduceReservesFresh' (VBep20Harness.sol#2650-2693) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 2715,
          "vulnerability_to_line": 2745,
          "vulnerability_code": "    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {\n\n\n\n        // Used to store old model for use in the event that is emitted on success\n\n        InterestRateModel oldInterestRateModel;\n\n\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);\n\n        }\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);\n\n        }\n\n\n\n        // Track the market's current interest rate model\n\n        oldInterestRateModel = interestRateModel;\n\n\n\n        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true\n\n        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n\n\n\n        // Set the interest rate model to newInterestRateModel\n\n        interestRateModel = newInterestRateModel;\n\n\n\n        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)\n\n        emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Function 'VToken._setInterestRateModelFresh' (VBep20Harness.sol#2715-2745) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 2897,
          "vulnerability_to_line": 2901,
          "vulnerability_code": "    function _addReserves(uint addAmount) external returns (uint) {\n\n        return _addReservesInternal(addAmount);\n\n    }\n\n\n",
          "message": "Function 'VBep20._addReserves' (VBep20Harness.sol#2897-2901) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 3357,
          "vulnerability_to_line": 3362,
          "vulnerability_code": "    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint) {\n\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"_setPendingAdmin(address)\", newPendingAdmin));\n\n        return abi.decode(data, (uint));\n\n    }\n\n\n",
          "message": "Function 'VBep20Delegator._setPendingAdmin' (VBep20Harness.sol#3357-3362) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 3387,
          "vulnerability_to_line": 3392,
          "vulnerability_code": "    function _acceptAdmin() external returns (uint) {\n\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"_acceptAdmin()\"));\n\n        return abi.decode(data, (uint));\n\n    }\n\n\n",
          "message": "Function 'VBep20Delegator._acceptAdmin' (VBep20Harness.sol#3387-3392) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 3367,
          "vulnerability_to_line": 3372,
          "vulnerability_code": "    function _setComptroller(ComptrollerInterface newComptroller) public returns (uint) {\n\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"_setComptroller(address)\", newComptroller));\n\n        return abi.decode(data, (uint));\n\n    }\n\n\n",
          "message": "Function 'VBep20Delegator._setComptroller' (VBep20Harness.sol#3367-3372) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 3377,
          "vulnerability_to_line": 3382,
          "vulnerability_code": "    function _setReserveFactor(uint newReserveFactorMantissa) external returns (uint) {\n\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"_setReserveFactor(uint256)\", newReserveFactorMantissa));\n\n        return abi.decode(data, (uint));\n\n    }\n\n\n",
          "message": "Function 'VBep20Delegator._setReserveFactor' (VBep20Harness.sol#3377-3382) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 3407,
          "vulnerability_to_line": 3412,
          "vulnerability_code": "    function _reduceReserves(uint reduceAmount) external returns (uint) {\n\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"_reduceReserves(uint256)\", reduceAmount));\n\n        return abi.decode(data, (uint));\n\n    }\n\n\n",
          "message": "Function 'VBep20Delegator._reduceReserves' (VBep20Harness.sol#3407-3412) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 3418,
          "vulnerability_to_line": 3423,
          "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {\n\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"_setInterestRateModel(address)\", newInterestRateModel));\n\n        return abi.decode(data, (uint));\n\n    }\n\n\n",
          "message": "Function 'VBep20Delegator._setInterestRateModel' (VBep20Harness.sol#3418-3423) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 3397,
          "vulnerability_to_line": 3402,
          "vulnerability_code": "    function _addReserves(uint addAmount) external returns (uint) {\n\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"_addReserves(uint256)\", addAmount));\n\n        return abi.decode(data, (uint));\n\n    }\n\n\n",
          "message": "Function 'VBep20Delegator._addReserves' (VBep20Harness.sol#3397-3402) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 3079,
          "vulnerability_to_line": 3094,
          "vulnerability_code": "    function _setImplementation(address implementation_, bool allowResign, bytes memory becomeImplementationData) public {\n\n        require(msg.sender == admin, \"VBep20Delegator::_setImplementation: Caller must be admin\");\n\n\n\n        if (allowResign) {\n\n            delegateToImplementation(abi.encodeWithSignature(\"_resignImplementation()\"));\n\n        }\n\n\n\n        address oldImplementation = implementation;\n\n        implementation = implementation_;\n\n\n\n        delegateToImplementation(abi.encodeWithSignature(\"_becomeImplementation(bytes)\", becomeImplementationData));\n\n\n\n        emit NewImplementation(oldImplementation, implementation);\n\n    }\n\n\n",
          "message": "Function 'VBep20Delegator._setImplementation' (VBep20Harness.sol#3079-3094) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 3507,
          "vulnerability_to_line": 3519,
          "vulnerability_code": "    function _becomeImplementation(bytes memory data) public {\n\n        // Shh -- currently unused\n\n        data;\n\n\n\n        // Shh -- we don't ever want this hook to be marked pure\n\n        if (false) {\n\n            implementation = address(0);\n\n        }\n\n\n\n        require(msg.sender == admin, \"only the admin may call _becomeImplementation\");\n\n    }\n\n\n",
          "message": "Function 'VBep20Delegate._becomeImplementation' (VBep20Harness.sol#3507-3519) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 3522,
          "vulnerability_to_line": 3532,
          "vulnerability_code": "    function _resignImplementation() public {\n\n        // Shh -- we don't ever want this hook to be marked pure\n\n        if (false) {\n\n            implementation = address(0);\n\n        }\n\n\n\n        require(msg.sender == admin, \"only the admin may call _resignImplementation\");\n\n    }\n\n}\n\n\n",
          "message": "Function 'VBep20Delegate._resignImplementation' (VBep20Harness.sol#3522-3532) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 3561,
          "vulnerability_to_line": 3568,
          "vulnerability_code": "    function _becomeImplementation(bytes memory data) public {\n\n        require(msg.sender == admin, \"only the admin may initialize the implementation\");\n\n\n\n        (address daiJoinAddress_, address potAddress_) = abi.decode(data, (address, address));\n\n        return _becomeImplementation(daiJoinAddress_, potAddress_);\n\n    }\n\n\n",
          "message": "Function 'VDaiDelegate._becomeImplementation' (VBep20Harness.sol#3561-3568) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 3603,
          "vulnerability_to_line": 3625,
          "vulnerability_code": "    function _resignImplementation() public {\n\n        require(msg.sender == admin, \"only the admin may abandon the implementation\");\n\n\n\n        // Transfer all cash out of the DSR - note that this relies on self-transfer\n\n        DaiJoinLike daiJoin = DaiJoinLike(daiJoinAddress);\n\n        PotLike pot = PotLike(potAddress);\n\n        VatLike vat = VatLike(vatAddress);\n\n\n\n        // Accumulate interest\n\n        pot.drip();\n\n\n\n        // Calculate the total amount in the pot, and move it out\n\n        uint pie = pot.pie(address(this));\n\n        pot.exit(pie);\n\n\n\n        // Checks the actual balance of DAI in the vat after the pot exit\n\n        uint bal = vat.dai(address(this));\n\n\n\n        // Remove our whole balance\n\n        daiJoin.exit(address(this), bal / RAY);\n\n    }\n\n\n",
          "message": "Function 'VDaiDelegate._resignImplementation' (VBep20Harness.sol#3603-3625) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 3573,
          "vulnerability_to_line": 3600,
          "vulnerability_code": "    function _becomeImplementation(address daiJoinAddress_, address potAddress_) internal {\n\n        // Get dai and vat and sanity check the underlying\n\n        DaiJoinLike daiJoin = DaiJoinLike(daiJoinAddress_);\n\n        PotLike pot = PotLike(potAddress_);\n\n        GemLike dai = daiJoin.dai();\n\n        VatLike vat = daiJoin.vat();\n\n        require(address(dai) == underlying, \"DAI must be the same as underlying\");\n\n\n\n        // Remember the relevant addresses\n\n        daiJoinAddress = daiJoinAddress_;\n\n        potAddress = potAddress_;\n\n        vatAddress = address(vat);\n\n\n\n        // Approve moving our DAI into the vat through daiJoin\n\n        dai.approve(daiJoinAddress, uint(-1));\n\n\n\n        // Approve the pot to transfer our funds within the vat\n\n        vat.hope(potAddress);\n\n        vat.hope(daiJoinAddress);\n\n\n\n        // Accumulate DSR interest -- must do this in order to doTransferIn\n\n        pot.drip();\n\n\n\n        // Transfer all cash in (doTransferIn does this regardless of amount)\n\n        doTransferIn(address(this), 0);\n\n    }\n\n\n",
          "message": "Function 'VDaiDelegate._becomeImplementation' (VBep20Harness.sol#3573-3600) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 3717,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function pie(address) external view returns (uint);\n",
          "message": "Parameter '' of PotLike.pie (VBep20Harness.sol#3717) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 3719,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function join(uint) external;\n",
          "message": "Parameter '' of PotLike.join (VBep20Harness.sol#3719) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 3720,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function exit(uint) external;\n",
          "message": "Parameter '' of PotLike.exit (VBep20Harness.sol#3720) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 3724,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function approve(address, uint) external;\n",
          "message": "Parameter '' of GemLike.approve (VBep20Harness.sol#3724) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 3724,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function approve(address, uint) external;\n",
          "message": "Parameter '_scope_0' of GemLike.approve (VBep20Harness.sol#3724) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 3725,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function balanceOf(address) external view returns (uint);\n",
          "message": "Parameter '' of GemLike.balanceOf (VBep20Harness.sol#3725) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 3726,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function transferFrom(address, address, uint) external returns (bool);\n",
          "message": "Parameter '' of GemLike.transferFrom (VBep20Harness.sol#3726) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 3726,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function transferFrom(address, address, uint) external returns (bool);\n",
          "message": "Parameter '_scope_0' of GemLike.transferFrom (VBep20Harness.sol#3726) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 3726,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function transferFrom(address, address, uint) external returns (bool);\n",
          "message": "Parameter '_scope_1' of GemLike.transferFrom (VBep20Harness.sol#3726) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 3730,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function dai(address) external view returns (uint);\n",
          "message": "Parameter '' of VatLike.dai (VBep20Harness.sol#3730) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 3731,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function hope(address) external;\n",
          "message": "Parameter '' of VatLike.hope (VBep20Harness.sol#3731) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 3737,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function join(address, uint) external payable;\n",
          "message": "Parameter '' of DaiJoinLike.join (VBep20Harness.sol#3737) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 3737,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function join(address, uint) external payable;\n",
          "message": "Parameter '_scope_0' of DaiJoinLike.join (VBep20Harness.sol#3737) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 3738,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function exit(address, uint) external;\n",
          "message": "Parameter '' of DaiJoinLike.exit (VBep20Harness.sol#3738) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 3738,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function exit(address, uint) external;\n",
          "message": "Parameter '_scope_0' of DaiJoinLike.exit (VBep20Harness.sol#3738) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 3747,
          "vulnerability_to_line": 3749,
          "vulnerability_code": "    bool public constant isPriceOracle = true;\n\n\n",
          "message": "Constant 'PriceOracle.isPriceOracle' (VBep20Harness.sol#3747-3749) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 3768,
          "vulnerability_to_line": 3769,
          "vulnerability_code": "    function _initializeVenusVAIState(uint blockNumber) external returns (uint);\n",
          "message": "Function 'VAIControllerInterface._initializeVenusVAIState' (VBep20Harness.sol#3768-3769) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 3858,
          "vulnerability_to_line": 3859,
          "vulnerability_code": "    bool public _mintGuardianPaused;\n",
          "message": "Variable 'ComptrollerV1Storage._mintGuardianPaused' (VBep20Harness.sol#3858-3859) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 3859,
          "vulnerability_to_line": 3860,
          "vulnerability_code": "    bool public _borrowGuardianPaused;\n",
          "message": "Variable 'ComptrollerV1Storage._borrowGuardianPaused' (VBep20Harness.sol#3859-3860) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 3992,
          "vulnerability_to_line": 4007,
          "vulnerability_code": "    function _setPendingImplementation(address newPendingImplementation) public returns (uint) {\n\n\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_IMPLEMENTATION_OWNER_CHECK);\n\n        }\n\n\n\n        address oldPendingImplementation = pendingComptrollerImplementation;\n\n\n\n        pendingComptrollerImplementation = newPendingImplementation;\n\n\n\n        emit NewPendingImplementation(oldPendingImplementation, pendingComptrollerImplementation);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Function 'Unitroller._setPendingImplementation' (VBep20Harness.sol#3992-4007) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 4012,
          "vulnerability_to_line": 4033,
          "vulnerability_code": "    function _acceptImplementation() public returns (uint) {\n\n        // Check caller is pendingImplementation and pendingImplementation \u2260 address(0)\n\n        if (msg.sender != pendingComptrollerImplementation || pendingComptrollerImplementation == address(0)) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_PENDING_IMPLEMENTATION_ADDRESS_CHECK);\n\n        }\n\n\n\n        // Save current values for inclusion in log\n\n        address oldImplementation = comptrollerImplementation;\n\n        address oldPendingImplementation = pendingComptrollerImplementation;\n\n\n\n        comptrollerImplementation = pendingComptrollerImplementation;\n\n\n\n        pendingComptrollerImplementation = address(0);\n\n\n\n        emit NewImplementation(oldImplementation, comptrollerImplementation);\n\n        emit NewPendingImplementation(oldPendingImplementation, pendingComptrollerImplementation);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n\n",
          "message": "Function 'Unitroller._acceptImplementation' (VBep20Harness.sol#4012-4033) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 4039,
          "vulnerability_to_line": 4057,
          "vulnerability_code": "    function _setPendingAdmin(address newPendingAdmin) public returns (uint) {\n\n        // Check caller = admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);\n\n        }\n\n\n\n        // Save current value, if any, for inclusion in log\n\n        address oldPendingAdmin = pendingAdmin;\n\n\n\n        // Store pendingAdmin with value newPendingAdmin\n\n        pendingAdmin = newPendingAdmin;\n\n\n\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\n\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Function 'Unitroller._setPendingAdmin' (VBep20Harness.sol#4039-4057) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 4062,
          "vulnerability_to_line": 4085,
          "vulnerability_code": "    function _acceptAdmin() public returns (uint) {\n\n        // Check caller is pendingAdmin and pendingAdmin \u2260 address(0)\n\n        if (msg.sender != pendingAdmin || msg.sender == address(0)) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);\n\n        }\n\n\n\n        // Save current values for inclusion in log\n\n        address oldAdmin = admin;\n\n        address oldPendingAdmin = pendingAdmin;\n\n\n\n        // Store admin with value pendingAdmin\n\n        admin = pendingAdmin;\n\n\n\n        // Clear the pending value\n\n        pendingAdmin = address(0);\n\n\n\n        emit NewAdmin(oldAdmin, admin);\n\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
          "message": "Function 'Unitroller._acceptAdmin' (VBep20Harness.sol#4062-4085) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 4372,
          "vulnerability_to_line": 4382,
          "vulnerability_code": "    function _delegate(address delegator, address delegatee) internal {\n\n        address currentDelegate = delegates[delegator];\n\n        uint96 delegatorBalance = balances[delegator];\n\n        delegates[delegator] = delegatee;\n\n\n\n        emit DelegateChanged(delegator, currentDelegate, delegatee);\n\n\n\n        _moveDelegates(currentDelegate, delegatee, delegatorBalance);\n\n    }\n\n\n",
          "message": "Function 'XVS._delegate' (VBep20Harness.sol#4372-4382) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 4382,
          "vulnerability_to_line": 4393,
          "vulnerability_code": "    function _transferTokens(address src, address dst, uint96 amount) internal {\n\n        require(src != address(0), \"XVS::_transferTokens: cannot transfer from the zero address\");\n\n        require(dst != address(0), \"XVS::_transferTokens: cannot transfer to the zero address\");\n\n\n\n        balances[src] = sub96(balances[src], amount, \"XVS::_transferTokens: transfer amount exceeds balance\");\n\n        balances[dst] = add96(balances[dst], amount, \"XVS::_transferTokens: transfer amount overflows\");\n\n        emit Transfer(src, dst, amount);\n\n\n\n        _moveDelegates(delegates[src], delegates[dst], amount);\n\n    }\n\n\n",
          "message": "Function 'XVS._transferTokens' (VBep20Harness.sol#4382-4393) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 4393,
          "vulnerability_to_line": 4411,
          "vulnerability_code": "    function _moveDelegates(address srcRep, address dstRep, uint96 amount) internal {\n\n        if (srcRep != dstRep && amount > 0) {\n\n            if (srcRep != address(0)) {\n\n                uint32 srcRepNum = numCheckpoints[srcRep];\n\n                uint96 srcRepOld = srcRepNum > 0 ? checkpoints[srcRep][srcRepNum - 1].votes : 0;\n\n                uint96 srcRepNew = sub96(srcRepOld, amount, \"XVS::_moveVotes: vote amount underflows\");\n\n                _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);\n\n            }\n\n\n\n            if (dstRep != address(0)) {\n\n                uint32 dstRepNum = numCheckpoints[dstRep];\n\n                uint96 dstRepOld = dstRepNum > 0 ? checkpoints[dstRep][dstRepNum - 1].votes : 0;\n\n                uint96 dstRepNew = add96(dstRepOld, amount, \"XVS::_moveVotes: vote amount overflows\");\n\n                _writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);\n\n            }\n\n        }\n\n    }\n\n\n",
          "message": "Function 'XVS._moveDelegates' (VBep20Harness.sol#4393-4411) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 4411,
          "vulnerability_to_line": 4424,
          "vulnerability_code": "    function _writeCheckpoint(address delegatee, uint32 nCheckpoints, uint96 oldVotes, uint96 newVotes) internal {\n\n      uint32 blockNumber = safe32(block.number, \"XVS::_writeCheckpoint: block number exceeds 32 bits\");\n\n\n\n      if (nCheckpoints > 0 && checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber) {\n\n          checkpoints[delegatee][nCheckpoints - 1].votes = newVotes;\n\n      } else {\n\n          checkpoints[delegatee][nCheckpoints] = Checkpoint(blockNumber, newVotes);\n\n          numCheckpoints[delegatee] = nCheckpoints + 1;\n\n      }\n\n\n\n      emit DelegateVotesChanged(delegatee, oldVotes, newVotes);\n\n    }\n\n\n",
          "message": "Function 'XVS._writeCheckpoint' (VBep20Harness.sol#4411-4424) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 4165,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint public constant totalSupply = 30000000e18; // 30 million XVS\n",
          "message": "Constant 'XVS.totalSupply' (VBep20Harness.sol#4165) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 4534,
          "vulnerability_to_line": 4535,
          "vulnerability_code": "    string  public constant version  = \"1\";\n",
          "message": "Constant 'VAI.version' (VBep20Harness.sol#4534-4535) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 4554,
          "vulnerability_to_line": 4555,
          "vulnerability_code": "    bytes32 public DOMAIN_SEPARATOR;\n",
          "message": "Variable 'VAI.DOMAIN_SEPARATOR' (VBep20Harness.sol#4554-4555) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 5515,
          "vulnerability_to_line": 5534,
          "vulnerability_code": "    function _setPriceOracle(PriceOracle newOracle) public returns (uint) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PRICE_ORACLE_OWNER_CHECK);\n\n        }\n\n\n\n        // Track the old oracle for the comptroller\n\n        PriceOracle oldOracle = oracle;\n\n\n\n        // Set comptroller's oracle to newOracle\n\n        oracle = newOracle;\n\n\n\n        // Emit NewPriceOracle(oldOracle, newOracle)\n\n        emit NewPriceOracle(oldOracle, newOracle);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
          "message": "Function 'Comptroller._setPriceOracle' (VBep20Harness.sol#5515-5534) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 5539,
          "vulnerability_to_line": 5551,
          "vulnerability_code": "    function _setCloseFactor(uint newCloseFactorMantissa) external returns (uint) {\n\n        // Check caller is admin\n\n    \trequire(msg.sender == admin, \"only admin can set close factor\");\n\n\n\n        uint oldCloseFactorMantissa = closeFactorMantissa;\n\n        closeFactorMantissa = newCloseFactorMantissa;\n\n        emit NewCloseFactor(oldCloseFactorMantissa, newCloseFactorMantissa);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
          "message": "Function 'Comptroller._setCloseFactor' (VBep20Harness.sol#5539-5551) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 5557,
          "vulnerability_to_line": 5593,
          "vulnerability_code": "    function _setCollateralFactor(VToken vToken, uint newCollateralFactorMantissa) external returns (uint) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COLLATERAL_FACTOR_OWNER_CHECK);\n\n        }\n\n\n\n        // Verify market is listed\n\n        Market storage market = markets[address(vToken)];\n\n        if (!market.isListed) {\n\n            return fail(Error.MARKET_NOT_LISTED, FailureInfo.SET_COLLATERAL_FACTOR_NO_EXISTS);\n\n        }\n\n\n\n        Exp memory newCollateralFactorExp = Exp({mantissa: newCollateralFactorMantissa});\n\n\n\n        // Check collateral factor <= 0.9\n\n        Exp memory highLimit = Exp({mantissa: collateralFactorMaxMantissa});\n\n        if (lessThanExp(highLimit, newCollateralFactorExp)) {\n\n            return fail(Error.INVALID_COLLATERAL_FACTOR, FailureInfo.SET_COLLATERAL_FACTOR_VALIDATION);\n\n        }\n\n\n\n        // If collateral factor != 0, fail if price == 0\n\n        if (newCollateralFactorMantissa != 0 && oracle.getUnderlyingPrice(vToken) == 0) {\n\n            return fail(Error.PRICE_ERROR, FailureInfo.SET_COLLATERAL_FACTOR_WITHOUT_PRICE);\n\n        }\n\n\n\n        // Set market's collateral factor to new collateral factor, remember old value\n\n        uint oldCollateralFactorMantissa = market.collateralFactorMantissa;\n\n        market.collateralFactorMantissa = newCollateralFactorMantissa;\n\n\n\n        // Emit event with asset, old collateral factor, and new collateral factor\n\n        emit NewCollateralFactor(vToken, oldCollateralFactorMantissa, newCollateralFactorMantissa);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
          "message": "Function 'Comptroller._setCollateralFactor' (VBep20Harness.sol#5557-5593) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 5598,
          "vulnerability_to_line": 5617,
          "vulnerability_code": "    function _setLiquidationIncentive(uint newLiquidationIncentiveMantissa) external returns (uint) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_LIQUIDATION_INCENTIVE_OWNER_CHECK);\n\n        }\n\n\n\n        // Save current value for use in log\n\n        uint oldLiquidationIncentiveMantissa = liquidationIncentiveMantissa;\n\n\n\n        // Set liquidation incentive to new incentive\n\n        liquidationIncentiveMantissa = newLiquidationIncentiveMantissa;\n\n\n\n        // Emit event with old incentive, new incentive\n\n        emit NewLiquidationIncentive(oldLiquidationIncentiveMantissa, newLiquidationIncentiveMantissa);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
          "message": "Function 'Comptroller._setLiquidationIncentive' (VBep20Harness.sol#5598-5617) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 5622,
          "vulnerability_to_line": 5643,
          "vulnerability_code": "    function _supportMarket(VToken vToken) external returns (uint) {\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SUPPORT_MARKET_OWNER_CHECK);\n\n        }\n\n\n\n        if (markets[address(vToken)].isListed) {\n\n            return fail(Error.MARKET_ALREADY_LISTED, FailureInfo.SUPPORT_MARKET_EXISTS);\n\n        }\n\n\n\n        vToken.isVToken(); // Sanity check to make sure its really a VToken\n\n\n\n        // Note that isVenus is not in active use anymore\n\n        markets[address(vToken)] = Market({isListed: true, isVenus: false, collateralFactorMantissa: 0});\n\n\n\n        _addMarketInternal(vToken);\n\n\n\n        emit MarketListed(vToken);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Function 'Comptroller._supportMarket' (VBep20Harness.sol#5622-5643) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 5643,
          "vulnerability_to_line": 5651,
          "vulnerability_code": "    function _addMarketInternal(VToken vToken) internal {\n\n        for (uint i = 0; i < allMarkets.length; i ++) {\n\n            require(allMarkets[i] != vToken, \"market already added\");\n\n        }\n\n        allMarkets.push(vToken);\n\n    }\n\n\n\n    /**\n",
          "message": "Function 'Comptroller._addMarketInternal' (VBep20Harness.sol#5643-5651) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 5655,
          "vulnerability_to_line": 5673,
          "vulnerability_code": "    function _setPauseGuardian(address newPauseGuardian) public returns (uint) {\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PAUSE_GUARDIAN_OWNER_CHECK);\n\n        }\n\n\n\n        // Save current value for inclusion in log\n\n        address oldPauseGuardian = pauseGuardian;\n\n\n\n        // Store pauseGuardian with value newPauseGuardian\n\n        pauseGuardian = newPauseGuardian;\n\n\n\n        // Emit NewPauseGuardian(OldPauseGuardian, NewPauseGuardian)\n\n        emit NewPauseGuardian(oldPauseGuardian, newPauseGuardian);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
          "message": "Function 'Comptroller._setPauseGuardian' (VBep20Harness.sol#5655-5673) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 5678,
          "vulnerability_to_line": 5693,
          "vulnerability_code": "    function _setMarketBorrowCaps(VToken[] calldata vTokens, uint[] calldata newBorrowCaps) external {\n\n        require(msg.sender == admin || msg.sender == borrowCapGuardian, \"only admin or borrow cap guardian can set borrow caps\");\n\n\n\n        uint numMarkets = vTokens.length;\n\n        uint numBorrowCaps = newBorrowCaps.length;\n\n\n\n        require(numMarkets != 0 && numMarkets == numBorrowCaps, \"invalid input\");\n\n\n\n        for(uint i = 0; i < numMarkets; i++) {\n\n            borrowCaps[address(vTokens[i])] = newBorrowCaps[i];\n\n            emit NewBorrowCap(vTokens[i], newBorrowCaps[i]);\n\n        }\n\n    }\n\n\n\n    /**\n",
          "message": "Function 'Comptroller._setMarketBorrowCaps' (VBep20Harness.sol#5678-5693) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 5696,
          "vulnerability_to_line": 5708,
          "vulnerability_code": "    function _setBorrowCapGuardian(address newBorrowCapGuardian) external onlyAdmin {\n\n        // Save current value for inclusion in log\n\n        address oldBorrowCapGuardian = borrowCapGuardian;\n\n\n\n        // Store borrowCapGuardian with value newBorrowCapGuardian\n\n        borrowCapGuardian = newBorrowCapGuardian;\n\n\n\n        // Emit NewBorrowCapGuardian(OldBorrowCapGuardian, NewBorrowCapGuardian)\n\n        emit NewBorrowCapGuardian(oldBorrowCapGuardian, newBorrowCapGuardian);\n\n    }\n\n\n\n    /**\n",
          "message": "Function 'Comptroller._setBorrowCapGuardian' (VBep20Harness.sol#5696-5708) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 5710,
          "vulnerability_to_line": 5717,
          "vulnerability_code": "    function _setProtocolPaused(bool state) public validPauseState(state) returns(bool) {\n\n        protocolPaused = state;\n\n        emit ActionProtocolPaused(state);\n\n        return state;\n\n    }\n\n\n\n    /**\n",
          "message": "Function 'Comptroller._setProtocolPaused' (VBep20Harness.sol#5710-5717) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 5721,
          "vulnerability_to_line": 5732,
          "vulnerability_code": "    function _setVAIController(VAIControllerInterface vaiController_) external returns (uint) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_VAICONTROLLER_OWNER_CHECK);\n\n        }\n\n\n\n        VAIControllerInterface oldRate = vaiController;\n\n        vaiController = vaiController_;\n\n        emit NewVAIController(oldRate, vaiController_);\n\n    }\n\n\n",
          "message": "Function 'Comptroller._setVAIController' (VBep20Harness.sol#5721-5732) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 5732,
          "vulnerability_to_line": 5745,
          "vulnerability_code": "    function _setVAIMintRate(uint newVAIMintRate) external returns (uint) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_VAI_MINT_RATE_CHECK);\n\n        }\n\n\n\n        uint oldVAIMintRate = vaiMintRate;\n\n        vaiMintRate = newVAIMintRate;\n\n        emit NewVAIMintRate(oldVAIMintRate, newVAIMintRate);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Function 'Comptroller._setVAIMintRate' (VBep20Harness.sol#5732-5745) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 5745,
          "vulnerability_to_line": 5768,
          "vulnerability_code": "    function _setTreasuryData(address newTreasuryGuardian, address newTreasuryAddress, uint newTreasuryPercent) external returns (uint) {\n\n        // Check caller is admin\n\n        if (!(msg.sender == admin || msg.sender == treasuryGuardian)) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_TREASURY_OWNER_CHECK);\n\n        }\n\n\n\n        require(newTreasuryPercent < 1e18, \"treasury percent cap overflow\");\n\n\n\n        address oldTreasuryGuardian = treasuryGuardian;\n\n        address oldTreasuryAddress = treasuryAddress;\n\n        uint oldTreasuryPercent = treasuryPercent;\n\n\n\n        treasuryGuardian = newTreasuryGuardian;\n\n        treasuryAddress = newTreasuryAddress;\n\n        treasuryPercent = newTreasuryPercent;\n\n\n\n        emit NewTreasuryGuardian(oldTreasuryGuardian, newTreasuryGuardian);\n\n        emit NewTreasuryAddress(oldTreasuryAddress, newTreasuryAddress);\n\n        emit NewTreasuryPercent(oldTreasuryPercent, newTreasuryPercent);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Function 'Comptroller._setTreasuryData' (VBep20Harness.sol#5745-5768) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 5768,
          "vulnerability_to_line": 5774,
          "vulnerability_code": "    function _become(Unitroller unitroller) public {\n\n        require(msg.sender == unitroller.admin(), \"only unitroller admin can\");\n\n        require(unitroller._acceptImplementation() == 0, \"not authorized\");\n\n    }\n\n\n\n    /**\n",
          "message": "Function 'Comptroller._become' (VBep20Harness.sol#5768-5774) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 6017,
          "vulnerability_to_line": 6024,
          "vulnerability_code": "    function _setVenusVAIRate(uint venusVAIRate_) public onlyAdmin {\n\n        uint oldVAIRate = venusVAIRate;\n\n        venusVAIRate = venusVAIRate_;\n\n        emit NewVenusVAIRate(oldVAIRate, venusVAIRate_);\n\n    }\n\n\n\n    /**\n",
          "message": "Function 'Comptroller._setVenusVAIRate' (VBep20Harness.sol#6017-6024) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 6027,
          "vulnerability_to_line": 6034,
          "vulnerability_code": "    function _setVenusVAIVaultRate(uint venusVAIVaultRate_) public onlyAdmin {\n\n        uint oldVenusVAIVaultRate = venusVAIVaultRate;\n\n        venusVAIVaultRate = venusVAIVaultRate_;\n\n        emit NewVenusVAIVaultRate(oldVenusVAIVaultRate, venusVAIVaultRate_);\n\n    }\n\n\n\n    /**\n",
          "message": "Function 'Comptroller._setVenusVAIVaultRate' (VBep20Harness.sol#6027-6034) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 6039,
          "vulnerability_to_line": 6047,
          "vulnerability_code": "    function _setVAIVaultInfo(address vault_, uint256 releaseStartBlock_, uint256 minReleaseAmount_) public onlyAdmin {\n\n        vaiVaultAddress = vault_;\n\n        releaseStartBlock = releaseStartBlock_;\n\n        minReleaseAmount = minReleaseAmount_;\n\n        emit NewVAIVaultInfo(vault_, releaseStartBlock_, minReleaseAmount_);\n\n    }\n\n\n\n    /**\n",
          "message": "Function 'Comptroller._setVAIVaultInfo' (VBep20Harness.sol#6039-6047) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 6051,
          "vulnerability_to_line": 6057,
          "vulnerability_code": "    function _setVenusSpeed(VToken vToken, uint venusSpeed) public {\n\n        require(adminOrInitializing(), \"only admin can set venus speed\");\n\n        setVenusSpeedInternal(vToken, venusSpeed);\n\n    }\n\n\n\n    /**\n",
          "message": "Function 'Comptroller._setVenusSpeed' (VBep20Harness.sol#6051-6057) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 4738,
          "vulnerability_to_line": 4740,
          "vulnerability_code": "    uint224 public constant venusInitialIndex = 1e36;\n\n\n",
          "message": "Constant 'Comptroller.venusInitialIndex' (VBep20Harness.sol#4738-4740) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 4741,
          "vulnerability_to_line": 4742,
          "vulnerability_code": "    uint internal constant closeFactorMinMantissa = 0.05e18; // 0.05\n",
          "message": "Constant 'Comptroller.closeFactorMinMantissa' (VBep20Harness.sol#4741-4742) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 4744,
          "vulnerability_to_line": 4746,
          "vulnerability_code": "    uint internal constant closeFactorMaxMantissa = 0.9e18; // 0.9\n\n\n",
          "message": "Constant 'Comptroller.closeFactorMaxMantissa' (VBep20Harness.sol#4744-4746) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 4747,
          "vulnerability_to_line": 4749,
          "vulnerability_code": "    uint internal constant collateralFactorMaxMantissa = 0.9e18; // 0.9\n\n\n",
          "message": "Constant 'Comptroller.collateralFactorMaxMantissa' (VBep20Harness.sol#4747-4749) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 6291,
          "vulnerability_to_line": 6292,
          "vulnerability_code": "    function harnessSetAccrualBlockNumber(uint _accrualblockNumber) public {\n",
          "message": "Parameter '_accrualblockNumber' of VBep20Harness.harnessSetAccrualBlockNumber (VBep20Harness.sol#6291-6292) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 6330,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function harnessSetFailTransferToAddress(address _to, bool _fail) public {\n",
          "message": "Parameter '_to' of VBep20Harness.harnessSetFailTransferToAddress (VBep20Harness.sol#6330) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 6330,
          "vulnerability_to_line": 6331,
          "vulnerability_code": "    function harnessSetFailTransferToAddress(address _to, bool _fail) public {\n",
          "message": "Parameter '_fail' of VBep20Harness.harnessSetFailTransferToAddress (VBep20Harness.sol#6330-6331) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 6522,
          "vulnerability_to_line": 6523,
          "vulnerability_code": "    function harnessSetAccrualBlockNumber(uint _accrualblockNumber) public {\n",
          "message": "Parameter '_accrualblockNumber' of VBep20DelegateHarness.harnessSetAccrualBlockNumber (VBep20Harness.sol#6522-6523) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 6553,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function harnessSetFailTransferToAddress(address _to, bool _fail) public {\n",
          "message": "Parameter '_to' of VBep20DelegateHarness.harnessSetFailTransferToAddress (VBep20Harness.sol#6553) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 6553,
          "vulnerability_to_line": 6554,
          "vulnerability_code": "    function harnessSetFailTransferToAddress(address _to, bool _fail) public {\n",
          "message": "Parameter '_fail' of VBep20DelegateHarness.harnessSetFailTransferToAddress (VBep20Harness.sol#6553-6554) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 6654,
          "vulnerability_to_line": 6655,
          "vulnerability_code": "    function harnessSetAccrualBlockNumber(uint _accrualblockNumber) public {\n",
          "message": "Parameter '_accrualblockNumber' of VDaiDelegateHarness.harnessSetAccrualBlockNumber (VBep20Harness.sol#6654-6655) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 6702,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function pie(address) external view returns (uint) { return 0; }\n",
          "message": "Parameter '' of VDaiDelegateMakerHarness.pie (VBep20Harness.sol#6702) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 6708,
          "vulnerability_to_line": 6710,
          "vulnerability_code": "    function join(uint) external {}\n\n\n",
          "message": "Parameter '' of VDaiDelegateMakerHarness.join (VBep20Harness.sol#6708-6710) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 6711,
          "vulnerability_to_line": 6713,
          "vulnerability_code": "    function exit(uint) external {}\n\n\n",
          "message": "Parameter '' of VDaiDelegateMakerHarness.exit (VBep20Harness.sol#6711-6713) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 6716,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function dai(address) external view returns (uint) { return 0; }\n",
          "message": "Parameter '' of VDaiDelegateMakerHarness.dai (VBep20Harness.sol#6716) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 6719,
          "vulnerability_to_line": 6721,
          "vulnerability_code": "    function hope(address) external {}\n\n\n",
          "message": "Parameter '' of VDaiDelegateMakerHarness.hope (VBep20Harness.sol#6719-6721) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 6726,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function approve(address, uint) external {}\n",
          "message": "Parameter '' of VDaiDelegateMakerHarness.approve (VBep20Harness.sol#6726) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 6726,
          "vulnerability_to_line": 6727,
          "vulnerability_code": "    function approve(address, uint) external {}\n",
          "message": "Parameter '_scope_0' of VDaiDelegateMakerHarness.approve (VBep20Harness.sol#6726-6727) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 6746,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function join(address, uint) external payable {}\n",
          "message": "Parameter '' of VDaiDelegateMakerHarness.join (VBep20Harness.sol#6746) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 6746,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function join(address, uint) external payable {}\n",
          "message": "Parameter '_scope_0' of VDaiDelegateMakerHarness.join (VBep20Harness.sol#6746) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 6749,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function exit(address, uint) external {}\n",
          "message": "Parameter '' of VDaiDelegateMakerHarness.exit (VBep20Harness.sol#6749) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 6749,
          "vulnerability_to_line": 6750,
          "vulnerability_code": "    function exit(address, uint) external {}\n",
          "message": "Parameter '_scope_0' of VDaiDelegateMakerHarness.exit (VBep20Harness.sol#6749-6750) is not in mixedCase\n"
        },
        {
          "name": "unused-state",
          "vulnerability_from_line": 823,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint constant halfExpScale = expScale/2;\n",
          "message": "ExponentialNoError.halfExpScale (VBep20Harness.sol#823) is never used in ComptrollerScenario\nExponentialNoError.mantissaOne (VBep20Harness.sol#824) is never used in ComptrollerScenario\nComptroller.closeFactorMinMantissa (VBep20Harness.sol#4741-4742) is never used in ComptrollerScenario\nComptroller.closeFactorMaxMantissa (VBep20Harness.sol#4744-4746) is never used in ComptrollerScenario\n"
        },
        {
          "name": "unused-state",
          "vulnerability_from_line": 137,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bool internal _notEntered;\n",
          "message": "VTokenStorage._notEntered (VBep20Harness.sol#137) is never used in VBep20DelegatorScenario\nVTokenStorage.borrowRateMaxMantissa (VBep20Harness.sol#158) is never used in VBep20DelegatorScenario\nVTokenStorage.reserveFactorMaxMantissa (VBep20Harness.sol#163) is never used in VBep20DelegatorScenario\nVTokenStorage.initialExchangeRateMantissa (VBep20Harness.sol#188) is never used in VBep20DelegatorScenario\nVTokenStorage.accountTokens (VBep20Harness.sol#223) is never used in VBep20DelegatorScenario\nVTokenStorage.transferAllowances (VBep20Harness.sol#228) is never used in VBep20DelegatorScenario\nVTokenStorage.accountBorrows (VBep20Harness.sol#243) is never used in VBep20DelegatorScenario\n"
        }
      ]
    },
    "smartcheck": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 6074,
          "vulnerability_to_line": null,
          "vulnerability_code": "        return 0xcF6BB5389c92Bdda8a3747Ddb454cB7a64626C63;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 6637,
          "vulnerability_to_line": null,
          "vulnerability_code": "      admin = address(1); // make a change to test effect\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 3513,
          "vulnerability_to_line": null,
          "vulnerability_code": "            implementation = address(0);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 3525,
          "vulnerability_to_line": null,
          "vulnerability_code": "            implementation = address(0);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 4024,
          "vulnerability_to_line": null,
          "vulnerability_code": "        pendingComptrollerImplementation = address(0);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 4076,
          "vulnerability_to_line": null,
          "vulnerability_code": "        pendingAdmin = address(0);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ARRAY_LENGTH_MANIPULATION",
          "vulnerability_from_line": 4885,
          "vulnerability_to_line": null,
          "vulnerability_code": "                userAssetList.length--;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ERC20_APPROVE",
          "vulnerability_from_line": 1483,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function approve(address spender, uint256 amount) external returns (bool) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ERC20_APPROVE",
          "vulnerability_from_line": 4235,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function approve(address spender, uint rawAmount) external validLock returns (bool) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 5386,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < assets.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 5644,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < allMarkets.length; i ++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 5969,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (j = 0; j < holders.length; j++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 5973,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < vTokens.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 5979,
          "vulnerability_to_line": null,
          "vulnerability_code": "                for (j = 0; j < holders.length; j++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 5986,
          "vulnerability_to_line": null,
          "vulnerability_code": "                for (j = 0; j < holders.length; j++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 6211,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < allMarkets_.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 6220,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < allMarkets_.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 6230,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < allMarkets_.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 4804,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < len; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 5386,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < assets.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 5644,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < allMarkets.length; i ++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 5686,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(uint i = 0; i < numMarkets; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 5969,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (j = 0; j < holders.length; j++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 5973,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < vTokens.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 5979,
          "vulnerability_to_line": null,
          "vulnerability_code": "                for (j = 0; j < holders.length; j++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 5986,
          "vulnerability_to_line": null,
          "vulnerability_code": "                for (j = 0; j < holders.length; j++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 6185,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < m; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 6193,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < m; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 6211,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < allMarkets_.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 6220,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < allMarkets_.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 6230,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < allMarkets_.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 4358,
          "vulnerability_to_line": null,
          "vulnerability_code": "        while (upper > lower) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_LOCKED_MONEY",
          "vulnerability_from_line": 246,
          "vulnerability_to_line": null,
          "vulnerability_code": "contract VTokenInterface is VTokenStorage {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_LOCKED_MONEY",
          "vulnerability_from_line": 2989,
          "vulnerability_to_line": null,
          "vulnerability_code": "contract VBep20Immutable is VBep20 {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_LOCKED_MONEY",
          "vulnerability_from_line": 3029,
          "vulnerability_to_line": null,
          "vulnerability_code": "contract VBep20Delegator is VTokenInterface, VBep20Interface, VDelegatorInterface {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_LOCKED_MONEY",
          "vulnerability_from_line": 3964,
          "vulnerability_to_line": null,
          "vulnerability_code": "contract Unitroller is UnitrollerAdminStorage, ComptrollerErrorReporter {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_LOCKED_MONEY",
          "vulnerability_from_line": 6246,
          "vulnerability_to_line": null,
          "vulnerability_code": "contract VBep20Harness is VBep20Immutable {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_LOCKED_MONEY",
          "vulnerability_from_line": 6391,
          "vulnerability_to_line": null,
          "vulnerability_code": "contract VBep20Scenario is VBep20Immutable {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_LOCKED_MONEY",
          "vulnerability_from_line": 6424,
          "vulnerability_to_line": null,
          "vulnerability_code": "contract VEvil is VBep20Scenario {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_LOCKED_MONEY",
          "vulnerability_from_line": 6448,
          "vulnerability_to_line": null,
          "vulnerability_code": "contract VBep20DelegatorScenario is VBep20Delegator {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_LOCKED_MONEY",
          "vulnerability_from_line": 6480,
          "vulnerability_to_line": null,
          "vulnerability_code": "contract VBep20DelegateHarness is VBep20Delegate {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_LOCKED_MONEY",
          "vulnerability_from_line": 6695,
          "vulnerability_to_line": null,
          "vulnerability_code": "contract VDaiDelegateMakerHarness is PotLike, VatLike, GemLike, DaiJoinLike {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 97,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 130,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 438,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 723,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 811,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 1009,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 1192,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 1256,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 1328,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 2783,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 2982,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 3022,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 3490,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 3534,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 3743,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 3760,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 3775,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 3956,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 4106,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 4469,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity >=0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 4519,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity >=0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 4645,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 6139,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 6240,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 4445,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getChainId() internal pure returns (uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 72,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint repayAmount) external view returns (uint, uint);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 79,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint repayAmount) external view returns (uint, uint);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 352,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 746,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function mulUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 763,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function divUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 774,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function subUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 785,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function addUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 798,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function addThenSubUInt(uint a, uint b, uint c) internal pure returns (MathError, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 1025,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getExp(uint num, uint denom) internal pure returns (MathError, Exp memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 1042,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function addExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 1051,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function subExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 1060,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function mulScalar(Exp memory a, uint scalar) internal pure returns (MathError, Exp memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 1072,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function mulScalarTruncate(Exp memory a, uint scalar) internal pure returns (MathError, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 1084,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function mulScalarTruncateAddUInt(Exp memory a, uint scalar, uint addend) internal pure returns (MathError, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 1096,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function divScalar(Exp memory a, uint scalar) internal pure returns (MathError, Exp memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 1108,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function divScalarByExp(uint scalar, Exp memory divisor) internal pure returns (MathError, Exp memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 1128,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function divScalarByExpTruncate(uint scalar, Exp memory divisor) internal pure returns (MathError, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 1140,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function mulExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 1165,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function mulExp(uint a, uint b) internal pure returns (MathError, Exp memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 1172,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function mulExp3(Exp memory a, Exp memory b, Exp memory c) internal pure returns (MathError, Exp memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 1185,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function divExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 1528,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 1607,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 1664,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function exchangeRateStoredInternal() internal view returns (MathError, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 1795,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function mintInternal(uint mintAmount) internal nonReentrant returns (uint, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 1822,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function mintFresh(address minter, uint mintAmount) internal returns (uint, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 3764,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getMintableVAI(address minter) public view returns (uint, uint);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 3770,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function calcDistributeVAIMinterVenus(address vaiMinter) external returns(uint, uint, uint, uint);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 5338,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getAccountLiquidity(address account) public view returns (uint, uint, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 5358,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint borrowAmount) public view returns (uint, uint, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 5379,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint borrowAmount) internal view returns (Error, uint, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 5443,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function liquidateCalculateSeizeTokens(address vTokenBorrowed, address vTokenCollateral, uint actualRepayAmount) external view returns (uint, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 5479,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function liquidateVAICalculateSeizeTokens(address vTokenCollateral, uint actualRepayAmount) external view returns (uint, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 6490,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function exchangeRateStoredInternal() internal view returns (MathError, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UNCHECKED_CALL",
          "vulnerability_from_line": 4091,
          "vulnerability_to_line": null,
          "vulnerability_code": "        (bool success, ) = comptrollerImplementation.delegatecall(msg.data);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 2928,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 4093,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 4447,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly { chainId := chainid() }\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 4482,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 367,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1938,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 2958,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function doTransferOut(address payable to, uint amount) internal {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 3001,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor(address underlying_,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 3043,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor(address underlying_,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 3688,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function doTransferOut(address payable to, uint amount) internal {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 6253,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor(address underlying_,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 6392,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor(address underlying_,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 6425,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor(address underlying_,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 6449,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor(address underlying_,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 6497,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function doTransferOut(address payable to, uint amount) internal {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 367,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 821,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint constant expScale = 1e18;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 822,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint constant doubleScale = 1e36;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 823,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint constant halfExpScale = expScale/2;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 824,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint constant mantissaOne = expScale;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1938,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1938,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1938,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1938,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1939,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1941,
          "vulnerability_to_line": null,
          "vulnerability_code": "        RedeemLocalVars memory vars;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1944,
          "vulnerability_to_line": null,
          "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1944,
          "vulnerability_to_line": null,
          "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1944,
          "vulnerability_to_line": null,
          "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1944,
          "vulnerability_to_line": null,
          "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1945,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (vars.mathErr != MathError.NO_ERROR) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1945,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (vars.mathErr != MathError.NO_ERROR) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1946,
          "vulnerability_to_line": null,
          "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1946,
          "vulnerability_to_line": null,
          "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1946,
          "vulnerability_to_line": null,
          "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1946,
          "vulnerability_to_line": null,
          "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1946,
          "vulnerability_to_line": null,
          "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 2958,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function doTransferOut(address payable to, uint amount) internal {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 2958,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function doTransferOut(address payable to, uint amount) internal {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 2959,
          "vulnerability_to_line": null,
          "vulnerability_code": "        EIP20NonStandardInterface token = EIP20NonStandardInterface(underlying);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 2960,
          "vulnerability_to_line": null,
          "vulnerability_code": "        token.transfer(to, amount);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 2960,
          "vulnerability_to_line": null,
          "vulnerability_code": "        token.transfer(to, amount);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 2962,
          "vulnerability_to_line": null,
          "vulnerability_code": "        bool success;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 2964,
          "vulnerability_to_line": null,
          "vulnerability_code": "            switch returndatasize()\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 2964,
          "vulnerability_to_line": null,
          "vulnerability_code": "            switch returndatasize()\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 2966,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    success := not(0)          // set success to true\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 2966,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    success := not(0)          // set success to true\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 3013,
          "vulnerability_to_line": null,
          "vulnerability_code": "        initialize(underlying_, comptroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 3013,
          "vulnerability_to_line": null,
          "vulnerability_code": "        initialize(underlying_, comptroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 3013,
          "vulnerability_to_line": null,
          "vulnerability_code": "        initialize(underlying_, comptroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 3013,
          "vulnerability_to_line": null,
          "vulnerability_code": "        initialize(underlying_, comptroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 3016,
          "vulnerability_to_line": null,
          "vulnerability_code": "        admin = admin_;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 3050,
          "vulnerability_to_line": null,
          "vulnerability_code": "                address payable admin_,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 3051,
          "vulnerability_to_line": null,
          "vulnerability_code": "                address implementation_,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 3052,
          "vulnerability_to_line": null,
          "vulnerability_code": "                bytes memory becomeImplementationData) public {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 3054,
          "vulnerability_to_line": null,
          "vulnerability_code": "        admin = msg.sender;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 3054,
          "vulnerability_to_line": null,
          "vulnerability_code": "        admin = msg.sender;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 3057,
          "vulnerability_to_line": null,
          "vulnerability_code": "        delegateTo(implementation_, abi.encodeWithSignature(\"initialize(address,address,address,uint256,string,string,uint8)\",\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 3057,
          "vulnerability_to_line": null,
          "vulnerability_code": "        delegateTo(implementation_, abi.encodeWithSignature(\"initialize(address,address,address,uint256,string,string,uint8)\",\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 3057,
          "vulnerability_to_line": null,
          "vulnerability_code": "        delegateTo(implementation_, abi.encodeWithSignature(\"initialize(address,address,address,uint256,string,string,uint8)\",\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 3059,
          "vulnerability_to_line": null,
          "vulnerability_code": "                                                            comptroller_,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 3061,
          "vulnerability_to_line": null,
          "vulnerability_code": "                                                            initialExchangeRateMantissa_,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 3063,
          "vulnerability_to_line": null,
          "vulnerability_code": "                                                            symbol_,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 3067,
          "vulnerability_to_line": null,
          "vulnerability_code": "        _setImplementation(implementation_, false, becomeImplementationData);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 3067,
          "vulnerability_to_line": null,
          "vulnerability_code": "        _setImplementation(implementation_, false, becomeImplementationData);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 3070,
          "vulnerability_to_line": null,
          "vulnerability_code": "        admin = admin_;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 3688,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function doTransferOut(address payable to, uint amount) internal {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 3688,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function doTransferOut(address payable to, uint amount) internal {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 3689,
          "vulnerability_to_line": null,
          "vulnerability_code": "        DaiJoinLike daiJoin = DaiJoinLike(daiJoinAddress);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 3690,
          "vulnerability_to_line": null,
          "vulnerability_code": "        PotLike pot = PotLike(potAddress);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 3694,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint pie = add(mul(amount, RAY) / pot.chi(), 1);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 3695,
          "vulnerability_to_line": null,
          "vulnerability_code": "        pot.exit(pie);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 3697,
          "vulnerability_to_line": null,
          "vulnerability_code": "        daiJoin.exit(to, amount);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 3697,
          "vulnerability_to_line": null,
          "vulnerability_code": "        daiJoin.exit(to, amount);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 4131,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint8 isLocked = 0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 6247,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint blockNumber = 100000;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 6248,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint harnessExchangeRate;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 6249,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bool harnessExchangeRateStored;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 6260,
          "vulnerability_to_line": null,
          "vulnerability_code": "                address payable admin_)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 6261,
          "vulnerability_to_line": null,
          "vulnerability_code": "    VBep20Immutable(\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 6264,
          "vulnerability_to_line": null,
          "vulnerability_code": "    interestRateModel_,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 6266,
          "vulnerability_to_line": null,
          "vulnerability_code": "    name_,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 6268,
          "vulnerability_to_line": null,
          "vulnerability_code": "    decimals_,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 6399,
          "vulnerability_to_line": null,
          "vulnerability_code": "                address payable admin_)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 6400,
          "vulnerability_to_line": null,
          "vulnerability_code": "    VBep20Immutable(\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 6403,
          "vulnerability_to_line": null,
          "vulnerability_code": "    interestRateModel_,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 6405,
          "vulnerability_to_line": null,
          "vulnerability_code": "    name_,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 6407,
          "vulnerability_to_line": null,
          "vulnerability_code": "    decimals_,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 6432,
          "vulnerability_to_line": null,
          "vulnerability_code": "                address payable admin_)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 6433,
          "vulnerability_to_line": null,
          "vulnerability_code": "    VBep20Scenario(\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 6436,
          "vulnerability_to_line": null,
          "vulnerability_code": "    interestRateModel_,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 6438,
          "vulnerability_to_line": null,
          "vulnerability_code": "    name_,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 6440,
          "vulnerability_to_line": null,
          "vulnerability_code": "    decimals_,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 6456,
          "vulnerability_to_line": null,
          "vulnerability_code": "                address payable admin_,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 6457,
          "vulnerability_to_line": null,
          "vulnerability_code": "                address implementation_,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 6458,
          "vulnerability_to_line": null,
          "vulnerability_code": "                bytes memory becomeImplementationData)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 6459,
          "vulnerability_to_line": null,
          "vulnerability_code": "    VBep20Delegator(\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 6461,
          "vulnerability_to_line": null,
          "vulnerability_code": "    comptroller_,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 6463,
          "vulnerability_to_line": null,
          "vulnerability_code": "    initialExchangeRateMantissa_,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 6465,
          "vulnerability_to_line": null,
          "vulnerability_code": "    symbol_,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 6467,
          "vulnerability_to_line": null,
          "vulnerability_code": "    admin_,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 6484,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint blockNumber = 100000;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 6485,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint harnessExchangeRate;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 6486,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bool harnessExchangeRateStored;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 6497,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function doTransferOut(address payable to, uint amount) internal {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 6497,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function doTransferOut(address payable to, uint amount) internal {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 6498,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(failTransferToAddresses[to] == false, \"TOKEN_TRANSFER_OUT_FAILED\");\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 6498,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(failTransferToAddresses[to] == false, \"TOKEN_TRANSFER_OUT_FAILED\");\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 6499,
          "vulnerability_to_line": null,
          "vulnerability_code": "        return super.doTransferOut(to, amount);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 6499,
          "vulnerability_to_line": null,
          "vulnerability_code": "        return super.doTransferOut(to, amount);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 6646,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint blockNumber = 100000;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 6647,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint harnessExchangeRate;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 6648,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bool harnessExchangeRateStored;\n",
          "message": null
        }
      ]
    },
    "oyente": {
      "successfull_analysis": false,
      "errors": [
        "exception (RuntimeError: Source map error, unknown name(SHR) or instr_name(INVALID))"
      ],
      "vulnerability_findings": []
    },
    "mythril": {
      "successfull_analysis": false,
      "errors": [
        "DOCKER_TIMEOUT"
      ],
      "vulnerability_findings": []
    },
    "osiris": {
      "successfull_analysis": false,
      "errors": [
        "Solidity compilation failed"
      ],
      "vulnerability_findings": []
    }
  }
}