{
  "smartbugs_completed": true,
  "analyzer_results": {
    "semgrep": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 229,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor() public {\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 230,
          "vulnerability_to_line": null,
          "vulnerability_code": "        setUpgradeabilityOwner(msg.sender);\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 231,
          "vulnerability_to_line": null,
          "vulnerability_code": "    }\n",
          "message": "Consider making costructor payable to save gas."
        }
      ]
    },
    "slither": {
      "successfull_analysis": true,
      "errors": [
        "EXIT_CODE_19"
      ],
      "vulnerability_findings": [
        {
          "name": "uninitialized-state",
          "vulnerability_from_line": 12,
          "vulnerability_to_line": null,
          "vulnerability_code": "    mapping(bytes32 => uint256) internal uintStorage;\n",
          "message": "EternalStorage.uintStorage (ClassicEternalStorageProxy.sol#12) is never initialized. It is used in:\n\t- getSize (ClassicEternalStorageProxy.sol#304-310)\n"
        },
        {
          "name": "shadowing-local",
          "vulnerability_from_line": 171,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _upgradeTo(uint256 version, address implementation) internal {\n",
          "message": "UpgradeabilityProxy._upgradeTo.version (local variable @ ClassicEternalStorageProxy.sol#171) shadows:\n\t- UpgradeabilityStorage.version (function @ ClassicEternalStorageProxy.sol#136-138)\n"
        },
        {
          "name": "shadowing-local",
          "vulnerability_from_line": 171,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _upgradeTo(uint256 version, address implementation) internal {\n",
          "message": "UpgradeabilityProxy._upgradeTo.implementation (local variable @ ClassicEternalStorageProxy.sol#171) shadows:\n\t- UpgradeabilityStorage.implementation (function @ ClassicEternalStorageProxy.sol#144-146)\n\t- Proxy.implementation (function @ ClassicEternalStorageProxy.sol#36)\n"
        },
        {
          "name": "shadowing-local",
          "vulnerability_from_line": 264,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function upgradeTo(uint256 version, address implementation) public onlyProxyOwner {\n",
          "message": "OwnedUpgradeabilityProxy.upgradeTo.version (local variable @ ClassicEternalStorageProxy.sol#264) shadows:\n\t- UpgradeabilityStorage.version (function @ ClassicEternalStorageProxy.sol#136-138)\n"
        },
        {
          "name": "shadowing-local",
          "vulnerability_from_line": 264,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function upgradeTo(uint256 version, address implementation) public onlyProxyOwner {\n",
          "message": "OwnedUpgradeabilityProxy.upgradeTo.implementation (local variable @ ClassicEternalStorageProxy.sol#264) shadows:\n\t- UpgradeabilityStorage.implementation (function @ ClassicEternalStorageProxy.sol#144-146)\n\t- Proxy.implementation (function @ ClassicEternalStorageProxy.sol#36)\n"
        },
        {
          "name": "shadowing-local",
          "vulnerability_from_line": 276,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function upgradeToAndCall(uint256 version, address implementation, bytes data) payable public onlyProxyOwner {\n",
          "message": "OwnedUpgradeabilityProxy.upgradeToAndCall.version (local variable @ ClassicEternalStorageProxy.sol#276) shadows:\n\t- UpgradeabilityStorage.version (function @ ClassicEternalStorageProxy.sol#136-138)\n"
        },
        {
          "name": "shadowing-local",
          "vulnerability_from_line": 276,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function upgradeToAndCall(uint256 version, address implementation, bytes data) payable public onlyProxyOwner {\n",
          "message": "OwnedUpgradeabilityProxy.upgradeToAndCall.implementation (local variable @ ClassicEternalStorageProxy.sol#276) shadows:\n\t- UpgradeabilityStorage.implementation (function @ ClassicEternalStorageProxy.sol#144-146)\n\t- Proxy.implementation (function @ ClassicEternalStorageProxy.sol#36)\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 42,
          "vulnerability_to_line": 113,
          "vulnerability_code": "    function () payable public {\n\n        address _impl = implementation();\n\n        require(_impl != address(0));\n\n        assembly {\n\n            /*\n\n                0x40 is the \"free memory slot\", meaning a pointer to next slot of empty memory. mload(0x40)\n\n                loads the data in the free memory slot, so `ptr` is a pointer to the next slot of empty\n\n                memory. It's needed because we're going to write the return data of delegatecall to the\n\n                free memory slot.\n\n            */\n\n            let ptr := mload(0x40)\n\n            /*\n\n                `calldatacopy` is copy calldatasize bytes from calldata\n\n                First argument is the destination to which data is copied(ptr)\n\n                Second argument specifies the start position of the copied data.\n\n                    Since calldata is sort of its own unique location in memory,\n\n                    0 doesn't refer to 0 in memory or 0 in storage - it just refers to the zeroth byte of calldata.\n\n                    That's always going to be the zeroth byte of the function selector.\n\n                Third argument, calldatasize, specifies how much data will be copied.\n\n                    calldata is naturally calldatasize bytes long (same thing as msg.data.length)\n\n            */\n\n            calldatacopy(ptr, 0, calldatasize)\n\n            /*\n\n                delegatecall params explained:\n\n                gas: the amount of gas to provide for the call. `gas` is an Opcode that gives\n\n                    us the amount of gas still available to execution\n\n\n\n                _impl: address of the contract to delegate to\n\n\n\n                ptr: to pass copied data\n\n\n\n                calldatasize: loads the size of `bytes memory data`, same as msg.data.length\n\n\n\n                0, 0: These are for the `out` and `outsize` params. Because the output could be dynamic,\n\n                        these are set to 0, 0 so the output data will not be written to memory. The output\n\n                        data will be read using `returndatasize` and `returdatacopy` instead.\n\n\n\n                result: This will be 0 if the call fails and 1 if it succeeds\n\n            */\n\n            let result := delegatecall(gas, _impl, ptr, calldatasize, 0, 0)\n\n            /*\n\n\n\n            */\n\n            /*\n\n                ptr current points to the value stored at 0x40,\n\n                because we assigned it like ptr := mload(0x40).\n\n                Because we use 0x40 as a free memory pointer,\n\n                we want to make sure that the next time we want to allocate memory,\n\n                we aren't overwriting anything important.\n\n                So, by adding ptr and returndatasize,\n\n                we get a memory location beyond the end of the data we will be copying to ptr.\n\n                We place this in at 0x40, and any reads from 0x40 will now read from free memory\n\n            */\n\n            mstore(0x40, add(ptr, returndatasize))\n\n            /*\n\n                `returndatacopy` is an Opcode that copies the last return data to a slot. `ptr` is the\n\n                    slot it will copy to, 0 means copy from the beginning of the return data, and size is\n\n                    the amount of data to copy.\n\n                `returndatasize` is an Opcode that gives us the size of the last return data. In this case, that is the size of the data returned from delegatecall\n\n            */\n\n            returndatacopy(ptr, 0, returndatasize)\n\n\n\n            /*\n\n                if `result` is 0, revert.\n\n                if `result` is 1, return `size` amount of data from `ptr`. This is the data that was\n\n                copied to `ptr` from the delegatecall return data\n\n            */\n\n            switch result\n\n            case 0 { revert(ptr, returndatasize) }\n\n            default { return(ptr, returndatasize) }\n\n        }\n",
          "message": "Proxy.fallback uses assembly (ClassicEternalStorageProxy.sol#42-113)\n\t- ClassicEternalStorageProxy.sol#45-113\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 289,
          "vulnerability_to_line": 302,
          "vulnerability_code": "    function () payable public {\n\n        address _impl = implementation();\n\n        require(_impl != address(0));\n\n        uint256 len = getSize(msg.sig);\n\n        assembly {\n\n            let ptr := mload(0x40)\n\n            calldatacopy(ptr, 0, calldatasize)\n\n            let result := delegatecall(gas, _impl, ptr, calldatasize, 0, len)\n\n\n\n            switch result\n\n            case 0 { revert(0, len) }\n\n            default { return(0, len) }\n\n        }\n",
          "message": "ClassicEternalStorageProxy.fallback uses assembly (ClassicEternalStorageProxy.sol#289-302)\n\t- ClassicEternalStorageProxy.sol#293-302\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 289,
          "vulnerability_to_line": 302,
          "vulnerability_code": "    function () payable public {\n\n        address _impl = implementation();\n\n        require(_impl != address(0));\n\n        uint256 len = getSize(msg.sig);\n\n        assembly {\n\n            let ptr := mload(0x40)\n\n            calldatacopy(ptr, 0, calldatasize)\n\n            let result := delegatecall(gas, _impl, ptr, calldatasize, 0, len)\n\n\n\n            switch result\n\n            case 0 { revert(0, len) }\n\n            default { return(0, len) }\n\n        }\n",
          "message": "ClassicEternalStorageProxy.fallback (ClassicEternalStorageProxy.sol#289-302) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 42,
          "vulnerability_to_line": 113,
          "vulnerability_code": "    function () payable public {\n\n        address _impl = implementation();\n\n        require(_impl != address(0));\n\n        assembly {\n\n            /*\n\n                0x40 is the \"free memory slot\", meaning a pointer to next slot of empty memory. mload(0x40)\n\n                loads the data in the free memory slot, so `ptr` is a pointer to the next slot of empty\n\n                memory. It's needed because we're going to write the return data of delegatecall to the\n\n                free memory slot.\n\n            */\n\n            let ptr := mload(0x40)\n\n            /*\n\n                `calldatacopy` is copy calldatasize bytes from calldata\n\n                First argument is the destination to which data is copied(ptr)\n\n                Second argument specifies the start position of the copied data.\n\n                    Since calldata is sort of its own unique location in memory,\n\n                    0 doesn't refer to 0 in memory or 0 in storage - it just refers to the zeroth byte of calldata.\n\n                    That's always going to be the zeroth byte of the function selector.\n\n                Third argument, calldatasize, specifies how much data will be copied.\n\n                    calldata is naturally calldatasize bytes long (same thing as msg.data.length)\n\n            */\n\n            calldatacopy(ptr, 0, calldatasize)\n\n            /*\n\n                delegatecall params explained:\n\n                gas: the amount of gas to provide for the call. `gas` is an Opcode that gives\n\n                    us the amount of gas still available to execution\n\n\n\n                _impl: address of the contract to delegate to\n\n\n\n                ptr: to pass copied data\n\n\n\n                calldatasize: loads the size of `bytes memory data`, same as msg.data.length\n\n\n\n                0, 0: These are for the `out` and `outsize` params. Because the output could be dynamic,\n\n                        these are set to 0, 0 so the output data will not be written to memory. The output\n\n                        data will be read using `returndatasize` and `returdatacopy` instead.\n\n\n\n                result: This will be 0 if the call fails and 1 if it succeeds\n\n            */\n\n            let result := delegatecall(gas, _impl, ptr, calldatasize, 0, 0)\n\n            /*\n\n\n\n            */\n\n            /*\n\n                ptr current points to the value stored at 0x40,\n\n                because we assigned it like ptr := mload(0x40).\n\n                Because we use 0x40 as a free memory pointer,\n\n                we want to make sure that the next time we want to allocate memory,\n\n                we aren't overwriting anything important.\n\n                So, by adding ptr and returndatasize,\n\n                we get a memory location beyond the end of the data we will be copying to ptr.\n\n                We place this in at 0x40, and any reads from 0x40 will now read from free memory\n\n            */\n\n            mstore(0x40, add(ptr, returndatasize))\n\n            /*\n\n                `returndatacopy` is an Opcode that copies the last return data to a slot. `ptr` is the\n\n                    slot it will copy to, 0 means copy from the beginning of the return data, and size is\n\n                    the amount of data to copy.\n\n                `returndatasize` is an Opcode that gives us the size of the last return data. In this case, that is the size of the data returned from delegatecall\n\n            */\n\n            returndatacopy(ptr, 0, returndatasize)\n\n\n\n            /*\n\n                if `result` is 0, revert.\n\n                if `result` is 1, return `size` amount of data from `ptr`. This is the data that was\n\n                copied to `ptr` from the delegatecall return data\n\n            */\n\n            switch result\n\n            case 0 { revert(ptr, returndatasize) }\n\n            default { return(ptr, returndatasize) }\n\n        }\n",
          "message": "Proxy.fallback (ClassicEternalStorageProxy.sol#42-113) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 136,
          "vulnerability_to_line": 138,
          "vulnerability_code": "    function version() public view returns (uint256) {\n\n        return _version;\n",
          "message": "UpgradeabilityStorage.version (ClassicEternalStorageProxy.sol#136-138) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 253,
          "vulnerability_to_line": 257,
          "vulnerability_code": "    function transferProxyOwnership(address newOwner) public onlyProxyOwner {\n\n        require(newOwner != address(0));\n\n        emit ProxyOwnershipTransferred(proxyOwner(), newOwner);\n\n        setUpgradeabilityOwner(newOwner);\n",
          "message": "OwnedUpgradeabilityProxy.transferProxyOwnership (ClassicEternalStorageProxy.sol#253-257) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 276,
          "vulnerability_to_line": 279,
          "vulnerability_code": "    function upgradeToAndCall(uint256 version, address implementation, bytes data) payable public onlyProxyOwner {\n\n        upgradeTo(version, implementation);\n\n        require(address(this).call.value(msg.value)(data));\n",
          "message": "OwnedUpgradeabilityProxy.upgradeToAndCall (ClassicEternalStorageProxy.sol#276-279) should be declared external\n"
        },
        {
          "name": "low-level-calls",
          "vulnerability_from_line": 276,
          "vulnerability_to_line": 279,
          "vulnerability_code": "    function upgradeToAndCall(uint256 version, address implementation, bytes data) payable public onlyProxyOwner {\n\n        upgradeTo(version, implementation);\n\n        require(address(this).call.value(msg.value)(data));\n",
          "message": "Low level call in OwnedUpgradeabilityProxy.upgradeToAndCall (ClassicEternalStorageProxy.sol#276-279):\n\t-require(bool)(address(this).call.value(msg.value)(data)) ClassicEternalStorageProxy.sol#278\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 127,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint256 internal _version;\n",
          "message": "Variable 'UpgradeabilityStorage._version' (ClassicEternalStorageProxy.sol#127) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 130,
          "vulnerability_to_line": null,
          "vulnerability_code": "    address internal _implementation;\n",
          "message": "Variable 'UpgradeabilityStorage._implementation' (ClassicEternalStorageProxy.sol#130) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 171,
          "vulnerability_to_line": 177,
          "vulnerability_code": "    function _upgradeTo(uint256 version, address implementation) internal {\n\n        require(_implementation != implementation);\n\n        require(version > _version);\n\n        _version = version;\n\n        _implementation = implementation;\n\n        emit Upgraded(version, implementation);\n",
          "message": "Function 'UpgradeabilityProxy._upgradeTo' (ClassicEternalStorageProxy.sol#171-177) is not in mixedCase\n"
        },
        {
          "name": "unused-state",
          "vulnerability_from_line": 13,
          "vulnerability_to_line": null,
          "vulnerability_code": "    mapping(bytes32 => string) internal stringStorage;\n",
          "message": "EternalStorage.stringStorage (ClassicEternalStorageProxy.sol#13) is never used in ClassicEternalStorageProxy\nEternalStorage.addressStorage (ClassicEternalStorageProxy.sol#14) is never used in ClassicEternalStorageProxy\nEternalStorage.bytesStorage (ClassicEternalStorageProxy.sol#15) is never used in ClassicEternalStorageProxy\nEternalStorage.boolStorage (ClassicEternalStorageProxy.sol#16) is never used in ClassicEternalStorageProxy\nEternalStorage.intStorage (ClassicEternalStorageProxy.sol#17) is never used in ClassicEternalStorageProxy\n"
        }
      ]
    },
    "smartcheck": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "SOLIDITY_LOCKED_MONEY",
          "vulnerability_from_line": 30,
          "vulnerability_to_line": null,
          "vulnerability_code": "contract Proxy {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_LOCKED_MONEY",
          "vulnerability_from_line": 287,
          "vulnerability_to_line": null,
          "vulnerability_code": "contract ClassicEternalStorageProxy is EternalStorage, OwnedUpgradeabilityProxy {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 191,
          "vulnerability_to_line": null,
          "vulnerability_code": "    address private _upgradeabilityOwner;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 42,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function () payable public {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 289,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function () payable public {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 276,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function upgradeToAndCall(uint256 version, address implementation, bytes data) payable public onlyProxyOwner {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 45,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 293,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        }
      ]
    },
    "oyente": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "Integer Overflow",
          "vulnerability_from_line": 304,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getSize(bytes4 sig) public view returns(uint256) {\n",
          "message": null
        },
        {
          "name": "Integer Underflow",
          "vulnerability_from_line": 305,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint256 ret = uintStorage[keccak256(abi.encodePacked(\"dataSizes\", sig))];\n",
          "message": null
        },
        {
          "name": "Integer Overflow",
          "vulnerability_from_line": 276,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function upgradeToAndCall(uint256 version, address implementation, bytes data) payable public onlyProxyOwner {\n",
          "message": null
        }
      ]
    },
    "mythril": {
      "successfull_analysis": false,
      "errors": [
        "DOCKER_TIMEOUT"
      ],
      "vulnerability_findings": []
    },
    "osiris": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": []
    }
  }
}