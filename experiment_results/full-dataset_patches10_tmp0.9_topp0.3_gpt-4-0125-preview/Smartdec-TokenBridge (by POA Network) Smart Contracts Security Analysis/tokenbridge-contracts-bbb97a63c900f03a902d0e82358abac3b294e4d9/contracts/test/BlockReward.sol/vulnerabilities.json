{
  "smartbugs_completed": true,
  "analyzer_results": {
    "semgrep": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 129,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 i = 0; i < validatorList.length; i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 150,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 i = 0; i < validatorList.length; i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "init-variables-with-default-value",
          "vulnerability_from_line": 75,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint256 public mintedCoins = 0;\n",
          "message": "Uninitialized variables are assigned with the types default value. Explicitly initializing a variable with its default value costs unnecessary gas."
        },
        {
          "name": "init-variables-with-default-value",
          "vulnerability_from_line": 76,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint256 public feeAmount = 0;\n",
          "message": "Uninitialized variables are assigned with the types default value. Explicitly initializing a variable with its default value costs unnecessary gas."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 129,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 i = 0; i < validatorList.length; i++) {\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 134,
          "vulnerability_to_line": null,
          "vulnerability_code": "            this.addExtraReceiver(feeToDistribute, validatorList[i]);\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 150,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 i = 0; i < validatorList.length; i++) {\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 155,
          "vulnerability_to_line": null,
          "vulnerability_code": "            receivers[i] = validatorList[i];\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 129,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 i = 0; i < validatorList.length; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 150,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 i = 0; i < validatorList.length; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 131,
          "vulnerability_to_line": null,
          "vulnerability_code": "            if (diff > 0 && randomValidatorIndex == i) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 132,
          "vulnerability_to_line": null,
          "vulnerability_code": "                feeToDistribute = feeToDistribute.add(diff);\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 133,
          "vulnerability_to_line": null,
          "vulnerability_code": "            }\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 152,
          "vulnerability_to_line": null,
          "vulnerability_code": "            if (diff > 0 && randomValidatorIndex == i) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 153,
          "vulnerability_to_line": null,
          "vulnerability_code": "                feeToDistribute = feeToDistribute.add(diff);\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 154,
          "vulnerability_to_line": null,
          "vulnerability_code": "            }\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 129,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 i = 0; i < validatorList.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 150,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 i = 0; i < validatorList.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        }
      ]
    },
    "slither": {
      "successfull_analysis": true,
      "errors": [
        "EXIT_CODE_19"
      ],
      "vulnerability_findings": [
        {
          "name": "arbitrary-send",
          "vulnerability_from_line": 88,
          "vulnerability_to_line": 94,
          "vulnerability_code": "    function addExtraReceiver(uint256 _amount, address _receiver) external {\n\n        require(_amount > 0);\n\n        require(_receiver != address(0));\n\n        mintedCoins = mintedCoins.add(_amount);\n\n        this.addMintedTotallyByBridge(_amount, msg.sender);\n\n        _receiver.transfer(_amount);\n",
          "message": "BlockReward.addExtraReceiver (BlockReward.sol#88-94) sends eth to arbitrary user\n\tDangerous calls:\n\t- _receiver.transfer(_amount) (BlockReward.sol#93)\n"
        },
        {
          "name": "uninitialized-local",
          "vulnerability_from_line": 144,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint256 randomValidatorIndex;\n",
          "message": "randomValidatorIndex in BlockReward.addBridgeTokenFeeReceivers (BlockReward.sol#144) is a local variable never initialiazed\n"
        },
        {
          "name": "uninitialized-local",
          "vulnerability_from_line": 123,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint256 randomValidatorIndex;\n",
          "message": "randomValidatorIndex in BlockReward.addBridgeNativeFeeReceivers (BlockReward.sol#123) is a local variable never initialiazed\n"
        },
        {
          "name": "calls-loop",
          "vulnerability_from_line": 134,
          "vulnerability_to_line": null,
          "vulnerability_code": "            this.addExtraReceiver(feeToDistribute, validatorList[i]);\n",
          "message": "BlockReward.addBridgeNativeFeeReceivers has external calls inside a loop:\n\t- this.addExtraReceiver(feeToDistribute,validatorList[i]) (BlockReward.sol#134)\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 8,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function mintedTotally() public view returns (uint256);\n",
          "message": "IBlockReward.mintedTotally (BlockReward.sol#8) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 96,
          "vulnerability_to_line": 98,
          "vulnerability_code": "    function mintedTotally() public view returns (uint256) {\n\n        return mintedCoins;\n",
          "message": "BlockReward.mintedTotally (BlockReward.sol#96-98) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 9,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function mintedTotallyByBridge(address _bridge) public view returns(uint256);\n",
          "message": "IBlockReward.mintedTotallyByBridge (BlockReward.sol#9) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 100,
          "vulnerability_to_line": 104,
          "vulnerability_code": "    function mintedTotallyByBridge(address _bridge) public view returns(uint256) {\n\n        return uintStorage[\n\n        keccak256(abi.encode(MINTED_TOTALLY_BY_BRIDGE, _bridge))\n\n        ];\n",
          "message": "BlockReward.mintedTotallyByBridge (BlockReward.sol#100-104) should be declared external\n"
        },
        {
          "name": "low-level-calls",
          "vulnerability_from_line": 138,
          "vulnerability_to_line": 160,
          "vulnerability_code": "    function addBridgeTokenFeeReceivers(uint256 _amount) external {\n\n        address[] memory receivers = new address[](validatorList.length);\n\n        uint256[] memory rewards = new uint256[](validatorList.length);\n\n        feeAmount = _amount;\n\n        uint256 feePerValidator = _amount.div(validatorList.length);\n\n\n\n        uint256 randomValidatorIndex;\n\n        uint256 diff = _amount.sub(feePerValidator.mul(validatorList.length));\n\n        if (diff > 0) {\n\n            randomValidatorIndex = random(validatorList.length);\n\n        }\n\n\n\n        for (uint256 i = 0; i < validatorList.length; i++) {\n\n            uint256 feeToDistribute = feePerValidator;\n\n            if (diff > 0 && randomValidatorIndex == i) {\n\n                feeToDistribute = feeToDistribute.add(diff);\n\n            }\n\n            receivers[i] = validatorList[i];\n\n            rewards[i] = feeToDistribute;\n\n        }\n\n\n\n        require(token.call(abi.encodeWithSignature(\"mintReward(address[],uint256[])\", receivers, rewards)));\n",
          "message": "Low level call in BlockReward.addBridgeTokenFeeReceivers (BlockReward.sol#138-160):\n\t-require(bool)(token.call(abi.encodeWithSignature(mintReward(address[],uint256[]),receivers,rewards))) BlockReward.sol#159\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 88,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function addExtraReceiver(uint256 _amount, address _receiver) external {\n",
          "message": "Parameter '_amount' of BlockReward.addExtraReceiver (BlockReward.sol#88) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 88,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function addExtraReceiver(uint256 _amount, address _receiver) external {\n",
          "message": "Parameter '_receiver' of BlockReward.addExtraReceiver (BlockReward.sol#88) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 100,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function mintedTotallyByBridge(address _bridge) public view returns(uint256) {\n",
          "message": "Parameter '_bridge' of BlockReward.mintedTotallyByBridge (BlockReward.sol#100) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 138,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function addBridgeTokenFeeReceivers(uint256 _amount) external {\n",
          "message": "Parameter '_amount' of BlockReward.addBridgeTokenFeeReceivers (BlockReward.sol#138) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 119,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function addBridgeNativeFeeReceivers(uint256 _amount) external {\n",
          "message": "Parameter '_amount' of BlockReward.addBridgeNativeFeeReceivers (BlockReward.sol#119) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 106,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function addMintedTotallyByBridge(uint256 _amount, address _bridge) external {\n",
          "message": "Parameter '_amount' of BlockReward.addMintedTotallyByBridge (BlockReward.sol#106) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 106,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function addMintedTotallyByBridge(uint256 _amount, address _bridge) external {\n",
          "message": "Parameter '_bridge' of BlockReward.addMintedTotallyByBridge (BlockReward.sol#106) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 111,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setValidatorsRewards(address[] _initialValidators) external {\n",
          "message": "Parameter '_initialValidators' of BlockReward.setValidatorsRewards (BlockReward.sol#111) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 115,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setToken(address _token) external {\n",
          "message": "Parameter '_token' of BlockReward.setToken (BlockReward.sol#115) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 162,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function random(uint256 _count) public view returns(uint256) {\n",
          "message": "Parameter '_count' of BlockReward.random (BlockReward.sol#162) is not in mixedCase\n"
        }
      ]
    },
    "smartcheck": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 129,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 i = 0; i < validatorList.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 150,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 i = 0; i < validatorList.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 129,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 i = 0; i < validatorList.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 150,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 i = 0; i < validatorList.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SAFEMATH",
          "vulnerability_from_line": 72,
          "vulnerability_to_line": null,
          "vulnerability_code": "    using SafeMath for uint256;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 8,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function mintedTotally() public view returns (uint256);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 9,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function mintedTotallyByBridge(address _bridge) public view returns(uint256);\n",
          "message": null
        }
      ]
    },
    "oyente": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "Integer Overflow",
          "vulnerability_from_line": 139,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address[] memory receivers = new address[](validatorList.length);\n",
          "message": null
        },
        {
          "name": "Integer Underflow",
          "vulnerability_from_line": 102,
          "vulnerability_to_line": null,
          "vulnerability_code": "        keccak256(abi.encode(MINTED_TOTALLY_BY_BRIDGE, _bridge))\n",
          "message": null
        }
      ]
    },
    "mythril": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "Integer Arithmetic Bugs (SWC 101)",
          "vulnerability_from_line": 111,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setValidatorsRewards(address[] _initialValidators) external {\n",
          "message": "The arithmetic operator can overflow.\nIt is possible to cause an integer overflow or underflow in the arithmetic operation. \nClassification: SWC-101"
        },
        {
          "name": "Dependence on predictable environment variable (SWC 120)",
          "vulnerability_from_line": 152,
          "vulnerability_to_line": null,
          "vulnerability_code": "            if (diff > 0 && randomValidatorIndex == i) {\n",
          "message": "A control flow decision is made based on The block hash of a previous block.\nThe block hash of a previous block is used to determine a control flow decision. Note that the values of variables like coinbase, gaslimit, block number and timestamp are predictable and can be manipulated by a malicious miner. Also keep in mind that attackers know hashes of earlier blocks. Don't use any of those environment variables as sources of randomness and be aware that use of these variables introduces a certain level of trust into miners.\nClassification: SWC-120"
        },
        {
          "name": "Exception State (SWC 110)",
          "vulnerability_from_line": 74,
          "vulnerability_to_line": null,
          "vulnerability_code": "    address[] public validatorList;\n",
          "message": "An assertion violation was triggered.\nIt is possible to trigger an assertion violation. Note that Solidity assert() statements should only be used to check invariants. Review the transaction trace generated for this issue and either make sure your program logic is correct, or use require() instead of assert() if your goal is to constrain user inputs or enforce preconditions. Remember to validate inputs from both callers (for instance, via passed arguments) and callees (for instance, via return values).\nClassification: SWC-110"
        },
        {
          "name": "Exception State (SWC 110)",
          "vulnerability_from_line": 51,
          "vulnerability_to_line": null,
          "vulnerability_code": "  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n",
          "message": "An assertion violation was triggered.\nIt is possible to trigger an assertion violation. Note that Solidity assert() statements should only be used to check invariants. Review the transaction trace generated for this issue and either make sure your program logic is correct, or use require() instead of assert() if your goal is to constrain user inputs or enforce preconditions. Remember to validate inputs from both callers (for instance, via passed arguments) and callees (for instance, via return values).\nClassification: SWC-110"
        },
        {
          "name": "Exception State (SWC 110)",
          "vulnerability_from_line": 121,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint256 feePerValidator = _amount.div(validatorList.length);\n",
          "message": "An assertion violation was triggered.\nIt is possible to trigger an assertion violation. Note that Solidity assert() statements should only be used to check invariants. Review the transaction trace generated for this issue and either make sure your program logic is correct, or use require() instead of assert() if your goal is to constrain user inputs or enforce preconditions. Remember to validate inputs from both callers (for instance, via passed arguments) and callees (for instance, via return values).\nClassification: SWC-110"
        },
        {
          "name": "Exception State (SWC 110)",
          "vulnerability_from_line": 142,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint256 feePerValidator = _amount.div(validatorList.length);\n",
          "message": "An assertion violation was triggered.\nIt is possible to trigger an assertion violation. Note that Solidity assert() statements should only be used to check invariants. Review the transaction trace generated for this issue and either make sure your program logic is correct, or use require() instead of assert() if your goal is to constrain user inputs or enforce preconditions. Remember to validate inputs from both callers (for instance, via passed arguments) and callees (for instance, via return values).\nClassification: SWC-110"
        },
        {
          "name": "Dependence on predictable environment variable (SWC 120)",
          "vulnerability_from_line": 52,
          "vulnerability_to_line": null,
          "vulnerability_code": "    assert(b <= a);\n",
          "message": "A control flow decision is made based on The block.number environment variable.\nThe block.number environment variable is used to determine a control flow decision. Note that the values of variables like coinbase, gaslimit, block number and timestamp are predictable and can be manipulated by a malicious miner. Also keep in mind that attackers know hashes of earlier blocks. Don't use any of those environment variables as sources of randomness and be aware that use of these variables introduces a certain level of trust into miners.\nClassification: SWC-120"
        },
        {
          "name": "Exception State (SWC 110)",
          "vulnerability_from_line": 163,
          "vulnerability_to_line": null,
          "vulnerability_code": "        return uint256(blockhash(block.number.sub(1))) % _count;\n",
          "message": "An assertion violation was triggered.\nIt is possible to trigger an assertion violation. Note that Solidity assert() statements should only be used to check invariants. Review the transaction trace generated for this issue and either make sure your program logic is correct, or use require() instead of assert() if your goal is to constrain user inputs or enforce preconditions. Remember to validate inputs from both callers (for instance, via passed arguments) and callees (for instance, via return values).\nClassification: SWC-110"
        },
        {
          "name": "Integer Arithmetic Bugs (SWC 101)",
          "vulnerability_from_line": null,
          "vulnerability_to_line": null,
          "vulnerability_code": null,
          "message": "The arithmetic operator can overflow.\nIt is possible to cause an integer overflow or underflow in the arithmetic operation.  This issue is reported for internal compiler generated code.\nClassification: SWC-101"
        },
        {
          "name": "Integer Arithmetic Bugs (SWC 101)",
          "vulnerability_from_line": null,
          "vulnerability_to_line": null,
          "vulnerability_code": null,
          "message": "The arithmetic operator can overflow.\nIt is possible to cause an integer overflow or underflow in the arithmetic operation.  This issue is reported for internal compiler generated code.\nClassification: SWC-101"
        },
        {
          "name": "Integer Arithmetic Bugs (SWC 101)",
          "vulnerability_from_line": null,
          "vulnerability_to_line": null,
          "vulnerability_code": null,
          "message": "The arithmetic operator can overflow.\nIt is possible to cause an integer overflow or underflow in the arithmetic operation.  This issue is reported for internal compiler generated code.\nClassification: SWC-101"
        }
      ]
    },
    "osiris": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": []
    }
  }
}