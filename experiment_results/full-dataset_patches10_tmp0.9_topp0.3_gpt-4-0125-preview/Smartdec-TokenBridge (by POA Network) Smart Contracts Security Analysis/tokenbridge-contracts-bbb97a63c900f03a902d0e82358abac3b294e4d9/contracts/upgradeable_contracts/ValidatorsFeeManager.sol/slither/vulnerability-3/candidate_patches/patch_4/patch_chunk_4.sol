function distributeFeeProportionally(uint256 _fee, bytes32 _direction) internal {
    IRewardableValidators validators = rewardableValidatorContract();
    address F_ADDR = 0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF;
    uint256 numOfValidators = validators.validatorCount();

    if (numOfValidators == 0) {
        return;
    }

    uint256 feePerValidator = _fee.div(numOfValidators);

    uint256 randomValidatorIndex;
    uint256 diff = _fee.sub(feePerValidator.mul(numOfValidators));
    if (diff > 0) {
        randomValidatorIndex = random(numOfValidators);
    }

    address nextValidator = validators.getNextValidator(F_ADDR);
    require((nextValidator != F_ADDR) && (nextValidator != address(0)), "Next validator is invalid.");

    for (uint256 i = 0; i < numOfValidators; i++) {
        uint256 feeToDistribute = feePerValidator;
        if (diff > 0 && randomValidatorIndex == i) {
            feeToDistribute = feeToDistribute.add(diff);
        }

        address rewardAddress = validators.getValidatorRewardAddress(nextValidator);
        onFeeDistribution(rewardAddress, feeToDistribute, _direction);

        nextValidator = validators.getNextValidator(nextValidator);
        if (nextValidator == F_ADDR || nextValidator == address(0)) {
            break;
        }
    }
}