function distributeFeeProportionally(uint256 _fee, bytes32 _direction) internal {
    IRewardableValidators validators = rewardableValidatorContract();
    address F_ADDR = 0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF;
    uint256 numOfValidators = validators.validatorCount();

    uint256[] memory feesToDistribute = new uint256[](numOfValidators);
    address[] memory rewardAddresses = new address[](numOfValidators);

    uint256 feePerValidator = _fee.div(numOfValidators);
    uint256 diff = _fee.sub(feePerValidator.mul(numOfValidators));
    if (diff > 0) {
        uint256 randomValidatorIndex = random(numOfValidators);
        feesToDistribute[randomValidatorIndex] = diff;
    }

    address nextValidator = validators.getNextValidator(F_ADDR);
    require((nextValidator != F_ADDR) && (nextValidator != address(0)));

    uint256 i = 0;
    while (nextValidator != F_ADDR) {
        feesToDistribute[i] = feesToDistribute[i].add(feePerValidator);
        rewardAddresses[i] = validators.getValidatorRewardAddress(nextValidator);

        nextValidator = validators.getNextValidator(nextValidator);
        require((nextValidator != F_ADDR) && (nextValidator != address(0)));
        i = i + 1;
    }

    for (uint256 j = 0; j < rewardAddresses.length; j++) {
        onFeeDistribution(rewardAddresses[j], feesToDistribute[j], _direction);
    }
}