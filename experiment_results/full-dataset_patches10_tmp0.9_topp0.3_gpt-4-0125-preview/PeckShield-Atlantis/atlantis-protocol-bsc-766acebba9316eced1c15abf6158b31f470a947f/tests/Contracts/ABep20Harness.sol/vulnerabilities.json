{
  "smartbugs_completed": true,
  "analyzer_results": {
    "semgrep": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 5063,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < assets.length; i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 5283,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < allMarkets.length; i ++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 5582,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < aTokens.length; i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 5588,
          "vulnerability_to_line": null,
          "vulnerability_code": "                for (uint j = 0; j < holders.length; j++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 5594,
          "vulnerability_to_line": null,
          "vulnerability_code": "                for (uint j = 0; j < holders.length; j++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 5599,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint j = 0; j < holders.length; j++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 5707,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < vaults.length; i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 5835,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < allMarkets_.length; i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 5844,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < allMarkets_.length; i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 5854,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < allMarkets_.length; i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "inefficient-state-variable-increment",
          "vulnerability_from_line": 5801,
          "vulnerability_to_line": null,
          "vulnerability_code": "        blockNumber += blocks;\n",
          "message": "<x> += <y> costs more gas than <x> = <x> + <y> for state variables."
        },
        {
          "name": "inefficient-state-variable-increment",
          "vulnerability_from_line": 5924,
          "vulnerability_to_line": null,
          "vulnerability_code": "        blockNumber += blocks;\n",
          "message": "<x> += <y> costs more gas than <x> = <x> + <y> for state variables."
        },
        {
          "name": "inefficient-state-variable-increment",
          "vulnerability_from_line": 6139,
          "vulnerability_to_line": null,
          "vulnerability_code": "        blockNumber += blocks;\n",
          "message": "<x> += <y> costs more gas than <x> = <x> + <y> for state variables."
        },
        {
          "name": "inefficient-state-variable-increment",
          "vulnerability_from_line": 6275,
          "vulnerability_to_line": null,
          "vulnerability_code": "        blockNumber += blocks;\n",
          "message": "<x> += <y> costs more gas than <x> = <x> + <y> for state variables."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 2947,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor(address underlying_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 2948,
          "vulnerability_to_line": null,
          "vulnerability_code": "                ComptrollerInterface comptroller_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 2949,
          "vulnerability_to_line": null,
          "vulnerability_code": "                InterestRateModel interestRateModel_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 2950,
          "vulnerability_to_line": null,
          "vulnerability_code": "                uint initialExchangeRateMantissa_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 2951,
          "vulnerability_to_line": null,
          "vulnerability_code": "                string memory name_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 2952,
          "vulnerability_to_line": null,
          "vulnerability_code": "                string memory symbol_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 2953,
          "vulnerability_to_line": null,
          "vulnerability_code": "                uint8 decimals_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 2954,
          "vulnerability_to_line": null,
          "vulnerability_code": "                address payable admin_) public {\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 2955,
          "vulnerability_to_line": null,
          "vulnerability_code": "        // Creator of the contract is admin during initialization\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 2956,
          "vulnerability_to_line": null,
          "vulnerability_code": "        admin = msg.sender;\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 2989,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor(address underlying_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 2990,
          "vulnerability_to_line": null,
          "vulnerability_code": "                ComptrollerInterface comptroller_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 2991,
          "vulnerability_to_line": null,
          "vulnerability_code": "                InterestRateModel interestRateModel_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 2992,
          "vulnerability_to_line": null,
          "vulnerability_code": "                uint initialExchangeRateMantissa_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 2993,
          "vulnerability_to_line": null,
          "vulnerability_code": "                string memory name_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 2994,
          "vulnerability_to_line": null,
          "vulnerability_code": "                string memory symbol_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 2995,
          "vulnerability_to_line": null,
          "vulnerability_code": "                uint8 decimals_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 2996,
          "vulnerability_to_line": null,
          "vulnerability_code": "                address payable admin_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 2997,
          "vulnerability_to_line": null,
          "vulnerability_code": "                address implementation_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 2998,
          "vulnerability_to_line": null,
          "vulnerability_code": "                bytes memory becomeImplementationData) public {\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 3456,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor() public {}\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 3909,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor() public {\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 3910,
          "vulnerability_to_line": null,
          "vulnerability_code": "        // Set admin to caller\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 3911,
          "vulnerability_to_line": null,
          "vulnerability_code": "        admin = msg.sender;\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 3912,
          "vulnerability_to_line": null,
          "vulnerability_code": "    }\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 4091,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor(address account) public {\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 4092,
          "vulnerability_to_line": null,
          "vulnerability_code": "        balances[account] = uint96(totalSupply);\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 4093,
          "vulnerability_to_line": null,
          "vulnerability_code": "        emit Transfer(address(0), account, totalSupply);\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 4094,
          "vulnerability_to_line": null,
          "vulnerability_code": "    }\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 4418,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor() public {\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 4419,
          "vulnerability_to_line": null,
          "vulnerability_code": "        admin = msg.sender;\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 4420,
          "vulnerability_to_line": null,
          "vulnerability_code": "    }\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 5798,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor() Comptroller() public {}\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 5877,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor(address underlying_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 5878,
          "vulnerability_to_line": null,
          "vulnerability_code": "                ComptrollerInterface comptroller_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 5879,
          "vulnerability_to_line": null,
          "vulnerability_code": "                InterestRateModel interestRateModel_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 5880,
          "vulnerability_to_line": null,
          "vulnerability_code": "                uint initialExchangeRateMantissa_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 5881,
          "vulnerability_to_line": null,
          "vulnerability_code": "                string memory name_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 5882,
          "vulnerability_to_line": null,
          "vulnerability_code": "                string memory symbol_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 5883,
          "vulnerability_to_line": null,
          "vulnerability_code": "                uint8 decimals_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 5884,
          "vulnerability_to_line": null,
          "vulnerability_code": "                address payable admin_)\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 5885,
          "vulnerability_to_line": null,
          "vulnerability_code": "    ABep20Immutable(\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 5886,
          "vulnerability_to_line": null,
          "vulnerability_code": "    underlying_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 6016,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor(address underlying_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 6017,
          "vulnerability_to_line": null,
          "vulnerability_code": "                ComptrollerInterface comptroller_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 6018,
          "vulnerability_to_line": null,
          "vulnerability_code": "                InterestRateModel interestRateModel_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 6019,
          "vulnerability_to_line": null,
          "vulnerability_code": "                uint initialExchangeRateMantissa_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 6020,
          "vulnerability_to_line": null,
          "vulnerability_code": "                string memory name_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 6021,
          "vulnerability_to_line": null,
          "vulnerability_code": "                string memory symbol_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 6022,
          "vulnerability_to_line": null,
          "vulnerability_code": "                uint8 decimals_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 6023,
          "vulnerability_to_line": null,
          "vulnerability_code": "                address payable admin_)\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 6024,
          "vulnerability_to_line": null,
          "vulnerability_code": "    ABep20Immutable(\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 6025,
          "vulnerability_to_line": null,
          "vulnerability_code": "    underlying_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 6049,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor(address underlying_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 6050,
          "vulnerability_to_line": null,
          "vulnerability_code": "                ComptrollerInterface comptroller_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 6051,
          "vulnerability_to_line": null,
          "vulnerability_code": "                InterestRateModel interestRateModel_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 6052,
          "vulnerability_to_line": null,
          "vulnerability_code": "                uint initialExchangeRateMantissa_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 6053,
          "vulnerability_to_line": null,
          "vulnerability_code": "                string memory name_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 6054,
          "vulnerability_to_line": null,
          "vulnerability_code": "                string memory symbol_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 6055,
          "vulnerability_to_line": null,
          "vulnerability_code": "                uint8 decimals_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 6056,
          "vulnerability_to_line": null,
          "vulnerability_code": "                address payable admin_)\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 6057,
          "vulnerability_to_line": null,
          "vulnerability_code": "    ABep20Scenario(\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 6058,
          "vulnerability_to_line": null,
          "vulnerability_code": "    underlying_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 6073,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor(address underlying_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 6074,
          "vulnerability_to_line": null,
          "vulnerability_code": "                ComptrollerInterface comptroller_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 6075,
          "vulnerability_to_line": null,
          "vulnerability_code": "                InterestRateModel interestRateModel_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 6076,
          "vulnerability_to_line": null,
          "vulnerability_code": "                uint initialExchangeRateMantissa_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 6077,
          "vulnerability_to_line": null,
          "vulnerability_code": "                string memory name_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 6078,
          "vulnerability_to_line": null,
          "vulnerability_code": "                string memory symbol_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 6079,
          "vulnerability_to_line": null,
          "vulnerability_code": "                uint8 decimals_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 6080,
          "vulnerability_to_line": null,
          "vulnerability_code": "                address payable admin_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 6081,
          "vulnerability_to_line": null,
          "vulnerability_code": "                address implementation_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 6082,
          "vulnerability_to_line": null,
          "vulnerability_code": "                bytes memory becomeImplementationData)\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 6239,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor() public {}\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 4239,
          "vulnerability_to_line": null,
          "vulnerability_code": "            Checkpoint memory cp = checkpoints[account][center];\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 4454,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < len; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 4534,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < len; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 5063,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < assets.length; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 5283,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < allMarkets.length; i ++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 5304,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(uint i = 0; i < numMarkets; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 5582,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < aTokens.length; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 5588,
          "vulnerability_to_line": null,
          "vulnerability_code": "                for (uint j = 0; j < holders.length; j++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 5594,
          "vulnerability_to_line": null,
          "vulnerability_code": "                for (uint j = 0; j < holders.length; j++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 5599,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint j = 0; j < holders.length; j++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 5707,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < vaults.length; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 5835,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < allMarkets_.length; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 5844,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < allMarkets_.length; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 5854,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < allMarkets_.length; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1273,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == admin, \"only admin may initialize the market\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1274,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(accrualBlockNumber == 0 && borrowIndex == 0, \"market may only be initialized once\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1278,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(initialExchangeRateMantissa > 0, \"initial exchange rate must be greater than zero.\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1282,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(err == uint(Error.NO_ERROR), \"setting comptroller failed\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1290,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(err == uint(Error.NO_ERROR), \"setting interest rate model failed\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1435,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(mErr == MathError.NO_ERROR, \"balance could not be calculated\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1494,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1504,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1515,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(err == MathError.NO_ERROR, \"borrowBalanceStored: borrowBalanceStoredInternal failed\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1561,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1572,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(err == MathError.NO_ERROR, \"exchangeRateStored: exchangeRateStoredInternal failed\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1644,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1648,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(mathErr == MathError.NO_ERROR, \"could not calculate block delta\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1778,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(vars.mathErr == MathError.NO_ERROR, \"MINT_EXCHANGE_CALCULATION_FAILED\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1786,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(vars.mathErr == MathError.NO_ERROR, \"MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1789,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(vars.mathErr == MathError.NO_ERROR, \"MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1857,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 2144,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(vars.mathErr == MathError.NO_ERROR, \"REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 2147,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(vars.mathErr == MathError.NO_ERROR, \"REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 2243,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(amountSeizeError == uint(Error.NO_ERROR), \"LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 2246,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(aTokenCollateral.balanceOf(borrower) >= seizeTokens, \"LIQUIDATE_SEIZE_TOO_MUCH\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 2257,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(seizeError == uint(Error.NO_ERROR), \"token seizure failed\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 2332,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(vars.mathErr == MathError.NO_ERROR, \"exchange rate math error\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 2433,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(newComptroller.isComptroller(), \"marker method returned false\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 2538,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(totalReservesNew >= totalReserves, \"add reserves unexpected overflow\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 2602,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(totalReservesNew <= totalReserves, \"reduce reserves unexpected underflow\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 2656,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 2696,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_notEntered, \"re-entered\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 2823,
          "vulnerability_to_line": null,
          "vulnerability_code": "    \trequire(address(token) != underlying, \"ABep20::sweepToken: can not sweep underlying token\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 2877,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(success, \"TOKEN_TRANSFER_IN_FAILED\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 2881,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(balanceAfter >= balanceBefore, \"TOKEN_TRANSFER_IN_OVERFLOW\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 2912,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(success, \"TOKEN_TRANSFER_OUT_FAILED\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 2921,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == admin, \"only the admin may set the atlantis-like delegate\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 3026,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == admin, \"ABep20Delegator::_setImplementation: Caller must be admin\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 3427,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.value == 0,\"ABep20Delegator:fallback: cannot send value to fallback\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 3471,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == admin, \"only the admin may call _becomeImplementation\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 3483,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == admin, \"only the admin may call _resignImplementation\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 3517,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == admin, \"only the admin may initialize the implementation\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 3534,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(address(dai) == underlying, \"DAI must be the same as underlying\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 3559,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == admin, \"only the admin may abandon the implementation\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 3617,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(token.transferFrom(from, address(this), amount), \"unexpected EIP-20 transfer in return\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 3660,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require((z = x + y) >= x, \"add-overflow\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 3664,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(y == 0 || (z = x * y) / y == x, \"mul-overflow\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 4194,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(signatory != address(0), \"Atlantis::delegateBySig: invalid signature\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 4195,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(nonce == nonces[signatory]++, \"Atlantis::delegateBySig: invalid nonce\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 4196,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(now <= expiry, \"Atlantis::delegateBySig: signature expired\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 4218,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(blockNumber < block.number, \"Atlantis::getPriorVotes: not yet determined\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 4262,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(src != address(0), \"Atlantis::_transferTokens: cannot transfer from the zero address\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 4263,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(dst != address(0), \"Atlantis::_transferTokens: cannot transfer to the zero address\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 4506,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(oErr == 0, \"exitMarket: getAccountSnapshot failed\"); // semi-opaque error code\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 4565,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(!mintGuardianPaused[aToken], \"mint is paused\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 4658,
          "vulnerability_to_line": null,
          "vulnerability_code": "            revert(\"redeemTokens zero\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 4671,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(!borrowGuardianPaused[aToken], \"borrow is paused\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 4679,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(msg.sender == aToken, \"sender must be aToken\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 4701,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(nextTotalBorrows < borrowCap, \"market borrow cap reached\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 4819,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(borrowBalance >= repayAmount, \"Can not repay more than the total borrow\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 4884,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(!seizeGuardianPaused, \"seize is paused\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 4942,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(!transferGuardianPaused, \"transfer is paused\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 5180,
          "vulnerability_to_line": null,
          "vulnerability_code": "    \trequire(msg.sender == admin, \"only admin can set close factor\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 5284,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(allMarkets[i] != AToken(aToken), \"market already added\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 5297,
          "vulnerability_to_line": null,
          "vulnerability_code": "    \trequire(msg.sender == admin || msg.sender == borrowCapGuardian, \"only admin or borrow cap guardian can set borrow caps\"); \n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 5302,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(numMarkets != 0 && numMarkets == numBorrowCaps, \"invalid input\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 5315,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == admin, \"only admin can set borrow cap guardian\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 5350,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(markets[address(aToken)].isListed, \"cannot pause a market that is not listed\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 5351,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == pauseGuardian || msg.sender == admin, \"only pause guardian and admin can pause\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 5352,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == admin || state == true, \"only admin can unpause\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 5360,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(markets[address(aToken)].isListed, \"cannot pause a market that is not listed\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 5361,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == pauseGuardian || msg.sender == admin, \"only pause guardian and admin can pause\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 5362,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == admin || state == true, \"only admin can unpause\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 5370,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == pauseGuardian || msg.sender == admin, \"only pause guardian and admin can pause\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 5371,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == admin || state == true, \"only admin can unpause\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 5379,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == pauseGuardian || msg.sender == admin, \"only pause guardian and admin can pause\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 5380,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == admin || state == true, \"only admin can unpause\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 5388,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == unitroller.admin(), \"only unitroller admin can change brains\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 5389,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(unitroller._acceptImplementation() == 0, \"change not authorized\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 5416,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(market.isListed == true, \"atlantis market is not listed\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 5584,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(markets[address(aToken)].isListed, \"market must be listed\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 5630,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(adminOrInitializing(), \"only admin can grant atlantis\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 5632,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(amountLeft == 0, \"insufficient atlantis for grant\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 5642,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(adminOrInitializing(), \"only admin can set atlantis speed\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 5652,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(adminOrInitializing(), \"only admin can set atlantis speed\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 5673,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == admin, \"only admin can set Atlantis vault rate\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 5687,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == admin, \"only admin can set vault info\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 5688,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(releaseStartBlock_ > 0, \"Release start block should be greater than 0\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 5896,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(failTransferToAddresses[to] == false, \"TOKEN_TRANSFER_OUT_FAILED\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 6122,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(failTransferToAddresses[to] == false, \"TOKEN_TRANSFER_OUT_FAILED\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 6265,
          "vulnerability_to_line": null,
          "vulnerability_code": "      revert(\"protect the baby\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 1274,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(accrualBlockNumber == 0 && borrowIndex == 0, \"market may only be initialized once\");\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 5302,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(numMarkets != 0 && numMarkets == numBorrowCaps, \"invalid input\");\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4161,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (spender != src && spenderAllowance != uint96(-1)) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4162,
          "vulnerability_to_line": null,
          "vulnerability_code": "            uint96 newAllowance = sub96(spenderAllowance, amount, \"Atlantis::transferFrom: transfer amount exceeds spender allowance\");\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4163,
          "vulnerability_to_line": null,
          "vulnerability_code": "            allowances[src][spender] = newAllowance;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4164,
          "vulnerability_to_line": null,
          "vulnerability_code": "\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4165,
          "vulnerability_to_line": null,
          "vulnerability_code": "            emit Approval(src, spender, newAllowance);\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4166,
          "vulnerability_to_line": null,
          "vulnerability_code": "        }\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4273,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (srcRep != dstRep && amount > 0) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4274,
          "vulnerability_to_line": null,
          "vulnerability_code": "            if (srcRep != address(0)) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4275,
          "vulnerability_to_line": null,
          "vulnerability_code": "                uint32 srcRepNum = numCheckpoints[srcRep];\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4276,
          "vulnerability_to_line": null,
          "vulnerability_code": "                uint96 srcRepOld = srcRepNum > 0 ? checkpoints[srcRep][srcRepNum - 1].votes : 0;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4277,
          "vulnerability_to_line": null,
          "vulnerability_code": "                uint96 srcRepNew = sub96(srcRepOld, amount, \"Atlantis::_moveVotes: vote amount underflows\");\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4278,
          "vulnerability_to_line": null,
          "vulnerability_code": "                _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4279,
          "vulnerability_to_line": null,
          "vulnerability_code": "            }\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4280,
          "vulnerability_to_line": null,
          "vulnerability_code": "\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4281,
          "vulnerability_to_line": null,
          "vulnerability_code": "            if (dstRep != address(0)) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4282,
          "vulnerability_to_line": null,
          "vulnerability_code": "                uint32 dstRepNum = numCheckpoints[dstRep];\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4293,
          "vulnerability_to_line": null,
          "vulnerability_code": "      if (nCheckpoints > 0 && checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4294,
          "vulnerability_to_line": null,
          "vulnerability_code": "          checkpoints[delegatee][nCheckpoints - 1].votes = newVotes;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4295,
          "vulnerability_to_line": null,
          "vulnerability_code": "      } else {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4296,
          "vulnerability_to_line": null,
          "vulnerability_code": "          checkpoints[delegatee][nCheckpoints] = Checkpoint(blockNumber, newVotes);\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4297,
          "vulnerability_to_line": null,
          "vulnerability_code": "          numCheckpoints[delegatee] = nCheckpoints + 1;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4298,
          "vulnerability_to_line": null,
          "vulnerability_code": "      }\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4657,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (redeemTokens == 0 && redeemAmount > 0) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4658,
          "vulnerability_to_line": null,
          "vulnerability_code": "            revert(\"redeemTokens zero\");\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4659,
          "vulnerability_to_line": null,
          "vulnerability_code": "        }\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 5217,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (newCollateralFactorMantissa != 0 && oracle.getUnderlyingPrice(aToken) == 0) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 5218,
          "vulnerability_to_line": null,
          "vulnerability_code": "            return fail(Error.PRICE_ERROR, FailureInfo.SET_COLLATERAL_FACTOR_WITHOUT_PRICE);\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 5219,
          "vulnerability_to_line": null,
          "vulnerability_code": "        }\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 5418,
          "vulnerability_to_line": null,
          "vulnerability_code": "            if (atlantisSupplyState[address(aToken)].index == 0 && atlantisSupplyState[address(aToken)].block == 0) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 5419,
          "vulnerability_to_line": null,
          "vulnerability_code": "                atlantisSupplyState[address(aToken)] = AtlantisMarketState({\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 5420,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    index: atlantisInitialIndex,\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 5421,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    block: safe32(getBlockNumber(), \"block number exceeds 32 bits\")\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 5422,
          "vulnerability_to_line": null,
          "vulnerability_code": "                });\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 5423,
          "vulnerability_to_line": null,
          "vulnerability_code": "            }\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 5425,
          "vulnerability_to_line": null,
          "vulnerability_code": "            if (atlantisBorrowState[address(aToken)].index == 0 && atlantisBorrowState[address(aToken)].block == 0) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 5426,
          "vulnerability_to_line": null,
          "vulnerability_code": "                atlantisBorrowState[address(aToken)] = AtlantisMarketState({\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 5427,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    index: atlantisInitialIndex,\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 5428,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    block: safe32(getBlockNumber(), \"block number exceeds 32 bits\")\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 5429,
          "vulnerability_to_line": null,
          "vulnerability_code": "                });\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 5430,
          "vulnerability_to_line": null,
          "vulnerability_code": "            }\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 5448,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (deltaBlocks > 0 && supplySpeed > 0) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 5449,
          "vulnerability_to_line": null,
          "vulnerability_code": "            uint supplyTokens = AToken(aToken).totalSupply();\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 5450,
          "vulnerability_to_line": null,
          "vulnerability_code": "            uint atlantisAccrued = mul_(deltaBlocks, supplySpeed);\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 5451,
          "vulnerability_to_line": null,
          "vulnerability_code": "            Double memory ratio = supplyTokens > 0 ? fraction(atlantisAccrued, supplyTokens) : Double({mantissa: 0});\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 5452,
          "vulnerability_to_line": null,
          "vulnerability_code": "            Double memory index = add_(Double({mantissa: supplyState.index}), ratio);\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 5453,
          "vulnerability_to_line": null,
          "vulnerability_code": "            atlantisSupplyState[aToken] = AtlantisMarketState({\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 5454,
          "vulnerability_to_line": null,
          "vulnerability_code": "                index: safe224(index.mantissa, \"new index exceeds 224 bits\"),\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 5455,
          "vulnerability_to_line": null,
          "vulnerability_code": "                block: safe32(blockNumber, \"block number exceeds 32 bits\")\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 5456,
          "vulnerability_to_line": null,
          "vulnerability_code": "            });\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 5457,
          "vulnerability_to_line": null,
          "vulnerability_code": "        } else if (deltaBlocks > 0) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 5471,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (deltaBlocks > 0 && borrowSpeed > 0) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 5472,
          "vulnerability_to_line": null,
          "vulnerability_code": "            uint borrowAmount = div_(AToken(aToken).totalBorrows(), marketBorrowIndex);\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 5473,
          "vulnerability_to_line": null,
          "vulnerability_code": "            uint atlantisAccrued = mul_(deltaBlocks, borrowSpeed);\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 5474,
          "vulnerability_to_line": null,
          "vulnerability_code": "            Double memory ratio = borrowAmount > 0 ? fraction(atlantisAccrued, borrowAmount) : Double({mantissa: 0});\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 5475,
          "vulnerability_to_line": null,
          "vulnerability_code": "            Double memory index = add_(Double({mantissa: borrowState.index}), ratio);\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 5476,
          "vulnerability_to_line": null,
          "vulnerability_code": "            atlantisBorrowState[aToken] = AtlantisMarketState({\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 5477,
          "vulnerability_to_line": null,
          "vulnerability_code": "                index: safe224(index.mantissa, \"new index exceeds 224 bits\"),\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 5478,
          "vulnerability_to_line": null,
          "vulnerability_code": "                block: safe32(blockNumber, \"block number exceeds 32 bits\")\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 5479,
          "vulnerability_to_line": null,
          "vulnerability_code": "            });\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 5480,
          "vulnerability_to_line": null,
          "vulnerability_code": "        } else if (deltaBlocks > 0) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 5500,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (supplierIndex.mantissa == 0 && supplyIndex.mantissa > 0) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 5501,
          "vulnerability_to_line": null,
          "vulnerability_code": "            supplierIndex.mantissa = atlantisInitialIndex;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 5502,
          "vulnerability_to_line": null,
          "vulnerability_code": "        }\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 5546,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (deltaBlocks > 0 && atlantisSpeed > 0) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 5547,
          "vulnerability_to_line": null,
          "vulnerability_code": "            uint newAccrued = mul_(deltaBlocks, atlantisSpeed);\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 5548,
          "vulnerability_to_line": null,
          "vulnerability_code": "            uint contributorAccrued = add_(atlantisAccrued[contributor], newAccrued);\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 5549,
          "vulnerability_to_line": null,
          "vulnerability_code": "\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 5550,
          "vulnerability_to_line": null,
          "vulnerability_code": "            atlantisAccrued[contributor] = contributorAccrued;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 5551,
          "vulnerability_to_line": null,
          "vulnerability_code": "            lastContributorBlock[contributor] = blockNumber;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 5552,
          "vulnerability_to_line": null,
          "vulnerability_code": "        }\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 5614,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (amount > 0 && amount <= atlantisRemaining) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 5615,
          "vulnerability_to_line": null,
          "vulnerability_code": "            atlantis.transfer(user, amount);\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 5616,
          "vulnerability_to_line": null,
          "vulnerability_code": "            return 0;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 5617,
          "vulnerability_to_line": null,
          "vulnerability_code": "        }\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-prefix-decrement-not-postfix",
          "vulnerability_from_line": 4547,
          "vulnerability_to_line": null,
          "vulnerability_code": "        storedList.length--;\n",
          "message": "Consider using the prefix decrement expression whenever the return value is not needed. The prefix decrement expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 4195,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(nonce == nonces[signatory]++, \"Atlantis::delegateBySig: invalid nonce\");\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 4454,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < len; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 4534,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < len; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 5063,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < assets.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 5283,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < allMarkets.length; i ++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 5304,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(uint i = 0; i < numMarkets; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 5582,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < aTokens.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 5588,
          "vulnerability_to_line": null,
          "vulnerability_code": "                for (uint j = 0; j < holders.length; j++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 5594,
          "vulnerability_to_line": null,
          "vulnerability_code": "                for (uint j = 0; j < holders.length; j++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 5599,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint j = 0; j < holders.length; j++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 5707,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < vaults.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 5835,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < allMarkets_.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 5844,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < allMarkets_.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 5854,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < allMarkets_.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 1273,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == admin, \"only admin may initialize the market\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 1274,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(accrualBlockNumber == 0 && borrowIndex == 0, \"market may only be initialized once\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 1278,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(initialExchangeRateMantissa > 0, \"initial exchange rate must be greater than zero.\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 1290,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(err == uint(Error.NO_ERROR), \"setting interest rate model failed\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 1515,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(err == MathError.NO_ERROR, \"borrowBalanceStored: borrowBalanceStoredInternal failed\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 1572,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(err == MathError.NO_ERROR, \"exchangeRateStored: exchangeRateStoredInternal failed\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 1786,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(vars.mathErr == MathError.NO_ERROR, \"MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 1789,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(vars.mathErr == MathError.NO_ERROR, \"MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 1857,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 2144,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(vars.mathErr == MathError.NO_ERROR, \"REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 2147,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(vars.mathErr == MathError.NO_ERROR, \"REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 2243,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(amountSeizeError == uint(Error.NO_ERROR), \"LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 2602,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(totalReservesNew <= totalReserves, \"reduce reserves unexpected underflow\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 2823,
          "vulnerability_to_line": null,
          "vulnerability_code": "    \trequire(address(token) != underlying, \"ABep20::sweepToken: can not sweep underlying token\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 2921,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == admin, \"only the admin may set the atlantis-like delegate\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 3026,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == admin, \"ABep20Delegator::_setImplementation: Caller must be admin\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 3427,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.value == 0,\"ABep20Delegator:fallback: cannot send value to fallback\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 3471,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == admin, \"only the admin may call _becomeImplementation\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 3483,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == admin, \"only the admin may call _resignImplementation\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 3517,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == admin, \"only the admin may initialize the implementation\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 3534,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(address(dai) == underlying, \"DAI must be the same as underlying\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 3559,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == admin, \"only the admin may abandon the implementation\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 3617,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(token.transferFrom(from, address(this), amount), \"unexpected EIP-20 transfer in return\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 4194,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(signatory != address(0), \"Atlantis::delegateBySig: invalid signature\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 4195,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(nonce == nonces[signatory]++, \"Atlantis::delegateBySig: invalid nonce\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 4196,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(now <= expiry, \"Atlantis::delegateBySig: signature expired\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 4218,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(blockNumber < block.number, \"Atlantis::getPriorVotes: not yet determined\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 4262,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(src != address(0), \"Atlantis::_transferTokens: cannot transfer from the zero address\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 4263,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(dst != address(0), \"Atlantis::_transferTokens: cannot transfer to the zero address\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 4506,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(oErr == 0, \"exitMarket: getAccountSnapshot failed\"); // semi-opaque error code\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 4819,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(borrowBalance >= repayAmount, \"Can not repay more than the total borrow\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 5297,
          "vulnerability_to_line": null,
          "vulnerability_code": "    \trequire(msg.sender == admin || msg.sender == borrowCapGuardian, \"only admin or borrow cap guardian can set borrow caps\"); \n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 5315,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == admin, \"only admin can set borrow cap guardian\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 5350,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(markets[address(aToken)].isListed, \"cannot pause a market that is not listed\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 5351,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == pauseGuardian || msg.sender == admin, \"only pause guardian and admin can pause\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 5360,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(markets[address(aToken)].isListed, \"cannot pause a market that is not listed\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 5361,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == pauseGuardian || msg.sender == admin, \"only pause guardian and admin can pause\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 5370,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == pauseGuardian || msg.sender == admin, \"only pause guardian and admin can pause\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 5379,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == pauseGuardian || msg.sender == admin, \"only pause guardian and admin can pause\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 5388,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == unitroller.admin(), \"only unitroller admin can change brains\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 5642,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(adminOrInitializing(), \"only admin can set atlantis speed\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 5652,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(adminOrInitializing(), \"only admin can set atlantis speed\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 5673,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == admin, \"only admin can set Atlantis vault rate\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 5688,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(releaseStartBlock_ > 0, \"Release start block should be greater than 0\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "compound-borrowfresh-reentrancy",
          "vulnerability_from_line": 2029,
          "vulnerability_to_line": null,
          "vulnerability_code": "        doTransferOut(borrower, borrowAmount);\n",
          "message": "Function borrowFresh() in Compound performs state update after doTransferOut()"
        },
        {
          "name": "compound-sweeptoken-not-restricted",
          "vulnerability_from_line": 2825,
          "vulnerability_to_line": null,
          "vulnerability_code": "    \ttoken.transfer(admin, balance);\n",
          "message": "Function sweepToken is allowed to be called by anyone"
        }
      ]
    },
    "slither": {
      "successfull_analysis": true,
      "errors": [
        "EXIT_CODE_53"
      ],
      "vulnerability_findings": [
        {
          "name": "controlled-delegatecall",
          "vulnerability_from_line": 3385,
          "vulnerability_to_line": 3395,
          "vulnerability_code": "    function delegateTo(address callee, bytes memory data) internal returns (bytes memory) {\n\n        (bool success, bytes memory returnData) = callee.delegatecall(data);\n\n        assembly {\n\n            if eq(success, 0) {\n\n                revert(add(returnData, 0x20), returndatasize)\n\n            }\n\n        }\n\n        return returnData;\n\n    }\n\n\n",
          "message": "ABep20Delegator.delegateTo (ABep20Harness.sol#3385-3395) uses delegatecall to a input-controlled function id\n\t(success,returnData) = callee.delegatecall(data) (ABep20Harness.sol#3386-3387)\n"
        },
        {
          "name": "controlled-delegatecall",
          "vulnerability_from_line": 3426,
          "vulnerability_to_line": 3443,
          "vulnerability_code": "    function () external payable {\n\n        require(msg.value == 0,\"ABep20Delegator:fallback: cannot send value to fallback\");\n\n\n\n        // delegate all other functions to current implementation\n\n        (bool success, ) = implementation.delegatecall(msg.data);\n\n\n\n        assembly {\n\n            let free_mem_ptr := mload(0x40)\n\n            returndatacopy(free_mem_ptr, 0, returndatasize)\n\n\n\n            switch success\n\n            case 0 { revert(free_mem_ptr, returndatasize) }\n\n            default { return(free_mem_ptr, returndatasize) }\n\n        }\n\n    }\n\n}\n\n\n",
          "message": "ABep20Delegator.fallback (ABep20Harness.sol#3426-3443) uses delegatecall to a input-controlled function id\n\t(success) = implementation.delegatecall(msg.data) (ABep20Harness.sol#3430-3432)\n"
        },
        {
          "name": "controlled-delegatecall",
          "vulnerability_from_line": 4012,
          "vulnerability_to_line": 4027,
          "vulnerability_code": "    function () payable external {\n\n        // delegate all other functions to current implementation\n\n        (bool success, ) = comptrollerImplementation.delegatecall(msg.data);\n\n\n\n        assembly {\n\n              let free_mem_ptr := mload(0x40)\n\n              returndatacopy(free_mem_ptr, 0, returndatasize)\n\n\n\n              switch success\n\n              case 0 { revert(free_mem_ptr, returndatasize) }\n\n              default { return(free_mem_ptr, returndatasize) }\n\n        }\n\n    }\n\n}\n\n\n",
          "message": "Unitroller.fallback (ABep20Harness.sol#4012-4027) uses delegatecall to a input-controlled function id\n\t(success) = comptrollerImplementation.delegatecall(msg.data) (ABep20Harness.sol#4014-4016)\n"
        },
        {
          "name": "uninitialized-state",
          "vulnerability_from_line": 3732,
          "vulnerability_to_line": 3734,
          "vulnerability_code": "    address public comptrollerImplementation;\n\n\n",
          "message": "UnitrollerAdminStorage.comptrollerImplementation (ABep20Harness.sol#3732-3734) is never initialized. It is used in:\n\t- adminOrInitializing (ABep20Harness.sol#5395-5399)\n"
        },
        {
          "name": "uninitialized-state",
          "vulnerability_from_line": 3822,
          "vulnerability_to_line": 3824,
          "vulnerability_code": "    uint public atlantisRate;\n\n\n",
          "message": "ComptrollerV3Storage.atlantisRate (ABep20Harness.sol#3822-3824) is never initialized. It is used in:\n\t- refreshAtlantisSpeeds (ABep20Harness.sol#5832-5862)\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 3412,
          "vulnerability_to_line": 3422,
          "vulnerability_code": "    function delegateToViewImplementation(bytes memory data) public view returns (bytes memory) {\n\n        (bool success, bytes memory returnData) = address(this).staticcall(abi.encodeWithSignature(\"delegateToImplementation(bytes)\", data));\n\n        assembly {\n\n            if eq(success, 0) {\n\n                revert(add(returnData, 0x20), returndatasize)\n\n            }\n\n        }\n\n        return abi.decode(returnData, (bytes));\n\n    }\n\n\n",
          "message": "ABep20Delegator.delegateToViewImplementation (ABep20Harness.sol#3412-3422) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 4324,
          "vulnerability_to_line": 4331,
          "vulnerability_code": "    function getChainId() internal pure returns (uint) {\n\n        uint256 chainId;\n\n        assembly { chainId := chainid() }\n\n        return chainId;\n\n    }\n\n}\n\n\n",
          "message": "Atlantis.getChainId (ABep20Harness.sol#4324-4331) is declared view but contains assembly code\n"
        },
        {
          "name": "erc20-interface",
          "vulnerability_from_line": 123,
          "vulnerability_to_line": 185,
          "vulnerability_code": "interface EIP20NonStandardInterface {\n\n\n\n    /**\n\n     * @notice Get the total number of tokens in circulation\n\n     * @return The supply of tokens\n\n     */\n\n    function totalSupply() external view returns (uint256);\n\n\n\n    /**\n\n     * @notice Gets the balance of the specified address\n\n     * @param owner The address from which the balance will be retrieved\n\n     * @return The balance\n\n     */\n\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n\n\n    ///\n\n    /// !!!!!!!!!!!!!!\n\n    /// !!! NOTICE !!! `transfer` does not return a value, in violation of the BEP-20 specification\n\n    /// !!!!!!!!!!!!!!\n\n    ///\n\n\n\n    /**\n\n      * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n\n      * @param dst The address of the destination account\n\n      * @param amount The number of tokens to transfer\n\n      */\n\n    function transfer(address dst, uint256 amount) external;\n\n\n\n    ///\n\n    /// !!!!!!!!!!!!!!\n\n    /// !!! NOTICE !!! `transferFrom` does not return a value, in violation of the BEP-20 specification\n\n    /// !!!!!!!!!!!!!!\n\n    ///\n\n\n\n    /**\n\n      * @notice Transfer `amount` tokens from `src` to `dst`\n\n      * @param src The address of the source account\n\n      * @param dst The address of the destination account\n\n      * @param amount The number of tokens to transfer\n\n      */\n\n    function transferFrom(address src, address dst, uint256 amount) external;\n\n\n\n    /**\n\n      * @notice Approve `spender` to transfer up to `amount` from `src`\n\n      * @dev This will overwrite the approval amount for `spender`\n\n      *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n\n      * @param spender The address of the account which may transfer tokens\n\n      * @param amount The number of tokens that are approved\n\n      * @return Whether or not the approval succeeded\n\n      */\n\n    function approve(address spender, uint256 amount) external returns (bool success);\n\n\n\n    /**\n\n      * @notice Get the current allowance from `owner` for `spender`\n\n      * @param owner The address of the account which owns the tokens to be spent\n\n      * @param spender The address of the account which may transfer tokens\n\n      * @return The number of tokens allowed to be spent\n\n      */\n\n    function allowance(address owner, address spender) external view returns (uint256 remaining);\n\n\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n",
          "message": "EIP20NonStandardInterface (ABep20Harness.sol#123-185) has incorrect ERC20 function interface(s):\n\t-transfer (ABep20Harness.sol#149)\n\t-transferFrom (ABep20Harness.sol#163)\n"
        },
        {
          "name": "erc20-interface",
          "vulnerability_from_line": 3678,
          "vulnerability_to_line": 3684,
          "vulnerability_code": "interface GemLike {\n\n    function approve(address, uint) external;\n\n    function balanceOf(address) external view returns (uint);\n\n    function transferFrom(address, address, uint) external returns (bool);\n\n}\n\n\n",
          "message": "GemLike (ABep20Harness.sol#3678-3684) has incorrect ERC20 function interface(s):\n\t-approve (ABep20Harness.sol#3679-3680)\n"
        },
        {
          "name": "erc20-interface",
          "vulnerability_from_line": 6319,
          "vulnerability_to_line": 6374,
          "vulnerability_code": "contract ADaiDelegateMakerHarness is PotLike, VatLike, GemLike, DaiJoinLike {\n\n    /* Pot */\n\n\n\n    // exchangeRate\n\n    function chi() external view returns (uint) { return 1; }\n\n\n\n    // totalSupply\n\n    function pie(address) external view returns (uint) { return 0; }\n\n\n\n    // accrueInterest -> new exchangeRate\n\n    function drip() external returns (uint) { return 0; }\n\n\n\n    // mint\n\n    function join(uint) external {}\n\n\n\n    // redeem\n\n    function exit(uint) external {}\n\n\n\n    /* Vat */\n\n\n\n    // internal dai balance\n\n    function dai(address) external view returns (uint) { return 0; }\n\n\n\n    // approve pot transfer\n\n    function hope(address) external {}\n\n\n\n    /* Gem (Dai) */\n\n\n\n    uint public totalSupply;\n\n    mapping (address => mapping (address => uint)) public allowance;\n\n    mapping (address => uint) public balanceOf;\n\n    function approve(address, uint) external {}\n\n    function transferFrom(address src, address dst, uint amount) external returns (bool) {\n\n        balanceOf[src] -= amount;\n\n        balanceOf[dst] += amount;\n\n        return true;\n\n    }\n\n\n\n    function harnessSetBalance(address account, uint amount) external {\n\n        balanceOf[account] = amount;\n\n    }\n\n\n\n    /* DaiJoin */\n\n\n\n    // vat contract\n\n    function vat() external returns (VatLike) { return this; }\n\n\n\n    // dai contract\n\n    function dai() external returns (GemLike) { return this; }\n\n\n\n    // dai -> internal dai\n\n    function join(address, uint) external payable {}\n\n\n\n    // internal dai transfer out\n\n    function exit(address, uint) external {}\n",
          "message": "ADaiDelegateMakerHarness (ABep20Harness.sol#6319-6374) has incorrect ERC20 function interface(s):\n\t-approve (ABep20Harness.sol#6350-6351)\n"
        },
        {
          "name": "incorrect-equality",
          "vulnerability_from_line": 4290,
          "vulnerability_to_line": 4303,
          "vulnerability_code": "    function _writeCheckpoint(address delegatee, uint32 nCheckpoints, uint96 oldVotes, uint96 newVotes) internal {\n\n      uint32 blockNumber = safe32(block.number, \"Atlantis::_writeCheckpoint: block number exceeds 32 bits\");\n\n\n\n      if (nCheckpoints > 0 && checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber) {\n\n          checkpoints[delegatee][nCheckpoints - 1].votes = newVotes;\n\n      } else {\n\n          checkpoints[delegatee][nCheckpoints] = Checkpoint(blockNumber, newVotes);\n\n          numCheckpoints[delegatee] = nCheckpoints + 1;\n\n      }\n\n\n\n      emit DelegateVotesChanged(delegatee, oldVotes, newVotes);\n\n    }\n\n\n",
          "message": "Atlantis._writeCheckpoint (ABep20Harness.sol#4290-4303) uses a dangerous strict equality:\n\t- nCheckpoints > 0 && checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber\n"
        },
        {
          "name": "incorrect-equality",
          "vulnerability_from_line": 5714,
          "vulnerability_to_line": 5756,
          "vulnerability_code": "    function _releaseToVaultInternal(address vault_) internal {\n\n        VaultInfo storage vaultInfo = vaultInfo[vault_];\n\n\n\n        if (atlantisVaultRate[vault_] == 0) {\n\n            return;\n\n        }\n\n        \n\n        if(vaultInfo.releaseStartBlock == 0 || getBlockNumber() < vaultInfo.releaseStartBlock) {\n\n            return;\n\n        }\n\n\n\n        Atlantis atlantis = Atlantis(getAtlantisAddress());\n\n        uint256 atlantisBalance = atlantis.balanceOf(address(this));\n\n        if(atlantisBalance == 0) {\n\n            return;\n\n        }\n\n\n\n        uint256 actualAmount;\n\n        uint256 deltaBlocks = sub_(getBlockNumber(), vaultInfo.releaseStartBlock);\n\n        // releaseAmount = atlantisVaultRate * deltaBlocks\n\n        uint256 _releaseAmount = mul_(atlantisVaultRate[vault_], deltaBlocks);\n\n\n\n        if (_releaseAmount < vaultInfo.minReleaseAmount) {\n\n            return;\n\n        }\n\n\n\n        if (atlantisBalance >= _releaseAmount) {\n\n            actualAmount = _releaseAmount;\n\n        } else {\n\n            actualAmount = atlantisBalance;\n\n        }\n\n\n\n        vaultInfo.releaseStartBlock = getBlockNumber();\n\n\n\n        address atlantisStoreAddress = IVault(vault_).getAtlantisStore();\n\n        atlantis.transfer(atlantisStoreAddress, actualAmount);\n\n        emit DistributedVaultAtlantis(vault_, actualAmount);\n\n\n\n        IVault(vault_).updatePendingRewards();\n\n    }\n\n\n\n    /**\n",
          "message": "Comptroller._releaseToVaultInternal (ABep20Harness.sol#5714-5756) uses a dangerous strict equality:\n\t- atlantisBalance == 0\n"
        },
        {
          "name": "locked-ether",
          "vulnerability_from_line": 6370,
          "vulnerability_to_line": 6372,
          "vulnerability_code": "    function join(address, uint) external payable {}\n\n\n",
          "message": "Contract locking ether found in ABep20Harness.sol:\n\tContract ADaiDelegateMakerHarness has payable functions:\n\t - join (ABep20Harness.sol#6370-6372)\n\tBut does not have a function to withdraw the ether\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 2493,
          "vulnerability_to_line": 2505,
          "vulnerability_code": "    function _addReservesInternal(uint addAmount) internal nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n\n            return fail(Error(error), FailureInfo.ADD_RESERVES_ACCRUE_INTEREST_FAILED);\n\n        }\n\n\n\n        // _addReservesFresh emits reserve-addition-specific logs on errors, so we don't need to.\n\n        (error, ) = _addReservesFresh(addAmount);\n\n        return error;\n\n    }\n\n\n",
          "message": "Reentrancy in AToken._addReservesInternal (ABep20Harness.sol#2493-2505):\n\tExternal calls:\n\t- error = accrueInterest() (ABep20Harness.sol#2494-2495)\n\tState variables written after the call(s):\n\t- totalReserves (ABep20Harness.sol#2501-2502)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 2556,
          "vulnerability_to_line": 2566,
          "vulnerability_code": "    function _reduceReserves(uint reduceAmount) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n\n            return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.\n\n        return _reduceReservesFresh(reduceAmount);\n\n    }\n\n\n",
          "message": "Reentrancy in AToken._reduceReserves (ABep20Harness.sol#2556-2566):\n\tExternal calls:\n\t- error = accrueInterest() (ABep20Harness.sol#2557-2558)\n\tState variables written after the call(s):\n\t- totalReserves (ABep20Harness.sol#2563-2564)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 2425,
          "vulnerability_to_line": 2444,
          "vulnerability_code": "    function _setComptroller(ComptrollerInterface newComptroller) public returns (uint) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COMPTROLLER_OWNER_CHECK);\n\n        }\n\n\n\n        ComptrollerInterface oldComptroller = comptroller;\n\n        // Ensure invoke comptroller.isComptroller() returns true\n\n        require(newComptroller.isComptroller(), \"marker method returned false\");\n\n\n\n        // Set market's comptroller to newComptroller\n\n        comptroller = newComptroller;\n\n\n\n        // Emit NewComptroller(oldComptroller, newComptroller)\n\n        emit NewComptroller(oldComptroller, newComptroller);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Reentrancy in AToken._setComptroller (ABep20Harness.sol#2425-2444):\n\tExternal calls:\n\t- require(bool,string)(newComptroller.isComptroller(),marker method returned false) (ABep20Harness.sol#2433-2434)\n\tState variables written after the call(s):\n\t- comptroller (ABep20Harness.sol#2436-2437)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 3025,
          "vulnerability_to_line": 3040,
          "vulnerability_code": "    function _setImplementation(address implementation_, bool allowResign, bytes memory becomeImplementationData) public {\n\n        require(msg.sender == admin, \"ABep20Delegator::_setImplementation: Caller must be admin\");\n\n\n\n        if (allowResign) {\n\n            delegateToImplementation(abi.encodeWithSignature(\"_resignImplementation()\"));\n\n        }\n\n\n\n        address oldImplementation = implementation;\n\n        implementation = implementation_;\n\n\n\n        delegateToImplementation(abi.encodeWithSignature(\"_becomeImplementation(bytes)\", becomeImplementationData));\n\n\n\n        emit NewImplementation(oldImplementation, implementation);\n\n    }\n\n\n",
          "message": "Reentrancy in ABep20Delegator._setImplementation (ABep20Harness.sol#3025-3040):\n\tExternal calls:\n\t- delegateToImplementation(abi.encodeWithSignature(_resignImplementation())) (ABep20Harness.sol#3029-3030)\n\tState variables written after the call(s):\n\t- implementation (ABep20Harness.sol#3033-3035)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 2621,
          "vulnerability_to_line": 2631,
          "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n\n        return _setInterestRateModelFresh(newInterestRateModel);\n\n    }\n\n\n",
          "message": "Reentrancy in AToken._setInterestRateModel (ABep20Harness.sol#2621-2631):\n\tExternal calls:\n\t- error = accrueInterest() (ABep20Harness.sol#2622-2623)\n\t- _setInterestRateModelFresh(newInterestRateModel) (ABep20Harness.sol#2628-2629)\n\tState variables written after the call(s):\n\t- interestRateModel (ABep20Harness.sol#2628-2629)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 2637,
          "vulnerability_to_line": 2667,
          "vulnerability_code": "    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {\n\n\n\n        // Used to store old model for use in the event that is emitted on success\n\n        InterestRateModel oldInterestRateModel;\n\n\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);\n\n        }\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);\n\n        }\n\n\n\n        // Track the market's current interest rate model\n\n        oldInterestRateModel = interestRateModel;\n\n\n\n        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true\n\n        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n\n\n\n        // Set the interest rate model to newInterestRateModel\n\n        interestRateModel = newInterestRateModel;\n\n\n\n        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)\n\n        emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Reentrancy in AToken._setInterestRateModelFresh (ABep20Harness.sol#2637-2667):\n\tExternal calls:\n\t- require(bool,string)(newInterestRateModel.isInterestRateModel(),marker method returned false) (ABep20Harness.sol#2656-2658)\n\tState variables written after the call(s):\n\t- interestRateModel (ABep20Harness.sol#2659-2661)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 2449,
          "vulnerability_to_line": 2459,
          "vulnerability_code": "    function _setReserveFactor(uint newReserveFactorMantissa) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.\n\n            return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.\n\n        return _setReserveFactorFresh(newReserveFactorMantissa);\n\n    }\n\n\n",
          "message": "Reentrancy in AToken._setReserveFactor (ABep20Harness.sol#2449-2459):\n\tExternal calls:\n\t- error = accrueInterest() (ABep20Harness.sol#2450-2451)\n\tState variables written after the call(s):\n\t- reserveFactorMantissa (ABep20Harness.sol#2456-2457)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 5261,
          "vulnerability_to_line": 5282,
          "vulnerability_code": "    function _supportMarket(AToken aToken) external returns (uint) {\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SUPPORT_MARKET_OWNER_CHECK);\n\n        }\n\n\n\n        if (markets[address(aToken)].isListed) {\n\n            return fail(Error.MARKET_ALREADY_LISTED, FailureInfo.SUPPORT_MARKET_EXISTS);\n\n        }\n\n\n\n        aToken.isAToken(); // Sanity check to make sure its really a AToken\n\n\n\n        // Note that isAtled is not in active use anymore\n\n        markets[address(aToken)] = Market({isListed: true, isAtled: false, collateralFactorMantissa: 0});\n\n\n\n        _addMarketInternal(address(aToken));\n\n\n\n        emit MarketListed(aToken);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Reentrancy in Comptroller._supportMarket (ABep20Harness.sol#5261-5282):\n\tExternal calls:\n\t- aToken.isAToken() (ABep20Harness.sol#5270)\n\tState variables written after the call(s):\n\t- markets (ABep20Harness.sol#5273-5275)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 1626,
          "vulnerability_to_line": 1704,
          "vulnerability_code": "    function accrueInterest() public returns (uint) {\n\n        /* Remember the initial block number */\n\n        uint currentBlockNumber = getBlockNumber();\n\n        uint accrualBlockNumberPrior = accrualBlockNumber;\n\n\n\n        /* Short-circuit accumulating 0 interest */\n\n        if (accrualBlockNumberPrior == currentBlockNumber) {\n\n            return uint(Error.NO_ERROR);\n\n        }\n\n\n\n        /* Read the previous values out of storage */\n\n        uint cashPrior = getCashPrior();\n\n        uint borrowsPrior = totalBorrows;\n\n        uint reservesPrior = totalReserves;\n\n        uint borrowIndexPrior = borrowIndex;\n\n\n\n        /* Calculate the current borrow interest rate */\n\n        uint borrowRateMantissa = interestRateModel.getBorrowRate(cashPrior, borrowsPrior, reservesPrior);\n\n        require(borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n\n\n\n        /* Calculate the number of blocks elapsed since the last accrual */\n\n        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);\n\n        require(mathErr == MathError.NO_ERROR, \"could not calculate block delta\");\n\n\n\n        /*\n\n         * Calculate the interest accumulated into borrows and reserves and the new index:\n\n         *  simpleInterestFactor = borrowRate * blockDelta\n\n         *  interestAccumulated = simpleInterestFactor * totalBorrows\n\n         *  totalBorrowsNew = interestAccumulated + totalBorrows\n\n         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves\n\n         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\n\n         */\n\n\n\n        Exp memory simpleInterestFactor;\n\n        uint interestAccumulated;\n\n        uint totalBorrowsNew;\n\n        uint totalReservesNew;\n\n        uint borrowIndexNew;\n\n\n\n        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa: borrowRateMantissa}), blockDelta);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED, uint(mathErr));\n\n        }\n\n\n\n        (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED, uint(mathErr));\n\n        }\n\n\n\n        (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED, uint(mathErr));\n\n        }\n\n\n\n        (mathErr, totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa: reserveFactorMantissa}), interestAccumulated, reservesPrior);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED, uint(mathErr));\n\n        }\n\n\n\n        (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndexPrior, borrowIndexPrior);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED, uint(mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accrualBlockNumber = currentBlockNumber;\n\n        borrowIndex = borrowIndexNew;\n\n        totalBorrows = totalBorrowsNew;\n\n        totalReserves = totalReservesNew;\n\n\n\n        /* We emit an AccrueInterest event */\n\n        emit AccrueInterest(cashPrior, interestAccumulated, borrowIndexNew, totalBorrowsNew);\n\n\n\n        return uint(Error.NO_ERROR);\n",
          "message": "Reentrancy in AToken.accrueInterest (ABep20Harness.sol#1626-1704):\n\tExternal calls:\n\t- borrowRateMantissa = interestRateModel.getBorrowRate(cashPrior,borrowsPrior,reservesPrior) (ABep20Harness.sol#1643)\n\tState variables written after the call(s):\n\t- accrualBlockNumber (ABep20Harness.sol#1695)\n\t- borrowIndex (ABep20Harness.sol#1696)\n\t- totalBorrows (ABep20Harness.sol#1697)\n\t- totalReserves (ABep20Harness.sol#1698)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 1957,
          "vulnerability_to_line": 1965,
          "vulnerability_code": "    function borrowInternal(uint borrowAmount) internal nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n\n            return fail(Error(error), FailureInfo.BORROW_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // borrowFresh emits borrow-specific logs on errors, so we don't need to\n\n        return borrowFresh(msg.sender, borrowAmount);\n",
          "message": "Reentrancy in AToken.borrowInternal (ABep20Harness.sol#1957-1965):\n\tExternal calls:\n\t- error = accrueInterest() (ABep20Harness.sol#1958)\n\t- borrowFresh(msg.sender,borrowAmount) (ABep20Harness.sol#1964)\n\tState variables written after the call(s):\n\t- totalBorrows (ABep20Harness.sol#1964)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 2947,
          "vulnerability_to_line": 2966,
          "vulnerability_code": "    constructor(address underlying_,\n\n                ComptrollerInterface comptroller_,\n\n                InterestRateModel interestRateModel_,\n\n                uint initialExchangeRateMantissa_,\n\n                string memory name_,\n\n                string memory symbol_,\n\n                uint8 decimals_,\n\n                address payable admin_) public {\n\n        // Creator of the contract is admin during initialization\n\n        admin = msg.sender;\n\n\n\n        // Initialize the market\n\n        initialize(underlying_, comptroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_);\n\n\n\n        // Set the proper admin now that initialization is done\n\n        admin = admin_;\n\n    }\n\n}\n\n\n",
          "message": "Reentrancy in ABep20Immutable.constructor (ABep20Harness.sol#2947-2966):\n\tExternal calls:\n\t- initialize(underlying_,comptroller_,interestRateModel_,initialExchangeRateMantissa_,name_,symbol_,decimals_) (ABep20Harness.sol#2959-2961)\n\tState variables written after the call(s):\n\t- admin (ABep20Harness.sol#2962-2963)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 2989,
          "vulnerability_to_line": 3019,
          "vulnerability_code": "    constructor(address underlying_,\n\n                ComptrollerInterface comptroller_,\n\n                InterestRateModel interestRateModel_,\n\n                uint initialExchangeRateMantissa_,\n\n                string memory name_,\n\n                string memory symbol_,\n\n                uint8 decimals_,\n\n                address payable admin_,\n\n                address implementation_,\n\n                bytes memory becomeImplementationData) public {\n\n        // Creator of the contract is admin during initialization\n\n        admin = msg.sender;\n\n\n\n        // First delegate gets to initialize the delegator (i.e. storage contract)\n\n        delegateTo(implementation_, abi.encodeWithSignature(\"initialize(address,address,address,uint256,string,string,uint8)\",\n\n                                                            underlying_,\n\n                                                            comptroller_,\n\n                                                            interestRateModel_,\n\n                                                            initialExchangeRateMantissa_,\n\n                                                            name_,\n\n                                                            symbol_,\n\n                                                            decimals_));\n\n\n\n        // New implementations always get set via the settor (post-initialize)\n\n        _setImplementation(implementation_, false, becomeImplementationData);\n\n\n\n        // Set the proper admin now that initialization is done\n\n        admin = admin_;\n\n    }\n\n\n",
          "message": "Reentrancy in ABep20Delegator.constructor (ABep20Harness.sol#2989-3019):\n\tExternal calls:\n\t- delegateTo(implementation_,abi.encodeWithSignature(initialize(address,address,address,uint256,string,string,uint8),underlying_,comptroller_,interestRateModel_,initialExchangeRateMantissa_,name_,symbol_,decimals_)) (ABep20Harness.sol#3003-3012)\n\t- _setImplementation(implementation_,false,becomeImplementationData) (ABep20Harness.sol#3013-3015)\n\tState variables written after the call(s):\n\t- admin (ABep20Harness.sol#3016-3017)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 4502,
          "vulnerability_to_line": 4554,
          "vulnerability_code": "    function exitMarket(address aTokenAddress) external returns (uint) {\n\n        AToken aToken = AToken(aTokenAddress);\n\n        /* Get sender tokensHeld and amountOwed underlying from the aToken */\n\n        (uint oErr, uint tokensHeld, uint amountOwed, ) = aToken.getAccountSnapshot(msg.sender);\n\n        require(oErr == 0, \"exitMarket: getAccountSnapshot failed\"); // semi-opaque error code\n\n\n\n        /* Fail if the sender has a borrow balance */\n\n        if (amountOwed != 0) {\n\n            return fail(Error.NONZERO_BORROW_BALANCE, FailureInfo.EXIT_MARKET_BALANCE_OWED);\n\n        }\n\n\n\n        /* Fail if the sender is not permitted to redeem all of their tokens */\n\n        uint allowed = redeemAllowedInternal(aTokenAddress, msg.sender, tokensHeld);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.REJECTION, FailureInfo.EXIT_MARKET_REJECTION, allowed);\n\n        }\n\n\n\n        Market storage marketToExit = markets[address(aToken)];\n\n\n\n        /* Return true if the sender is not already \u2018in\u2019 the market */\n\n        if (!marketToExit.accountMembership[msg.sender]) {\n\n            return uint(Error.NO_ERROR);\n\n        }\n\n\n\n        /* Set aToken account membership to false */\n\n        delete marketToExit.accountMembership[msg.sender];\n\n\n\n        /* Delete aToken from the account\u2019s list of assets */\n\n        // load into memory for faster iteration\n\n        AToken[] memory userAssetList = accountAssets[msg.sender];\n\n        uint len = userAssetList.length;\n\n        uint assetIndex = len;\n\n        for (uint i = 0; i < len; i++) {\n\n            if (userAssetList[i] == aToken) {\n\n                assetIndex = i;\n\n                break;\n\n            }\n\n        }\n\n\n\n        // We *must* have found the asset in the list or our redundant data structure is broken\n\n        assert(assetIndex < len);\n\n\n\n        // copy last item in list to location of item to be removed, reduce length by 1\n\n        AToken[] storage storedList = accountAssets[msg.sender];\n\n        storedList[assetIndex] = storedList[storedList.length - 1];\n\n        storedList.length--;\n\n\n\n        emit MarketExited(aToken, msg.sender);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Reentrancy in Comptroller.exitMarket (ABep20Harness.sol#4502-4554):\n\tExternal calls:\n\t- (oErr,tokensHeld,amountOwed) = aToken.getAccountSnapshot(msg.sender) (ABep20Harness.sol#4505-4506)\n\t- allowed = redeemAllowedInternal(aTokenAddress,msg.sender,tokensHeld) (ABep20Harness.sol#4514-4515)\n\tState variables written after the call(s):\n\t- accountAssets (ABep20Harness.sol#4546-4547)\n\t- accountAssets (ABep20Harness.sol#4547-4549)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 1267,
          "vulnerability_to_line": 1298,
          "vulnerability_code": "    function initialize(ComptrollerInterface comptroller_,\n\n                        InterestRateModel interestRateModel_,\n\n                        uint initialExchangeRateMantissa_,\n\n                        string memory name_,\n\n                        string memory symbol_,\n\n                        uint8 decimals_) public {\n\n        require(msg.sender == admin, \"only admin may initialize the market\");\n\n        require(accrualBlockNumber == 0 && borrowIndex == 0, \"market may only be initialized once\");\n\n\n\n        // Set initial exchange rate\n\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n\n        require(initialExchangeRateMantissa > 0, \"initial exchange rate must be greater than zero.\");\n\n\n\n        // Set the comptroller\n\n        uint err = _setComptroller(comptroller_);\n\n        require(err == uint(Error.NO_ERROR), \"setting comptroller failed\");\n\n\n\n        // Initialize block number and borrow index (block number mocks depend on comptroller being set)\n\n        accrualBlockNumber = getBlockNumber();\n\n        borrowIndex = mantissaOne;\n\n\n\n        // Set the interest rate model (depends on block number / borrow index)\n\n        err = _setInterestRateModelFresh(interestRateModel_);\n\n        require(err == uint(Error.NO_ERROR), \"setting interest rate model failed\");\n\n\n\n        name = name_;\n\n        symbol = symbol_;\n\n        decimals = decimals_;\n\n\n\n        // The counter starts true to prevent changing it from zero to non-zero (i.e. smaller cost/refund)\n\n        _notEntered = true;\n",
          "message": "Reentrancy in AToken.initialize (ABep20Harness.sol#1267-1298):\n\tExternal calls:\n\t- err = _setComptroller(comptroller_) (ABep20Harness.sol#1281)\n\tState variables written after the call(s):\n\t- accrualBlockNumber (ABep20Harness.sol#1285)\n\t- borrowIndex (ABep20Harness.sol#1286)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 2172,
          "vulnerability_to_line": 2187,
          "vulnerability_code": "    function liquidateBorrowInternal(address borrower, uint repayAmount, ATokenInterface aTokenCollateral) internal nonReentrant returns (uint, uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\n\n            return (fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED), 0);\n\n        }\n\n\n\n        error = aTokenCollateral.accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\n\n            return (fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED), 0);\n\n        }\n\n\n\n        // liquidateBorrowFresh emits borrow-specific logs on errors, so we don't need to\n\n        return liquidateBorrowFresh(msg.sender, borrower, repayAmount, aTokenCollateral);\n",
          "message": "Reentrancy in AToken.liquidateBorrowInternal (ABep20Harness.sol#2172-2187):\n\tExternal calls:\n\t- error = accrueInterest() (ABep20Harness.sol#2173)\n\t- error = aTokenCollateral.accrueInterest() (ABep20Harness.sol#2179)\n\t- liquidateBorrowFresh(msg.sender,borrower,repayAmount,aTokenCollateral) (ABep20Harness.sol#2186)\n\tState variables written after the call(s):\n\t- totalBorrows (ABep20Harness.sol#2186)\n\t- totalReserves (ABep20Harness.sol#2186)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 1856,
          "vulnerability_to_line": 1950,
          "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n\n\n\n        RedeemLocalVars memory vars;\n\n\n\n        /* exchangeRate = invoke Exchange Rate Stored() */\n\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* If redeemTokensIn > 0: */\n\n        if (redeemTokensIn > 0) {\n\n            /*\n\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\n\n             *  redeemTokens = redeemTokensIn\n\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n\n             */\n\n            vars.redeemTokens = redeemTokensIn;\n\n\n\n            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED, uint(vars.mathErr));\n\n            }\n\n        } else {\n\n            /*\n\n             * We get the current exchange rate and calculate the amount to be redeemed:\n\n             *  redeemTokens = redeemAmountIn / exchangeRate\n\n             *  redeemAmount = redeemAmountIn\n\n             */\n\n\n\n            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED, uint(vars.mathErr));\n\n            }\n\n\n\n            vars.redeemAmount = redeemAmountIn;\n\n        }\n\n\n\n        /* Fail if redeem not allowed */\n\n        uint allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);\n\n        }\n\n\n\n        /*\n\n         * We calculate the new total supply and redeemer balance, checking for underflow:\n\n         *  totalSupplyNew = totalSupply - redeemTokens\n\n         *  accountTokensNew = accountTokens[redeemer] - redeemTokens\n\n         */\n\n        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* Fail gracefully if protocol has insufficient cash */\n\n        if (getCashPrior() < vars.redeemAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We invoke doTransferOut for the redeemer and the redeemAmount.\n\n         *  Note: The aToken must handle variations between BEP-20 and BNB underlying.\n\n         *  On success, the aToken has redeemAmount less of cash.\n\n         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n\n         */\n\n        doTransferOut(redeemer, vars.redeemAmount);\n\n\n\n        /* We write previously calculated values into storage */\n\n        totalSupply = vars.totalSupplyNew;\n\n        accountTokens[redeemer] = vars.accountTokensNew;\n\n\n\n        /* We emit a Transfer event, and a Redeem event */\n\n        emit Transfer(redeemer, address(this), vars.redeemTokens);\n\n        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        /* We call the defense hook */\n\n        comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        return uint(Error.NO_ERROR);\n",
          "message": "Reentrancy in AToken.redeemFresh (ABep20Harness.sol#1856-1950):\n\tExternal calls:\n\t- allowed = comptroller.redeemAllowed(address(this),redeemer,vars.redeemTokens) (ABep20Harness.sol#1896)\n\tState variables written after the call(s):\n\t- totalSupply (ABep20Harness.sol#1939)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 2067,
          "vulnerability_to_line": 2075,
          "vulnerability_code": "    function repayBorrowBehalfInternal(address borrower, uint repayAmount) internal nonReentrant returns (uint, uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n\n            return (fail(Error(error), FailureInfo.REPAY_BEHALF_ACCRUE_INTEREST_FAILED), 0);\n\n        }\n\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n\n        return repayBorrowFresh(msg.sender, borrower, repayAmount);\n",
          "message": "Reentrancy in AToken.repayBorrowBehalfInternal (ABep20Harness.sol#2067-2075):\n\tExternal calls:\n\t- error = accrueInterest() (ABep20Harness.sol#2068)\n\t- repayBorrowFresh(msg.sender,borrower,repayAmount) (ABep20Harness.sol#2074)\n\tState variables written after the call(s):\n\t- totalBorrows (ABep20Harness.sol#2074)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 2051,
          "vulnerability_to_line": 2059,
          "vulnerability_code": "    function repayBorrowInternal(uint repayAmount) internal nonReentrant returns (uint, uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n\n            return (fail(Error(error), FailureInfo.REPAY_BORROW_ACCRUE_INTEREST_FAILED), 0);\n\n        }\n\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n\n        return repayBorrowFresh(msg.sender, msg.sender, repayAmount);\n",
          "message": "Reentrancy in AToken.repayBorrowInternal (ABep20Harness.sol#2051-2059):\n\tExternal calls:\n\t- error = accrueInterest() (ABep20Harness.sol#2052)\n\t- repayBorrowFresh(msg.sender,msg.sender,repayAmount) (ABep20Harness.sol#2058)\n\tState variables written after the call(s):\n\t- totalBorrows (ABep20Harness.sol#2058)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 4877,
          "vulnerability_to_line": 4906,
          "vulnerability_code": "    function seizeAllowed(\n\n        address aTokenCollateral,\n\n        address aTokenBorrowed,\n\n        address liquidator,\n\n        address borrower,\n\n        uint seizeTokens) external returns (uint) {\n\n        // Pausing is a very serious situation - we revert to sound the alarms\n\n        require(!seizeGuardianPaused, \"seize is paused\");\n\n\n\n        // Shh - currently unused\n\n        seizeTokens;\n\n\n\n        if (!markets[aTokenCollateral].isListed || !markets[aTokenBorrowed].isListed) {\n\n            return uint(Error.MARKET_NOT_LISTED);\n\n        }\n\n\n\n        if (AToken(aTokenCollateral).comptroller() != AToken(aTokenBorrowed).comptroller()) {\n\n            return uint(Error.COMPTROLLER_MISMATCH);\n\n        }\n\n\n\n        // Keep the flywheel moving\n\n        updateAtlantisSupplyIndex(aTokenCollateral);\n\n        distributeSupplierAtlantis(aTokenCollateral, borrower);\n\n        distributeSupplierAtlantis(aTokenCollateral, liquidator);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
          "message": "Reentrancy in Comptroller.seizeAllowed (ABep20Harness.sol#4877-4906):\n\tExternal calls:\n\t- updateAtlantisSupplyIndex(aTokenCollateral) (ABep20Harness.sol#4898-4899)\n\t- distributeSupplierAtlantis(aTokenCollateral,borrower) (ABep20Harness.sol#4899-4900)\n\t- distributeSupplierAtlantis(aTokenCollateral,liquidator) (ABep20Harness.sol#4900-4902)\n\tState variables written after the call(s):\n\t- atlantisAccrued (ABep20Harness.sol#4900-4902)\n\t- atlantisSupplierIndex (ABep20Harness.sol#4900-4902)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 5406,
          "vulnerability_to_line": 5440,
          "vulnerability_code": "    function setAtlantisSpeedInternal(AToken aToken, uint atlantisSpeed) internal {\n\n        uint currentAtlantisSpeed = atlantisSpeeds[address(aToken)];\n\n        if (currentAtlantisSpeed != 0) {\n\n            // note that Atlantis speed could be set to 0 to halt liquidity rewards for a market\n\n            Exp memory borrowIndex = Exp({mantissa: aToken.borrowIndex()});\n\n            updateAtlantisSupplyIndex(address(aToken));\n\n            updateAtlantisBorrowIndex(address(aToken), borrowIndex);\n\n        } else if (atlantisSpeed != 0) {\n\n            // Add the Atlantis market\n\n            Market storage market = markets[address(aToken)];\n\n            require(market.isListed == true, \"atlantis market is not listed\");\n\n\n\n            if (atlantisSupplyState[address(aToken)].index == 0 && atlantisSupplyState[address(aToken)].block == 0) {\n\n                atlantisSupplyState[address(aToken)] = AtlantisMarketState({\n\n                    index: atlantisInitialIndex,\n\n                    block: safe32(getBlockNumber(), \"block number exceeds 32 bits\")\n\n                });\n\n            }\n\n\n\n            if (atlantisBorrowState[address(aToken)].index == 0 && atlantisBorrowState[address(aToken)].block == 0) {\n\n                atlantisBorrowState[address(aToken)] = AtlantisMarketState({\n\n                    index: atlantisInitialIndex,\n\n                    block: safe32(getBlockNumber(), \"block number exceeds 32 bits\")\n\n                });\n\n            }\n\n        }\n\n\n\n        if (currentAtlantisSpeed != atlantisSpeed) {\n\n            atlantisSpeeds[address(aToken)] = atlantisSpeed;\n\n            emit AtlantisSpeedUpdated(aToken, atlantisSpeed);\n\n        }\n\n    }\n\n\n\n    /**\n",
          "message": "Reentrancy in Comptroller.setAtlantisSpeedInternal (ABep20Harness.sol#5406-5440):\n\tExternal calls:\n\t- borrowIndex = Exp(aToken.borrowIndex()) (ABep20Harness.sol#5410-5411)\n\t- updateAtlantisSupplyIndex(address(aToken)) (ABep20Harness.sol#5411-5412)\n\t- updateAtlantisBorrowIndex(address(aToken),borrowIndex) (ABep20Harness.sol#5412-5413)\n\tState variables written after the call(s):\n\t- atlantisSpeeds (ABep20Harness.sol#5434-5435)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 4940,
          "vulnerability_to_line": 4960,
          "vulnerability_code": "    function transferAllowed(address aToken, address src, address dst, uint transferTokens) external returns (uint) {\n\n        // Pausing is a very serious situation - we revert to sound the alarms\n\n        require(!transferGuardianPaused, \"transfer is paused\");\n\n\n\n        // Currently the only consideration is whether or not\n\n        //  the src is allowed to redeem this many tokens\n\n        uint allowed = redeemAllowedInternal(aToken, src, transferTokens);\n\n        if (allowed != uint(Error.NO_ERROR)) {\n\n            return allowed;\n\n        }\n\n\n\n        // Keep the flywheel moving\n\n        updateAtlantisSupplyIndex(aToken);\n\n        distributeSupplierAtlantis(aToken, src);\n\n        distributeSupplierAtlantis(aToken, dst);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
          "message": "Reentrancy in Comptroller.transferAllowed (ABep20Harness.sol#4940-4960):\n\tExternal calls:\n\t- allowed = redeemAllowedInternal(aToken,src,transferTokens) (ABep20Harness.sol#4946-4947)\n\t- updateAtlantisSupplyIndex(aToken) (ABep20Harness.sol#4952-4953)\n\t- distributeSupplierAtlantis(aToken,src) (ABep20Harness.sol#4953-4954)\n\t- distributeSupplierAtlantis(aToken,dst) (ABep20Harness.sol#4954-4956)\n\tState variables written after the call(s):\n\t- atlantisAccrued (ABep20Harness.sol#4954-4956)\n\t- atlantisSupplierIndex (ABep20Harness.sol#4954-4956)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 5466,
          "vulnerability_to_line": 5486,
          "vulnerability_code": "    function updateAtlantisBorrowIndex(address aToken, Exp memory marketBorrowIndex) internal {\n\n        AtlantisMarketState storage borrowState = atlantisBorrowState[aToken];\n\n        uint borrowSpeed = atlantisSpeeds[aToken];\n\n        uint blockNumber = getBlockNumber();\n\n        uint deltaBlocks = sub_(blockNumber, uint(borrowState.block));\n\n        if (deltaBlocks > 0 && borrowSpeed > 0) {\n\n            uint borrowAmount = div_(AToken(aToken).totalBorrows(), marketBorrowIndex);\n\n            uint atlantisAccrued = mul_(deltaBlocks, borrowSpeed);\n\n            Double memory ratio = borrowAmount > 0 ? fraction(atlantisAccrued, borrowAmount) : Double({mantissa: 0});\n\n            Double memory index = add_(Double({mantissa: borrowState.index}), ratio);\n\n            atlantisBorrowState[aToken] = AtlantisMarketState({\n\n                index: safe224(index.mantissa, \"new index exceeds 224 bits\"),\n\n                block: safe32(blockNumber, \"block number exceeds 32 bits\")\n\n            });\n\n        } else if (deltaBlocks > 0) {\n\n            borrowState.block = safe32(blockNumber, \"block number exceeds 32 bits\");\n\n        }\n\n    }\n\n\n\n    /**\n",
          "message": "Reentrancy in Comptroller.updateAtlantisBorrowIndex (ABep20Harness.sol#5466-5486):\n\tExternal calls:\n\t- borrowAmount = div_(AToken(aToken).totalBorrows(),marketBorrowIndex) (ABep20Harness.sol#5472-5473)\n\tState variables written after the call(s):\n\t- atlantisBorrowState (ABep20Harness.sol#5476-5480)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 5443,
          "vulnerability_to_line": 5463,
          "vulnerability_code": "    function updateAtlantisSupplyIndex(address aToken) internal {\n\n        AtlantisMarketState storage supplyState = atlantisSupplyState[aToken];\n\n        uint supplySpeed = atlantisSpeeds[aToken];\n\n        uint blockNumber = getBlockNumber();\n\n        uint deltaBlocks = sub_(blockNumber, uint(supplyState.block));\n\n        if (deltaBlocks > 0 && supplySpeed > 0) {\n\n            uint supplyTokens = AToken(aToken).totalSupply();\n\n            uint atlantisAccrued = mul_(deltaBlocks, supplySpeed);\n\n            Double memory ratio = supplyTokens > 0 ? fraction(atlantisAccrued, supplyTokens) : Double({mantissa: 0});\n\n            Double memory index = add_(Double({mantissa: supplyState.index}), ratio);\n\n            atlantisSupplyState[aToken] = AtlantisMarketState({\n\n                index: safe224(index.mantissa, \"new index exceeds 224 bits\"),\n\n                block: safe32(blockNumber, \"block number exceeds 32 bits\")\n\n            });\n\n        } else if (deltaBlocks > 0) {\n\n            supplyState.block = safe32(blockNumber, \"block number exceeds 32 bits\");\n\n        }\n\n    }\n\n\n\n    /**\n",
          "message": "Reentrancy in Comptroller.updateAtlantisSupplyIndex (ABep20Harness.sol#5443-5463):\n\tExternal calls:\n\t- supplyTokens = AToken(aToken).totalSupply() (ABep20Harness.sol#5449-5450)\n\tState variables written after the call(s):\n\t- atlantisSupplyState (ABep20Harness.sol#5453-5457)\n"
        },
        {
          "name": "uninitialized-local",
          "vulnerability_from_line": 2107,
          "vulnerability_to_line": null,
          "vulnerability_code": "        RepayBorrowLocalVars memory vars;\n",
          "message": "vars in AToken.repayBorrowFresh (ABep20Harness.sol#2107) is a local variable never initialiazed\n"
        },
        {
          "name": "uninitialized-local",
          "vulnerability_from_line": 2514,
          "vulnerability_to_line": 2516,
          "vulnerability_code": "        uint actualAddAmount;\n\n\n",
          "message": "actualAddAmount in AToken._addReservesFresh (ABep20Harness.sol#2514-2516) is a local variable never initialiazed\n"
        },
        {
          "name": "uninitialized-local",
          "vulnerability_from_line": 1751,
          "vulnerability_to_line": null,
          "vulnerability_code": "        MintLocalVars memory vars;\n",
          "message": "vars in AToken.mintFresh (ABep20Harness.sol#1751) is a local variable never initialiazed\n"
        },
        {
          "name": "uninitialized-local",
          "vulnerability_from_line": 4704,
          "vulnerability_to_line": null,
          "vulnerability_code": "        (Error err, , uint shortfall) = getHypotheticalAccountLiquidityInternal(borrower, AToken(aToken), 0, borrowAmount);\n",
          "message": "err_scope_0 in Comptroller.borrowAllowed (ABep20Harness.sol#4704) is a local variable never initialiazed\n"
        },
        {
          "name": "uninitialized-local",
          "vulnerability_from_line": 1997,
          "vulnerability_to_line": null,
          "vulnerability_code": "        BorrowLocalVars memory vars;\n",
          "message": "vars in AToken.borrowFresh (ABep20Harness.sol#1997) is a local variable never initialiazed\n"
        },
        {
          "name": "uninitialized-local",
          "vulnerability_from_line": 2316,
          "vulnerability_to_line": null,
          "vulnerability_code": "        SeizeInternalLocalVars memory vars;\n",
          "message": "vars in AToken.seizeInternal (ABep20Harness.sol#2316) is a local variable never initialiazed\n"
        },
        {
          "name": "uninitialized-local",
          "vulnerability_from_line": 1859,
          "vulnerability_to_line": null,
          "vulnerability_code": "        RedeemLocalVars memory vars;\n",
          "message": "vars in AToken.redeemFresh (ABep20Harness.sol#1859) is a local variable never initialiazed\n"
        },
        {
          "name": "unused-return",
          "vulnerability_from_line": 2727,
          "vulnerability_to_line": 2742,
          "vulnerability_code": "    function initialize(address underlying_,\n\n                        ComptrollerInterface comptroller_,\n\n                        InterestRateModel interestRateModel_,\n\n                        uint initialExchangeRateMantissa_,\n\n                        string memory name_,\n\n                        string memory symbol_,\n\n                        uint8 decimals_) public {\n\n        // AToken initialize does the bulk of the work\n\n        super.initialize(comptroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_);\n\n\n\n        // Set underlying and sanity check it\n\n        underlying = underlying_;\n\n        EIP20Interface(underlying).totalSupply();\n\n    }\n\n\n",
          "message": "ABep20.initialize (ABep20Harness.sol#2727-2742) does not use the value returned by external calls:\n\t-EIP20Interface(underlying).totalSupply() (ABep20Harness.sol#2739-2740)\n"
        },
        {
          "name": "unused-return",
          "vulnerability_from_line": 3587,
          "vulnerability_to_line": 3595,
          "vulnerability_code": "    function accrueInterest() public returns (uint) {\n\n        // Accumulate DSR interest\n\n        PotLike(potAddress).drip();\n\n\n\n        // Accumulate AToken interest\n\n        return super.accrueInterest();\n\n    }\n\n\n",
          "message": "ADaiDelegate.accrueInterest (ABep20Harness.sol#3587-3595) does not use the value returned by external calls:\n\t-PotLike(potAddress).drip() (ABep20Harness.sol#3589-3591)\n"
        },
        {
          "name": "unused-return",
          "vulnerability_from_line": 3558,
          "vulnerability_to_line": 3580,
          "vulnerability_code": "    function _resignImplementation() public {\n\n        require(msg.sender == admin, \"only the admin may abandon the implementation\");\n\n\n\n        // Transfer all cash out of the DSR - note that this relies on self-transfer\n\n        DaiJoinLike daiJoin = DaiJoinLike(daiJoinAddress);\n\n        PotLike pot = PotLike(potAddress);\n\n        VatLike vat = VatLike(vatAddress);\n\n\n\n        // Accumulate interest\n\n        pot.drip();\n\n\n\n        // Calculate the total amount in the pot, and move it out\n\n        uint pie = pot.pie(address(this));\n\n        pot.exit(pie);\n\n\n\n        // Checks the actual balance of DAI in the vat after the pot exit\n\n        uint bal = vat.dai(address(this));\n\n\n\n        // Remove our whole balance\n\n        daiJoin.exit(address(this), bal / RAY);\n\n    }\n\n\n",
          "message": "ADaiDelegate._resignImplementation (ABep20Harness.sol#3558-3580) does not use the value returned by external calls:\n\t-pot.drip() (ABep20Harness.sol#3567-3569)\n"
        },
        {
          "name": "unused-return",
          "vulnerability_from_line": 3528,
          "vulnerability_to_line": 3555,
          "vulnerability_code": "    function _becomeImplementation(address daiJoinAddress_, address potAddress_) internal {\n\n        // Get dai and vat and sanity check the underlying\n\n        DaiJoinLike daiJoin = DaiJoinLike(daiJoinAddress_);\n\n        PotLike pot = PotLike(potAddress_);\n\n        GemLike dai = daiJoin.dai();\n\n        VatLike vat = daiJoin.vat();\n\n        require(address(dai) == underlying, \"DAI must be the same as underlying\");\n\n\n\n        // Remember the relevant addresses\n\n        daiJoinAddress = daiJoinAddress_;\n\n        potAddress = potAddress_;\n\n        vatAddress = address(vat);\n\n\n\n        // Approve moving our DAI into the vat through daiJoin\n\n        dai.approve(daiJoinAddress, uint(-1));\n\n\n\n        // Approve the pot to transfer our funds within the vat\n\n        vat.hope(potAddress);\n\n        vat.hope(daiJoinAddress);\n\n\n\n        // Accumulate DSR interest -- must do this in order to doTransferIn\n\n        pot.drip();\n\n\n\n        // Transfer all cash in (doTransferIn does this regardless of amount)\n\n        doTransferIn(address(this), 0);\n\n    }\n\n\n",
          "message": "ADaiDelegate._becomeImplementation (ABep20Harness.sol#3528-3555) does not use the value returned by external calls:\n\t-pot.drip() (ABep20Harness.sol#3549-3551)\n"
        },
        {
          "name": "unused-return",
          "vulnerability_from_line": 5261,
          "vulnerability_to_line": 5282,
          "vulnerability_code": "    function _supportMarket(AToken aToken) external returns (uint) {\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SUPPORT_MARKET_OWNER_CHECK);\n\n        }\n\n\n\n        if (markets[address(aToken)].isListed) {\n\n            return fail(Error.MARKET_ALREADY_LISTED, FailureInfo.SUPPORT_MARKET_EXISTS);\n\n        }\n\n\n\n        aToken.isAToken(); // Sanity check to make sure its really a AToken\n\n\n\n        // Note that isAtled is not in active use anymore\n\n        markets[address(aToken)] = Market({isListed: true, isAtled: false, collateralFactorMantissa: 0});\n\n\n\n        _addMarketInternal(address(aToken));\n\n\n\n        emit MarketListed(aToken);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Comptroller._supportMarket (ABep20Harness.sol#5261-5282) does not use the value returned by external calls:\n\t-aToken.isAToken() (ABep20Harness.sol#5270)\n"
        },
        {
          "name": "unused-return",
          "vulnerability_from_line": 5611,
          "vulnerability_to_line": 5621,
          "vulnerability_code": "    function grantAtlantisInternal(address user, uint amount) internal returns (uint) {\n\n        Atlantis atlantis = Atlantis(getAtlantisAddress());\n\n        uint atlantisRemaining = atlantis.balanceOf(address(this));\n\n        if (amount > 0 && amount <= atlantisRemaining) {\n\n            atlantis.transfer(user, amount);\n\n            return 0;\n\n        }\n\n        return amount;\n\n    }\n\n\n",
          "message": "Comptroller.grantAtlantisInternal (ABep20Harness.sol#5611-5621) does not use the value returned by external calls:\n\t-atlantis.transfer(user,amount) (ABep20Harness.sol#5615-5616)\n"
        },
        {
          "name": "unused-return",
          "vulnerability_from_line": 5714,
          "vulnerability_to_line": 5756,
          "vulnerability_code": "    function _releaseToVaultInternal(address vault_) internal {\n\n        VaultInfo storage vaultInfo = vaultInfo[vault_];\n\n\n\n        if (atlantisVaultRate[vault_] == 0) {\n\n            return;\n\n        }\n\n        \n\n        if(vaultInfo.releaseStartBlock == 0 || getBlockNumber() < vaultInfo.releaseStartBlock) {\n\n            return;\n\n        }\n\n\n\n        Atlantis atlantis = Atlantis(getAtlantisAddress());\n\n        uint256 atlantisBalance = atlantis.balanceOf(address(this));\n\n        if(atlantisBalance == 0) {\n\n            return;\n\n        }\n\n\n\n        uint256 actualAmount;\n\n        uint256 deltaBlocks = sub_(getBlockNumber(), vaultInfo.releaseStartBlock);\n\n        // releaseAmount = atlantisVaultRate * deltaBlocks\n\n        uint256 _releaseAmount = mul_(atlantisVaultRate[vault_], deltaBlocks);\n\n\n\n        if (_releaseAmount < vaultInfo.minReleaseAmount) {\n\n            return;\n\n        }\n\n\n\n        if (atlantisBalance >= _releaseAmount) {\n\n            actualAmount = _releaseAmount;\n\n        } else {\n\n            actualAmount = atlantisBalance;\n\n        }\n\n\n\n        vaultInfo.releaseStartBlock = getBlockNumber();\n\n\n\n        address atlantisStoreAddress = IVault(vault_).getAtlantisStore();\n\n        atlantis.transfer(atlantisStoreAddress, actualAmount);\n\n        emit DistributedVaultAtlantis(vault_, actualAmount);\n\n\n\n        IVault(vault_).updatePendingRewards();\n\n    }\n\n\n\n    /**\n",
          "message": "Comptroller._releaseToVaultInternal (ABep20Harness.sol#5714-5756) does not use the value returned by external calls:\n\t-atlantis.transfer(atlantisStoreAddress,actualAmount) (ABep20Harness.sol#5749-5750)\n"
        },
        {
          "name": "shadowing-local",
          "vulnerability_from_line": 1117,
          "vulnerability_to_line": null,
          "vulnerability_code": "        (MathError err, Exp memory fraction) = divScalarByExp(scalar, divisor);\n",
          "message": "Exponential.divScalarByExpTruncate.fraction (local variable @ ABep20Harness.sol#1117) shadows:\n\t- ExponentialNoError.fraction (function @ ABep20Harness.sol#989-991)\n"
        },
        {
          "name": "shadowing-local",
          "vulnerability_from_line": 5450,
          "vulnerability_to_line": 5451,
          "vulnerability_code": "            uint atlantisAccrued = mul_(deltaBlocks, supplySpeed);\n",
          "message": "Comptroller.updateAtlantisSupplyIndex.atlantisAccrued (local variable @ ABep20Harness.sol#5450-5451) shadows:\n\t- ComptrollerV3Storage.atlantisAccrued (state variable @ ABep20Harness.sol#3840-3843)\n"
        },
        {
          "name": "shadowing-local",
          "vulnerability_from_line": 5473,
          "vulnerability_to_line": 5474,
          "vulnerability_code": "            uint atlantisAccrued = mul_(deltaBlocks, borrowSpeed);\n",
          "message": "Comptroller.updateAtlantisBorrowIndex.atlantisAccrued (local variable @ ABep20Harness.sol#5473-5474) shadows:\n\t- ComptrollerV3Storage.atlantisAccrued (state variable @ ABep20Harness.sol#3840-3843)\n"
        },
        {
          "name": "shadowing-local",
          "vulnerability_from_line": 5715,
          "vulnerability_to_line": 5717,
          "vulnerability_code": "        VaultInfo storage vaultInfo = vaultInfo[vault_];\n\n\n",
          "message": "Comptroller._releaseToVaultInternal.vaultInfo (local variable @ ABep20Harness.sol#5715-5717) shadows:\n\t- ComptrollerV5Storage.vaultInfo (state variable @ ABep20Harness.sol#3874-3877)\n"
        },
        {
          "name": "calls-loop",
          "vulnerability_from_line": 5847,
          "vulnerability_to_line": 5848,
          "vulnerability_code": "                Exp memory assetPrice = Exp({mantissa: oracle.getUnderlyingPrice(aToken)});\n",
          "message": "ComptrollerScenario.refreshAtlantisSpeeds has external calls inside a loop:\n\t- assetPrice = Exp(oracle.getUnderlyingPrice(aToken_scope_1)) (ABep20Harness.sol#5847-5848)\n"
        },
        {
          "name": "calls-loop",
          "vulnerability_from_line": 5848,
          "vulnerability_to_line": 5849,
          "vulnerability_code": "                Exp memory utility = mul_(assetPrice, aToken.totalBorrows());\n",
          "message": "ComptrollerScenario.refreshAtlantisSpeeds has external calls inside a loop:\n\t- utility = mul_(assetPrice,aToken_scope_1.totalBorrows()) (ABep20Harness.sol#5848-5849)\n"
        },
        {
          "name": "calls-loop",
          "vulnerability_from_line": 5837,
          "vulnerability_to_line": 5838,
          "vulnerability_code": "            Exp memory borrowIndex = Exp({mantissa: aToken.borrowIndex()});\n",
          "message": "ComptrollerScenario.refreshAtlantisSpeeds has external calls inside a loop:\n\t- borrowIndex = Exp(aToken.borrowIndex()) (ABep20Harness.sol#5837-5838)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 3528,
          "vulnerability_to_line": 3555,
          "vulnerability_code": "    function _becomeImplementation(address daiJoinAddress_, address potAddress_) internal {\n\n        // Get dai and vat and sanity check the underlying\n\n        DaiJoinLike daiJoin = DaiJoinLike(daiJoinAddress_);\n\n        PotLike pot = PotLike(potAddress_);\n\n        GemLike dai = daiJoin.dai();\n\n        VatLike vat = daiJoin.vat();\n\n        require(address(dai) == underlying, \"DAI must be the same as underlying\");\n\n\n\n        // Remember the relevant addresses\n\n        daiJoinAddress = daiJoinAddress_;\n\n        potAddress = potAddress_;\n\n        vatAddress = address(vat);\n\n\n\n        // Approve moving our DAI into the vat through daiJoin\n\n        dai.approve(daiJoinAddress, uint(-1));\n\n\n\n        // Approve the pot to transfer our funds within the vat\n\n        vat.hope(potAddress);\n\n        vat.hope(daiJoinAddress);\n\n\n\n        // Accumulate DSR interest -- must do this in order to doTransferIn\n\n        pot.drip();\n\n\n\n        // Transfer all cash in (doTransferIn does this regardless of amount)\n\n        doTransferIn(address(this), 0);\n\n    }\n\n\n",
          "message": "Reentrancy in ADaiDelegate._becomeImplementation (ABep20Harness.sol#3528-3555):\n\tExternal calls:\n\t- dai = daiJoin.dai() (ABep20Harness.sol#3532-3533)\n\t- vat = daiJoin.vat() (ABep20Harness.sol#3533-3534)\n\tState variables written after the call(s):\n\t- daiJoinAddress (ABep20Harness.sol#3537-3538)\n\t- potAddress (ABep20Harness.sol#3538-3539)\n\t- vatAddress (ABep20Harness.sol#3539-3541)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 5261,
          "vulnerability_to_line": 5282,
          "vulnerability_code": "    function _supportMarket(AToken aToken) external returns (uint) {\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SUPPORT_MARKET_OWNER_CHECK);\n\n        }\n\n\n\n        if (markets[address(aToken)].isListed) {\n\n            return fail(Error.MARKET_ALREADY_LISTED, FailureInfo.SUPPORT_MARKET_EXISTS);\n\n        }\n\n\n\n        aToken.isAToken(); // Sanity check to make sure its really a AToken\n\n\n\n        // Note that isAtled is not in active use anymore\n\n        markets[address(aToken)] = Market({isListed: true, isAtled: false, collateralFactorMantissa: 0});\n\n\n\n        _addMarketInternal(address(aToken));\n\n\n\n        emit MarketListed(aToken);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Reentrancy in Comptroller._supportMarket (ABep20Harness.sol#5261-5282):\n\tExternal calls:\n\t- aToken.isAToken() (ABep20Harness.sol#5270)\n\tState variables written after the call(s):\n\t- allMarkets (ABep20Harness.sol#5275-5277)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 1980,
          "vulnerability_to_line": 2044,
          "vulnerability_code": "    function borrowFresh(address payable borrower, uint borrowAmount) internal returns (uint) {\n\n        /* Fail if borrow not allowed */\n\n        uint allowed = comptroller.borrowAllowed(address(this), borrower, borrowAmount);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.BORROW_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.BORROW_FRESHNESS_CHECK);\n\n        }\n\n\n\n        /* Fail gracefully if protocol has insufficient underlying cash */\n\n        if (getCashPrior() < borrowAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.BORROW_CASH_NOT_AVAILABLE);\n\n        }\n\n\n\n        BorrowLocalVars memory vars;\n\n\n\n        /*\n\n         * We calculate the new borrower and total borrow balances, failing on overflow:\n\n         *  accountBorrowsNew = accountBorrows + borrowAmount\n\n         *  totalBorrowsNew = totalBorrows + borrowAmount\n\n         */\n\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We invoke doTransferOut for the borrower and the borrowAmount.\n\n         *  Note: The aToken must handle variations between BEP-20 and BNB underlying.\n\n         *  On success, the aToken borrowAmount less of cash.\n\n         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n\n         */\n\n        doTransferOut(borrower, borrowAmount);\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n\n        accountBorrows[borrower].interestIndex = borrowIndex;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n\n\n        /* We emit a Borrow event */\n\n        emit Borrow(borrower, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n\n\n        /* We call the defense hook */\n\n        // unused function\n\n        // comptroller.borrowVerify(address(this), borrower, borrowAmount);\n\n\n\n        return uint(Error.NO_ERROR);\n",
          "message": "Reentrancy in AToken.borrowFresh (ABep20Harness.sol#1980-2044):\n\tExternal calls:\n\t- allowed = comptroller.borrowAllowed(address(this),borrower,borrowAmount) (ABep20Harness.sol#1982)\n\tState variables written after the call(s):\n\t- accountBorrows (ABep20Harness.sol#2032)\n\t- accountBorrows (ABep20Harness.sol#2033)\n\t- totalBorrows (ABep20Harness.sol#2034)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 5518,
          "vulnerability_to_line": 5539,
          "vulnerability_code": "    function distributeBorrowerAtlantis(address aToken, address borrower, Exp memory marketBorrowIndex) internal {\n\n        if (vaults.length != 0) {\n\n            releaseToVault();\n\n        }\n\n       \n\n        AtlantisMarketState storage borrowState = atlantisBorrowState[aToken];\n\n        Double memory borrowIndex = Double({mantissa: borrowState.index});\n\n        Double memory borrowerIndex = Double({mantissa: atlantisBorrowerIndex[aToken][borrower]});\n\n        atlantisBorrowerIndex[aToken][borrower] = borrowIndex.mantissa;\n\n\n\n        if (borrowerIndex.mantissa > 0) {\n\n            Double memory deltaIndex = sub_(borrowIndex, borrowerIndex);\n\n            uint borrowerAmount = div_(AToken(aToken).borrowBalanceStored(borrower), marketBorrowIndex);\n\n            uint borrowerDelta = mul_(borrowerAmount, deltaIndex);\n\n            uint borrowerAccrued = add_(atlantisAccrued[borrower], borrowerDelta);\n\n            atlantisAccrued[borrower] = borrowerAccrued;\n\n            emit DistributedBorrowerAtlantis(AToken(aToken), borrower, borrowerDelta, borrowIndex.mantissa);\n\n        }\n\n    }\n\n\n\n    /**\n",
          "message": "Reentrancy in Comptroller.distributeBorrowerAtlantis (ABep20Harness.sol#5518-5539):\n\tExternal calls:\n\t- releaseToVault() (ABep20Harness.sol#5520-5522)\n\tState variables written after the call(s):\n\t- atlantisBorrowerIndex (ABep20Harness.sol#5526-5528)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 5518,
          "vulnerability_to_line": 5539,
          "vulnerability_code": "    function distributeBorrowerAtlantis(address aToken, address borrower, Exp memory marketBorrowIndex) internal {\n\n        if (vaults.length != 0) {\n\n            releaseToVault();\n\n        }\n\n       \n\n        AtlantisMarketState storage borrowState = atlantisBorrowState[aToken];\n\n        Double memory borrowIndex = Double({mantissa: borrowState.index});\n\n        Double memory borrowerIndex = Double({mantissa: atlantisBorrowerIndex[aToken][borrower]});\n\n        atlantisBorrowerIndex[aToken][borrower] = borrowIndex.mantissa;\n\n\n\n        if (borrowerIndex.mantissa > 0) {\n\n            Double memory deltaIndex = sub_(borrowIndex, borrowerIndex);\n\n            uint borrowerAmount = div_(AToken(aToken).borrowBalanceStored(borrower), marketBorrowIndex);\n\n            uint borrowerDelta = mul_(borrowerAmount, deltaIndex);\n\n            uint borrowerAccrued = add_(atlantisAccrued[borrower], borrowerDelta);\n\n            atlantisAccrued[borrower] = borrowerAccrued;\n\n            emit DistributedBorrowerAtlantis(AToken(aToken), borrower, borrowerDelta, borrowIndex.mantissa);\n\n        }\n\n    }\n\n\n\n    /**\n",
          "message": "Reentrancy in Comptroller.distributeBorrowerAtlantis (ABep20Harness.sol#5518-5539):\n\tExternal calls:\n\t- releaseToVault() (ABep20Harness.sol#5520-5522)\n\t- borrowerAmount = div_(AToken(aToken).borrowBalanceStored(borrower),marketBorrowIndex) (ABep20Harness.sol#5530-5531)\n\tState variables written after the call(s):\n\t- atlantisAccrued (ABep20Harness.sol#5533-5534)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 5490,
          "vulnerability_to_line": 5513,
          "vulnerability_code": "    function distributeSupplierAtlantis(address aToken, address supplier) internal {\n\n        if (vaults.length != 0) {\n\n            releaseToVault();\n\n        }\n\n\n\n        AtlantisMarketState storage supplyState = atlantisSupplyState[aToken];\n\n        Double memory supplyIndex = Double({mantissa: supplyState.index});\n\n        Double memory supplierIndex = Double({mantissa: atlantisSupplierIndex[aToken][supplier]});\n\n        atlantisSupplierIndex[aToken][supplier] = supplyIndex.mantissa;\n\n\n\n        if (supplierIndex.mantissa == 0 && supplyIndex.mantissa > 0) {\n\n            supplierIndex.mantissa = atlantisInitialIndex;\n\n        }\n\n\n\n        Double memory deltaIndex = sub_(supplyIndex, supplierIndex);\n\n        uint supplierTokens = AToken(aToken).balanceOf(supplier);\n\n        uint supplierDelta = mul_(supplierTokens, deltaIndex);\n\n        uint supplierAccrued = add_(atlantisAccrued[supplier], supplierDelta);\n\n        atlantisAccrued[supplier] = supplierAccrued;\n\n        emit DistributedSupplierAtlantis(AToken(aToken), supplier, supplierDelta, supplyIndex.mantissa);\n\n    }\n\n\n\n    /**\n",
          "message": "Reentrancy in Comptroller.distributeSupplierAtlantis (ABep20Harness.sol#5490-5513):\n\tExternal calls:\n\t- releaseToVault() (ABep20Harness.sol#5492-5495)\n\tState variables written after the call(s):\n\t- atlantisSupplierIndex (ABep20Harness.sol#5498-5500)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 5490,
          "vulnerability_to_line": 5513,
          "vulnerability_code": "    function distributeSupplierAtlantis(address aToken, address supplier) internal {\n\n        if (vaults.length != 0) {\n\n            releaseToVault();\n\n        }\n\n\n\n        AtlantisMarketState storage supplyState = atlantisSupplyState[aToken];\n\n        Double memory supplyIndex = Double({mantissa: supplyState.index});\n\n        Double memory supplierIndex = Double({mantissa: atlantisSupplierIndex[aToken][supplier]});\n\n        atlantisSupplierIndex[aToken][supplier] = supplyIndex.mantissa;\n\n\n\n        if (supplierIndex.mantissa == 0 && supplyIndex.mantissa > 0) {\n\n            supplierIndex.mantissa = atlantisInitialIndex;\n\n        }\n\n\n\n        Double memory deltaIndex = sub_(supplyIndex, supplierIndex);\n\n        uint supplierTokens = AToken(aToken).balanceOf(supplier);\n\n        uint supplierDelta = mul_(supplierTokens, deltaIndex);\n\n        uint supplierAccrued = add_(atlantisAccrued[supplier], supplierDelta);\n\n        atlantisAccrued[supplier] = supplierAccrued;\n\n        emit DistributedSupplierAtlantis(AToken(aToken), supplier, supplierDelta, supplyIndex.mantissa);\n\n    }\n\n\n\n    /**\n",
          "message": "Reentrancy in Comptroller.distributeSupplierAtlantis (ABep20Harness.sol#5490-5513):\n\tExternal calls:\n\t- releaseToVault() (ABep20Harness.sol#5492-5495)\n\t- supplierTokens = AToken(aToken).balanceOf(supplier) (ABep20Harness.sol#5505-5506)\n\tState variables written after the call(s):\n\t- atlantisAccrued (ABep20Harness.sol#5508-5509)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 1267,
          "vulnerability_to_line": 1298,
          "vulnerability_code": "    function initialize(ComptrollerInterface comptroller_,\n\n                        InterestRateModel interestRateModel_,\n\n                        uint initialExchangeRateMantissa_,\n\n                        string memory name_,\n\n                        string memory symbol_,\n\n                        uint8 decimals_) public {\n\n        require(msg.sender == admin, \"only admin may initialize the market\");\n\n        require(accrualBlockNumber == 0 && borrowIndex == 0, \"market may only be initialized once\");\n\n\n\n        // Set initial exchange rate\n\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n\n        require(initialExchangeRateMantissa > 0, \"initial exchange rate must be greater than zero.\");\n\n\n\n        // Set the comptroller\n\n        uint err = _setComptroller(comptroller_);\n\n        require(err == uint(Error.NO_ERROR), \"setting comptroller failed\");\n\n\n\n        // Initialize block number and borrow index (block number mocks depend on comptroller being set)\n\n        accrualBlockNumber = getBlockNumber();\n\n        borrowIndex = mantissaOne;\n\n\n\n        // Set the interest rate model (depends on block number / borrow index)\n\n        err = _setInterestRateModelFresh(interestRateModel_);\n\n        require(err == uint(Error.NO_ERROR), \"setting interest rate model failed\");\n\n\n\n        name = name_;\n\n        symbol = symbol_;\n\n        decimals = decimals_;\n\n\n\n        // The counter starts true to prevent changing it from zero to non-zero (i.e. smaller cost/refund)\n\n        _notEntered = true;\n",
          "message": "Reentrancy in AToken.initialize (ABep20Harness.sol#1267-1298):\n\tExternal calls:\n\t- err = _setComptroller(comptroller_) (ABep20Harness.sol#1281)\n\t- err = _setInterestRateModelFresh(interestRateModel_) (ABep20Harness.sol#1289)\n\tState variables written after the call(s):\n\t- _notEntered (ABep20Harness.sol#1297)\n\t- decimals (ABep20Harness.sol#1294)\n\t- name (ABep20Harness.sol#1292)\n\t- symbol (ABep20Harness.sol#1293)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 2727,
          "vulnerability_to_line": 2742,
          "vulnerability_code": "    function initialize(address underlying_,\n\n                        ComptrollerInterface comptroller_,\n\n                        InterestRateModel interestRateModel_,\n\n                        uint initialExchangeRateMantissa_,\n\n                        string memory name_,\n\n                        string memory symbol_,\n\n                        uint8 decimals_) public {\n\n        // AToken initialize does the bulk of the work\n\n        super.initialize(comptroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_);\n\n\n\n        // Set underlying and sanity check it\n\n        underlying = underlying_;\n\n        EIP20Interface(underlying).totalSupply();\n\n    }\n\n\n",
          "message": "Reentrancy in ABep20.initialize (ABep20Harness.sol#2727-2742):\n\tExternal calls:\n\t- super.initialize(comptroller_,interestRateModel_,initialExchangeRateMantissa_,name_,symbol_,decimals_) (ABep20Harness.sol#2735-2737)\n\tState variables written after the call(s):\n\t- underlying (ABep20Harness.sol#2738-2739)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 1739,
          "vulnerability_to_line": 1804,
          "vulnerability_code": "    function mintFresh(address minter, uint mintAmount) internal returns (uint, uint) {\n\n        /* Fail if mint not allowed */\n\n        uint allowed = comptroller.mintAllowed(address(this), minter, mintAmount);\n\n        if (allowed != 0) {\n\n            return (failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.MINT_COMPTROLLER_REJECTION, allowed), 0);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return (fail(Error.MARKET_NOT_FRESH, FailureInfo.MINT_FRESHNESS_CHECK), 0);\n\n        }\n\n\n\n        MintLocalVars memory vars;\n\n\n\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return (failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr)), 0);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         *  We call `doTransferIn` for the minter and the mintAmount.\n\n         *  Note: The aToken must handle variations between BEP-20 and BNB underlying.\n\n         *  `doTransferIn` reverts if anything goes wrong, since we can't be sure if\n\n         *  side-effects occurred. The function returns the amount actually transferred,\n\n         *  in case of a fee. On success, the aToken holds an additional `actualMintAmount`\n\n         *  of cash.\n\n         */\n\n        vars.actualMintAmount = doTransferIn(minter, mintAmount);\n\n\n\n        /*\n\n         * We get the current exchange rate and calculate the number of aTokens to be minted:\n\n         *  mintTokens = actualMintAmount / exchangeRate\n\n         */\n\n\n\n        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(vars.actualMintAmount, Exp({mantissa: vars.exchangeRateMantissa}));\n\n        require(vars.mathErr == MathError.NO_ERROR, \"MINT_EXCHANGE_CALCULATION_FAILED\");\n\n\n\n        /*\n\n         * We calculate the new total supply of aTokens and minter token balance, checking for overflow:\n\n         *  totalSupplyNew = totalSupply + mintTokens\n\n         *  accountTokensNew = accountTokens[minter] + mintTokens\n\n         */\n\n        (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);\n\n        require(vars.mathErr == MathError.NO_ERROR, \"MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED\");\n\n\n\n        (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);\n\n        require(vars.mathErr == MathError.NO_ERROR, \"MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED\");\n\n\n\n        /* We write previously calculated values into storage */\n\n        totalSupply = vars.totalSupplyNew;\n\n        accountTokens[minter] = vars.accountTokensNew;\n\n\n\n        /* We emit a Mint event, and a Transfer event */\n\n        emit Mint(minter, vars.actualMintAmount, vars.mintTokens);\n\n        emit Transfer(address(this), minter, vars.mintTokens);\n\n\n\n        /* We call the defense hook */\n\n        // unused function\n\n        // comptroller.mintVerify(address(this), minter, vars.actualMintAmount, vars.mintTokens);\n\n\n\n        return (uint(Error.NO_ERROR), vars.actualMintAmount);\n",
          "message": "Reentrancy in AToken.mintFresh (ABep20Harness.sol#1739-1804):\n\tExternal calls:\n\t- allowed = comptroller.mintAllowed(address(this),minter,mintAmount) (ABep20Harness.sol#1741)\n\tState variables written after the call(s):\n\t- accountTokens (ABep20Harness.sol#1793)\n\t- totalSupply (ABep20Harness.sol#1792)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 1856,
          "vulnerability_to_line": 1950,
          "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n\n\n\n        RedeemLocalVars memory vars;\n\n\n\n        /* exchangeRate = invoke Exchange Rate Stored() */\n\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* If redeemTokensIn > 0: */\n\n        if (redeemTokensIn > 0) {\n\n            /*\n\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\n\n             *  redeemTokens = redeemTokensIn\n\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n\n             */\n\n            vars.redeemTokens = redeemTokensIn;\n\n\n\n            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED, uint(vars.mathErr));\n\n            }\n\n        } else {\n\n            /*\n\n             * We get the current exchange rate and calculate the amount to be redeemed:\n\n             *  redeemTokens = redeemAmountIn / exchangeRate\n\n             *  redeemAmount = redeemAmountIn\n\n             */\n\n\n\n            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED, uint(vars.mathErr));\n\n            }\n\n\n\n            vars.redeemAmount = redeemAmountIn;\n\n        }\n\n\n\n        /* Fail if redeem not allowed */\n\n        uint allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);\n\n        }\n\n\n\n        /*\n\n         * We calculate the new total supply and redeemer balance, checking for underflow:\n\n         *  totalSupplyNew = totalSupply - redeemTokens\n\n         *  accountTokensNew = accountTokens[redeemer] - redeemTokens\n\n         */\n\n        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* Fail gracefully if protocol has insufficient cash */\n\n        if (getCashPrior() < vars.redeemAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We invoke doTransferOut for the redeemer and the redeemAmount.\n\n         *  Note: The aToken must handle variations between BEP-20 and BNB underlying.\n\n         *  On success, the aToken has redeemAmount less of cash.\n\n         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n\n         */\n\n        doTransferOut(redeemer, vars.redeemAmount);\n\n\n\n        /* We write previously calculated values into storage */\n\n        totalSupply = vars.totalSupplyNew;\n\n        accountTokens[redeemer] = vars.accountTokensNew;\n\n\n\n        /* We emit a Transfer event, and a Redeem event */\n\n        emit Transfer(redeemer, address(this), vars.redeemTokens);\n\n        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        /* We call the defense hook */\n\n        comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        return uint(Error.NO_ERROR);\n",
          "message": "Reentrancy in AToken.redeemFresh (ABep20Harness.sol#1856-1950):\n\tExternal calls:\n\t- allowed = comptroller.redeemAllowed(address(this),redeemer,vars.redeemTokens) (ABep20Harness.sol#1896)\n\tState variables written after the call(s):\n\t- accountTokens (ABep20Harness.sol#1940)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 2095,
          "vulnerability_to_line": 2162,
          "vulnerability_code": "    function repayBorrowFresh(address payer, address borrower, uint repayAmount) internal returns (uint, uint) {\n\n        /* Fail if repayBorrow not allowed */\n\n        uint allowed = comptroller.repayBorrowAllowed(address(this), payer, borrower, repayAmount);\n\n        if (allowed != 0) {\n\n            return (failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REPAY_BORROW_COMPTROLLER_REJECTION, allowed), 0);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return (fail(Error.MARKET_NOT_FRESH, FailureInfo.REPAY_BORROW_FRESHNESS_CHECK), 0);\n\n        }\n\n\n\n        RepayBorrowLocalVars memory vars;\n\n\n\n        /* We remember the original borrowerIndex for verification purposes */\n\n        vars.borrowerIndex = accountBorrows[borrower].interestIndex;\n\n\n\n        /* We fetch the amount the borrower owes, with accumulated interest */\n\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return (failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr)), 0);\n\n        }\n\n\n\n        /* If repayAmount == -1, repayAmount = accountBorrows */\n\n        if (repayAmount == uint(-1)) {\n\n            vars.repayAmount = vars.accountBorrows;\n\n        } else {\n\n            vars.repayAmount = repayAmount;\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We call doTransferIn for the payer and the repayAmount\n\n         *  Note: The aToken must handle variations between BEP-20 and BNB underlying.\n\n         *  On success, the aToken holds an additional repayAmount of cash.\n\n         *  doTransferIn reverts if anything goes wrong, since we can't be sure if side effects occurred.\n\n         *   it returns the amount actually transferred, in case of a fee.\n\n         */\n\n        vars.actualRepayAmount = doTransferIn(payer, vars.repayAmount);\n\n\n\n        /*\n\n         * We calculate the new borrower and total borrow balances, failing on underflow:\n\n         *  accountBorrowsNew = accountBorrows - actualRepayAmount\n\n         *  totalBorrowsNew = totalBorrows - actualRepayAmount\n\n         */\n\n        (vars.mathErr, vars.accountBorrowsNew) = subUInt(vars.accountBorrows, vars.actualRepayAmount);\n\n        require(vars.mathErr == MathError.NO_ERROR, \"REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED\");\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = subUInt(totalBorrows, vars.actualRepayAmount);\n\n        require(vars.mathErr == MathError.NO_ERROR, \"REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED\");\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n\n        accountBorrows[borrower].interestIndex = borrowIndex;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n\n\n        /* We emit a RepayBorrow event */\n\n        emit RepayBorrow(payer, borrower, vars.actualRepayAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n\n\n        /* We call the defense hook */\n\n        // unused function\n\n        // comptroller.repayBorrowVerify(address(this), payer, borrower, vars.actualRepayAmount, vars.borrowerIndex);\n\n\n\n        return (uint(Error.NO_ERROR), vars.actualRepayAmount);\n",
          "message": "Reentrancy in AToken.repayBorrowFresh (ABep20Harness.sol#2095-2162):\n\tExternal calls:\n\t- allowed = comptroller.repayBorrowAllowed(address(this),payer,borrower,repayAmount) (ABep20Harness.sol#2097)\n\tState variables written after the call(s):\n\t- accountBorrows (ABep20Harness.sol#2150)\n\t- accountBorrows (ABep20Harness.sol#2151)\n\t- totalBorrows (ABep20Harness.sol#2152)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 2304,
          "vulnerability_to_line": 2364,
          "vulnerability_code": "    function seizeInternal(address seizerToken, address liquidator, address borrower, uint seizeTokens) internal returns (uint) {\n\n        /* Fail if seize not allowed */\n\n        uint allowed = comptroller.seizeAllowed(address(this), seizerToken, liquidator, borrower, seizeTokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_SEIZE_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Fail if borrower = liquidator */\n\n        if (borrower == liquidator) {\n\n            return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER);\n\n        }\n\n\n\n        SeizeInternalLocalVars memory vars;\n\n\n\n        /*\n\n         * We calculate the new borrower and liquidator token balances, failing on underflow/overflow:\n\n         *  borrowerTokensNew = accountTokens[borrower] - seizeTokens\n\n         *  liquidatorTokensNew = accountTokens[liquidator] + seizeTokens\n\n         */\n\n        (vars.mathErr, vars.borrowerTokensNew) = subUInt(accountTokens[borrower], seizeTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        vars.protocolSeizeTokens = mul_(seizeTokens, Exp({mantissa: protocolSeizeShareMantissa}));\n\n        vars.liquidatorSeizeTokens = sub_(seizeTokens, vars.protocolSeizeTokens);\n\n\n\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n\n        require(vars.mathErr == MathError.NO_ERROR, \"exchange rate math error\");\n\n\n\n        vars.protocolSeizeAmount = mul_ScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), vars.protocolSeizeTokens);\n\n\n\n        vars.totalReservesNew = add_(totalReserves, vars.protocolSeizeAmount);\n\n        vars.totalSupplyNew = sub_(totalSupply, vars.protocolSeizeTokens);\n\n\n\n        (vars.mathErr, vars.liquidatorTokensNew) = addUInt(accountTokens[liquidator], vars.liquidatorSeizeTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /* We write the previously calculated values into storage */\n\n        totalReserves = vars.totalReservesNew;\n\n        totalSupply = vars.totalSupplyNew;\n\n        accountTokens[borrower] = vars.borrowerTokensNew;\n\n        accountTokens[liquidator] = vars.liquidatorTokensNew;\n\n\n\n        /* Emit a Transfer event */\n\n        emit Transfer(borrower, liquidator, vars.liquidatorSeizeTokens);\n\n        emit Transfer(borrower, address(this), vars.protocolSeizeTokens);\n\n        emit ReservesAdded(address(this), vars.protocolSeizeAmount, vars.totalReservesNew);\n\n\n\n        /* We call the defense hook */\n\n        // unused function\n\n        // comptroller.seizeVerify(address(this), seizerToken, liquidator, borrower, seizeTokens);\n\n\n\n        return uint(Error.NO_ERROR);\n",
          "message": "Reentrancy in AToken.seizeInternal (ABep20Harness.sol#2304-2364):\n\tExternal calls:\n\t- allowed = comptroller.seizeAllowed(address(this),seizerToken,liquidator,borrower,seizeTokens) (ABep20Harness.sol#2306)\n\tState variables written after the call(s):\n\t- accountTokens (ABep20Harness.sol#2351)\n\t- accountTokens (ABep20Harness.sol#2352)\n\t- totalReserves (ABep20Harness.sol#2349)\n\t- totalSupply (ABep20Harness.sol#2350)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 1309,
          "vulnerability_to_line": 1369,
          "vulnerability_code": "    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (uint) {\n\n        /* Fail if transfer not allowed */\n\n        uint allowed = comptroller.transferAllowed(address(this), src, dst, tokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.TRANSFER_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Do not allow self-transfers */\n\n        if (src == dst) {\n\n            return fail(Error.BAD_INPUT, FailureInfo.TRANSFER_NOT_ALLOWED);\n\n        }\n\n\n\n        /* Get the allowance, infinite for the account owner */\n\n        uint startingAllowance = 0;\n\n        if (spender == src) {\n\n            startingAllowance = uint(-1);\n\n        } else {\n\n            startingAllowance = transferAllowances[src][spender];\n\n        }\n\n\n\n        /* Do the calculations, checking for {under,over}flow */\n\n        MathError mathErr;\n\n        uint allowanceNew;\n\n        uint sraTokensNew;\n\n        uint dstTokensNew;\n\n\n\n        (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ALLOWED);\n\n        }\n\n\n\n        (mathErr, sraTokensNew) = subUInt(accountTokens[src], tokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ENOUGH);\n\n        }\n\n\n\n        (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_TOO_MUCH);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        accountTokens[src] = sraTokensNew;\n\n        accountTokens[dst] = dstTokensNew;\n\n\n\n        /* Eat some of the allowance (if necessary) */\n\n        if (startingAllowance != uint(-1)) {\n\n            transferAllowances[src][spender] = allowanceNew;\n\n        }\n\n\n\n        /* We emit a Transfer event */\n\n        emit Transfer(src, dst, tokens);\n\n\n\n        // unused function\n\n        // comptroller.transferVerify(address(this), src, dst, tokens);\n\n\n\n        return uint(Error.NO_ERROR);\n",
          "message": "Reentrancy in AToken.transferTokens (ABep20Harness.sol#1309-1369):\n\tExternal calls:\n\t- allowed = comptroller.transferAllowed(address(this),src,dst,tokens) (ABep20Harness.sol#1311)\n\tState variables written after the call(s):\n\t- accountTokens (ABep20Harness.sol#1354)\n\t- accountTokens (ABep20Harness.sol#1355)\n\t- transferAllowances (ABep20Harness.sol#1359)\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 2858,
          "vulnerability_to_line": 2885,
          "vulnerability_code": "    function doTransferIn(address from, uint amount) internal returns (uint) {\n\n        EIP20NonStandardInterface token = EIP20NonStandardInterface(underlying);\n\n        uint balanceBefore = EIP20Interface(underlying).balanceOf(address(this));\n\n        token.transferFrom(from, address(this), amount);\n\n\n\n        bool success;\n\n        assembly {\n\n            switch returndatasize()\n\n                case 0 {                       // This is a non-standard BEP-20\n\n                    success := not(0)          // set success to true\n\n                }\n\n                case 32 {                      // This is a compliant BEP-20\n\n                    returndatacopy(0, 0, 32)\n\n                    success := mload(0)        // Set `success = returndata` of external call\n\n                }\n\n                default {                      // This is an excessively non-compliant BEP-20, revert.\n\n                    revert(0, 0)\n\n                }\n\n        }\n\n        require(success, \"TOKEN_TRANSFER_IN_FAILED\");\n\n\n\n        // Calculate the amount that was *actually* transferred\n\n        uint balanceAfter = EIP20Interface(underlying).balanceOf(address(this));\n\n        require(balanceAfter >= balanceBefore, \"TOKEN_TRANSFER_IN_OVERFLOW\");\n\n        return balanceAfter - balanceBefore;   // underflow already checked above, just subtract\n\n    }\n\n\n",
          "message": "ABep20.doTransferIn uses assembly (ABep20Harness.sol#2858-2885)\n\t- ABep20Harness.sol#2864-2877\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 2894,
          "vulnerability_to_line": 2915,
          "vulnerability_code": "    function doTransferOut(address payable to, uint amount) internal {\n\n        EIP20NonStandardInterface token = EIP20NonStandardInterface(underlying);\n\n        token.transfer(to, amount);\n\n\n\n        bool success;\n\n        assembly {\n\n            switch returndatasize()\n\n                case 0 {                      // This is a non-standard BEP-20\n\n                    success := not(0)          // set success to true\n\n                }\n\n                case 32 {                     // This is a compliant BEP-20\n\n                    returndatacopy(0, 0, 32)\n\n                    success := mload(0)        // Set `success = returndata` of external call\n\n                }\n\n                default {                     // This is an excessively non-compliant BEP-20, revert.\n\n                    revert(0, 0)\n\n                }\n\n        }\n\n        require(success, \"TOKEN_TRANSFER_OUT_FAILED\");\n\n    }\n\n\n",
          "message": "ABep20.doTransferOut uses assembly (ABep20Harness.sol#2894-2915)\n\t- ABep20Harness.sol#2899-2912\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 3385,
          "vulnerability_to_line": 3395,
          "vulnerability_code": "    function delegateTo(address callee, bytes memory data) internal returns (bytes memory) {\n\n        (bool success, bytes memory returnData) = callee.delegatecall(data);\n\n        assembly {\n\n            if eq(success, 0) {\n\n                revert(add(returnData, 0x20), returndatasize)\n\n            }\n\n        }\n\n        return returnData;\n\n    }\n\n\n",
          "message": "ABep20Delegator.delegateTo uses assembly (ABep20Harness.sol#3385-3395)\n\t- ABep20Harness.sol#3387-3392\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 3412,
          "vulnerability_to_line": 3422,
          "vulnerability_code": "    function delegateToViewImplementation(bytes memory data) public view returns (bytes memory) {\n\n        (bool success, bytes memory returnData) = address(this).staticcall(abi.encodeWithSignature(\"delegateToImplementation(bytes)\", data));\n\n        assembly {\n\n            if eq(success, 0) {\n\n                revert(add(returnData, 0x20), returndatasize)\n\n            }\n\n        }\n\n        return abi.decode(returnData, (bytes));\n\n    }\n\n\n",
          "message": "ABep20Delegator.delegateToViewImplementation uses assembly (ABep20Harness.sol#3412-3422)\n\t- ABep20Harness.sol#3414-3419\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 3426,
          "vulnerability_to_line": 3443,
          "vulnerability_code": "    function () external payable {\n\n        require(msg.value == 0,\"ABep20Delegator:fallback: cannot send value to fallback\");\n\n\n\n        // delegate all other functions to current implementation\n\n        (bool success, ) = implementation.delegatecall(msg.data);\n\n\n\n        assembly {\n\n            let free_mem_ptr := mload(0x40)\n\n            returndatacopy(free_mem_ptr, 0, returndatasize)\n\n\n\n            switch success\n\n            case 0 { revert(free_mem_ptr, returndatasize) }\n\n            default { return(free_mem_ptr, returndatasize) }\n\n        }\n\n    }\n\n}\n\n\n",
          "message": "ABep20Delegator.fallback uses assembly (ABep20Harness.sol#3426-3443)\n\t- ABep20Harness.sol#3432-3440\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 4012,
          "vulnerability_to_line": 4027,
          "vulnerability_code": "    function () payable external {\n\n        // delegate all other functions to current implementation\n\n        (bool success, ) = comptrollerImplementation.delegatecall(msg.data);\n\n\n\n        assembly {\n\n              let free_mem_ptr := mload(0x40)\n\n              returndatacopy(free_mem_ptr, 0, returndatasize)\n\n\n\n              switch success\n\n              case 0 { revert(free_mem_ptr, returndatasize) }\n\n              default { return(free_mem_ptr, returndatasize) }\n\n        }\n\n    }\n\n}\n\n\n",
          "message": "Unitroller.fallback uses assembly (ABep20Harness.sol#4012-4027)\n\t- ABep20Harness.sol#4016-4027\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 4324,
          "vulnerability_to_line": 4331,
          "vulnerability_code": "    function getChainId() internal pure returns (uint) {\n\n        uint256 chainId;\n\n        assembly { chainId := chainid() }\n\n        return chainId;\n\n    }\n\n}\n\n\n",
          "message": "Atlantis.getChainId uses assembly (ABep20Harness.sol#4324-4331)\n\t- ABep20Harness.sol#4326-4327\n"
        },
        {
          "name": "constable-states",
          "vulnerability_from_line": 6347,
          "vulnerability_to_line": 6348,
          "vulnerability_code": "    uint public totalSupply;\n",
          "message": "ADaiDelegateMakerHarness.totalSupply should be constant (ABep20Harness.sol#6347-6348)\nComptrollerV2Storage._borrowGuardianPaused should be constant (ABep20Harness.sol#3802-3803)\nComptrollerV2Storage._mintGuardianPaused should be constant (ABep20Harness.sol#3801-3802)\nComptrollerV3Storage.atlantisRate should be constant (ABep20Harness.sol#3822-3824)\n"
        },
        {
          "name": "pragma",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": "Different versions of Solidity is used in ABep20Harness.sol:\n\t- Version used: ['ABIEncoderV2', '^0.5.16']\n\t- ABep20Harness.sol#3 declares pragma solidity^0.5.16\n\t- ABep20Harness.sol#83 declares pragma solidity^0.5.16\n\t- ABep20Harness.sol#116 declares pragma solidity^0.5.16\n\t- ABep20Harness.sol#189 declares pragma solidity^0.5.16\n\t- ABep20Harness.sol#500 declares pragma solidity^0.5.16\n\t- ABep20Harness.sol#710 declares pragma solidity^0.5.16\n\t- ABep20Harness.sol#798 declares pragma solidity^0.5.16\n\t- ABep20Harness.sol#996 declares pragma solidity^0.5.16\n\t- ABep20Harness.sol#1180 declares pragma solidity^0.5.16\n\t- ABep20Harness.sol#1245 declares pragma solidity^0.5.16\n\t- ABep20Harness.sol#2705-2707 declares pragma solidity^0.5.16\n\t- ABep20Harness.sol#2928-2931 declares pragma solidity^0.5.16\n\t- ABep20Harness.sol#2968-2971 declares pragma solidity^0.5.16\n\t- ABep20Harness.sol#3445-3448 declares pragma solidity^0.5.16\n\t- ABep20Harness.sol#3489-3492 declares pragma solidity^0.5.16\n\t- ABep20Harness.sol#3698-3700 declares pragma solidity^0.5.16\n\t- ABep20Harness.sol#3715-3718 declares pragma solidity^0.5.16\n\t- ABep20Harness.sol#3879-3882 declares pragma solidity^0.5.16\n\t- ABep20Harness.sol#4029-4030 declares pragma solidity^0.5.16\n\t- ABep20Harness.sol#4030-4032 declares pragma experimentalABIEncoderV2\n\t- ABep20Harness.sol#4333-4341 declares pragma solidity^0.5.16\n\t- ABep20Harness.sol#5792-5794 declares pragma solidity^0.5.16\n\t- ABep20Harness.sol#5864-5870 declares pragma solidity^0.5.16\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 433,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint);\n",
          "message": "ATokenInterface._setInterestRateModel (ABep20Harness.sol#433) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 3373,
          "vulnerability_to_line": 3378,
          "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {\n\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"_setInterestRateModel(address)\", newInterestRateModel));\n\n        return abi.decode(data, (uint));\n\n    }\n\n\n",
          "message": "ABep20Delegator._setInterestRateModel (ABep20Harness.sol#3373-3378) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 2621,
          "vulnerability_to_line": 2631,
          "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n\n        return _setInterestRateModelFresh(newInterestRateModel);\n\n    }\n\n\n",
          "message": "AToken._setInterestRateModel (ABep20Harness.sol#2621-2631) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 3516,
          "vulnerability_to_line": 3523,
          "vulnerability_code": "    function _becomeImplementation(bytes memory data) public {\n\n        require(msg.sender == admin, \"only the admin may initialize the implementation\");\n\n\n\n        (address daiJoinAddress_, address potAddress_) = abi.decode(data, (address, address));\n\n        return _becomeImplementation(daiJoinAddress_, potAddress_);\n\n    }\n\n\n",
          "message": "ADaiDelegate._becomeImplementation (ABep20Harness.sol#3516-3523) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 3462,
          "vulnerability_to_line": 3474,
          "vulnerability_code": "    function _becomeImplementation(bytes memory data) public {\n\n        // Shh -- currently unused\n\n        data;\n\n\n\n        // Shh -- we don't ever want this hook to be marked pure\n\n        if (false) {\n\n            implementation = address(0);\n\n        }\n\n\n\n        require(msg.sender == admin, \"only the admin may call _becomeImplementation\");\n\n    }\n\n\n",
          "message": "ABep20Delegate._becomeImplementation (ABep20Harness.sol#3462-3474) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 490,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _becomeImplementation(bytes memory data) public;\n",
          "message": "ADelegateInterface._becomeImplementation (ABep20Harness.sol#490) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 495,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _resignImplementation() public;\n",
          "message": "ADelegateInterface._resignImplementation (ABep20Harness.sol#495) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 3477,
          "vulnerability_to_line": 3487,
          "vulnerability_code": "    function _resignImplementation() public {\n\n        // Shh -- we don't ever want this hook to be marked pure\n\n        if (false) {\n\n            implementation = address(0);\n\n        }\n\n\n\n        require(msg.sender == admin, \"only the admin may call _resignImplementation\");\n\n    }\n\n}\n\n\n",
          "message": "ABep20Delegate._resignImplementation (ABep20Harness.sol#3477-3487) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 3558,
          "vulnerability_to_line": 3580,
          "vulnerability_code": "    function _resignImplementation() public {\n\n        require(msg.sender == admin, \"only the admin may abandon the implementation\");\n\n\n\n        // Transfer all cash out of the DSR - note that this relies on self-transfer\n\n        DaiJoinLike daiJoin = DaiJoinLike(daiJoinAddress);\n\n        PotLike pot = PotLike(potAddress);\n\n        VatLike vat = VatLike(vatAddress);\n\n\n\n        // Accumulate interest\n\n        pot.drip();\n\n\n\n        // Calculate the total amount in the pot, and move it out\n\n        uint pie = pot.pie(address(this));\n\n        pot.exit(pie);\n\n\n\n        // Checks the actual balance of DAI in the vat after the pot exit\n\n        uint bal = vat.dai(address(this));\n\n\n\n        // Remove our whole balance\n\n        daiJoin.exit(address(this), bal / RAY);\n\n    }\n\n\n",
          "message": "ADaiDelegate._resignImplementation (ABep20Harness.sol#3558-3580) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 3915,
          "vulnerability_to_line": 3930,
          "vulnerability_code": "    function _setPendingImplementation(address newPendingImplementation) public returns (uint) {\n\n\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_IMPLEMENTATION_OWNER_CHECK);\n\n        }\n\n\n\n        address oldPendingImplementation = pendingComptrollerImplementation;\n\n\n\n        pendingComptrollerImplementation = newPendingImplementation;\n\n\n\n        emit NewPendingImplementation(oldPendingImplementation, pendingComptrollerImplementation);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Unitroller._setPendingImplementation (ABep20Harness.sol#3915-3930) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 3935,
          "vulnerability_to_line": 3956,
          "vulnerability_code": "    function _acceptImplementation() public returns (uint) {\n\n        // Check caller is pendingImplementation and pendingImplementation \u2260 address(0)\n\n        if (msg.sender != pendingComptrollerImplementation || pendingComptrollerImplementation == address(0)) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_PENDING_IMPLEMENTATION_ADDRESS_CHECK);\n\n        }\n\n\n\n        // Save current values for inclusion in log\n\n        address oldImplementation = comptrollerImplementation;\n\n        address oldPendingImplementation = pendingComptrollerImplementation;\n\n\n\n        comptrollerImplementation = pendingComptrollerImplementation;\n\n\n\n        pendingComptrollerImplementation = address(0);\n\n\n\n        emit NewImplementation(oldImplementation, comptrollerImplementation);\n\n        emit NewPendingImplementation(oldPendingImplementation, pendingComptrollerImplementation);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n\n",
          "message": "Unitroller._acceptImplementation (ABep20Harness.sol#3935-3956) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 3962,
          "vulnerability_to_line": 3980,
          "vulnerability_code": "    function _setPendingAdmin(address newPendingAdmin) public returns (uint) {\n\n        // Check caller = admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);\n\n        }\n\n\n\n        // Save current value, if any, for inclusion in log\n\n        address oldPendingAdmin = pendingAdmin;\n\n\n\n        // Store pendingAdmin with value newPendingAdmin\n\n        pendingAdmin = newPendingAdmin;\n\n\n\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\n\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Unitroller._setPendingAdmin (ABep20Harness.sol#3962-3980) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 3985,
          "vulnerability_to_line": 4008,
          "vulnerability_code": "    function _acceptAdmin() public returns (uint) {\n\n        // Check caller is pendingAdmin and pendingAdmin \u2260 address(0)\n\n        if (msg.sender != pendingAdmin || msg.sender == address(0)) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);\n\n        }\n\n\n\n        // Save current values for inclusion in log\n\n        address oldAdmin = admin;\n\n        address oldPendingAdmin = pendingAdmin;\n\n\n\n        // Store admin with value pendingAdmin\n\n        admin = pendingAdmin;\n\n\n\n        // Clear the pending value\n\n        pendingAdmin = address(0);\n\n\n\n        emit NewAdmin(oldAdmin, admin);\n\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
          "message": "Unitroller._acceptAdmin (ABep20Harness.sol#3985-4008) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 4176,
          "vulnerability_to_line": 4181,
          "vulnerability_code": "    function delegate(address delegatee) public {\n\n        return _delegate(msg.sender, delegatee);\n\n    }\n\n\n\n    /**\n",
          "message": "Atlantis.delegate (ABep20Harness.sol#4176-4181) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 4189,
          "vulnerability_to_line": 4201,
          "vulnerability_code": "    function delegateBySig(address delegatee, uint nonce, uint expiry, uint8 v, bytes32 r, bytes32 s) public {\n\n        bytes32 domainSeparator = keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), getChainId(), address(this)));\n\n        bytes32 structHash = keccak256(abi.encode(DELEGATION_TYPEHASH, delegatee, nonce, expiry));\n\n        bytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n\n        address signatory = ecrecover(digest, v, r, s);\n\n        require(signatory != address(0), \"Atlantis::delegateBySig: invalid signature\");\n\n        require(nonce == nonces[signatory]++, \"Atlantis::delegateBySig: invalid nonce\");\n\n        require(now <= expiry, \"Atlantis::delegateBySig: signature expired\");\n\n        return _delegate(signatory, delegatee);\n\n    }\n\n\n\n    /**\n",
          "message": "Atlantis.delegateBySig (ABep20Harness.sol#4189-4201) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 4217,
          "vulnerability_to_line": 4251,
          "vulnerability_code": "    function getPriorVotes(address account, uint blockNumber) public view returns (uint96) {\n\n        require(blockNumber < block.number, \"Atlantis::getPriorVotes: not yet determined\");\n\n\n\n        uint32 nCheckpoints = numCheckpoints[account];\n\n        if (nCheckpoints == 0) {\n\n            return 0;\n\n        }\n\n\n\n        // First check most recent balance\n\n        if (checkpoints[account][nCheckpoints - 1].fromBlock <= blockNumber) {\n\n            return checkpoints[account][nCheckpoints - 1].votes;\n\n        }\n\n\n\n        // Next check implicit zero balance\n\n        if (checkpoints[account][0].fromBlock > blockNumber) {\n\n            return 0;\n\n        }\n\n\n\n        uint32 lower = 0;\n\n        uint32 upper = nCheckpoints - 1;\n\n        while (upper > lower) {\n\n            uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\n\n            Checkpoint memory cp = checkpoints[account][center];\n\n            if (cp.fromBlock == blockNumber) {\n\n                return cp.votes;\n\n            } else if (cp.fromBlock < blockNumber) {\n\n                lower = center;\n\n            } else {\n\n                upper = center - 1;\n\n            }\n\n        }\n\n        return checkpoints[account][lower].votes;\n\n    }\n\n\n",
          "message": "Atlantis.getPriorVotes (ABep20Harness.sol#4217-4251) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 11,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function enterMarkets(address[] calldata aTokens) external returns (uint[] memory);\n",
          "message": "ComptrollerInterface.enterMarkets (ABep20Harness.sol#11) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 4450,
          "vulnerability_to_line": 4464,
          "vulnerability_code": "    function enterMarkets(address[] memory aTokens) public returns (uint[] memory) {\n\n        uint len = aTokens.length;\n\n\n\n        uint[] memory results = new uint[](len);\n\n        for (uint i = 0; i < len; i++) {\n\n            AToken aToken = AToken(aTokens[i]);\n\n\n\n            results[i] = uint(addToMarketInternal(aToken, msg.sender));\n\n        }\n\n\n\n        return results;\n\n    }\n\n\n\n    /**\n",
          "message": "Comptroller.enterMarkets (ABep20Harness.sol#4450-4464) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 5005,
          "vulnerability_to_line": 5012,
          "vulnerability_code": "    function getAccountLiquidity(address account) public view returns (uint, uint, uint) {\n\n        (Error err, uint liquidity, uint shortfall) = getHypotheticalAccountLiquidityInternal(account, AToken(0), 0, 0);\n\n\n\n        return (uint(err), liquidity, shortfall);\n\n    }\n\n\n\n    /**\n",
          "message": "Comptroller.getAccountLiquidity (ABep20Harness.sol#5005-5012) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 5031,
          "vulnerability_to_line": 5041,
          "vulnerability_code": "    function getHypotheticalAccountLiquidity(\n\n        address account,\n\n        address aTokenModify,\n\n        uint redeemTokens,\n\n        uint borrowAmount) public view returns (uint, uint, uint) {\n\n        (Error err, uint liquidity, uint shortfall) = getHypotheticalAccountLiquidityInternal(account, AToken(aTokenModify), redeemTokens, borrowAmount);\n\n        return (uint(err), liquidity, shortfall);\n\n    }\n\n\n\n    /**\n",
          "message": "Comptroller.getHypotheticalAccountLiquidity (ABep20Harness.sol#5031-5041) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 5154,
          "vulnerability_to_line": 5173,
          "vulnerability_code": "    function _setPriceOracle(PriceOracle newOracle) public returns (uint) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PRICE_ORACLE_OWNER_CHECK);\n\n        }\n\n\n\n        // Track the old oracle for the comptroller\n\n        PriceOracle oldOracle = oracle;\n\n\n\n        // Set comptroller's oracle to newOracle\n\n        oracle = newOracle;\n\n\n\n        // Emit NewPriceOracle(oldOracle, newOracle)\n\n        emit NewPriceOracle(oldOracle, newOracle);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
          "message": "Comptroller._setPriceOracle (ABep20Harness.sol#5154-5173) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 5332,
          "vulnerability_to_line": 5349,
          "vulnerability_code": "    function _setPauseGuardian(address newPauseGuardian) public returns (uint) {\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PAUSE_GUARDIAN_OWNER_CHECK);\n\n        }\n\n\n\n        // Save current value for inclusion in log\n\n        address oldPauseGuardian = pauseGuardian;\n\n\n\n        // Store pauseGuardian with value newPauseGuardian\n\n        pauseGuardian = newPauseGuardian;\n\n\n\n        // Emit NewPauseGuardian(OldPauseGuardian, NewPauseGuardian)\n\n        emit NewPauseGuardian(oldPauseGuardian, pauseGuardian);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Comptroller._setPauseGuardian (ABep20Harness.sol#5332-5349) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 5349,
          "vulnerability_to_line": 5359,
          "vulnerability_code": "    function _setMintPaused(AToken aToken, bool state) public returns (bool) {\n\n        require(markets[address(aToken)].isListed, \"cannot pause a market that is not listed\");\n\n        require(msg.sender == pauseGuardian || msg.sender == admin, \"only pause guardian and admin can pause\");\n\n        require(msg.sender == admin || state == true, \"only admin can unpause\");\n\n\n\n        mintGuardianPaused[address(aToken)] = state;\n\n        emit ActionPaused(aToken, \"Mint\", state);\n\n        return state;\n\n    }\n\n\n",
          "message": "Comptroller._setMintPaused (ABep20Harness.sol#5349-5359) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 5359,
          "vulnerability_to_line": 5369,
          "vulnerability_code": "    function _setBorrowPaused(AToken aToken, bool state) public returns (bool) {\n\n        require(markets[address(aToken)].isListed, \"cannot pause a market that is not listed\");\n\n        require(msg.sender == pauseGuardian || msg.sender == admin, \"only pause guardian and admin can pause\");\n\n        require(msg.sender == admin || state == true, \"only admin can unpause\");\n\n\n\n        borrowGuardianPaused[address(aToken)] = state;\n\n        emit ActionPaused(aToken, \"Borrow\", state);\n\n        return state;\n\n    }\n\n\n",
          "message": "Comptroller._setBorrowPaused (ABep20Harness.sol#5359-5369) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 5369,
          "vulnerability_to_line": 5378,
          "vulnerability_code": "    function _setTransferPaused(bool state) public returns (bool) {\n\n        require(msg.sender == pauseGuardian || msg.sender == admin, \"only pause guardian and admin can pause\");\n\n        require(msg.sender == admin || state == true, \"only admin can unpause\");\n\n\n\n        transferGuardianPaused = state;\n\n        emit ActionPaused(\"Transfer\", state);\n\n        return state;\n\n    }\n\n\n",
          "message": "Comptroller._setTransferPaused (ABep20Harness.sol#5369-5378) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 5378,
          "vulnerability_to_line": 5387,
          "vulnerability_code": "    function _setSeizePaused(bool state) public returns (bool) {\n\n        require(msg.sender == pauseGuardian || msg.sender == admin, \"only pause guardian and admin can pause\");\n\n        require(msg.sender == admin || state == true, \"only admin can unpause\");\n\n\n\n        seizeGuardianPaused = state;\n\n        emit ActionPaused(\"Seize\", state);\n\n        return state;\n\n    }\n\n\n",
          "message": "Comptroller._setSeizePaused (ABep20Harness.sol#5378-5387) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 5387,
          "vulnerability_to_line": 5393,
          "vulnerability_code": "    function _become(Unitroller unitroller) public {\n\n        require(msg.sender == unitroller.admin(), \"only unitroller admin can change brains\");\n\n        require(unitroller._acceptImplementation() == 0, \"change not authorized\");\n\n    }\n\n\n\n    /**\n",
          "message": "Comptroller._become (ABep20Harness.sol#5387-5393) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 5559,
          "vulnerability_to_line": 5564,
          "vulnerability_code": "    function claimAtlantis(address holder) public {\n\n        return claimAtlantis(holder, allMarkets);\n\n    }\n\n\n\n    /**\n",
          "message": "Comptroller.claimAtlantis (ABep20Harness.sol#5559-5564) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 5629,
          "vulnerability_to_line": 5637,
          "vulnerability_code": "    function _grantAtlantis(address recipient, uint amount) public {\n\n        require(adminOrInitializing(), \"only admin can grant atlantis\");\n\n        uint amountLeft = grantAtlantisInternal(recipient, amount);\n\n        require(amountLeft == 0, \"insufficient atlantis for grant\");\n\n        emit AtlantisGranted(recipient, amount);\n\n    }\n\n\n\n    /**\n",
          "message": "Comptroller._grantAtlantis (ABep20Harness.sol#5629-5637) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 5641,
          "vulnerability_to_line": 5647,
          "vulnerability_code": "    function _setAtlantisSpeed(AToken aToken, uint atlantisSpeed) public {\n\n        require(adminOrInitializing(), \"only admin can set atlantis speed\");\n\n        setAtlantisSpeedInternal(aToken, atlantisSpeed);\n\n    }\n\n\n\n    /**\n",
          "message": "Comptroller._setAtlantisSpeed (ABep20Harness.sol#5641-5647) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 5651,
          "vulnerability_to_line": 5668,
          "vulnerability_code": "    function _setContributorAtlantisSpeed(address contributor, uint atlantisSpeed) public {\n\n        require(adminOrInitializing(), \"only admin can set atlantis speed\");\n\n\n\n        // note that Atlantis speed could be set to 0 to halt liquidity rewards for a contributor\n\n        updateContributorRewards(contributor);\n\n        if (atlantisSpeed == 0) {\n\n            // release storage\n\n            delete lastContributorBlock[contributor];\n\n        } else {\n\n            lastContributorBlock[contributor] = getBlockNumber();\n\n        }\n\n        atlantisContributorSpeeds[contributor] = atlantisSpeed;\n\n\n\n        emit ContributorAtlantisSpeedUpdated(contributor, atlantisSpeed);\n\n    }\n\n\n\n    /**\n",
          "message": "Comptroller._setContributorAtlantisSpeed (ABep20Harness.sol#5651-5668) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 5672,
          "vulnerability_to_line": 5681,
          "vulnerability_code": "    function _setAtlantisVaultRate(address vault_, uint atlantisVaultRate_) public {\n\n        require(msg.sender == admin, \"only admin can set Atlantis vault rate\");\n\n\n\n        uint oldAtlantisVaultRate = atlantisVaultRate[vault_];\n\n        atlantisVaultRate[vault_] = atlantisVaultRate_;\n\n        emit NewAtlantisVaultRate(vault_, oldAtlantisVaultRate, atlantisVaultRate[vault_]);\n\n    }\n\n\n\n    /**\n",
          "message": "Comptroller._setAtlantisVaultRate (ABep20Harness.sol#5672-5681) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 5686,
          "vulnerability_to_line": 5704,
          "vulnerability_code": "    function _setVaultInfo(address vault_, uint256 releaseStartBlock_, uint256 minReleaseAmount_) public {\n\n        require(msg.sender == admin, \"only admin can set vault info\");\n\n        require(releaseStartBlock_ > 0, \"Release start block should be greater than 0\");\n\n\n\n        if (vaultInfo[vault_].exists == false){\n\n            vaults.push(vault_);\n\n        }\n\n\n\n        vaultInfo[vault_] = VaultInfo({\n\n            releaseStartBlock: releaseStartBlock_,\n\n            minReleaseAmount: minReleaseAmount_,\n\n            exists: true\n\n        });\n\n\n\n        emit NewVaultInfo(vault_, releaseStartBlock_, minReleaseAmount_);\n\n    }\n\n\n\n    /**\n",
          "message": "Comptroller._setVaultInfo (ABep20Harness.sol#5686-5704) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 5760,
          "vulnerability_to_line": 5765,
          "vulnerability_code": "    function getAllMarkets() public view returns (AToken[] memory) {\n\n        return allMarkets;\n\n    }\n\n\n\n    /**\n",
          "message": "Comptroller.getAllMarkets (ABep20Harness.sol#5760-5765) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 5800,
          "vulnerability_to_line": 5805,
          "vulnerability_code": "    function fastForward(uint blocks) public returns (uint) {\n\n        blockNumber += blocks;\n\n        return blockNumber;\n\n    }\n\n\n",
          "message": "ComptrollerScenario.fastForward (ABep20Harness.sol#5800-5805) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 5805,
          "vulnerability_to_line": 5809,
          "vulnerability_code": "    function setAtlantisAddress(address atlantisAddress_) public {\n\n        atlantisAddress = atlantisAddress_;\n\n    }\n\n\n",
          "message": "ComptrollerScenario.setAtlantisAddress (ABep20Harness.sol#5805-5809) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 5813,
          "vulnerability_to_line": 5817,
          "vulnerability_code": "    function setBlockNumber(uint number) public {\n\n        blockNumber = number;\n\n    }\n\n\n",
          "message": "ComptrollerScenario.setBlockNumber (ABep20Harness.sol#5813-5817) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 5821,
          "vulnerability_to_line": 5825,
          "vulnerability_code": "    function membershipLength(AToken aToken) public view returns (uint) {\n\n        return accountAssets[address(aToken)].length;\n\n    }\n\n\n",
          "message": "ComptrollerScenario.membershipLength (ABep20Harness.sol#5821-5825) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 5825,
          "vulnerability_to_line": 5830,
          "vulnerability_code": "    function unlist(AToken aToken) public {\n\n        markets[address(aToken)].isListed = false;\n\n    }\n\n\n\n    /**\n",
          "message": "ComptrollerScenario.unlist (ABep20Harness.sol#5825-5830) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 5832,
          "vulnerability_to_line": 5862,
          "vulnerability_code": "    function refreshAtlantisSpeeds() public {\n\n        AToken[] memory allMarkets_ = allMarkets;\n\n\n\n        for (uint i = 0; i < allMarkets_.length; i++) {\n\n            AToken aToken = allMarkets_[i];\n\n            Exp memory borrowIndex = Exp({mantissa: aToken.borrowIndex()});\n\n            updateAtlantisSupplyIndex(address(aToken));\n\n            updateAtlantisBorrowIndex(address(aToken), borrowIndex);\n\n        }\n\n\n\n        Exp memory totalUtility = Exp({mantissa: 0});\n\n        Exp[] memory utilities = new Exp[](allMarkets_.length);\n\n        for (uint i = 0; i < allMarkets_.length; i++) {\n\n            AToken aToken = allMarkets_[i];\n\n            if (atlantisSpeeds[address(aToken)] > 0) {\n\n                Exp memory assetPrice = Exp({mantissa: oracle.getUnderlyingPrice(aToken)});\n\n                Exp memory utility = mul_(assetPrice, aToken.totalBorrows());\n\n                utilities[i] = utility;\n\n                totalUtility = add_(totalUtility, utility);\n\n            }\n\n        }\n\n\n\n        for (uint i = 0; i < allMarkets_.length; i++) {\n\n            AToken aToken = allMarkets[i];\n\n            uint newSpeed = totalUtility.mantissa > 0 ? mul_(atlantisRate, div_(utilities[i], totalUtility)) : 0;\n\n            setAtlantisSpeedInternal(aToken, newSpeed);\n\n        }\n\n    }\n\n}\n\n\n",
          "message": "ComptrollerScenario.refreshAtlantisSpeeds (ABep20Harness.sol#5832-5862) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 5911,
          "vulnerability_to_line": 5915,
          "vulnerability_code": "    function getBorrowRateMaxMantissa() public pure returns (uint) {\n\n        return borrowRateMaxMantissa;\n\n    }\n\n\n",
          "message": "ABep20Harness.getBorrowRateMaxMantissa (ABep20Harness.sol#5911-5915) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 5915,
          "vulnerability_to_line": 5919,
          "vulnerability_code": "    function harnessSetAccrualBlockNumber(uint _accrualblockNumber) public {\n\n        accrualBlockNumber = _accrualblockNumber;\n\n    }\n\n\n",
          "message": "ABep20Harness.harnessSetAccrualBlockNumber (ABep20Harness.sol#5915-5919) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 5919,
          "vulnerability_to_line": 5923,
          "vulnerability_code": "    function harnessSetBlockNumber(uint newBlockNumber) public {\n\n        blockNumber = newBlockNumber;\n\n    }\n\n\n",
          "message": "ABep20Harness.harnessSetBlockNumber (ABep20Harness.sol#5919-5923) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 5923,
          "vulnerability_to_line": 5927,
          "vulnerability_code": "    function harnessFastForward(uint blocks) public {\n\n        blockNumber += blocks;\n\n    }\n\n\n",
          "message": "ABep20Harness.harnessFastForward (ABep20Harness.sol#5923-5927) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 5931,
          "vulnerability_to_line": 5935,
          "vulnerability_code": "    function harnessSetTotalSupply(uint totalSupply_) public {\n\n        totalSupply = totalSupply_;\n\n    }\n\n\n",
          "message": "ABep20Harness.harnessSetTotalSupply (ABep20Harness.sol#5931-5935) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 5935,
          "vulnerability_to_line": 5939,
          "vulnerability_code": "    function harnessSetTotalBorrows(uint totalBorrows_) public {\n\n        totalBorrows = totalBorrows_;\n\n    }\n\n\n",
          "message": "ABep20Harness.harnessSetTotalBorrows (ABep20Harness.sol#5935-5939) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 5939,
          "vulnerability_to_line": 5943,
          "vulnerability_code": "    function harnessSetTotalReserves(uint totalReserves_) public {\n\n        totalReserves = totalReserves_;\n\n    }\n\n\n",
          "message": "ABep20Harness.harnessSetTotalReserves (ABep20Harness.sol#5939-5943) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 5943,
          "vulnerability_to_line": 5949,
          "vulnerability_code": "    function harnessExchangeRateDetails(uint totalSupply_, uint totalBorrows_, uint totalReserves_) public {\n\n        totalSupply = totalSupply_;\n\n        totalBorrows = totalBorrows_;\n\n        totalReserves = totalReserves_;\n\n    }\n\n\n",
          "message": "ABep20Harness.harnessExchangeRateDetails (ABep20Harness.sol#5943-5949) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 5949,
          "vulnerability_to_line": 5954,
          "vulnerability_code": "    function harnessSetExchangeRate(uint exchangeRate) public {\n\n        harnessExchangeRate = exchangeRate;\n\n        harnessExchangeRateStored = true;\n\n    }\n\n\n",
          "message": "ABep20Harness.harnessSetExchangeRate (ABep20Harness.sol#5949-5954) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 5954,
          "vulnerability_to_line": 5958,
          "vulnerability_code": "    function harnessSetFailTransferToAddress(address _to, bool _fail) public {\n\n        failTransferToAddresses[_to] = _fail;\n\n    }\n\n\n",
          "message": "ABep20Harness.harnessSetFailTransferToAddress (ABep20Harness.sol#5954-5958) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 5958,
          "vulnerability_to_line": 5963,
          "vulnerability_code": "    function harnessMintFresh(address account, uint mintAmount) public returns (uint) {\n\n        (uint err,) = super.mintFresh(account, mintAmount);\n\n        return err;\n\n    }\n\n\n",
          "message": "ABep20Harness.harnessMintFresh (ABep20Harness.sol#5958-5963) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 5963,
          "vulnerability_to_line": 5967,
          "vulnerability_code": "    function harnessRedeemFresh(address payable account, uint aTokenAmount, uint underlyingAmount) public returns (uint) {\n\n        return super.redeemFresh(account, aTokenAmount, underlyingAmount);\n\n    }\n\n\n",
          "message": "ABep20Harness.harnessRedeemFresh (ABep20Harness.sol#5963-5967) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 5967,
          "vulnerability_to_line": 5972,
          "vulnerability_code": "    function harnessAccountBorrows(address account) public view returns (uint principal, uint interestIndex) {\n\n        BorrowSnapshot memory snapshot = accountBorrows[account];\n\n        return (snapshot.principal, snapshot.interestIndex);\n\n    }\n\n\n",
          "message": "ABep20Harness.harnessAccountBorrows (ABep20Harness.sol#5967-5972) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 5972,
          "vulnerability_to_line": 5976,
          "vulnerability_code": "    function harnessSetAccountBorrows(address account, uint principal, uint interestIndex) public {\n\n        accountBorrows[account] = BorrowSnapshot({principal: principal, interestIndex: interestIndex});\n\n    }\n\n\n",
          "message": "ABep20Harness.harnessSetAccountBorrows (ABep20Harness.sol#5972-5976) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 5976,
          "vulnerability_to_line": 5980,
          "vulnerability_code": "    function harnessSetBorrowIndex(uint borrowIndex_) public {\n\n        borrowIndex = borrowIndex_;\n\n    }\n\n\n",
          "message": "ABep20Harness.harnessSetBorrowIndex (ABep20Harness.sol#5976-5980) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 5980,
          "vulnerability_to_line": 5984,
          "vulnerability_code": "    function harnessBorrowFresh(address payable account, uint borrowAmount) public returns (uint) {\n\n        return borrowFresh(account, borrowAmount);\n\n    }\n\n\n",
          "message": "ABep20Harness.harnessBorrowFresh (ABep20Harness.sol#5980-5984) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 5984,
          "vulnerability_to_line": 5989,
          "vulnerability_code": "    function harnessRepayBorrowFresh(address payer, address account, uint repayAmount) public returns (uint) {\n\n        (uint err,) = repayBorrowFresh(payer, account, repayAmount);\n\n        return err;\n\n    }\n\n\n",
          "message": "ABep20Harness.harnessRepayBorrowFresh (ABep20Harness.sol#5984-5989) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 5989,
          "vulnerability_to_line": 5994,
          "vulnerability_code": "    function harnessLiquidateBorrowFresh(address liquidator, address borrower, uint repayAmount, AToken aTokenCollateral) public returns (uint) {\n\n        (uint err,) = liquidateBorrowFresh(liquidator, borrower, repayAmount, aTokenCollateral);\n\n        return err;\n\n    }\n\n\n",
          "message": "ABep20Harness.harnessLiquidateBorrowFresh (ABep20Harness.sol#5989-5994) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 5994,
          "vulnerability_to_line": 5998,
          "vulnerability_code": "    function harnessReduceReservesFresh(uint amount) public returns (uint) {\n\n        return _reduceReservesFresh(amount);\n\n    }\n\n\n",
          "message": "ABep20Harness.harnessReduceReservesFresh (ABep20Harness.sol#5994-5998) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 5998,
          "vulnerability_to_line": 6002,
          "vulnerability_code": "    function harnessSetReserveFactorFresh(uint newReserveFactorMantissa) public returns (uint) {\n\n        return _setReserveFactorFresh(newReserveFactorMantissa);\n\n    }\n\n\n",
          "message": "ABep20Harness.harnessSetReserveFactorFresh (ABep20Harness.sol#5998-6002) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 6002,
          "vulnerability_to_line": 6006,
          "vulnerability_code": "    function harnessSetInterestRateModelFresh(InterestRateModel newInterestRateModel) public returns (uint) {\n\n        return _setInterestRateModelFresh(newInterestRateModel);\n\n    }\n\n\n",
          "message": "ABep20Harness.harnessSetInterestRateModelFresh (ABep20Harness.sol#6002-6006) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 6006,
          "vulnerability_to_line": 6010,
          "vulnerability_code": "    function harnessSetInterestRateModel(address newInterestRateModelAddress) public {\n\n        interestRateModel = InterestRateModel(newInterestRateModelAddress);\n\n    }\n\n\n",
          "message": "ABep20Harness.harnessSetInterestRateModel (ABep20Harness.sol#6006-6010) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 6010,
          "vulnerability_to_line": 6015,
          "vulnerability_code": "    function harnessCallBorrowAllowed(uint amount) public returns (uint) {\n\n        return comptroller.borrowAllowed(address(this), msg.sender, amount);\n\n    }\n\n}\n\n\n",
          "message": "ABep20Harness.harnessCallBorrowAllowed (ABep20Harness.sol#6010-6015) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 6034,
          "vulnerability_to_line": 6038,
          "vulnerability_code": "    function setTotalBorrows(uint totalBorrows_) public {\n\n        totalBorrows = totalBorrows_;\n\n    }\n\n\n",
          "message": "ABep20Scenario.setTotalBorrows (ABep20Harness.sol#6034-6038) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 6038,
          "vulnerability_to_line": 6042,
          "vulnerability_code": "    function setTotalReserves(uint totalReserves_) public {\n\n        totalReserves = totalReserves_;\n\n    }\n\n\n",
          "message": "ABep20Scenario.setTotalReserves (ABep20Harness.sol#6038-6042) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 6067,
          "vulnerability_to_line": 6072,
          "vulnerability_code": "    function evilSeize(AToken treasure, address liquidator, address borrower, uint seizeTokens) public returns (uint) {\n\n        return treasure.seize(liquidator, borrower, seizeTokens);\n\n    }\n\n}\n\n\n",
          "message": "CEvil.evilSeize (ABep20Harness.sol#6067-6072) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 6095,
          "vulnerability_to_line": 6099,
          "vulnerability_code": "    function setTotalBorrows(uint totalBorrows_) public {\n\n        totalBorrows = totalBorrows_;\n\n    }\n\n\n",
          "message": "ABep20DelegatorScenario.setTotalBorrows (ABep20Harness.sol#6095-6099) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 6099,
          "vulnerability_to_line": 6104,
          "vulnerability_code": "    function setTotalReserves(uint totalReserves_) public {\n\n        totalReserves = totalReserves_;\n\n    }\n\n}\n\n\n",
          "message": "ABep20DelegatorScenario.setTotalReserves (ABep20Harness.sol#6099-6104) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 6130,
          "vulnerability_to_line": 6134,
          "vulnerability_code": "    function getBorrowRateMaxMantissa() public pure returns (uint) {\n\n        return borrowRateMaxMantissa;\n\n    }\n\n\n",
          "message": "ABep20DelegateHarness.getBorrowRateMaxMantissa (ABep20Harness.sol#6130-6134) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 6134,
          "vulnerability_to_line": 6138,
          "vulnerability_code": "    function harnessSetBlockNumber(uint newBlockNumber) public {\n\n        blockNumber = newBlockNumber;\n\n    }\n\n\n",
          "message": "ABep20DelegateHarness.harnessSetBlockNumber (ABep20Harness.sol#6134-6138) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 6138,
          "vulnerability_to_line": 6142,
          "vulnerability_code": "    function harnessFastForward(uint blocks) public {\n\n        blockNumber += blocks;\n\n    }\n\n\n",
          "message": "ABep20DelegateHarness.harnessFastForward (ABep20Harness.sol#6138-6142) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 6146,
          "vulnerability_to_line": 6150,
          "vulnerability_code": "    function harnessSetAccrualBlockNumber(uint _accrualblockNumber) public {\n\n        accrualBlockNumber = _accrualblockNumber;\n\n    }\n\n\n",
          "message": "ABep20DelegateHarness.harnessSetAccrualBlockNumber (ABep20Harness.sol#6146-6150) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 6150,
          "vulnerability_to_line": 6154,
          "vulnerability_code": "    function harnessSetTotalSupply(uint totalSupply_) public {\n\n        totalSupply = totalSupply_;\n\n    }\n\n\n",
          "message": "ABep20DelegateHarness.harnessSetTotalSupply (ABep20Harness.sol#6150-6154) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 6154,
          "vulnerability_to_line": 6158,
          "vulnerability_code": "    function harnessSetTotalBorrows(uint totalBorrows_) public {\n\n        totalBorrows = totalBorrows_;\n\n    }\n\n\n",
          "message": "ABep20DelegateHarness.harnessSetTotalBorrows (ABep20Harness.sol#6154-6158) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 6158,
          "vulnerability_to_line": 6162,
          "vulnerability_code": "    function harnessIncrementTotalBorrows(uint addtlBorrow_) public {\n\n        totalBorrows = totalBorrows + addtlBorrow_;\n\n    }\n\n\n",
          "message": "ABep20DelegateHarness.harnessIncrementTotalBorrows (ABep20Harness.sol#6158-6162) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 6162,
          "vulnerability_to_line": 6166,
          "vulnerability_code": "    function harnessSetTotalReserves(uint totalReserves_) public {\n\n        totalReserves = totalReserves_;\n\n    }\n\n\n",
          "message": "ABep20DelegateHarness.harnessSetTotalReserves (ABep20Harness.sol#6162-6166) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 6166,
          "vulnerability_to_line": 6172,
          "vulnerability_code": "    function harnessExchangeRateDetails(uint totalSupply_, uint totalBorrows_, uint totalReserves_) public {\n\n        totalSupply = totalSupply_;\n\n        totalBorrows = totalBorrows_;\n\n        totalReserves = totalReserves_;\n\n    }\n\n\n",
          "message": "ABep20DelegateHarness.harnessExchangeRateDetails (ABep20Harness.sol#6166-6172) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 6172,
          "vulnerability_to_line": 6177,
          "vulnerability_code": "    function harnessSetExchangeRate(uint exchangeRate) public {\n\n        harnessExchangeRate = exchangeRate;\n\n        harnessExchangeRateStored = true;\n\n    }\n\n\n",
          "message": "ABep20DelegateHarness.harnessSetExchangeRate (ABep20Harness.sol#6172-6177) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 6177,
          "vulnerability_to_line": 6181,
          "vulnerability_code": "    function harnessSetFailTransferToAddress(address _to, bool _fail) public {\n\n        failTransferToAddresses[_to] = _fail;\n\n    }\n\n\n",
          "message": "ABep20DelegateHarness.harnessSetFailTransferToAddress (ABep20Harness.sol#6177-6181) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 6181,
          "vulnerability_to_line": 6186,
          "vulnerability_code": "    function harnessMintFresh(address account, uint mintAmount) public returns (uint) {\n\n        (uint err,) = super.mintFresh(account, mintAmount);\n\n        return err;\n\n    }\n\n\n",
          "message": "ABep20DelegateHarness.harnessMintFresh (ABep20Harness.sol#6181-6186) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 6186,
          "vulnerability_to_line": 6190,
          "vulnerability_code": "    function harnessRedeemFresh(address payable account, uint aTokenAmount, uint underlyingAmount) public returns (uint) {\n\n        return super.redeemFresh(account, aTokenAmount, underlyingAmount);\n\n    }\n\n\n",
          "message": "ABep20DelegateHarness.harnessRedeemFresh (ABep20Harness.sol#6186-6190) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 6190,
          "vulnerability_to_line": 6195,
          "vulnerability_code": "    function harnessAccountBorrows(address account) public view returns (uint principal, uint interestIndex) {\n\n        BorrowSnapshot memory snapshot = accountBorrows[account];\n\n        return (snapshot.principal, snapshot.interestIndex);\n\n    }\n\n\n",
          "message": "ABep20DelegateHarness.harnessAccountBorrows (ABep20Harness.sol#6190-6195) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 6195,
          "vulnerability_to_line": 6199,
          "vulnerability_code": "    function harnessSetAccountBorrows(address account, uint principal, uint interestIndex) public {\n\n        accountBorrows[account] = BorrowSnapshot({principal: principal, interestIndex: interestIndex});\n\n    }\n\n\n",
          "message": "ABep20DelegateHarness.harnessSetAccountBorrows (ABep20Harness.sol#6195-6199) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 6199,
          "vulnerability_to_line": 6203,
          "vulnerability_code": "    function harnessSetBorrowIndex(uint borrowIndex_) public {\n\n        borrowIndex = borrowIndex_;\n\n    }\n\n\n",
          "message": "ABep20DelegateHarness.harnessSetBorrowIndex (ABep20Harness.sol#6199-6203) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 6203,
          "vulnerability_to_line": 6207,
          "vulnerability_code": "    function harnessBorrowFresh(address payable account, uint borrowAmount) public returns (uint) {\n\n        return borrowFresh(account, borrowAmount);\n\n    }\n\n\n",
          "message": "ABep20DelegateHarness.harnessBorrowFresh (ABep20Harness.sol#6203-6207) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 6207,
          "vulnerability_to_line": 6212,
          "vulnerability_code": "    function harnessRepayBorrowFresh(address payer, address account, uint repayAmount) public returns (uint) {\n\n        (uint err,) = repayBorrowFresh(payer, account, repayAmount);\n\n        return err;\n\n    }\n\n\n",
          "message": "ABep20DelegateHarness.harnessRepayBorrowFresh (ABep20Harness.sol#6207-6212) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 6212,
          "vulnerability_to_line": 6217,
          "vulnerability_code": "    function harnessLiquidateBorrowFresh(address liquidator, address borrower, uint repayAmount, AToken aTokenCollateral) public returns (uint) {\n\n        (uint err,) = liquidateBorrowFresh(liquidator, borrower, repayAmount, aTokenCollateral);\n\n        return err;\n\n    }\n\n\n",
          "message": "ABep20DelegateHarness.harnessLiquidateBorrowFresh (ABep20Harness.sol#6212-6217) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 6217,
          "vulnerability_to_line": 6221,
          "vulnerability_code": "    function harnessReduceReservesFresh(uint amount) public returns (uint) {\n\n        return _reduceReservesFresh(amount);\n\n    }\n\n\n",
          "message": "ABep20DelegateHarness.harnessReduceReservesFresh (ABep20Harness.sol#6217-6221) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 6221,
          "vulnerability_to_line": 6225,
          "vulnerability_code": "    function harnessSetReserveFactorFresh(uint newReserveFactorMantissa) public returns (uint) {\n\n        return _setReserveFactorFresh(newReserveFactorMantissa);\n\n    }\n\n\n",
          "message": "ABep20DelegateHarness.harnessSetReserveFactorFresh (ABep20Harness.sol#6221-6225) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 6225,
          "vulnerability_to_line": 6229,
          "vulnerability_code": "    function harnessSetInterestRateModelFresh(InterestRateModel newInterestRateModel) public returns (uint) {\n\n        return _setInterestRateModelFresh(newInterestRateModel);\n\n    }\n\n\n",
          "message": "ABep20DelegateHarness.harnessSetInterestRateModelFresh (ABep20Harness.sol#6225-6229) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 6229,
          "vulnerability_to_line": 6233,
          "vulnerability_code": "    function harnessSetInterestRateModel(address newInterestRateModelAddress) public {\n\n        interestRateModel = InterestRateModel(newInterestRateModelAddress);\n\n    }\n\n\n",
          "message": "ABep20DelegateHarness.harnessSetInterestRateModel (ABep20Harness.sol#6229-6233) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 6233,
          "vulnerability_to_line": 6238,
          "vulnerability_code": "    function harnessCallBorrowAllowed(uint amount) public returns (uint) {\n\n        return comptroller.borrowAllowed(address(this), msg.sender, amount);\n\n    }\n\n}\n\n\n",
          "message": "ABep20DelegateHarness.harnessCallBorrowAllowed (ABep20Harness.sol#6233-6238) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 6241,
          "vulnerability_to_line": 6245,
          "vulnerability_code": "    function setTotalBorrows(uint totalBorrows_) public {\n\n        totalBorrows = totalBorrows_;\n\n    }\n\n\n",
          "message": "ABep20DelegateScenario.setTotalBorrows (ABep20Harness.sol#6241-6245) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 6245,
          "vulnerability_to_line": 6249,
          "vulnerability_code": "    function setTotalReserves(uint totalReserves_) public {\n\n        totalReserves = totalReserves_;\n\n    }\n\n\n",
          "message": "ABep20DelegateScenario.setTotalReserves (ABep20Harness.sol#6245-6249) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 6256,
          "vulnerability_to_line": 6260,
          "vulnerability_code": "    function iHaveSpoken() public pure returns (string memory) {\n\n      return \"i have spoken\";\n\n    }\n\n\n",
          "message": "ABep20DelegateScenarioExtra.iHaveSpoken (ABep20Harness.sol#6256-6260) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 6260,
          "vulnerability_to_line": 6264,
          "vulnerability_code": "    function itIsTheWay() public {\n\n      admin = address(1); // make a change to test effect\n\n    }\n\n\n",
          "message": "ABep20DelegateScenarioExtra.itIsTheWay (ABep20Harness.sol#6260-6264) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 6264,
          "vulnerability_to_line": 6269,
          "vulnerability_code": "    function babyYoda() public pure {\n\n      revert(\"protect the baby\");\n\n    }\n\n}\n\n\n",
          "message": "ABep20DelegateScenarioExtra.babyYoda (ABep20Harness.sol#6264-6269) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 6274,
          "vulnerability_to_line": 6278,
          "vulnerability_code": "    function harnessFastForward(uint blocks) public {\n\n        blockNumber += blocks;\n\n    }\n\n\n",
          "message": "ADaiDelegateHarness.harnessFastForward (ABep20Harness.sol#6274-6278) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 6278,
          "vulnerability_to_line": 6282,
          "vulnerability_code": "    function harnessSetAccrualBlockNumber(uint _accrualblockNumber) public {\n\n        accrualBlockNumber = _accrualblockNumber;\n\n    }\n\n\n",
          "message": "ADaiDelegateHarness.harnessSetAccrualBlockNumber (ABep20Harness.sol#6278-6282) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 6286,
          "vulnerability_to_line": 6290,
          "vulnerability_code": "    function harnessSetBlockNumber(uint newBlockNumber) public {\n\n        blockNumber = newBlockNumber;\n\n    }\n\n\n",
          "message": "ADaiDelegateHarness.harnessSetBlockNumber (ABep20Harness.sol#6286-6290) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 6290,
          "vulnerability_to_line": 6295,
          "vulnerability_code": "    function harnessSetExchangeRate(uint exchangeRate) public {\n\n        harnessExchangeRate = exchangeRate;\n\n        harnessExchangeRateStored = true;\n\n    }\n\n\n",
          "message": "ADaiDelegateHarness.harnessSetExchangeRate (ABep20Harness.sol#6290-6295) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 6295,
          "vulnerability_to_line": 6299,
          "vulnerability_code": "    function harnessSetTotalSupply(uint totalSupply_) public {\n\n        totalSupply = totalSupply_;\n\n    }\n\n\n",
          "message": "ADaiDelegateHarness.harnessSetTotalSupply (ABep20Harness.sol#6295-6299) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 6305,
          "vulnerability_to_line": 6309,
          "vulnerability_code": "    function setTotalBorrows(uint totalBorrows_) public {\n\n        totalBorrows = totalBorrows_;\n\n    }\n\n\n",
          "message": "ADaiDelegateScenario.setTotalBorrows (ABep20Harness.sol#6305-6309) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 6309,
          "vulnerability_to_line": 6313,
          "vulnerability_code": "    function setTotalReserves(uint totalReserves_) public {\n\n        totalReserves = totalReserves_;\n\n    }\n\n\n",
          "message": "ADaiDelegateScenario.setTotalReserves (ABep20Harness.sol#6309-6313) should be declared external\n"
        },
        {
          "name": "solc-version",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": "Detected issues with version pragma in ABep20Harness.sol:\n\t- pragma solidity^0.5.16 (ABep20Harness.sol#3): it allows old versions\n\t- pragma solidity^0.5.16 (ABep20Harness.sol#83): it allows old versions\n\t- pragma solidity^0.5.16 (ABep20Harness.sol#116): it allows old versions\n\t- pragma solidity^0.5.16 (ABep20Harness.sol#189): it allows old versions\n\t- pragma solidity^0.5.16 (ABep20Harness.sol#500): it allows old versions\n\t- pragma solidity^0.5.16 (ABep20Harness.sol#710): it allows old versions\n\t- pragma solidity^0.5.16 (ABep20Harness.sol#798): it allows old versions\n\t- pragma solidity^0.5.16 (ABep20Harness.sol#996): it allows old versions\n\t- pragma solidity^0.5.16 (ABep20Harness.sol#1180): it allows old versions\n\t- pragma solidity^0.5.16 (ABep20Harness.sol#1245): it allows old versions\n\t- pragma solidity^0.5.16 (ABep20Harness.sol#2705-2707): it allows old versions\n\t- pragma solidity^0.5.16 (ABep20Harness.sol#2928-2931): it allows old versions\n\t- pragma solidity^0.5.16 (ABep20Harness.sol#2968-2971): it allows old versions\n\t- pragma solidity^0.5.16 (ABep20Harness.sol#3445-3448): it allows old versions\n\t- pragma solidity^0.5.16 (ABep20Harness.sol#3489-3492): it allows old versions\n\t- pragma solidity^0.5.16 (ABep20Harness.sol#3698-3700): it allows old versions\n\t- pragma solidity^0.5.16 (ABep20Harness.sol#3715-3718): it allows old versions\n\t- pragma solidity^0.5.16 (ABep20Harness.sol#3879-3882): it allows old versions\n\t- pragma solidity^0.5.16 (ABep20Harness.sol#4029-4030): it allows old versions\n\t- pragma solidity^0.5.16 (ABep20Harness.sol#4333-4341): it allows old versions\n\t- pragma solidity^0.5.16 (ABep20Harness.sol#5792-5794): it allows old versions\n\t- pragma solidity^0.5.16 (ABep20Harness.sol#5864-5870): it allows old versions\n"
        },
        {
          "name": "low-level-calls",
          "vulnerability_from_line": 3385,
          "vulnerability_to_line": 3395,
          "vulnerability_code": "    function delegateTo(address callee, bytes memory data) internal returns (bytes memory) {\n\n        (bool success, bytes memory returnData) = callee.delegatecall(data);\n\n        assembly {\n\n            if eq(success, 0) {\n\n                revert(add(returnData, 0x20), returndatasize)\n\n            }\n\n        }\n\n        return returnData;\n\n    }\n\n\n",
          "message": "Low level call in ABep20Delegator.delegateTo (ABep20Harness.sol#3385-3395):\n\t-(success,returnData) = callee.delegatecall(data) ABep20Harness.sol#3386-3387\n"
        },
        {
          "name": "low-level-calls",
          "vulnerability_from_line": 3412,
          "vulnerability_to_line": 3422,
          "vulnerability_code": "    function delegateToViewImplementation(bytes memory data) public view returns (bytes memory) {\n\n        (bool success, bytes memory returnData) = address(this).staticcall(abi.encodeWithSignature(\"delegateToImplementation(bytes)\", data));\n\n        assembly {\n\n            if eq(success, 0) {\n\n                revert(add(returnData, 0x20), returndatasize)\n\n            }\n\n        }\n\n        return abi.decode(returnData, (bytes));\n\n    }\n\n\n",
          "message": "Low level call in ABep20Delegator.delegateToViewImplementation (ABep20Harness.sol#3412-3422):\n\t-(success,returnData) = address(this).staticcall(abi.encodeWithSignature(delegateToImplementation(bytes),data)) ABep20Harness.sol#3413-3414\n"
        },
        {
          "name": "low-level-calls",
          "vulnerability_from_line": 3426,
          "vulnerability_to_line": 3443,
          "vulnerability_code": "    function () external payable {\n\n        require(msg.value == 0,\"ABep20Delegator:fallback: cannot send value to fallback\");\n\n\n\n        // delegate all other functions to current implementation\n\n        (bool success, ) = implementation.delegatecall(msg.data);\n\n\n\n        assembly {\n\n            let free_mem_ptr := mload(0x40)\n\n            returndatacopy(free_mem_ptr, 0, returndatasize)\n\n\n\n            switch success\n\n            case 0 { revert(free_mem_ptr, returndatasize) }\n\n            default { return(free_mem_ptr, returndatasize) }\n\n        }\n\n    }\n\n}\n\n\n",
          "message": "Low level call in ABep20Delegator.fallback (ABep20Harness.sol#3426-3443):\n\t-(success) = implementation.delegatecall(msg.data) ABep20Harness.sol#3430-3432\n"
        },
        {
          "name": "low-level-calls",
          "vulnerability_from_line": 4012,
          "vulnerability_to_line": 4027,
          "vulnerability_code": "    function () payable external {\n\n        // delegate all other functions to current implementation\n\n        (bool success, ) = comptrollerImplementation.delegatecall(msg.data);\n\n\n\n        assembly {\n\n              let free_mem_ptr := mload(0x40)\n\n              returndatacopy(free_mem_ptr, 0, returndatasize)\n\n\n\n              switch success\n\n              case 0 { revert(free_mem_ptr, returndatasize) }\n\n              default { return(free_mem_ptr, returndatasize) }\n\n        }\n\n    }\n\n}\n\n\n",
          "message": "Low level call in Unitroller.fallback (ABep20Harness.sol#4012-4027):\n\t-(success) = comptrollerImplementation.delegatecall(msg.data) ABep20Harness.sol#4014-4016\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 7,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bool public constant isComptroller = true;\n",
          "message": "Constant 'ComptrollerInterface.isComptroller' (ABep20Harness.sol#7) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 91,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bool public constant isInterestRateModel = true;\n",
          "message": "Constant 'InterestRateModel.isInterestRateModel' (ABep20Harness.sol#91) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 197,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bool internal _notEntered;\n",
          "message": "Variable 'ATokenStorage._notEntered' (ABep20Harness.sol#197) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 218,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint internal constant borrowRateMaxMantissa = 0.0005e16;\n",
          "message": "Constant 'ATokenStorage.borrowRateMaxMantissa' (ABep20Harness.sol#218) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 223,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint internal constant reserveFactorMaxMantissa = 1e18;\n",
          "message": "Constant 'ATokenStorage.reserveFactorMaxMantissa' (ABep20Harness.sol#223) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 308,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint public constant protocolSeizeShareMantissa = 2.8e16; //2.8%\n",
          "message": "Constant 'ATokenStorage.protocolSeizeShareMantissa' (ABep20Harness.sol#308) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 428,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint);\n",
          "message": "Function 'ATokenInterface._setPendingAdmin' (ABep20Harness.sol#428) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 429,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _acceptAdmin() external returns (uint);\n",
          "message": "Function 'ATokenInterface._acceptAdmin' (ABep20Harness.sol#429) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 430,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setComptroller(ComptrollerInterface newComptroller) public returns (uint);\n",
          "message": "Function 'ATokenInterface._setComptroller' (ABep20Harness.sol#430) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 431,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setReserveFactor(uint newReserveFactorMantissa) external returns (uint);\n",
          "message": "Function 'ATokenInterface._setReserveFactor' (ABep20Harness.sol#431) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 432,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _reduceReserves(uint reduceAmount) external returns (uint);\n",
          "message": "Function 'ATokenInterface._reduceReserves' (ABep20Harness.sol#432) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 433,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint);\n",
          "message": "Function 'ATokenInterface._setInterestRateModel' (ABep20Harness.sol#433) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 316,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bool public constant isAToken = true;\n",
          "message": "Constant 'ATokenInterface.isAToken' (ABep20Harness.sol#316) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 459,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _addReserves(uint addAmount) external returns (uint);\n",
          "message": "Function 'ABep20Interface._addReserves' (ABep20Harness.sol#459) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 481,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setImplementation(address implementation_, bool allowResign, bytes memory becomeImplementationData) public;\n",
          "message": "Function 'ADelegatorInterface._setImplementation' (ABep20Harness.sol#481) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 490,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _becomeImplementation(bytes memory data) public;\n",
          "message": "Function 'ADelegateInterface._becomeImplementation' (ABep20Harness.sol#490) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 495,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _resignImplementation() public;\n",
          "message": "Function 'ADelegateInterface._resignImplementation' (ABep20Harness.sol#495) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 833,
          "vulnerability_to_line": 836,
          "vulnerability_code": "    function mul_ScalarTruncate(Exp memory a, uint scalar) pure internal returns (uint) {\n\n        Exp memory product = mul_(a, scalar);\n\n        return truncate(product);\n",
          "message": "Function 'ExponentialNoError.mul_ScalarTruncate' (ABep20Harness.sol#833-836) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 841,
          "vulnerability_to_line": 844,
          "vulnerability_code": "    function mul_ScalarTruncateAddUInt(Exp memory a, uint scalar, uint addend) pure internal returns (uint) {\n\n        Exp memory product = mul_(a, scalar);\n\n        return add_(truncate(product), addend);\n",
          "message": "Function 'ExponentialNoError.mul_ScalarTruncateAddUInt' (ABep20Harness.sol#841-844) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 808,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint constant expScale = 1e18;\n",
          "message": "Constant 'ExponentialNoError.expScale' (ABep20Harness.sol#808) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 809,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint constant doubleScale = 1e36;\n",
          "message": "Constant 'ExponentialNoError.doubleScale' (ABep20Harness.sol#809) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 810,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint constant halfExpScale = expScale/2;\n",
          "message": "Constant 'ExponentialNoError.halfExpScale' (ABep20Harness.sol#810) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 811,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint constant mantissaOne = expScale;\n",
          "message": "Constant 'ExponentialNoError.mantissaOne' (ABep20Harness.sol#811) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 2375,
          "vulnerability_to_line": 2391,
          "vulnerability_code": "    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint) {\n\n        // Check caller = admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);\n\n        }\n\n\n\n        // Save current value, if any, for inclusion in log\n\n        address oldPendingAdmin = pendingAdmin;\n\n\n\n        // Store pendingAdmin with value newPendingAdmin\n\n        pendingAdmin = newPendingAdmin;\n\n\n\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\n\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n\n\n\n        return uint(Error.NO_ERROR);\n",
          "message": "Function 'AToken._setPendingAdmin' (ABep20Harness.sol#2375-2391) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 2398,
          "vulnerability_to_line": 2420,
          "vulnerability_code": "    function _acceptAdmin() external returns (uint) {\n\n        // Check caller is pendingAdmin and pendingAdmin \u2260 address(0)\n\n        if (msg.sender != pendingAdmin || msg.sender == address(0)) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);\n\n        }\n\n\n\n        // Save current values for inclusion in log\n\n        address oldAdmin = admin;\n\n        address oldPendingAdmin = pendingAdmin;\n\n\n\n        // Store admin with value pendingAdmin\n\n        admin = pendingAdmin;\n\n\n\n        // Clear the pending value\n\n        pendingAdmin = address(0);\n\n\n\n        emit NewAdmin(oldAdmin, admin);\n\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Function 'AToken._acceptAdmin' (ABep20Harness.sol#2398-2420) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 2425,
          "vulnerability_to_line": 2444,
          "vulnerability_code": "    function _setComptroller(ComptrollerInterface newComptroller) public returns (uint) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COMPTROLLER_OWNER_CHECK);\n\n        }\n\n\n\n        ComptrollerInterface oldComptroller = comptroller;\n\n        // Ensure invoke comptroller.isComptroller() returns true\n\n        require(newComptroller.isComptroller(), \"marker method returned false\");\n\n\n\n        // Set market's comptroller to newComptroller\n\n        comptroller = newComptroller;\n\n\n\n        // Emit NewComptroller(oldComptroller, newComptroller)\n\n        emit NewComptroller(oldComptroller, newComptroller);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Function 'AToken._setComptroller' (ABep20Harness.sol#2425-2444) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 2449,
          "vulnerability_to_line": 2459,
          "vulnerability_code": "    function _setReserveFactor(uint newReserveFactorMantissa) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.\n\n            return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.\n\n        return _setReserveFactorFresh(newReserveFactorMantissa);\n\n    }\n\n\n",
          "message": "Function 'AToken._setReserveFactor' (ABep20Harness.sol#2449-2459) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 2556,
          "vulnerability_to_line": 2566,
          "vulnerability_code": "    function _reduceReserves(uint reduceAmount) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n\n            return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.\n\n        return _reduceReservesFresh(reduceAmount);\n\n    }\n\n\n",
          "message": "Function 'AToken._reduceReserves' (ABep20Harness.sol#2556-2566) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 2621,
          "vulnerability_to_line": 2631,
          "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n\n        return _setInterestRateModelFresh(newInterestRateModel);\n\n    }\n\n\n",
          "message": "Function 'AToken._setInterestRateModel' (ABep20Harness.sol#2621-2631) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 2464,
          "vulnerability_to_line": 2488,
          "vulnerability_code": "    function _setReserveFactorFresh(uint newReserveFactorMantissa) internal returns (uint) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_RESERVE_FACTOR_ADMIN_CHECK);\n\n        }\n\n\n\n        // Verify market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_RESERVE_FACTOR_FRESH_CHECK);\n\n        }\n\n\n\n        // Check newReserveFactor \u2264 maxReserveFactor\n\n        if (newReserveFactorMantissa > reserveFactorMaxMantissa) {\n\n            return fail(Error.BAD_INPUT, FailureInfo.SET_RESERVE_FACTOR_BOUNDS_CHECK);\n\n        }\n\n\n\n        uint oldReserveFactorMantissa = reserveFactorMantissa;\n\n        reserveFactorMantissa = newReserveFactorMantissa;\n\n\n\n        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Function 'AToken._setReserveFactorFresh' (ABep20Harness.sol#2464-2488) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 2493,
          "vulnerability_to_line": 2505,
          "vulnerability_code": "    function _addReservesInternal(uint addAmount) internal nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n\n            return fail(Error(error), FailureInfo.ADD_RESERVES_ACCRUE_INTEREST_FAILED);\n\n        }\n\n\n\n        // _addReservesFresh emits reserve-addition-specific logs on errors, so we don't need to.\n\n        (error, ) = _addReservesFresh(addAmount);\n\n        return error;\n\n    }\n\n\n",
          "message": "Function 'AToken._addReservesInternal' (ABep20Harness.sol#2493-2505) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 2511,
          "vulnerability_to_line": 2551,
          "vulnerability_code": "    function _addReservesFresh(uint addAmount) internal returns (uint, uint) {\n\n        // totalReserves + actualAddAmount\n\n        uint totalReservesNew;\n\n        uint actualAddAmount;\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return (fail(Error.MARKET_NOT_FRESH, FailureInfo.ADD_RESERVES_FRESH_CHECK), actualAddAmount);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We call doTransferIn for the caller and the addAmount\n\n         *  Note: The aToken must handle variations between BEP-20 and BNB underlying.\n\n         *  On success, the aToken holds an additional addAmount of cash.\n\n         *  doTransferIn reverts if anything goes wrong, since we can't be sure if side effects occurred.\n\n         *  it returns the amount actually transferred, in case of a fee.\n\n         */\n\n\n\n        actualAddAmount = doTransferIn(msg.sender, addAmount);\n\n\n\n        totalReservesNew = totalReserves + actualAddAmount;\n\n\n\n        /* Revert on overflow */\n\n        require(totalReservesNew >= totalReserves, \"add reserves unexpected overflow\");\n\n\n\n        // Store reserves[n+1] = reserves[n] + actualAddAmount\n\n        totalReserves = totalReservesNew;\n\n\n\n        /* Emit NewReserves(admin, actualAddAmount, reserves[n+1]) */\n\n        emit ReservesAdded(msg.sender, actualAddAmount, totalReservesNew);\n\n\n\n        /* Return (NO_ERROR, actualAddAmount) */\n\n        return (uint(Error.NO_ERROR), actualAddAmount);\n\n    }\n\n\n\n\n",
          "message": "Function 'AToken._addReservesFresh' (ABep20Harness.sol#2511-2551) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 2572,
          "vulnerability_to_line": 2615,
          "vulnerability_code": "    function _reduceReservesFresh(uint reduceAmount) internal returns (uint) {\n\n        // totalReserves - reduceAmount\n\n        uint totalReservesNew;\n\n\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.REDUCE_RESERVES_ADMIN_CHECK);\n\n        }\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDUCE_RESERVES_FRESH_CHECK);\n\n        }\n\n\n\n        // Fail gracefully if protocol has insufficient underlying cash\n\n        if (getCashPrior() < reduceAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDUCE_RESERVES_CASH_NOT_AVAILABLE);\n\n        }\n\n\n\n        // Check reduceAmount \u2264 reserves[n] (totalReserves)\n\n        if (reduceAmount > totalReserves) {\n\n            return fail(Error.BAD_INPUT, FailureInfo.REDUCE_RESERVES_VALIDATION);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        totalReservesNew = totalReserves - reduceAmount;\n\n        // We checked reduceAmount <= totalReserves above, so this should never revert.\n\n        require(totalReservesNew <= totalReserves, \"reduce reserves unexpected underflow\");\n\n\n\n        // Store reserves[n+1] = reserves[n] - reduceAmount\n\n        totalReserves = totalReservesNew;\n\n\n\n        // doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n\n        doTransferOut(admin, reduceAmount);\n\n\n\n        emit ReservesReduced(admin, reduceAmount, totalReservesNew);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Function 'AToken._reduceReservesFresh' (ABep20Harness.sol#2572-2615) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 2637,
          "vulnerability_to_line": 2667,
          "vulnerability_code": "    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {\n\n\n\n        // Used to store old model for use in the event that is emitted on success\n\n        InterestRateModel oldInterestRateModel;\n\n\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);\n\n        }\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);\n\n        }\n\n\n\n        // Track the market's current interest rate model\n\n        oldInterestRateModel = interestRateModel;\n\n\n\n        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true\n\n        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n\n\n\n        // Set the interest rate model to newInterestRateModel\n\n        interestRateModel = newInterestRateModel;\n\n\n\n        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)\n\n        emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Function 'AToken._setInterestRateModelFresh' (ABep20Harness.sol#2637-2667) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 2833,
          "vulnerability_to_line": 2837,
          "vulnerability_code": "    function _addReserves(uint addAmount) external returns (uint) {\n\n        return _addReservesInternal(addAmount);\n\n    }\n\n\n",
          "message": "Function 'ABep20._addReserves' (ABep20Harness.sol#2833-2837) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 2920,
          "vulnerability_to_line": 2926,
          "vulnerability_code": "    function _delegateAtlantisLikeTo(address atlantisLikeDelegatee) external {\n\n        require(msg.sender == admin, \"only the admin may set the atlantis-like delegate\");\n\n        AtlantisLike(underlying).delegate(atlantisLikeDelegatee);\n\n    }\n\n}\n\n\n",
          "message": "Function 'ABep20._delegateAtlantisLikeTo' (ABep20Harness.sol#2920-2926) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 3312,
          "vulnerability_to_line": 3317,
          "vulnerability_code": "    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint) {\n\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"_setPendingAdmin(address)\", newPendingAdmin));\n\n        return abi.decode(data, (uint));\n\n    }\n\n\n",
          "message": "Function 'ABep20Delegator._setPendingAdmin' (ABep20Harness.sol#3312-3317) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 3342,
          "vulnerability_to_line": 3347,
          "vulnerability_code": "    function _acceptAdmin() external returns (uint) {\n\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"_acceptAdmin()\"));\n\n        return abi.decode(data, (uint));\n\n    }\n\n\n",
          "message": "Function 'ABep20Delegator._acceptAdmin' (ABep20Harness.sol#3342-3347) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 3322,
          "vulnerability_to_line": 3327,
          "vulnerability_code": "    function _setComptroller(ComptrollerInterface newComptroller) public returns (uint) {\n\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"_setComptroller(address)\", newComptroller));\n\n        return abi.decode(data, (uint));\n\n    }\n\n\n",
          "message": "Function 'ABep20Delegator._setComptroller' (ABep20Harness.sol#3322-3327) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 3332,
          "vulnerability_to_line": 3337,
          "vulnerability_code": "    function _setReserveFactor(uint newReserveFactorMantissa) external returns (uint) {\n\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"_setReserveFactor(uint256)\", newReserveFactorMantissa));\n\n        return abi.decode(data, (uint));\n\n    }\n\n\n",
          "message": "Function 'ABep20Delegator._setReserveFactor' (ABep20Harness.sol#3332-3337) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 3362,
          "vulnerability_to_line": 3367,
          "vulnerability_code": "    function _reduceReserves(uint reduceAmount) external returns (uint) {\n\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"_reduceReserves(uint256)\", reduceAmount));\n\n        return abi.decode(data, (uint));\n\n    }\n\n\n",
          "message": "Function 'ABep20Delegator._reduceReserves' (ABep20Harness.sol#3362-3367) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 3373,
          "vulnerability_to_line": 3378,
          "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {\n\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"_setInterestRateModel(address)\", newInterestRateModel));\n\n        return abi.decode(data, (uint));\n\n    }\n\n\n",
          "message": "Function 'ABep20Delegator._setInterestRateModel' (ABep20Harness.sol#3373-3378) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 3352,
          "vulnerability_to_line": 3357,
          "vulnerability_code": "    function _addReserves(uint addAmount) external returns (uint) {\n\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"_addReserves(uint256)\", addAmount));\n\n        return abi.decode(data, (uint));\n\n    }\n\n\n",
          "message": "Function 'ABep20Delegator._addReserves' (ABep20Harness.sol#3352-3357) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 3025,
          "vulnerability_to_line": 3040,
          "vulnerability_code": "    function _setImplementation(address implementation_, bool allowResign, bytes memory becomeImplementationData) public {\n\n        require(msg.sender == admin, \"ABep20Delegator::_setImplementation: Caller must be admin\");\n\n\n\n        if (allowResign) {\n\n            delegateToImplementation(abi.encodeWithSignature(\"_resignImplementation()\"));\n\n        }\n\n\n\n        address oldImplementation = implementation;\n\n        implementation = implementation_;\n\n\n\n        delegateToImplementation(abi.encodeWithSignature(\"_becomeImplementation(bytes)\", becomeImplementationData));\n\n\n\n        emit NewImplementation(oldImplementation, implementation);\n\n    }\n\n\n",
          "message": "Function 'ABep20Delegator._setImplementation' (ABep20Harness.sol#3025-3040) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 3462,
          "vulnerability_to_line": 3474,
          "vulnerability_code": "    function _becomeImplementation(bytes memory data) public {\n\n        // Shh -- currently unused\n\n        data;\n\n\n\n        // Shh -- we don't ever want this hook to be marked pure\n\n        if (false) {\n\n            implementation = address(0);\n\n        }\n\n\n\n        require(msg.sender == admin, \"only the admin may call _becomeImplementation\");\n\n    }\n\n\n",
          "message": "Function 'ABep20Delegate._becomeImplementation' (ABep20Harness.sol#3462-3474) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 3477,
          "vulnerability_to_line": 3487,
          "vulnerability_code": "    function _resignImplementation() public {\n\n        // Shh -- we don't ever want this hook to be marked pure\n\n        if (false) {\n\n            implementation = address(0);\n\n        }\n\n\n\n        require(msg.sender == admin, \"only the admin may call _resignImplementation\");\n\n    }\n\n}\n\n\n",
          "message": "Function 'ABep20Delegate._resignImplementation' (ABep20Harness.sol#3477-3487) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 3516,
          "vulnerability_to_line": 3523,
          "vulnerability_code": "    function _becomeImplementation(bytes memory data) public {\n\n        require(msg.sender == admin, \"only the admin may initialize the implementation\");\n\n\n\n        (address daiJoinAddress_, address potAddress_) = abi.decode(data, (address, address));\n\n        return _becomeImplementation(daiJoinAddress_, potAddress_);\n\n    }\n\n\n",
          "message": "Function 'ADaiDelegate._becomeImplementation' (ABep20Harness.sol#3516-3523) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 3558,
          "vulnerability_to_line": 3580,
          "vulnerability_code": "    function _resignImplementation() public {\n\n        require(msg.sender == admin, \"only the admin may abandon the implementation\");\n\n\n\n        // Transfer all cash out of the DSR - note that this relies on self-transfer\n\n        DaiJoinLike daiJoin = DaiJoinLike(daiJoinAddress);\n\n        PotLike pot = PotLike(potAddress);\n\n        VatLike vat = VatLike(vatAddress);\n\n\n\n        // Accumulate interest\n\n        pot.drip();\n\n\n\n        // Calculate the total amount in the pot, and move it out\n\n        uint pie = pot.pie(address(this));\n\n        pot.exit(pie);\n\n\n\n        // Checks the actual balance of DAI in the vat after the pot exit\n\n        uint bal = vat.dai(address(this));\n\n\n\n        // Remove our whole balance\n\n        daiJoin.exit(address(this), bal / RAY);\n\n    }\n\n\n",
          "message": "Function 'ADaiDelegate._resignImplementation' (ABep20Harness.sol#3558-3580) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 3528,
          "vulnerability_to_line": 3555,
          "vulnerability_code": "    function _becomeImplementation(address daiJoinAddress_, address potAddress_) internal {\n\n        // Get dai and vat and sanity check the underlying\n\n        DaiJoinLike daiJoin = DaiJoinLike(daiJoinAddress_);\n\n        PotLike pot = PotLike(potAddress_);\n\n        GemLike dai = daiJoin.dai();\n\n        VatLike vat = daiJoin.vat();\n\n        require(address(dai) == underlying, \"DAI must be the same as underlying\");\n\n\n\n        // Remember the relevant addresses\n\n        daiJoinAddress = daiJoinAddress_;\n\n        potAddress = potAddress_;\n\n        vatAddress = address(vat);\n\n\n\n        // Approve moving our DAI into the vat through daiJoin\n\n        dai.approve(daiJoinAddress, uint(-1));\n\n\n\n        // Approve the pot to transfer our funds within the vat\n\n        vat.hope(potAddress);\n\n        vat.hope(daiJoinAddress);\n\n\n\n        // Accumulate DSR interest -- must do this in order to doTransferIn\n\n        pot.drip();\n\n\n\n        // Transfer all cash in (doTransferIn does this regardless of amount)\n\n        doTransferIn(address(this), 0);\n\n    }\n\n\n",
          "message": "Function 'ADaiDelegate._becomeImplementation' (ABep20Harness.sol#3528-3555) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 3672,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function pie(address) external view returns (uint);\n",
          "message": "Parameter '' of PotLike.pie (ABep20Harness.sol#3672) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 3674,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function join(uint) external;\n",
          "message": "Parameter '' of PotLike.join (ABep20Harness.sol#3674) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 3675,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function exit(uint) external;\n",
          "message": "Parameter '' of PotLike.exit (ABep20Harness.sol#3675) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 3679,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function approve(address, uint) external;\n",
          "message": "Parameter '' of GemLike.approve (ABep20Harness.sol#3679) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 3679,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function approve(address, uint) external;\n",
          "message": "Parameter '_scope_0' of GemLike.approve (ABep20Harness.sol#3679) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 3680,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function balanceOf(address) external view returns (uint);\n",
          "message": "Parameter '' of GemLike.balanceOf (ABep20Harness.sol#3680) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 3681,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function transferFrom(address, address, uint) external returns (bool);\n",
          "message": "Parameter '' of GemLike.transferFrom (ABep20Harness.sol#3681) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 3681,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function transferFrom(address, address, uint) external returns (bool);\n",
          "message": "Parameter '_scope_0' of GemLike.transferFrom (ABep20Harness.sol#3681) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 3681,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function transferFrom(address, address, uint) external returns (bool);\n",
          "message": "Parameter '_scope_1' of GemLike.transferFrom (ABep20Harness.sol#3681) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 3685,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function dai(address) external view returns (uint);\n",
          "message": "Parameter '' of VatLike.dai (ABep20Harness.sol#3685) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 3686,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function hope(address) external;\n",
          "message": "Parameter '' of VatLike.hope (ABep20Harness.sol#3686) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 3692,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function join(address, uint) external payable;\n",
          "message": "Parameter '' of DaiJoinLike.join (ABep20Harness.sol#3692) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 3692,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function join(address, uint) external payable;\n",
          "message": "Parameter '_scope_0' of DaiJoinLike.join (ABep20Harness.sol#3692) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 3693,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function exit(address, uint) external;\n",
          "message": "Parameter '' of DaiJoinLike.exit (ABep20Harness.sol#3693) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 3693,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function exit(address, uint) external;\n",
          "message": "Parameter '_scope_0' of DaiJoinLike.exit (ABep20Harness.sol#3693) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 3702,
          "vulnerability_to_line": 3704,
          "vulnerability_code": "    bool public constant isPriceOracle = true;\n\n\n",
          "message": "Constant 'PriceOracle.isPriceOracle' (ABep20Harness.sol#3702-3704) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 3801,
          "vulnerability_to_line": 3802,
          "vulnerability_code": "    bool public _mintGuardianPaused;\n",
          "message": "Variable 'ComptrollerV2Storage._mintGuardianPaused' (ABep20Harness.sol#3801-3802) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 3802,
          "vulnerability_to_line": 3803,
          "vulnerability_code": "    bool public _borrowGuardianPaused;\n",
          "message": "Variable 'ComptrollerV2Storage._borrowGuardianPaused' (ABep20Harness.sol#3802-3803) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 3915,
          "vulnerability_to_line": 3930,
          "vulnerability_code": "    function _setPendingImplementation(address newPendingImplementation) public returns (uint) {\n\n\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_IMPLEMENTATION_OWNER_CHECK);\n\n        }\n\n\n\n        address oldPendingImplementation = pendingComptrollerImplementation;\n\n\n\n        pendingComptrollerImplementation = newPendingImplementation;\n\n\n\n        emit NewPendingImplementation(oldPendingImplementation, pendingComptrollerImplementation);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Function 'Unitroller._setPendingImplementation' (ABep20Harness.sol#3915-3930) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 3935,
          "vulnerability_to_line": 3956,
          "vulnerability_code": "    function _acceptImplementation() public returns (uint) {\n\n        // Check caller is pendingImplementation and pendingImplementation \u2260 address(0)\n\n        if (msg.sender != pendingComptrollerImplementation || pendingComptrollerImplementation == address(0)) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_PENDING_IMPLEMENTATION_ADDRESS_CHECK);\n\n        }\n\n\n\n        // Save current values for inclusion in log\n\n        address oldImplementation = comptrollerImplementation;\n\n        address oldPendingImplementation = pendingComptrollerImplementation;\n\n\n\n        comptrollerImplementation = pendingComptrollerImplementation;\n\n\n\n        pendingComptrollerImplementation = address(0);\n\n\n\n        emit NewImplementation(oldImplementation, comptrollerImplementation);\n\n        emit NewPendingImplementation(oldPendingImplementation, pendingComptrollerImplementation);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n\n",
          "message": "Function 'Unitroller._acceptImplementation' (ABep20Harness.sol#3935-3956) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 3962,
          "vulnerability_to_line": 3980,
          "vulnerability_code": "    function _setPendingAdmin(address newPendingAdmin) public returns (uint) {\n\n        // Check caller = admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);\n\n        }\n\n\n\n        // Save current value, if any, for inclusion in log\n\n        address oldPendingAdmin = pendingAdmin;\n\n\n\n        // Store pendingAdmin with value newPendingAdmin\n\n        pendingAdmin = newPendingAdmin;\n\n\n\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\n\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Function 'Unitroller._setPendingAdmin' (ABep20Harness.sol#3962-3980) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 3985,
          "vulnerability_to_line": 4008,
          "vulnerability_code": "    function _acceptAdmin() public returns (uint) {\n\n        // Check caller is pendingAdmin and pendingAdmin \u2260 address(0)\n\n        if (msg.sender != pendingAdmin || msg.sender == address(0)) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);\n\n        }\n\n\n\n        // Save current values for inclusion in log\n\n        address oldAdmin = admin;\n\n        address oldPendingAdmin = pendingAdmin;\n\n\n\n        // Store admin with value pendingAdmin\n\n        admin = pendingAdmin;\n\n\n\n        // Clear the pending value\n\n        pendingAdmin = address(0);\n\n\n\n        emit NewAdmin(oldAdmin, admin);\n\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
          "message": "Function 'Unitroller._acceptAdmin' (ABep20Harness.sol#3985-4008) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 4251,
          "vulnerability_to_line": 4261,
          "vulnerability_code": "    function _delegate(address delegator, address delegatee) internal {\n\n        address currentDelegate = delegates[delegator];\n\n        uint96 delegatorBalance = balances[delegator];\n\n        delegates[delegator] = delegatee;\n\n\n\n        emit DelegateChanged(delegator, currentDelegate, delegatee);\n\n\n\n        _moveDelegates(currentDelegate, delegatee, delegatorBalance);\n\n    }\n\n\n",
          "message": "Function 'Atlantis._delegate' (ABep20Harness.sol#4251-4261) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 4261,
          "vulnerability_to_line": 4272,
          "vulnerability_code": "    function _transferTokens(address src, address dst, uint96 amount) internal {\n\n        require(src != address(0), \"Atlantis::_transferTokens: cannot transfer from the zero address\");\n\n        require(dst != address(0), \"Atlantis::_transferTokens: cannot transfer to the zero address\");\n\n\n\n        balances[src] = sub96(balances[src], amount, \"Atlantis::_transferTokens: transfer amount exceeds balance\");\n\n        balances[dst] = add96(balances[dst], amount, \"Atlantis::_transferTokens: transfer amount overflows\");\n\n        emit Transfer(src, dst, amount);\n\n\n\n        _moveDelegates(delegates[src], delegates[dst], amount);\n\n    }\n\n\n",
          "message": "Function 'Atlantis._transferTokens' (ABep20Harness.sol#4261-4272) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 4272,
          "vulnerability_to_line": 4290,
          "vulnerability_code": "    function _moveDelegates(address srcRep, address dstRep, uint96 amount) internal {\n\n        if (srcRep != dstRep && amount > 0) {\n\n            if (srcRep != address(0)) {\n\n                uint32 srcRepNum = numCheckpoints[srcRep];\n\n                uint96 srcRepOld = srcRepNum > 0 ? checkpoints[srcRep][srcRepNum - 1].votes : 0;\n\n                uint96 srcRepNew = sub96(srcRepOld, amount, \"Atlantis::_moveVotes: vote amount underflows\");\n\n                _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);\n\n            }\n\n\n\n            if (dstRep != address(0)) {\n\n                uint32 dstRepNum = numCheckpoints[dstRep];\n\n                uint96 dstRepOld = dstRepNum > 0 ? checkpoints[dstRep][dstRepNum - 1].votes : 0;\n\n                uint96 dstRepNew = add96(dstRepOld, amount, \"Atlantis::_moveVotes: vote amount overflows\");\n\n                _writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);\n\n            }\n\n        }\n\n    }\n\n\n",
          "message": "Function 'Atlantis._moveDelegates' (ABep20Harness.sol#4272-4290) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 4290,
          "vulnerability_to_line": 4303,
          "vulnerability_code": "    function _writeCheckpoint(address delegatee, uint32 nCheckpoints, uint96 oldVotes, uint96 newVotes) internal {\n\n      uint32 blockNumber = safe32(block.number, \"Atlantis::_writeCheckpoint: block number exceeds 32 bits\");\n\n\n\n      if (nCheckpoints > 0 && checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber) {\n\n          checkpoints[delegatee][nCheckpoints - 1].votes = newVotes;\n\n      } else {\n\n          checkpoints[delegatee][nCheckpoints] = Checkpoint(blockNumber, newVotes);\n\n          numCheckpoints[delegatee] = nCheckpoints + 1;\n\n      }\n\n\n\n      emit DelegateVotesChanged(delegatee, oldVotes, newVotes);\n\n    }\n\n\n",
          "message": "Function 'Atlantis._writeCheckpoint' (ABep20Harness.sol#4290-4303) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 4043,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint public constant totalSupply = 6500000e18; // 6500000 ATL\n",
          "message": "Constant 'Atlantis.totalSupply' (ABep20Harness.sol#4043) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 5154,
          "vulnerability_to_line": 5173,
          "vulnerability_code": "    function _setPriceOracle(PriceOracle newOracle) public returns (uint) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PRICE_ORACLE_OWNER_CHECK);\n\n        }\n\n\n\n        // Track the old oracle for the comptroller\n\n        PriceOracle oldOracle = oracle;\n\n\n\n        // Set comptroller's oracle to newOracle\n\n        oracle = newOracle;\n\n\n\n        // Emit NewPriceOracle(oldOracle, newOracle)\n\n        emit NewPriceOracle(oldOracle, newOracle);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
          "message": "Function 'Comptroller._setPriceOracle' (ABep20Harness.sol#5154-5173) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 5178,
          "vulnerability_to_line": 5190,
          "vulnerability_code": "    function _setCloseFactor(uint newCloseFactorMantissa) external returns (uint) {\n\n        // Check caller is admin\n\n    \trequire(msg.sender == admin, \"only admin can set close factor\");\n\n\n\n        uint oldCloseFactorMantissa = closeFactorMantissa;\n\n        closeFactorMantissa = newCloseFactorMantissa;\n\n        emit NewCloseFactor(oldCloseFactorMantissa, closeFactorMantissa);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
          "message": "Function 'Comptroller._setCloseFactor' (ABep20Harness.sol#5178-5190) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 5196,
          "vulnerability_to_line": 5232,
          "vulnerability_code": "    function _setCollateralFactor(AToken aToken, uint newCollateralFactorMantissa) external returns (uint) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COLLATERAL_FACTOR_OWNER_CHECK);\n\n        }\n\n\n\n        // Verify market is listed\n\n        Market storage market = markets[address(aToken)];\n\n        if (!market.isListed) {\n\n            return fail(Error.MARKET_NOT_LISTED, FailureInfo.SET_COLLATERAL_FACTOR_NO_EXISTS);\n\n        }\n\n\n\n        Exp memory newCollateralFactorExp = Exp({mantissa: newCollateralFactorMantissa});\n\n\n\n        // Check collateral factor <= 0.9\n\n        Exp memory highLimit = Exp({mantissa: collateralFactorMaxMantissa});\n\n        if (lessThanExp(highLimit, newCollateralFactorExp)) {\n\n            return fail(Error.INVALID_COLLATERAL_FACTOR, FailureInfo.SET_COLLATERAL_FACTOR_VALIDATION);\n\n        }\n\n\n\n        // If collateral factor != 0, fail if price == 0\n\n        if (newCollateralFactorMantissa != 0 && oracle.getUnderlyingPrice(aToken) == 0) {\n\n            return fail(Error.PRICE_ERROR, FailureInfo.SET_COLLATERAL_FACTOR_WITHOUT_PRICE);\n\n        }\n\n\n\n        // Set market's collateral factor to new collateral factor, remember old value\n\n        uint oldCollateralFactorMantissa = market.collateralFactorMantissa;\n\n        market.collateralFactorMantissa = newCollateralFactorMantissa;\n\n\n\n        // Emit event with asset, old collateral factor, and new collateral factor\n\n        emit NewCollateralFactor(aToken, oldCollateralFactorMantissa, newCollateralFactorMantissa);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
          "message": "Function 'Comptroller._setCollateralFactor' (ABep20Harness.sol#5196-5232) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 5237,
          "vulnerability_to_line": 5256,
          "vulnerability_code": "    function _setLiquidationIncentive(uint newLiquidationIncentiveMantissa) external returns (uint) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_LIQUIDATION_INCENTIVE_OWNER_CHECK);\n\n        }\n\n\n\n        // Save current value for use in log\n\n        uint oldLiquidationIncentiveMantissa = liquidationIncentiveMantissa;\n\n\n\n        // Set liquidation incentive to new incentive\n\n        liquidationIncentiveMantissa = newLiquidationIncentiveMantissa;\n\n\n\n        // Emit event with old incentive, new incentive\n\n        emit NewLiquidationIncentive(oldLiquidationIncentiveMantissa, newLiquidationIncentiveMantissa);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
          "message": "Function 'Comptroller._setLiquidationIncentive' (ABep20Harness.sol#5237-5256) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 5261,
          "vulnerability_to_line": 5282,
          "vulnerability_code": "    function _supportMarket(AToken aToken) external returns (uint) {\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SUPPORT_MARKET_OWNER_CHECK);\n\n        }\n\n\n\n        if (markets[address(aToken)].isListed) {\n\n            return fail(Error.MARKET_ALREADY_LISTED, FailureInfo.SUPPORT_MARKET_EXISTS);\n\n        }\n\n\n\n        aToken.isAToken(); // Sanity check to make sure its really a AToken\n\n\n\n        // Note that isAtled is not in active use anymore\n\n        markets[address(aToken)] = Market({isListed: true, isAtled: false, collateralFactorMantissa: 0});\n\n\n\n        _addMarketInternal(address(aToken));\n\n\n\n        emit MarketListed(aToken);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Function 'Comptroller._supportMarket' (ABep20Harness.sol#5261-5282) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 5282,
          "vulnerability_to_line": 5291,
          "vulnerability_code": "    function _addMarketInternal(address aToken) internal {\n\n        for (uint i = 0; i < allMarkets.length; i ++) {\n\n            require(allMarkets[i] != AToken(aToken), \"market already added\");\n\n        }\n\n        allMarkets.push(AToken(aToken));\n\n    }\n\n\n\n\n\n    /**\n",
          "message": "Function 'Comptroller._addMarketInternal' (ABep20Harness.sol#5282-5291) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 5296,
          "vulnerability_to_line": 5311,
          "vulnerability_code": "    function _setMarketBorrowCaps(AToken[] calldata aTokens, uint[] calldata newBorrowCaps) external {\n\n    \trequire(msg.sender == admin || msg.sender == borrowCapGuardian, \"only admin or borrow cap guardian can set borrow caps\"); \n\n\n\n        uint numMarkets = aTokens.length;\n\n        uint numBorrowCaps = newBorrowCaps.length;\n\n\n\n        require(numMarkets != 0 && numMarkets == numBorrowCaps, \"invalid input\");\n\n\n\n        for(uint i = 0; i < numMarkets; i++) {\n\n            borrowCaps[address(aTokens[i])] = newBorrowCaps[i];\n\n            emit NewBorrowCap(aTokens[i], newBorrowCaps[i]);\n\n        }\n\n    }\n\n\n\n    /**\n",
          "message": "Function 'Comptroller._setMarketBorrowCaps' (ABep20Harness.sol#5296-5311) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 5314,
          "vulnerability_to_line": 5328,
          "vulnerability_code": "    function _setBorrowCapGuardian(address newBorrowCapGuardian) external {\n\n        require(msg.sender == admin, \"only admin can set borrow cap guardian\");\n\n\n\n        // Save current value for inclusion in log\n\n        address oldBorrowCapGuardian = borrowCapGuardian;\n\n\n\n        // Store borrowCapGuardian with value newBorrowCapGuardian\n\n        borrowCapGuardian = newBorrowCapGuardian;\n\n\n\n        // Emit NewBorrowCapGuardian(OldBorrowCapGuardian, NewBorrowCapGuardian)\n\n        emit NewBorrowCapGuardian(oldBorrowCapGuardian, newBorrowCapGuardian);\n\n    }\n\n\n\n    /**\n",
          "message": "Function 'Comptroller._setBorrowCapGuardian' (ABep20Harness.sol#5314-5328) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 5332,
          "vulnerability_to_line": 5349,
          "vulnerability_code": "    function _setPauseGuardian(address newPauseGuardian) public returns (uint) {\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PAUSE_GUARDIAN_OWNER_CHECK);\n\n        }\n\n\n\n        // Save current value for inclusion in log\n\n        address oldPauseGuardian = pauseGuardian;\n\n\n\n        // Store pauseGuardian with value newPauseGuardian\n\n        pauseGuardian = newPauseGuardian;\n\n\n\n        // Emit NewPauseGuardian(OldPauseGuardian, NewPauseGuardian)\n\n        emit NewPauseGuardian(oldPauseGuardian, pauseGuardian);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Function 'Comptroller._setPauseGuardian' (ABep20Harness.sol#5332-5349) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 5349,
          "vulnerability_to_line": 5359,
          "vulnerability_code": "    function _setMintPaused(AToken aToken, bool state) public returns (bool) {\n\n        require(markets[address(aToken)].isListed, \"cannot pause a market that is not listed\");\n\n        require(msg.sender == pauseGuardian || msg.sender == admin, \"only pause guardian and admin can pause\");\n\n        require(msg.sender == admin || state == true, \"only admin can unpause\");\n\n\n\n        mintGuardianPaused[address(aToken)] = state;\n\n        emit ActionPaused(aToken, \"Mint\", state);\n\n        return state;\n\n    }\n\n\n",
          "message": "Function 'Comptroller._setMintPaused' (ABep20Harness.sol#5349-5359) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 5359,
          "vulnerability_to_line": 5369,
          "vulnerability_code": "    function _setBorrowPaused(AToken aToken, bool state) public returns (bool) {\n\n        require(markets[address(aToken)].isListed, \"cannot pause a market that is not listed\");\n\n        require(msg.sender == pauseGuardian || msg.sender == admin, \"only pause guardian and admin can pause\");\n\n        require(msg.sender == admin || state == true, \"only admin can unpause\");\n\n\n\n        borrowGuardianPaused[address(aToken)] = state;\n\n        emit ActionPaused(aToken, \"Borrow\", state);\n\n        return state;\n\n    }\n\n\n",
          "message": "Function 'Comptroller._setBorrowPaused' (ABep20Harness.sol#5359-5369) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 5369,
          "vulnerability_to_line": 5378,
          "vulnerability_code": "    function _setTransferPaused(bool state) public returns (bool) {\n\n        require(msg.sender == pauseGuardian || msg.sender == admin, \"only pause guardian and admin can pause\");\n\n        require(msg.sender == admin || state == true, \"only admin can unpause\");\n\n\n\n        transferGuardianPaused = state;\n\n        emit ActionPaused(\"Transfer\", state);\n\n        return state;\n\n    }\n\n\n",
          "message": "Function 'Comptroller._setTransferPaused' (ABep20Harness.sol#5369-5378) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 5378,
          "vulnerability_to_line": 5387,
          "vulnerability_code": "    function _setSeizePaused(bool state) public returns (bool) {\n\n        require(msg.sender == pauseGuardian || msg.sender == admin, \"only pause guardian and admin can pause\");\n\n        require(msg.sender == admin || state == true, \"only admin can unpause\");\n\n\n\n        seizeGuardianPaused = state;\n\n        emit ActionPaused(\"Seize\", state);\n\n        return state;\n\n    }\n\n\n",
          "message": "Function 'Comptroller._setSeizePaused' (ABep20Harness.sol#5378-5387) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 5387,
          "vulnerability_to_line": 5393,
          "vulnerability_code": "    function _become(Unitroller unitroller) public {\n\n        require(msg.sender == unitroller.admin(), \"only unitroller admin can change brains\");\n\n        require(unitroller._acceptImplementation() == 0, \"change not authorized\");\n\n    }\n\n\n\n    /**\n",
          "message": "Function 'Comptroller._become' (ABep20Harness.sol#5387-5393) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 5629,
          "vulnerability_to_line": 5637,
          "vulnerability_code": "    function _grantAtlantis(address recipient, uint amount) public {\n\n        require(adminOrInitializing(), \"only admin can grant atlantis\");\n\n        uint amountLeft = grantAtlantisInternal(recipient, amount);\n\n        require(amountLeft == 0, \"insufficient atlantis for grant\");\n\n        emit AtlantisGranted(recipient, amount);\n\n    }\n\n\n\n    /**\n",
          "message": "Function 'Comptroller._grantAtlantis' (ABep20Harness.sol#5629-5637) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 5641,
          "vulnerability_to_line": 5647,
          "vulnerability_code": "    function _setAtlantisSpeed(AToken aToken, uint atlantisSpeed) public {\n\n        require(adminOrInitializing(), \"only admin can set atlantis speed\");\n\n        setAtlantisSpeedInternal(aToken, atlantisSpeed);\n\n    }\n\n\n\n    /**\n",
          "message": "Function 'Comptroller._setAtlantisSpeed' (ABep20Harness.sol#5641-5647) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 5651,
          "vulnerability_to_line": 5668,
          "vulnerability_code": "    function _setContributorAtlantisSpeed(address contributor, uint atlantisSpeed) public {\n\n        require(adminOrInitializing(), \"only admin can set atlantis speed\");\n\n\n\n        // note that Atlantis speed could be set to 0 to halt liquidity rewards for a contributor\n\n        updateContributorRewards(contributor);\n\n        if (atlantisSpeed == 0) {\n\n            // release storage\n\n            delete lastContributorBlock[contributor];\n\n        } else {\n\n            lastContributorBlock[contributor] = getBlockNumber();\n\n        }\n\n        atlantisContributorSpeeds[contributor] = atlantisSpeed;\n\n\n\n        emit ContributorAtlantisSpeedUpdated(contributor, atlantisSpeed);\n\n    }\n\n\n\n    /**\n",
          "message": "Function 'Comptroller._setContributorAtlantisSpeed' (ABep20Harness.sol#5651-5668) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 5672,
          "vulnerability_to_line": 5681,
          "vulnerability_code": "    function _setAtlantisVaultRate(address vault_, uint atlantisVaultRate_) public {\n\n        require(msg.sender == admin, \"only admin can set Atlantis vault rate\");\n\n\n\n        uint oldAtlantisVaultRate = atlantisVaultRate[vault_];\n\n        atlantisVaultRate[vault_] = atlantisVaultRate_;\n\n        emit NewAtlantisVaultRate(vault_, oldAtlantisVaultRate, atlantisVaultRate[vault_]);\n\n    }\n\n\n\n    /**\n",
          "message": "Function 'Comptroller._setAtlantisVaultRate' (ABep20Harness.sol#5672-5681) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 5686,
          "vulnerability_to_line": 5704,
          "vulnerability_code": "    function _setVaultInfo(address vault_, uint256 releaseStartBlock_, uint256 minReleaseAmount_) public {\n\n        require(msg.sender == admin, \"only admin can set vault info\");\n\n        require(releaseStartBlock_ > 0, \"Release start block should be greater than 0\");\n\n\n\n        if (vaultInfo[vault_].exists == false){\n\n            vaults.push(vault_);\n\n        }\n\n\n\n        vaultInfo[vault_] = VaultInfo({\n\n            releaseStartBlock: releaseStartBlock_,\n\n            minReleaseAmount: minReleaseAmount_,\n\n            exists: true\n\n        });\n\n\n\n        emit NewVaultInfo(vault_, releaseStartBlock_, minReleaseAmount_);\n\n    }\n\n\n\n    /**\n",
          "message": "Function 'Comptroller._setVaultInfo' (ABep20Harness.sol#5686-5704) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 5714,
          "vulnerability_to_line": 5756,
          "vulnerability_code": "    function _releaseToVaultInternal(address vault_) internal {\n\n        VaultInfo storage vaultInfo = vaultInfo[vault_];\n\n\n\n        if (atlantisVaultRate[vault_] == 0) {\n\n            return;\n\n        }\n\n        \n\n        if(vaultInfo.releaseStartBlock == 0 || getBlockNumber() < vaultInfo.releaseStartBlock) {\n\n            return;\n\n        }\n\n\n\n        Atlantis atlantis = Atlantis(getAtlantisAddress());\n\n        uint256 atlantisBalance = atlantis.balanceOf(address(this));\n\n        if(atlantisBalance == 0) {\n\n            return;\n\n        }\n\n\n\n        uint256 actualAmount;\n\n        uint256 deltaBlocks = sub_(getBlockNumber(), vaultInfo.releaseStartBlock);\n\n        // releaseAmount = atlantisVaultRate * deltaBlocks\n\n        uint256 _releaseAmount = mul_(atlantisVaultRate[vault_], deltaBlocks);\n\n\n\n        if (_releaseAmount < vaultInfo.minReleaseAmount) {\n\n            return;\n\n        }\n\n\n\n        if (atlantisBalance >= _releaseAmount) {\n\n            actualAmount = _releaseAmount;\n\n        } else {\n\n            actualAmount = atlantisBalance;\n\n        }\n\n\n\n        vaultInfo.releaseStartBlock = getBlockNumber();\n\n\n\n        address atlantisStoreAddress = IVault(vault_).getAtlantisStore();\n\n        atlantis.transfer(atlantisStoreAddress, actualAmount);\n\n        emit DistributedVaultAtlantis(vault_, actualAmount);\n\n\n\n        IVault(vault_).updatePendingRewards();\n\n    }\n\n\n\n    /**\n",
          "message": "Function 'Comptroller._releaseToVaultInternal' (ABep20Harness.sol#5714-5756) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 4407,
          "vulnerability_to_line": 4409,
          "vulnerability_code": "    uint224 public constant atlantisInitialIndex = 1e36;\n\n\n",
          "message": "Constant 'Comptroller.atlantisInitialIndex' (ABep20Harness.sol#4407-4409) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 4410,
          "vulnerability_to_line": 4411,
          "vulnerability_code": "    uint internal constant closeFactorMinMantissa = 0.05e18; // 0.05\n",
          "message": "Constant 'Comptroller.closeFactorMinMantissa' (ABep20Harness.sol#4410-4411) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 4413,
          "vulnerability_to_line": 4415,
          "vulnerability_code": "    uint internal constant closeFactorMaxMantissa = 0.9e18; // 0.9\n\n\n",
          "message": "Constant 'Comptroller.closeFactorMaxMantissa' (ABep20Harness.sol#4413-4415) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 4416,
          "vulnerability_to_line": 4418,
          "vulnerability_code": "    uint internal constant collateralFactorMaxMantissa = 0.9e18; // 0.9\n\n\n",
          "message": "Constant 'Comptroller.collateralFactorMaxMantissa' (ABep20Harness.sol#4416-4418) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 5915,
          "vulnerability_to_line": 5916,
          "vulnerability_code": "    function harnessSetAccrualBlockNumber(uint _accrualblockNumber) public {\n",
          "message": "Parameter '_accrualblockNumber' of ABep20Harness.harnessSetAccrualBlockNumber (ABep20Harness.sol#5915-5916) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 5954,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function harnessSetFailTransferToAddress(address _to, bool _fail) public {\n",
          "message": "Parameter '_to' of ABep20Harness.harnessSetFailTransferToAddress (ABep20Harness.sol#5954) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 5954,
          "vulnerability_to_line": 5955,
          "vulnerability_code": "    function harnessSetFailTransferToAddress(address _to, bool _fail) public {\n",
          "message": "Parameter '_fail' of ABep20Harness.harnessSetFailTransferToAddress (ABep20Harness.sol#5954-5955) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 6146,
          "vulnerability_to_line": 6147,
          "vulnerability_code": "    function harnessSetAccrualBlockNumber(uint _accrualblockNumber) public {\n",
          "message": "Parameter '_accrualblockNumber' of ABep20DelegateHarness.harnessSetAccrualBlockNumber (ABep20Harness.sol#6146-6147) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 6177,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function harnessSetFailTransferToAddress(address _to, bool _fail) public {\n",
          "message": "Parameter '_to' of ABep20DelegateHarness.harnessSetFailTransferToAddress (ABep20Harness.sol#6177) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 6177,
          "vulnerability_to_line": 6178,
          "vulnerability_code": "    function harnessSetFailTransferToAddress(address _to, bool _fail) public {\n",
          "message": "Parameter '_fail' of ABep20DelegateHarness.harnessSetFailTransferToAddress (ABep20Harness.sol#6177-6178) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 6278,
          "vulnerability_to_line": 6279,
          "vulnerability_code": "    function harnessSetAccrualBlockNumber(uint _accrualblockNumber) public {\n",
          "message": "Parameter '_accrualblockNumber' of ADaiDelegateHarness.harnessSetAccrualBlockNumber (ABep20Harness.sol#6278-6279) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 6326,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function pie(address) external view returns (uint) { return 0; }\n",
          "message": "Parameter '' of ADaiDelegateMakerHarness.pie (ABep20Harness.sol#6326) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 6332,
          "vulnerability_to_line": 6334,
          "vulnerability_code": "    function join(uint) external {}\n\n\n",
          "message": "Parameter '' of ADaiDelegateMakerHarness.join (ABep20Harness.sol#6332-6334) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 6335,
          "vulnerability_to_line": 6337,
          "vulnerability_code": "    function exit(uint) external {}\n\n\n",
          "message": "Parameter '' of ADaiDelegateMakerHarness.exit (ABep20Harness.sol#6335-6337) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 6340,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function dai(address) external view returns (uint) { return 0; }\n",
          "message": "Parameter '' of ADaiDelegateMakerHarness.dai (ABep20Harness.sol#6340) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 6343,
          "vulnerability_to_line": 6345,
          "vulnerability_code": "    function hope(address) external {}\n\n\n",
          "message": "Parameter '' of ADaiDelegateMakerHarness.hope (ABep20Harness.sol#6343-6345) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 6350,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function approve(address, uint) external {}\n",
          "message": "Parameter '' of ADaiDelegateMakerHarness.approve (ABep20Harness.sol#6350) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 6350,
          "vulnerability_to_line": 6351,
          "vulnerability_code": "    function approve(address, uint) external {}\n",
          "message": "Parameter '_scope_0' of ADaiDelegateMakerHarness.approve (ABep20Harness.sol#6350-6351) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 6370,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function join(address, uint) external payable {}\n",
          "message": "Parameter '' of ADaiDelegateMakerHarness.join (ABep20Harness.sol#6370) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 6370,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function join(address, uint) external payable {}\n",
          "message": "Parameter '_scope_0' of ADaiDelegateMakerHarness.join (ABep20Harness.sol#6370) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 6373,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function exit(address, uint) external {}\n",
          "message": "Parameter '' of ADaiDelegateMakerHarness.exit (ABep20Harness.sol#6373) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 6373,
          "vulnerability_to_line": 6374,
          "vulnerability_code": "    function exit(address, uint) external {}\n",
          "message": "Parameter '_scope_0' of ADaiDelegateMakerHarness.exit (ABep20Harness.sol#6373-6374) is not in mixedCase\n"
        },
        {
          "name": "unused-state",
          "vulnerability_from_line": 810,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint constant halfExpScale = expScale/2;\n",
          "message": "ExponentialNoError.halfExpScale (ABep20Harness.sol#810) is never used in ComptrollerScenario\nExponentialNoError.mantissaOne (ABep20Harness.sol#811) is never used in ComptrollerScenario\nComptroller.closeFactorMinMantissa (ABep20Harness.sol#4410-4411) is never used in ComptrollerScenario\nComptroller.closeFactorMaxMantissa (ABep20Harness.sol#4413-4415) is never used in ComptrollerScenario\n"
        },
        {
          "name": "unused-state",
          "vulnerability_from_line": 197,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bool internal _notEntered;\n",
          "message": "ATokenStorage._notEntered (ABep20Harness.sol#197) is never used in ABep20DelegatorScenario\nATokenStorage.borrowRateMaxMantissa (ABep20Harness.sol#218) is never used in ABep20DelegatorScenario\nATokenStorage.reserveFactorMaxMantissa (ABep20Harness.sol#223) is never used in ABep20DelegatorScenario\nATokenStorage.initialExchangeRateMantissa (ABep20Harness.sol#248) is never used in ABep20DelegatorScenario\nATokenStorage.accountTokens (ABep20Harness.sol#283) is never used in ABep20DelegatorScenario\nATokenStorage.transferAllowances (ABep20Harness.sol#288) is never used in ABep20DelegatorScenario\nATokenStorage.accountBorrows (ABep20Harness.sol#303) is never used in ABep20DelegatorScenario\n"
        }
      ]
    },
    "smartcheck": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 5786,
          "vulnerability_to_line": null,
          "vulnerability_code": "        return 0x1fD991fb6c3102873ba68a4e6e6a87B3a5c10271;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 6261,
          "vulnerability_to_line": null,
          "vulnerability_code": "      admin = address(1); // make a change to test effect\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 3468,
          "vulnerability_to_line": null,
          "vulnerability_code": "            implementation = address(0);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 3480,
          "vulnerability_to_line": null,
          "vulnerability_code": "            implementation = address(0);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 3947,
          "vulnerability_to_line": null,
          "vulnerability_code": "        pendingComptrollerImplementation = address(0);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 3999,
          "vulnerability_to_line": null,
          "vulnerability_code": "        pendingAdmin = address(0);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ARRAY_LENGTH_MANIPULATION",
          "vulnerability_from_line": 4547,
          "vulnerability_to_line": null,
          "vulnerability_code": "        storedList.length--;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ERC20_APPROVE",
          "vulnerability_from_line": 1400,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function approve(address spender, uint256 amount) external returns (bool) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 5063,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < assets.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 5283,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < allMarkets.length; i ++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 5582,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < aTokens.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 5588,
          "vulnerability_to_line": null,
          "vulnerability_code": "                for (uint j = 0; j < holders.length; j++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 5594,
          "vulnerability_to_line": null,
          "vulnerability_code": "                for (uint j = 0; j < holders.length; j++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 5599,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint j = 0; j < holders.length; j++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 5707,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < vaults.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 5835,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < allMarkets_.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 5844,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < allMarkets_.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 5854,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < allMarkets_.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 4454,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < len; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 4534,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < len; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 5063,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < assets.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 5283,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < allMarkets.length; i ++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 5304,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for(uint i = 0; i < numMarkets; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 5582,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < aTokens.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 5588,
          "vulnerability_to_line": null,
          "vulnerability_code": "                for (uint j = 0; j < holders.length; j++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 5594,
          "vulnerability_to_line": null,
          "vulnerability_code": "                for (uint j = 0; j < holders.length; j++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 5599,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint j = 0; j < holders.length; j++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 5707,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < vaults.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 5835,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < allMarkets_.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 5844,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < allMarkets_.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 5854,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < allMarkets_.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 4237,
          "vulnerability_to_line": null,
          "vulnerability_code": "        while (upper > lower) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_LOCKED_MONEY",
          "vulnerability_from_line": 312,
          "vulnerability_to_line": null,
          "vulnerability_code": "contract ATokenInterface is ATokenStorage {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_LOCKED_MONEY",
          "vulnerability_from_line": 2935,
          "vulnerability_to_line": null,
          "vulnerability_code": "contract ABep20Immutable is ABep20 {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_LOCKED_MONEY",
          "vulnerability_from_line": 2975,
          "vulnerability_to_line": null,
          "vulnerability_code": "contract ABep20Delegator is ATokenInterface, ABep20Interface, ADelegatorInterface {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_LOCKED_MONEY",
          "vulnerability_from_line": 3887,
          "vulnerability_to_line": null,
          "vulnerability_code": "contract Unitroller is UnitrollerAdminStorage, ComptrollerErrorReporter {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_LOCKED_MONEY",
          "vulnerability_from_line": 5870,
          "vulnerability_to_line": null,
          "vulnerability_code": "contract ABep20Harness is ABep20Immutable {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_LOCKED_MONEY",
          "vulnerability_from_line": 6015,
          "vulnerability_to_line": null,
          "vulnerability_code": "contract ABep20Scenario is ABep20Immutable {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_LOCKED_MONEY",
          "vulnerability_from_line": 6048,
          "vulnerability_to_line": null,
          "vulnerability_code": "contract CEvil is ABep20Scenario {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_LOCKED_MONEY",
          "vulnerability_from_line": 6072,
          "vulnerability_to_line": null,
          "vulnerability_code": "contract ABep20DelegatorScenario is ABep20Delegator {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_LOCKED_MONEY",
          "vulnerability_from_line": 6104,
          "vulnerability_to_line": null,
          "vulnerability_code": "contract ABep20DelegateHarness is ABep20Delegate {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_LOCKED_MONEY",
          "vulnerability_from_line": 6319,
          "vulnerability_to_line": null,
          "vulnerability_code": "contract ADaiDelegateMakerHarness is PotLike, VatLike, GemLike, DaiJoinLike {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 83,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 116,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 189,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 500,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 710,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 798,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 996,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 1180,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 1245,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 2705,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 2928,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 2968,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 3445,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 3489,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 3698,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 3715,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 3879,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 4029,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 4333,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 5792,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 5864,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_REVERT_REQUIRE",
          "vulnerability_from_line": 4657,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (redeemTokens == 0 && redeemAmount > 0) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 4324,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getChainId() internal pure returns (uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 72,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint repayAmount) external view returns (uint, uint);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 413,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 733,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function mulUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 750,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function divUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 761,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function subUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 772,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function addUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 785,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function addThenSubUInt(uint a, uint b, uint c) internal pure returns (MathError, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 1013,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getExp(uint num, uint denom) pure internal returns (MathError, Exp memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 1030,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function addExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 1039,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function subExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 1048,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function mulScalar(Exp memory a, uint scalar) pure internal returns (MathError, Exp memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 1060,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function mulScalarTruncate(Exp memory a, uint scalar) pure internal returns (MathError, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 1072,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function mulScalarTruncateAddUInt(Exp memory a, uint scalar, uint addend) pure internal returns (MathError, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 1084,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function divScalar(Exp memory a, uint scalar) pure internal returns (MathError, Exp memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 1096,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function divScalarByExp(uint scalar, Exp memory divisor) pure internal returns (MathError, Exp memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 1116,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function divScalarByExpTruncate(uint scalar, Exp memory divisor) pure internal returns (MathError, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 1128,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function mulExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 1153,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function mulExp(uint a, uint b) pure internal returns (MathError, Exp memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 1160,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function mulExp3(Exp memory a, Exp memory b, Exp memory c) pure internal returns (MathError, Exp memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 1173,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function divExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 1445,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 1524,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 1581,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function exchangeRateStoredInternal() internal view returns (MathError, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 1712,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function mintInternal(uint mintAmount) internal nonReentrant returns (uint, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 1739,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function mintFresh(address minter, uint mintAmount) internal returns (uint, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 5005,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getAccountLiquidity(address account) public view returns (uint, uint, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 5017,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getAccountLiquidityInternal(address account) internal view returns (Error, uint, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 5035,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint borrowAmount) public view returns (uint, uint, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 5056,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint borrowAmount) internal view returns (Error, uint, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 5118,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function liquidateCalculateSeizeTokens(address aTokenBorrowed, address aTokenCollateral, uint actualRepayAmount) external view returns (uint, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 6114,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function exchangeRateStoredInternal() internal view returns (MathError, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UNCHECKED_CALL",
          "vulnerability_from_line": 4014,
          "vulnerability_to_line": null,
          "vulnerability_code": "        (bool success, ) = comptrollerImplementation.delegatecall(msg.data);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 2864,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 4016,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 4326,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly { chainId := chainid() }\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 428,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1856,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 2894,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function doTransferOut(address payable to, uint amount) internal {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 2947,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor(address underlying_,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 2989,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor(address underlying_,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 3643,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function doTransferOut(address payable to, uint amount) internal {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 5877,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor(address underlying_,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 6016,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor(address underlying_,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 6049,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor(address underlying_,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 6073,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor(address underlying_,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 6121,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function doTransferOut(address payable to, uint amount) internal {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 428,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 808,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint constant expScale = 1e18;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 809,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint constant doubleScale = 1e36;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 810,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint constant halfExpScale = expScale/2;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 811,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint constant mantissaOne = expScale;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1856,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1856,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1856,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1856,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1857,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1859,
          "vulnerability_to_line": null,
          "vulnerability_code": "        RedeemLocalVars memory vars;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1862,
          "vulnerability_to_line": null,
          "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1862,
          "vulnerability_to_line": null,
          "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1862,
          "vulnerability_to_line": null,
          "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1862,
          "vulnerability_to_line": null,
          "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1863,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (vars.mathErr != MathError.NO_ERROR) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1863,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (vars.mathErr != MathError.NO_ERROR) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1864,
          "vulnerability_to_line": null,
          "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1864,
          "vulnerability_to_line": null,
          "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1864,
          "vulnerability_to_line": null,
          "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1864,
          "vulnerability_to_line": null,
          "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1864,
          "vulnerability_to_line": null,
          "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 2894,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function doTransferOut(address payable to, uint amount) internal {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 2894,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function doTransferOut(address payable to, uint amount) internal {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 2895,
          "vulnerability_to_line": null,
          "vulnerability_code": "        EIP20NonStandardInterface token = EIP20NonStandardInterface(underlying);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 2896,
          "vulnerability_to_line": null,
          "vulnerability_code": "        token.transfer(to, amount);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 2896,
          "vulnerability_to_line": null,
          "vulnerability_code": "        token.transfer(to, amount);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 2898,
          "vulnerability_to_line": null,
          "vulnerability_code": "        bool success;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 2900,
          "vulnerability_to_line": null,
          "vulnerability_code": "            switch returndatasize()\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 2900,
          "vulnerability_to_line": null,
          "vulnerability_code": "            switch returndatasize()\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 2902,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    success := not(0)          // set success to true\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 2902,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    success := not(0)          // set success to true\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 2959,
          "vulnerability_to_line": null,
          "vulnerability_code": "        initialize(underlying_, comptroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 2959,
          "vulnerability_to_line": null,
          "vulnerability_code": "        initialize(underlying_, comptroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 2959,
          "vulnerability_to_line": null,
          "vulnerability_code": "        initialize(underlying_, comptroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 2959,
          "vulnerability_to_line": null,
          "vulnerability_code": "        initialize(underlying_, comptroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 2962,
          "vulnerability_to_line": null,
          "vulnerability_code": "        admin = admin_;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 2996,
          "vulnerability_to_line": null,
          "vulnerability_code": "                address payable admin_,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 2997,
          "vulnerability_to_line": null,
          "vulnerability_code": "                address implementation_,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 2998,
          "vulnerability_to_line": null,
          "vulnerability_code": "                bytes memory becomeImplementationData) public {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 3000,
          "vulnerability_to_line": null,
          "vulnerability_code": "        admin = msg.sender;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 3000,
          "vulnerability_to_line": null,
          "vulnerability_code": "        admin = msg.sender;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 3003,
          "vulnerability_to_line": null,
          "vulnerability_code": "        delegateTo(implementation_, abi.encodeWithSignature(\"initialize(address,address,address,uint256,string,string,uint8)\",\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 3003,
          "vulnerability_to_line": null,
          "vulnerability_code": "        delegateTo(implementation_, abi.encodeWithSignature(\"initialize(address,address,address,uint256,string,string,uint8)\",\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 3003,
          "vulnerability_to_line": null,
          "vulnerability_code": "        delegateTo(implementation_, abi.encodeWithSignature(\"initialize(address,address,address,uint256,string,string,uint8)\",\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 3005,
          "vulnerability_to_line": null,
          "vulnerability_code": "                                                            comptroller_,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 3007,
          "vulnerability_to_line": null,
          "vulnerability_code": "                                                            initialExchangeRateMantissa_,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 3009,
          "vulnerability_to_line": null,
          "vulnerability_code": "                                                            symbol_,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 3013,
          "vulnerability_to_line": null,
          "vulnerability_code": "        _setImplementation(implementation_, false, becomeImplementationData);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 3013,
          "vulnerability_to_line": null,
          "vulnerability_code": "        _setImplementation(implementation_, false, becomeImplementationData);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 3016,
          "vulnerability_to_line": null,
          "vulnerability_code": "        admin = admin_;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 3643,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function doTransferOut(address payable to, uint amount) internal {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 3643,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function doTransferOut(address payable to, uint amount) internal {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 3644,
          "vulnerability_to_line": null,
          "vulnerability_code": "        DaiJoinLike daiJoin = DaiJoinLike(daiJoinAddress);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 3645,
          "vulnerability_to_line": null,
          "vulnerability_code": "        PotLike pot = PotLike(potAddress);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 3649,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint pie = add(mul(amount, RAY) / pot.chi(), 1);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 3650,
          "vulnerability_to_line": null,
          "vulnerability_code": "        pot.exit(pie);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 3652,
          "vulnerability_to_line": null,
          "vulnerability_code": "        daiJoin.exit(to, amount);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 3652,
          "vulnerability_to_line": null,
          "vulnerability_code": "        daiJoin.exit(to, amount);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 5871,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint blockNumber = 100000;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 5872,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint harnessExchangeRate;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 5873,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bool harnessExchangeRateStored;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 5884,
          "vulnerability_to_line": null,
          "vulnerability_code": "                address payable admin_)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 5885,
          "vulnerability_to_line": null,
          "vulnerability_code": "    ABep20Immutable(\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 5888,
          "vulnerability_to_line": null,
          "vulnerability_code": "    interestRateModel_,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 5890,
          "vulnerability_to_line": null,
          "vulnerability_code": "    name_,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 5892,
          "vulnerability_to_line": null,
          "vulnerability_code": "    decimals_,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 6023,
          "vulnerability_to_line": null,
          "vulnerability_code": "                address payable admin_)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 6024,
          "vulnerability_to_line": null,
          "vulnerability_code": "    ABep20Immutable(\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 6027,
          "vulnerability_to_line": null,
          "vulnerability_code": "    interestRateModel_,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 6029,
          "vulnerability_to_line": null,
          "vulnerability_code": "    name_,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 6031,
          "vulnerability_to_line": null,
          "vulnerability_code": "    decimals_,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 6056,
          "vulnerability_to_line": null,
          "vulnerability_code": "                address payable admin_)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 6057,
          "vulnerability_to_line": null,
          "vulnerability_code": "    ABep20Scenario(\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 6060,
          "vulnerability_to_line": null,
          "vulnerability_code": "    interestRateModel_,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 6062,
          "vulnerability_to_line": null,
          "vulnerability_code": "    name_,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 6064,
          "vulnerability_to_line": null,
          "vulnerability_code": "    decimals_,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 6080,
          "vulnerability_to_line": null,
          "vulnerability_code": "                address payable admin_,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 6081,
          "vulnerability_to_line": null,
          "vulnerability_code": "                address implementation_,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 6082,
          "vulnerability_to_line": null,
          "vulnerability_code": "                bytes memory becomeImplementationData)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 6083,
          "vulnerability_to_line": null,
          "vulnerability_code": "    ABep20Delegator(\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 6085,
          "vulnerability_to_line": null,
          "vulnerability_code": "    comptroller_,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 6087,
          "vulnerability_to_line": null,
          "vulnerability_code": "    initialExchangeRateMantissa_,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 6089,
          "vulnerability_to_line": null,
          "vulnerability_code": "    symbol_,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 6091,
          "vulnerability_to_line": null,
          "vulnerability_code": "    admin_,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 6108,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint blockNumber = 100000;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 6109,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint harnessExchangeRate;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 6110,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bool harnessExchangeRateStored;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 6121,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function doTransferOut(address payable to, uint amount) internal {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 6121,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function doTransferOut(address payable to, uint amount) internal {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 6122,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(failTransferToAddresses[to] == false, \"TOKEN_TRANSFER_OUT_FAILED\");\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 6122,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(failTransferToAddresses[to] == false, \"TOKEN_TRANSFER_OUT_FAILED\");\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 6123,
          "vulnerability_to_line": null,
          "vulnerability_code": "        return super.doTransferOut(to, amount);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 6123,
          "vulnerability_to_line": null,
          "vulnerability_code": "        return super.doTransferOut(to, amount);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 6270,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint blockNumber = 100000;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 6271,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint harnessExchangeRate;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 6272,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bool harnessExchangeRateStored;\n",
          "message": null
        }
      ]
    },
    "oyente": {
      "successfull_analysis": false,
      "errors": [
        "exception (RuntimeError: Source map error, unknown name(SHR) or instr_name(INVALID))"
      ],
      "vulnerability_findings": []
    },
    "mythril": {
      "successfull_analysis": false,
      "errors": [
        "DOCKER_TIMEOUT"
      ],
      "vulnerability_findings": []
    },
    "osiris": {
      "successfull_analysis": false,
      "errors": [
        "Solidity compilation failed"
      ],
      "vulnerability_findings": []
    }
  }
}