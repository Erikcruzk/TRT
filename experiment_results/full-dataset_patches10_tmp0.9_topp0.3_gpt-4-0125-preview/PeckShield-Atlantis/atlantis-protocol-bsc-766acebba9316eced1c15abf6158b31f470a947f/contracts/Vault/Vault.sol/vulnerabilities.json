{
  "smartbugs_completed": true,
  "analyzer_results": {
    "semgrep": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "use-abi-encodecall-instead-of-encodewithselector",
          "vulnerability_from_line": 363,
          "vulnerability_to_line": null,
          "vulnerability_code": "        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n",
          "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
        },
        {
          "name": "use-abi-encodecall-instead-of-encodewithselector",
          "vulnerability_from_line": 367,
          "vulnerability_to_line": null,
          "vulnerability_code": "        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n",
          "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
        },
        {
          "name": "use-abi-encodecall-instead-of-encodewithselector",
          "vulnerability_from_line": 378,
          "vulnerability_to_line": null,
          "vulnerability_code": "        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n",
          "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
        },
        {
          "name": "use-abi-encodecall-instead-of-encodewithselector",
          "vulnerability_from_line": 383,
          "vulnerability_to_line": null,
          "vulnerability_code": "        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n",
          "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
        },
        {
          "name": "use-abi-encodecall-instead-of-encodewithselector",
          "vulnerability_from_line": 388,
          "vulnerability_to_line": null,
          "vulnerability_code": "        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n",
          "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 544,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor() public {\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 545,
          "vulnerability_to_line": null,
          "vulnerability_code": "        // Set admin to caller\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 546,
          "vulnerability_to_line": null,
          "vulnerability_code": "        admin = msg.sender;\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 547,
          "vulnerability_to_line": null,
          "vulnerability_code": "    }\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 683,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor() public {\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 684,
          "vulnerability_to_line": null,
          "vulnerability_code": "        admin = msg.sender;\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 685,
          "vulnerability_to_line": null,
          "vulnerability_code": "    }\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 111,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(c >= a, \"SafeMath: addition overflow\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 175,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(c / a == b, \"SafeMath: multiplication overflow\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 334,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(address(this).balance >= amount, \"Address: insufficient balance\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 339,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(success, \"Address: unable to send value, recipient may have reverted\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 375,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require((value == 0) || (token.allowance(address(this), spender) == 0),\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 376,
          "vulnerability_to_line": null,
          "vulnerability_code": "            \"SafeBEP20: approve from non-zero to non-zero allowance\"\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 377,
          "vulnerability_to_line": null,
          "vulnerability_code": "        );\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 406,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(address(token).isContract(), \"SafeBEP20: call to non-contract\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 410,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(success, \"SafeBEP20: low-level call failed\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 414,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(abi.decode(returndata, (bool)), \"SafeBEP20: BEP20 operation did not succeed\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 688,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == admin, \"only admin can\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 698,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_notEntered, \"re-entered\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 748,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(user.amount >= _amount, \"withdraw: not good\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 829,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(newAdmin != address(0), \"new owner is the zero address\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 837,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == vaultProxy.admin(), \"only proxy admin can change brains\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 838,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(vaultProxy._acceptImplementation() == 0, \"change not authorized\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 175,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(c / a == b, \"SafeMath: multiplication overflow\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 339,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(success, \"Address: unable to send value, recipient may have reverted\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 375,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require((value == 0) || (token.allowance(address(this), spender) == 0),\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 376,
          "vulnerability_to_line": null,
          "vulnerability_code": "            \"SafeBEP20: approve from non-zero to non-zero allowance\"\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 377,
          "vulnerability_to_line": null,
          "vulnerability_code": "        );\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 414,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(abi.decode(returndata, (bool)), \"SafeBEP20: BEP20 operation did not succeed\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 837,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == vaultProxy.admin(), \"only proxy admin can change brains\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        }
      ]
    },
    "slither": {
      "successfull_analysis": true,
      "errors": [
        "EXIT_CODE_43"
      ],
      "vulnerability_findings": [
        {
          "name": "controlled-delegatecall",
          "vulnerability_from_line": 647,
          "vulnerability_to_line": 659,
          "vulnerability_code": "    function () external payable {\n\n        // delegate all other functions to current implementation\n\n        (bool success, ) = vaultImplementation.delegatecall(msg.data);\n\n\n\n        assembly {\n\n              let free_mem_ptr := mload(0x40)\n\n              returndatacopy(free_mem_ptr, 0, returndatasize)\n\n\n\n              switch success\n\n              case 0 { revert(free_mem_ptr, returndatasize) }\n\n              default { return(free_mem_ptr, returndatasize) }\n\n        }\n",
          "message": "VaultProxy.fallback (Vault.sol#647-659) uses delegatecall to a input-controlled function id\n\t(success) = vaultImplementation.delegatecall(msg.data) (Vault.sol#649)\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 294,
          "vulnerability_to_line": 303,
          "vulnerability_code": "    function isContract(address account) internal view returns (bool) {\n\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n\n        // for accounts without code, i.e. `keccak256('')`\n\n        bytes32 codehash;\n\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly { codehash := extcodehash(account) }\n\n        return (codehash != accountHash && codehash != 0x0);\n",
          "message": "Address.isContract (Vault.sol#294-303) is declared view but contains assembly code\n"
        },
        {
          "name": "incorrect-equality",
          "vulnerability_from_line": 800,
          "vulnerability_to_line": 808,
          "vulnerability_code": "    function updateVault() internal {\n\n        uint256 stakedTokenBalance = stakedToken.balanceOf(address(this));\n\n        if (stakedTokenBalance == 0) { // avoids division by 0 errors\n\n            return;\n\n        }\n\n\n\n        accAtlantisPerShare = accAtlantisPerShare.add(pendingRewards.mul(1e18).div(stakedTokenBalance));\n\n        pendingRewards = 0;\n",
          "message": "Vault.updateVault (Vault.sol#800-808) uses a dangerous strict equality:\n\t- stakedTokenBalance == 0\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 746,
          "vulnerability_to_line": 760,
          "vulnerability_code": "    function _withdraw(address account, uint256 _amount) internal {\n\n        UserInfo storage user = userInfo[account];\n\n        require(user.amount >= _amount, \"withdraw: not good\");\n\n\n\n        updateVault();\n\n        updateAndPayOutPending(account); // Update balances of account this is not withdrawal but claiming Atlantis farmed\n\n\n\n        if(_amount > 0) {\n\n            user.amount = user.amount.sub(_amount);\n\n            stakedToken.safeTransfer(address(account), _amount);\n\n        }\n\n        user.rewardDebt = user.amount.mul(accAtlantisPerShare).div(1e18);\n\n\n\n        emit Withdraw(account, _amount);\n",
          "message": "Reentrancy in Vault._withdraw (Vault.sol#746-760):\n\tExternal calls:\n\t- updateVault() (Vault.sol#750)\n\t- updateAndPayOutPending(account) (Vault.sol#751)\n\tState variables written after the call(s):\n\t- userInfo (Vault.sol#754)\n\t- userInfo (Vault.sol#757)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 708,
          "vulnerability_to_line": 724,
          "vulnerability_code": "    function deposit(uint256 _amount) public nonReentrant {\n\n        UserInfo storage user = userInfo[msg.sender];\n\n\n\n        updateVault();\n\n\n\n        // Transfer pending tokens to user\n\n        updateAndPayOutPending(msg.sender);\n\n\n\n        // Transfer in the amounts from user\n\n        if(_amount > 0) {\n\n            stakedToken.safeTransferFrom(address(msg.sender), address(this), _amount);\n\n            user.amount = user.amount.add(_amount);\n\n        }\n\n\n\n        user.rewardDebt = user.amount.mul(accAtlantisPerShare).div(1e18);\n\n        emit Deposit(msg.sender, _amount);\n",
          "message": "Reentrancy in Vault.deposit (Vault.sol#708-724):\n\tExternal calls:\n\t- updateVault() (Vault.sol#711)\n\t- updateAndPayOutPending(msg.sender) (Vault.sol#714)\n\tState variables written after the call(s):\n\t- userInfo (Vault.sol#719)\n\t- userInfo (Vault.sol#722)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 746,
          "vulnerability_to_line": 760,
          "vulnerability_code": "    function _withdraw(address account, uint256 _amount) internal {\n\n        UserInfo storage user = userInfo[account];\n\n        require(user.amount >= _amount, \"withdraw: not good\");\n\n\n\n        updateVault();\n\n        updateAndPayOutPending(account); // Update balances of account this is not withdrawal but claiming Atlantis farmed\n\n\n\n        if(_amount > 0) {\n\n            user.amount = user.amount.sub(_amount);\n\n            stakedToken.safeTransfer(address(account), _amount);\n\n        }\n\n        user.rewardDebt = user.amount.mul(accAtlantisPerShare).div(1e18);\n\n\n\n        emit Withdraw(account, _amount);\n",
          "message": "Reentrancy in Vault._withdraw (Vault.sol#746-760):\n\tExternal calls:\n\t- updateVault() (Vault.sol#750)\n\t- updateAndPayOutPending(account) (Vault.sol#751)\n\tState variables written after the call(s):\n\t- atlantisBalance (Vault.sol#751)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 708,
          "vulnerability_to_line": 724,
          "vulnerability_code": "    function deposit(uint256 _amount) public nonReentrant {\n\n        UserInfo storage user = userInfo[msg.sender];\n\n\n\n        updateVault();\n\n\n\n        // Transfer pending tokens to user\n\n        updateAndPayOutPending(msg.sender);\n\n\n\n        // Transfer in the amounts from user\n\n        if(_amount > 0) {\n\n            stakedToken.safeTransferFrom(address(msg.sender), address(this), _amount);\n\n            user.amount = user.amount.add(_amount);\n\n        }\n\n\n\n        user.rewardDebt = user.amount.mul(accAtlantisPerShare).div(1e18);\n\n        emit Deposit(msg.sender, _amount);\n",
          "message": "Reentrancy in Vault.deposit (Vault.sol#708-724):\n\tExternal calls:\n\t- updateVault() (Vault.sol#711)\n\t- updateAndPayOutPending(msg.sender) (Vault.sol#714)\n\tState variables written after the call(s):\n\t- atlantisBalance (Vault.sol#714)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 775,
          "vulnerability_to_line": 782,
          "vulnerability_code": "    function updateAndPayOutPending(address account) internal {\n\n        uint256 pending = pendingAtlantis(account);\n\n\n\n        if(pending > 0) {\n\n            IAtlantisStore(atlantisStore).safeAtlantisTransfer(account, pending);\n\n            atlantisBalance = IAtlantisStore(atlantisStore).atlantisBalance();\n\n        }\n",
          "message": "Reentrancy in Vault.updateAndPayOutPending (Vault.sol#775-782):\n\tExternal calls:\n\t- IAtlantisStore(atlantisStore).safeAtlantisTransfer(account,pending) (Vault.sol#779)\n\t- atlantisBalance = IAtlantisStore(atlantisStore).atlantisBalance() (Vault.sol#780)\n\tState variables written after the call(s):\n\t- atlantisBalance (Vault.sol#780)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 787,
          "vulnerability_to_line": 795,
          "vulnerability_code": "    function updatePendingRewards() public {\n\n        uint256 existingRewards = IAtlantisStore(atlantisStore).atlantisBalance();\n\n        uint256 newRewards = existingRewards.sub(atlantisBalance);\n\n\n\n        if(newRewards > 0) {\n\n            atlantisBalance = IAtlantisStore(atlantisStore).atlantisBalance(); // If there is no change the balance didn't change\n\n            pendingRewards = pendingRewards.add(newRewards);\n\n        }\n",
          "message": "Reentrancy in Vault.updatePendingRewards (Vault.sol#787-795):\n\tExternal calls:\n\t- existingRewards = IAtlantisStore(atlantisStore).atlantisBalance() (Vault.sol#788)\n\t- atlantisBalance = IAtlantisStore(atlantisStore).atlantisBalance() (Vault.sol#792)\n\tState variables written after the call(s):\n\t- pendingRewards (Vault.sol#793)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 800,
          "vulnerability_to_line": 808,
          "vulnerability_code": "    function updateVault() internal {\n\n        uint256 stakedTokenBalance = stakedToken.balanceOf(address(this));\n\n        if (stakedTokenBalance == 0) { // avoids division by 0 errors\n\n            return;\n\n        }\n\n\n\n        accAtlantisPerShare = accAtlantisPerShare.add(pendingRewards.mul(1e18).div(stakedTokenBalance));\n\n        pendingRewards = 0;\n",
          "message": "Reentrancy in Vault.updateVault (Vault.sol#800-808):\n\tExternal calls:\n\t- stakedTokenBalance = stakedToken.balanceOf(address(this)) (Vault.sol#801)\n\tState variables written after the call(s):\n\t- accAtlantisPerShare (Vault.sol#806)\n\t- pendingRewards (Vault.sol#807)\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 294,
          "vulnerability_to_line": 303,
          "vulnerability_code": "    function isContract(address account) internal view returns (bool) {\n\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n\n        // for accounts without code, i.e. `keccak256('')`\n\n        bytes32 codehash;\n\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly { codehash := extcodehash(account) }\n\n        return (codehash != accountHash && codehash != 0x0);\n",
          "message": "Address.isContract uses assembly (Vault.sol#294-303)\n\t- Vault.sol#301\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 647,
          "vulnerability_to_line": 659,
          "vulnerability_code": "    function () external payable {\n\n        // delegate all other functions to current implementation\n\n        (bool success, ) = vaultImplementation.delegatecall(msg.data);\n\n\n\n        assembly {\n\n              let free_mem_ptr := mload(0x40)\n\n              returndatacopy(free_mem_ptr, 0, returndatasize)\n\n\n\n              switch success\n\n              case 0 { revert(free_mem_ptr, returndatasize) }\n\n              default { return(free_mem_ptr, returndatasize) }\n\n        }\n",
          "message": "VaultProxy.fallback uses assembly (Vault.sol#647-659)\n\t- Vault.sol#651-658\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 550,
          "vulnerability_to_line": 563,
          "vulnerability_code": "    function _setPendingImplementation(address newPendingImplementation) public returns (uint) {\n\n\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_IMPLEMENTATION_OWNER_CHECK);\n\n        }\n\n\n\n        address oldPendingImplementation = pendingVaultImplementation;\n\n\n\n        pendingVaultImplementation = newPendingImplementation;\n\n\n\n        emit NewPendingImplementation(oldPendingImplementation, pendingVaultImplementation);\n\n\n\n        return uint(Error.NO_ERROR);\n",
          "message": "VaultProxy._setPendingImplementation (Vault.sol#550-563) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 570,
          "vulnerability_to_line": 588,
          "vulnerability_code": "    function _acceptImplementation() public returns (uint) {\n\n        // Check caller is pendingImplementation\n\n        if (msg.sender != pendingVaultImplementation) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_PENDING_IMPLEMENTATION_ADDRESS_CHECK);\n\n        }\n\n\n\n        // Save current values for inclusion in log\n\n        address oldImplementation = vaultImplementation;\n\n        address oldPendingImplementation = pendingVaultImplementation;\n\n\n\n        vaultImplementation = pendingVaultImplementation;\n\n\n\n        pendingVaultImplementation = address(0);\n\n\n\n        emit NewImplementation(oldImplementation, vaultImplementation);\n\n        emit NewPendingImplementation(oldPendingImplementation, pendingVaultImplementation);\n\n\n\n        return uint(Error.NO_ERROR);\n",
          "message": "VaultProxy._acceptImplementation (Vault.sol#570-588) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 597,
          "vulnerability_to_line": 613,
          "vulnerability_code": "    function _setPendingAdmin(address newPendingAdmin) public returns (uint) {\n\n        // Check caller = admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);\n\n        }\n\n\n\n        // Save current value, if any, for inclusion in log\n\n        address oldPendingAdmin = pendingAdmin;\n\n\n\n        // Store pendingAdmin with value newPendingAdmin\n\n        pendingAdmin = newPendingAdmin;\n\n\n\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\n\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n\n\n\n        return uint(Error.NO_ERROR);\n",
          "message": "VaultProxy._setPendingAdmin (Vault.sol#597-613) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 620,
          "vulnerability_to_line": 640,
          "vulnerability_code": "    function _acceptAdmin() public returns (uint) {\n\n        // Check caller is pendingAdmin\n\n        if (msg.sender != pendingAdmin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);\n\n        }\n\n\n\n        // Save current values for inclusion in log\n\n        address oldAdmin = admin;\n\n        address oldPendingAdmin = pendingAdmin;\n\n\n\n        // Store admin with value pendingAdmin\n\n        admin = pendingAdmin;\n\n\n\n        // Clear the pending value\n\n        pendingAdmin = address(0);\n\n\n\n        emit NewAdmin(oldAdmin, admin);\n\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\n\n\n\n        return uint(Error.NO_ERROR);\n",
          "message": "VaultProxy._acceptAdmin (Vault.sol#620-640) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 708,
          "vulnerability_to_line": 724,
          "vulnerability_code": "    function deposit(uint256 _amount) public nonReentrant {\n\n        UserInfo storage user = userInfo[msg.sender];\n\n\n\n        updateVault();\n\n\n\n        // Transfer pending tokens to user\n\n        updateAndPayOutPending(msg.sender);\n\n\n\n        // Transfer in the amounts from user\n\n        if(_amount > 0) {\n\n            stakedToken.safeTransferFrom(address(msg.sender), address(this), _amount);\n\n            user.amount = user.amount.add(_amount);\n\n        }\n\n\n\n        user.rewardDebt = user.amount.mul(accAtlantisPerShare).div(1e18);\n\n        emit Deposit(msg.sender, _amount);\n",
          "message": "Vault.deposit (Vault.sol#708-724) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 730,
          "vulnerability_to_line": 732,
          "vulnerability_code": "    function withdraw(uint256 _amount) public nonReentrant {\n\n        _withdraw(msg.sender, _amount);\n",
          "message": "Vault.withdraw (Vault.sol#730-732) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 737,
          "vulnerability_to_line": 739,
          "vulnerability_code": "    function claim() public nonReentrant {\n\n        _withdraw(msg.sender, 0);\n",
          "message": "Vault.claim (Vault.sol#737-739) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 787,
          "vulnerability_to_line": 795,
          "vulnerability_code": "    function updatePendingRewards() public {\n\n        uint256 existingRewards = IAtlantisStore(atlantisStore).atlantisBalance();\n\n        uint256 newRewards = existingRewards.sub(atlantisBalance);\n\n\n\n        if(newRewards > 0) {\n\n            atlantisBalance = IAtlantisStore(atlantisStore).atlantisBalance(); // If there is no change the balance didn't change\n\n            pendingRewards = pendingRewards.add(newRewards);\n\n        }\n",
          "message": "Vault.updatePendingRewards (Vault.sol#787-795) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 813,
          "vulnerability_to_line": 815,
          "vulnerability_code": "    function getAdmin() public view returns (address) {\n\n        return admin;\n",
          "message": "Vault.getAdmin (Vault.sol#813-815) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 820,
          "vulnerability_to_line": 823,
          "vulnerability_code": "    function burnAdmin() public onlyAdmin {\n\n        emit AdminTransfered(admin, address(0));\n\n        admin = address(0);\n",
          "message": "Vault.burnAdmin (Vault.sol#820-823) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 828,
          "vulnerability_to_line": 832,
          "vulnerability_code": "    function setNewAdmin(address newAdmin) public onlyAdmin {\n\n        require(newAdmin != address(0), \"new owner is the zero address\");\n\n        emit AdminTransfered(admin, newAdmin);\n\n        admin = newAdmin;\n",
          "message": "Vault.setNewAdmin (Vault.sol#828-832) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 836,
          "vulnerability_to_line": 839,
          "vulnerability_code": "    function _become(VaultProxy vaultProxy) public {\n\n        require(msg.sender == vaultProxy.admin(), \"only proxy admin can change brains\");\n\n        require(vaultProxy._acceptImplementation() == 0, \"change not authorized\");\n",
          "message": "Vault._become (Vault.sol#836-839) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 841,
          "vulnerability_to_line": 845,
          "vulnerability_code": "    function setAtlantisInfo(address _atlantisStore, address _stakedToken) public onlyAdmin {\n\n        atlantisStore = _atlantisStore;\n\n        stakedToken = IBEP20(_stakedToken);\n\n        _notEntered = true;\n",
          "message": "Vault.setAtlantisInfo (Vault.sol#841-845) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 850,
          "vulnerability_to_line": 852,
          "vulnerability_code": "    function getAtlantisStore() public view returns (address) {\n\n        return address(atlantisStore);\n",
          "message": "Vault.getAtlantisStore (Vault.sol#850-852) should be declared external\n"
        },
        {
          "name": "solc-version",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": "Detected issues with version pragma in Vault.sol:\n\t- pragma solidity^0.5.16 (Vault.sol#3): it allows old versions\n\t- pragma solidity^0.5.16 (Vault.sol#82): it allows old versions\n\t- pragma solidity^0.5.16 (Vault.sol#271): it allows old versions\n\t- pragma solidity^0.5.16 (Vault.sol#345): it allows old versions\n\t- pragma solidity^0.5.16 (Vault.sol#421): it allows old versions\n\t- pragma solidity^0.5.16 (Vault.sol#477): it allows old versions\n\t- pragma solidity^0.5.16 (Vault.sol#519): it allows old versions\n\t- pragma solidity^0.5.16 (Vault.sol#664): it allows old versions\n"
        },
        {
          "name": "low-level-calls",
          "vulnerability_from_line": 333,
          "vulnerability_to_line": 340,
          "vulnerability_code": "    function sendValue(address payable recipient, uint256 amount) internal {\n\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n\n\n        // solhint-disable-next-line avoid-call-value\n\n        // solium-disable-next-line security/no-call-value\n\n        (bool success, ) = recipient.call.value(amount)(\"\");\n\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n",
          "message": "Low level call in Address.sendValue (Vault.sol#333-340):\n\t-(success) = recipient.call.value(amount)() Vault.sol#338\n"
        },
        {
          "name": "low-level-calls",
          "vulnerability_from_line": 397,
          "vulnerability_to_line": 416,
          "vulnerability_code": "    function callOptionalReturn(IBEP20 token, bytes memory data) private {\n\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n\n        // we're implementing it ourselves.\n\n\n\n        // A Solidity high level call has three parts:\n\n        //  1. The target address is checked to verify it contains contract code\n\n        //  2. The call itself is made, and success asserted\n\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\n\n        // solhint-disable-next-line max-line-length\n\n        require(address(token).isContract(), \"SafeBEP20: call to non-contract\");\n\n\n\n        // solhint-disable-next-line avoid-low-level-calls\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n\n        require(success, \"SafeBEP20: low-level call failed\");\n\n\n\n        if (returndata.length > 0) { // Return data is optional\n\n            // solhint-disable-next-line max-line-length\n\n            require(abi.decode(returndata, (bool)), \"SafeBEP20: BEP20 operation did not succeed\");\n\n        }\n",
          "message": "Low level call in SafeBEP20.callOptionalReturn (Vault.sol#397-416):\n\t-(success,returndata) = address(token).call(data) Vault.sol#409\n"
        },
        {
          "name": "low-level-calls",
          "vulnerability_from_line": 647,
          "vulnerability_to_line": 659,
          "vulnerability_code": "    function () external payable {\n\n        // delegate all other functions to current implementation\n\n        (bool success, ) = vaultImplementation.delegatecall(msg.data);\n\n\n\n        assembly {\n\n              let free_mem_ptr := mload(0x40)\n\n              returndatacopy(free_mem_ptr, 0, returndatasize)\n\n\n\n              switch success\n\n              case 0 { revert(free_mem_ptr, returndatasize) }\n\n              default { return(free_mem_ptr, returndatasize) }\n\n        }\n",
          "message": "Low level call in VaultProxy.fallback (Vault.sol#647-659):\n\t-(success) = vaultImplementation.delegatecall(msg.data) Vault.sol#649\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 454,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bool internal _notEntered;\n",
          "message": "Variable 'VaultStorage._notEntered' (Vault.sol#454) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 550,
          "vulnerability_to_line": 563,
          "vulnerability_code": "    function _setPendingImplementation(address newPendingImplementation) public returns (uint) {\n\n\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_IMPLEMENTATION_OWNER_CHECK);\n\n        }\n\n\n\n        address oldPendingImplementation = pendingVaultImplementation;\n\n\n\n        pendingVaultImplementation = newPendingImplementation;\n\n\n\n        emit NewPendingImplementation(oldPendingImplementation, pendingVaultImplementation);\n\n\n\n        return uint(Error.NO_ERROR);\n",
          "message": "Function 'VaultProxy._setPendingImplementation' (Vault.sol#550-563) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 570,
          "vulnerability_to_line": 588,
          "vulnerability_code": "    function _acceptImplementation() public returns (uint) {\n\n        // Check caller is pendingImplementation\n\n        if (msg.sender != pendingVaultImplementation) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_PENDING_IMPLEMENTATION_ADDRESS_CHECK);\n\n        }\n\n\n\n        // Save current values for inclusion in log\n\n        address oldImplementation = vaultImplementation;\n\n        address oldPendingImplementation = pendingVaultImplementation;\n\n\n\n        vaultImplementation = pendingVaultImplementation;\n\n\n\n        pendingVaultImplementation = address(0);\n\n\n\n        emit NewImplementation(oldImplementation, vaultImplementation);\n\n        emit NewPendingImplementation(oldPendingImplementation, pendingVaultImplementation);\n\n\n\n        return uint(Error.NO_ERROR);\n",
          "message": "Function 'VaultProxy._acceptImplementation' (Vault.sol#570-588) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 597,
          "vulnerability_to_line": 613,
          "vulnerability_code": "    function _setPendingAdmin(address newPendingAdmin) public returns (uint) {\n\n        // Check caller = admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);\n\n        }\n\n\n\n        // Save current value, if any, for inclusion in log\n\n        address oldPendingAdmin = pendingAdmin;\n\n\n\n        // Store pendingAdmin with value newPendingAdmin\n\n        pendingAdmin = newPendingAdmin;\n\n\n\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\n\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n\n\n\n        return uint(Error.NO_ERROR);\n",
          "message": "Function 'VaultProxy._setPendingAdmin' (Vault.sol#597-613) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 620,
          "vulnerability_to_line": 640,
          "vulnerability_code": "    function _acceptAdmin() public returns (uint) {\n\n        // Check caller is pendingAdmin\n\n        if (msg.sender != pendingAdmin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);\n\n        }\n\n\n\n        // Save current values for inclusion in log\n\n        address oldAdmin = admin;\n\n        address oldPendingAdmin = pendingAdmin;\n\n\n\n        // Store admin with value pendingAdmin\n\n        admin = pendingAdmin;\n\n\n\n        // Clear the pending value\n\n        pendingAdmin = address(0);\n\n\n\n        emit NewAdmin(oldAdmin, admin);\n\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\n\n\n\n        return uint(Error.NO_ERROR);\n",
          "message": "Function 'VaultProxy._acceptAdmin' (Vault.sol#620-640) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 708,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function deposit(uint256 _amount) public nonReentrant {\n",
          "message": "Parameter '_amount' of Vault.deposit (Vault.sol#708) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 730,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function withdraw(uint256 _amount) public nonReentrant {\n",
          "message": "Parameter '_amount' of Vault.withdraw (Vault.sol#730) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 746,
          "vulnerability_to_line": 760,
          "vulnerability_code": "    function _withdraw(address account, uint256 _amount) internal {\n\n        UserInfo storage user = userInfo[account];\n\n        require(user.amount >= _amount, \"withdraw: not good\");\n\n\n\n        updateVault();\n\n        updateAndPayOutPending(account); // Update balances of account this is not withdrawal but claiming Atlantis farmed\n\n\n\n        if(_amount > 0) {\n\n            user.amount = user.amount.sub(_amount);\n\n            stakedToken.safeTransfer(address(account), _amount);\n\n        }\n\n        user.rewardDebt = user.amount.mul(accAtlantisPerShare).div(1e18);\n\n\n\n        emit Withdraw(account, _amount);\n",
          "message": "Function 'Vault._withdraw' (Vault.sol#746-760) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 746,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _withdraw(address account, uint256 _amount) internal {\n",
          "message": "Parameter '_amount' of Vault._withdraw (Vault.sol#746) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 766,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function pendingAtlantis(address _user) public view returns (uint256) {\n",
          "message": "Parameter '_user' of Vault.pendingAtlantis (Vault.sol#766) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 836,
          "vulnerability_to_line": 839,
          "vulnerability_code": "    function _become(VaultProxy vaultProxy) public {\n\n        require(msg.sender == vaultProxy.admin(), \"only proxy admin can change brains\");\n\n        require(vaultProxy._acceptImplementation() == 0, \"change not authorized\");\n",
          "message": "Function 'Vault._become' (Vault.sol#836-839) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 841,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setAtlantisInfo(address _atlantisStore, address _stakedToken) public onlyAdmin {\n",
          "message": "Parameter '_atlantisStore' of Vault.setAtlantisInfo (Vault.sol#841) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 841,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setAtlantisInfo(address _atlantisStore, address _stakedToken) public onlyAdmin {\n",
          "message": "Parameter '_stakedToken' of Vault.setAtlantisInfo (Vault.sol#841) is not in mixedCase\n"
        }
      ]
    },
    "smartcheck": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 582,
          "vulnerability_to_line": null,
          "vulnerability_code": "        pendingVaultImplementation = address(0);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 634,
          "vulnerability_to_line": null,
          "vulnerability_code": "        pendingAdmin = address(0);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 822,
          "vulnerability_to_line": null,
          "vulnerability_code": "        admin = address(0);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_LOCKED_MONEY",
          "vulnerability_from_line": 522,
          "vulnerability_to_line": null,
          "vulnerability_code": "contract VaultProxy is VaultAdminStorage, VaultErrorReporter {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 82,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 271,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 345,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 421,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 477,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 519,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 664,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SAFEMATH",
          "vulnerability_from_line": 359,
          "vulnerability_to_line": null,
          "vulnerability_code": "    using SafeMath for uint256;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SAFEMATH",
          "vulnerability_from_line": 671,
          "vulnerability_to_line": null,
          "vulnerability_code": "    using SafeMath for uint256;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
          "vulnerability_from_line": 294,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function isContract(address account) internal view returns (bool) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UNCHECKED_CALL",
          "vulnerability_from_line": 363,
          "vulnerability_to_line": null,
          "vulnerability_code": "        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UNCHECKED_CALL",
          "vulnerability_from_line": 367,
          "vulnerability_to_line": null,
          "vulnerability_code": "        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UNCHECKED_CALL",
          "vulnerability_from_line": 378,
          "vulnerability_to_line": null,
          "vulnerability_code": "        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UNCHECKED_CALL",
          "vulnerability_from_line": 383,
          "vulnerability_to_line": null,
          "vulnerability_code": "        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UNCHECKED_CALL",
          "vulnerability_from_line": 388,
          "vulnerability_to_line": null,
          "vulnerability_code": "        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UNCHECKED_CALL",
          "vulnerability_from_line": 409,
          "vulnerability_to_line": null,
          "vulnerability_code": "        (bool success, bytes memory returndata) = address(token).call(data);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UNCHECKED_CALL",
          "vulnerability_from_line": 649,
          "vulnerability_to_line": null,
          "vulnerability_code": "        (bool success, ) = vaultImplementation.delegatecall(msg.data);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 301,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly { codehash := extcodehash(account) }\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 651,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 333,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function sendValue(address payable recipient, uint256 amount) internal {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 333,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function sendValue(address payable recipient, uint256 amount) internal {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 333,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function sendValue(address payable recipient, uint256 amount) internal {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 334,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(address(this).balance >= amount, \"Address: insufficient balance\");\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 334,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(address(this).balance >= amount, \"Address: insufficient balance\");\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 334,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(address(this).balance >= amount, \"Address: insufficient balance\");\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 334,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(address(this).balance >= amount, \"Address: insufficient balance\");\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 338,
          "vulnerability_to_line": null,
          "vulnerability_code": "        (bool success, ) = recipient.call.value(amount)(\"\");\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 338,
          "vulnerability_to_line": null,
          "vulnerability_code": "        (bool success, ) = recipient.call.value(amount)(\"\");\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 338,
          "vulnerability_to_line": null,
          "vulnerability_code": "        (bool success, ) = recipient.call.value(amount)(\"\");\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 339,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(success, \"Address: unable to send value, recipient may have reverted\");\n",
          "message": null
        }
      ]
    },
    "oyente": {
      "successfull_analysis": false,
      "errors": [
        "exception (RuntimeError: Source map error, unknown name(SHR) or instr_name(INVALID))"
      ],
      "vulnerability_findings": []
    },
    "mythril": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "External Call To User-Supplied Address (SWC 107)",
          "vulnerability_from_line": 838,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(vaultProxy._acceptImplementation() == 0, \"change not authorized\");\n",
          "message": "A call to a user-supplied address is executed.\nAn external message call to an address specified by the caller is executed. Note that the callee account might contain arbitrary code and could re-enter any function within this contract. Reentering the contract in an intermediate state may lead to unexpected behaviour. Make sure that no state modifications are executed after this call and/or reentrancy guards are in place.\nClassification: SWC-107"
        },
        {
          "name": "Multiple Calls in a Single Transaction (SWC 113)",
          "vulnerability_from_line": 838,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(vaultProxy._acceptImplementation() == 0, \"change not authorized\");\n",
          "message": "Multiple calls are executed in the same transaction.\nThis call is executed following another call within the same transaction. It is possible that the call never gets executed if a prior call fails permanently. This might be caused intentionally by a malicious callee. If possible, refactor the code such that each transaction only executes one external call or make sure that all callees can be trusted (i.e. they\u2019re part of your own codebase).\nClassification: SWC-113"
        },
        {
          "name": "External Call To User-Supplied Address (SWC 107)",
          "vulnerability_from_line": 788,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint256 existingRewards = IAtlantisStore(atlantisStore).atlantisBalance();\n",
          "message": "A call to a user-supplied address is executed.\nAn external message call to an address specified by the caller is executed. Note that the callee account might contain arbitrary code and could re-enter any function within this contract. Reentering the contract in an intermediate state may lead to unexpected behaviour. Make sure that no state modifications are executed after this call and/or reentrancy guards are in place.\nClassification: SWC-107"
        },
        {
          "name": "State access after external call (SWC 107)",
          "vulnerability_from_line": 789,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint256 newRewards = existingRewards.sub(atlantisBalance);\n",
          "message": "Read of persistent state following external call\nThe contract account state is accessed after an external call to a user defined address. To prevent reentrancy issues, consider accessing the state only before the call, especially if the callee is untrusted. Alternatively, a reentrancy lock can be used to prevent untrusted callees from re-entering the contract in an intermediate state.\nClassification: SWC-107"
        },
        {
          "name": "State access after external call (SWC 107)",
          "vulnerability_from_line": 792,
          "vulnerability_to_line": null,
          "vulnerability_code": "            atlantisBalance = IAtlantisStore(atlantisStore).atlantisBalance(); // If there is no change the balance didn't change\n",
          "message": "Read of persistent state following external call\nThe contract account state is accessed after an external call to a user defined address. To prevent reentrancy issues, consider accessing the state only before the call, especially if the callee is untrusted. Alternatively, a reentrancy lock can be used to prevent untrusted callees from re-entering the contract in an intermediate state.\nClassification: SWC-107"
        },
        {
          "name": "External Call To User-Supplied Address (SWC 107)",
          "vulnerability_from_line": 792,
          "vulnerability_to_line": null,
          "vulnerability_code": "            atlantisBalance = IAtlantisStore(atlantisStore).atlantisBalance(); // If there is no change the balance didn't change\n",
          "message": "A call to a user-supplied address is executed.\nAn external message call to an address specified by the caller is executed. Note that the callee account might contain arbitrary code and could re-enter any function within this contract. Reentering the contract in an intermediate state may lead to unexpected behaviour. Make sure that no state modifications are executed after this call and/or reentrancy guards are in place.\nClassification: SWC-107"
        },
        {
          "name": "Multiple Calls in a Single Transaction (SWC 113)",
          "vulnerability_from_line": 792,
          "vulnerability_to_line": null,
          "vulnerability_code": "            atlantisBalance = IAtlantisStore(atlantisStore).atlantisBalance(); // If there is no change the balance didn't change\n",
          "message": "Multiple calls are executed in the same transaction.\nThis call is executed following another call within the same transaction. It is possible that the call never gets executed if a prior call fails permanently. This might be caused intentionally by a malicious callee. If possible, refactor the code such that each transaction only executes one external call or make sure that all callees can be trusted (i.e. they\u2019re part of your own codebase).\nClassification: SWC-113"
        },
        {
          "name": "State access after external call (SWC 107)",
          "vulnerability_from_line": 792,
          "vulnerability_to_line": null,
          "vulnerability_code": "            atlantisBalance = IAtlantisStore(atlantisStore).atlantisBalance(); // If there is no change the balance didn't change\n",
          "message": "Write to persistent state following external call\nThe contract account state is accessed after an external call to a user defined address. To prevent reentrancy issues, consider accessing the state only before the call, especially if the callee is untrusted. Alternatively, a reentrancy lock can be used to prevent untrusted callees from re-entering the contract in an intermediate state.\nClassification: SWC-107"
        },
        {
          "name": "State access after external call (SWC 107)",
          "vulnerability_from_line": 792,
          "vulnerability_to_line": null,
          "vulnerability_code": "            atlantisBalance = IAtlantisStore(atlantisStore).atlantisBalance(); // If there is no change the balance didn't change\n",
          "message": "Write to persistent state following external call\nThe contract account state is accessed after an external call to a user defined address. To prevent reentrancy issues, consider accessing the state only before the call, especially if the callee is untrusted. Alternatively, a reentrancy lock can be used to prevent untrusted callees from re-entering the contract in an intermediate state.\nClassification: SWC-107"
        },
        {
          "name": "State access after external call (SWC 107)",
          "vulnerability_from_line": 793,
          "vulnerability_to_line": null,
          "vulnerability_code": "            pendingRewards = pendingRewards.add(newRewards);\n",
          "message": "Read of persistent state following external call\nThe contract account state is accessed after an external call to a user defined address. To prevent reentrancy issues, consider accessing the state only before the call, especially if the callee is untrusted. Alternatively, a reentrancy lock can be used to prevent untrusted callees from re-entering the contract in an intermediate state.\nClassification: SWC-107"
        },
        {
          "name": "State access after external call (SWC 107)",
          "vulnerability_from_line": 793,
          "vulnerability_to_line": null,
          "vulnerability_code": "            pendingRewards = pendingRewards.add(newRewards);\n",
          "message": "Write to persistent state following external call\nThe contract account state is accessed after an external call to a user defined address. To prevent reentrancy issues, consider accessing the state only before the call, especially if the callee is untrusted. Alternatively, a reentrancy lock can be used to prevent untrusted callees from re-entering the contract in an intermediate state.\nClassification: SWC-107"
        }
      ]
    },
    "osiris": {
      "successfull_analysis": false,
      "errors": [
        "Solidity compilation failed"
      ],
      "vulnerability_findings": []
    }
  }
}