{
  "smartbugs_completed": true,
  "analyzer_results": {
    "semgrep": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 521,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor(address underlying_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 522,
          "vulnerability_to_line": null,
          "vulnerability_code": "                ComptrollerInterface comptroller_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 523,
          "vulnerability_to_line": null,
          "vulnerability_code": "                InterestRateModel interestRateModel_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 524,
          "vulnerability_to_line": null,
          "vulnerability_code": "                uint initialExchangeRateMantissa_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 525,
          "vulnerability_to_line": null,
          "vulnerability_code": "                string memory name_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 526,
          "vulnerability_to_line": null,
          "vulnerability_code": "                string memory symbol_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 527,
          "vulnerability_to_line": null,
          "vulnerability_code": "                uint8 decimals_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 528,
          "vulnerability_to_line": null,
          "vulnerability_code": "                address payable admin_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 529,
          "vulnerability_to_line": null,
          "vulnerability_code": "                address implementation_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 530,
          "vulnerability_to_line": null,
          "vulnerability_code": "                bytes memory becomeImplementationData) public {\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 3424,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor(address underlying_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 3425,
          "vulnerability_to_line": null,
          "vulnerability_code": "                ComptrollerInterface comptroller_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 3426,
          "vulnerability_to_line": null,
          "vulnerability_code": "                InterestRateModel interestRateModel_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 3427,
          "vulnerability_to_line": null,
          "vulnerability_code": "                uint initialExchangeRateMantissa_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 3428,
          "vulnerability_to_line": null,
          "vulnerability_code": "                string memory name_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 3429,
          "vulnerability_to_line": null,
          "vulnerability_code": "                string memory symbol_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 3430,
          "vulnerability_to_line": null,
          "vulnerability_code": "                uint8 decimals_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 3431,
          "vulnerability_to_line": null,
          "vulnerability_code": "                address payable admin_) public {\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 3432,
          "vulnerability_to_line": null,
          "vulnerability_code": "        // Creator of the contract is admin during initialization\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 3433,
          "vulnerability_to_line": null,
          "vulnerability_code": "        admin = msg.sender;\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 3449,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor(address underlying_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 3450,
          "vulnerability_to_line": null,
          "vulnerability_code": "                ComptrollerInterface comptroller_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 3451,
          "vulnerability_to_line": null,
          "vulnerability_code": "                InterestRateModel interestRateModel_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 3452,
          "vulnerability_to_line": null,
          "vulnerability_code": "                uint initialExchangeRateMantissa_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 3453,
          "vulnerability_to_line": null,
          "vulnerability_code": "                string memory name_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 3454,
          "vulnerability_to_line": null,
          "vulnerability_code": "                string memory symbol_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 3455,
          "vulnerability_to_line": null,
          "vulnerability_code": "                uint8 decimals_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 3456,
          "vulnerability_to_line": null,
          "vulnerability_code": "                address payable admin_) public ABep20Immutable(underlying_, comptroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_, admin_) {\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 3457,
          "vulnerability_to_line": null,
          "vulnerability_code": "    }\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 3472,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor(address underlying_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 3473,
          "vulnerability_to_line": null,
          "vulnerability_code": "                ComptrollerInterface comptroller_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 3474,
          "vulnerability_to_line": null,
          "vulnerability_code": "                InterestRateModel interestRateModel_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 3475,
          "vulnerability_to_line": null,
          "vulnerability_code": "                uint initialExchangeRateMantissa_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 3476,
          "vulnerability_to_line": null,
          "vulnerability_code": "                string memory name_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 3477,
          "vulnerability_to_line": null,
          "vulnerability_code": "                string memory symbol_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 3478,
          "vulnerability_to_line": null,
          "vulnerability_code": "                uint8 decimals_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 3479,
          "vulnerability_to_line": null,
          "vulnerability_code": "                address payable admin_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 3480,
          "vulnerability_to_line": null,
          "vulnerability_code": "                address implementation_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 3481,
          "vulnerability_to_line": null,
          "vulnerability_code": "                bytes memory becomeImplementationData) public ABep20Delegator(underlying_, comptroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_, admin_, implementation_, becomeImplementationData) {\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 558,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == admin, \"ABep20Delegator::_setImplementation: Caller must be admin\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 959,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.value == 0,\"ABep20Delegator:fallback: cannot send value to fallback\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1750,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == admin, \"only admin may initialize the market\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1751,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(accrualBlockNumber == 0 && borrowIndex == 0, \"market may only be initialized once\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1755,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(initialExchangeRateMantissa > 0, \"initial exchange rate must be greater than zero.\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1759,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(err == uint(Error.NO_ERROR), \"setting comptroller failed\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1767,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(err == uint(Error.NO_ERROR), \"setting interest rate model failed\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1912,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(mErr == MathError.NO_ERROR, \"balance could not be calculated\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1971,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1981,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1992,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(err == MathError.NO_ERROR, \"borrowBalanceStored: borrowBalanceStoredInternal failed\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 2038,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 2049,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(err == MathError.NO_ERROR, \"exchangeRateStored: exchangeRateStoredInternal failed\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 2121,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 2125,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(mathErr == MathError.NO_ERROR, \"could not calculate block delta\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 2255,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(vars.mathErr == MathError.NO_ERROR, \"MINT_EXCHANGE_CALCULATION_FAILED\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 2263,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(vars.mathErr == MathError.NO_ERROR, \"MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 2266,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(vars.mathErr == MathError.NO_ERROR, \"MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 2334,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 2621,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(vars.mathErr == MathError.NO_ERROR, \"REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 2624,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(vars.mathErr == MathError.NO_ERROR, \"REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 2720,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(amountSeizeError == uint(Error.NO_ERROR), \"LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 2723,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(aTokenCollateral.balanceOf(borrower) >= seizeTokens, \"LIQUIDATE_SEIZE_TOO_MUCH\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 2734,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(seizeError == uint(Error.NO_ERROR), \"token seizure failed\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 2809,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(vars.mathErr == MathError.NO_ERROR, \"exchange rate math error\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 2910,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(newComptroller.isComptroller(), \"marker method returned false\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 3015,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(totalReservesNew >= totalReserves, \"add reserves unexpected overflow\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 3079,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(totalReservesNew <= totalReserves, \"reduce reserves unexpected underflow\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 3133,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 3173,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_notEntered, \"re-entered\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 3300,
          "vulnerability_to_line": null,
          "vulnerability_code": "    \trequire(address(token) != underlying, \"ABep20::sweepToken: can not sweep underlying token\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 3354,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(success, \"TOKEN_TRANSFER_IN_FAILED\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 3358,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(balanceAfter >= balanceBefore, \"TOKEN_TRANSFER_IN_OVERFLOW\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 3389,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(success, \"TOKEN_TRANSFER_OUT_FAILED\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 3398,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == admin, \"only the admin may set the atlantis-like delegate\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 1751,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(accrualBlockNumber == 0 && borrowIndex == 0, \"market may only be initialized once\");\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 558,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == admin, \"ABep20Delegator::_setImplementation: Caller must be admin\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 959,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.value == 0,\"ABep20Delegator:fallback: cannot send value to fallback\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 1750,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == admin, \"only admin may initialize the market\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 1751,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(accrualBlockNumber == 0 && borrowIndex == 0, \"market may only be initialized once\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 1755,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(initialExchangeRateMantissa > 0, \"initial exchange rate must be greater than zero.\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 1767,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(err == uint(Error.NO_ERROR), \"setting interest rate model failed\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 1992,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(err == MathError.NO_ERROR, \"borrowBalanceStored: borrowBalanceStoredInternal failed\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 2049,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(err == MathError.NO_ERROR, \"exchangeRateStored: exchangeRateStoredInternal failed\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 2263,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(vars.mathErr == MathError.NO_ERROR, \"MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 2266,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(vars.mathErr == MathError.NO_ERROR, \"MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 2334,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 2621,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(vars.mathErr == MathError.NO_ERROR, \"REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 2624,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(vars.mathErr == MathError.NO_ERROR, \"REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 2720,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(amountSeizeError == uint(Error.NO_ERROR), \"LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 3079,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(totalReservesNew <= totalReserves, \"reduce reserves unexpected underflow\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 3300,
          "vulnerability_to_line": null,
          "vulnerability_code": "    \trequire(address(token) != underlying, \"ABep20::sweepToken: can not sweep underlying token\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 3398,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == admin, \"only the admin may set the atlantis-like delegate\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "compound-borrowfresh-reentrancy",
          "vulnerability_from_line": 2506,
          "vulnerability_to_line": null,
          "vulnerability_code": "        doTransferOut(borrower, borrowAmount);\n",
          "message": "Function borrowFresh() in Compound performs state update after doTransferOut()"
        },
        {
          "name": "compound-sweeptoken-not-restricted",
          "vulnerability_from_line": 3302,
          "vulnerability_to_line": null,
          "vulnerability_code": "    \ttoken.transfer(admin, balance);\n",
          "message": "Function sweepToken is allowed to be called by anyone"
        }
      ]
    },
    "slither": {
      "successfull_analysis": true,
      "errors": [
        "EXIT_CODE_114"
      ],
      "vulnerability_findings": [
        {
          "name": "controlled-delegatecall",
          "vulnerability_from_line": 917,
          "vulnerability_to_line": 925,
          "vulnerability_code": "    function delegateTo(address callee, bytes memory data) internal returns (bytes memory) {\n\n        (bool success, bytes memory returnData) = callee.delegatecall(data);\n\n        assembly {\n\n            if eq(success, 0) {\n\n                revert(add(returnData, 0x20), returndatasize)\n\n            }\n\n        }\n\n        return returnData;\n",
          "message": "ABep20Delegator.delegateTo (ABep20DelegatorCertora.sol#917-925) uses delegatecall to a input-controlled function id\n\t(success,returnData) = callee.delegatecall(data) (ABep20DelegatorCertora.sol#918)\n"
        },
        {
          "name": "controlled-delegatecall",
          "vulnerability_from_line": 958,
          "vulnerability_to_line": 972,
          "vulnerability_code": "    function () external payable {\n\n        require(msg.value == 0,\"ABep20Delegator:fallback: cannot send value to fallback\");\n\n\n\n        // delegate all other functions to current implementation\n\n        (bool success, ) = implementation.delegatecall(msg.data);\n\n\n\n        assembly {\n\n            let free_mem_ptr := mload(0x40)\n\n            returndatacopy(free_mem_ptr, 0, returndatasize)\n\n\n\n            switch success\n\n            case 0 { revert(free_mem_ptr, returndatasize) }\n\n            default { return(free_mem_ptr, returndatasize) }\n\n        }\n",
          "message": "ABep20Delegator.fallback (ABep20DelegatorCertora.sol#958-972) uses delegatecall to a input-controlled function id\n\t(success) = implementation.delegatecall(msg.data) (ABep20DelegatorCertora.sol#962)\n"
        },
        {
          "name": "uninitialized-state",
          "vulnerability_from_line": 440,
          "vulnerability_to_line": null,
          "vulnerability_code": "    address public underlying;\n",
          "message": "ABep20Storage.underlying (ABep20DelegatorCertora.sol#440) is never initialized. It is used in:\n\t- getCashOf (ABep20DelegatorCertora.sol#3502-3506)\n"
        },
        {
          "name": "uninitialized-state",
          "vulnerability_from_line": 3470,
          "vulnerability_to_line": 3472,
          "vulnerability_code": "    ATokenCollateral public otherToken;\n\n\n",
          "message": "ABep20DelegatorCertora.otherToken (ABep20DelegatorCertora.sol#3470-3472) is never initialized. It is used in:\n\t- balanceOfInOther (ABep20DelegatorCertora.sol#3486-3490)\n\t- borrowBalanceStoredInOther (ABep20DelegatorCertora.sol#3490-3494)\n\t- exchangeRateStoredInOther (ABep20DelegatorCertora.sol#3494-3498)\n\t- getCashInOther (ABep20DelegatorCertora.sol#3498-3502)\n\t- getCashOfInOther (ABep20DelegatorCertora.sol#3506-3510)\n\t- totalSupplyInOther (ABep20DelegatorCertora.sol#3510-3514)\n\t- totalBorrowsInOther (ABep20DelegatorCertora.sol#3514-3518)\n\t- totalReservesInOther (ABep20DelegatorCertora.sol#3518-3522)\n\t- underlyingInOther (ABep20DelegatorCertora.sol#3522-3526)\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 944,
          "vulnerability_to_line": 952,
          "vulnerability_code": "    function delegateToViewImplementation(bytes memory data) public view returns (bytes memory) {\n\n        (bool success, bytes memory returnData) = address(this).staticcall(abi.encodeWithSignature(\"delegateToImplementation(bytes)\", data));\n\n        assembly {\n\n            if eq(success, 0) {\n\n                revert(add(returnData, 0x20), returndatasize)\n\n            }\n\n        }\n\n        return abi.decode(returnData, (bytes));\n",
          "message": "ABep20Delegator.delegateToViewImplementation (ABep20DelegatorCertora.sol#944-952) is declared view but contains assembly code\n"
        },
        {
          "name": "erc20-interface",
          "vulnerability_from_line": 123,
          "vulnerability_to_line": 185,
          "vulnerability_code": "interface EIP20NonStandardInterface {\n\n\n\n    /**\n\n     * @notice Get the total number of tokens in circulation\n\n     * @return The supply of tokens\n\n     */\n\n    function totalSupply() external view returns (uint256);\n\n\n\n    /**\n\n     * @notice Gets the balance of the specified address\n\n     * @param owner The address from which the balance will be retrieved\n\n     * @return The balance\n\n     */\n\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n\n\n    ///\n\n    /// !!!!!!!!!!!!!!\n\n    /// !!! NOTICE !!! `transfer` does not return a value, in violation of the BEP-20 specification\n\n    /// !!!!!!!!!!!!!!\n\n    ///\n\n\n\n    /**\n\n      * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n\n      * @param dst The address of the destination account\n\n      * @param amount The number of tokens to transfer\n\n      */\n\n    function transfer(address dst, uint256 amount) external;\n\n\n\n    ///\n\n    /// !!!!!!!!!!!!!!\n\n    /// !!! NOTICE !!! `transferFrom` does not return a value, in violation of the BEP-20 specification\n\n    /// !!!!!!!!!!!!!!\n\n    ///\n\n\n\n    /**\n\n      * @notice Transfer `amount` tokens from `src` to `dst`\n\n      * @param src The address of the source account\n\n      * @param dst The address of the destination account\n\n      * @param amount The number of tokens to transfer\n\n      */\n\n    function transferFrom(address src, address dst, uint256 amount) external;\n\n\n\n    /**\n\n      * @notice Approve `spender` to transfer up to `amount` from `src`\n\n      * @dev This will overwrite the approval amount for `spender`\n\n      *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n\n      * @param spender The address of the account which may transfer tokens\n\n      * @param amount The number of tokens that are approved\n\n      * @return Whether or not the approval succeeded\n\n      */\n\n    function approve(address spender, uint256 amount) external returns (bool success);\n\n\n\n    /**\n\n      * @notice Get the current allowance from `owner` for `spender`\n\n      * @param owner The address of the account which owns the tokens to be spent\n\n      * @param spender The address of the account which may transfer tokens\n\n      * @return The number of tokens allowed to be spent\n\n      */\n\n    function allowance(address owner, address spender) external view returns (uint256 remaining);\n\n\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n",
          "message": "EIP20NonStandardInterface (ABep20DelegatorCertora.sol#123-185) has incorrect ERC20 function interface(s):\n\t-transfer (ABep20DelegatorCertora.sol#149)\n\t-transferFrom (ABep20DelegatorCertora.sol#163)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 2970,
          "vulnerability_to_line": 2982,
          "vulnerability_code": "    function _addReservesInternal(uint addAmount) internal nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n\n            return fail(Error(error), FailureInfo.ADD_RESERVES_ACCRUE_INTEREST_FAILED);\n\n        }\n\n\n\n        // _addReservesFresh emits reserve-addition-specific logs on errors, so we don't need to.\n\n        (error, ) = _addReservesFresh(addAmount);\n\n        return error;\n\n    }\n\n\n",
          "message": "Reentrancy in AToken._addReservesInternal (ABep20DelegatorCertora.sol#2970-2982):\n\tExternal calls:\n\t- error = accrueInterest() (ABep20DelegatorCertora.sol#2971-2972)\n\tState variables written after the call(s):\n\t- totalReserves (ABep20DelegatorCertora.sol#2978-2979)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 3033,
          "vulnerability_to_line": 3043,
          "vulnerability_code": "    function _reduceReserves(uint reduceAmount) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n\n            return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.\n\n        return _reduceReservesFresh(reduceAmount);\n\n    }\n\n\n",
          "message": "Reentrancy in AToken._reduceReserves (ABep20DelegatorCertora.sol#3033-3043):\n\tExternal calls:\n\t- error = accrueInterest() (ABep20DelegatorCertora.sol#3034-3035)\n\tState variables written after the call(s):\n\t- totalReserves (ABep20DelegatorCertora.sol#3040-3041)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 2902,
          "vulnerability_to_line": 2921,
          "vulnerability_code": "    function _setComptroller(ComptrollerInterface newComptroller) public returns (uint) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COMPTROLLER_OWNER_CHECK);\n\n        }\n\n\n\n        ComptrollerInterface oldComptroller = comptroller;\n\n        // Ensure invoke comptroller.isComptroller() returns true\n\n        require(newComptroller.isComptroller(), \"marker method returned false\");\n\n\n\n        // Set market's comptroller to newComptroller\n\n        comptroller = newComptroller;\n\n\n\n        // Emit NewComptroller(oldComptroller, newComptroller)\n\n        emit NewComptroller(oldComptroller, newComptroller);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Reentrancy in AToken._setComptroller (ABep20DelegatorCertora.sol#2902-2921):\n\tExternal calls:\n\t- require(bool,string)(newComptroller.isComptroller(),marker method returned false) (ABep20DelegatorCertora.sol#2910-2911)\n\tState variables written after the call(s):\n\t- comptroller (ABep20DelegatorCertora.sol#2913-2914)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 557,
          "vulnerability_to_line": 570,
          "vulnerability_code": "    function _setImplementation(address implementation_, bool allowResign, bytes memory becomeImplementationData) public {\n\n        require(msg.sender == admin, \"ABep20Delegator::_setImplementation: Caller must be admin\");\n\n\n\n        if (allowResign) {\n\n            delegateToImplementation(abi.encodeWithSignature(\"_resignImplementation()\"));\n\n        }\n\n\n\n        address oldImplementation = implementation;\n\n        implementation = implementation_;\n\n\n\n        delegateToImplementation(abi.encodeWithSignature(\"_becomeImplementation(bytes)\", becomeImplementationData));\n\n\n\n        emit NewImplementation(oldImplementation, implementation);\n",
          "message": "Reentrancy in ABep20Delegator._setImplementation (ABep20DelegatorCertora.sol#557-570):\n\tExternal calls:\n\t- delegateToImplementation(abi.encodeWithSignature(_resignImplementation())) (ABep20DelegatorCertora.sol#561)\n\tState variables written after the call(s):\n\t- implementation (ABep20DelegatorCertora.sol#565)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 3098,
          "vulnerability_to_line": 3108,
          "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n\n        return _setInterestRateModelFresh(newInterestRateModel);\n\n    }\n\n\n",
          "message": "Reentrancy in AToken._setInterestRateModel (ABep20DelegatorCertora.sol#3098-3108):\n\tExternal calls:\n\t- error = accrueInterest() (ABep20DelegatorCertora.sol#3099-3100)\n\t- _setInterestRateModelFresh(newInterestRateModel) (ABep20DelegatorCertora.sol#3105-3106)\n\tState variables written after the call(s):\n\t- interestRateModel (ABep20DelegatorCertora.sol#3105-3106)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 3114,
          "vulnerability_to_line": 3144,
          "vulnerability_code": "    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {\n\n\n\n        // Used to store old model for use in the event that is emitted on success\n\n        InterestRateModel oldInterestRateModel;\n\n\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);\n\n        }\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);\n\n        }\n\n\n\n        // Track the market's current interest rate model\n\n        oldInterestRateModel = interestRateModel;\n\n\n\n        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true\n\n        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n\n\n\n        // Set the interest rate model to newInterestRateModel\n\n        interestRateModel = newInterestRateModel;\n\n\n\n        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)\n\n        emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Reentrancy in AToken._setInterestRateModelFresh (ABep20DelegatorCertora.sol#3114-3144):\n\tExternal calls:\n\t- require(bool,string)(newInterestRateModel.isInterestRateModel(),marker method returned false) (ABep20DelegatorCertora.sol#3133-3135)\n\tState variables written after the call(s):\n\t- interestRateModel (ABep20DelegatorCertora.sol#3136-3138)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 2926,
          "vulnerability_to_line": 2936,
          "vulnerability_code": "    function _setReserveFactor(uint newReserveFactorMantissa) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.\n\n            return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.\n\n        return _setReserveFactorFresh(newReserveFactorMantissa);\n\n    }\n\n\n",
          "message": "Reentrancy in AToken._setReserveFactor (ABep20DelegatorCertora.sol#2926-2936):\n\tExternal calls:\n\t- error = accrueInterest() (ABep20DelegatorCertora.sol#2927-2928)\n\tState variables written after the call(s):\n\t- reserveFactorMantissa (ABep20DelegatorCertora.sol#2933-2934)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 2103,
          "vulnerability_to_line": 2181,
          "vulnerability_code": "    function accrueInterest() public returns (uint) {\n\n        /* Remember the initial block number */\n\n        uint currentBlockNumber = getBlockNumber();\n\n        uint accrualBlockNumberPrior = accrualBlockNumber;\n\n\n\n        /* Short-circuit accumulating 0 interest */\n\n        if (accrualBlockNumberPrior == currentBlockNumber) {\n\n            return uint(Error.NO_ERROR);\n\n        }\n\n\n\n        /* Read the previous values out of storage */\n\n        uint cashPrior = getCashPrior();\n\n        uint borrowsPrior = totalBorrows;\n\n        uint reservesPrior = totalReserves;\n\n        uint borrowIndexPrior = borrowIndex;\n\n\n\n        /* Calculate the current borrow interest rate */\n\n        uint borrowRateMantissa = interestRateModel.getBorrowRate(cashPrior, borrowsPrior, reservesPrior);\n\n        require(borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n\n\n\n        /* Calculate the number of blocks elapsed since the last accrual */\n\n        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);\n\n        require(mathErr == MathError.NO_ERROR, \"could not calculate block delta\");\n\n\n\n        /*\n\n         * Calculate the interest accumulated into borrows and reserves and the new index:\n\n         *  simpleInterestFactor = borrowRate * blockDelta\n\n         *  interestAccumulated = simpleInterestFactor * totalBorrows\n\n         *  totalBorrowsNew = interestAccumulated + totalBorrows\n\n         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves\n\n         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\n\n         */\n\n\n\n        Exp memory simpleInterestFactor;\n\n        uint interestAccumulated;\n\n        uint totalBorrowsNew;\n\n        uint totalReservesNew;\n\n        uint borrowIndexNew;\n\n\n\n        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa: borrowRateMantissa}), blockDelta);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED, uint(mathErr));\n\n        }\n\n\n\n        (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED, uint(mathErr));\n\n        }\n\n\n\n        (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED, uint(mathErr));\n\n        }\n\n\n\n        (mathErr, totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa: reserveFactorMantissa}), interestAccumulated, reservesPrior);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED, uint(mathErr));\n\n        }\n\n\n\n        (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndexPrior, borrowIndexPrior);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED, uint(mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accrualBlockNumber = currentBlockNumber;\n\n        borrowIndex = borrowIndexNew;\n\n        totalBorrows = totalBorrowsNew;\n\n        totalReserves = totalReservesNew;\n\n\n\n        /* We emit an AccrueInterest event */\n\n        emit AccrueInterest(cashPrior, interestAccumulated, borrowIndexNew, totalBorrowsNew);\n\n\n\n        return uint(Error.NO_ERROR);\n",
          "message": "Reentrancy in AToken.accrueInterest (ABep20DelegatorCertora.sol#2103-2181):\n\tExternal calls:\n\t- borrowRateMantissa = interestRateModel.getBorrowRate(cashPrior,borrowsPrior,reservesPrior) (ABep20DelegatorCertora.sol#2120)\n\tState variables written after the call(s):\n\t- accrualBlockNumber (ABep20DelegatorCertora.sol#2172)\n\t- borrowIndex (ABep20DelegatorCertora.sol#2173)\n\t- totalBorrows (ABep20DelegatorCertora.sol#2174)\n\t- totalReserves (ABep20DelegatorCertora.sol#2175)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 2434,
          "vulnerability_to_line": 2442,
          "vulnerability_code": "    function borrowInternal(uint borrowAmount) internal nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n\n            return fail(Error(error), FailureInfo.BORROW_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // borrowFresh emits borrow-specific logs on errors, so we don't need to\n\n        return borrowFresh(msg.sender, borrowAmount);\n",
          "message": "Reentrancy in AToken.borrowInternal (ABep20DelegatorCertora.sol#2434-2442):\n\tExternal calls:\n\t- error = accrueInterest() (ABep20DelegatorCertora.sol#2435)\n\t- borrowFresh(msg.sender,borrowAmount) (ABep20DelegatorCertora.sol#2441)\n\tState variables written after the call(s):\n\t- totalBorrows (ABep20DelegatorCertora.sol#2441)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 521,
          "vulnerability_to_line": 549,
          "vulnerability_code": "    constructor(address underlying_,\n\n                ComptrollerInterface comptroller_,\n\n                InterestRateModel interestRateModel_,\n\n                uint initialExchangeRateMantissa_,\n\n                string memory name_,\n\n                string memory symbol_,\n\n                uint8 decimals_,\n\n                address payable admin_,\n\n                address implementation_,\n\n                bytes memory becomeImplementationData) public {\n\n        // Creator of the contract is admin during initialization\n\n        admin = msg.sender;\n\n\n\n        // First delegate gets to initialize the delegator (i.e. storage contract)\n\n        delegateTo(implementation_, abi.encodeWithSignature(\"initialize(address,address,address,uint256,string,string,uint8)\",\n\n                                                            underlying_,\n\n                                                            comptroller_,\n\n                                                            interestRateModel_,\n\n                                                            initialExchangeRateMantissa_,\n\n                                                            name_,\n\n                                                            symbol_,\n\n                                                            decimals_));\n\n\n\n        // New implementations always get set via the settor (post-initialize)\n\n        _setImplementation(implementation_, false, becomeImplementationData);\n\n\n\n        // Set the proper admin now that initialization is done\n\n        admin = admin_;\n",
          "message": "Reentrancy in ABep20Delegator.constructor (ABep20DelegatorCertora.sol#521-549):\n\tExternal calls:\n\t- delegateTo(implementation_,abi.encodeWithSignature(initialize(address,address,address,uint256,string,string,uint8),underlying_,comptroller_,interestRateModel_,initialExchangeRateMantissa_,name_,symbol_,decimals_)) (ABep20DelegatorCertora.sol#535-542)\n\t- _setImplementation(implementation_,false,becomeImplementationData) (ABep20DelegatorCertora.sol#545)\n\tState variables written after the call(s):\n\t- admin (ABep20DelegatorCertora.sol#548)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 3424,
          "vulnerability_to_line": 3443,
          "vulnerability_code": "    constructor(address underlying_,\n\n                ComptrollerInterface comptroller_,\n\n                InterestRateModel interestRateModel_,\n\n                uint initialExchangeRateMantissa_,\n\n                string memory name_,\n\n                string memory symbol_,\n\n                uint8 decimals_,\n\n                address payable admin_) public {\n\n        // Creator of the contract is admin during initialization\n\n        admin = msg.sender;\n\n\n\n        // Initialize the market\n\n        initialize(underlying_, comptroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_);\n\n\n\n        // Set the proper admin now that initialization is done\n\n        admin = admin_;\n\n    }\n\n}\n\n\n",
          "message": "Reentrancy in ABep20Immutable.constructor (ABep20DelegatorCertora.sol#3424-3443):\n\tExternal calls:\n\t- initialize(underlying_,comptroller_,interestRateModel_,initialExchangeRateMantissa_,name_,symbol_,decimals_) (ABep20DelegatorCertora.sol#3436-3438)\n\tState variables written after the call(s):\n\t- admin (ABep20DelegatorCertora.sol#3439-3440)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 1744,
          "vulnerability_to_line": 1775,
          "vulnerability_code": "    function initialize(ComptrollerInterface comptroller_,\n\n                        InterestRateModel interestRateModel_,\n\n                        uint initialExchangeRateMantissa_,\n\n                        string memory name_,\n\n                        string memory symbol_,\n\n                        uint8 decimals_) public {\n\n        require(msg.sender == admin, \"only admin may initialize the market\");\n\n        require(accrualBlockNumber == 0 && borrowIndex == 0, \"market may only be initialized once\");\n\n\n\n        // Set initial exchange rate\n\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n\n        require(initialExchangeRateMantissa > 0, \"initial exchange rate must be greater than zero.\");\n\n\n\n        // Set the comptroller\n\n        uint err = _setComptroller(comptroller_);\n\n        require(err == uint(Error.NO_ERROR), \"setting comptroller failed\");\n\n\n\n        // Initialize block number and borrow index (block number mocks depend on comptroller being set)\n\n        accrualBlockNumber = getBlockNumber();\n\n        borrowIndex = mantissaOne;\n\n\n\n        // Set the interest rate model (depends on block number / borrow index)\n\n        err = _setInterestRateModelFresh(interestRateModel_);\n\n        require(err == uint(Error.NO_ERROR), \"setting interest rate model failed\");\n\n\n\n        name = name_;\n\n        symbol = symbol_;\n\n        decimals = decimals_;\n\n\n\n        // The counter starts true to prevent changing it from zero to non-zero (i.e. smaller cost/refund)\n\n        _notEntered = true;\n",
          "message": "Reentrancy in AToken.initialize (ABep20DelegatorCertora.sol#1744-1775):\n\tExternal calls:\n\t- err = _setComptroller(comptroller_) (ABep20DelegatorCertora.sol#1758)\n\tState variables written after the call(s):\n\t- accrualBlockNumber (ABep20DelegatorCertora.sol#1762)\n\t- borrowIndex (ABep20DelegatorCertora.sol#1763)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 2649,
          "vulnerability_to_line": 2664,
          "vulnerability_code": "    function liquidateBorrowInternal(address borrower, uint repayAmount, ATokenInterface aTokenCollateral) internal nonReentrant returns (uint, uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\n\n            return (fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED), 0);\n\n        }\n\n\n\n        error = aTokenCollateral.accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\n\n            return (fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED), 0);\n\n        }\n\n\n\n        // liquidateBorrowFresh emits borrow-specific logs on errors, so we don't need to\n\n        return liquidateBorrowFresh(msg.sender, borrower, repayAmount, aTokenCollateral);\n",
          "message": "Reentrancy in AToken.liquidateBorrowInternal (ABep20DelegatorCertora.sol#2649-2664):\n\tExternal calls:\n\t- error = accrueInterest() (ABep20DelegatorCertora.sol#2650)\n\t- error = aTokenCollateral.accrueInterest() (ABep20DelegatorCertora.sol#2656)\n\t- liquidateBorrowFresh(msg.sender,borrower,repayAmount,aTokenCollateral) (ABep20DelegatorCertora.sol#2663)\n\tState variables written after the call(s):\n\t- totalBorrows (ABep20DelegatorCertora.sol#2663)\n\t- totalReserves (ABep20DelegatorCertora.sol#2663)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 2333,
          "vulnerability_to_line": 2427,
          "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n\n\n\n        RedeemLocalVars memory vars;\n\n\n\n        /* exchangeRate = invoke Exchange Rate Stored() */\n\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* If redeemTokensIn > 0: */\n\n        if (redeemTokensIn > 0) {\n\n            /*\n\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\n\n             *  redeemTokens = redeemTokensIn\n\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n\n             */\n\n            vars.redeemTokens = redeemTokensIn;\n\n\n\n            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED, uint(vars.mathErr));\n\n            }\n\n        } else {\n\n            /*\n\n             * We get the current exchange rate and calculate the amount to be redeemed:\n\n             *  redeemTokens = redeemAmountIn / exchangeRate\n\n             *  redeemAmount = redeemAmountIn\n\n             */\n\n\n\n            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED, uint(vars.mathErr));\n\n            }\n\n\n\n            vars.redeemAmount = redeemAmountIn;\n\n        }\n\n\n\n        /* Fail if redeem not allowed */\n\n        uint allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);\n\n        }\n\n\n\n        /*\n\n         * We calculate the new total supply and redeemer balance, checking for underflow:\n\n         *  totalSupplyNew = totalSupply - redeemTokens\n\n         *  accountTokensNew = accountTokens[redeemer] - redeemTokens\n\n         */\n\n        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* Fail gracefully if protocol has insufficient cash */\n\n        if (getCashPrior() < vars.redeemAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We invoke doTransferOut for the redeemer and the redeemAmount.\n\n         *  Note: The aToken must handle variations between BEP-20 and BNB underlying.\n\n         *  On success, the aToken has redeemAmount less of cash.\n\n         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n\n         */\n\n        doTransferOut(redeemer, vars.redeemAmount);\n\n\n\n        /* We write previously calculated values into storage */\n\n        totalSupply = vars.totalSupplyNew;\n\n        accountTokens[redeemer] = vars.accountTokensNew;\n\n\n\n        /* We emit a Transfer event, and a Redeem event */\n\n        emit Transfer(redeemer, address(this), vars.redeemTokens);\n\n        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        /* We call the defense hook */\n\n        comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        return uint(Error.NO_ERROR);\n",
          "message": "Reentrancy in AToken.redeemFresh (ABep20DelegatorCertora.sol#2333-2427):\n\tExternal calls:\n\t- allowed = comptroller.redeemAllowed(address(this),redeemer,vars.redeemTokens) (ABep20DelegatorCertora.sol#2373)\n\tState variables written after the call(s):\n\t- totalSupply (ABep20DelegatorCertora.sol#2416)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 2544,
          "vulnerability_to_line": 2552,
          "vulnerability_code": "    function repayBorrowBehalfInternal(address borrower, uint repayAmount) internal nonReentrant returns (uint, uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n\n            return (fail(Error(error), FailureInfo.REPAY_BEHALF_ACCRUE_INTEREST_FAILED), 0);\n\n        }\n\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n\n        return repayBorrowFresh(msg.sender, borrower, repayAmount);\n",
          "message": "Reentrancy in AToken.repayBorrowBehalfInternal (ABep20DelegatorCertora.sol#2544-2552):\n\tExternal calls:\n\t- error = accrueInterest() (ABep20DelegatorCertora.sol#2545)\n\t- repayBorrowFresh(msg.sender,borrower,repayAmount) (ABep20DelegatorCertora.sol#2551)\n\tState variables written after the call(s):\n\t- totalBorrows (ABep20DelegatorCertora.sol#2551)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 2528,
          "vulnerability_to_line": 2536,
          "vulnerability_code": "    function repayBorrowInternal(uint repayAmount) internal nonReentrant returns (uint, uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n\n            return (fail(Error(error), FailureInfo.REPAY_BORROW_ACCRUE_INTEREST_FAILED), 0);\n\n        }\n\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n\n        return repayBorrowFresh(msg.sender, msg.sender, repayAmount);\n",
          "message": "Reentrancy in AToken.repayBorrowInternal (ABep20DelegatorCertora.sol#2528-2536):\n\tExternal calls:\n\t- error = accrueInterest() (ABep20DelegatorCertora.sol#2529)\n\t- repayBorrowFresh(msg.sender,msg.sender,repayAmount) (ABep20DelegatorCertora.sol#2535)\n\tState variables written after the call(s):\n\t- totalBorrows (ABep20DelegatorCertora.sol#2535)\n"
        },
        {
          "name": "uninitialized-local",
          "vulnerability_from_line": 2474,
          "vulnerability_to_line": null,
          "vulnerability_code": "        BorrowLocalVars memory vars;\n",
          "message": "vars in AToken.borrowFresh (ABep20DelegatorCertora.sol#2474) is a local variable never initialiazed\n"
        },
        {
          "name": "uninitialized-local",
          "vulnerability_from_line": 2991,
          "vulnerability_to_line": 2993,
          "vulnerability_code": "        uint actualAddAmount;\n\n\n",
          "message": "actualAddAmount in AToken._addReservesFresh (ABep20DelegatorCertora.sol#2991-2993) is a local variable never initialiazed\n"
        },
        {
          "name": "uninitialized-local",
          "vulnerability_from_line": 2336,
          "vulnerability_to_line": null,
          "vulnerability_code": "        RedeemLocalVars memory vars;\n",
          "message": "vars in AToken.redeemFresh (ABep20DelegatorCertora.sol#2336) is a local variable never initialiazed\n"
        },
        {
          "name": "uninitialized-local",
          "vulnerability_from_line": 2228,
          "vulnerability_to_line": null,
          "vulnerability_code": "        MintLocalVars memory vars;\n",
          "message": "vars in AToken.mintFresh (ABep20DelegatorCertora.sol#2228) is a local variable never initialiazed\n"
        },
        {
          "name": "uninitialized-local",
          "vulnerability_from_line": 2584,
          "vulnerability_to_line": null,
          "vulnerability_code": "        RepayBorrowLocalVars memory vars;\n",
          "message": "vars in AToken.repayBorrowFresh (ABep20DelegatorCertora.sol#2584) is a local variable never initialiazed\n"
        },
        {
          "name": "uninitialized-local",
          "vulnerability_from_line": 2793,
          "vulnerability_to_line": null,
          "vulnerability_code": "        SeizeInternalLocalVars memory vars;\n",
          "message": "vars in AToken.seizeInternal (ABep20DelegatorCertora.sol#2793) is a local variable never initialiazed\n"
        },
        {
          "name": "unused-return",
          "vulnerability_from_line": 3204,
          "vulnerability_to_line": 3219,
          "vulnerability_code": "    function initialize(address underlying_,\n\n                        ComptrollerInterface comptroller_,\n\n                        InterestRateModel interestRateModel_,\n\n                        uint initialExchangeRateMantissa_,\n\n                        string memory name_,\n\n                        string memory symbol_,\n\n                        uint8 decimals_) public {\n\n        // AToken initialize does the bulk of the work\n\n        super.initialize(comptroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_);\n\n\n\n        // Set underlying and sanity check it\n\n        underlying = underlying_;\n\n        EIP20Interface(underlying).totalSupply();\n\n    }\n\n\n",
          "message": "ABep20.initialize (ABep20DelegatorCertora.sol#3204-3219) does not use the value returned by external calls:\n\t-EIP20Interface(underlying).totalSupply() (ABep20DelegatorCertora.sol#3216-3217)\n"
        },
        {
          "name": "shadowing-local",
          "vulnerability_from_line": 1659,
          "vulnerability_to_line": null,
          "vulnerability_code": "        (MathError err, Exp memory fraction) = divScalarByExp(scalar, divisor);\n",
          "message": "Exponential.divScalarByExpTruncate.fraction (local variable @ ABep20DelegatorCertora.sol#1659) shadows:\n\t- ExponentialNoError.fraction (function @ ABep20DelegatorCertora.sol#1531-1533)\n"
        },
        {
          "name": "shadowing-local",
          "vulnerability_from_line": 3531,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function redeemFreshPub(address payable redeemer, uint redeemTokens, uint redeemUnderlying) public returns (uint) {\n",
          "message": "ABep20DelegatorCertora.redeemFreshPub.redeemUnderlying (local variable @ ABep20DelegatorCertora.sol#3531) shadows:\n\t- ABep20Delegator.redeemUnderlying (function @ ABep20DelegatorCertora.sol#600-603)\n\t- ABep20Interface.redeemUnderlying (function @ ABep20DelegatorCertora.sol#449)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 2457,
          "vulnerability_to_line": 2521,
          "vulnerability_code": "    function borrowFresh(address payable borrower, uint borrowAmount) internal returns (uint) {\n\n        /* Fail if borrow not allowed */\n\n        uint allowed = comptroller.borrowAllowed(address(this), borrower, borrowAmount);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.BORROW_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.BORROW_FRESHNESS_CHECK);\n\n        }\n\n\n\n        /* Fail gracefully if protocol has insufficient underlying cash */\n\n        if (getCashPrior() < borrowAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.BORROW_CASH_NOT_AVAILABLE);\n\n        }\n\n\n\n        BorrowLocalVars memory vars;\n\n\n\n        /*\n\n         * We calculate the new borrower and total borrow balances, failing on overflow:\n\n         *  accountBorrowsNew = accountBorrows + borrowAmount\n\n         *  totalBorrowsNew = totalBorrows + borrowAmount\n\n         */\n\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We invoke doTransferOut for the borrower and the borrowAmount.\n\n         *  Note: The aToken must handle variations between BEP-20 and BNB underlying.\n\n         *  On success, the aToken borrowAmount less of cash.\n\n         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n\n         */\n\n        doTransferOut(borrower, borrowAmount);\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n\n        accountBorrows[borrower].interestIndex = borrowIndex;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n\n\n        /* We emit a Borrow event */\n\n        emit Borrow(borrower, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n\n\n        /* We call the defense hook */\n\n        // unused function\n\n        // comptroller.borrowVerify(address(this), borrower, borrowAmount);\n\n\n\n        return uint(Error.NO_ERROR);\n",
          "message": "Reentrancy in AToken.borrowFresh (ABep20DelegatorCertora.sol#2457-2521):\n\tExternal calls:\n\t- allowed = comptroller.borrowAllowed(address(this),borrower,borrowAmount) (ABep20DelegatorCertora.sol#2459)\n\tState variables written after the call(s):\n\t- accountBorrows (ABep20DelegatorCertora.sol#2509)\n\t- accountBorrows (ABep20DelegatorCertora.sol#2510)\n\t- totalBorrows (ABep20DelegatorCertora.sol#2511)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 1744,
          "vulnerability_to_line": 1775,
          "vulnerability_code": "    function initialize(ComptrollerInterface comptroller_,\n\n                        InterestRateModel interestRateModel_,\n\n                        uint initialExchangeRateMantissa_,\n\n                        string memory name_,\n\n                        string memory symbol_,\n\n                        uint8 decimals_) public {\n\n        require(msg.sender == admin, \"only admin may initialize the market\");\n\n        require(accrualBlockNumber == 0 && borrowIndex == 0, \"market may only be initialized once\");\n\n\n\n        // Set initial exchange rate\n\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n\n        require(initialExchangeRateMantissa > 0, \"initial exchange rate must be greater than zero.\");\n\n\n\n        // Set the comptroller\n\n        uint err = _setComptroller(comptroller_);\n\n        require(err == uint(Error.NO_ERROR), \"setting comptroller failed\");\n\n\n\n        // Initialize block number and borrow index (block number mocks depend on comptroller being set)\n\n        accrualBlockNumber = getBlockNumber();\n\n        borrowIndex = mantissaOne;\n\n\n\n        // Set the interest rate model (depends on block number / borrow index)\n\n        err = _setInterestRateModelFresh(interestRateModel_);\n\n        require(err == uint(Error.NO_ERROR), \"setting interest rate model failed\");\n\n\n\n        name = name_;\n\n        symbol = symbol_;\n\n        decimals = decimals_;\n\n\n\n        // The counter starts true to prevent changing it from zero to non-zero (i.e. smaller cost/refund)\n\n        _notEntered = true;\n",
          "message": "Reentrancy in AToken.initialize (ABep20DelegatorCertora.sol#1744-1775):\n\tExternal calls:\n\t- err = _setComptroller(comptroller_) (ABep20DelegatorCertora.sol#1758)\n\t- err = _setInterestRateModelFresh(interestRateModel_) (ABep20DelegatorCertora.sol#1766)\n\tState variables written after the call(s):\n\t- _notEntered (ABep20DelegatorCertora.sol#1774)\n\t- decimals (ABep20DelegatorCertora.sol#1771)\n\t- name (ABep20DelegatorCertora.sol#1769)\n\t- symbol (ABep20DelegatorCertora.sol#1770)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 3204,
          "vulnerability_to_line": 3219,
          "vulnerability_code": "    function initialize(address underlying_,\n\n                        ComptrollerInterface comptroller_,\n\n                        InterestRateModel interestRateModel_,\n\n                        uint initialExchangeRateMantissa_,\n\n                        string memory name_,\n\n                        string memory symbol_,\n\n                        uint8 decimals_) public {\n\n        // AToken initialize does the bulk of the work\n\n        super.initialize(comptroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_);\n\n\n\n        // Set underlying and sanity check it\n\n        underlying = underlying_;\n\n        EIP20Interface(underlying).totalSupply();\n\n    }\n\n\n",
          "message": "Reentrancy in ABep20.initialize (ABep20DelegatorCertora.sol#3204-3219):\n\tExternal calls:\n\t- super.initialize(comptroller_,interestRateModel_,initialExchangeRateMantissa_,name_,symbol_,decimals_) (ABep20DelegatorCertora.sol#3212-3214)\n\tState variables written after the call(s):\n\t- underlying (ABep20DelegatorCertora.sol#3215-3216)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 2216,
          "vulnerability_to_line": 2281,
          "vulnerability_code": "    function mintFresh(address minter, uint mintAmount) internal returns (uint, uint) {\n\n        /* Fail if mint not allowed */\n\n        uint allowed = comptroller.mintAllowed(address(this), minter, mintAmount);\n\n        if (allowed != 0) {\n\n            return (failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.MINT_COMPTROLLER_REJECTION, allowed), 0);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return (fail(Error.MARKET_NOT_FRESH, FailureInfo.MINT_FRESHNESS_CHECK), 0);\n\n        }\n\n\n\n        MintLocalVars memory vars;\n\n\n\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return (failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr)), 0);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         *  We call `doTransferIn` for the minter and the mintAmount.\n\n         *  Note: The aToken must handle variations between BEP-20 and BNB underlying.\n\n         *  `doTransferIn` reverts if anything goes wrong, since we can't be sure if\n\n         *  side-effects occurred. The function returns the amount actually transferred,\n\n         *  in case of a fee. On success, the aToken holds an additional `actualMintAmount`\n\n         *  of cash.\n\n         */\n\n        vars.actualMintAmount = doTransferIn(minter, mintAmount);\n\n\n\n        /*\n\n         * We get the current exchange rate and calculate the number of aTokens to be minted:\n\n         *  mintTokens = actualMintAmount / exchangeRate\n\n         */\n\n\n\n        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(vars.actualMintAmount, Exp({mantissa: vars.exchangeRateMantissa}));\n\n        require(vars.mathErr == MathError.NO_ERROR, \"MINT_EXCHANGE_CALCULATION_FAILED\");\n\n\n\n        /*\n\n         * We calculate the new total supply of aTokens and minter token balance, checking for overflow:\n\n         *  totalSupplyNew = totalSupply + mintTokens\n\n         *  accountTokensNew = accountTokens[minter] + mintTokens\n\n         */\n\n        (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);\n\n        require(vars.mathErr == MathError.NO_ERROR, \"MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED\");\n\n\n\n        (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);\n\n        require(vars.mathErr == MathError.NO_ERROR, \"MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED\");\n\n\n\n        /* We write previously calculated values into storage */\n\n        totalSupply = vars.totalSupplyNew;\n\n        accountTokens[minter] = vars.accountTokensNew;\n\n\n\n        /* We emit a Mint event, and a Transfer event */\n\n        emit Mint(minter, vars.actualMintAmount, vars.mintTokens);\n\n        emit Transfer(address(this), minter, vars.mintTokens);\n\n\n\n        /* We call the defense hook */\n\n        // unused function\n\n        // comptroller.mintVerify(address(this), minter, vars.actualMintAmount, vars.mintTokens);\n\n\n\n        return (uint(Error.NO_ERROR), vars.actualMintAmount);\n",
          "message": "Reentrancy in AToken.mintFresh (ABep20DelegatorCertora.sol#2216-2281):\n\tExternal calls:\n\t- allowed = comptroller.mintAllowed(address(this),minter,mintAmount) (ABep20DelegatorCertora.sol#2218)\n\tState variables written after the call(s):\n\t- accountTokens (ABep20DelegatorCertora.sol#2270)\n\t- totalSupply (ABep20DelegatorCertora.sol#2269)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 2333,
          "vulnerability_to_line": 2427,
          "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n\n\n\n        RedeemLocalVars memory vars;\n\n\n\n        /* exchangeRate = invoke Exchange Rate Stored() */\n\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* If redeemTokensIn > 0: */\n\n        if (redeemTokensIn > 0) {\n\n            /*\n\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\n\n             *  redeemTokens = redeemTokensIn\n\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n\n             */\n\n            vars.redeemTokens = redeemTokensIn;\n\n\n\n            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED, uint(vars.mathErr));\n\n            }\n\n        } else {\n\n            /*\n\n             * We get the current exchange rate and calculate the amount to be redeemed:\n\n             *  redeemTokens = redeemAmountIn / exchangeRate\n\n             *  redeemAmount = redeemAmountIn\n\n             */\n\n\n\n            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED, uint(vars.mathErr));\n\n            }\n\n\n\n            vars.redeemAmount = redeemAmountIn;\n\n        }\n\n\n\n        /* Fail if redeem not allowed */\n\n        uint allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);\n\n        }\n\n\n\n        /*\n\n         * We calculate the new total supply and redeemer balance, checking for underflow:\n\n         *  totalSupplyNew = totalSupply - redeemTokens\n\n         *  accountTokensNew = accountTokens[redeemer] - redeemTokens\n\n         */\n\n        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* Fail gracefully if protocol has insufficient cash */\n\n        if (getCashPrior() < vars.redeemAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We invoke doTransferOut for the redeemer and the redeemAmount.\n\n         *  Note: The aToken must handle variations between BEP-20 and BNB underlying.\n\n         *  On success, the aToken has redeemAmount less of cash.\n\n         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n\n         */\n\n        doTransferOut(redeemer, vars.redeemAmount);\n\n\n\n        /* We write previously calculated values into storage */\n\n        totalSupply = vars.totalSupplyNew;\n\n        accountTokens[redeemer] = vars.accountTokensNew;\n\n\n\n        /* We emit a Transfer event, and a Redeem event */\n\n        emit Transfer(redeemer, address(this), vars.redeemTokens);\n\n        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        /* We call the defense hook */\n\n        comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        return uint(Error.NO_ERROR);\n",
          "message": "Reentrancy in AToken.redeemFresh (ABep20DelegatorCertora.sol#2333-2427):\n\tExternal calls:\n\t- allowed = comptroller.redeemAllowed(address(this),redeemer,vars.redeemTokens) (ABep20DelegatorCertora.sol#2373)\n\tState variables written after the call(s):\n\t- accountTokens (ABep20DelegatorCertora.sol#2417)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 2572,
          "vulnerability_to_line": 2639,
          "vulnerability_code": "    function repayBorrowFresh(address payer, address borrower, uint repayAmount) internal returns (uint, uint) {\n\n        /* Fail if repayBorrow not allowed */\n\n        uint allowed = comptroller.repayBorrowAllowed(address(this), payer, borrower, repayAmount);\n\n        if (allowed != 0) {\n\n            return (failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REPAY_BORROW_COMPTROLLER_REJECTION, allowed), 0);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return (fail(Error.MARKET_NOT_FRESH, FailureInfo.REPAY_BORROW_FRESHNESS_CHECK), 0);\n\n        }\n\n\n\n        RepayBorrowLocalVars memory vars;\n\n\n\n        /* We remember the original borrowerIndex for verification purposes */\n\n        vars.borrowerIndex = accountBorrows[borrower].interestIndex;\n\n\n\n        /* We fetch the amount the borrower owes, with accumulated interest */\n\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return (failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr)), 0);\n\n        }\n\n\n\n        /* If repayAmount == -1, repayAmount = accountBorrows */\n\n        if (repayAmount == uint(-1)) {\n\n            vars.repayAmount = vars.accountBorrows;\n\n        } else {\n\n            vars.repayAmount = repayAmount;\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We call doTransferIn for the payer and the repayAmount\n\n         *  Note: The aToken must handle variations between BEP-20 and BNB underlying.\n\n         *  On success, the aToken holds an additional repayAmount of cash.\n\n         *  doTransferIn reverts if anything goes wrong, since we can't be sure if side effects occurred.\n\n         *   it returns the amount actually transferred, in case of a fee.\n\n         */\n\n        vars.actualRepayAmount = doTransferIn(payer, vars.repayAmount);\n\n\n\n        /*\n\n         * We calculate the new borrower and total borrow balances, failing on underflow:\n\n         *  accountBorrowsNew = accountBorrows - actualRepayAmount\n\n         *  totalBorrowsNew = totalBorrows - actualRepayAmount\n\n         */\n\n        (vars.mathErr, vars.accountBorrowsNew) = subUInt(vars.accountBorrows, vars.actualRepayAmount);\n\n        require(vars.mathErr == MathError.NO_ERROR, \"REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED\");\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = subUInt(totalBorrows, vars.actualRepayAmount);\n\n        require(vars.mathErr == MathError.NO_ERROR, \"REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED\");\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n\n        accountBorrows[borrower].interestIndex = borrowIndex;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n\n\n        /* We emit a RepayBorrow event */\n\n        emit RepayBorrow(payer, borrower, vars.actualRepayAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n\n\n        /* We call the defense hook */\n\n        // unused function\n\n        // comptroller.repayBorrowVerify(address(this), payer, borrower, vars.actualRepayAmount, vars.borrowerIndex);\n\n\n\n        return (uint(Error.NO_ERROR), vars.actualRepayAmount);\n",
          "message": "Reentrancy in AToken.repayBorrowFresh (ABep20DelegatorCertora.sol#2572-2639):\n\tExternal calls:\n\t- allowed = comptroller.repayBorrowAllowed(address(this),payer,borrower,repayAmount) (ABep20DelegatorCertora.sol#2574)\n\tState variables written after the call(s):\n\t- accountBorrows (ABep20DelegatorCertora.sol#2627)\n\t- accountBorrows (ABep20DelegatorCertora.sol#2628)\n\t- totalBorrows (ABep20DelegatorCertora.sol#2629)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 2781,
          "vulnerability_to_line": 2841,
          "vulnerability_code": "    function seizeInternal(address seizerToken, address liquidator, address borrower, uint seizeTokens) internal returns (uint) {\n\n        /* Fail if seize not allowed */\n\n        uint allowed = comptroller.seizeAllowed(address(this), seizerToken, liquidator, borrower, seizeTokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_SEIZE_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Fail if borrower = liquidator */\n\n        if (borrower == liquidator) {\n\n            return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER);\n\n        }\n\n\n\n        SeizeInternalLocalVars memory vars;\n\n\n\n        /*\n\n         * We calculate the new borrower and liquidator token balances, failing on underflow/overflow:\n\n         *  borrowerTokensNew = accountTokens[borrower] - seizeTokens\n\n         *  liquidatorTokensNew = accountTokens[liquidator] + seizeTokens\n\n         */\n\n        (vars.mathErr, vars.borrowerTokensNew) = subUInt(accountTokens[borrower], seizeTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        vars.protocolSeizeTokens = mul_(seizeTokens, Exp({mantissa: protocolSeizeShareMantissa}));\n\n        vars.liquidatorSeizeTokens = sub_(seizeTokens, vars.protocolSeizeTokens);\n\n\n\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n\n        require(vars.mathErr == MathError.NO_ERROR, \"exchange rate math error\");\n\n\n\n        vars.protocolSeizeAmount = mul_ScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), vars.protocolSeizeTokens);\n\n\n\n        vars.totalReservesNew = add_(totalReserves, vars.protocolSeizeAmount);\n\n        vars.totalSupplyNew = sub_(totalSupply, vars.protocolSeizeTokens);\n\n\n\n        (vars.mathErr, vars.liquidatorTokensNew) = addUInt(accountTokens[liquidator], vars.liquidatorSeizeTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /* We write the previously calculated values into storage */\n\n        totalReserves = vars.totalReservesNew;\n\n        totalSupply = vars.totalSupplyNew;\n\n        accountTokens[borrower] = vars.borrowerTokensNew;\n\n        accountTokens[liquidator] = vars.liquidatorTokensNew;\n\n\n\n        /* Emit a Transfer event */\n\n        emit Transfer(borrower, liquidator, vars.liquidatorSeizeTokens);\n\n        emit Transfer(borrower, address(this), vars.protocolSeizeTokens);\n\n        emit ReservesAdded(address(this), vars.protocolSeizeAmount, vars.totalReservesNew);\n\n\n\n        /* We call the defense hook */\n\n        // unused function\n\n        // comptroller.seizeVerify(address(this), seizerToken, liquidator, borrower, seizeTokens);\n\n\n\n        return uint(Error.NO_ERROR);\n",
          "message": "Reentrancy in AToken.seizeInternal (ABep20DelegatorCertora.sol#2781-2841):\n\tExternal calls:\n\t- allowed = comptroller.seizeAllowed(address(this),seizerToken,liquidator,borrower,seizeTokens) (ABep20DelegatorCertora.sol#2783)\n\tState variables written after the call(s):\n\t- accountTokens (ABep20DelegatorCertora.sol#2828)\n\t- accountTokens (ABep20DelegatorCertora.sol#2829)\n\t- totalReserves (ABep20DelegatorCertora.sol#2826)\n\t- totalSupply (ABep20DelegatorCertora.sol#2827)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 1786,
          "vulnerability_to_line": 1846,
          "vulnerability_code": "    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (uint) {\n\n        /* Fail if transfer not allowed */\n\n        uint allowed = comptroller.transferAllowed(address(this), src, dst, tokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.TRANSFER_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Do not allow self-transfers */\n\n        if (src == dst) {\n\n            return fail(Error.BAD_INPUT, FailureInfo.TRANSFER_NOT_ALLOWED);\n\n        }\n\n\n\n        /* Get the allowance, infinite for the account owner */\n\n        uint startingAllowance = 0;\n\n        if (spender == src) {\n\n            startingAllowance = uint(-1);\n\n        } else {\n\n            startingAllowance = transferAllowances[src][spender];\n\n        }\n\n\n\n        /* Do the calculations, checking for {under,over}flow */\n\n        MathError mathErr;\n\n        uint allowanceNew;\n\n        uint sraTokensNew;\n\n        uint dstTokensNew;\n\n\n\n        (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ALLOWED);\n\n        }\n\n\n\n        (mathErr, sraTokensNew) = subUInt(accountTokens[src], tokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ENOUGH);\n\n        }\n\n\n\n        (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_TOO_MUCH);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        accountTokens[src] = sraTokensNew;\n\n        accountTokens[dst] = dstTokensNew;\n\n\n\n        /* Eat some of the allowance (if necessary) */\n\n        if (startingAllowance != uint(-1)) {\n\n            transferAllowances[src][spender] = allowanceNew;\n\n        }\n\n\n\n        /* We emit a Transfer event */\n\n        emit Transfer(src, dst, tokens);\n\n\n\n        // unused function\n\n        // comptroller.transferVerify(address(this), src, dst, tokens);\n\n\n\n        return uint(Error.NO_ERROR);\n",
          "message": "Reentrancy in AToken.transferTokens (ABep20DelegatorCertora.sol#1786-1846):\n\tExternal calls:\n\t- allowed = comptroller.transferAllowed(address(this),src,dst,tokens) (ABep20DelegatorCertora.sol#1788)\n\tState variables written after the call(s):\n\t- accountTokens (ABep20DelegatorCertora.sol#1831)\n\t- accountTokens (ABep20DelegatorCertora.sol#1832)\n\t- transferAllowances (ABep20DelegatorCertora.sol#1836)\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 917,
          "vulnerability_to_line": 925,
          "vulnerability_code": "    function delegateTo(address callee, bytes memory data) internal returns (bytes memory) {\n\n        (bool success, bytes memory returnData) = callee.delegatecall(data);\n\n        assembly {\n\n            if eq(success, 0) {\n\n                revert(add(returnData, 0x20), returndatasize)\n\n            }\n\n        }\n\n        return returnData;\n",
          "message": "ABep20Delegator.delegateTo uses assembly (ABep20DelegatorCertora.sol#917-925)\n\t- ABep20DelegatorCertora.sol#919-923\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 944,
          "vulnerability_to_line": 952,
          "vulnerability_code": "    function delegateToViewImplementation(bytes memory data) public view returns (bytes memory) {\n\n        (bool success, bytes memory returnData) = address(this).staticcall(abi.encodeWithSignature(\"delegateToImplementation(bytes)\", data));\n\n        assembly {\n\n            if eq(success, 0) {\n\n                revert(add(returnData, 0x20), returndatasize)\n\n            }\n\n        }\n\n        return abi.decode(returnData, (bytes));\n",
          "message": "ABep20Delegator.delegateToViewImplementation uses assembly (ABep20DelegatorCertora.sol#944-952)\n\t- ABep20DelegatorCertora.sol#946-950\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 958,
          "vulnerability_to_line": 972,
          "vulnerability_code": "    function () external payable {\n\n        require(msg.value == 0,\"ABep20Delegator:fallback: cannot send value to fallback\");\n\n\n\n        // delegate all other functions to current implementation\n\n        (bool success, ) = implementation.delegatecall(msg.data);\n\n\n\n        assembly {\n\n            let free_mem_ptr := mload(0x40)\n\n            returndatacopy(free_mem_ptr, 0, returndatasize)\n\n\n\n            switch success\n\n            case 0 { revert(free_mem_ptr, returndatasize) }\n\n            default { return(free_mem_ptr, returndatasize) }\n\n        }\n",
          "message": "ABep20Delegator.fallback uses assembly (ABep20DelegatorCertora.sol#958-972)\n\t- ABep20DelegatorCertora.sol#964-971\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 3335,
          "vulnerability_to_line": 3362,
          "vulnerability_code": "    function doTransferIn(address from, uint amount) internal returns (uint) {\n\n        EIP20NonStandardInterface token = EIP20NonStandardInterface(underlying);\n\n        uint balanceBefore = EIP20Interface(underlying).balanceOf(address(this));\n\n        token.transferFrom(from, address(this), amount);\n\n\n\n        bool success;\n\n        assembly {\n\n            switch returndatasize()\n\n                case 0 {                       // This is a non-standard BEP-20\n\n                    success := not(0)          // set success to true\n\n                }\n\n                case 32 {                      // This is a compliant BEP-20\n\n                    returndatacopy(0, 0, 32)\n\n                    success := mload(0)        // Set `success = returndata` of external call\n\n                }\n\n                default {                      // This is an excessively non-compliant BEP-20, revert.\n\n                    revert(0, 0)\n\n                }\n\n        }\n\n        require(success, \"TOKEN_TRANSFER_IN_FAILED\");\n\n\n\n        // Calculate the amount that was *actually* transferred\n\n        uint balanceAfter = EIP20Interface(underlying).balanceOf(address(this));\n\n        require(balanceAfter >= balanceBefore, \"TOKEN_TRANSFER_IN_OVERFLOW\");\n\n        return balanceAfter - balanceBefore;   // underflow already checked above, just subtract\n\n    }\n\n\n",
          "message": "ABep20.doTransferIn uses assembly (ABep20DelegatorCertora.sol#3335-3362)\n\t- ABep20DelegatorCertora.sol#3341-3354\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 3371,
          "vulnerability_to_line": 3392,
          "vulnerability_code": "    function doTransferOut(address payable to, uint amount) internal {\n\n        EIP20NonStandardInterface token = EIP20NonStandardInterface(underlying);\n\n        token.transfer(to, amount);\n\n\n\n        bool success;\n\n        assembly {\n\n            switch returndatasize()\n\n                case 0 {                      // This is a non-standard BEP-20\n\n                    success := not(0)          // set success to true\n\n                }\n\n                case 32 {                     // This is a compliant BEP-20\n\n                    returndatacopy(0, 0, 32)\n\n                    success := mload(0)        // Set `success = returndata` of external call\n\n                }\n\n                default {                     // This is an excessively non-compliant BEP-20, revert.\n\n                    revert(0, 0)\n\n                }\n\n        }\n\n        require(success, \"TOKEN_TRANSFER_OUT_FAILED\");\n\n    }\n\n\n",
          "message": "ABep20.doTransferOut uses assembly (ABep20DelegatorCertora.sol#3371-3392)\n\t- ABep20DelegatorCertora.sol#3376-3389\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 433,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint);\n",
          "message": "ATokenInterface._setInterestRateModel (ABep20DelegatorCertora.sol#433) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 905,
          "vulnerability_to_line": 908,
          "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {\n\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"_setInterestRateModel(address)\", newInterestRateModel));\n\n        return abi.decode(data, (uint));\n",
          "message": "ABep20Delegator._setInterestRateModel (ABep20DelegatorCertora.sol#905-908) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 3098,
          "vulnerability_to_line": 3108,
          "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n\n        return _setInterestRateModelFresh(newInterestRateModel);\n\n    }\n\n\n",
          "message": "AToken._setInterestRateModel (ABep20DelegatorCertora.sol#3098-3108) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 490,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _becomeImplementation(bytes memory data) public;\n",
          "message": "ADelegateInterface._becomeImplementation (ABep20DelegatorCertora.sol#490) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 495,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _resignImplementation() public;\n",
          "message": "ADelegateInterface._resignImplementation (ABep20DelegatorCertora.sol#495) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 3459,
          "vulnerability_to_line": 3464,
          "vulnerability_code": "    function getCashOf(address account) public view returns (uint) {\n\n        return EIP20Interface(underlying).balanceOf(account);\n\n    }\n\n}\n\n\n",
          "message": "ATokenCollateral.getCashOf (ABep20DelegatorCertora.sol#3459-3464) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 3486,
          "vulnerability_to_line": 3490,
          "vulnerability_code": "    function balanceOfInOther(address account) public view returns (uint) {\n\n        return otherToken.balanceOf(account);\n\n    }\n\n\n",
          "message": "ABep20DelegatorCertora.balanceOfInOther (ABep20DelegatorCertora.sol#3486-3490) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 3490,
          "vulnerability_to_line": 3494,
          "vulnerability_code": "    function borrowBalanceStoredInOther(address account) public view returns (uint) {\n\n        return otherToken.borrowBalanceStored(account);\n\n    }\n\n\n",
          "message": "ABep20DelegatorCertora.borrowBalanceStoredInOther (ABep20DelegatorCertora.sol#3490-3494) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 3494,
          "vulnerability_to_line": 3498,
          "vulnerability_code": "    function exchangeRateStoredInOther() public view returns (uint) {\n\n        return otherToken.exchangeRateStored();\n\n    }\n\n\n",
          "message": "ABep20DelegatorCertora.exchangeRateStoredInOther (ABep20DelegatorCertora.sol#3494-3498) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 3498,
          "vulnerability_to_line": 3502,
          "vulnerability_code": "    function getCashInOther() public view returns (uint) {\n\n        return otherToken.getCash();\n\n    }\n\n\n",
          "message": "ABep20DelegatorCertora.getCashInOther (ABep20DelegatorCertora.sol#3498-3502) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 3502,
          "vulnerability_to_line": 3506,
          "vulnerability_code": "    function getCashOf(address account) public view returns (uint) {\n\n        return EIP20Interface(underlying).balanceOf(account);\n\n    }\n\n\n",
          "message": "ABep20DelegatorCertora.getCashOf (ABep20DelegatorCertora.sol#3502-3506) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 3506,
          "vulnerability_to_line": 3510,
          "vulnerability_code": "    function getCashOfInOther(address account) public view returns (uint) {\n\n        return otherToken.getCashOf(account);\n\n    }\n\n\n",
          "message": "ABep20DelegatorCertora.getCashOfInOther (ABep20DelegatorCertora.sol#3506-3510) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 3510,
          "vulnerability_to_line": 3514,
          "vulnerability_code": "    function totalSupplyInOther() public view returns (uint) {\n\n        return otherToken.totalSupply();\n\n    }\n\n\n",
          "message": "ABep20DelegatorCertora.totalSupplyInOther (ABep20DelegatorCertora.sol#3510-3514) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 3514,
          "vulnerability_to_line": 3518,
          "vulnerability_code": "    function totalBorrowsInOther() public view returns (uint) {\n\n        return otherToken.totalBorrows();\n\n    }\n\n\n",
          "message": "ABep20DelegatorCertora.totalBorrowsInOther (ABep20DelegatorCertora.sol#3514-3518) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 3518,
          "vulnerability_to_line": 3522,
          "vulnerability_code": "    function totalReservesInOther() public view returns (uint) {\n\n        return otherToken.totalReserves();\n\n    }\n\n\n",
          "message": "ABep20DelegatorCertora.totalReservesInOther (ABep20DelegatorCertora.sol#3518-3522) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 3522,
          "vulnerability_to_line": 3526,
          "vulnerability_code": "    function underlyingInOther() public view returns (address) {\n\n        return otherToken.underlying();\n\n    }\n\n\n",
          "message": "ABep20DelegatorCertora.underlyingInOther (ABep20DelegatorCertora.sol#3522-3526) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 3526,
          "vulnerability_to_line": 3531,
          "vulnerability_code": "    function mintFreshPub(address minter, uint mintAmount) public returns (uint) {\n\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"_mintFreshPub(address,uint256)\", minter, mintAmount));\n\n        return abi.decode(data, (uint));\n\n    }\n\n\n",
          "message": "ABep20DelegatorCertora.mintFreshPub (ABep20DelegatorCertora.sol#3526-3531) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 3531,
          "vulnerability_to_line": 3536,
          "vulnerability_code": "    function redeemFreshPub(address payable redeemer, uint redeemTokens, uint redeemUnderlying) public returns (uint) {\n\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"_redeemFreshPub(address,uint256,uint256)\", redeemer, redeemTokens, redeemUnderlying));\n\n        return abi.decode(data, (uint));\n\n    }\n\n\n",
          "message": "ABep20DelegatorCertora.redeemFreshPub (ABep20DelegatorCertora.sol#3531-3536) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 3536,
          "vulnerability_to_line": 3541,
          "vulnerability_code": "    function borrowFreshPub(address payable borrower, uint borrowAmount) public returns (uint) {\n\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"_borrowFreshPub(address,uint256)\", borrower, borrowAmount));\n\n        return abi.decode(data, (uint));\n\n    }\n\n\n",
          "message": "ABep20DelegatorCertora.borrowFreshPub (ABep20DelegatorCertora.sol#3536-3541) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 3541,
          "vulnerability_to_line": 3546,
          "vulnerability_code": "    function repayBorrowFreshPub(address payer, address borrower, uint repayAmount) public returns (uint) {\n\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"_repayBorrowFreshPub(address,address,uint256)\", payer, borrower, repayAmount));\n\n        return abi.decode(data, (uint));\n\n    }\n\n\n",
          "message": "ABep20DelegatorCertora.repayBorrowFreshPub (ABep20DelegatorCertora.sol#3541-3546) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 3546,
          "vulnerability_to_line": 3550,
          "vulnerability_code": "    function liquidateBorrowFreshPub(address liquidator, address borrower, uint repayAmount) public returns (uint) {\n\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"_liquidateBorrowFreshPub(address,address,uint256)\", liquidator, borrower, repayAmount));\n\n        return abi.decode(data, (uint));\n\n    }\n",
          "message": "ABep20DelegatorCertora.liquidateBorrowFreshPub (ABep20DelegatorCertora.sol#3546-3550) should be declared external\n"
        },
        {
          "name": "solc-version",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": "Detected issues with version pragma in ABep20DelegatorCertora.sol:\n\t- pragma solidity^0.5.16 (ABep20DelegatorCertora.sol#3): it allows old versions\n\t- pragma solidity^0.5.16 (ABep20DelegatorCertora.sol#83): it allows old versions\n\t- pragma solidity^0.5.16 (ABep20DelegatorCertora.sol#116): it allows old versions\n\t- pragma solidity^0.5.16 (ABep20DelegatorCertora.sol#189): it allows old versions\n\t- pragma solidity^0.5.16 (ABep20DelegatorCertora.sol#500): it allows old versions\n\t- pragma solidity^0.5.16 (ABep20DelegatorCertora.sol#977): it allows old versions\n\t- pragma solidity^0.5.16 (ABep20DelegatorCertora.sol#1042): it allows old versions\n\t- pragma solidity^0.5.16 (ABep20DelegatorCertora.sol#1252): it allows old versions\n\t- pragma solidity^0.5.16 (ABep20DelegatorCertora.sol#1340): it allows old versions\n\t- pragma solidity^0.5.16 (ABep20DelegatorCertora.sol#1538): it allows old versions\n\t- pragma solidity^0.5.16 (ABep20DelegatorCertora.sol#1722): it allows old versions\n\t- pragma solidity^0.5.16 (ABep20DelegatorCertora.sol#3182-3184): it allows old versions\n\t- pragma solidity^0.5.16 (ABep20DelegatorCertora.sol#3405-3408): it allows old versions\n\t- pragma solidity^0.5.16 (ABep20DelegatorCertora.sol#3445-3448): it allows old versions\n\t- pragma solidity^0.5.16 (ABep20DelegatorCertora.sol#3466-3469): it allows old versions\n"
        },
        {
          "name": "low-level-calls",
          "vulnerability_from_line": 917,
          "vulnerability_to_line": 925,
          "vulnerability_code": "    function delegateTo(address callee, bytes memory data) internal returns (bytes memory) {\n\n        (bool success, bytes memory returnData) = callee.delegatecall(data);\n\n        assembly {\n\n            if eq(success, 0) {\n\n                revert(add(returnData, 0x20), returndatasize)\n\n            }\n\n        }\n\n        return returnData;\n",
          "message": "Low level call in ABep20Delegator.delegateTo (ABep20DelegatorCertora.sol#917-925):\n\t-(success,returnData) = callee.delegatecall(data) ABep20DelegatorCertora.sol#918\n"
        },
        {
          "name": "low-level-calls",
          "vulnerability_from_line": 944,
          "vulnerability_to_line": 952,
          "vulnerability_code": "    function delegateToViewImplementation(bytes memory data) public view returns (bytes memory) {\n\n        (bool success, bytes memory returnData) = address(this).staticcall(abi.encodeWithSignature(\"delegateToImplementation(bytes)\", data));\n\n        assembly {\n\n            if eq(success, 0) {\n\n                revert(add(returnData, 0x20), returndatasize)\n\n            }\n\n        }\n\n        return abi.decode(returnData, (bytes));\n",
          "message": "Low level call in ABep20Delegator.delegateToViewImplementation (ABep20DelegatorCertora.sol#944-952):\n\t-(success,returnData) = address(this).staticcall(abi.encodeWithSignature(delegateToImplementation(bytes),data)) ABep20DelegatorCertora.sol#945\n"
        },
        {
          "name": "low-level-calls",
          "vulnerability_from_line": 958,
          "vulnerability_to_line": 972,
          "vulnerability_code": "    function () external payable {\n\n        require(msg.value == 0,\"ABep20Delegator:fallback: cannot send value to fallback\");\n\n\n\n        // delegate all other functions to current implementation\n\n        (bool success, ) = implementation.delegatecall(msg.data);\n\n\n\n        assembly {\n\n            let free_mem_ptr := mload(0x40)\n\n            returndatacopy(free_mem_ptr, 0, returndatasize)\n\n\n\n            switch success\n\n            case 0 { revert(free_mem_ptr, returndatasize) }\n\n            default { return(free_mem_ptr, returndatasize) }\n\n        }\n",
          "message": "Low level call in ABep20Delegator.fallback (ABep20DelegatorCertora.sol#958-972):\n\t-(success) = implementation.delegatecall(msg.data) ABep20DelegatorCertora.sol#962\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 7,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bool public constant isComptroller = true;\n",
          "message": "Constant 'ComptrollerInterface.isComptroller' (ABep20DelegatorCertora.sol#7) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 91,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bool public constant isInterestRateModel = true;\n",
          "message": "Constant 'InterestRateModel.isInterestRateModel' (ABep20DelegatorCertora.sol#91) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 197,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bool internal _notEntered;\n",
          "message": "Variable 'ATokenStorage._notEntered' (ABep20DelegatorCertora.sol#197) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 218,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint internal constant borrowRateMaxMantissa = 0.0005e16;\n",
          "message": "Constant 'ATokenStorage.borrowRateMaxMantissa' (ABep20DelegatorCertora.sol#218) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 223,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint internal constant reserveFactorMaxMantissa = 1e18;\n",
          "message": "Constant 'ATokenStorage.reserveFactorMaxMantissa' (ABep20DelegatorCertora.sol#223) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 308,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint public constant protocolSeizeShareMantissa = 2.8e16; //2.8%\n",
          "message": "Constant 'ATokenStorage.protocolSeizeShareMantissa' (ABep20DelegatorCertora.sol#308) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 428,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint);\n",
          "message": "Function 'ATokenInterface._setPendingAdmin' (ABep20DelegatorCertora.sol#428) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 429,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _acceptAdmin() external returns (uint);\n",
          "message": "Function 'ATokenInterface._acceptAdmin' (ABep20DelegatorCertora.sol#429) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 430,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setComptroller(ComptrollerInterface newComptroller) public returns (uint);\n",
          "message": "Function 'ATokenInterface._setComptroller' (ABep20DelegatorCertora.sol#430) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 431,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setReserveFactor(uint newReserveFactorMantissa) external returns (uint);\n",
          "message": "Function 'ATokenInterface._setReserveFactor' (ABep20DelegatorCertora.sol#431) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 432,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _reduceReserves(uint reduceAmount) external returns (uint);\n",
          "message": "Function 'ATokenInterface._reduceReserves' (ABep20DelegatorCertora.sol#432) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 433,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint);\n",
          "message": "Function 'ATokenInterface._setInterestRateModel' (ABep20DelegatorCertora.sol#433) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 316,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bool public constant isAToken = true;\n",
          "message": "Constant 'ATokenInterface.isAToken' (ABep20DelegatorCertora.sol#316) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 459,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _addReserves(uint addAmount) external returns (uint);\n",
          "message": "Function 'ABep20Interface._addReserves' (ABep20DelegatorCertora.sol#459) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 481,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setImplementation(address implementation_, bool allowResign, bytes memory becomeImplementationData) public;\n",
          "message": "Function 'ADelegatorInterface._setImplementation' (ABep20DelegatorCertora.sol#481) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 490,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _becomeImplementation(bytes memory data) public;\n",
          "message": "Function 'ADelegateInterface._becomeImplementation' (ABep20DelegatorCertora.sol#490) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 495,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _resignImplementation() public;\n",
          "message": "Function 'ADelegateInterface._resignImplementation' (ABep20DelegatorCertora.sol#495) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 844,
          "vulnerability_to_line": 847,
          "vulnerability_code": "    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint) {\n\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"_setPendingAdmin(address)\", newPendingAdmin));\n\n        return abi.decode(data, (uint));\n",
          "message": "Function 'ABep20Delegator._setPendingAdmin' (ABep20DelegatorCertora.sol#844-847) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 874,
          "vulnerability_to_line": 877,
          "vulnerability_code": "    function _acceptAdmin() external returns (uint) {\n\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"_acceptAdmin()\"));\n\n        return abi.decode(data, (uint));\n",
          "message": "Function 'ABep20Delegator._acceptAdmin' (ABep20DelegatorCertora.sol#874-877) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 854,
          "vulnerability_to_line": 857,
          "vulnerability_code": "    function _setComptroller(ComptrollerInterface newComptroller) public returns (uint) {\n\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"_setComptroller(address)\", newComptroller));\n\n        return abi.decode(data, (uint));\n",
          "message": "Function 'ABep20Delegator._setComptroller' (ABep20DelegatorCertora.sol#854-857) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 864,
          "vulnerability_to_line": 867,
          "vulnerability_code": "    function _setReserveFactor(uint newReserveFactorMantissa) external returns (uint) {\n\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"_setReserveFactor(uint256)\", newReserveFactorMantissa));\n\n        return abi.decode(data, (uint));\n",
          "message": "Function 'ABep20Delegator._setReserveFactor' (ABep20DelegatorCertora.sol#864-867) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 894,
          "vulnerability_to_line": 897,
          "vulnerability_code": "    function _reduceReserves(uint reduceAmount) external returns (uint) {\n\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"_reduceReserves(uint256)\", reduceAmount));\n\n        return abi.decode(data, (uint));\n",
          "message": "Function 'ABep20Delegator._reduceReserves' (ABep20DelegatorCertora.sol#894-897) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 905,
          "vulnerability_to_line": 908,
          "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {\n\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"_setInterestRateModel(address)\", newInterestRateModel));\n\n        return abi.decode(data, (uint));\n",
          "message": "Function 'ABep20Delegator._setInterestRateModel' (ABep20DelegatorCertora.sol#905-908) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 884,
          "vulnerability_to_line": 887,
          "vulnerability_code": "    function _addReserves(uint addAmount) external returns (uint) {\n\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"_addReserves(uint256)\", addAmount));\n\n        return abi.decode(data, (uint));\n",
          "message": "Function 'ABep20Delegator._addReserves' (ABep20DelegatorCertora.sol#884-887) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 557,
          "vulnerability_to_line": 570,
          "vulnerability_code": "    function _setImplementation(address implementation_, bool allowResign, bytes memory becomeImplementationData) public {\n\n        require(msg.sender == admin, \"ABep20Delegator::_setImplementation: Caller must be admin\");\n\n\n\n        if (allowResign) {\n\n            delegateToImplementation(abi.encodeWithSignature(\"_resignImplementation()\"));\n\n        }\n\n\n\n        address oldImplementation = implementation;\n\n        implementation = implementation_;\n\n\n\n        delegateToImplementation(abi.encodeWithSignature(\"_becomeImplementation(bytes)\", becomeImplementationData));\n\n\n\n        emit NewImplementation(oldImplementation, implementation);\n",
          "message": "Function 'ABep20Delegator._setImplementation' (ABep20DelegatorCertora.sol#557-570) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1375,
          "vulnerability_to_line": 1378,
          "vulnerability_code": "    function mul_ScalarTruncate(Exp memory a, uint scalar) pure internal returns (uint) {\n\n        Exp memory product = mul_(a, scalar);\n\n        return truncate(product);\n",
          "message": "Function 'ExponentialNoError.mul_ScalarTruncate' (ABep20DelegatorCertora.sol#1375-1378) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1383,
          "vulnerability_to_line": 1386,
          "vulnerability_code": "    function mul_ScalarTruncateAddUInt(Exp memory a, uint scalar, uint addend) pure internal returns (uint) {\n\n        Exp memory product = mul_(a, scalar);\n\n        return add_(truncate(product), addend);\n",
          "message": "Function 'ExponentialNoError.mul_ScalarTruncateAddUInt' (ABep20DelegatorCertora.sol#1383-1386) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1350,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint constant expScale = 1e18;\n",
          "message": "Constant 'ExponentialNoError.expScale' (ABep20DelegatorCertora.sol#1350) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1351,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint constant doubleScale = 1e36;\n",
          "message": "Constant 'ExponentialNoError.doubleScale' (ABep20DelegatorCertora.sol#1351) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1352,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint constant halfExpScale = expScale/2;\n",
          "message": "Constant 'ExponentialNoError.halfExpScale' (ABep20DelegatorCertora.sol#1352) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1353,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint constant mantissaOne = expScale;\n",
          "message": "Constant 'ExponentialNoError.mantissaOne' (ABep20DelegatorCertora.sol#1353) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 2852,
          "vulnerability_to_line": 2868,
          "vulnerability_code": "    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint) {\n\n        // Check caller = admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);\n\n        }\n\n\n\n        // Save current value, if any, for inclusion in log\n\n        address oldPendingAdmin = pendingAdmin;\n\n\n\n        // Store pendingAdmin with value newPendingAdmin\n\n        pendingAdmin = newPendingAdmin;\n\n\n\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\n\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n\n\n\n        return uint(Error.NO_ERROR);\n",
          "message": "Function 'AToken._setPendingAdmin' (ABep20DelegatorCertora.sol#2852-2868) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 2875,
          "vulnerability_to_line": 2897,
          "vulnerability_code": "    function _acceptAdmin() external returns (uint) {\n\n        // Check caller is pendingAdmin and pendingAdmin \u2260 address(0)\n\n        if (msg.sender != pendingAdmin || msg.sender == address(0)) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);\n\n        }\n\n\n\n        // Save current values for inclusion in log\n\n        address oldAdmin = admin;\n\n        address oldPendingAdmin = pendingAdmin;\n\n\n\n        // Store admin with value pendingAdmin\n\n        admin = pendingAdmin;\n\n\n\n        // Clear the pending value\n\n        pendingAdmin = address(0);\n\n\n\n        emit NewAdmin(oldAdmin, admin);\n\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Function 'AToken._acceptAdmin' (ABep20DelegatorCertora.sol#2875-2897) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 2902,
          "vulnerability_to_line": 2921,
          "vulnerability_code": "    function _setComptroller(ComptrollerInterface newComptroller) public returns (uint) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COMPTROLLER_OWNER_CHECK);\n\n        }\n\n\n\n        ComptrollerInterface oldComptroller = comptroller;\n\n        // Ensure invoke comptroller.isComptroller() returns true\n\n        require(newComptroller.isComptroller(), \"marker method returned false\");\n\n\n\n        // Set market's comptroller to newComptroller\n\n        comptroller = newComptroller;\n\n\n\n        // Emit NewComptroller(oldComptroller, newComptroller)\n\n        emit NewComptroller(oldComptroller, newComptroller);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Function 'AToken._setComptroller' (ABep20DelegatorCertora.sol#2902-2921) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 2926,
          "vulnerability_to_line": 2936,
          "vulnerability_code": "    function _setReserveFactor(uint newReserveFactorMantissa) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.\n\n            return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.\n\n        return _setReserveFactorFresh(newReserveFactorMantissa);\n\n    }\n\n\n",
          "message": "Function 'AToken._setReserveFactor' (ABep20DelegatorCertora.sol#2926-2936) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 3033,
          "vulnerability_to_line": 3043,
          "vulnerability_code": "    function _reduceReserves(uint reduceAmount) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n\n            return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.\n\n        return _reduceReservesFresh(reduceAmount);\n\n    }\n\n\n",
          "message": "Function 'AToken._reduceReserves' (ABep20DelegatorCertora.sol#3033-3043) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 3098,
          "vulnerability_to_line": 3108,
          "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n\n        return _setInterestRateModelFresh(newInterestRateModel);\n\n    }\n\n\n",
          "message": "Function 'AToken._setInterestRateModel' (ABep20DelegatorCertora.sol#3098-3108) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 2941,
          "vulnerability_to_line": 2965,
          "vulnerability_code": "    function _setReserveFactorFresh(uint newReserveFactorMantissa) internal returns (uint) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_RESERVE_FACTOR_ADMIN_CHECK);\n\n        }\n\n\n\n        // Verify market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_RESERVE_FACTOR_FRESH_CHECK);\n\n        }\n\n\n\n        // Check newReserveFactor \u2264 maxReserveFactor\n\n        if (newReserveFactorMantissa > reserveFactorMaxMantissa) {\n\n            return fail(Error.BAD_INPUT, FailureInfo.SET_RESERVE_FACTOR_BOUNDS_CHECK);\n\n        }\n\n\n\n        uint oldReserveFactorMantissa = reserveFactorMantissa;\n\n        reserveFactorMantissa = newReserveFactorMantissa;\n\n\n\n        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Function 'AToken._setReserveFactorFresh' (ABep20DelegatorCertora.sol#2941-2965) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 2970,
          "vulnerability_to_line": 2982,
          "vulnerability_code": "    function _addReservesInternal(uint addAmount) internal nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n\n            return fail(Error(error), FailureInfo.ADD_RESERVES_ACCRUE_INTEREST_FAILED);\n\n        }\n\n\n\n        // _addReservesFresh emits reserve-addition-specific logs on errors, so we don't need to.\n\n        (error, ) = _addReservesFresh(addAmount);\n\n        return error;\n\n    }\n\n\n",
          "message": "Function 'AToken._addReservesInternal' (ABep20DelegatorCertora.sol#2970-2982) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 2988,
          "vulnerability_to_line": 3028,
          "vulnerability_code": "    function _addReservesFresh(uint addAmount) internal returns (uint, uint) {\n\n        // totalReserves + actualAddAmount\n\n        uint totalReservesNew;\n\n        uint actualAddAmount;\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return (fail(Error.MARKET_NOT_FRESH, FailureInfo.ADD_RESERVES_FRESH_CHECK), actualAddAmount);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We call doTransferIn for the caller and the addAmount\n\n         *  Note: The aToken must handle variations between BEP-20 and BNB underlying.\n\n         *  On success, the aToken holds an additional addAmount of cash.\n\n         *  doTransferIn reverts if anything goes wrong, since we can't be sure if side effects occurred.\n\n         *  it returns the amount actually transferred, in case of a fee.\n\n         */\n\n\n\n        actualAddAmount = doTransferIn(msg.sender, addAmount);\n\n\n\n        totalReservesNew = totalReserves + actualAddAmount;\n\n\n\n        /* Revert on overflow */\n\n        require(totalReservesNew >= totalReserves, \"add reserves unexpected overflow\");\n\n\n\n        // Store reserves[n+1] = reserves[n] + actualAddAmount\n\n        totalReserves = totalReservesNew;\n\n\n\n        /* Emit NewReserves(admin, actualAddAmount, reserves[n+1]) */\n\n        emit ReservesAdded(msg.sender, actualAddAmount, totalReservesNew);\n\n\n\n        /* Return (NO_ERROR, actualAddAmount) */\n\n        return (uint(Error.NO_ERROR), actualAddAmount);\n\n    }\n\n\n\n\n",
          "message": "Function 'AToken._addReservesFresh' (ABep20DelegatorCertora.sol#2988-3028) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 3049,
          "vulnerability_to_line": 3092,
          "vulnerability_code": "    function _reduceReservesFresh(uint reduceAmount) internal returns (uint) {\n\n        // totalReserves - reduceAmount\n\n        uint totalReservesNew;\n\n\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.REDUCE_RESERVES_ADMIN_CHECK);\n\n        }\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDUCE_RESERVES_FRESH_CHECK);\n\n        }\n\n\n\n        // Fail gracefully if protocol has insufficient underlying cash\n\n        if (getCashPrior() < reduceAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDUCE_RESERVES_CASH_NOT_AVAILABLE);\n\n        }\n\n\n\n        // Check reduceAmount \u2264 reserves[n] (totalReserves)\n\n        if (reduceAmount > totalReserves) {\n\n            return fail(Error.BAD_INPUT, FailureInfo.REDUCE_RESERVES_VALIDATION);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        totalReservesNew = totalReserves - reduceAmount;\n\n        // We checked reduceAmount <= totalReserves above, so this should never revert.\n\n        require(totalReservesNew <= totalReserves, \"reduce reserves unexpected underflow\");\n\n\n\n        // Store reserves[n+1] = reserves[n] - reduceAmount\n\n        totalReserves = totalReservesNew;\n\n\n\n        // doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n\n        doTransferOut(admin, reduceAmount);\n\n\n\n        emit ReservesReduced(admin, reduceAmount, totalReservesNew);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Function 'AToken._reduceReservesFresh' (ABep20DelegatorCertora.sol#3049-3092) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 3114,
          "vulnerability_to_line": 3144,
          "vulnerability_code": "    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {\n\n\n\n        // Used to store old model for use in the event that is emitted on success\n\n        InterestRateModel oldInterestRateModel;\n\n\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);\n\n        }\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);\n\n        }\n\n\n\n        // Track the market's current interest rate model\n\n        oldInterestRateModel = interestRateModel;\n\n\n\n        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true\n\n        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n\n\n\n        // Set the interest rate model to newInterestRateModel\n\n        interestRateModel = newInterestRateModel;\n\n\n\n        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)\n\n        emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Function 'AToken._setInterestRateModelFresh' (ABep20DelegatorCertora.sol#3114-3144) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 3310,
          "vulnerability_to_line": 3314,
          "vulnerability_code": "    function _addReserves(uint addAmount) external returns (uint) {\n\n        return _addReservesInternal(addAmount);\n\n    }\n\n\n",
          "message": "Function 'ABep20._addReserves' (ABep20DelegatorCertora.sol#3310-3314) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 3397,
          "vulnerability_to_line": 3403,
          "vulnerability_code": "    function _delegateAtlantisLikeTo(address atlantisLikeDelegatee) external {\n\n        require(msg.sender == admin, \"only the admin may set the atlantis-like delegate\");\n\n        AtlantisLike(underlying).delegate(atlantisLikeDelegatee);\n\n    }\n\n}\n\n\n",
          "message": "Function 'ABep20._delegateAtlantisLikeTo' (ABep20DelegatorCertora.sol#3397-3403) is not in mixedCase\n"
        },
        {
          "name": "unused-state",
          "vulnerability_from_line": 197,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bool internal _notEntered;\n",
          "message": "ATokenStorage._notEntered (ABep20DelegatorCertora.sol#197) is never used in ABep20DelegatorCertora\nATokenStorage.borrowRateMaxMantissa (ABep20DelegatorCertora.sol#218) is never used in ABep20DelegatorCertora\nATokenStorage.reserveFactorMaxMantissa (ABep20DelegatorCertora.sol#223) is never used in ABep20DelegatorCertora\nATokenStorage.initialExchangeRateMantissa (ABep20DelegatorCertora.sol#248) is never used in ABep20DelegatorCertora\nATokenStorage.accountTokens (ABep20DelegatorCertora.sol#283) is never used in ABep20DelegatorCertora\nATokenStorage.transferAllowances (ABep20DelegatorCertora.sol#288) is never used in ABep20DelegatorCertora\nATokenStorage.accountBorrows (ABep20DelegatorCertora.sol#303) is never used in ABep20DelegatorCertora\n"
        }
      ]
    },
    "smartcheck": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "SOLIDITY_ERC20_APPROVE",
          "vulnerability_from_line": 1877,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function approve(address spender, uint256 amount) external returns (bool) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_LOCKED_MONEY",
          "vulnerability_from_line": 312,
          "vulnerability_to_line": null,
          "vulnerability_code": "contract ATokenInterface is ATokenStorage {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_LOCKED_MONEY",
          "vulnerability_from_line": 507,
          "vulnerability_to_line": null,
          "vulnerability_code": "contract ABep20Delegator is ATokenInterface, ABep20Interface, ADelegatorInterface {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_LOCKED_MONEY",
          "vulnerability_from_line": 3412,
          "vulnerability_to_line": null,
          "vulnerability_code": "contract ABep20Immutable is ABep20 {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_LOCKED_MONEY",
          "vulnerability_from_line": 3448,
          "vulnerability_to_line": null,
          "vulnerability_code": "contract ATokenCollateral is ABep20Immutable {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_LOCKED_MONEY",
          "vulnerability_from_line": 3469,
          "vulnerability_to_line": null,
          "vulnerability_code": "contract ABep20DelegatorCertora is ABep20Delegator {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 83,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 116,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 189,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 500,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 977,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 1042,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 1252,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 1340,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 1538,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 1722,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 3182,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 3405,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 3445,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 3466,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 72,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint repayAmount) external view returns (uint, uint);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 413,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 1275,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function mulUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 1292,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function divUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 1303,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function subUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 1314,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function addUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 1327,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function addThenSubUInt(uint a, uint b, uint c) internal pure returns (MathError, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 1555,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getExp(uint num, uint denom) pure internal returns (MathError, Exp memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 1572,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function addExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 1581,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function subExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 1590,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function mulScalar(Exp memory a, uint scalar) pure internal returns (MathError, Exp memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 1602,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function mulScalarTruncate(Exp memory a, uint scalar) pure internal returns (MathError, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 1614,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function mulScalarTruncateAddUInt(Exp memory a, uint scalar, uint addend) pure internal returns (MathError, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 1626,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function divScalar(Exp memory a, uint scalar) pure internal returns (MathError, Exp memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 1638,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function divScalarByExp(uint scalar, Exp memory divisor) pure internal returns (MathError, Exp memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 1658,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function divScalarByExpTruncate(uint scalar, Exp memory divisor) pure internal returns (MathError, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 1670,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function mulExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 1695,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function mulExp(uint a, uint b) pure internal returns (MathError, Exp memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 1702,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function mulExp3(Exp memory a, Exp memory b, Exp memory c) pure internal returns (MathError, Exp memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 1715,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function divExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 1922,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 2001,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 2058,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function exchangeRateStoredInternal() internal view returns (MathError, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 2189,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function mintInternal(uint mintAmount) internal nonReentrant returns (uint, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 2216,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function mintFresh(address minter, uint mintAmount) internal returns (uint, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 3341,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 428,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 521,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor(address underlying_,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 2333,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 3371,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function doTransferOut(address payable to, uint amount) internal {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 3424,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor(address underlying_,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 3449,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor(address underlying_,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 3472,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor(address underlying_,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 428,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 528,
          "vulnerability_to_line": null,
          "vulnerability_code": "                address payable admin_,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 529,
          "vulnerability_to_line": null,
          "vulnerability_code": "                address implementation_,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 530,
          "vulnerability_to_line": null,
          "vulnerability_code": "                bytes memory becomeImplementationData) public {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 532,
          "vulnerability_to_line": null,
          "vulnerability_code": "        admin = msg.sender;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 532,
          "vulnerability_to_line": null,
          "vulnerability_code": "        admin = msg.sender;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 535,
          "vulnerability_to_line": null,
          "vulnerability_code": "        delegateTo(implementation_, abi.encodeWithSignature(\"initialize(address,address,address,uint256,string,string,uint8)\",\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 535,
          "vulnerability_to_line": null,
          "vulnerability_code": "        delegateTo(implementation_, abi.encodeWithSignature(\"initialize(address,address,address,uint256,string,string,uint8)\",\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 535,
          "vulnerability_to_line": null,
          "vulnerability_code": "        delegateTo(implementation_, abi.encodeWithSignature(\"initialize(address,address,address,uint256,string,string,uint8)\",\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 537,
          "vulnerability_to_line": null,
          "vulnerability_code": "                                                            comptroller_,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 539,
          "vulnerability_to_line": null,
          "vulnerability_code": "                                                            initialExchangeRateMantissa_,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 541,
          "vulnerability_to_line": null,
          "vulnerability_code": "                                                            symbol_,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 545,
          "vulnerability_to_line": null,
          "vulnerability_code": "        _setImplementation(implementation_, false, becomeImplementationData);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 545,
          "vulnerability_to_line": null,
          "vulnerability_code": "        _setImplementation(implementation_, false, becomeImplementationData);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 548,
          "vulnerability_to_line": null,
          "vulnerability_code": "        admin = admin_;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1350,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint constant expScale = 1e18;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1351,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint constant doubleScale = 1e36;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1352,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint constant halfExpScale = expScale/2;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1353,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint constant mantissaOne = expScale;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 2333,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 2333,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 2333,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 2333,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 2334,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 2336,
          "vulnerability_to_line": null,
          "vulnerability_code": "        RedeemLocalVars memory vars;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 2339,
          "vulnerability_to_line": null,
          "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 2339,
          "vulnerability_to_line": null,
          "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 2339,
          "vulnerability_to_line": null,
          "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 2339,
          "vulnerability_to_line": null,
          "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 2340,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (vars.mathErr != MathError.NO_ERROR) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 2340,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (vars.mathErr != MathError.NO_ERROR) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 2341,
          "vulnerability_to_line": null,
          "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 2341,
          "vulnerability_to_line": null,
          "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 2341,
          "vulnerability_to_line": null,
          "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 2341,
          "vulnerability_to_line": null,
          "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 2341,
          "vulnerability_to_line": null,
          "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 3371,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function doTransferOut(address payable to, uint amount) internal {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 3371,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function doTransferOut(address payable to, uint amount) internal {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 3372,
          "vulnerability_to_line": null,
          "vulnerability_code": "        EIP20NonStandardInterface token = EIP20NonStandardInterface(underlying);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 3373,
          "vulnerability_to_line": null,
          "vulnerability_code": "        token.transfer(to, amount);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 3373,
          "vulnerability_to_line": null,
          "vulnerability_code": "        token.transfer(to, amount);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 3375,
          "vulnerability_to_line": null,
          "vulnerability_code": "        bool success;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 3377,
          "vulnerability_to_line": null,
          "vulnerability_code": "            switch returndatasize()\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 3377,
          "vulnerability_to_line": null,
          "vulnerability_code": "            switch returndatasize()\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 3379,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    success := not(0)          // set success to true\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 3379,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    success := not(0)          // set success to true\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 3436,
          "vulnerability_to_line": null,
          "vulnerability_code": "        initialize(underlying_, comptroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 3436,
          "vulnerability_to_line": null,
          "vulnerability_code": "        initialize(underlying_, comptroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 3436,
          "vulnerability_to_line": null,
          "vulnerability_code": "        initialize(underlying_, comptroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 3436,
          "vulnerability_to_line": null,
          "vulnerability_code": "        initialize(underlying_, comptroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 3439,
          "vulnerability_to_line": null,
          "vulnerability_code": "        admin = admin_;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 3456,
          "vulnerability_to_line": null,
          "vulnerability_code": "                address payable admin_) public ABep20Immutable(underlying_, comptroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_, admin_) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 3456,
          "vulnerability_to_line": null,
          "vulnerability_code": "                address payable admin_) public ABep20Immutable(underlying_, comptroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_, admin_) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 3456,
          "vulnerability_to_line": null,
          "vulnerability_code": "                address payable admin_) public ABep20Immutable(underlying_, comptroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_, admin_) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 3456,
          "vulnerability_to_line": null,
          "vulnerability_code": "                address payable admin_) public ABep20Immutable(underlying_, comptroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_, admin_) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 3479,
          "vulnerability_to_line": null,
          "vulnerability_code": "                address payable admin_,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 3480,
          "vulnerability_to_line": null,
          "vulnerability_code": "                address implementation_,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 3481,
          "vulnerability_to_line": null,
          "vulnerability_code": "                bytes memory becomeImplementationData) public ABep20Delegator(underlying_, comptroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_, admin_, implementation_, becomeImplementationData) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 3481,
          "vulnerability_to_line": null,
          "vulnerability_code": "                bytes memory becomeImplementationData) public ABep20Delegator(underlying_, comptroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_, admin_, implementation_, becomeImplementationData) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 3481,
          "vulnerability_to_line": null,
          "vulnerability_code": "                bytes memory becomeImplementationData) public ABep20Delegator(underlying_, comptroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_, admin_, implementation_, becomeImplementationData) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 3481,
          "vulnerability_to_line": null,
          "vulnerability_code": "                bytes memory becomeImplementationData) public ABep20Delegator(underlying_, comptroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_, admin_, implementation_, becomeImplementationData) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 3481,
          "vulnerability_to_line": null,
          "vulnerability_code": "                bytes memory becomeImplementationData) public ABep20Delegator(underlying_, comptroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_, admin_, implementation_, becomeImplementationData) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 3481,
          "vulnerability_to_line": null,
          "vulnerability_code": "                bytes memory becomeImplementationData) public ABep20Delegator(underlying_, comptroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_, admin_, implementation_, becomeImplementationData) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 3481,
          "vulnerability_to_line": null,
          "vulnerability_code": "                bytes memory becomeImplementationData) public ABep20Delegator(underlying_, comptroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_, admin_, implementation_, becomeImplementationData) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 3482,
          "vulnerability_to_line": null,
          "vulnerability_code": "        comptroller;       // touch for Certora slot deduction\n",
          "message": null
        }
      ]
    },
    "oyente": {
      "successfull_analysis": false,
      "errors": [
        "exception (RuntimeError: Source map error, unknown name(SHR) or instr_name(INVALID))"
      ],
      "vulnerability_findings": []
    },
    "mythril": {
      "successfull_analysis": false,
      "errors": [
        "DOCKER_TIMEOUT"
      ],
      "vulnerability_findings": []
    },
    "osiris": {
      "successfull_analysis": false,
      "errors": [
        "Solidity compilation failed"
      ],
      "vulnerability_findings": []
    }
  }
}