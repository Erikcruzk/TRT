{
  "smartbugs_completed": true,
  "analyzer_results": {
    "semgrep": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 2668,
          "vulnerability_to_line": null,
          "vulnerability_code": "            if (accountAssets[msg.sender].length >= maxAssets)  {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 3176,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < assets.length; i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "inefficient-state-variable-increment",
          "vulnerability_from_line": 607,
          "vulnerability_to_line": null,
          "vulnerability_code": "        _guardCounter += 1;\n",
          "message": "<x> += <y> costs more gas than <x> = <x> + <y> for state variables."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 593,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor () internal {\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 594,
          "vulnerability_to_line": null,
          "vulnerability_code": "        // The counter starts at one to prevent changing it from zero to a non-zero\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 595,
          "vulnerability_to_line": null,
          "vulnerability_code": "        // value, which is a more expensive operation.\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 596,
          "vulnerability_to_line": null,
          "vulnerability_code": "        _guardCounter = 1;\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 597,
          "vulnerability_to_line": null,
          "vulnerability_code": "    }\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 920,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor(ComptrollerInterface comptroller_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 921,
          "vulnerability_to_line": null,
          "vulnerability_code": "                InterestRateModel interestRateModel_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 922,
          "vulnerability_to_line": null,
          "vulnerability_code": "                uint initialExchangeRateMantissa_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 923,
          "vulnerability_to_line": null,
          "vulnerability_code": "                string memory name_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 924,
          "vulnerability_to_line": null,
          "vulnerability_code": "                string memory symbol_,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 925,
          "vulnerability_to_line": null,
          "vulnerability_code": "                uint decimals_) internal {\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 926,
          "vulnerability_to_line": null,
          "vulnerability_code": "        // Set admin to msg.sender\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 927,
          "vulnerability_to_line": null,
          "vulnerability_code": "        admin = msg.sender;\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 928,
          "vulnerability_to_line": null,
          "vulnerability_code": "\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 929,
          "vulnerability_to_line": null,
          "vulnerability_code": "        // Set initial exchange rate\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 2401,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor() public {\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 2402,
          "vulnerability_to_line": null,
          "vulnerability_code": "        // Set admin to caller\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 2403,
          "vulnerability_to_line": null,
          "vulnerability_code": "        admin = msg.sender;\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 2404,
          "vulnerability_to_line": null,
          "vulnerability_code": "    }\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 2616,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor() public {\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 2617,
          "vulnerability_to_line": null,
          "vulnerability_code": "        admin = msg.sender;\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 2618,
          "vulnerability_to_line": null,
          "vulnerability_code": "    }\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 2654,
          "vulnerability_to_line": null,
          "vulnerability_code": "            Market storage marketToJoin = markets[address(cToken)];\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 3184,
          "vulnerability_to_line": null,
          "vulnerability_code": "            vars.collateralFactor = Exp({mantissa: markets[address(asset)].collateralFactorMantissa});\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 2652,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < len; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 2729,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < len; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 3176,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < assets.length; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 610,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(localCounter == _guardCounter, \"re-entered\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 931,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(initialExchangeRateMantissa > 0, \"Initial exchange rate must be greater than zero.\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 935,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(err == uint(Error.NO_ERROR), \"Setting comptroller failed\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 943,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(err == uint(Error.NO_ERROR), \"Setting interest rate model failed\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1129,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(opaqueErr == 0, \"borrowRatePerBlock: interestRateModel.borrowRate failed\"); // semi-opaque\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1146,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(e0 == 0, \"supplyRatePerBlock: calculating borrowRate failed\"); // semi-opaque\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1149,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(e1 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating underlying failed\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1152,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(e2 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating borrowsPer failed\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1155,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(e3 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating oneMinusReserveFactor failed\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1158,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(e4 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating supplyRate failed\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1168,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1178,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1189,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(err == MathError.NO_ERROR, \"borrowBalanceStored: borrowBalanceStoredInternal failed\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1235,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1246,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(err == MathError.NO_ERROR, \"exchangeRateStored: exchangeRateStoredInternal failed\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1319,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(vars.borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1542,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1623,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(vars.err == Error.NO_ERROR, \"redeem transfer out failed\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1718,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(vars.err == Error.NO_ERROR, \"borrow transfer out failed\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1845,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(vars.err == Error.NO_ERROR, \"repay borrow transfer in failed\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1946,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(seizeError == uint(Error.NO_ERROR), \"token seizure failed\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 2083,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(newComptroller.isComptroller(), \"marker method returned false\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 2193,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(totalReservesNew <= totalReserves, \"reduce reserves unexpected underflow\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 2201,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(err == Error.NO_ERROR, \"reduce reserves transfer out failed\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 2250,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 2701,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(oErr == 0, \"exitMarket: getAccountSnapshot failed\"); // semi-opaque error code\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 2839,
          "vulnerability_to_line": null,
          "vulnerability_code": "            revert(\"redeemTokens zero\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 3469,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == unitroller.admin(), \"only unitroller admin can change brains\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 3472,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(changeStatus == 0, \"change not authorized\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 3479,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require (err == uint(Error.NO_ERROR), \"set price oracle error\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 3483,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require (err == uint(Error.NO_ERROR), \"set close factor error\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 3487,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require (err == uint(Error.NO_ERROR), \"set max asssets error\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 3491,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require (err == uint(Error.NO_ERROR), \"set liquidation incentive error\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 2838,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (redeemTokens == 0 && redeemAmount > 0) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 2839,
          "vulnerability_to_line": null,
          "vulnerability_code": "            revert(\"redeemTokens zero\");\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 2840,
          "vulnerability_to_line": null,
          "vulnerability_code": "        }\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 3376,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (newCollateralFactorMantissa != 0 && oracle.getUnderlyingPrice(cToken) == 0) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 3377,
          "vulnerability_to_line": null,
          "vulnerability_code": "            return fail(Error.PRICE_ERROR, FailureInfo.SET_COLLATERAL_FACTOR_WITHOUT_PRICE);\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 3378,
          "vulnerability_to_line": null,
          "vulnerability_code": "        }\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-prefix-decrement-not-postfix",
          "vulnerability_from_line": 2742,
          "vulnerability_to_line": null,
          "vulnerability_code": "        storedList.length--;\n",
          "message": "Consider using the prefix decrement expression whenever the return value is not needed. The prefix decrement expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 2652,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < len; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 2729,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < len; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 3176,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < assets.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 931,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(initialExchangeRateMantissa > 0, \"Initial exchange rate must be greater than zero.\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 943,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(err == uint(Error.NO_ERROR), \"Setting interest rate model failed\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 1129,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(opaqueErr == 0, \"borrowRatePerBlock: interestRateModel.borrowRate failed\"); // semi-opaque\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 1146,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(e0 == 0, \"supplyRatePerBlock: calculating borrowRate failed\"); // semi-opaque\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 1149,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(e1 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating underlying failed\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 1152,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(e2 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating borrowsPer failed\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 1155,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(e3 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating oneMinusReserveFactor failed\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 1158,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(e4 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating supplyRate failed\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 1189,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(err == MathError.NO_ERROR, \"borrowBalanceStored: borrowBalanceStoredInternal failed\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 1246,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(err == MathError.NO_ERROR, \"exchangeRateStored: exchangeRateStoredInternal failed\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 1542,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 2193,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(totalReservesNew <= totalReserves, \"reduce reserves unexpected underflow\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 2201,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(err == Error.NO_ERROR, \"reduce reserves transfer out failed\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 2701,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(oErr == 0, \"exitMarket: getAccountSnapshot failed\"); // semi-opaque error code\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 3469,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == unitroller.admin(), \"only unitroller admin can change brains\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "compound-borrowfresh-reentrancy",
          "vulnerability_from_line": 1717,
          "vulnerability_to_line": null,
          "vulnerability_code": "        vars.err = doTransferOut(borrower, borrowAmount);\n",
          "message": "Function borrowFresh() in Compound performs state update after doTransferOut()"
        }
      ]
    },
    "slither": {
      "successfull_analysis": true,
      "errors": [
        "EXIT_CODE_81"
      ],
      "vulnerability_findings": [
        {
          "name": "controlled-delegatecall",
          "vulnerability_from_line": 2506,
          "vulnerability_to_line": 2522,
          "vulnerability_code": "    function () payable external {\n\n        // delegate all other functions to current implementation\n\n        (bool success, ) = comptrollerImplementation.delegatecall(msg.data);\n\n\n\n        // solium-disable-next-line security/no-inline-assembly\n\n        assembly {\n\n              let free_mem_ptr := mload(0x40)\n\n              returndatacopy(free_mem_ptr, 0, returndatasize)\n\n\n\n              switch success\n\n              case 0 { revert(free_mem_ptr, returndatasize) }\n\n              default { return(free_mem_ptr, returndatasize) }\n\n        }\n\n    }\n\n}\n\n\n",
          "message": "Unitroller.fallback (Comptroller.sol#2506-2522) uses delegatecall to a input-controlled function id\n\t(success) = comptrollerImplementation.delegatecall(msg.data) (Comptroller.sol#2508-2510)\n"
        },
        {
          "name": "uninitialized-state",
          "vulnerability_from_line": 2331,
          "vulnerability_to_line": 2334,
          "vulnerability_code": "    address public comptrollerImplementation;\n\n\n\n    /**\n",
          "message": "UnitrollerAdminStorage.comptrollerImplementation (Comptroller.sol#2331-2334) is never initialized. It is used in:\n\t- adminOrInitializing (Comptroller.sol#3501-3511)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 2144,
          "vulnerability_to_line": 2154,
          "vulnerability_code": "    function _reduceReserves(uint reduceAmount) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n\n            return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.\n\n        return _reduceReservesFresh(reduceAmount);\n\n    }\n\n\n",
          "message": "Reentrancy in CToken._reduceReserves (Comptroller.sol#2144-2154):\n\tExternal calls:\n\t- error = accrueInterest() (Comptroller.sol#2145-2146)\n\tState variables written after the call(s):\n\t- totalReserves (Comptroller.sol#2151-2154)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 2075,
          "vulnerability_to_line": 2094,
          "vulnerability_code": "    function _setComptroller(ComptrollerInterface newComptroller) public returns (uint) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COMPTROLLER_OWNER_CHECK);\n\n        }\n\n\n\n        ComptrollerInterface oldComptroller = comptroller;\n\n        // Ensure invoke comptroller.isComptroller() returns true\n\n        require(newComptroller.isComptroller(), \"marker method returned false\");\n\n\n\n        // Set market's comptroller to newComptroller\n\n        comptroller = newComptroller;\n\n\n\n        // Emit NewComptroller(oldComptroller, newComptroller)\n\n        emit NewComptroller(oldComptroller, newComptroller);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Reentrancy in CToken._setComptroller (Comptroller.sol#2075-2094):\n\tExternal calls:\n\t- require(bool,string)(newComptroller.isComptroller(),marker method returned false) (Comptroller.sol#2083-2085)\n\tState variables written after the call(s):\n\t- comptroller (Comptroller.sol#2086-2088)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 2214,
          "vulnerability_to_line": 2225,
          "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n\n        return _setInterestRateModelFresh(newInterestRateModel);\n\n    }\n\n\n\n    /**\n",
          "message": "Reentrancy in CToken._setInterestRateModel (Comptroller.sol#2214-2225):\n\tExternal calls:\n\t- error = accrueInterest() (Comptroller.sol#2215-2216)\n\t- _setInterestRateModelFresh(newInterestRateModel) (Comptroller.sol#2221-2224)\n\tState variables written after the call(s):\n\t- interestRateModel (Comptroller.sol#2221-2224)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 2230,
          "vulnerability_to_line": 2261,
          "vulnerability_code": "    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {\n\n\n\n        // Used to store old model for use in the event that is emitted on success\n\n        InterestRateModel oldInterestRateModel;\n\n\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);\n\n        }\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            // TODO: static_assert + no error code?\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);\n\n        }\n\n\n\n        // Track the market's current interest rate model\n\n        oldInterestRateModel = interestRateModel;\n\n\n\n        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true\n\n        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n\n\n\n        // Set the interest rate model to newInterestRateModel\n\n        interestRateModel = newInterestRateModel;\n\n\n\n        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)\n\n        emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Reentrancy in CToken._setInterestRateModelFresh (Comptroller.sol#2230-2261):\n\tExternal calls:\n\t- require(bool,string)(newInterestRateModel.isInterestRateModel(),marker method returned false) (Comptroller.sol#2250-2252)\n\tState variables written after the call(s):\n\t- interestRateModel (Comptroller.sol#2253-2255)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 2099,
          "vulnerability_to_line": 2109,
          "vulnerability_code": "    function _setReserveFactor(uint newReserveFactorMantissa) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.\n\n            return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.\n\n        return _setReserveFactorFresh(newReserveFactorMantissa);\n\n    }\n\n\n",
          "message": "Reentrancy in CToken._setReserveFactor (Comptroller.sol#2099-2109):\n\tExternal calls:\n\t- error = accrueInterest() (Comptroller.sol#2100-2101)\n\tState variables written after the call(s):\n\t- reserveFactorMantissa (Comptroller.sol#2106-2107)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 3451,
          "vulnerability_to_line": 3468,
          "vulnerability_code": "    function _supportMarket(CToken cToken) external returns (uint) {\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SUPPORT_MARKET_OWNER_CHECK);\n\n        }\n\n\n\n        if (markets[address(cToken)].isListed) {\n\n            return fail(Error.MARKET_ALREADY_LISTED, FailureInfo.SUPPORT_MARKET_EXISTS);\n\n        }\n\n\n\n        cToken.isCToken(); // Sanity check to make sure its really a CToken\n\n\n\n        markets[address(cToken)] = Market({isListed: true, collateralFactorMantissa: 0});\n\n        emit MarketListed(cToken);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Reentrancy in Comptroller._supportMarket (Comptroller.sol#3451-3468):\n\tExternal calls:\n\t- cToken.isCToken() (Comptroller.sol#3460)\n\tState variables written after the call(s):\n\t- markets (Comptroller.sol#3462-3463)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 1314,
          "vulnerability_to_line": 1380,
          "vulnerability_code": "    function accrueInterest() public returns (uint) {\n\n        AccrueInterestLocalVars memory vars;\n\n\n\n        /* Calculate the current borrow interest rate */\n\n        (vars.opaqueErr, vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);\n\n        require(vars.borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n\n        if (vars.opaqueErr != 0) {\n\n            return failOpaque(Error.INTEREST_RATE_MODEL_ERROR, FailureInfo.ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED, vars.opaqueErr);\n\n        }\n\n\n\n        /* Remember the initial block number */\n\n        vars.currentBlockNumber = getBlockNumber();\n\n\n\n        /* Calculate the number of blocks elapsed since the last accrual */\n\n        (vars.mathErr, vars.blockDelta) = subUInt(vars.currentBlockNumber, accrualBlockNumber);\n\n        assert(vars.mathErr == MathError.NO_ERROR); // Block delta should always succeed and if it doesn't, blow up.\n\n\n\n        /*\n\n         * Calculate the interest accumulated into borrows and reserves and the new index:\n\n         *  simpleInterestFactor = borrowRate * blockDelta\n\n         *  interestAccumulated = simpleInterestFactor * totalBorrows\n\n         *  totalBorrowsNew = interestAccumulated + totalBorrows\n\n         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves\n\n         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\n\n         */\n\n        (vars.mathErr, vars.simpleInterestFactor) = mulScalar(Exp({mantissa: vars.borrowRateMantissa}), vars.blockDelta);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.interestAccumulated) = mulScalarTruncate(vars.simpleInterestFactor, totalBorrows);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(vars.interestAccumulated, totalBorrows);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa: reserveFactorMantissa}), vars.interestAccumulated, totalReserves);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.borrowIndexNew) = mulScalarTruncateAddUInt(vars.simpleInterestFactor, borrowIndex, borrowIndex);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accrualBlockNumber = vars.currentBlockNumber;\n\n        borrowIndex = vars.borrowIndexNew;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n        totalReserves = vars.totalReservesNew;\n\n\n\n        /* We emit an AccrueInterest event */\n\n        emit AccrueInterest(vars.interestAccumulated, vars.borrowIndexNew, totalBorrows);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Reentrancy in CToken.accrueInterest (Comptroller.sol#1314-1380):\n\tExternal calls:\n\t- (vars.opaqueErr,vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(),totalBorrows,totalReserves) (Comptroller.sol#1318-1319)\n\tState variables written after the call(s):\n\t- totalBorrows (Comptroller.sol#1371-1372)\n\t- totalReserves (Comptroller.sol#1372-1374)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 1644,
          "vulnerability_to_line": 1654,
          "vulnerability_code": "    function borrowInternal(uint borrowAmount) internal nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n\n            return fail(Error(error), FailureInfo.BORROW_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // borrowFresh emits borrow-specific logs on errors, so we don't need to\n\n        return borrowFresh(msg.sender, borrowAmount);\n\n    }\n\n\n",
          "message": "Reentrancy in CToken.borrowInternal (Comptroller.sol#1644-1654):\n\tExternal calls:\n\t- error = accrueInterest() (Comptroller.sol#1645-1646)\n\t- borrowFresh(msg.sender,borrowAmount) (Comptroller.sol#1651-1652)\n\tState variables written after the call(s):\n\t- totalBorrows (Comptroller.sol#1651-1652)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 2697,
          "vulnerability_to_line": 2749,
          "vulnerability_code": "    function exitMarket(address cTokenAddress) external returns (uint) {\n\n        CToken cToken = CToken(cTokenAddress);\n\n        /* Get sender tokensHeld and amountOwed underlying from the cToken */\n\n        (uint oErr, uint tokensHeld, uint amountOwed, ) = cToken.getAccountSnapshot(msg.sender);\n\n        require(oErr == 0, \"exitMarket: getAccountSnapshot failed\"); // semi-opaque error code\n\n\n\n        /* Fail if the sender has a borrow balance */\n\n        if (amountOwed != 0) {\n\n            return fail(Error.NONZERO_BORROW_BALANCE, FailureInfo.EXIT_MARKET_BALANCE_OWED);\n\n        }\n\n\n\n        /* Fail if the sender is not permitted to redeem all of their tokens */\n\n        uint allowed = redeemAllowedInternal(cTokenAddress, msg.sender, tokensHeld);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.REJECTION, FailureInfo.EXIT_MARKET_REJECTION, allowed);\n\n        }\n\n\n\n        Market storage marketToExit = markets[address(cToken)];\n\n\n\n        /* Return true if the sender is not already \u2018in\u2019 the market */\n\n        if (!marketToExit.accountMembership[msg.sender]) {\n\n            return uint(Error.NO_ERROR);\n\n        }\n\n\n\n        /* Set cToken account membership to false */\n\n        delete marketToExit.accountMembership[msg.sender];\n\n\n\n        /* Delete cToken from the account\u2019s list of assets */\n\n        // load into memory for faster iteration\n\n        CToken[] memory userAssetList = accountAssets[msg.sender];\n\n        uint len = userAssetList.length;\n\n        uint assetIndex = len;\n\n        for (uint i = 0; i < len; i++) {\n\n            if (userAssetList[i] == cToken) {\n\n                assetIndex = i;\n\n                break;\n\n            }\n\n        }\n\n\n\n        // We *must* have found the asset in the list or our redundant data structure is broken\n\n        assert(assetIndex < len);\n\n\n\n        // copy last item in list to location of item to be removed, reduce length by 1\n\n        CToken[] storage storedList = accountAssets[msg.sender];\n\n        storedList[assetIndex] = storedList[storedList.length - 1];\n\n        storedList.length--;\n\n\n\n        emit MarketExited(cToken, msg.sender);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Reentrancy in Comptroller.exitMarket (Comptroller.sol#2697-2749):\n\tExternal calls:\n\t- (oErr,tokensHeld,amountOwed) = cToken.getAccountSnapshot(msg.sender) (Comptroller.sol#2700-2701)\n\t- allowed = redeemAllowedInternal(cTokenAddress,msg.sender,tokensHeld) (Comptroller.sol#2709-2710)\n\tState variables written after the call(s):\n\t- accountAssets (Comptroller.sol#2741-2742)\n\t- accountAssets (Comptroller.sol#2743-2744)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 1869,
          "vulnerability_to_line": 1886,
          "vulnerability_code": "    function liquidateBorrowInternal(address borrower, uint repayAmount, CToken cTokenCollateral) internal nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\n\n            return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED);\n\n        }\n\n\n\n        error = cTokenCollateral.accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\n\n            return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED);\n\n        }\n\n\n\n        // liquidateBorrowFresh emits borrow-specific logs on errors, so we don't need to\n\n        return liquidateBorrowFresh(msg.sender, borrower, repayAmount, cTokenCollateral);\n\n    }\n\n\n",
          "message": "Reentrancy in CToken.liquidateBorrowInternal (Comptroller.sol#1869-1886):\n\tExternal calls:\n\t- error = accrueInterest() (Comptroller.sol#1870-1871)\n\t- error = cTokenCollateral.accrueInterest() (Comptroller.sol#1876-1877)\n\t- liquidateBorrowFresh(msg.sender,borrower,repayAmount,cTokenCollateral) (Comptroller.sol#1883-1884)\n\tState variables written after the call(s):\n\t- totalBorrows (Comptroller.sol#1883-1884)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 1541,
          "vulnerability_to_line": 1639,
          "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n\n\n\n        RedeemLocalVars memory vars;\n\n\n\n        /* exchangeRate = invoke Exchange Rate Stored() */\n\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* If redeemTokensIn > 0: */\n\n        if (redeemTokensIn > 0) {\n\n            /*\n\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\n\n             *  redeemTokens = redeemTokensIn\n\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n\n             */\n\n            vars.redeemTokens = redeemTokensIn;\n\n\n\n            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED, uint(vars.mathErr));\n\n            }\n\n        } else {\n\n            /*\n\n             * We get the current exchange rate and calculate the amount to be redeemed:\n\n             *  redeemTokens = redeemAmountIn / exchangeRate\n\n             *  redeemAmount = redeemAmountIn\n\n             */\n\n\n\n            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED, uint(vars.mathErr));\n\n            }\n\n\n\n            vars.redeemAmount = redeemAmountIn;\n\n        }\n\n\n\n        /* Fail if redeem not allowed */\n\n        uint allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);\n\n        }\n\n\n\n        /*\n\n         * We calculate the new total supply and redeemer balance, checking for underflow:\n\n         *  totalSupplyNew = totalSupply - redeemTokens\n\n         *  accountTokensNew = accountTokens[redeemer] - redeemTokens\n\n         */\n\n        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* Fail gracefully if protocol has insufficient cash */\n\n        if (getCashPrior() < vars.redeemAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We invoke doTransferOut for the redeemer and the redeemAmount.\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken has redeemAmount less of cash.\n\n         *  If doTransferOut fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferOut(redeemer, vars.redeemAmount);\n\n        require(vars.err == Error.NO_ERROR, \"redeem transfer out failed\");\n\n\n\n        /* We write previously calculated values into storage */\n\n        totalSupply = vars.totalSupplyNew;\n\n        accountTokens[redeemer] = vars.accountTokensNew;\n\n\n\n        /* We emit a Transfer event, and a Redeem event */\n\n        emit Transfer(redeemer, address(this), vars.redeemTokens);\n\n        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        /* We call the defense hook */\n\n        comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Reentrancy in CToken.redeemFresh (Comptroller.sol#1541-1639):\n\tExternal calls:\n\t- allowed = comptroller.redeemAllowed(address(this),redeemer,vars.redeemTokens) (Comptroller.sol#1581-1582)\n\tState variables written after the call(s):\n\t- totalSupply (Comptroller.sol#1626-1627)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 1755,
          "vulnerability_to_line": 1765,
          "vulnerability_code": "    function repayBorrowBehalfInternal(address borrower, uint repayAmount) internal nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n\n            return fail(Error(error), FailureInfo.REPAY_BEHALF_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n\n        return repayBorrowFresh(msg.sender, borrower, repayAmount);\n\n    }\n\n\n",
          "message": "Reentrancy in CToken.repayBorrowBehalfInternal (Comptroller.sol#1755-1765):\n\tExternal calls:\n\t- error = accrueInterest() (Comptroller.sol#1756-1757)\n\t- repayBorrowFresh(msg.sender,borrower,repayAmount) (Comptroller.sol#1762-1763)\n\tState variables written after the call(s):\n\t- totalBorrows (Comptroller.sol#1762-1763)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 1739,
          "vulnerability_to_line": 1749,
          "vulnerability_code": "    function repayBorrowInternal(uint repayAmount) internal nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n\n            return fail(Error(error), FailureInfo.REPAY_BORROW_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n\n        return repayBorrowFresh(msg.sender, msg.sender, repayAmount);\n\n    }\n\n\n",
          "message": "Reentrancy in CToken.repayBorrowInternal (Comptroller.sol#1739-1749):\n\tExternal calls:\n\t- error = accrueInterest() (Comptroller.sol#1740-1741)\n\t- repayBorrowFresh(msg.sender,msg.sender,repayAmount) (Comptroller.sol#1746-1747)\n\tState variables written after the call(s):\n\t- totalBorrows (Comptroller.sol#1746-1747)\n"
        },
        {
          "name": "uninitialized-local",
          "vulnerability_from_line": 1424,
          "vulnerability_to_line": 1426,
          "vulnerability_code": "        MintLocalVars memory vars;\n\n\n",
          "message": "vars in CToken.mintFresh (Comptroller.sol#1424-1426) is a local variable never initialiazed\n"
        },
        {
          "name": "uninitialized-local",
          "vulnerability_from_line": 1684,
          "vulnerability_to_line": 1686,
          "vulnerability_code": "        BorrowLocalVars memory vars;\n\n\n",
          "message": "vars in CToken.borrowFresh (Comptroller.sol#1684-1686) is a local variable never initialiazed\n"
        },
        {
          "name": "uninitialized-local",
          "vulnerability_from_line": 1544,
          "vulnerability_to_line": 1546,
          "vulnerability_code": "        RedeemLocalVars memory vars;\n\n\n",
          "message": "vars in CToken.redeemFresh (Comptroller.sol#1544-1546) is a local variable never initialiazed\n"
        },
        {
          "name": "uninitialized-local",
          "vulnerability_from_line": 1794,
          "vulnerability_to_line": 1796,
          "vulnerability_code": "        RepayBorrowLocalVars memory vars;\n\n\n",
          "message": "vars in CToken.repayBorrowFresh (Comptroller.sol#1794-1796) is a local variable never initialiazed\n"
        },
        {
          "name": "uninitialized-local",
          "vulnerability_from_line": 1315,
          "vulnerability_to_line": 1317,
          "vulnerability_code": "        AccrueInterestLocalVars memory vars;\n\n\n",
          "message": "vars in CToken.accrueInterest (Comptroller.sol#1315-1317) is a local variable never initialiazed\n"
        },
        {
          "name": "unused-return",
          "vulnerability_from_line": 3451,
          "vulnerability_to_line": 3468,
          "vulnerability_code": "    function _supportMarket(CToken cToken) external returns (uint) {\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SUPPORT_MARKET_OWNER_CHECK);\n\n        }\n\n\n\n        if (markets[address(cToken)].isListed) {\n\n            return fail(Error.MARKET_ALREADY_LISTED, FailureInfo.SUPPORT_MARKET_EXISTS);\n\n        }\n\n\n\n        cToken.isCToken(); // Sanity check to make sure its really a CToken\n\n\n\n        markets[address(cToken)] = Market({isListed: true, collateralFactorMantissa: 0});\n\n        emit MarketListed(cToken);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Comptroller._supportMarket (Comptroller.sol#3451-3468) does not use the value returned by external calls:\n\t-cToken.isCToken() (Comptroller.sol#3460)\n"
        },
        {
          "name": "calls-loop",
          "vulnerability_from_line": 3180,
          "vulnerability_to_line": 3181,
          "vulnerability_code": "            (oErr, vars.cTokenBalance, vars.borrowBalance, vars.exchangeRateMantissa) = asset.getAccountSnapshot(account);\n",
          "message": "Comptroller.getHypotheticalAccountLiquidityInternal has external calls inside a loop:\n\t- (oErr,vars.cTokenBalance,vars.borrowBalance,vars.exchangeRateMantissa) = asset.getAccountSnapshot(account) (Comptroller.sol#3180-3181)\n"
        },
        {
          "name": "calls-loop",
          "vulnerability_from_line": 3188,
          "vulnerability_to_line": 3189,
          "vulnerability_code": "            vars.oraclePriceMantissa = oracle.getUnderlyingPrice(asset);\n",
          "message": "Comptroller.getHypotheticalAccountLiquidityInternal has external calls inside a loop:\n\t- vars.oraclePriceMantissa = oracle.getUnderlyingPrice(asset) (Comptroller.sol#3188-3189)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 1314,
          "vulnerability_to_line": 1380,
          "vulnerability_code": "    function accrueInterest() public returns (uint) {\n\n        AccrueInterestLocalVars memory vars;\n\n\n\n        /* Calculate the current borrow interest rate */\n\n        (vars.opaqueErr, vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);\n\n        require(vars.borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n\n        if (vars.opaqueErr != 0) {\n\n            return failOpaque(Error.INTEREST_RATE_MODEL_ERROR, FailureInfo.ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED, vars.opaqueErr);\n\n        }\n\n\n\n        /* Remember the initial block number */\n\n        vars.currentBlockNumber = getBlockNumber();\n\n\n\n        /* Calculate the number of blocks elapsed since the last accrual */\n\n        (vars.mathErr, vars.blockDelta) = subUInt(vars.currentBlockNumber, accrualBlockNumber);\n\n        assert(vars.mathErr == MathError.NO_ERROR); // Block delta should always succeed and if it doesn't, blow up.\n\n\n\n        /*\n\n         * Calculate the interest accumulated into borrows and reserves and the new index:\n\n         *  simpleInterestFactor = borrowRate * blockDelta\n\n         *  interestAccumulated = simpleInterestFactor * totalBorrows\n\n         *  totalBorrowsNew = interestAccumulated + totalBorrows\n\n         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves\n\n         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\n\n         */\n\n        (vars.mathErr, vars.simpleInterestFactor) = mulScalar(Exp({mantissa: vars.borrowRateMantissa}), vars.blockDelta);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.interestAccumulated) = mulScalarTruncate(vars.simpleInterestFactor, totalBorrows);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(vars.interestAccumulated, totalBorrows);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa: reserveFactorMantissa}), vars.interestAccumulated, totalReserves);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.borrowIndexNew) = mulScalarTruncateAddUInt(vars.simpleInterestFactor, borrowIndex, borrowIndex);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accrualBlockNumber = vars.currentBlockNumber;\n\n        borrowIndex = vars.borrowIndexNew;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n        totalReserves = vars.totalReservesNew;\n\n\n\n        /* We emit an AccrueInterest event */\n\n        emit AccrueInterest(vars.interestAccumulated, vars.borrowIndexNew, totalBorrows);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Reentrancy in CToken.accrueInterest (Comptroller.sol#1314-1380):\n\tExternal calls:\n\t- (vars.opaqueErr,vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(),totalBorrows,totalReserves) (Comptroller.sol#1318-1319)\n\tState variables written after the call(s):\n\t- accrualBlockNumber (Comptroller.sol#1369-1370)\n\t- borrowIndex (Comptroller.sol#1370-1371)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 1667,
          "vulnerability_to_line": 1734,
          "vulnerability_code": "    function borrowFresh(address payable borrower, uint borrowAmount) internal returns (uint) {\n\n        /* Fail if borrow not allowed */\n\n        uint allowed = comptroller.borrowAllowed(address(this), borrower, borrowAmount);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.BORROW_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.BORROW_FRESHNESS_CHECK);\n\n        }\n\n\n\n        /* Fail gracefully if protocol has insufficient underlying cash */\n\n        if (getCashPrior() < borrowAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.BORROW_CASH_NOT_AVAILABLE);\n\n        }\n\n\n\n        BorrowLocalVars memory vars;\n\n\n\n        /*\n\n         * We calculate the new borrower and total borrow balances, failing on overflow:\n\n         *  accountBorrowsNew = accountBorrows + borrowAmount\n\n         *  totalBorrowsNew = totalBorrows + borrowAmount\n\n         */\n\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We invoke doTransferOut for the borrower and the borrowAmount.\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken borrowAmount less of cash.\n\n         *  If doTransferOut fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferOut(borrower, borrowAmount);\n\n        require(vars.err == Error.NO_ERROR, \"borrow transfer out failed\");\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n\n        accountBorrows[borrower].interestIndex = borrowIndex;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n\n\n        /* We emit a Borrow event */\n\n        emit Borrow(borrower, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n\n\n        /* We call the defense hook */\n\n        comptroller.borrowVerify(address(this), borrower, borrowAmount);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Reentrancy in CToken.borrowFresh (Comptroller.sol#1667-1734):\n\tExternal calls:\n\t- allowed = comptroller.borrowAllowed(address(this),borrower,borrowAmount) (Comptroller.sol#1669-1670)\n\tState variables written after the call(s):\n\t- accountBorrows (Comptroller.sol#1721-1722)\n\t- accountBorrows (Comptroller.sol#1722-1723)\n\t- totalBorrows (Comptroller.sol#1723-1725)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 920,
          "vulnerability_to_line": 949,
          "vulnerability_code": "    constructor(ComptrollerInterface comptroller_,\n\n                InterestRateModel interestRateModel_,\n\n                uint initialExchangeRateMantissa_,\n\n                string memory name_,\n\n                string memory symbol_,\n\n                uint decimals_) internal {\n\n        // Set admin to msg.sender\n\n        admin = msg.sender;\n\n\n\n        // Set initial exchange rate\n\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n\n        require(initialExchangeRateMantissa > 0, \"Initial exchange rate must be greater than zero.\");\n\n\n\n        // Set the comptroller\n\n        uint err = _setComptroller(comptroller_);\n\n        require(err == uint(Error.NO_ERROR), \"Setting comptroller failed\");\n\n\n\n        // Initialize block number and borrow index (block number mocks depend on comptroller being set)\n\n        accrualBlockNumber = getBlockNumber();\n\n        borrowIndex = mantissaOne;\n\n\n\n        // Set the interest rate model (depends on block number / borrow index)\n\n        err = _setInterestRateModelFresh(interestRateModel_);\n\n        require(err == uint(Error.NO_ERROR), \"Setting interest rate model failed\");\n\n\n\n        name = name_;\n\n        symbol = symbol_;\n\n        decimals = decimals_;\n\n    }\n",
          "message": "Reentrancy in CToken.constructor (Comptroller.sol#920-949):\n\tExternal calls:\n\t- err = _setComptroller(comptroller_) (Comptroller.sol#934)\n\tState variables written after the call(s):\n\t- accrualBlockNumber (Comptroller.sol#938)\n\t- borrowIndex (Comptroller.sol#939)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 920,
          "vulnerability_to_line": 949,
          "vulnerability_code": "    constructor(ComptrollerInterface comptroller_,\n\n                InterestRateModel interestRateModel_,\n\n                uint initialExchangeRateMantissa_,\n\n                string memory name_,\n\n                string memory symbol_,\n\n                uint decimals_) internal {\n\n        // Set admin to msg.sender\n\n        admin = msg.sender;\n\n\n\n        // Set initial exchange rate\n\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n\n        require(initialExchangeRateMantissa > 0, \"Initial exchange rate must be greater than zero.\");\n\n\n\n        // Set the comptroller\n\n        uint err = _setComptroller(comptroller_);\n\n        require(err == uint(Error.NO_ERROR), \"Setting comptroller failed\");\n\n\n\n        // Initialize block number and borrow index (block number mocks depend on comptroller being set)\n\n        accrualBlockNumber = getBlockNumber();\n\n        borrowIndex = mantissaOne;\n\n\n\n        // Set the interest rate model (depends on block number / borrow index)\n\n        err = _setInterestRateModelFresh(interestRateModel_);\n\n        require(err == uint(Error.NO_ERROR), \"Setting interest rate model failed\");\n\n\n\n        name = name_;\n\n        symbol = symbol_;\n\n        decimals = decimals_;\n\n    }\n",
          "message": "Reentrancy in CToken.constructor (Comptroller.sol#920-949):\n\tExternal calls:\n\t- err = _setComptroller(comptroller_) (Comptroller.sol#934)\n\t- err = _setInterestRateModelFresh(interestRateModel_) (Comptroller.sol#942)\n\tState variables written after the call(s):\n\t- decimals (Comptroller.sol#947)\n\t- name (Comptroller.sol#945)\n\t- symbol (Comptroller.sol#946)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 1412,
          "vulnerability_to_line": 1491,
          "vulnerability_code": "    function mintFresh(address minter, uint mintAmount) internal returns (uint) {\n\n        /* Fail if mint not allowed */\n\n        uint allowed = comptroller.mintAllowed(address(this), minter, mintAmount);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.MINT_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.MINT_FRESHNESS_CHECK);\n\n        }\n\n\n\n        MintLocalVars memory vars;\n\n\n\n        /* Fail if checkTransferIn fails */\n\n        vars.err = checkTransferIn(minter, mintAmount);\n\n        if (vars.err != Error.NO_ERROR) {\n\n            return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_NOT_POSSIBLE);\n\n        }\n\n\n\n        /*\n\n         * We get the current exchange rate and calculate the number of cTokens to be minted:\n\n         *  mintTokens = mintAmount / exchangeRate\n\n         */\n\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(mintAmount, Exp({mantissa: vars.exchangeRateMantissa}));\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /*\n\n         * We calculate the new total supply of cTokens and minter token balance, checking for overflow:\n\n         *  totalSupplyNew = totalSupply + mintTokens\n\n         *  accountTokensNew = accountTokens[minter] + mintTokens\n\n         */\n\n        (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We call doTransferIn for the minter and the mintAmount\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken holds an additional mintAmount of cash.\n\n         *  If doTransferIn fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferIn(minter, mintAmount);\n\n        if (vars.err != Error.NO_ERROR) {\n\n            return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_FAILED);\n\n        }\n\n\n\n        /* We write previously calculated values into storage */\n\n        totalSupply = vars.totalSupplyNew;\n\n        accountTokens[minter] = vars.accountTokensNew;\n\n\n\n        /* We emit a Mint event, and a Transfer event */\n\n        emit Mint(minter, mintAmount, vars.mintTokens);\n\n        emit Transfer(address(this), minter, vars.mintTokens);\n\n\n\n        /* We call the defense hook */\n\n        comptroller.mintVerify(address(this), minter, mintAmount, vars.mintTokens);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Reentrancy in CToken.mintFresh (Comptroller.sol#1412-1491):\n\tExternal calls:\n\t- allowed = comptroller.mintAllowed(address(this),minter,mintAmount) (Comptroller.sol#1414-1415)\n\tState variables written after the call(s):\n\t- accountTokens (Comptroller.sol#1479-1481)\n\t- totalSupply (Comptroller.sol#1478-1479)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 1541,
          "vulnerability_to_line": 1639,
          "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n\n\n\n        RedeemLocalVars memory vars;\n\n\n\n        /* exchangeRate = invoke Exchange Rate Stored() */\n\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* If redeemTokensIn > 0: */\n\n        if (redeemTokensIn > 0) {\n\n            /*\n\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\n\n             *  redeemTokens = redeemTokensIn\n\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n\n             */\n\n            vars.redeemTokens = redeemTokensIn;\n\n\n\n            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED, uint(vars.mathErr));\n\n            }\n\n        } else {\n\n            /*\n\n             * We get the current exchange rate and calculate the amount to be redeemed:\n\n             *  redeemTokens = redeemAmountIn / exchangeRate\n\n             *  redeemAmount = redeemAmountIn\n\n             */\n\n\n\n            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED, uint(vars.mathErr));\n\n            }\n\n\n\n            vars.redeemAmount = redeemAmountIn;\n\n        }\n\n\n\n        /* Fail if redeem not allowed */\n\n        uint allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);\n\n        }\n\n\n\n        /*\n\n         * We calculate the new total supply and redeemer balance, checking for underflow:\n\n         *  totalSupplyNew = totalSupply - redeemTokens\n\n         *  accountTokensNew = accountTokens[redeemer] - redeemTokens\n\n         */\n\n        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* Fail gracefully if protocol has insufficient cash */\n\n        if (getCashPrior() < vars.redeemAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We invoke doTransferOut for the redeemer and the redeemAmount.\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken has redeemAmount less of cash.\n\n         *  If doTransferOut fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferOut(redeemer, vars.redeemAmount);\n\n        require(vars.err == Error.NO_ERROR, \"redeem transfer out failed\");\n\n\n\n        /* We write previously calculated values into storage */\n\n        totalSupply = vars.totalSupplyNew;\n\n        accountTokens[redeemer] = vars.accountTokensNew;\n\n\n\n        /* We emit a Transfer event, and a Redeem event */\n\n        emit Transfer(redeemer, address(this), vars.redeemTokens);\n\n        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        /* We call the defense hook */\n\n        comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Reentrancy in CToken.redeemFresh (Comptroller.sol#1541-1639):\n\tExternal calls:\n\t- allowed = comptroller.redeemAllowed(address(this),redeemer,vars.redeemTokens) (Comptroller.sol#1581-1582)\n\tState variables written after the call(s):\n\t- accountTokens (Comptroller.sol#1627-1629)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 1782,
          "vulnerability_to_line": 1861,
          "vulnerability_code": "    function repayBorrowFresh(address payer, address borrower, uint repayAmount) internal returns (uint) {\n\n        /* Fail if repayBorrow not allowed */\n\n        uint allowed = comptroller.repayBorrowAllowed(address(this), payer, borrower, repayAmount);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REPAY_BORROW_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REPAY_BORROW_FRESHNESS_CHECK);\n\n        }\n\n\n\n        RepayBorrowLocalVars memory vars;\n\n\n\n        /* We remember the original borrowerIndex for verification purposes */\n\n        vars.borrowerIndex = accountBorrows[borrower].interestIndex;\n\n\n\n        /* We fetch the amount the borrower owes, with accumulated interest */\n\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* If repayAmount == -1, repayAmount = accountBorrows */\n\n        if (repayAmount == uint(-1)) {\n\n            vars.repayAmount = vars.accountBorrows;\n\n        } else {\n\n            vars.repayAmount = repayAmount;\n\n        }\n\n\n\n        /* Fail if checkTransferIn fails */\n\n        vars.err = checkTransferIn(payer, vars.repayAmount);\n\n        if (vars.err != Error.NO_ERROR) {\n\n            return fail(vars.err, FailureInfo.REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE);\n\n        }\n\n\n\n        /*\n\n         * We calculate the new borrower and total borrow balances, failing on underflow:\n\n         *  accountBorrowsNew = accountBorrows - repayAmount\n\n         *  totalBorrowsNew = totalBorrows - repayAmount\n\n         */\n\n        (vars.mathErr, vars.accountBorrowsNew) = subUInt(vars.accountBorrows, vars.repayAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = subUInt(totalBorrows, vars.repayAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We call doTransferIn for the payer and the repayAmount\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken holds an additional repayAmount of cash.\n\n         *  If doTransferIn fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferIn(payer, vars.repayAmount);\n\n        require(vars.err == Error.NO_ERROR, \"repay borrow transfer in failed\");\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n\n        accountBorrows[borrower].interestIndex = borrowIndex;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n\n\n        /* We emit a RepayBorrow event */\n\n        emit RepayBorrow(payer, borrower, vars.repayAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n\n\n        /* We call the defense hook */\n\n        comptroller.repayBorrowVerify(address(this), payer, borrower, vars.repayAmount, vars.borrowerIndex);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Reentrancy in CToken.repayBorrowFresh (Comptroller.sol#1782-1861):\n\tExternal calls:\n\t- allowed = comptroller.repayBorrowAllowed(address(this),payer,borrower,repayAmount) (Comptroller.sol#1784-1785)\n\tState variables written after the call(s):\n\t- accountBorrows (Comptroller.sol#1848-1849)\n\t- accountBorrows (Comptroller.sol#1849-1850)\n\t- totalBorrows (Comptroller.sol#1850-1852)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 1966,
          "vulnerability_to_line": 2015,
          "vulnerability_code": "    function seize(address liquidator, address borrower, uint seizeTokens) external nonReentrant returns (uint) {\n\n        /* Fail if seize not allowed */\n\n        uint allowed = comptroller.seizeAllowed(address(this), msg.sender, liquidator, borrower, seizeTokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_SEIZE_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Fail if borrower = liquidator */\n\n        if (borrower == liquidator) {\n\n            return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER);\n\n        }\n\n\n\n        MathError mathErr;\n\n        uint borrowerTokensNew;\n\n        uint liquidatorTokensNew;\n\n\n\n        /*\n\n         * We calculate the new borrower and liquidator token balances, failing on underflow/overflow:\n\n         *  borrowerTokensNew = accountTokens[borrower] - seizeTokens\n\n         *  liquidatorTokensNew = accountTokens[liquidator] + seizeTokens\n\n         */\n\n        (mathErr, borrowerTokensNew) = subUInt(accountTokens[borrower], seizeTokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED, uint(mathErr));\n\n        }\n\n\n\n        (mathErr, liquidatorTokensNew) = addUInt(accountTokens[liquidator], seizeTokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED, uint(mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accountTokens[borrower] = borrowerTokensNew;\n\n        accountTokens[liquidator] = liquidatorTokensNew;\n\n\n\n        /* Emit a Transfer event */\n\n        emit Transfer(borrower, liquidator, seizeTokens);\n\n\n\n        /* We call the defense hook */\n\n        comptroller.seizeVerify(address(this), msg.sender, liquidator, borrower, seizeTokens);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n\n",
          "message": "Reentrancy in CToken.seize (Comptroller.sol#1966-2015):\n\tExternal calls:\n\t- allowed = comptroller.seizeAllowed(address(this),msg.sender,liquidator,borrower,seizeTokens) (Comptroller.sol#1968-1969)\n\tState variables written after the call(s):\n\t- accountTokens (Comptroller.sol#2002-2003)\n\t- accountTokens (Comptroller.sol#2003-2005)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 959,
          "vulnerability_to_line": 1020,
          "vulnerability_code": "    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (uint) {\n\n        /* Fail if transfer not allowed */\n\n        uint allowed = comptroller.transferAllowed(address(this), src, dst, tokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.TRANSFER_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Do not allow self-transfers */\n\n        if (src == dst) {\n\n            return fail(Error.BAD_INPUT, FailureInfo.TRANSFER_NOT_ALLOWED);\n\n        }\n\n\n\n        /* Get the allowance, infinite for the account owner */\n\n        uint startingAllowance = 0;\n\n        if (spender == src) {\n\n            startingAllowance = uint(-1);\n\n        } else {\n\n            startingAllowance = transferAllowances[src][spender];\n\n        }\n\n\n\n        /* Do the calculations, checking for {under,over}flow */\n\n        MathError mathErr;\n\n        uint allowanceNew;\n\n        uint srcTokensNew;\n\n        uint dstTokensNew;\n\n\n\n        (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ALLOWED);\n\n        }\n\n\n\n        (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ENOUGH);\n\n        }\n\n\n\n        (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_TOO_MUCH);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        accountTokens[src] = srcTokensNew;\n\n        accountTokens[dst] = dstTokensNew;\n\n\n\n        /* Eat some of the allowance (if necessary) */\n\n        if (startingAllowance != uint(-1)) {\n\n            transferAllowances[src][spender] = allowanceNew;\n\n        }\n\n\n\n        /* We emit a Transfer event */\n\n        emit Transfer(src, dst, tokens);\n\n\n\n        /* We call the defense hook (which checks for under-collateralization) */\n\n        comptroller.transferVerify(address(this), src, dst, tokens);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n",
          "message": "Reentrancy in CToken.transferTokens (Comptroller.sol#959-1020):\n\tExternal calls:\n\t- allowed = comptroller.transferAllowed(address(this),src,dst,tokens) (Comptroller.sol#961)\n\tState variables written after the call(s):\n\t- accountTokens (Comptroller.sol#1004)\n\t- accountTokens (Comptroller.sol#1005)\n\t- transferAllowances (Comptroller.sol#1009)\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 2506,
          "vulnerability_to_line": 2522,
          "vulnerability_code": "    function () payable external {\n\n        // delegate all other functions to current implementation\n\n        (bool success, ) = comptrollerImplementation.delegatecall(msg.data);\n\n\n\n        // solium-disable-next-line security/no-inline-assembly\n\n        assembly {\n\n              let free_mem_ptr := mload(0x40)\n\n              returndatacopy(free_mem_ptr, 0, returndatasize)\n\n\n\n              switch success\n\n              case 0 { revert(free_mem_ptr, returndatasize) }\n\n              default { return(free_mem_ptr, returndatasize) }\n\n        }\n\n    }\n\n}\n\n\n",
          "message": "Unitroller.fallback uses assembly (Comptroller.sol#2506-2522)\n\t- Comptroller.sol#2512-2522\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 2214,
          "vulnerability_to_line": 2225,
          "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n\n        return _setInterestRateModelFresh(newInterestRateModel);\n\n    }\n\n\n\n    /**\n",
          "message": "CToken._setInterestRateModel (Comptroller.sol#2214-2225) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 2407,
          "vulnerability_to_line": 2423,
          "vulnerability_code": "    function _setPendingImplementation(address newPendingImplementation) public returns (uint) {\n\n\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_IMPLEMENTATION_OWNER_CHECK);\n\n        }\n\n\n\n        address oldPendingImplementation = pendingComptrollerImplementation;\n\n\n\n        pendingComptrollerImplementation = newPendingImplementation;\n\n\n\n        emit NewPendingImplementation(oldPendingImplementation, pendingComptrollerImplementation);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
          "message": "Unitroller._setPendingImplementation (Comptroller.sol#2407-2423) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 2427,
          "vulnerability_to_line": 2449,
          "vulnerability_code": "    function _acceptImplementation() public returns (uint) {\n\n        // Check caller is pendingImplementation and pendingImplementation \u2260 address(0)\n\n        if (msg.sender != pendingComptrollerImplementation || pendingComptrollerImplementation == address(0)) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_PENDING_IMPLEMENTATION_ADDRESS_CHECK);\n\n        }\n\n\n\n        // Save current values for inclusion in log\n\n        address oldImplementation = comptrollerImplementation;\n\n        address oldPendingImplementation = pendingComptrollerImplementation;\n\n\n\n        comptrollerImplementation = pendingComptrollerImplementation;\n\n\n\n        pendingComptrollerImplementation = address(0);\n\n\n\n        emit NewImplementation(oldImplementation, comptrollerImplementation);\n\n        emit NewPendingImplementation(oldPendingImplementation, pendingComptrollerImplementation);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n\n\n    /**\n",
          "message": "Unitroller._acceptImplementation (Comptroller.sol#2427-2449) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 2456,
          "vulnerability_to_line": 2475,
          "vulnerability_code": "    function _setPendingAdmin(address newPendingAdmin) public returns (uint) {\n\n        // Check caller = admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);\n\n        }\n\n\n\n        // Save current value, if any, for inclusion in log\n\n        address oldPendingAdmin = pendingAdmin;\n\n\n\n        // Store pendingAdmin with value newPendingAdmin\n\n        pendingAdmin = newPendingAdmin;\n\n\n\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\n\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
          "message": "Unitroller._setPendingAdmin (Comptroller.sol#2456-2475) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 2479,
          "vulnerability_to_line": 2502,
          "vulnerability_code": "    function _acceptAdmin() public returns (uint) {\n\n        // Check caller is pendingAdmin and pendingAdmin \u2260 address(0)\n\n        if (msg.sender != pendingAdmin || msg.sender == address(0)) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);\n\n        }\n\n\n\n        // Save current values for inclusion in log\n\n        address oldAdmin = admin;\n\n        address oldPendingAdmin = pendingAdmin;\n\n\n\n        // Store admin with value pendingAdmin\n\n        admin = pendingAdmin;\n\n\n\n        // Clear the pending value\n\n        pendingAdmin = address(0);\n\n\n\n        emit NewAdmin(oldAdmin, admin);\n\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
          "message": "Unitroller._acceptAdmin (Comptroller.sol#2479-2502) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 2648,
          "vulnerability_to_line": 2691,
          "vulnerability_code": "    function enterMarkets(address[] memory cTokens) public returns (uint[] memory) {\n\n        uint len = cTokens.length;\n\n\n\n        uint[] memory results = new uint[](len);\n\n        for (uint i = 0; i < len; i++) {\n\n            CToken cToken = CToken(cTokens[i]);\n\n            Market storage marketToJoin = markets[address(cToken)];\n\n\n\n            if (!marketToJoin.isListed) {\n\n                // if market is not listed, cannot join move along\n\n                results[i] = uint(Error.MARKET_NOT_LISTED);\n\n                continue;\n\n            }\n\n\n\n            if (marketToJoin.accountMembership[msg.sender] == true) {\n\n                // if already joined, move along\n\n                results[i] = uint(Error.NO_ERROR);\n\n                continue;\n\n            }\n\n\n\n            if (accountAssets[msg.sender].length >= maxAssets)  {\n\n                // if no space, cannot join, move along\n\n                results[i] = uint(Error.TOO_MANY_ASSETS);\n\n                continue;\n\n            }\n\n\n\n            // survived the gauntlet, add to list\n\n            // NOTE: we store these somewhat redundantly as a significant optimization\n\n            //  this avoids having to iterate through the list for the most common use cases\n\n            //  that is, only when we need to perform liquidity checks\n\n            //   and not whenever we want to check if an account is in a particular market\n\n            marketToJoin.accountMembership[msg.sender] = true;\n\n            accountAssets[msg.sender].push(cToken);\n\n\n\n            emit MarketEntered(cToken, msg.sender);\n\n\n\n            results[i] = uint(Error.NO_ERROR);\n\n        }\n\n\n\n        return results;\n\n    }\n\n\n\n    /**\n",
          "message": "Comptroller.enterMarkets (Comptroller.sol#2648-2691) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 628,
          "vulnerability_to_line": 629,
          "vulnerability_code": "    function enterMarkets(address[] calldata cTokens) external returns (uint[] memory);\n",
          "message": "ComptrollerInterface.enterMarkets (Comptroller.sol#628-629) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 3136,
          "vulnerability_to_line": 3143,
          "vulnerability_code": "    function getAccountLiquidity(address account) public view returns (uint, uint, uint) {\n\n        (Error err, uint liquidity, uint shortfall) = getHypotheticalAccountLiquidityInternal(account, CToken(0), 0, 0);\n\n\n\n        return (uint(err), liquidity, shortfall);\n\n    }\n\n\n\n    /**\n",
          "message": "Comptroller.getAccountLiquidity (Comptroller.sol#3136-3143) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 3297,
          "vulnerability_to_line": 3319,
          "vulnerability_code": "    function _setPriceOracle(PriceOracle newOracle) public returns (uint) {\n\n        // Check caller is admin OR currently initialzing as new unitroller implementation\n\n        if (!adminOrInitializing()) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PRICE_ORACLE_OWNER_CHECK);\n\n        }\n\n\n\n        // Track the old oracle for the comptroller\n\n        PriceOracle oldOracle = oracle;\n\n\n\n        // Ensure invoke newOracle.isPriceOracle() returns true\n\n        // require(newOracle.isPriceOracle(), \"oracle method isPriceOracle returned false\");\n\n\n\n        // Set comptroller's oracle to newOracle\n\n        oracle = newOracle;\n\n\n\n        // Emit NewPriceOracle(oldOracle, newOracle)\n\n        emit NewPriceOracle(oldOracle, newOracle);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
          "message": "Comptroller._setPriceOracle (Comptroller.sol#3297-3319) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 3468,
          "vulnerability_to_line": 3496,
          "vulnerability_code": "    function _become(Unitroller unitroller, PriceOracle _oracle, uint _closeFactorMantissa, uint _maxAssets, bool reinitializing) public {\n\n        require(msg.sender == unitroller.admin(), \"only unitroller admin can change brains\");\n\n        uint changeStatus = unitroller._acceptImplementation();\n\n\n\n        require(changeStatus == 0, \"change not authorized\");\n\n\n\n        if (!reinitializing) {\n\n            Comptroller freshBrainedComptroller = Comptroller(address(unitroller));\n\n\n\n            // Ensure invoke _setPriceOracle() = 0\n\n            uint err = freshBrainedComptroller._setPriceOracle(_oracle);\n\n            require (err == uint(Error.NO_ERROR), \"set price oracle error\");\n\n\n\n            // Ensure invoke _setCloseFactor() = 0\n\n            err = freshBrainedComptroller._setCloseFactor(_closeFactorMantissa);\n\n            require (err == uint(Error.NO_ERROR), \"set close factor error\");\n\n\n\n            // Ensure invoke _setMaxAssets() = 0\n\n            err = freshBrainedComptroller._setMaxAssets(_maxAssets);\n\n            require (err == uint(Error.NO_ERROR), \"set max asssets error\");\n\n\n\n            // Ensure invoke _setLiquidationIncentive(liquidationIncentiveMinMantissa) = 0\n\n            err = freshBrainedComptroller._setLiquidationIncentive(liquidationIncentiveMinMantissa);\n\n            require (err == uint(Error.NO_ERROR), \"set liquidation incentive error\");\n\n        }\n\n    }\n\n\n\n    /**\n",
          "message": "Comptroller._become (Comptroller.sol#3468-3496) should be declared external\n"
        },
        {
          "name": "solc-version",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.10;\n",
          "message": "Detected issues with version pragma in Comptroller.sol:\n\t- pragma solidity^0.5.10 (Comptroller.sol#3): it allows old versions\n\t- pragma solidity^0.5.10 (Comptroller.sol#65): it allows old versions\n\t- pragma solidity^0.5.10 (Comptroller.sol#153): it allows old versions\n\t- pragma solidity^0.5.10 (Comptroller.sol#374): it allows old versions\n\t- pragma solidity^0.5.10 (Comptroller.sol#581): it allows old versions\n\t- pragma solidity^0.5.10 (Comptroller.sol#616-617): it allows old versions\n\t- pragma solidity^0.5.10 (Comptroller.sol#694-695): it allows old versions\n\t- pragma solidity^0.5.10 (Comptroller.sol#726-727): it allows old versions\n\t- pragma solidity^0.5.10 (Comptroller.sol#2293-2296): it allows old versions\n\t- pragma solidity^0.5.10 (Comptroller.sol#2313-2317): it allows old versions\n\t- pragma solidity^0.5.10 (Comptroller.sol#2370-2374): it allows old versions\n\t- pragma solidity^0.5.10 (Comptroller.sol#2524-2527): it allows old versions\n"
        },
        {
          "name": "low-level-calls",
          "vulnerability_from_line": 2506,
          "vulnerability_to_line": 2522,
          "vulnerability_code": "    function () payable external {\n\n        // delegate all other functions to current implementation\n\n        (bool success, ) = comptrollerImplementation.delegatecall(msg.data);\n\n\n\n        // solium-disable-next-line security/no-inline-assembly\n\n        assembly {\n\n              let free_mem_ptr := mload(0x40)\n\n              returndatacopy(free_mem_ptr, 0, returndatasize)\n\n\n\n              switch success\n\n              case 0 { revert(free_mem_ptr, returndatasize) }\n\n              default { return(free_mem_ptr, returndatasize) }\n\n        }\n\n    }\n\n}\n\n\n",
          "message": "Low level call in Unitroller.fallback (Comptroller.sol#2506-2522):\n\t-(success) = comptrollerImplementation.delegatecall(msg.data) Comptroller.sol#2508-2510\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 164,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint constant expScale = 1e18;\n",
          "message": "Constant 'Exponential.expScale' (Comptroller.sol#164) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 165,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint constant halfExpScale = expScale/2;\n",
          "message": "Constant 'Exponential.halfExpScale' (Comptroller.sol#165) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 166,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint constant mantissaOne = expScale;\n",
          "message": "Constant 'Exponential.mantissaOne' (Comptroller.sol#166) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 2025,
          "vulnerability_to_line": 2043,
          "vulnerability_code": "    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint) {\n\n        // Check caller = admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);\n\n        }\n\n\n\n        // Save current value, if any, for inclusion in log\n\n        address oldPendingAdmin = pendingAdmin;\n\n\n\n        // Store pendingAdmin with value newPendingAdmin\n\n        pendingAdmin = newPendingAdmin;\n\n\n\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\n\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Function 'CToken._setPendingAdmin' (Comptroller.sol#2025-2043) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 2048,
          "vulnerability_to_line": 2070,
          "vulnerability_code": "    function _acceptAdmin() external returns (uint) {\n\n        // Check caller is pendingAdmin and pendingAdmin \u2260 address(0)\n\n        if (msg.sender != pendingAdmin || msg.sender == address(0)) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);\n\n        }\n\n\n\n        // Save current values for inclusion in log\n\n        address oldAdmin = admin;\n\n        address oldPendingAdmin = pendingAdmin;\n\n\n\n        // Store admin with value pendingAdmin\n\n        admin = pendingAdmin;\n\n\n\n        // Clear the pending value\n\n        pendingAdmin = address(0);\n\n\n\n        emit NewAdmin(oldAdmin, admin);\n\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Function 'CToken._acceptAdmin' (Comptroller.sol#2048-2070) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 2075,
          "vulnerability_to_line": 2094,
          "vulnerability_code": "    function _setComptroller(ComptrollerInterface newComptroller) public returns (uint) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COMPTROLLER_OWNER_CHECK);\n\n        }\n\n\n\n        ComptrollerInterface oldComptroller = comptroller;\n\n        // Ensure invoke comptroller.isComptroller() returns true\n\n        require(newComptroller.isComptroller(), \"marker method returned false\");\n\n\n\n        // Set market's comptroller to newComptroller\n\n        comptroller = newComptroller;\n\n\n\n        // Emit NewComptroller(oldComptroller, newComptroller)\n\n        emit NewComptroller(oldComptroller, newComptroller);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Function 'CToken._setComptroller' (Comptroller.sol#2075-2094) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 2099,
          "vulnerability_to_line": 2109,
          "vulnerability_code": "    function _setReserveFactor(uint newReserveFactorMantissa) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.\n\n            return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.\n\n        return _setReserveFactorFresh(newReserveFactorMantissa);\n\n    }\n\n\n",
          "message": "Function 'CToken._setReserveFactor' (Comptroller.sol#2099-2109) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 2114,
          "vulnerability_to_line": 2139,
          "vulnerability_code": "    function _setReserveFactorFresh(uint newReserveFactorMantissa) internal returns (uint) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_RESERVE_FACTOR_ADMIN_CHECK);\n\n        }\n\n\n\n        // Verify market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            // TODO: static_assert + no error code?\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_RESERVE_FACTOR_FRESH_CHECK);\n\n        }\n\n\n\n        // Check newReserveFactor \u2264 maxReserveFactor\n\n        if (newReserveFactorMantissa > reserveFactorMaxMantissa) {\n\n            return fail(Error.BAD_INPUT, FailureInfo.SET_RESERVE_FACTOR_BOUNDS_CHECK);\n\n        }\n\n\n\n        uint oldReserveFactorMantissa = reserveFactorMantissa;\n\n        reserveFactorMantissa = newReserveFactorMantissa;\n\n\n\n        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Function 'CToken._setReserveFactorFresh' (Comptroller.sol#2114-2139) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 2144,
          "vulnerability_to_line": 2154,
          "vulnerability_code": "    function _reduceReserves(uint reduceAmount) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n\n            return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.\n\n        return _reduceReservesFresh(reduceAmount);\n\n    }\n\n\n",
          "message": "Function 'CToken._reduceReserves' (Comptroller.sol#2144-2154) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 2160,
          "vulnerability_to_line": 2209,
          "vulnerability_code": "    function _reduceReservesFresh(uint reduceAmount) internal returns (uint) {\n\n        Error err;\n\n        // totalReserves - reduceAmount\n\n        uint totalReservesNew;\n\n\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.REDUCE_RESERVES_ADMIN_CHECK);\n\n        }\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            // TODO: static_assert + no error code?\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDUCE_RESERVES_FRESH_CHECK);\n\n        }\n\n\n\n        // Fail gracefully if protocol has insufficient underlying cash\n\n        if (getCashPrior() < reduceAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDUCE_RESERVES_CASH_NOT_AVAILABLE);\n\n        }\n\n\n\n        // Check reduceAmount \u2264 reserves[n] (totalReserves)\n\n        // TODO: I'm following the spec literally here but I think we should we just use SafeMath instead and fail on an error (which would be underflow)\n\n        if (reduceAmount > totalReserves) {\n\n            return fail(Error.BAD_INPUT, FailureInfo.REDUCE_RESERVES_VALIDATION);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        totalReservesNew = totalReserves - reduceAmount;\n\n        // We checked reduceAmount <= totalReserves above, so this should never revert.\n\n        require(totalReservesNew <= totalReserves, \"reduce reserves unexpected underflow\");\n\n\n\n        // Store reserves[n+1] = reserves[n] - reduceAmount\n\n        totalReserves = totalReservesNew;\n\n\n\n        // invoke doTransferOut(reduceAmount, admin)\n\n        err = doTransferOut(admin, reduceAmount);\n\n        // we revert on the failure of this command\n\n        require(err == Error.NO_ERROR, \"reduce reserves transfer out failed\");\n\n\n\n        emit ReservesReduced(admin, reduceAmount, totalReservesNew);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
          "message": "Function 'CToken._reduceReservesFresh' (Comptroller.sol#2160-2209) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 2214,
          "vulnerability_to_line": 2225,
          "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n\n        return _setInterestRateModelFresh(newInterestRateModel);\n\n    }\n\n\n\n    /**\n",
          "message": "Function 'CToken._setInterestRateModel' (Comptroller.sol#2214-2225) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 2230,
          "vulnerability_to_line": 2261,
          "vulnerability_code": "    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {\n\n\n\n        // Used to store old model for use in the event that is emitted on success\n\n        InterestRateModel oldInterestRateModel;\n\n\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);\n\n        }\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            // TODO: static_assert + no error code?\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);\n\n        }\n\n\n\n        // Track the market's current interest rate model\n\n        oldInterestRateModel = interestRateModel;\n\n\n\n        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true\n\n        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n\n\n\n        // Set the interest rate model to newInterestRateModel\n\n        interestRateModel = newInterestRateModel;\n\n\n\n        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)\n\n        emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Function 'CToken._setInterestRateModelFresh' (Comptroller.sol#2230-2261) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 737,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bool public constant isCToken = true;\n",
          "message": "Constant 'CToken.isCToken' (Comptroller.sol#737) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 757,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint constant borrowRateMaxMantissa = 5e14;\n",
          "message": "Constant 'CToken.borrowRateMaxMantissa' (Comptroller.sol#757) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 762,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint constant reserveFactorMaxMantissa = 1e18;\n",
          "message": "Constant 'CToken.reserveFactorMaxMantissa' (Comptroller.sol#762) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 2407,
          "vulnerability_to_line": 2423,
          "vulnerability_code": "    function _setPendingImplementation(address newPendingImplementation) public returns (uint) {\n\n\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_IMPLEMENTATION_OWNER_CHECK);\n\n        }\n\n\n\n        address oldPendingImplementation = pendingComptrollerImplementation;\n\n\n\n        pendingComptrollerImplementation = newPendingImplementation;\n\n\n\n        emit NewPendingImplementation(oldPendingImplementation, pendingComptrollerImplementation);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
          "message": "Function 'Unitroller._setPendingImplementation' (Comptroller.sol#2407-2423) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 2427,
          "vulnerability_to_line": 2449,
          "vulnerability_code": "    function _acceptImplementation() public returns (uint) {\n\n        // Check caller is pendingImplementation and pendingImplementation \u2260 address(0)\n\n        if (msg.sender != pendingComptrollerImplementation || pendingComptrollerImplementation == address(0)) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_PENDING_IMPLEMENTATION_ADDRESS_CHECK);\n\n        }\n\n\n\n        // Save current values for inclusion in log\n\n        address oldImplementation = comptrollerImplementation;\n\n        address oldPendingImplementation = pendingComptrollerImplementation;\n\n\n\n        comptrollerImplementation = pendingComptrollerImplementation;\n\n\n\n        pendingComptrollerImplementation = address(0);\n\n\n\n        emit NewImplementation(oldImplementation, comptrollerImplementation);\n\n        emit NewPendingImplementation(oldPendingImplementation, pendingComptrollerImplementation);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n\n\n    /**\n",
          "message": "Function 'Unitroller._acceptImplementation' (Comptroller.sol#2427-2449) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 2456,
          "vulnerability_to_line": 2475,
          "vulnerability_code": "    function _setPendingAdmin(address newPendingAdmin) public returns (uint) {\n\n        // Check caller = admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);\n\n        }\n\n\n\n        // Save current value, if any, for inclusion in log\n\n        address oldPendingAdmin = pendingAdmin;\n\n\n\n        // Store pendingAdmin with value newPendingAdmin\n\n        pendingAdmin = newPendingAdmin;\n\n\n\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\n\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
          "message": "Function 'Unitroller._setPendingAdmin' (Comptroller.sol#2456-2475) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 2479,
          "vulnerability_to_line": 2502,
          "vulnerability_code": "    function _acceptAdmin() public returns (uint) {\n\n        // Check caller is pendingAdmin and pendingAdmin \u2260 address(0)\n\n        if (msg.sender != pendingAdmin || msg.sender == address(0)) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);\n\n        }\n\n\n\n        // Save current values for inclusion in log\n\n        address oldAdmin = admin;\n\n        address oldPendingAdmin = pendingAdmin;\n\n\n\n        // Store admin with value pendingAdmin\n\n        admin = pendingAdmin;\n\n\n\n        // Clear the pending value\n\n        pendingAdmin = address(0);\n\n\n\n        emit NewAdmin(oldAdmin, admin);\n\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
          "message": "Function 'Unitroller._acceptAdmin' (Comptroller.sol#2479-2502) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 3297,
          "vulnerability_to_line": 3319,
          "vulnerability_code": "    function _setPriceOracle(PriceOracle newOracle) public returns (uint) {\n\n        // Check caller is admin OR currently initialzing as new unitroller implementation\n\n        if (!adminOrInitializing()) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PRICE_ORACLE_OWNER_CHECK);\n\n        }\n\n\n\n        // Track the old oracle for the comptroller\n\n        PriceOracle oldOracle = oracle;\n\n\n\n        // Ensure invoke newOracle.isPriceOracle() returns true\n\n        // require(newOracle.isPriceOracle(), \"oracle method isPriceOracle returned false\");\n\n\n\n        // Set comptroller's oracle to newOracle\n\n        oracle = newOracle;\n\n\n\n        // Emit NewPriceOracle(oldOracle, newOracle)\n\n        emit NewPriceOracle(oldOracle, newOracle);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
          "message": "Function 'Comptroller._setPriceOracle' (Comptroller.sol#3297-3319) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 3324,
          "vulnerability_to_line": 3349,
          "vulnerability_code": "    function _setCloseFactor(uint newCloseFactorMantissa) external returns (uint256) {\n\n        // Check caller is admin OR currently initialzing as new unitroller implementation\n\n        if (!adminOrInitializing()) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_CLOSE_FACTOR_OWNER_CHECK);\n\n        }\n\n\n\n        Exp memory newCloseFactorExp = Exp({mantissa: newCloseFactorMantissa});\n\n        Exp memory lowLimit = Exp({mantissa: closeFactorMinMantissa});\n\n        if (lessThanOrEqualExp(newCloseFactorExp, lowLimit)) {\n\n            return fail(Error.INVALID_CLOSE_FACTOR, FailureInfo.SET_CLOSE_FACTOR_VALIDATION);\n\n        }\n\n\n\n        Exp memory highLimit = Exp({mantissa: closeFactorMaxMantissa});\n\n        if (lessThanExp(highLimit, newCloseFactorExp)) {\n\n            return fail(Error.INVALID_CLOSE_FACTOR, FailureInfo.SET_CLOSE_FACTOR_VALIDATION);\n\n        }\n\n\n\n        uint oldCloseFactorMantissa = closeFactorMantissa;\n\n        closeFactorMantissa = newCloseFactorMantissa;\n\n        emit NewCloseFactor(oldCloseFactorMantissa, closeFactorMantissa);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
          "message": "Function 'Comptroller._setCloseFactor' (Comptroller.sol#3324-3349) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 3355,
          "vulnerability_to_line": 3391,
          "vulnerability_code": "    function _setCollateralFactor(CToken cToken, uint newCollateralFactorMantissa) external returns (uint256) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COLLATERAL_FACTOR_OWNER_CHECK);\n\n        }\n\n\n\n        // Verify market is listed\n\n        Market storage market = markets[address(cToken)];\n\n        if (!market.isListed) {\n\n            return fail(Error.MARKET_NOT_LISTED, FailureInfo.SET_COLLATERAL_FACTOR_NO_EXISTS);\n\n        }\n\n\n\n        Exp memory newCollateralFactorExp = Exp({mantissa: newCollateralFactorMantissa});\n\n\n\n        // Check collateral factor <= 0.9\n\n        Exp memory highLimit = Exp({mantissa: collateralFactorMaxMantissa});\n\n        if (lessThanExp(highLimit, newCollateralFactorExp)) {\n\n            return fail(Error.INVALID_COLLATERAL_FACTOR, FailureInfo.SET_COLLATERAL_FACTOR_VALIDATION);\n\n        }\n\n\n\n        // If collateral factor != 0, fail if price == 0\n\n        if (newCollateralFactorMantissa != 0 && oracle.getUnderlyingPrice(cToken) == 0) {\n\n            return fail(Error.PRICE_ERROR, FailureInfo.SET_COLLATERAL_FACTOR_WITHOUT_PRICE);\n\n        }\n\n\n\n        // Set market's collateral factor to new collateral factor, remember old value\n\n        uint oldCollateralFactorMantissa = market.collateralFactorMantissa;\n\n        market.collateralFactorMantissa = newCollateralFactorMantissa;\n\n\n\n        // Emit event with asset, old collateral factor, and new collateral factor\n\n        emit NewCollateralFactor(cToken, oldCollateralFactorMantissa, newCollateralFactorMantissa);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
          "message": "Function 'Comptroller._setCollateralFactor' (Comptroller.sol#3355-3391) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 3396,
          "vulnerability_to_line": 3410,
          "vulnerability_code": "    function _setMaxAssets(uint newMaxAssets) external returns (uint) {\n\n        // Check caller is admin OR currently initialzing as new unitroller implementation\n\n        if (!adminOrInitializing()) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_MAX_ASSETS_OWNER_CHECK);\n\n        }\n\n\n\n        uint oldMaxAssets = maxAssets;\n\n        maxAssets = newMaxAssets;\n\n        emit NewMaxAssets(oldMaxAssets, newMaxAssets);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
          "message": "Function 'Comptroller._setMaxAssets' (Comptroller.sol#3396-3410) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 3415,
          "vulnerability_to_line": 3446,
          "vulnerability_code": "    function _setLiquidationIncentive(uint newLiquidationIncentiveMantissa) external returns (uint) {\n\n        // Check caller is admin OR currently initialzing as new unitroller implementation\n\n        if (!adminOrInitializing()) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_LIQUIDATION_INCENTIVE_OWNER_CHECK);\n\n        }\n\n\n\n        // Check de-scaled 1 <= newLiquidationDiscount <= 1.5\n\n        Exp memory newLiquidationIncentive = Exp({mantissa: newLiquidationIncentiveMantissa});\n\n        Exp memory minLiquidationIncentive = Exp({mantissa: liquidationIncentiveMinMantissa});\n\n        if (lessThanExp(newLiquidationIncentive, minLiquidationIncentive)) {\n\n            return fail(Error.INVALID_LIQUIDATION_INCENTIVE, FailureInfo.SET_LIQUIDATION_INCENTIVE_VALIDATION);\n\n        }\n\n\n\n        Exp memory maxLiquidationIncentive = Exp({mantissa: liquidationIncentiveMaxMantissa});\n\n        if (lessThanExp(maxLiquidationIncentive, newLiquidationIncentive)) {\n\n            return fail(Error.INVALID_LIQUIDATION_INCENTIVE, FailureInfo.SET_LIQUIDATION_INCENTIVE_VALIDATION);\n\n        }\n\n\n\n        // Save current value for use in log\n\n        uint oldLiquidationIncentiveMantissa = liquidationIncentiveMantissa;\n\n\n\n        // Set liquidation incentive to new incentive\n\n        liquidationIncentiveMantissa = newLiquidationIncentiveMantissa;\n\n\n\n        // Emit event with old incentive, new incentive\n\n        emit NewLiquidationIncentive(oldLiquidationIncentiveMantissa, newLiquidationIncentiveMantissa);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
          "message": "Function 'Comptroller._setLiquidationIncentive' (Comptroller.sol#3415-3446) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 3451,
          "vulnerability_to_line": 3468,
          "vulnerability_code": "    function _supportMarket(CToken cToken) external returns (uint) {\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SUPPORT_MARKET_OWNER_CHECK);\n\n        }\n\n\n\n        if (markets[address(cToken)].isListed) {\n\n            return fail(Error.MARKET_ALREADY_LISTED, FailureInfo.SUPPORT_MARKET_EXISTS);\n\n        }\n\n\n\n        cToken.isCToken(); // Sanity check to make sure its really a CToken\n\n\n\n        markets[address(cToken)] = Market({isListed: true, collateralFactorMantissa: 0});\n\n        emit MarketListed(cToken);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Function 'Comptroller._supportMarket' (Comptroller.sol#3451-3468) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 3468,
          "vulnerability_to_line": 3496,
          "vulnerability_code": "    function _become(Unitroller unitroller, PriceOracle _oracle, uint _closeFactorMantissa, uint _maxAssets, bool reinitializing) public {\n\n        require(msg.sender == unitroller.admin(), \"only unitroller admin can change brains\");\n\n        uint changeStatus = unitroller._acceptImplementation();\n\n\n\n        require(changeStatus == 0, \"change not authorized\");\n\n\n\n        if (!reinitializing) {\n\n            Comptroller freshBrainedComptroller = Comptroller(address(unitroller));\n\n\n\n            // Ensure invoke _setPriceOracle() = 0\n\n            uint err = freshBrainedComptroller._setPriceOracle(_oracle);\n\n            require (err == uint(Error.NO_ERROR), \"set price oracle error\");\n\n\n\n            // Ensure invoke _setCloseFactor() = 0\n\n            err = freshBrainedComptroller._setCloseFactor(_closeFactorMantissa);\n\n            require (err == uint(Error.NO_ERROR), \"set close factor error\");\n\n\n\n            // Ensure invoke _setMaxAssets() = 0\n\n            err = freshBrainedComptroller._setMaxAssets(_maxAssets);\n\n            require (err == uint(Error.NO_ERROR), \"set max asssets error\");\n\n\n\n            // Ensure invoke _setLiquidationIncentive(liquidationIncentiveMinMantissa) = 0\n\n            err = freshBrainedComptroller._setLiquidationIncentive(liquidationIncentiveMinMantissa);\n\n            require (err == uint(Error.NO_ERROR), \"set liquidation incentive error\");\n\n        }\n\n    }\n\n\n\n    /**\n",
          "message": "Function 'Comptroller._become' (Comptroller.sol#3468-3496) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 3468,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _become(Unitroller unitroller, PriceOracle _oracle, uint _closeFactorMantissa, uint _maxAssets, bool reinitializing) public {\n",
          "message": "Parameter '_oracle' of Comptroller._become (Comptroller.sol#3468) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 3468,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _become(Unitroller unitroller, PriceOracle _oracle, uint _closeFactorMantissa, uint _maxAssets, bool reinitializing) public {\n",
          "message": "Parameter '_closeFactorMantissa' of Comptroller._become (Comptroller.sol#3468) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 3468,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _become(Unitroller unitroller, PriceOracle _oracle, uint _closeFactorMantissa, uint _maxAssets, bool reinitializing) public {\n",
          "message": "Parameter '_maxAssets' of Comptroller._become (Comptroller.sol#3468) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 2599,
          "vulnerability_to_line": 2601,
          "vulnerability_code": "    bool public constant isComptroller = true;\n\n\n",
          "message": "Constant 'Comptroller.isComptroller' (Comptroller.sol#2599-2601) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 2602,
          "vulnerability_to_line": 2604,
          "vulnerability_code": "    uint constant closeFactorMinMantissa = 5e16; // 0.05\n\n\n",
          "message": "Constant 'Comptroller.closeFactorMinMantissa' (Comptroller.sol#2602-2604) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 2605,
          "vulnerability_to_line": 2607,
          "vulnerability_code": "    uint constant closeFactorMaxMantissa = 9e17; // 0.9\n\n\n",
          "message": "Constant 'Comptroller.closeFactorMaxMantissa' (Comptroller.sol#2605-2607) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 2608,
          "vulnerability_to_line": 2610,
          "vulnerability_code": "    uint constant collateralFactorMaxMantissa = 9e17; // 0.9\n\n\n",
          "message": "Constant 'Comptroller.collateralFactorMaxMantissa' (Comptroller.sol#2608-2610) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 2611,
          "vulnerability_to_line": 2613,
          "vulnerability_code": "    uint constant liquidationIncentiveMinMantissa = mantissaOne;\n\n\n",
          "message": "Constant 'Comptroller.liquidationIncentiveMinMantissa' (Comptroller.sol#2611-2613) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 2614,
          "vulnerability_to_line": 2616,
          "vulnerability_code": "    uint constant liquidationIncentiveMaxMantissa = 15e17; // 1.5\n\n\n",
          "message": "Constant 'Comptroller.liquidationIncentiveMaxMantissa' (Comptroller.sol#2614-2616) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "unused-state",
          "vulnerability_from_line": 166,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint constant mantissaOne = expScale;\n",
          "message": "Exponential.mantissaOne (Comptroller.sol#166) is never used in Comptroller\n"
        }
      ]
    },
    "smartcheck": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 2439,
          "vulnerability_to_line": null,
          "vulnerability_code": "        pendingComptrollerImplementation = address(0);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 2493,
          "vulnerability_to_line": null,
          "vulnerability_code": "        pendingAdmin = address(0);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ARRAY_LENGTH_MANIPULATION",
          "vulnerability_from_line": 2742,
          "vulnerability_to_line": null,
          "vulnerability_code": "        storedList.length--;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ERC20_APPROVE",
          "vulnerability_from_line": 1050,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function approve(address spender, uint256 amount) external returns (bool) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 3176,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < assets.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 2652,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < len; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 2729,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < len; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 3176,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < assets.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_LOCKED_MONEY",
          "vulnerability_from_line": 2379,
          "vulnerability_to_line": null,
          "vulnerability_code": "contract Unitroller is UnitrollerAdminStorage, ComptrollerErrorReporter {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.10;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 65,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.10;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 153,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.10;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 374,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.10;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 581,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.10;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 616,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.10;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 694,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.10;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 726,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.10;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 2293,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.10;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 2313,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.10;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 2370,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.10;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 2524,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.10;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 591,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint256 private _guardCounter;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_REVERT_REQUIRE",
          "vulnerability_from_line": 2838,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (redeemTokens == 0 && redeemAmount > 0) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 88,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function mulUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 105,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function divUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 116,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function subUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 127,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function addUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 140,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function addThenSubUInt(uint a, uint b, uint c) internal pure returns (MathError, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 177,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getExp(uint num, uint denom) pure internal returns (MathError, Exp memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 194,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function addExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 203,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function subExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 212,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function mulScalar(Exp memory a, uint scalar) pure internal returns (MathError, Exp memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 224,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function mulScalarTruncate(Exp memory a, uint scalar) pure internal returns (MathError, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 236,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function mulScalarTruncateAddUInt(Exp memory a, uint scalar, uint addend) pure internal returns (MathError, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 248,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function divScalar(Exp memory a, uint scalar) pure internal returns (MathError, Exp memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 260,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function divScalarByExp(uint scalar, Exp memory divisor) pure internal returns (MathError, Exp memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 280,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function divScalarByExpTruncate(uint scalar, Exp memory divisor) pure internal returns (MathError, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 292,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function mulExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 317,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function mulExp(uint a, uint b) pure internal returns (MathError, Exp memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 324,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function mulExp3(Exp memory a, Exp memory b, Exp memory c) pure internal returns (MathError, Exp memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 337,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function divExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 689,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint repayAmount) external view returns (uint, uint);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 714,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getBorrowRate(uint cash, uint borrows, uint reserves) external view returns (uint, uint);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 1095,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 1198,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 1255,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function exchangeRateStoredInternal() internal view returns (MathError, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 3136,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getAccountLiquidity(address account) public view returns (uint, uint, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 3148,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getAccountLiquidityInternal(address account) internal view returns (Error, uint, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 3168,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint borrowAmount) internal view returns (Error, uint, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 3246,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function liquidateCalculateSeizeTokens(address cTokenBorrowed, address cTokenCollateral, uint repayAmount) external view returns (uint, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_TX_ORIGIN",
          "vulnerability_from_line": 3506,
          "vulnerability_to_line": null,
          "vulnerability_code": "                tx.origin == admin\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UNCHECKED_CALL",
          "vulnerability_from_line": 2508,
          "vulnerability_to_line": null,
          "vulnerability_code": "        (bool success, ) = comptrollerImplementation.delegatecall(msg.data);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 2511,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1541,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 164,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint constant expScale = 1e18;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 165,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint constant halfExpScale = expScale/2;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 166,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint constant mantissaOne = expScale;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 757,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint constant borrowRateMaxMantissa = 5e14;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 762,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint constant reserveFactorMaxMantissa = 1e18;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 822,
          "vulnerability_to_line": null,
          "vulnerability_code": "    mapping (address => uint256) accountTokens;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 827,
          "vulnerability_to_line": null,
          "vulnerability_code": "    mapping (address => mapping (address => uint256)) transferAllowances;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 842,
          "vulnerability_to_line": null,
          "vulnerability_code": "    mapping(address => BorrowSnapshot) accountBorrows;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1541,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1541,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1541,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1541,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1542,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1544,
          "vulnerability_to_line": null,
          "vulnerability_code": "        RedeemLocalVars memory vars;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1547,
          "vulnerability_to_line": null,
          "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1547,
          "vulnerability_to_line": null,
          "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1547,
          "vulnerability_to_line": null,
          "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1547,
          "vulnerability_to_line": null,
          "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1548,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (vars.mathErr != MathError.NO_ERROR) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1548,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (vars.mathErr != MathError.NO_ERROR) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1549,
          "vulnerability_to_line": null,
          "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1549,
          "vulnerability_to_line": null,
          "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1549,
          "vulnerability_to_line": null,
          "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1549,
          "vulnerability_to_line": null,
          "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1549,
          "vulnerability_to_line": null,
          "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 2602,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint constant closeFactorMinMantissa = 5e16; // 0.05\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 2605,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint constant closeFactorMaxMantissa = 9e17; // 0.9\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 2608,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint constant collateralFactorMaxMantissa = 9e17; // 0.9\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 2611,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint constant liquidationIncentiveMinMantissa = mantissaOne;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 2614,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint constant liquidationIncentiveMaxMantissa = 15e17; // 1.5\n",
          "message": null
        }
      ]
    },
    "oyente": {
      "successfull_analysis": false,
      "errors": [
        "exception (RuntimeError: Source map error, unknown name(SHR) or instr_name(INVALID))"
      ],
      "vulnerability_findings": []
    },
    "mythril": {
      "successfull_analysis": false,
      "errors": [
        "DOCKER_TIMEOUT"
      ],
      "vulnerability_findings": []
    },
    "osiris": {
      "successfull_analysis": false,
      "errors": [
        "Solidity compilation failed"
      ],
      "vulnerability_findings": []
    }
  }
}