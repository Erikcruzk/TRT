{
  "smartbugs_completed": true,
  "analyzer_results": {
    "semgrep": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": []
    },
    "slither": {
      "successfull_analysis": true,
      "errors": [
        "EXIT_CODE_9"
      ],
      "vulnerability_findings": [
        {
          "name": "solc-version",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.10;\n",
          "message": "Detected issues with version pragma in _Exponential.sol:\n\t- pragma solidity^0.5.10 (_Exponential.sol#3): it allows old versions\n\t- pragma solidity^0.5.10 (_Exponential.sol#156): it allows old versions\n\t- pragma solidity^0.5.10 (_Exponential.sol#228): it allows old versions\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 5,
          "vulnerability_to_line": 152,
          "vulnerability_code": "contract _ErrorReporter {\n\n\n\n    /**\n\n      * @dev `error` corresponds to enum Error; `info` corresponds to enum FailureInfo, and `detail` is an arbitrary\n\n      * contract-specific code that enables us to report opaque error codes from upgradeable contracts.\n\n      **/\n\n    event Failure(uint error, uint info, uint detail);\n\n\n\n    enum Error {\n\n        NO_ERROR,\n\n        OPAQUE_ERROR, // To be used when reporting errors from upgradeable contracts; the opaque code should be given as `detail` in the `Failure` event\n\n        UNAUTHORIZED,\n\n        INTEGER_OVERFLOW,\n\n        INTEGER_UNDERFLOW,\n\n        DIVISION_BY_ZERO,\n\n        BAD_INPUT,\n\n        TOKEN_INSUFFICIENT_ALLOWANCE,\n\n        TOKEN_INSUFFICIENT_BALANCE,\n\n        TOKEN_TRANSFER_FAILED,\n\n        MARKET_NOT_SUPPORTED,\n\n        SUPPLY_RATE_CALCULATION_FAILED,\n\n        BORROW_RATE_CALCULATION_FAILED,\n\n        TOKEN_INSUFFICIENT_CASH,\n\n        TOKEN_TRANSFER_OUT_FAILED,\n\n        INSUFFICIENT_LIQUIDITY,\n\n        INSUFFICIENT_BALANCE,\n\n        INVALID_COLLATERAL_RATIO,\n\n        MISSING_ASSET_PRICE,\n\n        EQUITY_INSUFFICIENT_BALANCE,\n\n        INVALID_CLOSE_AMOUNT_REQUESTED,\n\n        ASSET_NOT_PRICED,\n\n        INVALID_LIQUIDATION_DISCOUNT,\n\n        INVALID_COMBINED_RISK_PARAMETERS\n\n    }\n\n\n\n    /*\n\n     * Note: FailureInfo (but not Error) is kept in alphabetical order\n\n     *       This is because FailureInfo grows significantly faster, and\n\n     *       the order of Error has some meaning, while the order of FailureInfo\n\n     *       is entirely arbitrary.\n\n     */\n\n    enum FailureInfo {\n\n        BORROW_ACCOUNT_LIQUIDITY_CALCULATION_FAILED,\n\n        BORROW_ACCOUNT_SHORTFALL_PRESENT,\n\n        BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\n\n        BORROW_AMOUNT_LIQUIDITY_SHORTFALL,\n\n        BORROW_AMOUNT_VALUE_CALCULATION_FAILED,\n\n        BORROW_MARKET_NOT_SUPPORTED,\n\n        BORROW_NEW_BORROW_INDEX_CALCULATION_FAILED,\n\n        BORROW_NEW_BORROW_RATE_CALCULATION_FAILED,\n\n        BORROW_NEW_SUPPLY_INDEX_CALCULATION_FAILED,\n\n        BORROW_NEW_SUPPLY_RATE_CALCULATION_FAILED,\n\n        BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\n\n        BORROW_NEW_TOTAL_BORROW_CALCULATION_FAILED,\n\n        BORROW_NEW_TOTAL_CASH_CALCULATION_FAILED,\n\n        BORROW_ORIGINATION_FEE_CALCULATION_FAILED,\n\n        BORROW_TRANSFER_OUT_FAILED,\n\n        EQUITY_WITHDRAWAL_AMOUNT_VALIDATION,\n\n        EQUITY_WITHDRAWAL_CALCULATE_EQUITY,\n\n        EQUITY_WITHDRAWAL_MODEL_OWNER_CHECK,\n\n        EQUITY_WITHDRAWAL_TRANSFER_OUT_FAILED,\n\n        LIQUIDATE_ACCUMULATED_BORROW_BALANCE_CALCULATION_FAILED,\n\n        LIQUIDATE_ACCUMULATED_SUPPLY_BALANCE_CALCULATION_FAILED_BORROWER_COLLATERAL_ASSET,\n\n        LIQUIDATE_ACCUMULATED_SUPPLY_BALANCE_CALCULATION_FAILED_LIQUIDATOR_COLLATERAL_ASSET,\n\n        LIQUIDATE_AMOUNT_SEIZE_CALCULATION_FAILED,\n\n        LIQUIDATE_BORROW_DENOMINATED_COLLATERAL_CALCULATION_FAILED,\n\n        LIQUIDATE_CLOSE_AMOUNT_TOO_HIGH,\n\n        LIQUIDATE_DISCOUNTED_REPAY_TO_EVEN_AMOUNT_CALCULATION_FAILED,\n\n        LIQUIDATE_NEW_BORROW_INDEX_CALCULATION_FAILED_BORROWED_ASSET,\n\n        LIQUIDATE_NEW_BORROW_INDEX_CALCULATION_FAILED_COLLATERAL_ASSET,\n\n        LIQUIDATE_NEW_BORROW_RATE_CALCULATION_FAILED_BORROWED_ASSET,\n\n        LIQUIDATE_NEW_SUPPLY_INDEX_CALCULATION_FAILED_BORROWED_ASSET,\n\n        LIQUIDATE_NEW_SUPPLY_INDEX_CALCULATION_FAILED_COLLATERAL_ASSET,\n\n        LIQUIDATE_NEW_SUPPLY_RATE_CALCULATION_FAILED_BORROWED_ASSET,\n\n        LIQUIDATE_NEW_TOTAL_BORROW_CALCULATION_FAILED_BORROWED_ASSET,\n\n        LIQUIDATE_NEW_TOTAL_CASH_CALCULATION_FAILED_BORROWED_ASSET,\n\n        LIQUIDATE_NEW_TOTAL_SUPPLY_BALANCE_CALCULATION_FAILED_BORROWER_COLLATERAL_ASSET,\n\n        LIQUIDATE_NEW_TOTAL_SUPPLY_BALANCE_CALCULATION_FAILED_LIQUIDATOR_COLLATERAL_ASSET,\n\n        LIQUIDATE_TRANSFER_IN_FAILED,\n\n        LIQUIDATE_TRANSFER_IN_NOT_POSSIBLE,\n\n        REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\n\n        REPAY_BORROW_NEW_BORROW_INDEX_CALCULATION_FAILED,\n\n        REPAY_BORROW_NEW_BORROW_RATE_CALCULATION_FAILED,\n\n        REPAY_BORROW_NEW_SUPPLY_INDEX_CALCULATION_FAILED,\n\n        REPAY_BORROW_NEW_SUPPLY_RATE_CALCULATION_FAILED,\n\n        REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\n\n        REPAY_BORROW_NEW_TOTAL_BORROW_CALCULATION_FAILED,\n\n        REPAY_BORROW_NEW_TOTAL_CASH_CALCULATION_FAILED,\n\n        REPAY_BORROW_TRANSFER_IN_FAILED,\n\n        REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE,\n\n        SET_ADMIN_OWNER_CHECK,\n\n        SET_ASSET_PRICE_CHECK_ORACLE,\n\n        SET_MARKET_INTEREST_RATE_MODEL_OWNER_CHECK,\n\n        SET_ORACLE_OWNER_CHECK,\n\n        SET_ORIGINATION_FEE_OWNER_CHECK,\n\n        SET_RISK_PARAMETERS_OWNER_CHECK,\n\n        SET_RISK_PARAMETERS_VALIDATION,\n\n        SUPPLY_ACCUMULATED_BALANCE_CALCULATION_FAILED,\n\n        SUPPLY_MARKET_NOT_SUPPORTED,\n\n        SUPPLY_NEW_BORROW_INDEX_CALCULATION_FAILED,\n\n        SUPPLY_NEW_BORROW_RATE_CALCULATION_FAILED,\n\n        SUPPLY_NEW_SUPPLY_INDEX_CALCULATION_FAILED,\n\n        SUPPLY_NEW_SUPPLY_RATE_CALCULATION_FAILED,\n\n        SUPPLY_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\n\n        SUPPLY_NEW_TOTAL_CASH_CALCULATION_FAILED,\n\n        SUPPLY_NEW_TOTAL_SUPPLY_CALCULATION_FAILED,\n\n        SUPPLY_TRANSFER_IN_FAILED,\n\n        SUPPLY_TRANSFER_IN_NOT_POSSIBLE,\n\n        SUPPORT_MARKET_OWNER_CHECK,\n\n        SUPPORT_MARKET_PRICE_CHECK,\n\n        SUSPEND_MARKET_OWNER_CHECK,\n\n        WITHDRAW_ACCOUNT_LIQUIDITY_CALCULATION_FAILED,\n\n        WITHDRAW_ACCOUNT_SHORTFALL_PRESENT,\n\n        WITHDRAW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\n\n        WITHDRAW_AMOUNT_LIQUIDITY_SHORTFALL,\n\n        WITHDRAW_AMOUNT_VALUE_CALCULATION_FAILED,\n\n        WITHDRAW_CAPACITY_CALCULATION_FAILED,\n\n        WITHDRAW_NEW_BORROW_INDEX_CALCULATION_FAILED,\n\n        WITHDRAW_NEW_BORROW_RATE_CALCULATION_FAILED,\n\n        WITHDRAW_NEW_SUPPLY_INDEX_CALCULATION_FAILED,\n\n        WITHDRAW_NEW_SUPPLY_RATE_CALCULATION_FAILED,\n\n        WITHDRAW_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\n\n        WITHDRAW_NEW_TOTAL_SUPPLY_CALCULATION_FAILED,\n\n        WITHDRAW_TRANSFER_OUT_FAILED,\n\n        WITHDRAW_TRANSFER_OUT_NOT_POSSIBLE\n\n    }\n\n\n\n\n\n    /**\n\n      * @dev use this when reporting a known error from the money market or a non-upgradeable collaborator\n\n      */\n\n    function fail(Error err, FailureInfo info) internal returns (uint) {\n\n        emit Failure(uint(err), uint(info), 0);\n\n\n\n        return uint(err);\n\n    }\n\n\n\n\n\n    /**\n\n      * @dev use this when reporting an opaque error from an upgradeable collaborator contract\n\n      */\n\n    function failOpaque(FailureInfo info, uint opaqueError) internal returns (uint) {\n\n        emit Failure(uint(Error.OPAQUE_ERROR), uint(info), opaqueError);\n\n\n\n        return uint(Error.OPAQUE_ERROR);\n\n    }\n\n\n",
          "message": "Contract '_ErrorReporter' (_Exponential.sol#5-152) is not in CapWords\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 158,
          "vulnerability_to_line": 224,
          "vulnerability_code": "contract _CarefulMath is _ErrorReporter {\n\n\n\n    /**\n\n    * @dev Multiplies two numbers, returns an error on overflow.\n\n    */\n\n    function mul(uint a, uint b) internal pure returns (Error, uint) {\n\n        if (a == 0) {\n\n            return (Error.NO_ERROR, 0);\n\n        }\n\n\n\n        uint c = a * b;\n\n\n\n        if (c / a != b) {\n\n            return (Error.INTEGER_OVERFLOW, 0);\n\n        } else {\n\n            return (Error.NO_ERROR, c);\n\n        }\n\n    }\n\n\n\n    /**\n\n    * @dev Integer division of two numbers, truncating the quotient.\n\n    */\n\n    function div(uint a, uint b) internal pure returns (Error, uint) {\n\n        if (b == 0) {\n\n            return (Error.DIVISION_BY_ZERO, 0);\n\n        }\n\n\n\n        return (Error.NO_ERROR, a / b);\n\n    }\n\n\n\n    /**\n\n    * @dev Subtracts two numbers, returns an error on overflow (i.e. if subtrahend is greater than minuend).\n\n    */\n\n    function sub(uint a, uint b) internal pure returns (Error, uint) {\n\n        if (b <= a) {\n\n            return (Error.NO_ERROR, a - b);\n\n        } else {\n\n            return (Error.INTEGER_UNDERFLOW, 0);\n\n        }\n\n    }\n\n\n\n    /**\n\n    * @dev Adds two numbers, returns an error on overflow.\n\n    */\n\n    function add(uint a, uint b) internal pure returns (Error, uint) {\n\n        uint c = a + b;\n\n\n\n        if (c >= a) {\n\n            return (Error.NO_ERROR, c);\n\n        } else {\n\n            return (Error.INTEGER_OVERFLOW, 0);\n\n        }\n\n    }\n\n\n\n    /**\n\n    * @dev add a and b and then subtract c\n\n    */\n\n    function addThenSub(uint a, uint b, uint c) internal pure returns (Error, uint) {\n\n        (Error err0, uint sum) = add(a, b);\n\n\n\n        if (err0 != Error.NO_ERROR) {\n\n            return (err0, 0);\n\n        }\n\n\n\n        return sub(sum, c);\n\n    }\n",
          "message": "Contract '_CarefulMath' (_Exponential.sol#158-224) is not in CapWords\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 230,
          "vulnerability_to_line": 398,
          "vulnerability_code": "contract _Exponential is _ErrorReporter, _CarefulMath {\n\n\n\n    // TODO: We may wish to put the result of 10**18 here instead of the expression.\n\n    // Per https://solidity.readthedocs.io/en/latest/contracts.html#constant-state-variables\n\n    // the optimizer MAY replace the expression 10**18 with its calculated value.\n\n    uint constant expScale = 10**18;\n\n\n\n    // See TODO on expScale\n\n    uint constant halfExpScale = expScale/2;\n\n\n\n    struct Exp {\n\n        uint mantissa;\n\n    }\n\n\n\n    uint constant mantissaOne = 10**18;\n\n    uint constant mantissaOneTenth = 10**17;\n\n\n\n    /**\n\n    * @dev Creates an exponential from numerator and denominator values.\n\n    *      Note: Returns an error if (`num` * 10e18) > MAX_INT,\n\n    *            or if `denom` is zero.\n\n    */\n\n    function getExp(uint num, uint denom) pure internal returns (Error, Exp memory) {\n\n        (Error err0, uint scaledNumerator) = mul(num, expScale);\n\n        if (err0 != Error.NO_ERROR) {\n\n            return (err0, Exp({mantissa: 0}));\n\n        }\n\n\n\n        (Error err1, uint rational) = div(scaledNumerator, denom);\n\n        if (err1 != Error.NO_ERROR) {\n\n            return (err1, Exp({mantissa: 0}));\n\n        }\n\n\n\n        return (Error.NO_ERROR, Exp({mantissa: rational}));\n\n    }\n\n\n\n    /**\n\n    * @dev Adds two exponentials, returning a new exponential.\n\n    */\n\n    function addExp(Exp memory a, Exp memory b) pure internal returns (Error, Exp memory) {\n\n        (Error error, uint result) = add(a.mantissa, b.mantissa);\n\n\n\n        return (error, Exp({mantissa: result}));\n\n    }\n\n\n\n    /**\n\n    * @dev Subtracts two exponentials, returning a new exponential.\n\n    */\n\n    function subExp(Exp memory a, Exp memory b) pure internal returns (Error, Exp memory) {\n\n        (Error error, uint result) = sub(a.mantissa, b.mantissa);\n\n\n\n        return (error, Exp({mantissa: result}));\n\n    }\n\n\n\n    /**\n\n    * @dev Multiply an Exp by a scalar, returning a new Exp.\n\n    */\n\n    function mulScalar(Exp memory a, uint scalar) pure internal returns (Error, Exp memory) {\n\n        (Error err0, uint scaledMantissa) = mul(a.mantissa, scalar);\n\n        if (err0 != Error.NO_ERROR) {\n\n            return (err0, Exp({mantissa: 0}));\n\n        }\n\n\n\n        return (Error.NO_ERROR, Exp({mantissa: scaledMantissa}));\n\n    }\n\n\n\n    /**\n\n    * @dev Divide an Exp by a scalar, returning a new Exp.\n\n    */\n\n    function divScalar(Exp memory a, uint scalar) pure internal returns (Error, Exp memory) {\n\n        (Error err0, uint descaledMantissa) = div(a.mantissa, scalar);\n\n        if (err0 != Error.NO_ERROR) {\n\n            return (err0, Exp({mantissa: 0}));\n\n        }\n\n\n\n        return (Error.NO_ERROR, Exp({mantissa: descaledMantissa}));\n\n    }\n\n\n\n    /**\n\n    * @dev Divide a scalar by an Exp, returning a new Exp.\n\n    */\n\n    function divScalarByExp(uint scalar, Exp memory divisor) pure internal returns (Error, Exp memory) {\n\n        /*\n\n            We are doing this as:\n\n            getExp(mul(expScale, scalar), divisor.mantissa)\n\n\n\n            How it works:\n\n            Exp = a / b;\n\n            Scalar = s;\n\n            `s / (a / b)` = `b * s / a` and since for an Exp `a = mantissa, b = expScale`\n\n        */\n\n        (Error err0, uint numerator) = mul(expScale, scalar);\n\n        if (err0 != Error.NO_ERROR) {\n\n            return (err0, Exp({mantissa: 0}));\n\n        }\n\n        return getExp(numerator, divisor.mantissa);\n\n    }\n\n\n\n    /**\n\n    * @dev Multiplies two exponentials, returning a new exponential.\n\n    */\n\n    function mulExp(Exp memory a, Exp memory b) pure internal returns (Error, Exp memory) {\n\n\n\n        (Error err0, uint doubleScaledProduct) = mul(a.mantissa, b.mantissa);\n\n        if (err0 != Error.NO_ERROR) {\n\n            return (err0, Exp({mantissa: 0}));\n\n        }\n\n\n\n        // We add half the scale before dividing so that we get rounding instead of truncation.\n\n        //  See \"Listing 6\" and text above it at https://accu.org/index.php/journals/1717\n\n        // Without this change, a result like 6.6...e-19 will be truncated to 0 instead of being rounded to 1e-18.\n\n        (Error err1, uint doubleScaledProductWithHalfScale) = add(halfExpScale, doubleScaledProduct);\n\n        if (err1 != Error.NO_ERROR) {\n\n            return (err1, Exp({mantissa: 0}));\n\n        }\n\n\n\n        (Error err2, uint product) = div(doubleScaledProductWithHalfScale, expScale);\n\n        // The only error `div` can return is Error.DIVISION_BY_ZERO but we control `expScale` and it is not zero.\n\n        assert(err2 == Error.NO_ERROR);\n\n\n\n        return (Error.NO_ERROR, Exp({mantissa: product}));\n\n    }\n\n\n\n    /**\n\n      * @dev Divides two exponentials, returning a new exponential.\n\n      *     (a/scale) / (b/scale) = (a/scale) * (scale/b) = a/b,\n\n      *  which we can scale as an Exp by calling getExp(a.mantissa, b.mantissa)\n\n      */\n\n    function divExp(Exp memory a, Exp memory b) pure internal returns (Error, Exp memory) {\n\n        return getExp(a.mantissa, b.mantissa);\n\n    }\n\n\n\n    /**\n\n      * @dev Truncates the given exp to a whole number value.\n\n      *      For example, truncate(Exp{mantissa: 15 * (10**18)}) = 15\n\n      */\n\n    function truncate(Exp memory exp) pure internal returns (uint) {\n\n        // Note: We are not using careful math here as we're performing a division that cannot fail\n\n        return exp.mantissa / 10**18;\n\n    }\n\n\n\n    /**\n\n      * @dev Checks if first Exp is less than second Exp.\n\n      */\n\n    function lessThanExp(Exp memory left, Exp memory right) pure internal returns (bool) {\n\n        return left.mantissa < right.mantissa; //TODO: Add some simple tests and this in another PR yo.\n\n    }\n\n\n\n    /**\n\n      * @dev Checks if left Exp <= right Exp.\n\n      */\n\n    function lessThanOrEqualExp(Exp memory left, Exp memory right) pure internal returns (bool) {\n\n        return left.mantissa <= right.mantissa;\n\n    }\n\n\n\n    /**\n\n      * @dev Checks if first Exp is greater than second Exp.\n\n      */\n\n    function greaterThanExp(Exp memory left, Exp memory right) pure internal returns (bool) {\n\n        return left.mantissa > right.mantissa;\n\n    }\n\n\n\n    /**\n\n      * @dev returns true if Exp is exactly zero\n\n      */\n\n    function isZeroExp(Exp memory value) pure internal returns (bool) {\n\n        return value.mantissa == 0;\n\n    }\n",
          "message": "Contract '_Exponential' (_Exponential.sol#230-398) is not in CapWords\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 235,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint constant expScale = 10**18;\n",
          "message": "Constant '_Exponential.expScale' (_Exponential.sol#235) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 238,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint constant halfExpScale = expScale/2;\n",
          "message": "Constant '_Exponential.halfExpScale' (_Exponential.sol#238) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 244,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint constant mantissaOne = 10**18;\n",
          "message": "Constant '_Exponential.mantissaOne' (_Exponential.sol#244) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 245,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint constant mantissaOneTenth = 10**17;\n",
          "message": "Constant '_Exponential.mantissaOneTenth' (_Exponential.sol#245) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "unused-state",
          "vulnerability_from_line": 244,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint constant mantissaOne = 10**18;\n",
          "message": "_Exponential.mantissaOne (_Exponential.sol#244) is never used in _Exponential\n_Exponential.mantissaOneTenth (_Exponential.sol#245) is never used in _Exponential\n"
        }
      ]
    },
    "smartcheck": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.10;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 156,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.10;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 228,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.10;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 163,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function mul(uint a, uint b) internal pure returns (Error, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 180,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function div(uint a, uint b) internal pure returns (Error, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 191,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function sub(uint a, uint b) internal pure returns (Error, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 202,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function add(uint a, uint b) internal pure returns (Error, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 215,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function addThenSub(uint a, uint b, uint c) internal pure returns (Error, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 252,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getExp(uint num, uint denom) pure internal returns (Error, Exp memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 269,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function addExp(Exp memory a, Exp memory b) pure internal returns (Error, Exp memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 278,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function subExp(Exp memory a, Exp memory b) pure internal returns (Error, Exp memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 287,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function mulScalar(Exp memory a, uint scalar) pure internal returns (Error, Exp memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 299,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function divScalar(Exp memory a, uint scalar) pure internal returns (Error, Exp memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 311,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function divScalarByExp(uint scalar, Exp memory divisor) pure internal returns (Error, Exp memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 331,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function mulExp(Exp memory a, Exp memory b) pure internal returns (Error, Exp memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 358,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function divExp(Exp memory a, Exp memory b) pure internal returns (Error, Exp memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 235,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint constant expScale = 10**18;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 238,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint constant halfExpScale = expScale/2;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 244,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint constant mantissaOne = 10**18;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 245,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint constant mantissaOneTenth = 10**17;\n",
          "message": null
        }
      ]
    },
    "oyente": {
      "successfull_analysis": false,
      "errors": [
        "exception (IndexError: pop from empty list)"
      ],
      "vulnerability_findings": []
    },
    "mythril": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": []
    },
    "osiris": {
      "successfull_analysis": false,
      "errors": [
        "Solidity compilation failed"
      ],
      "vulnerability_findings": []
    }
  }
}