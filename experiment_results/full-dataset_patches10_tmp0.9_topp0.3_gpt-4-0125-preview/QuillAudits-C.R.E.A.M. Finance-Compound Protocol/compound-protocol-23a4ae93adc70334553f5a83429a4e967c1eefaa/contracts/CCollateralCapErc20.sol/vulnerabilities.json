{
  "smartbugs_completed": true,
  "analyzer_results": {
    "semgrep": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1366,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == admin, \"only admin may initialize the market\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1367,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(accrualBlockNumber == 0 && borrowIndex == 0, \"market may only be initialized once\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1371,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(initialExchangeRateMantissa > 0, \"initial exchange rate must be greater than zero.\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1375,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(err == uint(Error.NO_ERROR), \"setting comptroller failed\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1383,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(err == uint(Error.NO_ERROR), \"setting interest rate model failed\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1539,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1549,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1591,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1660,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 2017,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(amountSeizeError == uint(Error.NO_ERROR), \"LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 2020,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(cTokenCollateral.balanceOf(borrower) >= seizeTokens, \"LIQUIDATE_SEIZE_TOO_MUCH\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 2031,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(seizeError == uint(Error.NO_ERROR), \"token seizure failed\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 2122,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(newComptroller.isComptroller(), \"marker method returned false\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 2340,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 2409,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_notEntered, \"re-entered\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 2722,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == admin, \"only admin can set collateral cap\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 2749,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(cashBefore >= amount, \"INSUFFICIENT_LIQUIDITY\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 2762,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(cashOnChainAfter == add_(cashOnChainBefore, totalFee), \"BALANCE_INCONSISTENT\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 2782,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == address(comptroller), \"only comptroller may register collateral for user\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 2797,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == address(comptroller), \"only comptroller may unregister collateral for user\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 2876,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(success, \"TOKEN_TRANSFER_IN_FAILED\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 2912,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(success, \"TOKEN_TRANSFER_OUT_FAILED\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 3042,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(comptroller.redeemAllowed(address(this), account, amount) == 0, \"comptroller rejection\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 3146,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 1367,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(accrualBlockNumber == 0 && borrowIndex == 0, \"market may only be initialized once\");\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 3014,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (collateralCap == 0 || (collateralCap != 0 && totalCollateralTokensNew <= collateralCap)) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 3015,
          "vulnerability_to_line": null,
          "vulnerability_code": "            // 1. If collateral cap is not set,\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 3016,
          "vulnerability_to_line": null,
          "vulnerability_code": "            // 2. If collateral cap is set but has enough space for this user,\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 3017,
          "vulnerability_to_line": null,
          "vulnerability_code": "            // give all the user needs.\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 3018,
          "vulnerability_to_line": null,
          "vulnerability_code": "            totalCollateralTokens = totalCollateralTokensNew;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 3019,
          "vulnerability_to_line": null,
          "vulnerability_code": "            accountCollateralTokens[account] = add_(accountCollateralTokens[account], amount);\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 3020,
          "vulnerability_to_line": null,
          "vulnerability_code": "\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 3021,
          "vulnerability_to_line": null,
          "vulnerability_code": "            emit UserCollateralChanged(account, accountCollateralTokens[account]);\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 3022,
          "vulnerability_to_line": null,
          "vulnerability_code": "            return amount;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 3023,
          "vulnerability_to_line": null,
          "vulnerability_code": "        } else if (collateralCap > totalCollateralTokens) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 1366,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == admin, \"only admin may initialize the market\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 1367,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(accrualBlockNumber == 0 && borrowIndex == 0, \"market may only be initialized once\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 1371,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(initialExchangeRateMantissa > 0, \"initial exchange rate must be greater than zero.\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 1383,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(err == uint(Error.NO_ERROR), \"setting interest rate model failed\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 2017,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(amountSeizeError == uint(Error.NO_ERROR), \"LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 2722,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == admin, \"only admin can set collateral cap\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 2782,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == address(comptroller), \"only comptroller may register collateral for user\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 2797,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == address(comptroller), \"only comptroller may unregister collateral for user\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 3146,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "compound-borrowfresh-reentrancy",
          "vulnerability_from_line": 1809,
          "vulnerability_to_line": null,
          "vulnerability_code": "        doTransferOut(borrower, borrowAmount);\n",
          "message": "Function borrowFresh() in Compound performs state update after doTransferOut()"
        }
      ]
    },
    "slither": {
      "successfull_analysis": true,
      "errors": [
        "EXIT_CODE_96"
      ],
      "vulnerability_findings": [
        {
          "name": "erc20-interface",
          "vulnerability_from_line": 1271,
          "vulnerability_to_line": 1333,
          "vulnerability_code": "interface EIP20NonStandardInterface {\n\n\n\n    /**\n\n     * @notice Get the total number of tokens in circulation\n\n     * @return The supply of tokens\n\n     */\n\n    function totalSupply() external view returns (uint256);\n\n\n\n    /**\n\n     * @notice Gets the balance of the specified address\n\n     * @param owner The address from which the balance will be retrieved\n\n     * @return The balance\n\n     */\n\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n\n\n    ///\n\n    /// !!!!!!!!!!!!!!\n\n    /// !!! NOTICE !!! `transfer` does not return a value, in violation of the ERC-20 specification\n\n    /// !!!!!!!!!!!!!!\n\n    ///\n\n\n\n    /**\n\n      * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n\n      * @param dst The address of the destination account\n\n      * @param amount The number of tokens to transfer\n\n      */\n\n    function transfer(address dst, uint256 amount) external;\n\n\n\n    ///\n\n    /// !!!!!!!!!!!!!!\n\n    /// !!! NOTICE !!! `transferFrom` does not return a value, in violation of the ERC-20 specification\n\n    /// !!!!!!!!!!!!!!\n\n    ///\n\n\n\n    /**\n\n      * @notice Transfer `amount` tokens from `src` to `dst`\n\n      * @param src The address of the source account\n\n      * @param dst The address of the destination account\n\n      * @param amount The number of tokens to transfer\n\n      */\n\n    function transferFrom(address src, address dst, uint256 amount) external;\n\n\n\n    /**\n\n      * @notice Approve `spender` to transfer up to `amount` from `src`\n\n      * @dev This will overwrite the approval amount for `spender`\n\n      *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n\n      * @param spender The address of the account which may transfer tokens\n\n      * @param amount The number of tokens that are approved\n\n      * @return Whether or not the approval succeeded\n\n      */\n\n    function approve(address spender, uint256 amount) external returns (bool success);\n\n\n\n    /**\n\n      * @notice Get the current allowance from `owner` for `spender`\n\n      * @param owner The address of the account which owns the tokens to be spent\n\n      * @param spender The address of the account which may transfer tokens\n\n      * @return The number of tokens allowed to be spent\n\n      */\n\n    function allowance(address owner, address spender) external view returns (uint256 remaining);\n\n\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n",
          "message": "EIP20NonStandardInterface (CCollateralCapErc20.sol#1271-1333) has incorrect ERC20 function interface(s):\n\t-transfer (CCollateralCapErc20.sol#1297)\n\t-transferFrom (CCollateralCapErc20.sol#1311)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 2182,
          "vulnerability_to_line": 2194,
          "vulnerability_code": "    function _addReservesInternal(uint addAmount) internal nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n\n            return fail(Error(error), FailureInfo.ADD_RESERVES_ACCRUE_INTEREST_FAILED);\n\n        }\n\n\n\n        // _addReservesFresh emits reserve-addition-specific logs on errors, so we don't need to.\n\n        (error, ) = _addReservesFresh(addAmount);\n\n        return error;\n\n    }\n\n\n",
          "message": "Reentrancy in CToken._addReservesInternal (CCollateralCapErc20.sol#2182-2194):\n\tExternal calls:\n\t- error = accrueInterest() (CCollateralCapErc20.sol#2183-2184)\n\tState variables written after the call(s):\n\t- totalReserves (CCollateralCapErc20.sol#2190-2191)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 2242,
          "vulnerability_to_line": 2252,
          "vulnerability_code": "    function _reduceReserves(uint reduceAmount) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n\n            return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.\n\n        return _reduceReservesFresh(reduceAmount);\n\n    }\n\n\n",
          "message": "Reentrancy in CToken._reduceReserves (CCollateralCapErc20.sol#2242-2252):\n\tExternal calls:\n\t- error = accrueInterest() (CCollateralCapErc20.sol#2243-2244)\n\tState variables written after the call(s):\n\t- totalReserves (CCollateralCapErc20.sol#2249-2250)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 2114,
          "vulnerability_to_line": 2133,
          "vulnerability_code": "    function _setComptroller(ComptrollerInterface newComptroller) public returns (uint) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COMPTROLLER_OWNER_CHECK);\n\n        }\n\n\n\n        ComptrollerInterface oldComptroller = comptroller;\n\n        // Ensure invoke comptroller.isComptroller() returns true\n\n        require(newComptroller.isComptroller(), \"marker method returned false\");\n\n\n\n        // Set market's comptroller to newComptroller\n\n        comptroller = newComptroller;\n\n\n\n        // Emit NewComptroller(oldComptroller, newComptroller)\n\n        emit NewComptroller(oldComptroller, newComptroller);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Reentrancy in CToken._setComptroller (CCollateralCapErc20.sol#2114-2133):\n\tExternal calls:\n\t- require(bool,string)(newComptroller.isComptroller(),marker method returned false) (CCollateralCapErc20.sol#2122-2123)\n\tState variables written after the call(s):\n\t- comptroller (CCollateralCapErc20.sol#2125-2126)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 2305,
          "vulnerability_to_line": 2315,
          "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n\n        return _setInterestRateModelFresh(newInterestRateModel);\n\n    }\n\n\n",
          "message": "Reentrancy in CToken._setInterestRateModel (CCollateralCapErc20.sol#2305-2315):\n\tExternal calls:\n\t- error = accrueInterest() (CCollateralCapErc20.sol#2306-2307)\n\t- _setInterestRateModelFresh(newInterestRateModel) (CCollateralCapErc20.sol#2312-2313)\n\tState variables written after the call(s):\n\t- interestRateModel (CCollateralCapErc20.sol#2312-2313)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 2321,
          "vulnerability_to_line": 2351,
          "vulnerability_code": "    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {\n\n\n\n        // Used to store old model for use in the event that is emitted on success\n\n        InterestRateModel oldInterestRateModel;\n\n\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);\n\n        }\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);\n\n        }\n\n\n\n        // Track the market's current interest rate model\n\n        oldInterestRateModel = interestRateModel;\n\n\n\n        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true\n\n        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n\n\n\n        // Set the interest rate model to newInterestRateModel\n\n        interestRateModel = newInterestRateModel;\n\n\n\n        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)\n\n        emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Reentrancy in CToken._setInterestRateModelFresh (CCollateralCapErc20.sol#2321-2351):\n\tExternal calls:\n\t- require(bool,string)(newInterestRateModel.isInterestRateModel(),marker method returned false) (CCollateralCapErc20.sol#2340-2342)\n\tState variables written after the call(s):\n\t- interestRateModel (CCollateralCapErc20.sol#2343-2345)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 2138,
          "vulnerability_to_line": 2148,
          "vulnerability_code": "    function _setReserveFactor(uint newReserveFactorMantissa) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.\n\n            return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.\n\n        return _setReserveFactorFresh(newReserveFactorMantissa);\n\n    }\n\n\n",
          "message": "Reentrancy in CToken._setReserveFactor (CCollateralCapErc20.sol#2138-2148):\n\tExternal calls:\n\t- error = accrueInterest() (CCollateralCapErc20.sol#2139-2140)\n\tState variables written after the call(s):\n\t- reserveFactorMantissa (CCollateralCapErc20.sol#2145-2146)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 1642,
          "vulnerability_to_line": 1694,
          "vulnerability_code": "    function accrueInterest() public returns (uint) {\n\n        /* Remember the initial block number */\n\n        uint currentBlockNumber = getBlockNumber();\n\n        uint accrualBlockNumberPrior = accrualBlockNumber;\n\n\n\n        /* Short-circuit accumulating 0 interest */\n\n        if (accrualBlockNumberPrior == currentBlockNumber) {\n\n            return uint(Error.NO_ERROR);\n\n        }\n\n\n\n        /* Read the previous values out of storage */\n\n        uint cashPrior = getCashPrior();\n\n        uint borrowsPrior = totalBorrows;\n\n        uint reservesPrior = totalReserves;\n\n        uint borrowIndexPrior = borrowIndex;\n\n\n\n        /* Calculate the current borrow interest rate */\n\n        uint borrowRateMantissa = interestRateModel.getBorrowRate(cashPrior, borrowsPrior, reservesPrior);\n\n        require(borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n\n\n\n        /* Calculate the number of blocks elapsed since the last accrual */\n\n        uint blockDelta = sub_(currentBlockNumber, accrualBlockNumberPrior);\n\n\n\n        /*\n\n         * Calculate the interest accumulated into borrows and reserves and the new index:\n\n         *  simpleInterestFactor = borrowRate * blockDelta\n\n         *  interestAccumulated = simpleInterestFactor * totalBorrows\n\n         *  totalBorrowsNew = interestAccumulated + totalBorrows\n\n         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves\n\n         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\n\n         */\n\n\n\n        Exp memory simpleInterestFactor = mul_(Exp({mantissa: borrowRateMantissa}), blockDelta);\n\n        uint interestAccumulated = mul_ScalarTruncate(simpleInterestFactor, borrowsPrior);\n\n        uint totalBorrowsNew = add_(interestAccumulated, borrowsPrior);\n\n        uint totalReservesNew = mul_ScalarTruncateAddUInt(Exp({mantissa: reserveFactorMantissa}), interestAccumulated, reservesPrior);\n\n        uint borrowIndexNew = mul_ScalarTruncateAddUInt(simpleInterestFactor, borrowIndexPrior, borrowIndexPrior);\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accrualBlockNumber = currentBlockNumber;\n\n        borrowIndex = borrowIndexNew;\n\n        totalBorrows = totalBorrowsNew;\n\n        totalReserves = totalReservesNew;\n\n\n\n        /* We emit an AccrueInterest event */\n\n        emit AccrueInterest(cashPrior, interestAccumulated, borrowIndexNew, totalBorrowsNew);\n\n\n\n        return uint(Error.NO_ERROR);\n",
          "message": "Reentrancy in CToken.accrueInterest (CCollateralCapErc20.sol#1642-1694):\n\tExternal calls:\n\t- borrowRateMantissa = interestRateModel.getBorrowRate(cashPrior,borrowsPrior,reservesPrior) (CCollateralCapErc20.sol#1659)\n\tState variables written after the call(s):\n\t- accrualBlockNumber (CCollateralCapErc20.sol#1685)\n\t- borrowIndex (CCollateralCapErc20.sol#1686)\n\t- totalBorrows (CCollateralCapErc20.sol#1687)\n\t- totalReserves (CCollateralCapErc20.sol#1688)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 1749,
          "vulnerability_to_line": 1757,
          "vulnerability_code": "    function borrowInternal(uint borrowAmount) internal nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n\n            return fail(Error(error), FailureInfo.BORROW_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // borrowFresh emits borrow-specific logs on errors, so we don't need to\n\n        return borrowFresh(msg.sender, borrowAmount);\n",
          "message": "Reentrancy in CToken.borrowInternal (CCollateralCapErc20.sol#1749-1757):\n\tExternal calls:\n\t- error = accrueInterest() (CCollateralCapErc20.sol#1750)\n\t- borrowFresh(msg.sender,borrowAmount) (CCollateralCapErc20.sol#1756)\n\tState variables written after the call(s):\n\t- totalBorrows (CCollateralCapErc20.sol#1756)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 2746,
          "vulnerability_to_line": 2772,
          "vulnerability_code": "    function flashLoan(address receiver, uint amount, bytes calldata params) external nonReentrant {\n\n        uint cashOnChainBefore = getCashOnChain();\n\n        uint cashBefore = getCashPrior();\n\n        require(cashBefore >= amount, \"INSUFFICIENT_LIQUIDITY\");\n\n\n\n        // 1. calculate fee, 1 bips = 1/10000\n\n        uint totalFee = div_(mul_(amount, flashFeeBips), 10000);\n\n\n\n        // 2. transfer fund to receiver\n\n        doTransferOut(address(uint160(receiver)), amount);\n\n\n\n        // 3. execute receiver's callback function\n\n        IFlashloanReceiver(receiver).executeOperation(msg.sender, underlying, amount, totalFee, params);\n\n\n\n        // 4. check balance\n\n        uint cashOnChainAfter = getCashOnChain();\n\n        require(cashOnChainAfter == add_(cashOnChainBefore, totalFee), \"BALANCE_INCONSISTENT\");\n\n\n\n        // 5. update reserves and internal cash\n\n        uint reservesFee = mul_ScalarTruncate(Exp({mantissa: reserveFactorMantissa}), totalFee);\n\n        totalReserves = add_(totalReserves, reservesFee);\n\n        internalCash = add_(cashBefore, totalFee);\n\n\n\n        emit Flashloan(receiver, amount, totalFee, reservesFee);\n\n    }\n\n\n",
          "message": "Reentrancy in CCollateralCapErc20.flashLoan (CCollateralCapErc20.sol#2746-2772):\n\tExternal calls:\n\t- cashOnChainBefore = getCashOnChain() (CCollateralCapErc20.sol#2747-2748)\n\t- doTransferOut(address(uint160(receiver)),amount) (CCollateralCapErc20.sol#2755-2757)\n\t- IFlashloanReceiver(receiver).executeOperation(msg.sender,underlying,amount,totalFee,params) (CCollateralCapErc20.sol#2758-2760)\n\t- cashOnChainAfter = getCashOnChain() (CCollateralCapErc20.sol#2761-2762)\n\tState variables written after the call(s):\n\t- internalCash (CCollateralCapErc20.sol#2767-2769)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 1360,
          "vulnerability_to_line": 1391,
          "vulnerability_code": "    function initialize(ComptrollerInterface comptroller_,\n\n                        InterestRateModel interestRateModel_,\n\n                        uint initialExchangeRateMantissa_,\n\n                        string memory name_,\n\n                        string memory symbol_,\n\n                        uint8 decimals_) public {\n\n        require(msg.sender == admin, \"only admin may initialize the market\");\n\n        require(accrualBlockNumber == 0 && borrowIndex == 0, \"market may only be initialized once\");\n\n\n\n        // Set initial exchange rate\n\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n\n        require(initialExchangeRateMantissa > 0, \"initial exchange rate must be greater than zero.\");\n\n\n\n        // Set the comptroller\n\n        uint err = _setComptroller(comptroller_);\n\n        require(err == uint(Error.NO_ERROR), \"setting comptroller failed\");\n\n\n\n        // Initialize block number and borrow index (block number mocks depend on comptroller being set)\n\n        accrualBlockNumber = getBlockNumber();\n\n        borrowIndex = mantissaOne;\n\n\n\n        // Set the interest rate model (depends on block number / borrow index)\n\n        err = _setInterestRateModelFresh(interestRateModel_);\n\n        require(err == uint(Error.NO_ERROR), \"setting interest rate model failed\");\n\n\n\n        name = name_;\n\n        symbol = symbol_;\n\n        decimals = decimals_;\n\n\n\n        // The counter starts true to prevent changing it from zero to non-zero (i.e. smaller cost/refund)\n\n        _notEntered = true;\n",
          "message": "Reentrancy in CToken.initialize (CCollateralCapErc20.sol#1360-1391):\n\tExternal calls:\n\t- err = _setComptroller(comptroller_) (CCollateralCapErc20.sol#1374)\n\tState variables written after the call(s):\n\t- accrualBlockNumber (CCollateralCapErc20.sol#1378)\n\t- borrowIndex (CCollateralCapErc20.sol#1379)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 2829,
          "vulnerability_to_line": 2848,
          "vulnerability_code": "    function initializeAccountCollateralTokens(address account) internal {\n\n        /**\n\n         * If isCollateralTokenInit is false, it means accountCollateralTokens was not initialized yet.\n\n         * This case will only happen once and must be the very beginning. accountCollateralTokens is a new structure and its\n\n         * initial value should be equal to accountTokens if user has entered the market. However, it's almost impossible to\n\n         * check every user's value when the implementation becomes active. Therefore, it must rely on every action which will\n\n         * access accountTokens to call this function to check if accountCollateralTokens needed to be initialized.\n\n         */\n\n        if (!isCollateralTokenInit[account]) {\n\n            if (ComptrollerInterfaceExtension(address(comptroller)).checkMembership(account, CToken(this))) {\n\n                accountCollateralTokens[account] = accountTokens[account];\n\n                totalCollateralTokens = add_(totalCollateralTokens, accountTokens[account]);\n\n\n\n                emit UserCollateralChanged(account, accountCollateralTokens[account]);\n\n            }\n\n            isCollateralTokenInit[account] = true;\n\n        }\n\n    }\n\n\n",
          "message": "Reentrancy in CCollateralCapErc20.initializeAccountCollateralTokens (CCollateralCapErc20.sol#2829-2848):\n\tExternal calls:\n\t- ComptrollerInterfaceExtension(address(comptroller)).checkMembership(account,CToken(this)) (CCollateralCapErc20.sol#2838-2844)\n\tState variables written after the call(s):\n\t- isCollateralTokenInit (CCollateralCapErc20.sol#2844-2845)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 1946,
          "vulnerability_to_line": 1961,
          "vulnerability_code": "    function liquidateBorrowInternal(address borrower, uint repayAmount, CTokenInterface cTokenCollateral) internal nonReentrant returns (uint, uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\n\n            return (fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED), 0);\n\n        }\n\n\n\n        error = cTokenCollateral.accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\n\n            return (fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED), 0);\n\n        }\n\n\n\n        // liquidateBorrowFresh emits borrow-specific logs on errors, so we don't need to\n\n        return liquidateBorrowFresh(msg.sender, borrower, repayAmount, cTokenCollateral);\n",
          "message": "Reentrancy in CToken.liquidateBorrowInternal (CCollateralCapErc20.sol#1946-1961):\n\tExternal calls:\n\t- error = accrueInterest() (CCollateralCapErc20.sol#1947)\n\t- error = cTokenCollateral.accrueInterest() (CCollateralCapErc20.sol#1953)\n\t- liquidateBorrowFresh(msg.sender,borrower,repayAmount,cTokenCollateral) (CCollateralCapErc20.sol#1960)\n\tState variables written after the call(s):\n\t- totalBorrows (CCollateralCapErc20.sol#1960)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 3063,
          "vulnerability_to_line": 3128,
          "vulnerability_code": "    function mintFresh(address minter, uint mintAmount) internal returns (uint, uint) {\n\n        // Make sure accountCollateralTokens of `minter` is initialized.\n\n        initializeAccountCollateralTokens(minter);\n\n\n\n        /* Fail if mint not allowed */\n\n        uint allowed = comptroller.mintAllowed(address(this), minter, mintAmount);\n\n        if (allowed != 0) {\n\n            return (failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.MINT_COMPTROLLER_REJECTION, allowed), 0);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return (fail(Error.MARKET_NOT_FRESH, FailureInfo.MINT_FRESHNESS_CHECK), 0);\n\n        }\n\n\n\n        MintLocalVars memory vars;\n\n\n\n        vars.exchangeRateMantissa = exchangeRateStoredInternal();\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         *  We call `doTransferIn` for the minter and the mintAmount.\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  `doTransferIn` reverts if anything goes wrong, since we can't be sure if\n\n         *  side-effects occurred. The function returns the amount actually transferred,\n\n         *  in case of a fee. On success, the cToken holds an additional `actualMintAmount`\n\n         *  of cash.\n\n         */\n\n        vars.actualMintAmount = doTransferIn(minter, mintAmount);\n\n\n\n        /*\n\n         * We get the current exchange rate and calculate the number of cTokens to be minted:\n\n         *  mintTokens = actualMintAmount / exchangeRate\n\n         */\n\n        vars.mintTokens = div_ScalarByExpTruncate(vars.actualMintAmount, Exp({mantissa: vars.exchangeRateMantissa}));\n\n\n\n        /*\n\n         * We calculate the new total supply of cTokens and minter token balance, checking for overflow:\n\n         *  totalSupply = totalSupply + mintTokens\n\n         *  accountTokens[minter] = accountTokens[minter] + mintTokens\n\n         */\n\n        totalSupply = add_(totalSupply, vars.mintTokens);\n\n        accountTokens[minter] = add_(accountTokens[minter], vars.mintTokens);\n\n\n\n        /*\n\n         * We only allocate collateral tokens if the minter has entered the market.\n\n         */\n\n        if (ComptrollerInterfaceExtension(address(comptroller)).checkMembership(minter, CToken(this))) {\n\n            increaseUserCollateralInternal(minter, vars.mintTokens);\n\n        }\n\n\n\n        /* We emit a Mint event, and a Transfer event */\n\n        emit Mint(minter, vars.actualMintAmount, vars.mintTokens);\n\n        emit Transfer(address(this), minter, vars.mintTokens);\n\n\n\n        /* We call the defense hook */\n\n        // unused function\n\n        // comptroller.mintVerify(address(this), minter, vars.actualMintAmount, vars.mintTokens);\n\n\n\n        return (uint(Error.NO_ERROR), vars.actualMintAmount);\n\n    }\n\n\n",
          "message": "Reentrancy in CCollateralCapErc20.mintFresh (CCollateralCapErc20.sol#3063-3128):\n\tExternal calls:\n\t- initializeAccountCollateralTokens(minter) (CCollateralCapErc20.sol#3065-3067)\n\t- allowed = comptroller.mintAllowed(address(this),minter,mintAmount) (CCollateralCapErc20.sol#3068-3069)\n\t- vars.actualMintAmount = doTransferIn(minter,mintAmount) (CCollateralCapErc20.sol#3094-3096)\n\tState variables written after the call(s):\n\t- accountTokens (CCollateralCapErc20.sol#3108-3110)\n\t- totalSupply (CCollateralCapErc20.sol#3107-3108)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 3063,
          "vulnerability_to_line": 3128,
          "vulnerability_code": "    function mintFresh(address minter, uint mintAmount) internal returns (uint, uint) {\n\n        // Make sure accountCollateralTokens of `minter` is initialized.\n\n        initializeAccountCollateralTokens(minter);\n\n\n\n        /* Fail if mint not allowed */\n\n        uint allowed = comptroller.mintAllowed(address(this), minter, mintAmount);\n\n        if (allowed != 0) {\n\n            return (failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.MINT_COMPTROLLER_REJECTION, allowed), 0);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return (fail(Error.MARKET_NOT_FRESH, FailureInfo.MINT_FRESHNESS_CHECK), 0);\n\n        }\n\n\n\n        MintLocalVars memory vars;\n\n\n\n        vars.exchangeRateMantissa = exchangeRateStoredInternal();\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         *  We call `doTransferIn` for the minter and the mintAmount.\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  `doTransferIn` reverts if anything goes wrong, since we can't be sure if\n\n         *  side-effects occurred. The function returns the amount actually transferred,\n\n         *  in case of a fee. On success, the cToken holds an additional `actualMintAmount`\n\n         *  of cash.\n\n         */\n\n        vars.actualMintAmount = doTransferIn(minter, mintAmount);\n\n\n\n        /*\n\n         * We get the current exchange rate and calculate the number of cTokens to be minted:\n\n         *  mintTokens = actualMintAmount / exchangeRate\n\n         */\n\n        vars.mintTokens = div_ScalarByExpTruncate(vars.actualMintAmount, Exp({mantissa: vars.exchangeRateMantissa}));\n\n\n\n        /*\n\n         * We calculate the new total supply of cTokens and minter token balance, checking for overflow:\n\n         *  totalSupply = totalSupply + mintTokens\n\n         *  accountTokens[minter] = accountTokens[minter] + mintTokens\n\n         */\n\n        totalSupply = add_(totalSupply, vars.mintTokens);\n\n        accountTokens[minter] = add_(accountTokens[minter], vars.mintTokens);\n\n\n\n        /*\n\n         * We only allocate collateral tokens if the minter has entered the market.\n\n         */\n\n        if (ComptrollerInterfaceExtension(address(comptroller)).checkMembership(minter, CToken(this))) {\n\n            increaseUserCollateralInternal(minter, vars.mintTokens);\n\n        }\n\n\n\n        /* We emit a Mint event, and a Transfer event */\n\n        emit Mint(minter, vars.actualMintAmount, vars.mintTokens);\n\n        emit Transfer(address(this), minter, vars.mintTokens);\n\n\n\n        /* We call the defense hook */\n\n        // unused function\n\n        // comptroller.mintVerify(address(this), minter, vars.actualMintAmount, vars.mintTokens);\n\n\n\n        return (uint(Error.NO_ERROR), vars.actualMintAmount);\n\n    }\n\n\n",
          "message": "Reentrancy in CCollateralCapErc20.mintFresh (CCollateralCapErc20.sol#3063-3128):\n\tExternal calls:\n\t- initializeAccountCollateralTokens(minter) (CCollateralCapErc20.sol#3065-3067)\n\t- allowed = comptroller.mintAllowed(address(this),minter,mintAmount) (CCollateralCapErc20.sol#3068-3069)\n\t- vars.actualMintAmount = doTransferIn(minter,mintAmount) (CCollateralCapErc20.sol#3094-3096)\n\t- ComptrollerInterfaceExtension(address(comptroller)).checkMembership(minter,CToken(this)) (CCollateralCapErc20.sol#3113-3117)\n\tState variables written after the call(s):\n\t- accountCollateralTokens (CCollateralCapErc20.sol#3114-3115)\n\t- totalCollateralTokens (CCollateralCapErc20.sol#3114-3115)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 3142,
          "vulnerability_to_line": 3231,
          "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n\n        // Make sure accountCollateralTokens of `redeemer` is initialized.\n\n        initializeAccountCollateralTokens(redeemer);\n\n\n\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n\n\n\n        RedeemLocalVars memory vars;\n\n\n\n        /* exchangeRate = invoke Exchange Rate Stored() */\n\n        vars.exchangeRateMantissa = exchangeRateStoredInternal();\n\n\n\n        /* If redeemTokensIn > 0: */\n\n        if (redeemTokensIn > 0) {\n\n            /*\n\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\n\n             *  redeemTokens = redeemTokensIn\n\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n\n             */\n\n            vars.redeemTokens = redeemTokensIn;\n\n            vars.redeemAmount = mul_ScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);\n\n        } else {\n\n            /*\n\n             * We get the current exchange rate and calculate the amount to be redeemed:\n\n             *  redeemTokens = redeemAmountIn / exchangeRate\n\n             *  redeemAmount = redeemAmountIn\n\n             */\n\n            vars.redeemTokens = div_ScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));\n\n            vars.redeemAmount = redeemAmountIn;\n\n        }\n\n\n\n        /**\n\n         * For every user, accountTokens must be greater than or equal to accountCollateralTokens.\n\n         * The buffer between the two values will be redeemed first.\n\n         * bufferTokens = accountTokens[redeemer] - accountCollateralTokens[redeemer]\n\n         * collateralTokens = redeemTokens - bufferTokens\n\n         */\n\n        uint bufferTokens = sub_(accountTokens[redeemer], accountCollateralTokens[redeemer]);\n\n        uint collateralTokens = 0;\n\n        if (vars.redeemTokens > bufferTokens) {\n\n            collateralTokens = sub_(vars.redeemTokens, bufferTokens);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);\n\n        }\n\n\n\n        /* Fail gracefully if protocol has insufficient cash */\n\n        if (getCashPrior() < vars.redeemAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We invoke doTransferOut for the redeemer and the redeemAmount.\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken has redeemAmount less of cash.\n\n         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n\n         */\n\n        doTransferOut(redeemer, vars.redeemAmount);\n\n\n\n        /*\n\n         * We calculate the new total supply and redeemer balance, checking for underflow:\n\n         *  totalSupplyNew = totalSupply - redeemTokens\n\n         *  accountTokensNew = accountTokens[redeemer] - redeemTokens\n\n         */\n\n        totalSupply = sub_(totalSupply, vars.redeemTokens);\n\n        accountTokens[redeemer] = sub_(accountTokens[redeemer], vars.redeemTokens);\n\n\n\n        /*\n\n         * We only deallocate collateral tokens if the redeemer needs to redeem them.\n\n         */\n\n        if (collateralTokens > 0) {\n\n            decreaseUserCollateralInternal(redeemer, collateralTokens);\n\n        }\n\n\n\n        /* We emit a Transfer event, and a Redeem event */\n\n        emit Transfer(redeemer, address(this), vars.redeemTokens);\n\n        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        /* We call the defense hook */\n\n        comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Reentrancy in CCollateralCapErc20.redeemFresh (CCollateralCapErc20.sol#3142-3231):\n\tExternal calls:\n\t- initializeAccountCollateralTokens(redeemer) (CCollateralCapErc20.sol#3144-3146)\n\t- doTransferOut(redeemer,vars.redeemAmount) (CCollateralCapErc20.sol#3204-3206)\n\tState variables written after the call(s):\n\t- accountTokens (CCollateralCapErc20.sol#3212-3214)\n\t- totalSupply (CCollateralCapErc20.sol#3211-3212)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 3142,
          "vulnerability_to_line": 3231,
          "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n\n        // Make sure accountCollateralTokens of `redeemer` is initialized.\n\n        initializeAccountCollateralTokens(redeemer);\n\n\n\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n\n\n\n        RedeemLocalVars memory vars;\n\n\n\n        /* exchangeRate = invoke Exchange Rate Stored() */\n\n        vars.exchangeRateMantissa = exchangeRateStoredInternal();\n\n\n\n        /* If redeemTokensIn > 0: */\n\n        if (redeemTokensIn > 0) {\n\n            /*\n\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\n\n             *  redeemTokens = redeemTokensIn\n\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n\n             */\n\n            vars.redeemTokens = redeemTokensIn;\n\n            vars.redeemAmount = mul_ScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);\n\n        } else {\n\n            /*\n\n             * We get the current exchange rate and calculate the amount to be redeemed:\n\n             *  redeemTokens = redeemAmountIn / exchangeRate\n\n             *  redeemAmount = redeemAmountIn\n\n             */\n\n            vars.redeemTokens = div_ScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));\n\n            vars.redeemAmount = redeemAmountIn;\n\n        }\n\n\n\n        /**\n\n         * For every user, accountTokens must be greater than or equal to accountCollateralTokens.\n\n         * The buffer between the two values will be redeemed first.\n\n         * bufferTokens = accountTokens[redeemer] - accountCollateralTokens[redeemer]\n\n         * collateralTokens = redeemTokens - bufferTokens\n\n         */\n\n        uint bufferTokens = sub_(accountTokens[redeemer], accountCollateralTokens[redeemer]);\n\n        uint collateralTokens = 0;\n\n        if (vars.redeemTokens > bufferTokens) {\n\n            collateralTokens = sub_(vars.redeemTokens, bufferTokens);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);\n\n        }\n\n\n\n        /* Fail gracefully if protocol has insufficient cash */\n\n        if (getCashPrior() < vars.redeemAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We invoke doTransferOut for the redeemer and the redeemAmount.\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken has redeemAmount less of cash.\n\n         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n\n         */\n\n        doTransferOut(redeemer, vars.redeemAmount);\n\n\n\n        /*\n\n         * We calculate the new total supply and redeemer balance, checking for underflow:\n\n         *  totalSupplyNew = totalSupply - redeemTokens\n\n         *  accountTokensNew = accountTokens[redeemer] - redeemTokens\n\n         */\n\n        totalSupply = sub_(totalSupply, vars.redeemTokens);\n\n        accountTokens[redeemer] = sub_(accountTokens[redeemer], vars.redeemTokens);\n\n\n\n        /*\n\n         * We only deallocate collateral tokens if the redeemer needs to redeem them.\n\n         */\n\n        if (collateralTokens > 0) {\n\n            decreaseUserCollateralInternal(redeemer, collateralTokens);\n\n        }\n\n\n\n        /* We emit a Transfer event, and a Redeem event */\n\n        emit Transfer(redeemer, address(this), vars.redeemTokens);\n\n        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        /* We call the defense hook */\n\n        comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Reentrancy in CCollateralCapErc20.redeemFresh (CCollateralCapErc20.sol#3142-3231):\n\tExternal calls:\n\t- initializeAccountCollateralTokens(redeemer) (CCollateralCapErc20.sol#3144-3146)\n\t- doTransferOut(redeemer,vars.redeemAmount) (CCollateralCapErc20.sol#3204-3206)\n\t- decreaseUserCollateralInternal(redeemer,collateralTokens) (CCollateralCapErc20.sol#3218-3219)\n\tState variables written after the call(s):\n\t- accountCollateralTokens (CCollateralCapErc20.sol#3218-3219)\n\t- totalCollateralTokens (CCollateralCapErc20.sol#3218-3219)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 2778,
          "vulnerability_to_line": 2788,
          "vulnerability_code": "    function registerCollateral(address account) external returns (uint) {\n\n        // Make sure accountCollateralTokens of `account` is initialized.\n\n        initializeAccountCollateralTokens(account);\n\n\n\n        require(msg.sender == address(comptroller), \"only comptroller may register collateral for user\");\n\n\n\n        uint amount = sub_(accountTokens[account], accountCollateralTokens[account]);\n\n        return increaseUserCollateralInternal(account, amount);\n\n    }\n\n\n",
          "message": "Reentrancy in CCollateralCapErc20.registerCollateral (CCollateralCapErc20.sol#2778-2788):\n\tExternal calls:\n\t- initializeAccountCollateralTokens(account) (CCollateralCapErc20.sol#2780-2782)\n\tState variables written after the call(s):\n\t- accountCollateralTokens (CCollateralCapErc20.sol#2785-2786)\n\t- totalCollateralTokens (CCollateralCapErc20.sol#2785-2786)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 1847,
          "vulnerability_to_line": 1855,
          "vulnerability_code": "    function repayBorrowBehalfInternal(address borrower, uint repayAmount) internal nonReentrant returns (uint, uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n\n            return (fail(Error(error), FailureInfo.REPAY_BEHALF_ACCRUE_INTEREST_FAILED), 0);\n\n        }\n\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n\n        return repayBorrowFresh(msg.sender, borrower, repayAmount);\n",
          "message": "Reentrancy in CToken.repayBorrowBehalfInternal (CCollateralCapErc20.sol#1847-1855):\n\tExternal calls:\n\t- error = accrueInterest() (CCollateralCapErc20.sol#1848)\n\t- repayBorrowFresh(msg.sender,borrower,repayAmount) (CCollateralCapErc20.sol#1854)\n\tState variables written after the call(s):\n\t- totalBorrows (CCollateralCapErc20.sol#1854)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 1831,
          "vulnerability_to_line": 1839,
          "vulnerability_code": "    function repayBorrowInternal(uint repayAmount) internal nonReentrant returns (uint, uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n\n            return (fail(Error(error), FailureInfo.REPAY_BORROW_ACCRUE_INTEREST_FAILED), 0);\n\n        }\n\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n\n        return repayBorrowFresh(msg.sender, msg.sender, repayAmount);\n",
          "message": "Reentrancy in CToken.repayBorrowInternal (CCollateralCapErc20.sol#1831-1839):\n\tExternal calls:\n\t- error = accrueInterest() (CCollateralCapErc20.sol#1832)\n\t- repayBorrowFresh(msg.sender,msg.sender,repayAmount) (CCollateralCapErc20.sol#1838)\n\tState variables written after the call(s):\n\t- totalBorrows (CCollateralCapErc20.sol#1838)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 3241,
          "vulnerability_to_line": 3280,
          "vulnerability_code": "    function seizeInternal(address seizerToken, address liquidator, address borrower, uint seizeTokens) internal returns (uint) {\n\n        // Make sure accountCollateralTokens of `liquidator` and `borrower` are initialized.\n\n        initializeAccountCollateralTokens(liquidator);\n\n        initializeAccountCollateralTokens(borrower);\n\n\n\n        /* Fail if seize not allowed */\n\n        uint allowed = comptroller.seizeAllowed(address(this), seizerToken, liquidator, borrower, seizeTokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_SEIZE_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Fail if borrower = liquidator */\n\n        if (borrower == liquidator) {\n\n            return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER);\n\n        }\n\n\n\n        /*\n\n         * We calculate the new borrower and liquidator token balances and token collateral balances, failing on underflow/overflow:\n\n         *  accountTokens[borrower] = accountTokens[borrower] - seizeTokens\n\n         *  accountTokens[liquidator] = accountTokens[liquidator] + seizeTokens\n\n         *  accountCollateralTokens[borrower] = accountCollateralTokens[borrower] - seizeTokens\n\n         *  accountCollateralTokens[liquidator] = accountCollateralTokens[liquidator] + seizeTokens\n\n         */\n\n        accountTokens[borrower] = sub_(accountTokens[borrower], seizeTokens);\n\n        accountTokens[liquidator] = add_(accountTokens[liquidator], seizeTokens);\n\n        accountCollateralTokens[borrower] = sub_(accountCollateralTokens[borrower], seizeTokens);\n\n        accountCollateralTokens[liquidator] = add_(accountCollateralTokens[liquidator], seizeTokens);\n\n\n\n        /* Emit a Transfer, UserCollateralChanged events */\n\n        emit Transfer(borrower, liquidator, seizeTokens);\n\n        emit UserCollateralChanged(borrower, accountCollateralTokens[borrower]);\n\n        emit UserCollateralChanged(liquidator, accountCollateralTokens[liquidator]);\n\n\n\n        /* We call the defense hook */\n\n        // unused function\n\n        // comptroller.seizeVerify(address(this), seizerToken, liquidator, borrower, seizeTokens);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n",
          "message": "Reentrancy in CCollateralCapErc20.seizeInternal (CCollateralCapErc20.sol#3241-3280):\n\tExternal calls:\n\t- initializeAccountCollateralTokens(liquidator) (CCollateralCapErc20.sol#3243-3244)\n\t- initializeAccountCollateralTokens(borrower) (CCollateralCapErc20.sol#3244-3246)\n\tState variables written after the call(s):\n\t- accountCollateralTokens (CCollateralCapErc20.sol#3244-3246)\n\t- isCollateralTokenInit (CCollateralCapErc20.sol#3244-3246)\n\t- totalCollateralTokens (CCollateralCapErc20.sol#3244-3246)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 3241,
          "vulnerability_to_line": 3280,
          "vulnerability_code": "    function seizeInternal(address seizerToken, address liquidator, address borrower, uint seizeTokens) internal returns (uint) {\n\n        // Make sure accountCollateralTokens of `liquidator` and `borrower` are initialized.\n\n        initializeAccountCollateralTokens(liquidator);\n\n        initializeAccountCollateralTokens(borrower);\n\n\n\n        /* Fail if seize not allowed */\n\n        uint allowed = comptroller.seizeAllowed(address(this), seizerToken, liquidator, borrower, seizeTokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_SEIZE_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Fail if borrower = liquidator */\n\n        if (borrower == liquidator) {\n\n            return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER);\n\n        }\n\n\n\n        /*\n\n         * We calculate the new borrower and liquidator token balances and token collateral balances, failing on underflow/overflow:\n\n         *  accountTokens[borrower] = accountTokens[borrower] - seizeTokens\n\n         *  accountTokens[liquidator] = accountTokens[liquidator] + seizeTokens\n\n         *  accountCollateralTokens[borrower] = accountCollateralTokens[borrower] - seizeTokens\n\n         *  accountCollateralTokens[liquidator] = accountCollateralTokens[liquidator] + seizeTokens\n\n         */\n\n        accountTokens[borrower] = sub_(accountTokens[borrower], seizeTokens);\n\n        accountTokens[liquidator] = add_(accountTokens[liquidator], seizeTokens);\n\n        accountCollateralTokens[borrower] = sub_(accountCollateralTokens[borrower], seizeTokens);\n\n        accountCollateralTokens[liquidator] = add_(accountCollateralTokens[liquidator], seizeTokens);\n\n\n\n        /* Emit a Transfer, UserCollateralChanged events */\n\n        emit Transfer(borrower, liquidator, seizeTokens);\n\n        emit UserCollateralChanged(borrower, accountCollateralTokens[borrower]);\n\n        emit UserCollateralChanged(liquidator, accountCollateralTokens[liquidator]);\n\n\n\n        /* We call the defense hook */\n\n        // unused function\n\n        // comptroller.seizeVerify(address(this), seizerToken, liquidator, borrower, seizeTokens);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n",
          "message": "Reentrancy in CCollateralCapErc20.seizeInternal (CCollateralCapErc20.sol#3241-3280):\n\tExternal calls:\n\t- initializeAccountCollateralTokens(liquidator) (CCollateralCapErc20.sol#3243-3244)\n\t- initializeAccountCollateralTokens(borrower) (CCollateralCapErc20.sol#3244-3246)\n\t- allowed = comptroller.seizeAllowed(address(this),seizerToken,liquidator,borrower,seizeTokens) (CCollateralCapErc20.sol#3247-3248)\n\tState variables written after the call(s):\n\t- accountCollateralTokens (CCollateralCapErc20.sol#3266-3267)\n\t- accountCollateralTokens (CCollateralCapErc20.sol#3267-3269)\n\t- accountTokens (CCollateralCapErc20.sol#3264-3265)\n\t- accountTokens (CCollateralCapErc20.sol#3265-3266)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 2925,
          "vulnerability_to_line": 2990,
          "vulnerability_code": "    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (uint) {\n\n        // Make sure accountCollateralTokens of `src` and `dst` are initialized.\n\n        initializeAccountCollateralTokens(src);\n\n        initializeAccountCollateralTokens(dst);\n\n\n\n        /**\n\n         * For every user, accountTokens must be greater than or equal to accountCollateralTokens.\n\n         * The buffer between the two values will be transferred first.\n\n         * bufferTokens = accountTokens[src] - accountCollateralTokens[src]\n\n         * collateralTokens = tokens - bufferTokens\n\n         */\n\n        uint bufferTokens = sub_(accountTokens[src], accountCollateralTokens[src]);\n\n        uint collateralTokens = 0;\n\n        if (tokens > bufferTokens) {\n\n            collateralTokens = sub_(tokens, bufferTokens);\n\n        }\n\n\n\n        /**\n\n         * Since bufferTokens are not collateralized and can be transferred freely, we only check with comptroller\n\n         * whether collateralized tokens can be transferred.\n\n         */\n\n        uint allowed = comptroller.transferAllowed(address(this), src, dst, collateralTokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.TRANSFER_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Do not allow self-transfers */\n\n        if (src == dst) {\n\n            return fail(Error.BAD_INPUT, FailureInfo.TRANSFER_NOT_ALLOWED);\n\n        }\n\n\n\n        /* Get the allowance, infinite for the account owner */\n\n        uint startingAllowance = 0;\n\n        if (spender == src) {\n\n            startingAllowance = uint(-1);\n\n        } else {\n\n            startingAllowance = transferAllowances[src][spender];\n\n        }\n\n\n\n        /* Do the calculations, checking for {under,over}flow */\n\n        uint allowanceNew = sub_(startingAllowance, tokens);\n\n        accountTokens[src] = sub_(accountTokens[src], tokens);\n\n        accountTokens[dst] = add_(accountTokens[dst], tokens);\n\n        if (collateralTokens > 0) {\n\n            accountCollateralTokens[src] = sub_(accountCollateralTokens[src], collateralTokens);\n\n            accountCollateralTokens[dst] = add_(accountCollateralTokens[dst], collateralTokens);\n\n\n\n            emit UserCollateralChanged(src, accountCollateralTokens[src]);\n\n            emit UserCollateralChanged(dst, accountCollateralTokens[dst]);\n\n        }\n\n\n\n        /* Eat some of the allowance (if necessary) */\n\n        if (startingAllowance != uint(-1)) {\n\n            transferAllowances[src][spender] = allowanceNew;\n\n        }\n\n\n\n        /* We emit a Transfer event */\n\n        emit Transfer(src, dst, tokens);\n\n\n\n        // unused function\n\n        // comptroller.transferVerify(address(this), src, dst, tokens);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Reentrancy in CCollateralCapErc20.transferTokens (CCollateralCapErc20.sol#2925-2990):\n\tExternal calls:\n\t- initializeAccountCollateralTokens(src) (CCollateralCapErc20.sol#2927-2928)\n\t- initializeAccountCollateralTokens(dst) (CCollateralCapErc20.sol#2928-2930)\n\tState variables written after the call(s):\n\t- accountCollateralTokens (CCollateralCapErc20.sol#2928-2930)\n\t- isCollateralTokenInit (CCollateralCapErc20.sol#2928-2930)\n\t- totalCollateralTokens (CCollateralCapErc20.sol#2928-2930)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 2925,
          "vulnerability_to_line": 2990,
          "vulnerability_code": "    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (uint) {\n\n        // Make sure accountCollateralTokens of `src` and `dst` are initialized.\n\n        initializeAccountCollateralTokens(src);\n\n        initializeAccountCollateralTokens(dst);\n\n\n\n        /**\n\n         * For every user, accountTokens must be greater than or equal to accountCollateralTokens.\n\n         * The buffer between the two values will be transferred first.\n\n         * bufferTokens = accountTokens[src] - accountCollateralTokens[src]\n\n         * collateralTokens = tokens - bufferTokens\n\n         */\n\n        uint bufferTokens = sub_(accountTokens[src], accountCollateralTokens[src]);\n\n        uint collateralTokens = 0;\n\n        if (tokens > bufferTokens) {\n\n            collateralTokens = sub_(tokens, bufferTokens);\n\n        }\n\n\n\n        /**\n\n         * Since bufferTokens are not collateralized and can be transferred freely, we only check with comptroller\n\n         * whether collateralized tokens can be transferred.\n\n         */\n\n        uint allowed = comptroller.transferAllowed(address(this), src, dst, collateralTokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.TRANSFER_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Do not allow self-transfers */\n\n        if (src == dst) {\n\n            return fail(Error.BAD_INPUT, FailureInfo.TRANSFER_NOT_ALLOWED);\n\n        }\n\n\n\n        /* Get the allowance, infinite for the account owner */\n\n        uint startingAllowance = 0;\n\n        if (spender == src) {\n\n            startingAllowance = uint(-1);\n\n        } else {\n\n            startingAllowance = transferAllowances[src][spender];\n\n        }\n\n\n\n        /* Do the calculations, checking for {under,over}flow */\n\n        uint allowanceNew = sub_(startingAllowance, tokens);\n\n        accountTokens[src] = sub_(accountTokens[src], tokens);\n\n        accountTokens[dst] = add_(accountTokens[dst], tokens);\n\n        if (collateralTokens > 0) {\n\n            accountCollateralTokens[src] = sub_(accountCollateralTokens[src], collateralTokens);\n\n            accountCollateralTokens[dst] = add_(accountCollateralTokens[dst], collateralTokens);\n\n\n\n            emit UserCollateralChanged(src, accountCollateralTokens[src]);\n\n            emit UserCollateralChanged(dst, accountCollateralTokens[dst]);\n\n        }\n\n\n\n        /* Eat some of the allowance (if necessary) */\n\n        if (startingAllowance != uint(-1)) {\n\n            transferAllowances[src][spender] = allowanceNew;\n\n        }\n\n\n\n        /* We emit a Transfer event */\n\n        emit Transfer(src, dst, tokens);\n\n\n\n        // unused function\n\n        // comptroller.transferVerify(address(this), src, dst, tokens);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Reentrancy in CCollateralCapErc20.transferTokens (CCollateralCapErc20.sol#2925-2990):\n\tExternal calls:\n\t- initializeAccountCollateralTokens(src) (CCollateralCapErc20.sol#2927-2928)\n\t- initializeAccountCollateralTokens(dst) (CCollateralCapErc20.sol#2928-2930)\n\t- allowed = comptroller.transferAllowed(address(this),src,dst,collateralTokens) (CCollateralCapErc20.sol#2946-2947)\n\tState variables written after the call(s):\n\t- accountCollateralTokens (CCollateralCapErc20.sol#2969-2970)\n\t- accountCollateralTokens (CCollateralCapErc20.sol#2970-2972)\n\t- accountTokens (CCollateralCapErc20.sol#2966-2967)\n\t- accountTokens (CCollateralCapErc20.sol#2967-2968)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 2793,
          "vulnerability_to_line": 2802,
          "vulnerability_code": "    function unregisterCollateral(address account) external {\n\n        // Make sure accountCollateralTokens of `account` is initialized.\n\n        initializeAccountCollateralTokens(account);\n\n\n\n        require(msg.sender == address(comptroller), \"only comptroller may unregister collateral for user\");\n\n\n\n        decreaseUserCollateralInternal(account, accountCollateralTokens[account]);\n\n    }\n\n\n",
          "message": "Reentrancy in CCollateralCapErc20.unregisterCollateral (CCollateralCapErc20.sol#2793-2802):\n\tExternal calls:\n\t- initializeAccountCollateralTokens(account) (CCollateralCapErc20.sol#2795-2797)\n\t- decreaseUserCollateralInternal(account,accountCollateralTokens[account]) (CCollateralCapErc20.sol#2799-2800)\n\tState variables written after the call(s):\n\t- accountCollateralTokens (CCollateralCapErc20.sol#2799-2800)\n\t- totalCollateralTokens (CCollateralCapErc20.sol#2799-2800)\n"
        },
        {
          "name": "uninitialized-local",
          "vulnerability_from_line": 1887,
          "vulnerability_to_line": null,
          "vulnerability_code": "        RepayBorrowLocalVars memory vars;\n",
          "message": "vars in CToken.repayBorrowFresh (CCollateralCapErc20.sol#1887) is a local variable never initialiazed\n"
        },
        {
          "name": "uninitialized-local",
          "vulnerability_from_line": 2203,
          "vulnerability_to_line": 2205,
          "vulnerability_code": "        uint actualAddAmount;\n\n\n",
          "message": "actualAddAmount in CToken._addReservesFresh (CCollateralCapErc20.sol#2203-2205) is a local variable never initialiazed\n"
        },
        {
          "name": "uninitialized-local",
          "vulnerability_from_line": 3078,
          "vulnerability_to_line": 3080,
          "vulnerability_code": "        MintLocalVars memory vars;\n\n\n",
          "message": "vars in CCollateralCapErc20.mintFresh (CCollateralCapErc20.sol#3078-3080) is a local variable never initialiazed\n"
        },
        {
          "name": "uninitialized-local",
          "vulnerability_from_line": 1788,
          "vulnerability_to_line": null,
          "vulnerability_code": "        BorrowLocalVars memory vars;\n",
          "message": "vars in CToken.borrowFresh (CCollateralCapErc20.sol#1788) is a local variable never initialiazed\n"
        },
        {
          "name": "uninitialized-local",
          "vulnerability_from_line": 3148,
          "vulnerability_to_line": 3150,
          "vulnerability_code": "        RedeemLocalVars memory vars;\n\n\n",
          "message": "vars in CCollateralCapErc20.redeemFresh (CCollateralCapErc20.sol#3148-3150) is a local variable never initialiazed\n"
        },
        {
          "name": "unused-return",
          "vulnerability_from_line": 2617,
          "vulnerability_to_line": 2632,
          "vulnerability_code": "    function initialize(address underlying_,\n\n                        ComptrollerInterface comptroller_,\n\n                        InterestRateModel interestRateModel_,\n\n                        uint initialExchangeRateMantissa_,\n\n                        string memory name_,\n\n                        string memory symbol_,\n\n                        uint8 decimals_) public {\n\n        // CToken initialize does the bulk of the work\n\n        super.initialize(comptroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_);\n\n\n\n        // Set underlying and sanity check it\n\n        underlying = underlying_;\n\n        EIP20Interface(underlying).totalSupply();\n\n    }\n\n\n",
          "message": "CCollateralCapErc20.initialize (CCollateralCapErc20.sol#2617-2632) does not use the value returned by external calls:\n\t-EIP20Interface(underlying).totalSupply() (CCollateralCapErc20.sol#2629-2630)\n"
        },
        {
          "name": "shadowing-local",
          "vulnerability_from_line": 916,
          "vulnerability_to_line": null,
          "vulnerability_code": "        (MathError err, Exp memory fraction) = divScalarByExp(scalar, divisor);\n",
          "message": "Exponential.divScalarByExpTruncate.fraction (local variable @ CCollateralCapErc20.sol#916) shadows:\n\t- Exponential.fraction (function @ CCollateralCapErc20.sol#1146-1148)\n"
        },
        {
          "name": "shadowing-local",
          "vulnerability_from_line": 945,
          "vulnerability_to_line": null,
          "vulnerability_code": "        Exp memory fraction = div_ScalarByExp(scalar, divisor);\n",
          "message": "Exponential.div_ScalarByExpTruncate.fraction (local variable @ CCollateralCapErc20.sol#945) shadows:\n\t- Exponential.fraction (function @ CCollateralCapErc20.sol#1146-1148)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 1771,
          "vulnerability_to_line": 1824,
          "vulnerability_code": "    function borrowFresh(address payable borrower, uint borrowAmount) internal returns (uint) {\n\n        /* Fail if borrow not allowed */\n\n        uint allowed = comptroller.borrowAllowed(address(this), borrower, borrowAmount);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.BORROW_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.BORROW_FRESHNESS_CHECK);\n\n        }\n\n\n\n        /* Fail gracefully if protocol has insufficient underlying cash */\n\n        if (getCashPrior() < borrowAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.BORROW_CASH_NOT_AVAILABLE);\n\n        }\n\n\n\n        BorrowLocalVars memory vars;\n\n\n\n        /*\n\n         * We calculate the new borrower and total borrow balances, failing on overflow:\n\n         *  accountBorrowsNew = accountBorrows + borrowAmount\n\n         *  totalBorrowsNew = totalBorrows + borrowAmount\n\n         */\n\n        vars.accountBorrows = borrowBalanceStoredInternal(borrower);\n\n        vars.accountBorrowsNew = add_(vars.accountBorrows, borrowAmount);\n\n        vars.totalBorrowsNew = add_(totalBorrows, borrowAmount);\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We invoke doTransferOut for the borrower and the borrowAmount.\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken borrowAmount less of cash.\n\n         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n\n         */\n\n        doTransferOut(borrower, borrowAmount);\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n\n        accountBorrows[borrower].interestIndex = borrowIndex;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n\n\n        /* We emit a Borrow event */\n\n        emit Borrow(borrower, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n\n\n        /* We call the defense hook */\n\n        // unused function\n\n        // comptroller.borrowVerify(address(this), borrower, borrowAmount);\n\n\n\n        return uint(Error.NO_ERROR);\n",
          "message": "Reentrancy in CToken.borrowFresh (CCollateralCapErc20.sol#1771-1824):\n\tExternal calls:\n\t- allowed = comptroller.borrowAllowed(address(this),borrower,borrowAmount) (CCollateralCapErc20.sol#1773)\n\tState variables written after the call(s):\n\t- accountBorrows (CCollateralCapErc20.sol#1812)\n\t- accountBorrows (CCollateralCapErc20.sol#1813)\n\t- totalBorrows (CCollateralCapErc20.sol#1814)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 3041,
          "vulnerability_to_line": 3050,
          "vulnerability_code": "    function decreaseUserCollateralInternal(address account, uint amount) internal {\n\n        require(comptroller.redeemAllowed(address(this), account, amount) == 0, \"comptroller rejection\");\n\n\n\n        totalCollateralTokens = sub_(totalCollateralTokens, amount);\n\n        accountCollateralTokens[account] = sub_(accountCollateralTokens[account], amount);\n\n\n\n        emit UserCollateralChanged(account, accountCollateralTokens[account]);\n\n    }\n\n\n",
          "message": "Reentrancy in CCollateralCapErc20.decreaseUserCollateralInternal (CCollateralCapErc20.sol#3041-3050):\n\tExternal calls:\n\t- require(bool,string)(comptroller.redeemAllowed(address(this),account,amount) == 0,comptroller rejection) (CCollateralCapErc20.sol#3042-3044)\n\tState variables written after the call(s):\n\t- accountCollateralTokens (CCollateralCapErc20.sol#3045-3047)\n\t- totalCollateralTokens (CCollateralCapErc20.sol#3044-3045)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 2857,
          "vulnerability_to_line": 2885,
          "vulnerability_code": "    function doTransferIn(address from, uint amount) internal returns (uint) {\n\n        EIP20NonStandardInterface token = EIP20NonStandardInterface(underlying);\n\n        uint balanceBefore = EIP20Interface(underlying).balanceOf(address(this));\n\n        token.transferFrom(from, address(this), amount);\n\n\n\n        bool success;\n\n        assembly {\n\n            switch returndatasize()\n\n                case 0 {                       // This is a non-standard ERC-20\n\n                    success := not(0)          // set success to true\n\n                }\n\n                case 32 {                      // This is a compliant ERC-20\n\n                    returndatacopy(0, 0, 32)\n\n                    success := mload(0)        // Set `success = returndata` of external call\n\n                }\n\n                default {                      // This is an excessively non-compliant ERC-20, revert.\n\n                    revert(0, 0)\n\n                }\n\n        }\n\n        require(success, \"TOKEN_TRANSFER_IN_FAILED\");\n\n\n\n        // Calculate the amount that was *actually* transferred\n\n        uint balanceAfter = EIP20Interface(underlying).balanceOf(address(this));\n\n        uint transferredIn = sub_(balanceAfter, balanceBefore);\n\n        internalCash = add_(internalCash, transferredIn);\n\n        return transferredIn;\n\n    }\n\n\n",
          "message": "Reentrancy in CCollateralCapErc20.doTransferIn (CCollateralCapErc20.sol#2857-2885):\n\tExternal calls:\n\t- balanceBefore = EIP20Interface(underlying).balanceOf(address(this)) (CCollateralCapErc20.sol#2859-2860)\n\t- token.transferFrom(from,address(this),amount) (CCollateralCapErc20.sol#2860-2862)\n\t- balanceAfter = EIP20Interface(underlying).balanceOf(address(this)) (CCollateralCapErc20.sol#2879-2880)\n\tState variables written after the call(s):\n\t- internalCash (CCollateralCapErc20.sol#2881-2882)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 2894,
          "vulnerability_to_line": 2916,
          "vulnerability_code": "    function doTransferOut(address payable to, uint amount) internal {\n\n        EIP20NonStandardInterface token = EIP20NonStandardInterface(underlying);\n\n        token.transfer(to, amount);\n\n\n\n        bool success;\n\n        assembly {\n\n            switch returndatasize()\n\n                case 0 {                      // This is a non-standard ERC-20\n\n                    success := not(0)          // set success to true\n\n                }\n\n                case 32 {                     // This is a complaint ERC-20\n\n                    returndatacopy(0, 0, 32)\n\n                    success := mload(0)        // Set `success = returndata` of external call\n\n                }\n\n                default {                     // This is an excessively non-compliant ERC-20, revert.\n\n                    revert(0, 0)\n\n                }\n\n        }\n\n        require(success, \"TOKEN_TRANSFER_OUT_FAILED\");\n\n        internalCash = sub_(internalCash, amount);\n\n    }\n\n\n",
          "message": "Reentrancy in CCollateralCapErc20.doTransferOut (CCollateralCapErc20.sol#2894-2916):\n\tExternal calls:\n\t- token.transfer(to,amount) (CCollateralCapErc20.sol#2896-2898)\n\tState variables written after the call(s):\n\t- internalCash (CCollateralCapErc20.sol#2913-2914)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 2746,
          "vulnerability_to_line": 2772,
          "vulnerability_code": "    function flashLoan(address receiver, uint amount, bytes calldata params) external nonReentrant {\n\n        uint cashOnChainBefore = getCashOnChain();\n\n        uint cashBefore = getCashPrior();\n\n        require(cashBefore >= amount, \"INSUFFICIENT_LIQUIDITY\");\n\n\n\n        // 1. calculate fee, 1 bips = 1/10000\n\n        uint totalFee = div_(mul_(amount, flashFeeBips), 10000);\n\n\n\n        // 2. transfer fund to receiver\n\n        doTransferOut(address(uint160(receiver)), amount);\n\n\n\n        // 3. execute receiver's callback function\n\n        IFlashloanReceiver(receiver).executeOperation(msg.sender, underlying, amount, totalFee, params);\n\n\n\n        // 4. check balance\n\n        uint cashOnChainAfter = getCashOnChain();\n\n        require(cashOnChainAfter == add_(cashOnChainBefore, totalFee), \"BALANCE_INCONSISTENT\");\n\n\n\n        // 5. update reserves and internal cash\n\n        uint reservesFee = mul_ScalarTruncate(Exp({mantissa: reserveFactorMantissa}), totalFee);\n\n        totalReserves = add_(totalReserves, reservesFee);\n\n        internalCash = add_(cashBefore, totalFee);\n\n\n\n        emit Flashloan(receiver, amount, totalFee, reservesFee);\n\n    }\n\n\n",
          "message": "Reentrancy in CCollateralCapErc20.flashLoan (CCollateralCapErc20.sol#2746-2772):\n\tExternal calls:\n\t- cashOnChainBefore = getCashOnChain() (CCollateralCapErc20.sol#2747-2748)\n\t- doTransferOut(address(uint160(receiver)),amount) (CCollateralCapErc20.sol#2755-2757)\n\t- IFlashloanReceiver(receiver).executeOperation(msg.sender,underlying,amount,totalFee,params) (CCollateralCapErc20.sol#2758-2760)\n\t- cashOnChainAfter = getCashOnChain() (CCollateralCapErc20.sol#2761-2762)\n\tState variables written after the call(s):\n\t- totalReserves (CCollateralCapErc20.sol#2766-2767)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 2731,
          "vulnerability_to_line": 2740,
          "vulnerability_code": "    function gulp() external nonReentrant {\n\n        uint256 cashOnChain = getCashOnChain();\n\n        uint256 cashPrior = getCashPrior();\n\n\n\n        uint excessCash = sub_(cashOnChain, cashPrior);\n\n        totalReserves = add_(totalReserves, excessCash);\n\n        internalCash = cashOnChain;\n\n    }\n\n\n",
          "message": "Reentrancy in CCollateralCapErc20.gulp (CCollateralCapErc20.sol#2731-2740):\n\tExternal calls:\n\t- cashOnChain = getCashOnChain() (CCollateralCapErc20.sol#2732-2733)\n\tState variables written after the call(s):\n\t- internalCash (CCollateralCapErc20.sol#2737-2738)\n\t- totalReserves (CCollateralCapErc20.sol#2736-2737)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 1360,
          "vulnerability_to_line": 1391,
          "vulnerability_code": "    function initialize(ComptrollerInterface comptroller_,\n\n                        InterestRateModel interestRateModel_,\n\n                        uint initialExchangeRateMantissa_,\n\n                        string memory name_,\n\n                        string memory symbol_,\n\n                        uint8 decimals_) public {\n\n        require(msg.sender == admin, \"only admin may initialize the market\");\n\n        require(accrualBlockNumber == 0 && borrowIndex == 0, \"market may only be initialized once\");\n\n\n\n        // Set initial exchange rate\n\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n\n        require(initialExchangeRateMantissa > 0, \"initial exchange rate must be greater than zero.\");\n\n\n\n        // Set the comptroller\n\n        uint err = _setComptroller(comptroller_);\n\n        require(err == uint(Error.NO_ERROR), \"setting comptroller failed\");\n\n\n\n        // Initialize block number and borrow index (block number mocks depend on comptroller being set)\n\n        accrualBlockNumber = getBlockNumber();\n\n        borrowIndex = mantissaOne;\n\n\n\n        // Set the interest rate model (depends on block number / borrow index)\n\n        err = _setInterestRateModelFresh(interestRateModel_);\n\n        require(err == uint(Error.NO_ERROR), \"setting interest rate model failed\");\n\n\n\n        name = name_;\n\n        symbol = symbol_;\n\n        decimals = decimals_;\n\n\n\n        // The counter starts true to prevent changing it from zero to non-zero (i.e. smaller cost/refund)\n\n        _notEntered = true;\n",
          "message": "Reentrancy in CToken.initialize (CCollateralCapErc20.sol#1360-1391):\n\tExternal calls:\n\t- err = _setComptroller(comptroller_) (CCollateralCapErc20.sol#1374)\n\t- err = _setInterestRateModelFresh(interestRateModel_) (CCollateralCapErc20.sol#1382)\n\tState variables written after the call(s):\n\t- _notEntered (CCollateralCapErc20.sol#1390)\n\t- decimals (CCollateralCapErc20.sol#1387)\n\t- name (CCollateralCapErc20.sol#1385)\n\t- symbol (CCollateralCapErc20.sol#1386)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 2617,
          "vulnerability_to_line": 2632,
          "vulnerability_code": "    function initialize(address underlying_,\n\n                        ComptrollerInterface comptroller_,\n\n                        InterestRateModel interestRateModel_,\n\n                        uint initialExchangeRateMantissa_,\n\n                        string memory name_,\n\n                        string memory symbol_,\n\n                        uint8 decimals_) public {\n\n        // CToken initialize does the bulk of the work\n\n        super.initialize(comptroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_);\n\n\n\n        // Set underlying and sanity check it\n\n        underlying = underlying_;\n\n        EIP20Interface(underlying).totalSupply();\n\n    }\n\n\n",
          "message": "Reentrancy in CCollateralCapErc20.initialize (CCollateralCapErc20.sol#2617-2632):\n\tExternal calls:\n\t- super.initialize(comptroller_,interestRateModel_,initialExchangeRateMantissa_,name_,symbol_,decimals_) (CCollateralCapErc20.sol#2625-2627)\n\tState variables written after the call(s):\n\t- underlying (CCollateralCapErc20.sol#2628-2629)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 2829,
          "vulnerability_to_line": 2848,
          "vulnerability_code": "    function initializeAccountCollateralTokens(address account) internal {\n\n        /**\n\n         * If isCollateralTokenInit is false, it means accountCollateralTokens was not initialized yet.\n\n         * This case will only happen once and must be the very beginning. accountCollateralTokens is a new structure and its\n\n         * initial value should be equal to accountTokens if user has entered the market. However, it's almost impossible to\n\n         * check every user's value when the implementation becomes active. Therefore, it must rely on every action which will\n\n         * access accountTokens to call this function to check if accountCollateralTokens needed to be initialized.\n\n         */\n\n        if (!isCollateralTokenInit[account]) {\n\n            if (ComptrollerInterfaceExtension(address(comptroller)).checkMembership(account, CToken(this))) {\n\n                accountCollateralTokens[account] = accountTokens[account];\n\n                totalCollateralTokens = add_(totalCollateralTokens, accountTokens[account]);\n\n\n\n                emit UserCollateralChanged(account, accountCollateralTokens[account]);\n\n            }\n\n            isCollateralTokenInit[account] = true;\n\n        }\n\n    }\n\n\n",
          "message": "Reentrancy in CCollateralCapErc20.initializeAccountCollateralTokens (CCollateralCapErc20.sol#2829-2848):\n\tExternal calls:\n\t- ComptrollerInterfaceExtension(address(comptroller)).checkMembership(account,CToken(this)) (CCollateralCapErc20.sol#2838-2844)\n\tState variables written after the call(s):\n\t- accountCollateralTokens (CCollateralCapErc20.sol#2839-2840)\n\t- totalCollateralTokens (CCollateralCapErc20.sol#2840-2842)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 1875,
          "vulnerability_to_line": 1936,
          "vulnerability_code": "    function repayBorrowFresh(address payer, address borrower, uint repayAmount) internal returns (uint, uint) {\n\n        /* Fail if repayBorrow not allowed */\n\n        uint allowed = comptroller.repayBorrowAllowed(address(this), payer, borrower, repayAmount);\n\n        if (allowed != 0) {\n\n            return (failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REPAY_BORROW_COMPTROLLER_REJECTION, allowed), 0);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return (fail(Error.MARKET_NOT_FRESH, FailureInfo.REPAY_BORROW_FRESHNESS_CHECK), 0);\n\n        }\n\n\n\n        RepayBorrowLocalVars memory vars;\n\n\n\n        /* We remember the original borrowerIndex for verification purposes */\n\n        vars.borrowerIndex = accountBorrows[borrower].interestIndex;\n\n\n\n        /* We fetch the amount the borrower owes, with accumulated interest */\n\n        vars.accountBorrows = borrowBalanceStoredInternal(borrower);\n\n\n\n        /* If repayAmount == -1, repayAmount = accountBorrows */\n\n        if (repayAmount == uint(-1)) {\n\n            vars.repayAmount = vars.accountBorrows;\n\n        } else {\n\n            vars.repayAmount = repayAmount;\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We call doTransferIn for the payer and the repayAmount\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken holds an additional repayAmount of cash.\n\n         *  doTransferIn reverts if anything goes wrong, since we can't be sure if side effects occurred.\n\n         *   it returns the amount actually transferred, in case of a fee.\n\n         */\n\n        vars.actualRepayAmount = doTransferIn(payer, vars.repayAmount);\n\n\n\n        /*\n\n         * We calculate the new borrower and total borrow balances, failing on underflow:\n\n         *  accountBorrowsNew = accountBorrows - actualRepayAmount\n\n         *  totalBorrowsNew = totalBorrows - actualRepayAmount\n\n         */\n\n        vars.accountBorrowsNew = sub_(vars.accountBorrows, vars.actualRepayAmount);\n\n        vars.totalBorrowsNew = sub_(totalBorrows, vars.actualRepayAmount);\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n\n        accountBorrows[borrower].interestIndex = borrowIndex;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n\n\n        /* We emit a RepayBorrow event */\n\n        emit RepayBorrow(payer, borrower, vars.actualRepayAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n\n\n        /* We call the defense hook */\n\n        // unused function\n\n        // comptroller.repayBorrowVerify(address(this), payer, borrower, vars.actualRepayAmount, vars.borrowerIndex);\n\n\n\n        return (uint(Error.NO_ERROR), vars.actualRepayAmount);\n",
          "message": "Reentrancy in CToken.repayBorrowFresh (CCollateralCapErc20.sol#1875-1936):\n\tExternal calls:\n\t- allowed = comptroller.repayBorrowAllowed(address(this),payer,borrower,repayAmount) (CCollateralCapErc20.sol#1877)\n\tState variables written after the call(s):\n\t- accountBorrows (CCollateralCapErc20.sol#1924)\n\t- accountBorrows (CCollateralCapErc20.sol#1925)\n\t- totalBorrows (CCollateralCapErc20.sol#1926)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 2925,
          "vulnerability_to_line": 2990,
          "vulnerability_code": "    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (uint) {\n\n        // Make sure accountCollateralTokens of `src` and `dst` are initialized.\n\n        initializeAccountCollateralTokens(src);\n\n        initializeAccountCollateralTokens(dst);\n\n\n\n        /**\n\n         * For every user, accountTokens must be greater than or equal to accountCollateralTokens.\n\n         * The buffer between the two values will be transferred first.\n\n         * bufferTokens = accountTokens[src] - accountCollateralTokens[src]\n\n         * collateralTokens = tokens - bufferTokens\n\n         */\n\n        uint bufferTokens = sub_(accountTokens[src], accountCollateralTokens[src]);\n\n        uint collateralTokens = 0;\n\n        if (tokens > bufferTokens) {\n\n            collateralTokens = sub_(tokens, bufferTokens);\n\n        }\n\n\n\n        /**\n\n         * Since bufferTokens are not collateralized and can be transferred freely, we only check with comptroller\n\n         * whether collateralized tokens can be transferred.\n\n         */\n\n        uint allowed = comptroller.transferAllowed(address(this), src, dst, collateralTokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.TRANSFER_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Do not allow self-transfers */\n\n        if (src == dst) {\n\n            return fail(Error.BAD_INPUT, FailureInfo.TRANSFER_NOT_ALLOWED);\n\n        }\n\n\n\n        /* Get the allowance, infinite for the account owner */\n\n        uint startingAllowance = 0;\n\n        if (spender == src) {\n\n            startingAllowance = uint(-1);\n\n        } else {\n\n            startingAllowance = transferAllowances[src][spender];\n\n        }\n\n\n\n        /* Do the calculations, checking for {under,over}flow */\n\n        uint allowanceNew = sub_(startingAllowance, tokens);\n\n        accountTokens[src] = sub_(accountTokens[src], tokens);\n\n        accountTokens[dst] = add_(accountTokens[dst], tokens);\n\n        if (collateralTokens > 0) {\n\n            accountCollateralTokens[src] = sub_(accountCollateralTokens[src], collateralTokens);\n\n            accountCollateralTokens[dst] = add_(accountCollateralTokens[dst], collateralTokens);\n\n\n\n            emit UserCollateralChanged(src, accountCollateralTokens[src]);\n\n            emit UserCollateralChanged(dst, accountCollateralTokens[dst]);\n\n        }\n\n\n\n        /* Eat some of the allowance (if necessary) */\n\n        if (startingAllowance != uint(-1)) {\n\n            transferAllowances[src][spender] = allowanceNew;\n\n        }\n\n\n\n        /* We emit a Transfer event */\n\n        emit Transfer(src, dst, tokens);\n\n\n\n        // unused function\n\n        // comptroller.transferVerify(address(this), src, dst, tokens);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Reentrancy in CCollateralCapErc20.transferTokens (CCollateralCapErc20.sol#2925-2990):\n\tExternal calls:\n\t- initializeAccountCollateralTokens(src) (CCollateralCapErc20.sol#2927-2928)\n\t- initializeAccountCollateralTokens(dst) (CCollateralCapErc20.sol#2928-2930)\n\t- allowed = comptroller.transferAllowed(address(this),src,dst,collateralTokens) (CCollateralCapErc20.sol#2946-2947)\n\tState variables written after the call(s):\n\t- transferAllowances (CCollateralCapErc20.sol#2978-2979)\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 2857,
          "vulnerability_to_line": 2885,
          "vulnerability_code": "    function doTransferIn(address from, uint amount) internal returns (uint) {\n\n        EIP20NonStandardInterface token = EIP20NonStandardInterface(underlying);\n\n        uint balanceBefore = EIP20Interface(underlying).balanceOf(address(this));\n\n        token.transferFrom(from, address(this), amount);\n\n\n\n        bool success;\n\n        assembly {\n\n            switch returndatasize()\n\n                case 0 {                       // This is a non-standard ERC-20\n\n                    success := not(0)          // set success to true\n\n                }\n\n                case 32 {                      // This is a compliant ERC-20\n\n                    returndatacopy(0, 0, 32)\n\n                    success := mload(0)        // Set `success = returndata` of external call\n\n                }\n\n                default {                      // This is an excessively non-compliant ERC-20, revert.\n\n                    revert(0, 0)\n\n                }\n\n        }\n\n        require(success, \"TOKEN_TRANSFER_IN_FAILED\");\n\n\n\n        // Calculate the amount that was *actually* transferred\n\n        uint balanceAfter = EIP20Interface(underlying).balanceOf(address(this));\n\n        uint transferredIn = sub_(balanceAfter, balanceBefore);\n\n        internalCash = add_(internalCash, transferredIn);\n\n        return transferredIn;\n\n    }\n\n\n",
          "message": "CCollateralCapErc20.doTransferIn uses assembly (CCollateralCapErc20.sol#2857-2885)\n\t- CCollateralCapErc20.sol#2863-2876\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 2894,
          "vulnerability_to_line": 2916,
          "vulnerability_code": "    function doTransferOut(address payable to, uint amount) internal {\n\n        EIP20NonStandardInterface token = EIP20NonStandardInterface(underlying);\n\n        token.transfer(to, amount);\n\n\n\n        bool success;\n\n        assembly {\n\n            switch returndatasize()\n\n                case 0 {                      // This is a non-standard ERC-20\n\n                    success := not(0)          // set success to true\n\n                }\n\n                case 32 {                     // This is a complaint ERC-20\n\n                    returndatacopy(0, 0, 32)\n\n                    success := mload(0)        // Set `success = returndata` of external call\n\n                }\n\n                default {                     // This is an excessively non-compliant ERC-20, revert.\n\n                    revert(0, 0)\n\n                }\n\n        }\n\n        require(success, \"TOKEN_TRANSFER_OUT_FAILED\");\n\n        internalCash = sub_(internalCash, amount);\n\n    }\n\n\n",
          "message": "CCollateralCapErc20.doTransferOut uses assembly (CCollateralCapErc20.sol#2894-2916)\n\t- CCollateralCapErc20.sol#2899-2912\n"
        },
        {
          "name": "constable-states",
          "vulnerability_from_line": 235,
          "vulnerability_to_line": null,
          "vulnerability_code": "    address public implementation;\n",
          "message": "CErc20Storage.implementation should be constant (CCollateralCapErc20.sol#235)\nComptrollerV1Storage.closeFactorMantissa should be constant (CCollateralCapErc20.sol#2470-2472)\nComptrollerV1Storage.liquidationIncentiveMantissa should be constant (CCollateralCapErc20.sol#2475-2477)\nComptrollerV1Storage.maxAssets should be constant (CCollateralCapErc20.sol#2480-2482)\nComptrollerV2Storage._borrowGuardianPaused should be constant (CCollateralCapErc20.sol#2530-2531)\nComptrollerV2Storage._mintGuardianPaused should be constant (CCollateralCapErc20.sol#2529-2530)\nComptrollerV2Storage.pauseGuardian should be constant (CCollateralCapErc20.sol#2528-2529)\nComptrollerV2Storage.seizeGuardianPaused should be constant (CCollateralCapErc20.sol#2532-2533)\nComptrollerV2Storage.transferGuardianPaused should be constant (CCollateralCapErc20.sol#2531-2532)\nComptrollerV3Storage.compRate should be constant (CCollateralCapErc20.sol#2550-2552)\nComptrollerV4Storage.borrowCapGuardian should be constant (CCollateralCapErc20.sol#2573-2575)\nComptrollerV5Storage.supplyCapGuardian should be constant (CCollateralCapErc20.sol#2581-2583)\nUnitrollerAdminStorage.admin should be constant (CCollateralCapErc20.sol#2442-2444)\nUnitrollerAdminStorage.comptrollerImplementation should be constant (CCollateralCapErc20.sol#2452-2454)\nUnitrollerAdminStorage.pendingAdmin should be constant (CCollateralCapErc20.sol#2447-2449)\nUnitrollerAdminStorage.pendingComptrollerImplementation should be constant (CCollateralCapErc20.sol#2457-2460)\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 2305,
          "vulnerability_to_line": 2315,
          "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n\n        return _setInterestRateModelFresh(newInterestRateModel);\n\n    }\n\n\n",
          "message": "CToken._setInterestRateModel (CCollateralCapErc20.sol#2305-2315) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 391,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint);\n",
          "message": "CTokenInterface._setInterestRateModel (CCollateralCapErc20.sol#391) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 466,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setImplementation(address implementation_, bool allowResign, bytes memory becomeImplementationData) public;\n",
          "message": "CDelegatorInterface._setImplementation (CCollateralCapErc20.sol#466) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 475,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _becomeImplementation(bytes memory data) public;\n",
          "message": "CDelegateInterface._becomeImplementation (CCollateralCapErc20.sol#475) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 480,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _resignImplementation() public;\n",
          "message": "CDelegateInterface._resignImplementation (CCollateralCapErc20.sol#480) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 2617,
          "vulnerability_to_line": 2632,
          "vulnerability_code": "    function initialize(address underlying_,\n\n                        ComptrollerInterface comptroller_,\n\n                        InterestRateModel interestRateModel_,\n\n                        uint initialExchangeRateMantissa_,\n\n                        string memory name_,\n\n                        string memory symbol_,\n\n                        uint8 decimals_) public {\n\n        // CToken initialize does the bulk of the work\n\n        super.initialize(comptroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_);\n\n\n\n        // Set underlying and sanity check it\n\n        underlying = underlying_;\n\n        EIP20Interface(underlying).totalSupply();\n\n    }\n\n\n",
          "message": "CCollateralCapErc20.initialize (CCollateralCapErc20.sol#2617-2632) should be declared external\n"
        },
        {
          "name": "solc-version",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": "Detected issues with version pragma in CCollateralCapErc20.sol:\n\t- pragma solidity^0.5.16 (CCollateralCapErc20.sol#3): it allows old versions\n\t- pragma solidity^0.5.16 (CCollateralCapErc20.sol#77): it allows old versions\n\t- pragma solidity^0.5.16 (CCollateralCapErc20.sol#110): it allows old versions\n\t- pragma solidity^0.5.16 (CCollateralCapErc20.sol#494): it allows old versions\n\t- pragma solidity^0.5.16 (CCollateralCapErc20.sol#680): it allows old versions\n\t- pragma solidity^0.5.16 (CCollateralCapErc20.sol#768): it allows old versions\n\t- pragma solidity^0.5.16 (CCollateralCapErc20.sol#1199): it allows old versions\n\t- pragma solidity^0.5.16 (CCollateralCapErc20.sol#1264): it allows old versions\n\t- pragma solidity^0.5.16 (CCollateralCapErc20.sol#1337): it allows old versions\n\t- pragma solidity^0.5.16 (CCollateralCapErc20.sol#2418-2420): it allows old versions\n\t- pragma solidity^0.5.16 (CCollateralCapErc20.sol#2435-2438): it allows old versions\n\t- pragma solidity^0.5.16 (CCollateralCapErc20.sol#2589-2592): it allows old versions\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 7,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bool public constant isComptroller = true;\n",
          "message": "Constant 'ComptrollerInterface.isComptroller' (CCollateralCapErc20.sol#7) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 85,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bool public constant isInterestRateModel = true;\n",
          "message": "Constant 'InterestRateModel.isInterestRateModel' (CCollateralCapErc20.sol#85) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 117,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bool internal _notEntered;\n",
          "message": "Variable 'CTokenStorage._notEntered' (CCollateralCapErc20.sol#117) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 138,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint internal constant borrowRateMaxMantissa = 0.0005e16;\n",
          "message": "Constant 'CTokenStorage.borrowRateMaxMantissa' (CCollateralCapErc20.sol#138) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 143,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint internal constant reserveFactorMaxMantissa = 1e18;\n",
          "message": "Constant 'CTokenStorage.reserveFactorMaxMantissa' (CCollateralCapErc20.sol#143) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 386,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint);\n",
          "message": "Function 'CTokenInterface._setPendingAdmin' (CCollateralCapErc20.sol#386) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 387,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _acceptAdmin() external returns (uint);\n",
          "message": "Function 'CTokenInterface._acceptAdmin' (CCollateralCapErc20.sol#387) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 388,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setComptroller(ComptrollerInterface newComptroller) public returns (uint);\n",
          "message": "Function 'CTokenInterface._setComptroller' (CCollateralCapErc20.sol#388) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 389,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setReserveFactor(uint newReserveFactorMantissa) external returns (uint);\n",
          "message": "Function 'CTokenInterface._setReserveFactor' (CCollateralCapErc20.sol#389) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 390,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _reduceReserves(uint reduceAmount) external returns (uint);\n",
          "message": "Function 'CTokenInterface._reduceReserves' (CCollateralCapErc20.sol#390) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 391,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint);\n",
          "message": "Function 'CTokenInterface._setInterestRateModel' (CCollateralCapErc20.sol#391) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 274,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bool public constant isCToken = true;\n",
          "message": "Constant 'CTokenInterface.isCToken' (CCollateralCapErc20.sol#274) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 408,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _addReserves(uint addAmount) external returns (uint);\n",
          "message": "Function 'CErc20Interface._addReserves' (CCollateralCapErc20.sol#408) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 415,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint public constant flashFeeBips = 3;\n",
          "message": "Constant 'CCapableErc20Interface.flashFeeBips' (CCollateralCapErc20.sol#415) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 451,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setCollateralCap(uint newCollateralCap) external;\n",
          "message": "Function 'CCollateralCapErc20Interface._setCollateralCap' (CCollateralCapErc20.sol#451) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 466,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setImplementation(address implementation_, bool allowResign, bytes memory becomeImplementationData) public;\n",
          "message": "Function 'CDelegatorInterface._setImplementation' (CCollateralCapErc20.sol#466) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 475,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _becomeImplementation(bytes memory data) public;\n",
          "message": "Function 'CDelegateInterface._becomeImplementation' (CCollateralCapErc20.sol#475) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 480,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _resignImplementation() public;\n",
          "message": "Function 'CDelegateInterface._resignImplementation' (CCollateralCapErc20.sol#480) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 867,
          "vulnerability_to_line": 870,
          "vulnerability_code": "    function mul_ScalarTruncate(Exp memory a, uint scalar) pure internal returns (uint) {\n\n        Exp memory product = mul_(a, scalar);\n\n        return truncate(product);\n",
          "message": "Function 'Exponential.mul_ScalarTruncate' (CCollateralCapErc20.sol#867-870) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 875,
          "vulnerability_to_line": 878,
          "vulnerability_code": "    function mul_ScalarTruncateAddUInt(Exp memory a, uint scalar, uint addend) pure internal returns (uint) {\n\n        Exp memory product = mul_(a, scalar);\n\n        return add_(truncate(product), addend);\n",
          "message": "Function 'Exponential.mul_ScalarTruncateAddUInt' (CCollateralCapErc20.sol#875-878) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 927,
          "vulnerability_to_line": 939,
          "vulnerability_code": "    function div_ScalarByExp(uint scalar, Exp memory divisor) pure internal returns (Exp memory) {\n\n        /*\n\n          We are doing this as:\n\n          getExp(mulUInt(expScale, scalar), divisor.mantissa)\n\n\n\n          How it works:\n\n          Exp = a / b;\n\n          Scalar = s;\n\n          `s / (a / b)` = `b * s / a` and since for an Exp `a = mantissa, b = expScale`\n\n        */\n\n        uint numerator = mul_(expScale, scalar);\n\n        return Exp({mantissa: div_(numerator, divisor)});\n",
          "message": "Function 'Exponential.div_ScalarByExp' (CCollateralCapErc20.sol#927-939) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 944,
          "vulnerability_to_line": 947,
          "vulnerability_code": "    function div_ScalarByExpTruncate(uint scalar, Exp memory divisor) pure internal returns (uint) {\n\n        Exp memory fraction = div_ScalarByExp(scalar, divisor);\n\n        return truncate(fraction);\n",
          "message": "Function 'Exponential.div_ScalarByExpTruncate' (CCollateralCapErc20.sol#944-947) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 778,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint constant expScale = 1e18;\n",
          "message": "Constant 'Exponential.expScale' (CCollateralCapErc20.sol#778) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 779,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint constant doubleScale = 1e36;\n",
          "message": "Constant 'Exponential.doubleScale' (CCollateralCapErc20.sol#779) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 780,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint constant halfExpScale = expScale/2;\n",
          "message": "Constant 'Exponential.halfExpScale' (CCollateralCapErc20.sol#780) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 781,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint constant mantissaOne = expScale;\n",
          "message": "Constant 'Exponential.mantissaOne' (CCollateralCapErc20.sol#781) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 2064,
          "vulnerability_to_line": 2080,
          "vulnerability_code": "    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint) {\n\n        // Check caller = admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);\n\n        }\n\n\n\n        // Save current value, if any, for inclusion in log\n\n        address oldPendingAdmin = pendingAdmin;\n\n\n\n        // Store pendingAdmin with value newPendingAdmin\n\n        pendingAdmin = newPendingAdmin;\n\n\n\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\n\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n\n\n\n        return uint(Error.NO_ERROR);\n",
          "message": "Function 'CToken._setPendingAdmin' (CCollateralCapErc20.sol#2064-2080) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 2087,
          "vulnerability_to_line": 2109,
          "vulnerability_code": "    function _acceptAdmin() external returns (uint) {\n\n        // Check caller is pendingAdmin and pendingAdmin \u2260 address(0)\n\n        if (msg.sender != pendingAdmin || msg.sender == address(0)) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);\n\n        }\n\n\n\n        // Save current values for inclusion in log\n\n        address oldAdmin = admin;\n\n        address oldPendingAdmin = pendingAdmin;\n\n\n\n        // Store admin with value pendingAdmin\n\n        admin = pendingAdmin;\n\n\n\n        // Clear the pending value\n\n        pendingAdmin = address(0);\n\n\n\n        emit NewAdmin(oldAdmin, admin);\n\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Function 'CToken._acceptAdmin' (CCollateralCapErc20.sol#2087-2109) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 2114,
          "vulnerability_to_line": 2133,
          "vulnerability_code": "    function _setComptroller(ComptrollerInterface newComptroller) public returns (uint) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COMPTROLLER_OWNER_CHECK);\n\n        }\n\n\n\n        ComptrollerInterface oldComptroller = comptroller;\n\n        // Ensure invoke comptroller.isComptroller() returns true\n\n        require(newComptroller.isComptroller(), \"marker method returned false\");\n\n\n\n        // Set market's comptroller to newComptroller\n\n        comptroller = newComptroller;\n\n\n\n        // Emit NewComptroller(oldComptroller, newComptroller)\n\n        emit NewComptroller(oldComptroller, newComptroller);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Function 'CToken._setComptroller' (CCollateralCapErc20.sol#2114-2133) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 2138,
          "vulnerability_to_line": 2148,
          "vulnerability_code": "    function _setReserveFactor(uint newReserveFactorMantissa) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.\n\n            return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.\n\n        return _setReserveFactorFresh(newReserveFactorMantissa);\n\n    }\n\n\n",
          "message": "Function 'CToken._setReserveFactor' (CCollateralCapErc20.sol#2138-2148) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 2242,
          "vulnerability_to_line": 2252,
          "vulnerability_code": "    function _reduceReserves(uint reduceAmount) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n\n            return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.\n\n        return _reduceReservesFresh(reduceAmount);\n\n    }\n\n\n",
          "message": "Function 'CToken._reduceReserves' (CCollateralCapErc20.sol#2242-2252) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 2305,
          "vulnerability_to_line": 2315,
          "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n\n        return _setInterestRateModelFresh(newInterestRateModel);\n\n    }\n\n\n",
          "message": "Function 'CToken._setInterestRateModel' (CCollateralCapErc20.sol#2305-2315) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 2153,
          "vulnerability_to_line": 2177,
          "vulnerability_code": "    function _setReserveFactorFresh(uint newReserveFactorMantissa) internal returns (uint) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_RESERVE_FACTOR_ADMIN_CHECK);\n\n        }\n\n\n\n        // Verify market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_RESERVE_FACTOR_FRESH_CHECK);\n\n        }\n\n\n\n        // Check newReserveFactor \u2264 maxReserveFactor\n\n        if (newReserveFactorMantissa > reserveFactorMaxMantissa) {\n\n            return fail(Error.BAD_INPUT, FailureInfo.SET_RESERVE_FACTOR_BOUNDS_CHECK);\n\n        }\n\n\n\n        uint oldReserveFactorMantissa = reserveFactorMantissa;\n\n        reserveFactorMantissa = newReserveFactorMantissa;\n\n\n\n        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Function 'CToken._setReserveFactorFresh' (CCollateralCapErc20.sol#2153-2177) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 2182,
          "vulnerability_to_line": 2194,
          "vulnerability_code": "    function _addReservesInternal(uint addAmount) internal nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n\n            return fail(Error(error), FailureInfo.ADD_RESERVES_ACCRUE_INTEREST_FAILED);\n\n        }\n\n\n\n        // _addReservesFresh emits reserve-addition-specific logs on errors, so we don't need to.\n\n        (error, ) = _addReservesFresh(addAmount);\n\n        return error;\n\n    }\n\n\n",
          "message": "Function 'CToken._addReservesInternal' (CCollateralCapErc20.sol#2182-2194) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 2200,
          "vulnerability_to_line": 2237,
          "vulnerability_code": "    function _addReservesFresh(uint addAmount) internal returns (uint, uint) {\n\n        // totalReserves + actualAddAmount\n\n        uint totalReservesNew;\n\n        uint actualAddAmount;\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return (fail(Error.MARKET_NOT_FRESH, FailureInfo.ADD_RESERVES_FRESH_CHECK), actualAddAmount);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We call doTransferIn for the caller and the addAmount\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken holds an additional addAmount of cash.\n\n         *  doTransferIn reverts if anything goes wrong, since we can't be sure if side effects occurred.\n\n         *  it returns the amount actually transferred, in case of a fee.\n\n         */\n\n\n\n        actualAddAmount = doTransferIn(msg.sender, addAmount);\n\n\n\n        totalReservesNew = add_(totalReserves, actualAddAmount);\n\n\n\n        // Store reserves[n+1] = reserves[n] + actualAddAmount\n\n        totalReserves = totalReservesNew;\n\n\n\n        /* Emit NewReserves(admin, actualAddAmount, reserves[n+1]) */\n\n        emit ReservesAdded(msg.sender, actualAddAmount, totalReservesNew);\n\n\n\n        /* Return (NO_ERROR, actualAddAmount) */\n\n        return (uint(Error.NO_ERROR), actualAddAmount);\n\n    }\n\n\n\n\n",
          "message": "Function 'CToken._addReservesFresh' (CCollateralCapErc20.sol#2200-2237) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 2258,
          "vulnerability_to_line": 2299,
          "vulnerability_code": "    function _reduceReservesFresh(uint reduceAmount) internal returns (uint) {\n\n        // totalReserves - reduceAmount\n\n        uint totalReservesNew;\n\n\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.REDUCE_RESERVES_ADMIN_CHECK);\n\n        }\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDUCE_RESERVES_FRESH_CHECK);\n\n        }\n\n\n\n        // Fail gracefully if protocol has insufficient underlying cash\n\n        if (getCashPrior() < reduceAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDUCE_RESERVES_CASH_NOT_AVAILABLE);\n\n        }\n\n\n\n        // Check reduceAmount \u2264 reserves[n] (totalReserves)\n\n        if (reduceAmount > totalReserves) {\n\n            return fail(Error.BAD_INPUT, FailureInfo.REDUCE_RESERVES_VALIDATION);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        totalReservesNew = sub_(totalReserves, reduceAmount);\n\n\n\n        // Store reserves[n+1] = reserves[n] - reduceAmount\n\n        totalReserves = totalReservesNew;\n\n\n\n        // doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n\n        doTransferOut(admin, reduceAmount);\n\n\n\n        emit ReservesReduced(admin, reduceAmount, totalReservesNew);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Function 'CToken._reduceReservesFresh' (CCollateralCapErc20.sol#2258-2299) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 2321,
          "vulnerability_to_line": 2351,
          "vulnerability_code": "    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {\n\n\n\n        // Used to store old model for use in the event that is emitted on success\n\n        InterestRateModel oldInterestRateModel;\n\n\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);\n\n        }\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);\n\n        }\n\n\n\n        // Track the market's current interest rate model\n\n        oldInterestRateModel = interestRateModel;\n\n\n\n        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true\n\n        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n\n\n\n        // Set the interest rate model to newInterestRateModel\n\n        interestRateModel = newInterestRateModel;\n\n\n\n        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)\n\n        emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Function 'CToken._setInterestRateModelFresh' (CCollateralCapErc20.sol#2321-2351) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 2422,
          "vulnerability_to_line": 2424,
          "vulnerability_code": "    bool public constant isPriceOracle = true;\n\n\n",
          "message": "Constant 'PriceOracle.isPriceOracle' (CCollateralCapErc20.sol#2422-2424) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 2529,
          "vulnerability_to_line": 2530,
          "vulnerability_code": "    bool public _mintGuardianPaused;\n",
          "message": "Variable 'ComptrollerV2Storage._mintGuardianPaused' (CCollateralCapErc20.sol#2529-2530) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 2530,
          "vulnerability_to_line": 2531,
          "vulnerability_code": "    bool public _borrowGuardianPaused;\n",
          "message": "Variable 'ComptrollerV2Storage._borrowGuardianPaused' (CCollateralCapErc20.sol#2530-2531) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 2713,
          "vulnerability_to_line": 2717,
          "vulnerability_code": "    function _addReserves(uint addAmount) external returns (uint) {\n\n        return _addReservesInternal(addAmount);\n\n    }\n\n\n",
          "message": "Function 'CCollateralCapErc20._addReserves' (CCollateralCapErc20.sol#2713-2717) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 2721,
          "vulnerability_to_line": 2728,
          "vulnerability_code": "    function _setCollateralCap(uint newCollateralCap) external {\n\n        require(msg.sender == admin, \"only admin can set collateral cap\");\n\n\n\n        collateralCap = newCollateralCap;\n\n        emit NewCollateralCap(address(this), newCollateralCap);\n\n    }\n\n\n",
          "message": "Function 'CCollateralCapErc20._setCollateralCap' (CCollateralCapErc20.sol#2721-2728) is not in mixedCase\n"
        }
      ]
    },
    "smartcheck": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 1157,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (xx >= 0x100000000000000000000000000000000) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 1161,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (xx >= 0x10000000000000000) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 1165,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (xx >= 0x100000000) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 1169,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (xx >= 0x10000) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 1173,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (xx >= 0x100) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 1177,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (xx >= 0x10) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 1181,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (xx >= 0x8) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ERC20_APPROVE",
          "vulnerability_from_line": 1422,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function approve(address spender, uint256 amount) external returns (bool) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_LOCKED_MONEY",
          "vulnerability_from_line": 270,
          "vulnerability_to_line": null,
          "vulnerability_code": "contract CTokenInterface is CTokenStorage {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 77,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 110,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 494,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 680,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 768,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 1199,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 1264,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 1337,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 2418,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 2435,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 2589,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 72,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint repayAmount) external view returns (uint, uint);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 371,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 703,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function mulUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 720,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function divUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 731,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function subUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 742,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function addUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 755,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function addThenSubUInt(uint a, uint b, uint c) internal pure returns (MathError, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 796,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getExp(uint num, uint denom) pure internal returns (MathError, Exp memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 813,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function addExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 822,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function subExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 831,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function mulScalar(Exp memory a, uint scalar) pure internal returns (MathError, Exp memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 843,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function mulScalarTruncate(Exp memory a, uint scalar) pure internal returns (MathError, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 855,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function mulScalarTruncateAddUInt(Exp memory a, uint scalar, uint addend) pure internal returns (MathError, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 883,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function divScalar(Exp memory a, uint scalar) pure internal returns (MathError, Exp memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 895,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function divScalarByExp(uint scalar, Exp memory divisor) pure internal returns (MathError, Exp memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 915,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function divScalarByExpTruncate(uint scalar, Exp memory divisor) pure internal returns (MathError, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 952,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function mulExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 977,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function mulExp(uint a, uint b) pure internal returns (MathError, Exp memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 984,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function mulExp3(Exp memory a, Exp memory b, Exp memory c) pure internal returns (MathError, Exp memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 997,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function divExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 1465,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 1702,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function mintInternal(uint mintAmount) internal nonReentrant returns (uint, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 2863,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 386,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1771,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function borrowFresh(address payable borrower, uint borrowAmount) internal returns (uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 2894,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function doTransferOut(address payable to, uint amount) internal {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 386,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 778,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint constant expScale = 1e18;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 779,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint constant doubleScale = 1e36;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 780,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint constant halfExpScale = expScale/2;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 781,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint constant mantissaOne = expScale;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1771,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function borrowFresh(address payable borrower, uint borrowAmount) internal returns (uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1771,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function borrowFresh(address payable borrower, uint borrowAmount) internal returns (uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1771,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function borrowFresh(address payable borrower, uint borrowAmount) internal returns (uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1773,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint allowed = comptroller.borrowAllowed(address(this), borrower, borrowAmount);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1774,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (allowed != 0) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1775,
          "vulnerability_to_line": null,
          "vulnerability_code": "            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.BORROW_COMPTROLLER_REJECTION, allowed);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1775,
          "vulnerability_to_line": null,
          "vulnerability_code": "            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.BORROW_COMPTROLLER_REJECTION, allowed);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 2894,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function doTransferOut(address payable to, uint amount) internal {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 2894,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function doTransferOut(address payable to, uint amount) internal {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 2895,
          "vulnerability_to_line": null,
          "vulnerability_code": "        EIP20NonStandardInterface token = EIP20NonStandardInterface(underlying);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 2896,
          "vulnerability_to_line": null,
          "vulnerability_code": "        token.transfer(to, amount);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 2896,
          "vulnerability_to_line": null,
          "vulnerability_code": "        token.transfer(to, amount);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 2898,
          "vulnerability_to_line": null,
          "vulnerability_code": "        bool success;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 2900,
          "vulnerability_to_line": null,
          "vulnerability_code": "            switch returndatasize()\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 2900,
          "vulnerability_to_line": null,
          "vulnerability_code": "            switch returndatasize()\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 2902,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    success := not(0)          // set success to true\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 2902,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    success := not(0)          // set success to true\n",
          "message": null
        }
      ]
    },
    "oyente": {
      "successfull_analysis": false,
      "errors": [
        "exception (RuntimeError: Source map error, unknown name(SHR) or instr_name(INVALID))"
      ],
      "vulnerability_findings": []
    },
    "mythril": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "Exception State (SWC 110)",
          "vulnerability_from_line": 2485,
          "vulnerability_to_line": null,
          "vulnerability_code": "    mapping(address => CToken[]) public accountAssets;\n",
          "message": "An assertion violation was triggered.\nIt is possible to trigger an assertion violation. Note that Solidity assert() statements should only be used to check invariants. Review the transaction trace generated for this issue and either make sure your program logic is correct, or use require() instead of assert() if your goal is to constrain user inputs or enforce preconditions. Remember to validate inputs from both callers (for instance, via passed arguments) and callees (for instance, via return values).\nClassification: SWC-110"
        },
        {
          "name": "Exception State (SWC 110)",
          "vulnerability_from_line": 2485,
          "vulnerability_to_line": null,
          "vulnerability_code": "    mapping(address => CToken[]) public accountAssets;\n",
          "message": "An assertion violation was triggered.\nIt is possible to trigger an assertion violation. Note that Solidity assert() statements should only be used to check invariants. Review the transaction trace generated for this issue and either make sure your program logic is correct, or use require() instead of assert() if your goal is to constrain user inputs or enforce preconditions. Remember to validate inputs from both callers (for instance, via passed arguments) and callees (for instance, via return values).\nClassification: SWC-110"
        },
        {
          "name": "Exception State (SWC 110)",
          "vulnerability_from_line": 2547,
          "vulnerability_to_line": null,
          "vulnerability_code": "    CToken[] public allMarkets;\n",
          "message": "An assertion violation was triggered.\nIt is possible to trigger an assertion violation. Note that Solidity assert() statements should only be used to check invariants. Review the transaction trace generated for this issue and either make sure your program logic is correct, or use require() instead of assert() if your goal is to constrain user inputs or enforce preconditions. Remember to validate inputs from both callers (for instance, via passed arguments) and callees (for instance, via return values).\nClassification: SWC-110"
        },
        {
          "name": "Exception State (SWC 110)",
          "vulnerability_from_line": 2547,
          "vulnerability_to_line": null,
          "vulnerability_code": "    CToken[] public allMarkets;\n",
          "message": "An assertion violation was triggered.\nIt is possible to trigger an assertion violation. Note that Solidity assert() statements should only be used to check invariants. Review the transaction trace generated for this issue and either make sure your program logic is correct, or use require() instead of assert() if your goal is to constrain user inputs or enforce preconditions. Remember to validate inputs from both callers (for instance, via passed arguments) and callees (for instance, via return values).\nClassification: SWC-110"
        },
        {
          "name": "Exception State (SWC 110)",
          "vulnerability_from_line": 2547,
          "vulnerability_to_line": null,
          "vulnerability_code": "    CToken[] public allMarkets;\n",
          "message": "An assertion violation was triggered.\nIt is possible to trigger an assertion violation. Note that Solidity assert() statements should only be used to check invariants. Review the transaction trace generated for this issue and either make sure your program logic is correct, or use require() instead of assert() if your goal is to constrain user inputs or enforce preconditions. Remember to validate inputs from both callers (for instance, via passed arguments) and callees (for instance, via return values).\nClassification: SWC-110"
        },
        {
          "name": "Exception State (SWC 110)",
          "vulnerability_from_line": 2485,
          "vulnerability_to_line": null,
          "vulnerability_code": "    mapping(address => CToken[]) public accountAssets;\n",
          "message": "An assertion violation was triggered.\nIt is possible to trigger an assertion violation. Note that Solidity assert() statements should only be used to check invariants. Review the transaction trace generated for this issue and either make sure your program logic is correct, or use require() instead of assert() if your goal is to constrain user inputs or enforce preconditions. Remember to validate inputs from both callers (for instance, via passed arguments) and callees (for instance, via return values).\nClassification: SWC-110"
        },
        {
          "name": "Exception State (SWC 110)",
          "vulnerability_from_line": 2485,
          "vulnerability_to_line": null,
          "vulnerability_code": "    mapping(address => CToken[]) public accountAssets;\n",
          "message": "An assertion violation was triggered.\nIt is possible to trigger an assertion violation. Note that Solidity assert() statements should only be used to check invariants. Review the transaction trace generated for this issue and either make sure your program logic is correct, or use require() instead of assert() if your goal is to constrain user inputs or enforce preconditions. Remember to validate inputs from both callers (for instance, via passed arguments) and callees (for instance, via return values).\nClassification: SWC-110"
        },
        {
          "name": "Exception State (SWC 110)",
          "vulnerability_from_line": 2485,
          "vulnerability_to_line": null,
          "vulnerability_code": "    mapping(address => CToken[]) public accountAssets;\n",
          "message": "An assertion violation was triggered.\nIt is possible to trigger an assertion violation. Note that Solidity assert() statements should only be used to check invariants. Review the transaction trace generated for this issue and either make sure your program logic is correct, or use require() instead of assert() if your goal is to constrain user inputs or enforce preconditions. Remember to validate inputs from both callers (for instance, via passed arguments) and callees (for instance, via return values).\nClassification: SWC-110"
        },
        {
          "name": "Dependence on predictable environment variable (SWC 120)",
          "vulnerability_from_line": 1648,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (accrualBlockNumberPrior == currentBlockNumber) {\n",
          "message": "A control flow decision is made based on The block.number environment variable.\nThe block.number environment variable is used to determine a control flow decision. Note that the values of variables like coinbase, gaslimit, block number and timestamp are predictable and can be manipulated by a malicious miner. Also keep in mind that attackers know hashes of earlier blocks. Don't use any of those environment variables as sources of randomness and be aware that use of these variables introduces a certain level of trust into miners.\nClassification: SWC-120"
        },
        {
          "name": "Dependence on predictable environment variable (SWC 120)",
          "vulnerability_from_line": 1072,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(b <= a, errorMessage);\n",
          "message": "A control flow decision is made based on The block.number environment variable.\nThe block.number environment variable is used to determine a control flow decision. Note that the values of variables like coinbase, gaslimit, block number and timestamp are predictable and can be manipulated by a malicious miner. Also keep in mind that attackers know hashes of earlier blocks. Don't use any of those environment variables as sources of randomness and be aware that use of these variables introduces a certain level of trust into miners.\nClassification: SWC-120"
        },
        {
          "name": "Dependence on predictable environment variable (SWC 120)",
          "vulnerability_from_line": 1105,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (a == 0 || b == 0) {\n",
          "message": "A control flow decision is made based on The block.number environment variable.\nThe block.number environment variable is used to determine a control flow decision. Note that the values of variables like coinbase, gaslimit, block number and timestamp are predictable and can be manipulated by a malicious miner. Also keep in mind that attackers know hashes of earlier blocks. Don't use any of those environment variables as sources of randomness and be aware that use of these variables introduces a certain level of trust into miners.\nClassification: SWC-120"
        },
        {
          "name": "Dependence on predictable environment variable (SWC 120)",
          "vulnerability_from_line": 1109,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(c / a == b, errorMessage);\n",
          "message": "A control flow decision is made based on The block.number environment variable.\nThe block.number environment variable is used to determine a control flow decision. Note that the values of variables like coinbase, gaslimit, block number and timestamp are predictable and can be manipulated by a malicious miner. Also keep in mind that attackers know hashes of earlier blocks. Don't use any of those environment variables as sources of randomness and be aware that use of these variables introduces a certain level of trust into miners.\nClassification: SWC-120"
        }
      ]
    },
    "osiris": {
      "successfull_analysis": false,
      "errors": [
        "Solidity compilation failed"
      ],
      "vulnerability_findings": []
    }
  }
}