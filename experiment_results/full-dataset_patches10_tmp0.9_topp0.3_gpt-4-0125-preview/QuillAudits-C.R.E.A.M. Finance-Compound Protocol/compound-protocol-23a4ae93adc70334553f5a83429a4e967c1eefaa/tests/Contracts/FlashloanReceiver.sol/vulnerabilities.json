{
  "smartbugs_completed": true,
  "analyzer_results": {
    "semgrep": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 228,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor(uint256 _initialAmount, string memory _tokenName, uint8 _decimalUnits, string memory _tokenSymbol) public {\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 229,
          "vulnerability_to_line": null,
          "vulnerability_code": "        totalSupply = _initialAmount;\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 230,
          "vulnerability_to_line": null,
          "vulnerability_code": "        balanceOf[msg.sender] = _initialAmount;\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 231,
          "vulnerability_to_line": null,
          "vulnerability_code": "        name = _tokenName;\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 232,
          "vulnerability_to_line": null,
          "vulnerability_code": "        symbol = _tokenSymbol;\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 233,
          "vulnerability_to_line": null,
          "vulnerability_code": "        decimals = _decimalUnits;\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 234,
          "vulnerability_to_line": null,
          "vulnerability_code": "    }\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 273,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor(uint256 _initialAmount, string memory _tokenName, uint8 _decimalUnits, string memory _tokenSymbol) public {\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 274,
          "vulnerability_to_line": null,
          "vulnerability_code": "        totalSupply = _initialAmount;\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 275,
          "vulnerability_to_line": null,
          "vulnerability_code": "        balanceOf[msg.sender] = _initialAmount;\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 276,
          "vulnerability_to_line": null,
          "vulnerability_code": "        name = _tokenName;\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 277,
          "vulnerability_to_line": null,
          "vulnerability_code": "        symbol = _tokenSymbol;\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 278,
          "vulnerability_to_line": null,
          "vulnerability_code": "        decimals = _decimalUnits;\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 279,
          "vulnerability_to_line": null,
          "vulnerability_code": "    }\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 308,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor(uint256 _initialAmount, string memory _tokenName, uint8 _decimalUnits, string memory _tokenSymbol) public\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 309,
          "vulnerability_to_line": null,
          "vulnerability_code": "        StandardToken(_initialAmount, _tokenName, _decimalUnits, _tokenSymbol) {}\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 352,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor(uint256 _initialAmount, string memory _tokenName, uint8 _decimalUnits, string memory _tokenSymbol, address _comptroller) public\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 353,
          "vulnerability_to_line": null,
          "vulnerability_code": "        ERC20Harness(_initialAmount, _tokenName, _decimalUnits, _tokenSymbol) {\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 354,
          "vulnerability_to_line": null,
          "vulnerability_code": "        comptroller = _comptroller;\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 355,
          "vulnerability_to_line": null,
          "vulnerability_code": "    }\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 32,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(c >= a, \"SafeMath: addition overflow\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 96,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(c / a == b, \"SafeMath: multiplication overflow\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1723,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == admin, \"only admin may initialize the market\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1724,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(accrualBlockNumber == 0 && borrowIndex == 0, \"market may only be initialized once\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1728,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(initialExchangeRateMantissa > 0, \"initial exchange rate must be greater than zero.\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1732,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(err == uint(Error.NO_ERROR), \"setting comptroller failed\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1740,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(err == uint(Error.NO_ERROR), \"setting interest rate model failed\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1896,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1906,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1948,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 2017,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 2374,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(amountSeizeError == uint(Error.NO_ERROR), \"LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 2377,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(cTokenCollateral.balanceOf(borrower) >= seizeTokens, \"LIQUIDATE_SEIZE_TOO_MUCH\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 2388,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(seizeError == uint(Error.NO_ERROR), \"token seizure failed\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 2479,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(newComptroller.isComptroller(), \"marker method returned false\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 2697,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 2766,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_notEntered, \"re-entered\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 3079,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == admin, \"only admin can set collateral cap\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 3106,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(cashBefore >= amount, \"INSUFFICIENT_LIQUIDITY\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 3119,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(cashOnChainAfter == add_(cashOnChainBefore, totalFee), \"BALANCE_INCONSISTENT\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 3139,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == address(comptroller), \"only comptroller may register collateral for user\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 3154,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == address(comptroller), \"only comptroller may unregister collateral for user\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 3233,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(success, \"TOKEN_TRANSFER_IN_FAILED\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 3269,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(success, \"TOKEN_TRANSFER_OUT_FAILED\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 3399,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(comptroller.redeemAllowed(address(this), account, amount) == 0, \"comptroller rejection\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 3503,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 3654,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(balanceAfter == balanceBefore.add(borrowAmount).sub(repayAmount), \"Balance inconsistent\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 3659,
          "vulnerability_to_line": null,
          "vulnerability_code": "      require(underlying == CCollateralCapErc20(cToken).underlying(), \"Params not match\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 3660,
          "vulnerability_to_line": null,
          "vulnerability_code": "      require(amount == borrowAmount, \"Params not match\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 3661,
          "vulnerability_to_line": null,
          "vulnerability_code": "      require(ERC20(underlying).transfer(cToken, repayAmount), \"Transfer fund back failed\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 1724,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(accrualBlockNumber == 0 && borrowIndex == 0, \"market may only be initialized once\");\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 3371,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (collateralCap == 0 || (collateralCap != 0 && totalCollateralTokensNew <= collateralCap)) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 3372,
          "vulnerability_to_line": null,
          "vulnerability_code": "            // 1. If collateral cap is not set,\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 3373,
          "vulnerability_to_line": null,
          "vulnerability_code": "            // 2. If collateral cap is set but has enough space for this user,\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 3374,
          "vulnerability_to_line": null,
          "vulnerability_code": "            // give all the user needs.\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 3375,
          "vulnerability_to_line": null,
          "vulnerability_code": "            totalCollateralTokens = totalCollateralTokensNew;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 3376,
          "vulnerability_to_line": null,
          "vulnerability_code": "            accountCollateralTokens[account] = add_(accountCollateralTokens[account], amount);\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 3377,
          "vulnerability_to_line": null,
          "vulnerability_code": "\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 3378,
          "vulnerability_to_line": null,
          "vulnerability_code": "            emit UserCollateralChanged(account, accountCollateralTokens[account]);\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 3379,
          "vulnerability_to_line": null,
          "vulnerability_code": "            return amount;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 3380,
          "vulnerability_to_line": null,
          "vulnerability_code": "        } else if (collateralCap > totalCollateralTokens) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 96,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(c / a == b, \"SafeMath: multiplication overflow\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 1723,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == admin, \"only admin may initialize the market\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 1724,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(accrualBlockNumber == 0 && borrowIndex == 0, \"market may only be initialized once\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 1728,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(initialExchangeRateMantissa > 0, \"initial exchange rate must be greater than zero.\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 1740,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(err == uint(Error.NO_ERROR), \"setting interest rate model failed\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 2374,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(amountSeizeError == uint(Error.NO_ERROR), \"LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 3079,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == admin, \"only admin can set collateral cap\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 3139,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == address(comptroller), \"only comptroller may register collateral for user\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 3154,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == address(comptroller), \"only comptroller may unregister collateral for user\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 3503,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "compound-borrowfresh-reentrancy",
          "vulnerability_from_line": 2166,
          "vulnerability_to_line": null,
          "vulnerability_code": "        doTransferOut(borrower, borrowAmount);\n",
          "message": "Function borrowFresh() in Compound performs state update after doTransferOut()"
        }
      ]
    },
    "slither": {
      "successfull_analysis": true,
      "errors": [
        "EXIT_CODE_120"
      ],
      "vulnerability_findings": [
        {
          "name": "erc20-interface",
          "vulnerability_from_line": 208,
          "vulnerability_to_line": 211,
          "vulnerability_code": "contract ERC20NS is ERC20Base {\n\n    function transfer(address to, uint256 value) external;\n\n    function transferFrom(address from, address to, uint256 value) external;\n",
          "message": "ERC20NS (FlashloanReceiver.sol#208-211) has incorrect ERC20 function interface(s):\n\t-transfer (FlashloanReceiver.sol#209)\n\t-transferFrom (FlashloanReceiver.sol#210)\n"
        },
        {
          "name": "erc20-interface",
          "vulnerability_from_line": 263,
          "vulnerability_to_line": 299,
          "vulnerability_code": "contract NonStandardToken is ERC20NS {\n\n    using SafeMath for uint256;\n\n\n\n    string public name;\n\n    uint8 public decimals;\n\n    string public symbol;\n\n    uint256 public totalSupply;\n\n    mapping (address => mapping (address => uint256)) public allowance;\n\n    mapping(address => uint256) public balanceOf;\n\n\n\n    constructor(uint256 _initialAmount, string memory _tokenName, uint8 _decimalUnits, string memory _tokenSymbol) public {\n\n        totalSupply = _initialAmount;\n\n        balanceOf[msg.sender] = _initialAmount;\n\n        name = _tokenName;\n\n        symbol = _tokenSymbol;\n\n        decimals = _decimalUnits;\n\n    }\n\n\n\n    function transfer(address dst, uint256 amount) external {\n\n        balanceOf[msg.sender] = balanceOf[msg.sender].sub(amount, \"Insufficient balance\");\n\n        balanceOf[dst] = balanceOf[dst].add(amount, \"Balance overflow\");\n\n        emit Transfer(msg.sender, dst, amount);\n\n    }\n\n\n\n    function transferFrom(address src, address dst, uint256 amount) external {\n\n        allowance[src][msg.sender] = allowance[src][msg.sender].sub(amount, \"Insufficient allowance\");\n\n        balanceOf[src] = balanceOf[src].sub(amount, \"Insufficient balance\");\n\n        balanceOf[dst] = balanceOf[dst].add(amount, \"Balance overflow\");\n\n        emit Transfer(src, dst, amount);\n\n    }\n\n\n\n    function approve(address _spender, uint256 amount) external returns (bool) {\n\n        allowance[msg.sender][_spender] = amount;\n\n        emit Approval(msg.sender, _spender, amount);\n\n        return true;\n\n    }\n",
          "message": "NonStandardToken (FlashloanReceiver.sol#263-299) has incorrect ERC20 function interface(s):\n\t-transfer (FlashloanReceiver.sol#281-285)\n\t-transferFrom (FlashloanReceiver.sol#287-292)\n"
        },
        {
          "name": "erc20-interface",
          "vulnerability_from_line": 1628,
          "vulnerability_to_line": 1690,
          "vulnerability_code": "interface EIP20NonStandardInterface {\n\n\n\n    /**\n\n     * @notice Get the total number of tokens in circulation\n\n     * @return The supply of tokens\n\n     */\n\n    function totalSupply() external view returns (uint256);\n\n\n\n    /**\n\n     * @notice Gets the balance of the specified address\n\n     * @param owner The address from which the balance will be retrieved\n\n     * @return The balance\n\n     */\n\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n\n\n    ///\n\n    /// !!!!!!!!!!!!!!\n\n    /// !!! NOTICE !!! `transfer` does not return a value, in violation of the ERC-20 specification\n\n    /// !!!!!!!!!!!!!!\n\n    ///\n\n\n\n    /**\n\n      * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n\n      * @param dst The address of the destination account\n\n      * @param amount The number of tokens to transfer\n\n      */\n\n    function transfer(address dst, uint256 amount) external;\n\n\n\n    ///\n\n    /// !!!!!!!!!!!!!!\n\n    /// !!! NOTICE !!! `transferFrom` does not return a value, in violation of the ERC-20 specification\n\n    /// !!!!!!!!!!!!!!\n\n    ///\n\n\n\n    /**\n\n      * @notice Transfer `amount` tokens from `src` to `dst`\n\n      * @param src The address of the source account\n\n      * @param dst The address of the destination account\n\n      * @param amount The number of tokens to transfer\n\n      */\n\n    function transferFrom(address src, address dst, uint256 amount) external;\n\n\n\n    /**\n\n      * @notice Approve `spender` to transfer up to `amount` from `src`\n\n      * @dev This will overwrite the approval amount for `spender`\n\n      *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n\n      * @param spender The address of the account which may transfer tokens\n\n      * @param amount The number of tokens that are approved\n\n      * @return Whether or not the approval succeeded\n\n      */\n\n    function approve(address spender, uint256 amount) external returns (bool success);\n\n\n\n    /**\n\n      * @notice Get the current allowance from `owner` for `spender`\n\n      * @param owner The address of the account which owns the tokens to be spent\n\n      * @param spender The address of the account which may transfer tokens\n\n      * @return The number of tokens allowed to be spent\n\n      */\n\n    function allowance(address owner, address spender) external view returns (uint256 remaining);\n\n\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n",
          "message": "EIP20NonStandardInterface (FlashloanReceiver.sol#1628-1690) has incorrect ERC20 function interface(s):\n\t-transfer (FlashloanReceiver.sol#1654)\n\t-transferFrom (FlashloanReceiver.sol#1668)\n"
        },
        {
          "name": "incorrect-equality",
          "vulnerability_from_line": 3649,
          "vulnerability_to_line": 3657,
          "vulnerability_code": "    function doFlashloan(address cToken, uint borrowAmount, uint repayAmount) external {\n\n        uint balanceBefore = ERC20(CCollateralCapErc20(cToken).underlying()).balanceOf(address(this));\n\n        bytes memory data = abi.encode(cToken, borrowAmount, repayAmount);\n\n        CCollateralCapErc20(cToken).flashLoan(address(this), borrowAmount, data);\n\n        uint balanceAfter = ERC20(CCollateralCapErc20(cToken).underlying()).balanceOf(address(this));\n\n        require(balanceAfter == balanceBefore.add(borrowAmount).sub(repayAmount), \"Balance inconsistent\");\n\n    }\n\n\n",
          "message": "FlashloanReceiver.doFlashloan (FlashloanReceiver.sol#3649-3657) uses a dangerous strict equality:\n\t- require(bool,string)(balanceAfter == balanceBefore.add(borrowAmount).sub(repayAmount),Balance inconsistent)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 2539,
          "vulnerability_to_line": 2551,
          "vulnerability_code": "    function _addReservesInternal(uint addAmount) internal nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n\n            return fail(Error(error), FailureInfo.ADD_RESERVES_ACCRUE_INTEREST_FAILED);\n\n        }\n\n\n\n        // _addReservesFresh emits reserve-addition-specific logs on errors, so we don't need to.\n\n        (error, ) = _addReservesFresh(addAmount);\n\n        return error;\n\n    }\n\n\n",
          "message": "Reentrancy in CToken._addReservesInternal (FlashloanReceiver.sol#2539-2551):\n\tExternal calls:\n\t- error = accrueInterest() (FlashloanReceiver.sol#2540-2541)\n\tState variables written after the call(s):\n\t- totalReserves (FlashloanReceiver.sol#2547-2548)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 2599,
          "vulnerability_to_line": 2609,
          "vulnerability_code": "    function _reduceReserves(uint reduceAmount) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n\n            return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.\n\n        return _reduceReservesFresh(reduceAmount);\n\n    }\n\n\n",
          "message": "Reentrancy in CToken._reduceReserves (FlashloanReceiver.sol#2599-2609):\n\tExternal calls:\n\t- error = accrueInterest() (FlashloanReceiver.sol#2600-2601)\n\tState variables written after the call(s):\n\t- totalReserves (FlashloanReceiver.sol#2606-2607)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 2471,
          "vulnerability_to_line": 2490,
          "vulnerability_code": "    function _setComptroller(ComptrollerInterface newComptroller) public returns (uint) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COMPTROLLER_OWNER_CHECK);\n\n        }\n\n\n\n        ComptrollerInterface oldComptroller = comptroller;\n\n        // Ensure invoke comptroller.isComptroller() returns true\n\n        require(newComptroller.isComptroller(), \"marker method returned false\");\n\n\n\n        // Set market's comptroller to newComptroller\n\n        comptroller = newComptroller;\n\n\n\n        // Emit NewComptroller(oldComptroller, newComptroller)\n\n        emit NewComptroller(oldComptroller, newComptroller);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Reentrancy in CToken._setComptroller (FlashloanReceiver.sol#2471-2490):\n\tExternal calls:\n\t- require(bool,string)(newComptroller.isComptroller(),marker method returned false) (FlashloanReceiver.sol#2479-2480)\n\tState variables written after the call(s):\n\t- comptroller (FlashloanReceiver.sol#2482-2483)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 2662,
          "vulnerability_to_line": 2672,
          "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n\n        return _setInterestRateModelFresh(newInterestRateModel);\n\n    }\n\n\n",
          "message": "Reentrancy in CToken._setInterestRateModel (FlashloanReceiver.sol#2662-2672):\n\tExternal calls:\n\t- error = accrueInterest() (FlashloanReceiver.sol#2663-2664)\n\t- _setInterestRateModelFresh(newInterestRateModel) (FlashloanReceiver.sol#2669-2670)\n\tState variables written after the call(s):\n\t- interestRateModel (FlashloanReceiver.sol#2669-2670)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 2678,
          "vulnerability_to_line": 2708,
          "vulnerability_code": "    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {\n\n\n\n        // Used to store old model for use in the event that is emitted on success\n\n        InterestRateModel oldInterestRateModel;\n\n\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);\n\n        }\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);\n\n        }\n\n\n\n        // Track the market's current interest rate model\n\n        oldInterestRateModel = interestRateModel;\n\n\n\n        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true\n\n        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n\n\n\n        // Set the interest rate model to newInterestRateModel\n\n        interestRateModel = newInterestRateModel;\n\n\n\n        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)\n\n        emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Reentrancy in CToken._setInterestRateModelFresh (FlashloanReceiver.sol#2678-2708):\n\tExternal calls:\n\t- require(bool,string)(newInterestRateModel.isInterestRateModel(),marker method returned false) (FlashloanReceiver.sol#2697-2699)\n\tState variables written after the call(s):\n\t- interestRateModel (FlashloanReceiver.sol#2700-2702)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 2495,
          "vulnerability_to_line": 2505,
          "vulnerability_code": "    function _setReserveFactor(uint newReserveFactorMantissa) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.\n\n            return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.\n\n        return _setReserveFactorFresh(newReserveFactorMantissa);\n\n    }\n\n\n",
          "message": "Reentrancy in CToken._setReserveFactor (FlashloanReceiver.sol#2495-2505):\n\tExternal calls:\n\t- error = accrueInterest() (FlashloanReceiver.sol#2496-2497)\n\tState variables written after the call(s):\n\t- reserveFactorMantissa (FlashloanReceiver.sol#2502-2503)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 1999,
          "vulnerability_to_line": 2051,
          "vulnerability_code": "    function accrueInterest() public returns (uint) {\n\n        /* Remember the initial block number */\n\n        uint currentBlockNumber = getBlockNumber();\n\n        uint accrualBlockNumberPrior = accrualBlockNumber;\n\n\n\n        /* Short-circuit accumulating 0 interest */\n\n        if (accrualBlockNumberPrior == currentBlockNumber) {\n\n            return uint(Error.NO_ERROR);\n\n        }\n\n\n\n        /* Read the previous values out of storage */\n\n        uint cashPrior = getCashPrior();\n\n        uint borrowsPrior = totalBorrows;\n\n        uint reservesPrior = totalReserves;\n\n        uint borrowIndexPrior = borrowIndex;\n\n\n\n        /* Calculate the current borrow interest rate */\n\n        uint borrowRateMantissa = interestRateModel.getBorrowRate(cashPrior, borrowsPrior, reservesPrior);\n\n        require(borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n\n\n\n        /* Calculate the number of blocks elapsed since the last accrual */\n\n        uint blockDelta = sub_(currentBlockNumber, accrualBlockNumberPrior);\n\n\n\n        /*\n\n         * Calculate the interest accumulated into borrows and reserves and the new index:\n\n         *  simpleInterestFactor = borrowRate * blockDelta\n\n         *  interestAccumulated = simpleInterestFactor * totalBorrows\n\n         *  totalBorrowsNew = interestAccumulated + totalBorrows\n\n         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves\n\n         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\n\n         */\n\n\n\n        Exp memory simpleInterestFactor = mul_(Exp({mantissa: borrowRateMantissa}), blockDelta);\n\n        uint interestAccumulated = mul_ScalarTruncate(simpleInterestFactor, borrowsPrior);\n\n        uint totalBorrowsNew = add_(interestAccumulated, borrowsPrior);\n\n        uint totalReservesNew = mul_ScalarTruncateAddUInt(Exp({mantissa: reserveFactorMantissa}), interestAccumulated, reservesPrior);\n\n        uint borrowIndexNew = mul_ScalarTruncateAddUInt(simpleInterestFactor, borrowIndexPrior, borrowIndexPrior);\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accrualBlockNumber = currentBlockNumber;\n\n        borrowIndex = borrowIndexNew;\n\n        totalBorrows = totalBorrowsNew;\n\n        totalReserves = totalReservesNew;\n\n\n\n        /* We emit an AccrueInterest event */\n\n        emit AccrueInterest(cashPrior, interestAccumulated, borrowIndexNew, totalBorrowsNew);\n\n\n\n        return uint(Error.NO_ERROR);\n",
          "message": "Reentrancy in CToken.accrueInterest (FlashloanReceiver.sol#1999-2051):\n\tExternal calls:\n\t- borrowRateMantissa = interestRateModel.getBorrowRate(cashPrior,borrowsPrior,reservesPrior) (FlashloanReceiver.sol#2016)\n\tState variables written after the call(s):\n\t- accrualBlockNumber (FlashloanReceiver.sol#2042)\n\t- borrowIndex (FlashloanReceiver.sol#2043)\n\t- totalBorrows (FlashloanReceiver.sol#2044)\n\t- totalReserves (FlashloanReceiver.sol#2045)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 2106,
          "vulnerability_to_line": 2114,
          "vulnerability_code": "    function borrowInternal(uint borrowAmount) internal nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n\n            return fail(Error(error), FailureInfo.BORROW_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // borrowFresh emits borrow-specific logs on errors, so we don't need to\n\n        return borrowFresh(msg.sender, borrowAmount);\n",
          "message": "Reentrancy in CToken.borrowInternal (FlashloanReceiver.sol#2106-2114):\n\tExternal calls:\n\t- error = accrueInterest() (FlashloanReceiver.sol#2107)\n\t- borrowFresh(msg.sender,borrowAmount) (FlashloanReceiver.sol#2113)\n\tState variables written after the call(s):\n\t- totalBorrows (FlashloanReceiver.sol#2113)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 3103,
          "vulnerability_to_line": 3129,
          "vulnerability_code": "    function flashLoan(address receiver, uint amount, bytes calldata params) external nonReentrant {\n\n        uint cashOnChainBefore = getCashOnChain();\n\n        uint cashBefore = getCashPrior();\n\n        require(cashBefore >= amount, \"INSUFFICIENT_LIQUIDITY\");\n\n\n\n        // 1. calculate fee, 1 bips = 1/10000\n\n        uint totalFee = div_(mul_(amount, flashFeeBips), 10000);\n\n\n\n        // 2. transfer fund to receiver\n\n        doTransferOut(address(uint160(receiver)), amount);\n\n\n\n        // 3. execute receiver's callback function\n\n        IFlashloanReceiver(receiver).executeOperation(msg.sender, underlying, amount, totalFee, params);\n\n\n\n        // 4. check balance\n\n        uint cashOnChainAfter = getCashOnChain();\n\n        require(cashOnChainAfter == add_(cashOnChainBefore, totalFee), \"BALANCE_INCONSISTENT\");\n\n\n\n        // 5. update reserves and internal cash\n\n        uint reservesFee = mul_ScalarTruncate(Exp({mantissa: reserveFactorMantissa}), totalFee);\n\n        totalReserves = add_(totalReserves, reservesFee);\n\n        internalCash = add_(cashBefore, totalFee);\n\n\n\n        emit Flashloan(receiver, amount, totalFee, reservesFee);\n\n    }\n\n\n",
          "message": "Reentrancy in CCollateralCapErc20.flashLoan (FlashloanReceiver.sol#3103-3129):\n\tExternal calls:\n\t- cashOnChainBefore = getCashOnChain() (FlashloanReceiver.sol#3104-3105)\n\t- doTransferOut(address(uint160(receiver)),amount) (FlashloanReceiver.sol#3112-3114)\n\t- IFlashloanReceiver(receiver).executeOperation(msg.sender,underlying,amount,totalFee,params) (FlashloanReceiver.sol#3115-3117)\n\t- cashOnChainAfter = getCashOnChain() (FlashloanReceiver.sol#3118-3119)\n\tState variables written after the call(s):\n\t- internalCash (FlashloanReceiver.sol#3124-3126)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 1717,
          "vulnerability_to_line": 1748,
          "vulnerability_code": "    function initialize(ComptrollerInterface comptroller_,\n\n                        InterestRateModel interestRateModel_,\n\n                        uint initialExchangeRateMantissa_,\n\n                        string memory name_,\n\n                        string memory symbol_,\n\n                        uint8 decimals_) public {\n\n        require(msg.sender == admin, \"only admin may initialize the market\");\n\n        require(accrualBlockNumber == 0 && borrowIndex == 0, \"market may only be initialized once\");\n\n\n\n        // Set initial exchange rate\n\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n\n        require(initialExchangeRateMantissa > 0, \"initial exchange rate must be greater than zero.\");\n\n\n\n        // Set the comptroller\n\n        uint err = _setComptroller(comptroller_);\n\n        require(err == uint(Error.NO_ERROR), \"setting comptroller failed\");\n\n\n\n        // Initialize block number and borrow index (block number mocks depend on comptroller being set)\n\n        accrualBlockNumber = getBlockNumber();\n\n        borrowIndex = mantissaOne;\n\n\n\n        // Set the interest rate model (depends on block number / borrow index)\n\n        err = _setInterestRateModelFresh(interestRateModel_);\n\n        require(err == uint(Error.NO_ERROR), \"setting interest rate model failed\");\n\n\n\n        name = name_;\n\n        symbol = symbol_;\n\n        decimals = decimals_;\n\n\n\n        // The counter starts true to prevent changing it from zero to non-zero (i.e. smaller cost/refund)\n\n        _notEntered = true;\n",
          "message": "Reentrancy in CToken.initialize (FlashloanReceiver.sol#1717-1748):\n\tExternal calls:\n\t- err = _setComptroller(comptroller_) (FlashloanReceiver.sol#1731)\n\tState variables written after the call(s):\n\t- accrualBlockNumber (FlashloanReceiver.sol#1735)\n\t- borrowIndex (FlashloanReceiver.sol#1736)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 3186,
          "vulnerability_to_line": 3205,
          "vulnerability_code": "    function initializeAccountCollateralTokens(address account) internal {\n\n        /**\n\n         * If isCollateralTokenInit is false, it means accountCollateralTokens was not initialized yet.\n\n         * This case will only happen once and must be the very beginning. accountCollateralTokens is a new structure and its\n\n         * initial value should be equal to accountTokens if user has entered the market. However, it's almost impossible to\n\n         * check every user's value when the implementation becomes active. Therefore, it must rely on every action which will\n\n         * access accountTokens to call this function to check if accountCollateralTokens needed to be initialized.\n\n         */\n\n        if (!isCollateralTokenInit[account]) {\n\n            if (ComptrollerInterfaceExtension(address(comptroller)).checkMembership(account, CToken(this))) {\n\n                accountCollateralTokens[account] = accountTokens[account];\n\n                totalCollateralTokens = add_(totalCollateralTokens, accountTokens[account]);\n\n\n\n                emit UserCollateralChanged(account, accountCollateralTokens[account]);\n\n            }\n\n            isCollateralTokenInit[account] = true;\n\n        }\n\n    }\n\n\n",
          "message": "Reentrancy in CCollateralCapErc20.initializeAccountCollateralTokens (FlashloanReceiver.sol#3186-3205):\n\tExternal calls:\n\t- ComptrollerInterfaceExtension(address(comptroller)).checkMembership(account,CToken(this)) (FlashloanReceiver.sol#3195-3201)\n\tState variables written after the call(s):\n\t- isCollateralTokenInit (FlashloanReceiver.sol#3201-3202)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 2303,
          "vulnerability_to_line": 2318,
          "vulnerability_code": "    function liquidateBorrowInternal(address borrower, uint repayAmount, CTokenInterface cTokenCollateral) internal nonReentrant returns (uint, uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\n\n            return (fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED), 0);\n\n        }\n\n\n\n        error = cTokenCollateral.accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\n\n            return (fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED), 0);\n\n        }\n\n\n\n        // liquidateBorrowFresh emits borrow-specific logs on errors, so we don't need to\n\n        return liquidateBorrowFresh(msg.sender, borrower, repayAmount, cTokenCollateral);\n",
          "message": "Reentrancy in CToken.liquidateBorrowInternal (FlashloanReceiver.sol#2303-2318):\n\tExternal calls:\n\t- error = accrueInterest() (FlashloanReceiver.sol#2304)\n\t- error = cTokenCollateral.accrueInterest() (FlashloanReceiver.sol#2310)\n\t- liquidateBorrowFresh(msg.sender,borrower,repayAmount,cTokenCollateral) (FlashloanReceiver.sol#2317)\n\tState variables written after the call(s):\n\t- totalBorrows (FlashloanReceiver.sol#2317)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 3420,
          "vulnerability_to_line": 3485,
          "vulnerability_code": "    function mintFresh(address minter, uint mintAmount) internal returns (uint, uint) {\n\n        // Make sure accountCollateralTokens of `minter` is initialized.\n\n        initializeAccountCollateralTokens(minter);\n\n\n\n        /* Fail if mint not allowed */\n\n        uint allowed = comptroller.mintAllowed(address(this), minter, mintAmount);\n\n        if (allowed != 0) {\n\n            return (failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.MINT_COMPTROLLER_REJECTION, allowed), 0);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return (fail(Error.MARKET_NOT_FRESH, FailureInfo.MINT_FRESHNESS_CHECK), 0);\n\n        }\n\n\n\n        MintLocalVars memory vars;\n\n\n\n        vars.exchangeRateMantissa = exchangeRateStoredInternal();\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         *  We call `doTransferIn` for the minter and the mintAmount.\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  `doTransferIn` reverts if anything goes wrong, since we can't be sure if\n\n         *  side-effects occurred. The function returns the amount actually transferred,\n\n         *  in case of a fee. On success, the cToken holds an additional `actualMintAmount`\n\n         *  of cash.\n\n         */\n\n        vars.actualMintAmount = doTransferIn(minter, mintAmount);\n\n\n\n        /*\n\n         * We get the current exchange rate and calculate the number of cTokens to be minted:\n\n         *  mintTokens = actualMintAmount / exchangeRate\n\n         */\n\n        vars.mintTokens = div_ScalarByExpTruncate(vars.actualMintAmount, Exp({mantissa: vars.exchangeRateMantissa}));\n\n\n\n        /*\n\n         * We calculate the new total supply of cTokens and minter token balance, checking for overflow:\n\n         *  totalSupply = totalSupply + mintTokens\n\n         *  accountTokens[minter] = accountTokens[minter] + mintTokens\n\n         */\n\n        totalSupply = add_(totalSupply, vars.mintTokens);\n\n        accountTokens[minter] = add_(accountTokens[minter], vars.mintTokens);\n\n\n\n        /*\n\n         * We only allocate collateral tokens if the minter has entered the market.\n\n         */\n\n        if (ComptrollerInterfaceExtension(address(comptroller)).checkMembership(minter, CToken(this))) {\n\n            increaseUserCollateralInternal(minter, vars.mintTokens);\n\n        }\n\n\n\n        /* We emit a Mint event, and a Transfer event */\n\n        emit Mint(minter, vars.actualMintAmount, vars.mintTokens);\n\n        emit Transfer(address(this), minter, vars.mintTokens);\n\n\n\n        /* We call the defense hook */\n\n        // unused function\n\n        // comptroller.mintVerify(address(this), minter, vars.actualMintAmount, vars.mintTokens);\n\n\n\n        return (uint(Error.NO_ERROR), vars.actualMintAmount);\n\n    }\n\n\n",
          "message": "Reentrancy in CCollateralCapErc20.mintFresh (FlashloanReceiver.sol#3420-3485):\n\tExternal calls:\n\t- initializeAccountCollateralTokens(minter) (FlashloanReceiver.sol#3422-3424)\n\t- allowed = comptroller.mintAllowed(address(this),minter,mintAmount) (FlashloanReceiver.sol#3425-3426)\n\t- vars.actualMintAmount = doTransferIn(minter,mintAmount) (FlashloanReceiver.sol#3451-3453)\n\tState variables written after the call(s):\n\t- accountTokens (FlashloanReceiver.sol#3465-3467)\n\t- totalSupply (FlashloanReceiver.sol#3464-3465)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 3420,
          "vulnerability_to_line": 3485,
          "vulnerability_code": "    function mintFresh(address minter, uint mintAmount) internal returns (uint, uint) {\n\n        // Make sure accountCollateralTokens of `minter` is initialized.\n\n        initializeAccountCollateralTokens(minter);\n\n\n\n        /* Fail if mint not allowed */\n\n        uint allowed = comptroller.mintAllowed(address(this), minter, mintAmount);\n\n        if (allowed != 0) {\n\n            return (failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.MINT_COMPTROLLER_REJECTION, allowed), 0);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return (fail(Error.MARKET_NOT_FRESH, FailureInfo.MINT_FRESHNESS_CHECK), 0);\n\n        }\n\n\n\n        MintLocalVars memory vars;\n\n\n\n        vars.exchangeRateMantissa = exchangeRateStoredInternal();\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         *  We call `doTransferIn` for the minter and the mintAmount.\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  `doTransferIn` reverts if anything goes wrong, since we can't be sure if\n\n         *  side-effects occurred. The function returns the amount actually transferred,\n\n         *  in case of a fee. On success, the cToken holds an additional `actualMintAmount`\n\n         *  of cash.\n\n         */\n\n        vars.actualMintAmount = doTransferIn(minter, mintAmount);\n\n\n\n        /*\n\n         * We get the current exchange rate and calculate the number of cTokens to be minted:\n\n         *  mintTokens = actualMintAmount / exchangeRate\n\n         */\n\n        vars.mintTokens = div_ScalarByExpTruncate(vars.actualMintAmount, Exp({mantissa: vars.exchangeRateMantissa}));\n\n\n\n        /*\n\n         * We calculate the new total supply of cTokens and minter token balance, checking for overflow:\n\n         *  totalSupply = totalSupply + mintTokens\n\n         *  accountTokens[minter] = accountTokens[minter] + mintTokens\n\n         */\n\n        totalSupply = add_(totalSupply, vars.mintTokens);\n\n        accountTokens[minter] = add_(accountTokens[minter], vars.mintTokens);\n\n\n\n        /*\n\n         * We only allocate collateral tokens if the minter has entered the market.\n\n         */\n\n        if (ComptrollerInterfaceExtension(address(comptroller)).checkMembership(minter, CToken(this))) {\n\n            increaseUserCollateralInternal(minter, vars.mintTokens);\n\n        }\n\n\n\n        /* We emit a Mint event, and a Transfer event */\n\n        emit Mint(minter, vars.actualMintAmount, vars.mintTokens);\n\n        emit Transfer(address(this), minter, vars.mintTokens);\n\n\n\n        /* We call the defense hook */\n\n        // unused function\n\n        // comptroller.mintVerify(address(this), minter, vars.actualMintAmount, vars.mintTokens);\n\n\n\n        return (uint(Error.NO_ERROR), vars.actualMintAmount);\n\n    }\n\n\n",
          "message": "Reentrancy in CCollateralCapErc20.mintFresh (FlashloanReceiver.sol#3420-3485):\n\tExternal calls:\n\t- initializeAccountCollateralTokens(minter) (FlashloanReceiver.sol#3422-3424)\n\t- allowed = comptroller.mintAllowed(address(this),minter,mintAmount) (FlashloanReceiver.sol#3425-3426)\n\t- vars.actualMintAmount = doTransferIn(minter,mintAmount) (FlashloanReceiver.sol#3451-3453)\n\t- ComptrollerInterfaceExtension(address(comptroller)).checkMembership(minter,CToken(this)) (FlashloanReceiver.sol#3470-3474)\n\tState variables written after the call(s):\n\t- accountCollateralTokens (FlashloanReceiver.sol#3471-3472)\n\t- totalCollateralTokens (FlashloanReceiver.sol#3471-3472)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 3499,
          "vulnerability_to_line": 3588,
          "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n\n        // Make sure accountCollateralTokens of `redeemer` is initialized.\n\n        initializeAccountCollateralTokens(redeemer);\n\n\n\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n\n\n\n        RedeemLocalVars memory vars;\n\n\n\n        /* exchangeRate = invoke Exchange Rate Stored() */\n\n        vars.exchangeRateMantissa = exchangeRateStoredInternal();\n\n\n\n        /* If redeemTokensIn > 0: */\n\n        if (redeemTokensIn > 0) {\n\n            /*\n\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\n\n             *  redeemTokens = redeemTokensIn\n\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n\n             */\n\n            vars.redeemTokens = redeemTokensIn;\n\n            vars.redeemAmount = mul_ScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);\n\n        } else {\n\n            /*\n\n             * We get the current exchange rate and calculate the amount to be redeemed:\n\n             *  redeemTokens = redeemAmountIn / exchangeRate\n\n             *  redeemAmount = redeemAmountIn\n\n             */\n\n            vars.redeemTokens = div_ScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));\n\n            vars.redeemAmount = redeemAmountIn;\n\n        }\n\n\n\n        /**\n\n         * For every user, accountTokens must be greater than or equal to accountCollateralTokens.\n\n         * The buffer between the two values will be redeemed first.\n\n         * bufferTokens = accountTokens[redeemer] - accountCollateralTokens[redeemer]\n\n         * collateralTokens = redeemTokens - bufferTokens\n\n         */\n\n        uint bufferTokens = sub_(accountTokens[redeemer], accountCollateralTokens[redeemer]);\n\n        uint collateralTokens = 0;\n\n        if (vars.redeemTokens > bufferTokens) {\n\n            collateralTokens = sub_(vars.redeemTokens, bufferTokens);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);\n\n        }\n\n\n\n        /* Fail gracefully if protocol has insufficient cash */\n\n        if (getCashPrior() < vars.redeemAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We invoke doTransferOut for the redeemer and the redeemAmount.\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken has redeemAmount less of cash.\n\n         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n\n         */\n\n        doTransferOut(redeemer, vars.redeemAmount);\n\n\n\n        /*\n\n         * We calculate the new total supply and redeemer balance, checking for underflow:\n\n         *  totalSupplyNew = totalSupply - redeemTokens\n\n         *  accountTokensNew = accountTokens[redeemer] - redeemTokens\n\n         */\n\n        totalSupply = sub_(totalSupply, vars.redeemTokens);\n\n        accountTokens[redeemer] = sub_(accountTokens[redeemer], vars.redeemTokens);\n\n\n\n        /*\n\n         * We only deallocate collateral tokens if the redeemer needs to redeem them.\n\n         */\n\n        if (collateralTokens > 0) {\n\n            decreaseUserCollateralInternal(redeemer, collateralTokens);\n\n        }\n\n\n\n        /* We emit a Transfer event, and a Redeem event */\n\n        emit Transfer(redeemer, address(this), vars.redeemTokens);\n\n        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        /* We call the defense hook */\n\n        comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Reentrancy in CCollateralCapErc20.redeemFresh (FlashloanReceiver.sol#3499-3588):\n\tExternal calls:\n\t- initializeAccountCollateralTokens(redeemer) (FlashloanReceiver.sol#3501-3503)\n\t- doTransferOut(redeemer,vars.redeemAmount) (FlashloanReceiver.sol#3561-3563)\n\tState variables written after the call(s):\n\t- accountTokens (FlashloanReceiver.sol#3569-3571)\n\t- totalSupply (FlashloanReceiver.sol#3568-3569)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 3499,
          "vulnerability_to_line": 3588,
          "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n\n        // Make sure accountCollateralTokens of `redeemer` is initialized.\n\n        initializeAccountCollateralTokens(redeemer);\n\n\n\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n\n\n\n        RedeemLocalVars memory vars;\n\n\n\n        /* exchangeRate = invoke Exchange Rate Stored() */\n\n        vars.exchangeRateMantissa = exchangeRateStoredInternal();\n\n\n\n        /* If redeemTokensIn > 0: */\n\n        if (redeemTokensIn > 0) {\n\n            /*\n\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\n\n             *  redeemTokens = redeemTokensIn\n\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n\n             */\n\n            vars.redeemTokens = redeemTokensIn;\n\n            vars.redeemAmount = mul_ScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);\n\n        } else {\n\n            /*\n\n             * We get the current exchange rate and calculate the amount to be redeemed:\n\n             *  redeemTokens = redeemAmountIn / exchangeRate\n\n             *  redeemAmount = redeemAmountIn\n\n             */\n\n            vars.redeemTokens = div_ScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));\n\n            vars.redeemAmount = redeemAmountIn;\n\n        }\n\n\n\n        /**\n\n         * For every user, accountTokens must be greater than or equal to accountCollateralTokens.\n\n         * The buffer between the two values will be redeemed first.\n\n         * bufferTokens = accountTokens[redeemer] - accountCollateralTokens[redeemer]\n\n         * collateralTokens = redeemTokens - bufferTokens\n\n         */\n\n        uint bufferTokens = sub_(accountTokens[redeemer], accountCollateralTokens[redeemer]);\n\n        uint collateralTokens = 0;\n\n        if (vars.redeemTokens > bufferTokens) {\n\n            collateralTokens = sub_(vars.redeemTokens, bufferTokens);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);\n\n        }\n\n\n\n        /* Fail gracefully if protocol has insufficient cash */\n\n        if (getCashPrior() < vars.redeemAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We invoke doTransferOut for the redeemer and the redeemAmount.\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken has redeemAmount less of cash.\n\n         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n\n         */\n\n        doTransferOut(redeemer, vars.redeemAmount);\n\n\n\n        /*\n\n         * We calculate the new total supply and redeemer balance, checking for underflow:\n\n         *  totalSupplyNew = totalSupply - redeemTokens\n\n         *  accountTokensNew = accountTokens[redeemer] - redeemTokens\n\n         */\n\n        totalSupply = sub_(totalSupply, vars.redeemTokens);\n\n        accountTokens[redeemer] = sub_(accountTokens[redeemer], vars.redeemTokens);\n\n\n\n        /*\n\n         * We only deallocate collateral tokens if the redeemer needs to redeem them.\n\n         */\n\n        if (collateralTokens > 0) {\n\n            decreaseUserCollateralInternal(redeemer, collateralTokens);\n\n        }\n\n\n\n        /* We emit a Transfer event, and a Redeem event */\n\n        emit Transfer(redeemer, address(this), vars.redeemTokens);\n\n        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        /* We call the defense hook */\n\n        comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Reentrancy in CCollateralCapErc20.redeemFresh (FlashloanReceiver.sol#3499-3588):\n\tExternal calls:\n\t- initializeAccountCollateralTokens(redeemer) (FlashloanReceiver.sol#3501-3503)\n\t- doTransferOut(redeemer,vars.redeemAmount) (FlashloanReceiver.sol#3561-3563)\n\t- decreaseUserCollateralInternal(redeemer,collateralTokens) (FlashloanReceiver.sol#3575-3576)\n\tState variables written after the call(s):\n\t- accountCollateralTokens (FlashloanReceiver.sol#3575-3576)\n\t- totalCollateralTokens (FlashloanReceiver.sol#3575-3576)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 3135,
          "vulnerability_to_line": 3145,
          "vulnerability_code": "    function registerCollateral(address account) external returns (uint) {\n\n        // Make sure accountCollateralTokens of `account` is initialized.\n\n        initializeAccountCollateralTokens(account);\n\n\n\n        require(msg.sender == address(comptroller), \"only comptroller may register collateral for user\");\n\n\n\n        uint amount = sub_(accountTokens[account], accountCollateralTokens[account]);\n\n        return increaseUserCollateralInternal(account, amount);\n\n    }\n\n\n",
          "message": "Reentrancy in CCollateralCapErc20.registerCollateral (FlashloanReceiver.sol#3135-3145):\n\tExternal calls:\n\t- initializeAccountCollateralTokens(account) (FlashloanReceiver.sol#3137-3139)\n\tState variables written after the call(s):\n\t- accountCollateralTokens (FlashloanReceiver.sol#3142-3143)\n\t- totalCollateralTokens (FlashloanReceiver.sol#3142-3143)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 2204,
          "vulnerability_to_line": 2212,
          "vulnerability_code": "    function repayBorrowBehalfInternal(address borrower, uint repayAmount) internal nonReentrant returns (uint, uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n\n            return (fail(Error(error), FailureInfo.REPAY_BEHALF_ACCRUE_INTEREST_FAILED), 0);\n\n        }\n\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n\n        return repayBorrowFresh(msg.sender, borrower, repayAmount);\n",
          "message": "Reentrancy in CToken.repayBorrowBehalfInternal (FlashloanReceiver.sol#2204-2212):\n\tExternal calls:\n\t- error = accrueInterest() (FlashloanReceiver.sol#2205)\n\t- repayBorrowFresh(msg.sender,borrower,repayAmount) (FlashloanReceiver.sol#2211)\n\tState variables written after the call(s):\n\t- totalBorrows (FlashloanReceiver.sol#2211)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 2188,
          "vulnerability_to_line": 2196,
          "vulnerability_code": "    function repayBorrowInternal(uint repayAmount) internal nonReentrant returns (uint, uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n\n            return (fail(Error(error), FailureInfo.REPAY_BORROW_ACCRUE_INTEREST_FAILED), 0);\n\n        }\n\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n\n        return repayBorrowFresh(msg.sender, msg.sender, repayAmount);\n",
          "message": "Reentrancy in CToken.repayBorrowInternal (FlashloanReceiver.sol#2188-2196):\n\tExternal calls:\n\t- error = accrueInterest() (FlashloanReceiver.sol#2189)\n\t- repayBorrowFresh(msg.sender,msg.sender,repayAmount) (FlashloanReceiver.sol#2195)\n\tState variables written after the call(s):\n\t- totalBorrows (FlashloanReceiver.sol#2195)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 3598,
          "vulnerability_to_line": 3639,
          "vulnerability_code": "    function seizeInternal(address seizerToken, address liquidator, address borrower, uint seizeTokens) internal returns (uint) {\n\n        // Make sure accountCollateralTokens of `liquidator` and `borrower` are initialized.\n\n        initializeAccountCollateralTokens(liquidator);\n\n        initializeAccountCollateralTokens(borrower);\n\n\n\n        /* Fail if seize not allowed */\n\n        uint allowed = comptroller.seizeAllowed(address(this), seizerToken, liquidator, borrower, seizeTokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_SEIZE_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Fail if borrower = liquidator */\n\n        if (borrower == liquidator) {\n\n            return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER);\n\n        }\n\n\n\n        /*\n\n         * We calculate the new borrower and liquidator token balances and token collateral balances, failing on underflow/overflow:\n\n         *  accountTokens[borrower] = accountTokens[borrower] - seizeTokens\n\n         *  accountTokens[liquidator] = accountTokens[liquidator] + seizeTokens\n\n         *  accountCollateralTokens[borrower] = accountCollateralTokens[borrower] - seizeTokens\n\n         *  accountCollateralTokens[liquidator] = accountCollateralTokens[liquidator] + seizeTokens\n\n         */\n\n        accountTokens[borrower] = sub_(accountTokens[borrower], seizeTokens);\n\n        accountTokens[liquidator] = add_(accountTokens[liquidator], seizeTokens);\n\n        accountCollateralTokens[borrower] = sub_(accountCollateralTokens[borrower], seizeTokens);\n\n        accountCollateralTokens[liquidator] = add_(accountCollateralTokens[liquidator], seizeTokens);\n\n\n\n        /* Emit a Transfer, UserCollateralChanged events */\n\n        emit Transfer(borrower, liquidator, seizeTokens);\n\n        emit UserCollateralChanged(borrower, accountCollateralTokens[borrower]);\n\n        emit UserCollateralChanged(liquidator, accountCollateralTokens[liquidator]);\n\n\n\n        /* We call the defense hook */\n\n        // unused function\n\n        // comptroller.seizeVerify(address(this), seizerToken, liquidator, borrower, seizeTokens);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n}\n\n\n",
          "message": "Reentrancy in CCollateralCapErc20.seizeInternal (FlashloanReceiver.sol#3598-3639):\n\tExternal calls:\n\t- initializeAccountCollateralTokens(liquidator) (FlashloanReceiver.sol#3600-3601)\n\t- initializeAccountCollateralTokens(borrower) (FlashloanReceiver.sol#3601-3603)\n\tState variables written after the call(s):\n\t- accountCollateralTokens (FlashloanReceiver.sol#3601-3603)\n\t- isCollateralTokenInit (FlashloanReceiver.sol#3601-3603)\n\t- totalCollateralTokens (FlashloanReceiver.sol#3601-3603)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 3598,
          "vulnerability_to_line": 3639,
          "vulnerability_code": "    function seizeInternal(address seizerToken, address liquidator, address borrower, uint seizeTokens) internal returns (uint) {\n\n        // Make sure accountCollateralTokens of `liquidator` and `borrower` are initialized.\n\n        initializeAccountCollateralTokens(liquidator);\n\n        initializeAccountCollateralTokens(borrower);\n\n\n\n        /* Fail if seize not allowed */\n\n        uint allowed = comptroller.seizeAllowed(address(this), seizerToken, liquidator, borrower, seizeTokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_SEIZE_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Fail if borrower = liquidator */\n\n        if (borrower == liquidator) {\n\n            return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER);\n\n        }\n\n\n\n        /*\n\n         * We calculate the new borrower and liquidator token balances and token collateral balances, failing on underflow/overflow:\n\n         *  accountTokens[borrower] = accountTokens[borrower] - seizeTokens\n\n         *  accountTokens[liquidator] = accountTokens[liquidator] + seizeTokens\n\n         *  accountCollateralTokens[borrower] = accountCollateralTokens[borrower] - seizeTokens\n\n         *  accountCollateralTokens[liquidator] = accountCollateralTokens[liquidator] + seizeTokens\n\n         */\n\n        accountTokens[borrower] = sub_(accountTokens[borrower], seizeTokens);\n\n        accountTokens[liquidator] = add_(accountTokens[liquidator], seizeTokens);\n\n        accountCollateralTokens[borrower] = sub_(accountCollateralTokens[borrower], seizeTokens);\n\n        accountCollateralTokens[liquidator] = add_(accountCollateralTokens[liquidator], seizeTokens);\n\n\n\n        /* Emit a Transfer, UserCollateralChanged events */\n\n        emit Transfer(borrower, liquidator, seizeTokens);\n\n        emit UserCollateralChanged(borrower, accountCollateralTokens[borrower]);\n\n        emit UserCollateralChanged(liquidator, accountCollateralTokens[liquidator]);\n\n\n\n        /* We call the defense hook */\n\n        // unused function\n\n        // comptroller.seizeVerify(address(this), seizerToken, liquidator, borrower, seizeTokens);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n}\n\n\n",
          "message": "Reentrancy in CCollateralCapErc20.seizeInternal (FlashloanReceiver.sol#3598-3639):\n\tExternal calls:\n\t- initializeAccountCollateralTokens(liquidator) (FlashloanReceiver.sol#3600-3601)\n\t- initializeAccountCollateralTokens(borrower) (FlashloanReceiver.sol#3601-3603)\n\t- allowed = comptroller.seizeAllowed(address(this),seizerToken,liquidator,borrower,seizeTokens) (FlashloanReceiver.sol#3604-3605)\n\tState variables written after the call(s):\n\t- accountCollateralTokens (FlashloanReceiver.sol#3623-3624)\n\t- accountCollateralTokens (FlashloanReceiver.sol#3624-3626)\n\t- accountTokens (FlashloanReceiver.sol#3621-3622)\n\t- accountTokens (FlashloanReceiver.sol#3622-3623)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 3282,
          "vulnerability_to_line": 3347,
          "vulnerability_code": "    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (uint) {\n\n        // Make sure accountCollateralTokens of `src` and `dst` are initialized.\n\n        initializeAccountCollateralTokens(src);\n\n        initializeAccountCollateralTokens(dst);\n\n\n\n        /**\n\n         * For every user, accountTokens must be greater than or equal to accountCollateralTokens.\n\n         * The buffer between the two values will be transferred first.\n\n         * bufferTokens = accountTokens[src] - accountCollateralTokens[src]\n\n         * collateralTokens = tokens - bufferTokens\n\n         */\n\n        uint bufferTokens = sub_(accountTokens[src], accountCollateralTokens[src]);\n\n        uint collateralTokens = 0;\n\n        if (tokens > bufferTokens) {\n\n            collateralTokens = sub_(tokens, bufferTokens);\n\n        }\n\n\n\n        /**\n\n         * Since bufferTokens are not collateralized and can be transferred freely, we only check with comptroller\n\n         * whether collateralized tokens can be transferred.\n\n         */\n\n        uint allowed = comptroller.transferAllowed(address(this), src, dst, collateralTokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.TRANSFER_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Do not allow self-transfers */\n\n        if (src == dst) {\n\n            return fail(Error.BAD_INPUT, FailureInfo.TRANSFER_NOT_ALLOWED);\n\n        }\n\n\n\n        /* Get the allowance, infinite for the account owner */\n\n        uint startingAllowance = 0;\n\n        if (spender == src) {\n\n            startingAllowance = uint(-1);\n\n        } else {\n\n            startingAllowance = transferAllowances[src][spender];\n\n        }\n\n\n\n        /* Do the calculations, checking for {under,over}flow */\n\n        uint allowanceNew = sub_(startingAllowance, tokens);\n\n        accountTokens[src] = sub_(accountTokens[src], tokens);\n\n        accountTokens[dst] = add_(accountTokens[dst], tokens);\n\n        if (collateralTokens > 0) {\n\n            accountCollateralTokens[src] = sub_(accountCollateralTokens[src], collateralTokens);\n\n            accountCollateralTokens[dst] = add_(accountCollateralTokens[dst], collateralTokens);\n\n\n\n            emit UserCollateralChanged(src, accountCollateralTokens[src]);\n\n            emit UserCollateralChanged(dst, accountCollateralTokens[dst]);\n\n        }\n\n\n\n        /* Eat some of the allowance (if necessary) */\n\n        if (startingAllowance != uint(-1)) {\n\n            transferAllowances[src][spender] = allowanceNew;\n\n        }\n\n\n\n        /* We emit a Transfer event */\n\n        emit Transfer(src, dst, tokens);\n\n\n\n        // unused function\n\n        // comptroller.transferVerify(address(this), src, dst, tokens);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Reentrancy in CCollateralCapErc20.transferTokens (FlashloanReceiver.sol#3282-3347):\n\tExternal calls:\n\t- initializeAccountCollateralTokens(src) (FlashloanReceiver.sol#3284-3285)\n\t- initializeAccountCollateralTokens(dst) (FlashloanReceiver.sol#3285-3287)\n\tState variables written after the call(s):\n\t- accountCollateralTokens (FlashloanReceiver.sol#3285-3287)\n\t- isCollateralTokenInit (FlashloanReceiver.sol#3285-3287)\n\t- totalCollateralTokens (FlashloanReceiver.sol#3285-3287)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 3282,
          "vulnerability_to_line": 3347,
          "vulnerability_code": "    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (uint) {\n\n        // Make sure accountCollateralTokens of `src` and `dst` are initialized.\n\n        initializeAccountCollateralTokens(src);\n\n        initializeAccountCollateralTokens(dst);\n\n\n\n        /**\n\n         * For every user, accountTokens must be greater than or equal to accountCollateralTokens.\n\n         * The buffer between the two values will be transferred first.\n\n         * bufferTokens = accountTokens[src] - accountCollateralTokens[src]\n\n         * collateralTokens = tokens - bufferTokens\n\n         */\n\n        uint bufferTokens = sub_(accountTokens[src], accountCollateralTokens[src]);\n\n        uint collateralTokens = 0;\n\n        if (tokens > bufferTokens) {\n\n            collateralTokens = sub_(tokens, bufferTokens);\n\n        }\n\n\n\n        /**\n\n         * Since bufferTokens are not collateralized and can be transferred freely, we only check with comptroller\n\n         * whether collateralized tokens can be transferred.\n\n         */\n\n        uint allowed = comptroller.transferAllowed(address(this), src, dst, collateralTokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.TRANSFER_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Do not allow self-transfers */\n\n        if (src == dst) {\n\n            return fail(Error.BAD_INPUT, FailureInfo.TRANSFER_NOT_ALLOWED);\n\n        }\n\n\n\n        /* Get the allowance, infinite for the account owner */\n\n        uint startingAllowance = 0;\n\n        if (spender == src) {\n\n            startingAllowance = uint(-1);\n\n        } else {\n\n            startingAllowance = transferAllowances[src][spender];\n\n        }\n\n\n\n        /* Do the calculations, checking for {under,over}flow */\n\n        uint allowanceNew = sub_(startingAllowance, tokens);\n\n        accountTokens[src] = sub_(accountTokens[src], tokens);\n\n        accountTokens[dst] = add_(accountTokens[dst], tokens);\n\n        if (collateralTokens > 0) {\n\n            accountCollateralTokens[src] = sub_(accountCollateralTokens[src], collateralTokens);\n\n            accountCollateralTokens[dst] = add_(accountCollateralTokens[dst], collateralTokens);\n\n\n\n            emit UserCollateralChanged(src, accountCollateralTokens[src]);\n\n            emit UserCollateralChanged(dst, accountCollateralTokens[dst]);\n\n        }\n\n\n\n        /* Eat some of the allowance (if necessary) */\n\n        if (startingAllowance != uint(-1)) {\n\n            transferAllowances[src][spender] = allowanceNew;\n\n        }\n\n\n\n        /* We emit a Transfer event */\n\n        emit Transfer(src, dst, tokens);\n\n\n\n        // unused function\n\n        // comptroller.transferVerify(address(this), src, dst, tokens);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Reentrancy in CCollateralCapErc20.transferTokens (FlashloanReceiver.sol#3282-3347):\n\tExternal calls:\n\t- initializeAccountCollateralTokens(src) (FlashloanReceiver.sol#3284-3285)\n\t- initializeAccountCollateralTokens(dst) (FlashloanReceiver.sol#3285-3287)\n\t- allowed = comptroller.transferAllowed(address(this),src,dst,collateralTokens) (FlashloanReceiver.sol#3303-3304)\n\tState variables written after the call(s):\n\t- accountCollateralTokens (FlashloanReceiver.sol#3326-3327)\n\t- accountCollateralTokens (FlashloanReceiver.sol#3327-3329)\n\t- accountTokens (FlashloanReceiver.sol#3323-3324)\n\t- accountTokens (FlashloanReceiver.sol#3324-3325)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 3150,
          "vulnerability_to_line": 3159,
          "vulnerability_code": "    function unregisterCollateral(address account) external {\n\n        // Make sure accountCollateralTokens of `account` is initialized.\n\n        initializeAccountCollateralTokens(account);\n\n\n\n        require(msg.sender == address(comptroller), \"only comptroller may unregister collateral for user\");\n\n\n\n        decreaseUserCollateralInternal(account, accountCollateralTokens[account]);\n\n    }\n\n\n",
          "message": "Reentrancy in CCollateralCapErc20.unregisterCollateral (FlashloanReceiver.sol#3150-3159):\n\tExternal calls:\n\t- initializeAccountCollateralTokens(account) (FlashloanReceiver.sol#3152-3154)\n\t- decreaseUserCollateralInternal(account,accountCollateralTokens[account]) (FlashloanReceiver.sol#3156-3157)\n\tState variables written after the call(s):\n\t- accountCollateralTokens (FlashloanReceiver.sol#3156-3157)\n\t- totalCollateralTokens (FlashloanReceiver.sol#3156-3157)\n"
        },
        {
          "name": "uninitialized-local",
          "vulnerability_from_line": 3505,
          "vulnerability_to_line": 3507,
          "vulnerability_code": "        RedeemLocalVars memory vars;\n\n\n",
          "message": "vars in CCollateralCapErc20.redeemFresh (FlashloanReceiver.sol#3505-3507) is a local variable never initialiazed\n"
        },
        {
          "name": "uninitialized-local",
          "vulnerability_from_line": 3435,
          "vulnerability_to_line": 3437,
          "vulnerability_code": "        MintLocalVars memory vars;\n\n\n",
          "message": "vars in CCollateralCapErc20.mintFresh (FlashloanReceiver.sol#3435-3437) is a local variable never initialiazed\n"
        },
        {
          "name": "uninitialized-local",
          "vulnerability_from_line": 2560,
          "vulnerability_to_line": 2562,
          "vulnerability_code": "        uint actualAddAmount;\n\n\n",
          "message": "actualAddAmount in CToken._addReservesFresh (FlashloanReceiver.sol#2560-2562) is a local variable never initialiazed\n"
        },
        {
          "name": "uninitialized-local",
          "vulnerability_from_line": 2145,
          "vulnerability_to_line": null,
          "vulnerability_code": "        BorrowLocalVars memory vars;\n",
          "message": "vars in CToken.borrowFresh (FlashloanReceiver.sol#2145) is a local variable never initialiazed\n"
        },
        {
          "name": "uninitialized-local",
          "vulnerability_from_line": 2244,
          "vulnerability_to_line": null,
          "vulnerability_code": "        RepayBorrowLocalVars memory vars;\n",
          "message": "vars in CToken.repayBorrowFresh (FlashloanReceiver.sol#2244) is a local variable never initialiazed\n"
        },
        {
          "name": "unused-return",
          "vulnerability_from_line": 2974,
          "vulnerability_to_line": 2989,
          "vulnerability_code": "    function initialize(address underlying_,\n\n                        ComptrollerInterface comptroller_,\n\n                        InterestRateModel interestRateModel_,\n\n                        uint initialExchangeRateMantissa_,\n\n                        string memory name_,\n\n                        string memory symbol_,\n\n                        uint8 decimals_) public {\n\n        // CToken initialize does the bulk of the work\n\n        super.initialize(comptroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_);\n\n\n\n        // Set underlying and sanity check it\n\n        underlying = underlying_;\n\n        EIP20Interface(underlying).totalSupply();\n\n    }\n\n\n",
          "message": "CCollateralCapErc20.initialize (FlashloanReceiver.sol#2974-2989) does not use the value returned by external calls:\n\t-EIP20Interface(underlying).totalSupply() (FlashloanReceiver.sol#2986-2987)\n"
        },
        {
          "name": "unused-return",
          "vulnerability_from_line": 3673,
          "vulnerability_to_line": 3679,
          "vulnerability_code": "    function executeOperation(address sender, address underlying, uint amount, uint fee, bytes calldata params) external {\n\n        address cToken = abi.decode(params, (address));\n\n        CCollateralCapErc20(cToken).mint(amount.add(fee));\n\n    }\n\n}\n\n\n",
          "message": "FlashloanAndMint.executeOperation (FlashloanReceiver.sol#3673-3679) does not use the value returned by external calls:\n\t-CCollateralCapErc20(cToken).mint(amount.add(fee)) (FlashloanReceiver.sol#3675-3676)\n"
        },
        {
          "name": "unused-return",
          "vulnerability_from_line": 3687,
          "vulnerability_to_line": 3693,
          "vulnerability_code": "    function executeOperation(address sender, address underlying, uint amount, uint fee, bytes calldata params) external {\n\n        address cToken = abi.decode(params, (address));\n\n        CCollateralCapErc20(cToken).repayBorrow(amount.add(fee));\n\n    }\n\n}\n\n\n",
          "message": "FlashloanAndRepayBorrow.executeOperation (FlashloanReceiver.sol#3687-3693) does not use the value returned by external calls:\n\t-CCollateralCapErc20(cToken).repayBorrow(amount.add(fee)) (FlashloanReceiver.sol#3689-3690)\n"
        },
        {
          "name": "shadowing-local",
          "vulnerability_from_line": 1273,
          "vulnerability_to_line": null,
          "vulnerability_code": "        (MathError err, Exp memory fraction) = divScalarByExp(scalar, divisor);\n",
          "message": "Exponential.divScalarByExpTruncate.fraction (local variable @ FlashloanReceiver.sol#1273) shadows:\n\t- Exponential.fraction (function @ FlashloanReceiver.sol#1503-1505)\n"
        },
        {
          "name": "shadowing-local",
          "vulnerability_from_line": 1302,
          "vulnerability_to_line": null,
          "vulnerability_code": "        Exp memory fraction = div_ScalarByExp(scalar, divisor);\n",
          "message": "Exponential.div_ScalarByExpTruncate.fraction (local variable @ FlashloanReceiver.sol#1302) shadows:\n\t- Exponential.fraction (function @ FlashloanReceiver.sol#1503-1505)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 2128,
          "vulnerability_to_line": 2181,
          "vulnerability_code": "    function borrowFresh(address payable borrower, uint borrowAmount) internal returns (uint) {\n\n        /* Fail if borrow not allowed */\n\n        uint allowed = comptroller.borrowAllowed(address(this), borrower, borrowAmount);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.BORROW_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.BORROW_FRESHNESS_CHECK);\n\n        }\n\n\n\n        /* Fail gracefully if protocol has insufficient underlying cash */\n\n        if (getCashPrior() < borrowAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.BORROW_CASH_NOT_AVAILABLE);\n\n        }\n\n\n\n        BorrowLocalVars memory vars;\n\n\n\n        /*\n\n         * We calculate the new borrower and total borrow balances, failing on overflow:\n\n         *  accountBorrowsNew = accountBorrows + borrowAmount\n\n         *  totalBorrowsNew = totalBorrows + borrowAmount\n\n         */\n\n        vars.accountBorrows = borrowBalanceStoredInternal(borrower);\n\n        vars.accountBorrowsNew = add_(vars.accountBorrows, borrowAmount);\n\n        vars.totalBorrowsNew = add_(totalBorrows, borrowAmount);\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We invoke doTransferOut for the borrower and the borrowAmount.\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken borrowAmount less of cash.\n\n         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n\n         */\n\n        doTransferOut(borrower, borrowAmount);\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n\n        accountBorrows[borrower].interestIndex = borrowIndex;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n\n\n        /* We emit a Borrow event */\n\n        emit Borrow(borrower, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n\n\n        /* We call the defense hook */\n\n        // unused function\n\n        // comptroller.borrowVerify(address(this), borrower, borrowAmount);\n\n\n\n        return uint(Error.NO_ERROR);\n",
          "message": "Reentrancy in CToken.borrowFresh (FlashloanReceiver.sol#2128-2181):\n\tExternal calls:\n\t- allowed = comptroller.borrowAllowed(address(this),borrower,borrowAmount) (FlashloanReceiver.sol#2130)\n\tState variables written after the call(s):\n\t- accountBorrows (FlashloanReceiver.sol#2169)\n\t- accountBorrows (FlashloanReceiver.sol#2170)\n\t- totalBorrows (FlashloanReceiver.sol#2171)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 3398,
          "vulnerability_to_line": 3407,
          "vulnerability_code": "    function decreaseUserCollateralInternal(address account, uint amount) internal {\n\n        require(comptroller.redeemAllowed(address(this), account, amount) == 0, \"comptroller rejection\");\n\n\n\n        totalCollateralTokens = sub_(totalCollateralTokens, amount);\n\n        accountCollateralTokens[account] = sub_(accountCollateralTokens[account], amount);\n\n\n\n        emit UserCollateralChanged(account, accountCollateralTokens[account]);\n\n    }\n\n\n",
          "message": "Reentrancy in CCollateralCapErc20.decreaseUserCollateralInternal (FlashloanReceiver.sol#3398-3407):\n\tExternal calls:\n\t- require(bool,string)(comptroller.redeemAllowed(address(this),account,amount) == 0,comptroller rejection) (FlashloanReceiver.sol#3399-3401)\n\tState variables written after the call(s):\n\t- accountCollateralTokens (FlashloanReceiver.sol#3402-3404)\n\t- totalCollateralTokens (FlashloanReceiver.sol#3401-3402)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 3214,
          "vulnerability_to_line": 3242,
          "vulnerability_code": "    function doTransferIn(address from, uint amount) internal returns (uint) {\n\n        EIP20NonStandardInterface token = EIP20NonStandardInterface(underlying);\n\n        uint balanceBefore = EIP20Interface(underlying).balanceOf(address(this));\n\n        token.transferFrom(from, address(this), amount);\n\n\n\n        bool success;\n\n        assembly {\n\n            switch returndatasize()\n\n                case 0 {                       // This is a non-standard ERC-20\n\n                    success := not(0)          // set success to true\n\n                }\n\n                case 32 {                      // This is a compliant ERC-20\n\n                    returndatacopy(0, 0, 32)\n\n                    success := mload(0)        // Set `success = returndata` of external call\n\n                }\n\n                default {                      // This is an excessively non-compliant ERC-20, revert.\n\n                    revert(0, 0)\n\n                }\n\n        }\n\n        require(success, \"TOKEN_TRANSFER_IN_FAILED\");\n\n\n\n        // Calculate the amount that was *actually* transferred\n\n        uint balanceAfter = EIP20Interface(underlying).balanceOf(address(this));\n\n        uint transferredIn = sub_(balanceAfter, balanceBefore);\n\n        internalCash = add_(internalCash, transferredIn);\n\n        return transferredIn;\n\n    }\n\n\n",
          "message": "Reentrancy in CCollateralCapErc20.doTransferIn (FlashloanReceiver.sol#3214-3242):\n\tExternal calls:\n\t- balanceBefore = EIP20Interface(underlying).balanceOf(address(this)) (FlashloanReceiver.sol#3216-3217)\n\t- token.transferFrom(from,address(this),amount) (FlashloanReceiver.sol#3217-3219)\n\t- balanceAfter = EIP20Interface(underlying).balanceOf(address(this)) (FlashloanReceiver.sol#3236-3237)\n\tState variables written after the call(s):\n\t- internalCash (FlashloanReceiver.sol#3238-3239)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 3251,
          "vulnerability_to_line": 3273,
          "vulnerability_code": "    function doTransferOut(address payable to, uint amount) internal {\n\n        EIP20NonStandardInterface token = EIP20NonStandardInterface(underlying);\n\n        token.transfer(to, amount);\n\n\n\n        bool success;\n\n        assembly {\n\n            switch returndatasize()\n\n                case 0 {                      // This is a non-standard ERC-20\n\n                    success := not(0)          // set success to true\n\n                }\n\n                case 32 {                     // This is a complaint ERC-20\n\n                    returndatacopy(0, 0, 32)\n\n                    success := mload(0)        // Set `success = returndata` of external call\n\n                }\n\n                default {                     // This is an excessively non-compliant ERC-20, revert.\n\n                    revert(0, 0)\n\n                }\n\n        }\n\n        require(success, \"TOKEN_TRANSFER_OUT_FAILED\");\n\n        internalCash = sub_(internalCash, amount);\n\n    }\n\n\n",
          "message": "Reentrancy in CCollateralCapErc20.doTransferOut (FlashloanReceiver.sol#3251-3273):\n\tExternal calls:\n\t- token.transfer(to,amount) (FlashloanReceiver.sol#3253-3255)\n\tState variables written after the call(s):\n\t- internalCash (FlashloanReceiver.sol#3270-3271)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 3103,
          "vulnerability_to_line": 3129,
          "vulnerability_code": "    function flashLoan(address receiver, uint amount, bytes calldata params) external nonReentrant {\n\n        uint cashOnChainBefore = getCashOnChain();\n\n        uint cashBefore = getCashPrior();\n\n        require(cashBefore >= amount, \"INSUFFICIENT_LIQUIDITY\");\n\n\n\n        // 1. calculate fee, 1 bips = 1/10000\n\n        uint totalFee = div_(mul_(amount, flashFeeBips), 10000);\n\n\n\n        // 2. transfer fund to receiver\n\n        doTransferOut(address(uint160(receiver)), amount);\n\n\n\n        // 3. execute receiver's callback function\n\n        IFlashloanReceiver(receiver).executeOperation(msg.sender, underlying, amount, totalFee, params);\n\n\n\n        // 4. check balance\n\n        uint cashOnChainAfter = getCashOnChain();\n\n        require(cashOnChainAfter == add_(cashOnChainBefore, totalFee), \"BALANCE_INCONSISTENT\");\n\n\n\n        // 5. update reserves and internal cash\n\n        uint reservesFee = mul_ScalarTruncate(Exp({mantissa: reserveFactorMantissa}), totalFee);\n\n        totalReserves = add_(totalReserves, reservesFee);\n\n        internalCash = add_(cashBefore, totalFee);\n\n\n\n        emit Flashloan(receiver, amount, totalFee, reservesFee);\n\n    }\n\n\n",
          "message": "Reentrancy in CCollateralCapErc20.flashLoan (FlashloanReceiver.sol#3103-3129):\n\tExternal calls:\n\t- cashOnChainBefore = getCashOnChain() (FlashloanReceiver.sol#3104-3105)\n\t- doTransferOut(address(uint160(receiver)),amount) (FlashloanReceiver.sol#3112-3114)\n\t- IFlashloanReceiver(receiver).executeOperation(msg.sender,underlying,amount,totalFee,params) (FlashloanReceiver.sol#3115-3117)\n\t- cashOnChainAfter = getCashOnChain() (FlashloanReceiver.sol#3118-3119)\n\tState variables written after the call(s):\n\t- totalReserves (FlashloanReceiver.sol#3123-3124)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 3088,
          "vulnerability_to_line": 3097,
          "vulnerability_code": "    function gulp() external nonReentrant {\n\n        uint256 cashOnChain = getCashOnChain();\n\n        uint256 cashPrior = getCashPrior();\n\n\n\n        uint excessCash = sub_(cashOnChain, cashPrior);\n\n        totalReserves = add_(totalReserves, excessCash);\n\n        internalCash = cashOnChain;\n\n    }\n\n\n",
          "message": "Reentrancy in CCollateralCapErc20.gulp (FlashloanReceiver.sol#3088-3097):\n\tExternal calls:\n\t- cashOnChain = getCashOnChain() (FlashloanReceiver.sol#3089-3090)\n\tState variables written after the call(s):\n\t- internalCash (FlashloanReceiver.sol#3094-3095)\n\t- totalReserves (FlashloanReceiver.sol#3093-3094)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 1717,
          "vulnerability_to_line": 1748,
          "vulnerability_code": "    function initialize(ComptrollerInterface comptroller_,\n\n                        InterestRateModel interestRateModel_,\n\n                        uint initialExchangeRateMantissa_,\n\n                        string memory name_,\n\n                        string memory symbol_,\n\n                        uint8 decimals_) public {\n\n        require(msg.sender == admin, \"only admin may initialize the market\");\n\n        require(accrualBlockNumber == 0 && borrowIndex == 0, \"market may only be initialized once\");\n\n\n\n        // Set initial exchange rate\n\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n\n        require(initialExchangeRateMantissa > 0, \"initial exchange rate must be greater than zero.\");\n\n\n\n        // Set the comptroller\n\n        uint err = _setComptroller(comptroller_);\n\n        require(err == uint(Error.NO_ERROR), \"setting comptroller failed\");\n\n\n\n        // Initialize block number and borrow index (block number mocks depend on comptroller being set)\n\n        accrualBlockNumber = getBlockNumber();\n\n        borrowIndex = mantissaOne;\n\n\n\n        // Set the interest rate model (depends on block number / borrow index)\n\n        err = _setInterestRateModelFresh(interestRateModel_);\n\n        require(err == uint(Error.NO_ERROR), \"setting interest rate model failed\");\n\n\n\n        name = name_;\n\n        symbol = symbol_;\n\n        decimals = decimals_;\n\n\n\n        // The counter starts true to prevent changing it from zero to non-zero (i.e. smaller cost/refund)\n\n        _notEntered = true;\n",
          "message": "Reentrancy in CToken.initialize (FlashloanReceiver.sol#1717-1748):\n\tExternal calls:\n\t- err = _setComptroller(comptroller_) (FlashloanReceiver.sol#1731)\n\t- err = _setInterestRateModelFresh(interestRateModel_) (FlashloanReceiver.sol#1739)\n\tState variables written after the call(s):\n\t- _notEntered (FlashloanReceiver.sol#1747)\n\t- decimals (FlashloanReceiver.sol#1744)\n\t- name (FlashloanReceiver.sol#1742)\n\t- symbol (FlashloanReceiver.sol#1743)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 2974,
          "vulnerability_to_line": 2989,
          "vulnerability_code": "    function initialize(address underlying_,\n\n                        ComptrollerInterface comptroller_,\n\n                        InterestRateModel interestRateModel_,\n\n                        uint initialExchangeRateMantissa_,\n\n                        string memory name_,\n\n                        string memory symbol_,\n\n                        uint8 decimals_) public {\n\n        // CToken initialize does the bulk of the work\n\n        super.initialize(comptroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_);\n\n\n\n        // Set underlying and sanity check it\n\n        underlying = underlying_;\n\n        EIP20Interface(underlying).totalSupply();\n\n    }\n\n\n",
          "message": "Reentrancy in CCollateralCapErc20.initialize (FlashloanReceiver.sol#2974-2989):\n\tExternal calls:\n\t- super.initialize(comptroller_,interestRateModel_,initialExchangeRateMantissa_,name_,symbol_,decimals_) (FlashloanReceiver.sol#2982-2984)\n\tState variables written after the call(s):\n\t- underlying (FlashloanReceiver.sol#2985-2986)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 3186,
          "vulnerability_to_line": 3205,
          "vulnerability_code": "    function initializeAccountCollateralTokens(address account) internal {\n\n        /**\n\n         * If isCollateralTokenInit is false, it means accountCollateralTokens was not initialized yet.\n\n         * This case will only happen once and must be the very beginning. accountCollateralTokens is a new structure and its\n\n         * initial value should be equal to accountTokens if user has entered the market. However, it's almost impossible to\n\n         * check every user's value when the implementation becomes active. Therefore, it must rely on every action which will\n\n         * access accountTokens to call this function to check if accountCollateralTokens needed to be initialized.\n\n         */\n\n        if (!isCollateralTokenInit[account]) {\n\n            if (ComptrollerInterfaceExtension(address(comptroller)).checkMembership(account, CToken(this))) {\n\n                accountCollateralTokens[account] = accountTokens[account];\n\n                totalCollateralTokens = add_(totalCollateralTokens, accountTokens[account]);\n\n\n\n                emit UserCollateralChanged(account, accountCollateralTokens[account]);\n\n            }\n\n            isCollateralTokenInit[account] = true;\n\n        }\n\n    }\n\n\n",
          "message": "Reentrancy in CCollateralCapErc20.initializeAccountCollateralTokens (FlashloanReceiver.sol#3186-3205):\n\tExternal calls:\n\t- ComptrollerInterfaceExtension(address(comptroller)).checkMembership(account,CToken(this)) (FlashloanReceiver.sol#3195-3201)\n\tState variables written after the call(s):\n\t- accountCollateralTokens (FlashloanReceiver.sol#3196-3197)\n\t- totalCollateralTokens (FlashloanReceiver.sol#3197-3199)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 2232,
          "vulnerability_to_line": 2293,
          "vulnerability_code": "    function repayBorrowFresh(address payer, address borrower, uint repayAmount) internal returns (uint, uint) {\n\n        /* Fail if repayBorrow not allowed */\n\n        uint allowed = comptroller.repayBorrowAllowed(address(this), payer, borrower, repayAmount);\n\n        if (allowed != 0) {\n\n            return (failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REPAY_BORROW_COMPTROLLER_REJECTION, allowed), 0);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return (fail(Error.MARKET_NOT_FRESH, FailureInfo.REPAY_BORROW_FRESHNESS_CHECK), 0);\n\n        }\n\n\n\n        RepayBorrowLocalVars memory vars;\n\n\n\n        /* We remember the original borrowerIndex for verification purposes */\n\n        vars.borrowerIndex = accountBorrows[borrower].interestIndex;\n\n\n\n        /* We fetch the amount the borrower owes, with accumulated interest */\n\n        vars.accountBorrows = borrowBalanceStoredInternal(borrower);\n\n\n\n        /* If repayAmount == -1, repayAmount = accountBorrows */\n\n        if (repayAmount == uint(-1)) {\n\n            vars.repayAmount = vars.accountBorrows;\n\n        } else {\n\n            vars.repayAmount = repayAmount;\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We call doTransferIn for the payer and the repayAmount\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken holds an additional repayAmount of cash.\n\n         *  doTransferIn reverts if anything goes wrong, since we can't be sure if side effects occurred.\n\n         *   it returns the amount actually transferred, in case of a fee.\n\n         */\n\n        vars.actualRepayAmount = doTransferIn(payer, vars.repayAmount);\n\n\n\n        /*\n\n         * We calculate the new borrower and total borrow balances, failing on underflow:\n\n         *  accountBorrowsNew = accountBorrows - actualRepayAmount\n\n         *  totalBorrowsNew = totalBorrows - actualRepayAmount\n\n         */\n\n        vars.accountBorrowsNew = sub_(vars.accountBorrows, vars.actualRepayAmount);\n\n        vars.totalBorrowsNew = sub_(totalBorrows, vars.actualRepayAmount);\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n\n        accountBorrows[borrower].interestIndex = borrowIndex;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n\n\n        /* We emit a RepayBorrow event */\n\n        emit RepayBorrow(payer, borrower, vars.actualRepayAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n\n\n        /* We call the defense hook */\n\n        // unused function\n\n        // comptroller.repayBorrowVerify(address(this), payer, borrower, vars.actualRepayAmount, vars.borrowerIndex);\n\n\n\n        return (uint(Error.NO_ERROR), vars.actualRepayAmount);\n",
          "message": "Reentrancy in CToken.repayBorrowFresh (FlashloanReceiver.sol#2232-2293):\n\tExternal calls:\n\t- allowed = comptroller.repayBorrowAllowed(address(this),payer,borrower,repayAmount) (FlashloanReceiver.sol#2234)\n\tState variables written after the call(s):\n\t- accountBorrows (FlashloanReceiver.sol#2281)\n\t- accountBorrows (FlashloanReceiver.sol#2282)\n\t- totalBorrows (FlashloanReceiver.sol#2283)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 3282,
          "vulnerability_to_line": 3347,
          "vulnerability_code": "    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (uint) {\n\n        // Make sure accountCollateralTokens of `src` and `dst` are initialized.\n\n        initializeAccountCollateralTokens(src);\n\n        initializeAccountCollateralTokens(dst);\n\n\n\n        /**\n\n         * For every user, accountTokens must be greater than or equal to accountCollateralTokens.\n\n         * The buffer between the two values will be transferred first.\n\n         * bufferTokens = accountTokens[src] - accountCollateralTokens[src]\n\n         * collateralTokens = tokens - bufferTokens\n\n         */\n\n        uint bufferTokens = sub_(accountTokens[src], accountCollateralTokens[src]);\n\n        uint collateralTokens = 0;\n\n        if (tokens > bufferTokens) {\n\n            collateralTokens = sub_(tokens, bufferTokens);\n\n        }\n\n\n\n        /**\n\n         * Since bufferTokens are not collateralized and can be transferred freely, we only check with comptroller\n\n         * whether collateralized tokens can be transferred.\n\n         */\n\n        uint allowed = comptroller.transferAllowed(address(this), src, dst, collateralTokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.TRANSFER_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Do not allow self-transfers */\n\n        if (src == dst) {\n\n            return fail(Error.BAD_INPUT, FailureInfo.TRANSFER_NOT_ALLOWED);\n\n        }\n\n\n\n        /* Get the allowance, infinite for the account owner */\n\n        uint startingAllowance = 0;\n\n        if (spender == src) {\n\n            startingAllowance = uint(-1);\n\n        } else {\n\n            startingAllowance = transferAllowances[src][spender];\n\n        }\n\n\n\n        /* Do the calculations, checking for {under,over}flow */\n\n        uint allowanceNew = sub_(startingAllowance, tokens);\n\n        accountTokens[src] = sub_(accountTokens[src], tokens);\n\n        accountTokens[dst] = add_(accountTokens[dst], tokens);\n\n        if (collateralTokens > 0) {\n\n            accountCollateralTokens[src] = sub_(accountCollateralTokens[src], collateralTokens);\n\n            accountCollateralTokens[dst] = add_(accountCollateralTokens[dst], collateralTokens);\n\n\n\n            emit UserCollateralChanged(src, accountCollateralTokens[src]);\n\n            emit UserCollateralChanged(dst, accountCollateralTokens[dst]);\n\n        }\n\n\n\n        /* Eat some of the allowance (if necessary) */\n\n        if (startingAllowance != uint(-1)) {\n\n            transferAllowances[src][spender] = allowanceNew;\n\n        }\n\n\n\n        /* We emit a Transfer event */\n\n        emit Transfer(src, dst, tokens);\n\n\n\n        // unused function\n\n        // comptroller.transferVerify(address(this), src, dst, tokens);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Reentrancy in CCollateralCapErc20.transferTokens (FlashloanReceiver.sol#3282-3347):\n\tExternal calls:\n\t- initializeAccountCollateralTokens(src) (FlashloanReceiver.sol#3284-3285)\n\t- initializeAccountCollateralTokens(dst) (FlashloanReceiver.sol#3285-3287)\n\t- allowed = comptroller.transferAllowed(address(this),src,dst,collateralTokens) (FlashloanReceiver.sol#3303-3304)\n\tState variables written after the call(s):\n\t- transferAllowances (FlashloanReceiver.sol#3335-3336)\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 3214,
          "vulnerability_to_line": 3242,
          "vulnerability_code": "    function doTransferIn(address from, uint amount) internal returns (uint) {\n\n        EIP20NonStandardInterface token = EIP20NonStandardInterface(underlying);\n\n        uint balanceBefore = EIP20Interface(underlying).balanceOf(address(this));\n\n        token.transferFrom(from, address(this), amount);\n\n\n\n        bool success;\n\n        assembly {\n\n            switch returndatasize()\n\n                case 0 {                       // This is a non-standard ERC-20\n\n                    success := not(0)          // set success to true\n\n                }\n\n                case 32 {                      // This is a compliant ERC-20\n\n                    returndatacopy(0, 0, 32)\n\n                    success := mload(0)        // Set `success = returndata` of external call\n\n                }\n\n                default {                      // This is an excessively non-compliant ERC-20, revert.\n\n                    revert(0, 0)\n\n                }\n\n        }\n\n        require(success, \"TOKEN_TRANSFER_IN_FAILED\");\n\n\n\n        // Calculate the amount that was *actually* transferred\n\n        uint balanceAfter = EIP20Interface(underlying).balanceOf(address(this));\n\n        uint transferredIn = sub_(balanceAfter, balanceBefore);\n\n        internalCash = add_(internalCash, transferredIn);\n\n        return transferredIn;\n\n    }\n\n\n",
          "message": "CCollateralCapErc20.doTransferIn uses assembly (FlashloanReceiver.sol#3214-3242)\n\t- FlashloanReceiver.sol#3220-3233\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 3251,
          "vulnerability_to_line": 3273,
          "vulnerability_code": "    function doTransferOut(address payable to, uint amount) internal {\n\n        EIP20NonStandardInterface token = EIP20NonStandardInterface(underlying);\n\n        token.transfer(to, amount);\n\n\n\n        bool success;\n\n        assembly {\n\n            switch returndatasize()\n\n                case 0 {                      // This is a non-standard ERC-20\n\n                    success := not(0)          // set success to true\n\n                }\n\n                case 32 {                     // This is a complaint ERC-20\n\n                    returndatacopy(0, 0, 32)\n\n                    success := mload(0)        // Set `success = returndata` of external call\n\n                }\n\n                default {                     // This is an excessively non-compliant ERC-20, revert.\n\n                    revert(0, 0)\n\n                }\n\n        }\n\n        require(success, \"TOKEN_TRANSFER_OUT_FAILED\");\n\n        internalCash = sub_(internalCash, amount);\n\n    }\n\n\n",
          "message": "CCollateralCapErc20.doTransferOut uses assembly (FlashloanReceiver.sol#3251-3273)\n\t- FlashloanReceiver.sol#3256-3269\n"
        },
        {
          "name": "constable-states",
          "vulnerability_from_line": 592,
          "vulnerability_to_line": null,
          "vulnerability_code": "    address public implementation;\n",
          "message": "CErc20Storage.implementation should be constant (FlashloanReceiver.sol#592)\nComptrollerV1Storage.closeFactorMantissa should be constant (FlashloanReceiver.sol#2827-2829)\nComptrollerV1Storage.liquidationIncentiveMantissa should be constant (FlashloanReceiver.sol#2832-2834)\nComptrollerV1Storage.maxAssets should be constant (FlashloanReceiver.sol#2837-2839)\nComptrollerV2Storage._borrowGuardianPaused should be constant (FlashloanReceiver.sol#2887-2888)\nComptrollerV2Storage._mintGuardianPaused should be constant (FlashloanReceiver.sol#2886-2887)\nComptrollerV2Storage.pauseGuardian should be constant (FlashloanReceiver.sol#2885-2886)\nComptrollerV2Storage.seizeGuardianPaused should be constant (FlashloanReceiver.sol#2889-2890)\nComptrollerV2Storage.transferGuardianPaused should be constant (FlashloanReceiver.sol#2888-2889)\nComptrollerV3Storage.compRate should be constant (FlashloanReceiver.sol#2907-2909)\nComptrollerV4Storage.borrowCapGuardian should be constant (FlashloanReceiver.sol#2930-2932)\nComptrollerV5Storage.supplyCapGuardian should be constant (FlashloanReceiver.sol#2938-2940)\nUnitrollerAdminStorage.admin should be constant (FlashloanReceiver.sol#2799-2801)\nUnitrollerAdminStorage.comptrollerImplementation should be constant (FlashloanReceiver.sol#2809-2811)\nUnitrollerAdminStorage.pendingAdmin should be constant (FlashloanReceiver.sol#2804-2806)\nUnitrollerAdminStorage.pendingComptrollerImplementation should be constant (FlashloanReceiver.sol#2814-2817)\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 311,
          "vulnerability_to_line": 313,
          "vulnerability_code": "    function harnessSetFailTransferFromAddress(address src, bool _fail) public {\n\n        failTransferFromAddresses[src] = _fail;\n",
          "message": "ERC20Harness.harnessSetFailTransferFromAddress (FlashloanReceiver.sol#311-313) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 315,
          "vulnerability_to_line": 317,
          "vulnerability_code": "    function harnessSetFailTransferToAddress(address dst, bool _fail) public {\n\n        failTransferToAddresses[dst] = _fail;\n",
          "message": "ERC20Harness.harnessSetFailTransferToAddress (FlashloanReceiver.sol#315-317) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 319,
          "vulnerability_to_line": 321,
          "vulnerability_code": "    function harnessSetBalance(address _account, uint _amount) public {\n\n        balanceOf[_account] = _amount;\n",
          "message": "ERC20Harness.harnessSetBalance (FlashloanReceiver.sol#319-321) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 748,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint);\n",
          "message": "CTokenInterface._setInterestRateModel (FlashloanReceiver.sol#748) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 2662,
          "vulnerability_to_line": 2672,
          "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n\n        return _setInterestRateModelFresh(newInterestRateModel);\n\n    }\n\n\n",
          "message": "CToken._setInterestRateModel (FlashloanReceiver.sol#2662-2672) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 823,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setImplementation(address implementation_, bool allowResign, bytes memory becomeImplementationData) public;\n",
          "message": "CDelegatorInterface._setImplementation (FlashloanReceiver.sol#823) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 832,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _becomeImplementation(bytes memory data) public;\n",
          "message": "CDelegateInterface._becomeImplementation (FlashloanReceiver.sol#832) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 837,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _resignImplementation() public;\n",
          "message": "CDelegateInterface._resignImplementation (FlashloanReceiver.sol#837) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 2974,
          "vulnerability_to_line": 2989,
          "vulnerability_code": "    function initialize(address underlying_,\n\n                        ComptrollerInterface comptroller_,\n\n                        InterestRateModel interestRateModel_,\n\n                        uint initialExchangeRateMantissa_,\n\n                        string memory name_,\n\n                        string memory symbol_,\n\n                        uint8 decimals_) public {\n\n        // CToken initialize does the bulk of the work\n\n        super.initialize(comptroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_);\n\n\n\n        // Set underlying and sanity check it\n\n        underlying = underlying_;\n\n        EIP20Interface(underlying).totalSupply();\n\n    }\n\n\n",
          "message": "CCollateralCapErc20.initialize (FlashloanReceiver.sol#2974-2989) should be declared external\n"
        },
        {
          "name": "solc-version",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": "Detected issues with version pragma in FlashloanReceiver.sol:\n\t- pragma solidity^0.5.16 (FlashloanReceiver.sol#3): it allows old versions\n\t- pragma solidity^0.5.16 (FlashloanReceiver.sol#192): it allows old versions\n\t- pragma solidity^0.5.16 (FlashloanReceiver.sol#360): it allows old versions\n\t- pragma solidity^0.5.16 (FlashloanReceiver.sol#434): it allows old versions\n\t- pragma solidity^0.5.16 (FlashloanReceiver.sol#467): it allows old versions\n\t- pragma solidity^0.5.16 (FlashloanReceiver.sol#851): it allows old versions\n\t- pragma solidity^0.5.16 (FlashloanReceiver.sol#1037): it allows old versions\n\t- pragma solidity^0.5.16 (FlashloanReceiver.sol#1125): it allows old versions\n\t- pragma solidity^0.5.16 (FlashloanReceiver.sol#1556): it allows old versions\n\t- pragma solidity^0.5.16 (FlashloanReceiver.sol#1621): it allows old versions\n\t- pragma solidity^0.5.16 (FlashloanReceiver.sol#1694): it allows old versions\n\t- pragma solidity^0.5.16 (FlashloanReceiver.sol#2775-2777): it allows old versions\n\t- pragma solidity^0.5.16 (FlashloanReceiver.sol#2792-2795): it allows old versions\n\t- pragma solidity^0.5.16 (FlashloanReceiver.sol#2946-2949): it allows old versions\n\t- pragma solidity^0.5.16 (FlashloanReceiver.sol#3641-3645): it allows old versions\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 251,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function approve(address _spender, uint256 amount) external returns (bool) {\n",
          "message": "Parameter '_spender' of StandardToken.approve (FlashloanReceiver.sol#251) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 228,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor(uint256 _initialAmount, string memory _tokenName, uint8 _decimalUnits, string memory _tokenSymbol) public {\n",
          "message": "Parameter '_initialAmount' of StandardToken. (FlashloanReceiver.sol#228) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 228,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor(uint256 _initialAmount, string memory _tokenName, uint8 _decimalUnits, string memory _tokenSymbol) public {\n",
          "message": "Parameter '_tokenName' of StandardToken. (FlashloanReceiver.sol#228) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 228,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor(uint256 _initialAmount, string memory _tokenName, uint8 _decimalUnits, string memory _tokenSymbol) public {\n",
          "message": "Parameter '_decimalUnits' of StandardToken. (FlashloanReceiver.sol#228) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 228,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor(uint256 _initialAmount, string memory _tokenName, uint8 _decimalUnits, string memory _tokenSymbol) public {\n",
          "message": "Parameter '_tokenSymbol' of StandardToken. (FlashloanReceiver.sol#228) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 294,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function approve(address _spender, uint256 amount) external returns (bool) {\n",
          "message": "Parameter '_spender' of NonStandardToken.approve (FlashloanReceiver.sol#294) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 273,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor(uint256 _initialAmount, string memory _tokenName, uint8 _decimalUnits, string memory _tokenSymbol) public {\n",
          "message": "Parameter '_initialAmount' of NonStandardToken. (FlashloanReceiver.sol#273) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 273,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor(uint256 _initialAmount, string memory _tokenName, uint8 _decimalUnits, string memory _tokenSymbol) public {\n",
          "message": "Parameter '_tokenName' of NonStandardToken. (FlashloanReceiver.sol#273) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 273,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor(uint256 _initialAmount, string memory _tokenName, uint8 _decimalUnits, string memory _tokenSymbol) public {\n",
          "message": "Parameter '_decimalUnits' of NonStandardToken. (FlashloanReceiver.sol#273) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 273,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor(uint256 _initialAmount, string memory _tokenName, uint8 _decimalUnits, string memory _tokenSymbol) public {\n",
          "message": "Parameter '_tokenSymbol' of NonStandardToken. (FlashloanReceiver.sol#273) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 311,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function harnessSetFailTransferFromAddress(address src, bool _fail) public {\n",
          "message": "Parameter '_fail' of ERC20Harness.harnessSetFailTransferFromAddress (FlashloanReceiver.sol#311) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 315,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function harnessSetFailTransferToAddress(address dst, bool _fail) public {\n",
          "message": "Parameter '_fail' of ERC20Harness.harnessSetFailTransferToAddress (FlashloanReceiver.sol#315) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 319,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function harnessSetBalance(address _account, uint _amount) public {\n",
          "message": "Parameter '_account' of ERC20Harness.harnessSetBalance (FlashloanReceiver.sol#319) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 319,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function harnessSetBalance(address _account, uint _amount) public {\n",
          "message": "Parameter '_amount' of ERC20Harness.harnessSetBalance (FlashloanReceiver.sol#319) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 352,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor(uint256 _initialAmount, string memory _tokenName, uint8 _decimalUnits, string memory _tokenSymbol, address _comptroller) public\n",
          "message": "Parameter '_comptroller' of CTokenHarness. (FlashloanReceiver.sol#352) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 348,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bool public constant isCToken = true;\n",
          "message": "Constant 'CTokenHarness.isCToken' (FlashloanReceiver.sol#348) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 364,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bool public constant isComptroller = true;\n",
          "message": "Constant 'ComptrollerInterface.isComptroller' (FlashloanReceiver.sol#364) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 442,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bool public constant isInterestRateModel = true;\n",
          "message": "Constant 'InterestRateModel.isInterestRateModel' (FlashloanReceiver.sol#442) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 474,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bool internal _notEntered;\n",
          "message": "Variable 'CTokenStorage._notEntered' (FlashloanReceiver.sol#474) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 495,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint internal constant borrowRateMaxMantissa = 0.0005e16;\n",
          "message": "Constant 'CTokenStorage.borrowRateMaxMantissa' (FlashloanReceiver.sol#495) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 500,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint internal constant reserveFactorMaxMantissa = 1e18;\n",
          "message": "Constant 'CTokenStorage.reserveFactorMaxMantissa' (FlashloanReceiver.sol#500) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 743,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint);\n",
          "message": "Function 'CTokenInterface._setPendingAdmin' (FlashloanReceiver.sol#743) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 744,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _acceptAdmin() external returns (uint);\n",
          "message": "Function 'CTokenInterface._acceptAdmin' (FlashloanReceiver.sol#744) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 745,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setComptroller(ComptrollerInterface newComptroller) public returns (uint);\n",
          "message": "Function 'CTokenInterface._setComptroller' (FlashloanReceiver.sol#745) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 746,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setReserveFactor(uint newReserveFactorMantissa) external returns (uint);\n",
          "message": "Function 'CTokenInterface._setReserveFactor' (FlashloanReceiver.sol#746) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 747,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _reduceReserves(uint reduceAmount) external returns (uint);\n",
          "message": "Function 'CTokenInterface._reduceReserves' (FlashloanReceiver.sol#747) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 748,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint);\n",
          "message": "Function 'CTokenInterface._setInterestRateModel' (FlashloanReceiver.sol#748) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 631,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bool public constant isCToken = true;\n",
          "message": "Constant 'CTokenInterface.isCToken' (FlashloanReceiver.sol#631) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 765,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _addReserves(uint addAmount) external returns (uint);\n",
          "message": "Function 'CErc20Interface._addReserves' (FlashloanReceiver.sol#765) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 772,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint public constant flashFeeBips = 3;\n",
          "message": "Constant 'CCapableErc20Interface.flashFeeBips' (FlashloanReceiver.sol#772) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 808,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setCollateralCap(uint newCollateralCap) external;\n",
          "message": "Function 'CCollateralCapErc20Interface._setCollateralCap' (FlashloanReceiver.sol#808) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 823,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setImplementation(address implementation_, bool allowResign, bytes memory becomeImplementationData) public;\n",
          "message": "Function 'CDelegatorInterface._setImplementation' (FlashloanReceiver.sol#823) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 832,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _becomeImplementation(bytes memory data) public;\n",
          "message": "Function 'CDelegateInterface._becomeImplementation' (FlashloanReceiver.sol#832) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 837,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _resignImplementation() public;\n",
          "message": "Function 'CDelegateInterface._resignImplementation' (FlashloanReceiver.sol#837) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1224,
          "vulnerability_to_line": 1227,
          "vulnerability_code": "    function mul_ScalarTruncate(Exp memory a, uint scalar) pure internal returns (uint) {\n\n        Exp memory product = mul_(a, scalar);\n\n        return truncate(product);\n",
          "message": "Function 'Exponential.mul_ScalarTruncate' (FlashloanReceiver.sol#1224-1227) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1232,
          "vulnerability_to_line": 1235,
          "vulnerability_code": "    function mul_ScalarTruncateAddUInt(Exp memory a, uint scalar, uint addend) pure internal returns (uint) {\n\n        Exp memory product = mul_(a, scalar);\n\n        return add_(truncate(product), addend);\n",
          "message": "Function 'Exponential.mul_ScalarTruncateAddUInt' (FlashloanReceiver.sol#1232-1235) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1284,
          "vulnerability_to_line": 1296,
          "vulnerability_code": "    function div_ScalarByExp(uint scalar, Exp memory divisor) pure internal returns (Exp memory) {\n\n        /*\n\n          We are doing this as:\n\n          getExp(mulUInt(expScale, scalar), divisor.mantissa)\n\n\n\n          How it works:\n\n          Exp = a / b;\n\n          Scalar = s;\n\n          `s / (a / b)` = `b * s / a` and since for an Exp `a = mantissa, b = expScale`\n\n        */\n\n        uint numerator = mul_(expScale, scalar);\n\n        return Exp({mantissa: div_(numerator, divisor)});\n",
          "message": "Function 'Exponential.div_ScalarByExp' (FlashloanReceiver.sol#1284-1296) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1301,
          "vulnerability_to_line": 1304,
          "vulnerability_code": "    function div_ScalarByExpTruncate(uint scalar, Exp memory divisor) pure internal returns (uint) {\n\n        Exp memory fraction = div_ScalarByExp(scalar, divisor);\n\n        return truncate(fraction);\n",
          "message": "Function 'Exponential.div_ScalarByExpTruncate' (FlashloanReceiver.sol#1301-1304) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1135,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint constant expScale = 1e18;\n",
          "message": "Constant 'Exponential.expScale' (FlashloanReceiver.sol#1135) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1136,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint constant doubleScale = 1e36;\n",
          "message": "Constant 'Exponential.doubleScale' (FlashloanReceiver.sol#1136) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1137,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint constant halfExpScale = expScale/2;\n",
          "message": "Constant 'Exponential.halfExpScale' (FlashloanReceiver.sol#1137) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1138,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint constant mantissaOne = expScale;\n",
          "message": "Constant 'Exponential.mantissaOne' (FlashloanReceiver.sol#1138) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 2421,
          "vulnerability_to_line": 2437,
          "vulnerability_code": "    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint) {\n\n        // Check caller = admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);\n\n        }\n\n\n\n        // Save current value, if any, for inclusion in log\n\n        address oldPendingAdmin = pendingAdmin;\n\n\n\n        // Store pendingAdmin with value newPendingAdmin\n\n        pendingAdmin = newPendingAdmin;\n\n\n\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\n\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n\n\n\n        return uint(Error.NO_ERROR);\n",
          "message": "Function 'CToken._setPendingAdmin' (FlashloanReceiver.sol#2421-2437) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 2444,
          "vulnerability_to_line": 2466,
          "vulnerability_code": "    function _acceptAdmin() external returns (uint) {\n\n        // Check caller is pendingAdmin and pendingAdmin \u2260 address(0)\n\n        if (msg.sender != pendingAdmin || msg.sender == address(0)) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);\n\n        }\n\n\n\n        // Save current values for inclusion in log\n\n        address oldAdmin = admin;\n\n        address oldPendingAdmin = pendingAdmin;\n\n\n\n        // Store admin with value pendingAdmin\n\n        admin = pendingAdmin;\n\n\n\n        // Clear the pending value\n\n        pendingAdmin = address(0);\n\n\n\n        emit NewAdmin(oldAdmin, admin);\n\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Function 'CToken._acceptAdmin' (FlashloanReceiver.sol#2444-2466) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 2471,
          "vulnerability_to_line": 2490,
          "vulnerability_code": "    function _setComptroller(ComptrollerInterface newComptroller) public returns (uint) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COMPTROLLER_OWNER_CHECK);\n\n        }\n\n\n\n        ComptrollerInterface oldComptroller = comptroller;\n\n        // Ensure invoke comptroller.isComptroller() returns true\n\n        require(newComptroller.isComptroller(), \"marker method returned false\");\n\n\n\n        // Set market's comptroller to newComptroller\n\n        comptroller = newComptroller;\n\n\n\n        // Emit NewComptroller(oldComptroller, newComptroller)\n\n        emit NewComptroller(oldComptroller, newComptroller);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Function 'CToken._setComptroller' (FlashloanReceiver.sol#2471-2490) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 2495,
          "vulnerability_to_line": 2505,
          "vulnerability_code": "    function _setReserveFactor(uint newReserveFactorMantissa) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.\n\n            return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.\n\n        return _setReserveFactorFresh(newReserveFactorMantissa);\n\n    }\n\n\n",
          "message": "Function 'CToken._setReserveFactor' (FlashloanReceiver.sol#2495-2505) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 2599,
          "vulnerability_to_line": 2609,
          "vulnerability_code": "    function _reduceReserves(uint reduceAmount) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n\n            return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.\n\n        return _reduceReservesFresh(reduceAmount);\n\n    }\n\n\n",
          "message": "Function 'CToken._reduceReserves' (FlashloanReceiver.sol#2599-2609) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 2662,
          "vulnerability_to_line": 2672,
          "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n\n        return _setInterestRateModelFresh(newInterestRateModel);\n\n    }\n\n\n",
          "message": "Function 'CToken._setInterestRateModel' (FlashloanReceiver.sol#2662-2672) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 2510,
          "vulnerability_to_line": 2534,
          "vulnerability_code": "    function _setReserveFactorFresh(uint newReserveFactorMantissa) internal returns (uint) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_RESERVE_FACTOR_ADMIN_CHECK);\n\n        }\n\n\n\n        // Verify market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_RESERVE_FACTOR_FRESH_CHECK);\n\n        }\n\n\n\n        // Check newReserveFactor \u2264 maxReserveFactor\n\n        if (newReserveFactorMantissa > reserveFactorMaxMantissa) {\n\n            return fail(Error.BAD_INPUT, FailureInfo.SET_RESERVE_FACTOR_BOUNDS_CHECK);\n\n        }\n\n\n\n        uint oldReserveFactorMantissa = reserveFactorMantissa;\n\n        reserveFactorMantissa = newReserveFactorMantissa;\n\n\n\n        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Function 'CToken._setReserveFactorFresh' (FlashloanReceiver.sol#2510-2534) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 2539,
          "vulnerability_to_line": 2551,
          "vulnerability_code": "    function _addReservesInternal(uint addAmount) internal nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n\n            return fail(Error(error), FailureInfo.ADD_RESERVES_ACCRUE_INTEREST_FAILED);\n\n        }\n\n\n\n        // _addReservesFresh emits reserve-addition-specific logs on errors, so we don't need to.\n\n        (error, ) = _addReservesFresh(addAmount);\n\n        return error;\n\n    }\n\n\n",
          "message": "Function 'CToken._addReservesInternal' (FlashloanReceiver.sol#2539-2551) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 2557,
          "vulnerability_to_line": 2594,
          "vulnerability_code": "    function _addReservesFresh(uint addAmount) internal returns (uint, uint) {\n\n        // totalReserves + actualAddAmount\n\n        uint totalReservesNew;\n\n        uint actualAddAmount;\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return (fail(Error.MARKET_NOT_FRESH, FailureInfo.ADD_RESERVES_FRESH_CHECK), actualAddAmount);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We call doTransferIn for the caller and the addAmount\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken holds an additional addAmount of cash.\n\n         *  doTransferIn reverts if anything goes wrong, since we can't be sure if side effects occurred.\n\n         *  it returns the amount actually transferred, in case of a fee.\n\n         */\n\n\n\n        actualAddAmount = doTransferIn(msg.sender, addAmount);\n\n\n\n        totalReservesNew = add_(totalReserves, actualAddAmount);\n\n\n\n        // Store reserves[n+1] = reserves[n] + actualAddAmount\n\n        totalReserves = totalReservesNew;\n\n\n\n        /* Emit NewReserves(admin, actualAddAmount, reserves[n+1]) */\n\n        emit ReservesAdded(msg.sender, actualAddAmount, totalReservesNew);\n\n\n\n        /* Return (NO_ERROR, actualAddAmount) */\n\n        return (uint(Error.NO_ERROR), actualAddAmount);\n\n    }\n\n\n\n\n",
          "message": "Function 'CToken._addReservesFresh' (FlashloanReceiver.sol#2557-2594) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 2615,
          "vulnerability_to_line": 2656,
          "vulnerability_code": "    function _reduceReservesFresh(uint reduceAmount) internal returns (uint) {\n\n        // totalReserves - reduceAmount\n\n        uint totalReservesNew;\n\n\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.REDUCE_RESERVES_ADMIN_CHECK);\n\n        }\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDUCE_RESERVES_FRESH_CHECK);\n\n        }\n\n\n\n        // Fail gracefully if protocol has insufficient underlying cash\n\n        if (getCashPrior() < reduceAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDUCE_RESERVES_CASH_NOT_AVAILABLE);\n\n        }\n\n\n\n        // Check reduceAmount \u2264 reserves[n] (totalReserves)\n\n        if (reduceAmount > totalReserves) {\n\n            return fail(Error.BAD_INPUT, FailureInfo.REDUCE_RESERVES_VALIDATION);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        totalReservesNew = sub_(totalReserves, reduceAmount);\n\n\n\n        // Store reserves[n+1] = reserves[n] - reduceAmount\n\n        totalReserves = totalReservesNew;\n\n\n\n        // doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n\n        doTransferOut(admin, reduceAmount);\n\n\n\n        emit ReservesReduced(admin, reduceAmount, totalReservesNew);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Function 'CToken._reduceReservesFresh' (FlashloanReceiver.sol#2615-2656) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 2678,
          "vulnerability_to_line": 2708,
          "vulnerability_code": "    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {\n\n\n\n        // Used to store old model for use in the event that is emitted on success\n\n        InterestRateModel oldInterestRateModel;\n\n\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);\n\n        }\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);\n\n        }\n\n\n\n        // Track the market's current interest rate model\n\n        oldInterestRateModel = interestRateModel;\n\n\n\n        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true\n\n        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n\n\n\n        // Set the interest rate model to newInterestRateModel\n\n        interestRateModel = newInterestRateModel;\n\n\n\n        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)\n\n        emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Function 'CToken._setInterestRateModelFresh' (FlashloanReceiver.sol#2678-2708) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 2779,
          "vulnerability_to_line": 2781,
          "vulnerability_code": "    bool public constant isPriceOracle = true;\n\n\n",
          "message": "Constant 'PriceOracle.isPriceOracle' (FlashloanReceiver.sol#2779-2781) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 2886,
          "vulnerability_to_line": 2887,
          "vulnerability_code": "    bool public _mintGuardianPaused;\n",
          "message": "Variable 'ComptrollerV2Storage._mintGuardianPaused' (FlashloanReceiver.sol#2886-2887) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 2887,
          "vulnerability_to_line": 2888,
          "vulnerability_code": "    bool public _borrowGuardianPaused;\n",
          "message": "Variable 'ComptrollerV2Storage._borrowGuardianPaused' (FlashloanReceiver.sol#2887-2888) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 3070,
          "vulnerability_to_line": 3074,
          "vulnerability_code": "    function _addReserves(uint addAmount) external returns (uint) {\n\n        return _addReservesInternal(addAmount);\n\n    }\n\n\n",
          "message": "Function 'CCollateralCapErc20._addReserves' (FlashloanReceiver.sol#3070-3074) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 3078,
          "vulnerability_to_line": 3085,
          "vulnerability_code": "    function _setCollateralCap(uint newCollateralCap) external {\n\n        require(msg.sender == admin, \"only admin can set collateral cap\");\n\n\n\n        collateralCap = newCollateralCap;\n\n        emit NewCollateralCap(address(this), newCollateralCap);\n\n    }\n\n\n",
          "message": "Function 'CCollateralCapErc20._setCollateralCap' (FlashloanReceiver.sol#3078-3085) is not in mixedCase\n"
        }
      ]
    },
    "smartcheck": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 1514,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (xx >= 0x100000000000000000000000000000000) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 1518,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (xx >= 0x10000000000000000) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 1522,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (xx >= 0x100000000) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 1526,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (xx >= 0x10000) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 1530,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (xx >= 0x100) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 1534,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (xx >= 0x10) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 1538,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (xx >= 0x8) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ERC20_APPROVE",
          "vulnerability_from_line": 251,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function approve(address _spender, uint256 amount) external returns (bool) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ERC20_APPROVE",
          "vulnerability_from_line": 294,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function approve(address _spender, uint256 amount) external returns (bool) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ERC20_APPROVE",
          "vulnerability_from_line": 1779,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function approve(address spender, uint256 amount) external returns (bool) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_LOCKED_MONEY",
          "vulnerability_from_line": 627,
          "vulnerability_to_line": null,
          "vulnerability_code": "contract CTokenInterface is CTokenStorage {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 192,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 360,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 434,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 467,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 851,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 1037,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 1125,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 1556,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 1621,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 1694,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 2775,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 2792,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 2946,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 3641,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SAFEMATH",
          "vulnerability_from_line": 219,
          "vulnerability_to_line": null,
          "vulnerability_code": "    using SafeMath for uint256;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SAFEMATH",
          "vulnerability_from_line": 264,
          "vulnerability_to_line": null,
          "vulnerability_code": "    using SafeMath for uint256;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SAFEMATH",
          "vulnerability_from_line": 3647,
          "vulnerability_to_line": null,
          "vulnerability_code": "    using SafeMath for uint256;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SAFEMATH",
          "vulnerability_from_line": 3666,
          "vulnerability_to_line": null,
          "vulnerability_code": "    using SafeMath for uint256;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SAFEMATH",
          "vulnerability_from_line": 3680,
          "vulnerability_to_line": null,
          "vulnerability_code": "    using SafeMath for uint256;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SAFEMATH",
          "vulnerability_from_line": 3694,
          "vulnerability_to_line": null,
          "vulnerability_code": "    using SafeMath for uint256;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 429,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint repayAmount) external view returns (uint, uint);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 728,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 1060,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function mulUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 1077,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function divUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 1088,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function subUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 1099,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function addUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 1112,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function addThenSubUInt(uint a, uint b, uint c) internal pure returns (MathError, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 1153,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getExp(uint num, uint denom) pure internal returns (MathError, Exp memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 1170,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function addExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 1179,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function subExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 1188,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function mulScalar(Exp memory a, uint scalar) pure internal returns (MathError, Exp memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 1200,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function mulScalarTruncate(Exp memory a, uint scalar) pure internal returns (MathError, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 1212,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function mulScalarTruncateAddUInt(Exp memory a, uint scalar, uint addend) pure internal returns (MathError, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 1240,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function divScalar(Exp memory a, uint scalar) pure internal returns (MathError, Exp memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 1252,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function divScalarByExp(uint scalar, Exp memory divisor) pure internal returns (MathError, Exp memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 1272,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function divScalarByExpTruncate(uint scalar, Exp memory divisor) pure internal returns (MathError, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 1309,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function mulExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 1334,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function mulExp(uint a, uint b) pure internal returns (MathError, Exp memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 1341,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function mulExp3(Exp memory a, Exp memory b, Exp memory c) pure internal returns (MathError, Exp memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 1354,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function divExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 1822,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 2059,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function mintInternal(uint mintAmount) internal nonReentrant returns (uint, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 3220,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 743,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 2128,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function borrowFresh(address payable borrower, uint borrowAmount) internal returns (uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 3251,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function doTransferOut(address payable to, uint amount) internal {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 743,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1135,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint constant expScale = 1e18;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1136,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint constant doubleScale = 1e36;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1137,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint constant halfExpScale = expScale/2;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1138,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint constant mantissaOne = expScale;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 2128,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function borrowFresh(address payable borrower, uint borrowAmount) internal returns (uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 2128,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function borrowFresh(address payable borrower, uint borrowAmount) internal returns (uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 2128,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function borrowFresh(address payable borrower, uint borrowAmount) internal returns (uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 2130,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint allowed = comptroller.borrowAllowed(address(this), borrower, borrowAmount);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 2131,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (allowed != 0) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 2132,
          "vulnerability_to_line": null,
          "vulnerability_code": "            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.BORROW_COMPTROLLER_REJECTION, allowed);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 2132,
          "vulnerability_to_line": null,
          "vulnerability_code": "            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.BORROW_COMPTROLLER_REJECTION, allowed);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 3251,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function doTransferOut(address payable to, uint amount) internal {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 3251,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function doTransferOut(address payable to, uint amount) internal {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 3252,
          "vulnerability_to_line": null,
          "vulnerability_code": "        EIP20NonStandardInterface token = EIP20NonStandardInterface(underlying);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 3253,
          "vulnerability_to_line": null,
          "vulnerability_code": "        token.transfer(to, amount);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 3253,
          "vulnerability_to_line": null,
          "vulnerability_code": "        token.transfer(to, amount);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 3255,
          "vulnerability_to_line": null,
          "vulnerability_code": "        bool success;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 3257,
          "vulnerability_to_line": null,
          "vulnerability_code": "            switch returndatasize()\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 3257,
          "vulnerability_to_line": null,
          "vulnerability_code": "            switch returndatasize()\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 3259,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    success := not(0)          // set success to true\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 3259,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    success := not(0)          // set success to true\n",
          "message": null
        }
      ]
    },
    "oyente": {
      "successfull_analysis": false,
      "errors": [
        "exception (RuntimeError: Source map error, unknown name(SHR) or instr_name(INVALID))"
      ],
      "vulnerability_findings": []
    },
    "mythril": {
      "successfull_analysis": false,
      "errors": [
        "DOCKER_TIMEOUT"
      ],
      "vulnerability_findings": []
    },
    "osiris": {
      "successfull_analysis": false,
      "errors": [
        "Solidity compilation failed"
      ],
      "vulnerability_findings": []
    }
  }
}