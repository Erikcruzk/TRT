{
  "smartbugs_completed": true,
  "analyzer_results": {
    "semgrep": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 3765,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < assets.length; i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 4058,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < allMarkets.length; i ++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 4134,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < compMarketsToAdd.length; i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 4138,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < otherMarketsToAdd.length; i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 4161,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < allMarkets_.length; i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 4170,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < allMarkets_.length; i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 4181,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < allMarkets_.length; i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 4326,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < cTokens.length; i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 4332,
          "vulnerability_to_line": null,
          "vulnerability_code": "                for (uint j = 0; j < holders.length; j++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 4338,
          "vulnerability_to_line": null,
          "vulnerability_code": "                for (uint j = 0; j < holders.length; j++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 4368,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < cTokens.length; i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "inefficient-state-variable-increment",
          "vulnerability_from_line": 4459,
          "vulnerability_to_line": null,
          "vulnerability_code": "        blockNumber += blocks;\n",
          "message": "<x> += <y> costs more gas than <x> = <x> + <y> for state variables."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 2619,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor() public {\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 2620,
          "vulnerability_to_line": null,
          "vulnerability_code": "        // Set admin to caller\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 2621,
          "vulnerability_to_line": null,
          "vulnerability_code": "        admin = msg.sender;\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 2622,
          "vulnerability_to_line": null,
          "vulnerability_code": "    }\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 2801,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor(address account) public {\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 2802,
          "vulnerability_to_line": null,
          "vulnerability_code": "        balances[account] = uint96(totalSupply);\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 2803,
          "vulnerability_to_line": null,
          "vulnerability_code": "        emit Transfer(address(0), account, totalSupply);\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 2804,
          "vulnerability_to_line": null,
          "vulnerability_code": "    }\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 3126,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor() public {\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 3127,
          "vulnerability_to_line": null,
          "vulnerability_code": "        admin = msg.sender;\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 3128,
          "vulnerability_to_line": null,
          "vulnerability_code": "    }\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 4444,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor() ComptrollerG3() public {}\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 2949,
          "vulnerability_to_line": null,
          "vulnerability_code": "            Checkpoint memory cp = checkpoints[account][center];\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 3162,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < len; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 3247,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < len; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 3765,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < assets.length; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 4058,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < allMarkets.length; i ++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 4134,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < compMarketsToAdd.length; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 4138,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < otherMarketsToAdd.length; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 4161,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < allMarkets_.length; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 4170,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < allMarkets_.length; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 4181,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < allMarkets_.length; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 4326,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < cTokens.length; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 4332,
          "vulnerability_to_line": null,
          "vulnerability_code": "                for (uint j = 0; j < holders.length; j++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 4338,
          "vulnerability_to_line": null,
          "vulnerability_code": "                for (uint j = 0; j < holders.length; j++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 4368,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < cTokens.length; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 4475,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < m; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 4483,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < m; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1366,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == admin, \"only admin may initialize the market\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1367,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(accrualBlockNumber == 0 && borrowIndex == 0, \"market may only be initialized once\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1371,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(initialExchangeRateMantissa > 0, \"initial exchange rate must be greater than zero.\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1375,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(err == uint(Error.NO_ERROR), \"setting comptroller failed\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1383,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(err == uint(Error.NO_ERROR), \"setting interest rate model failed\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1539,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1549,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1591,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1660,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 2017,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(amountSeizeError == uint(Error.NO_ERROR), \"LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 2020,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(cTokenCollateral.balanceOf(borrower) >= seizeTokens, \"LIQUIDATE_SEIZE_TOO_MUCH\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 2031,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(seizeError == uint(Error.NO_ERROR), \"token seizure failed\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 2122,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(newComptroller.isComptroller(), \"marker method returned false\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 2340,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 2409,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_notEntered, \"re-entered\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 2904,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(signatory != address(0), \"Comp::delegateBySig: invalid signature\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 2905,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(nonce == nonces[signatory]++, \"Comp::delegateBySig: invalid nonce\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 2906,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(now <= expiry, \"Comp::delegateBySig: signature expired\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 2928,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(blockNumber < block.number, \"Comp::getPriorVotes: not yet determined\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 2972,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(src != address(0), \"Comp::_transferTokens: cannot transfer from the zero address\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 2973,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(dst != address(0), \"Comp::_transferTokens: cannot transfer to the zero address\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 3219,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(oErr == 0, \"exitMarket: getAccountSnapshot failed\"); // semi-opaque error code\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 3278,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(!mintGuardianPaused[cToken], \"mint is paused\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 3371,
          "vulnerability_to_line": null,
          "vulnerability_code": "            revert(\"redeemTokens zero\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 3384,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(!borrowGuardianPaused[cToken], \"borrow is paused\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 3392,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(msg.sender == cToken, \"sender must be cToken\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 3585,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(!seizeGuardianPaused, \"seize is paused\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 3643,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(!transferGuardianPaused, \"transfer is paused\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 4059,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(allMarkets[i] != CToken(cToken), \"market already added\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 4087,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(markets[address(cToken)].isListed, \"cannot pause a market that is not listed\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 4088,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == pauseGuardian || msg.sender == admin, \"only pause guardian and admin can pause\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 4089,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == admin || state == true, \"only admin can unpause\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 4097,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(markets[address(cToken)].isListed, \"cannot pause a market that is not listed\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 4098,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == pauseGuardian || msg.sender == admin, \"only pause guardian and admin can pause\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 4099,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == admin || state == true, \"only admin can unpause\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 4107,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == pauseGuardian || msg.sender == admin, \"only pause guardian and admin can pause\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 4108,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == admin || state == true, \"only admin can unpause\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 4116,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == pauseGuardian || msg.sender == admin, \"only pause guardian and admin can pause\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 4117,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == admin || state == true, \"only admin can unpause\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 4125,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == unitroller.admin(), \"only unitroller admin can change brains\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 4126,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(unitroller._acceptImplementation() == 0, \"change not authorized\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 4132,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == comptrollerImplementation, \"only brains can become itself\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 4328,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(markets[address(cToken)].isListed, \"market must be listed\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 4352,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(adminOrInitializing(), \"only admin can change comp rate\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 4366,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(adminOrInitializing(), \"only admin can add comp market\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 4377,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(market.isListed == true, \"comp market is not listed\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 4378,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(market.isComped == false, \"comp market already added\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 4403,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == admin, \"only admin can drop comp market\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 4406,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(market.isComped == true, \"market is not a comp market\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 1367,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(accrualBlockNumber == 0 && borrowIndex == 0, \"market may only be initialized once\");\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 2871,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (spender != src && spenderAllowance != uint96(-1)) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 2872,
          "vulnerability_to_line": null,
          "vulnerability_code": "            uint96 newAllowance = sub96(spenderAllowance, amount, \"Comp::transferFrom: transfer amount exceeds spender allowance\");\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 2873,
          "vulnerability_to_line": null,
          "vulnerability_code": "            allowances[src][spender] = newAllowance;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 2874,
          "vulnerability_to_line": null,
          "vulnerability_code": "\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 2875,
          "vulnerability_to_line": null,
          "vulnerability_code": "            emit Approval(src, spender, newAllowance);\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 2876,
          "vulnerability_to_line": null,
          "vulnerability_code": "        }\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 2983,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (srcRep != dstRep && amount > 0) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 2984,
          "vulnerability_to_line": null,
          "vulnerability_code": "            if (srcRep != address(0)) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 2985,
          "vulnerability_to_line": null,
          "vulnerability_code": "                uint32 srcRepNum = numCheckpoints[srcRep];\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 2986,
          "vulnerability_to_line": null,
          "vulnerability_code": "                uint96 srcRepOld = srcRepNum > 0 ? checkpoints[srcRep][srcRepNum - 1].votes : 0;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 2987,
          "vulnerability_to_line": null,
          "vulnerability_code": "                uint96 srcRepNew = sub96(srcRepOld, amount, \"Comp::_moveVotes: vote amount underflows\");\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 2988,
          "vulnerability_to_line": null,
          "vulnerability_code": "                _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 2989,
          "vulnerability_to_line": null,
          "vulnerability_code": "            }\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 2990,
          "vulnerability_to_line": null,
          "vulnerability_code": "\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 2991,
          "vulnerability_to_line": null,
          "vulnerability_code": "            if (dstRep != address(0)) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 2992,
          "vulnerability_to_line": null,
          "vulnerability_code": "                uint32 dstRepNum = numCheckpoints[dstRep];\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 3003,
          "vulnerability_to_line": null,
          "vulnerability_code": "      if (nCheckpoints > 0 && checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 3004,
          "vulnerability_to_line": null,
          "vulnerability_code": "          checkpoints[delegatee][nCheckpoints - 1].votes = newVotes;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 3005,
          "vulnerability_to_line": null,
          "vulnerability_code": "      } else {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 3006,
          "vulnerability_to_line": null,
          "vulnerability_code": "          checkpoints[delegatee][nCheckpoints] = Checkpoint(blockNumber, newVotes);\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 3007,
          "vulnerability_to_line": null,
          "vulnerability_code": "          numCheckpoints[delegatee] = nCheckpoints + 1;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 3008,
          "vulnerability_to_line": null,
          "vulnerability_code": "      }\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 3370,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (redeemTokens == 0 && redeemAmount > 0) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 3371,
          "vulnerability_to_line": null,
          "vulnerability_code": "            revert(\"redeemTokens zero\");\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 3372,
          "vulnerability_to_line": null,
          "vulnerability_code": "        }\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 3962,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (newCollateralFactorMantissa != 0 && oracle.getUnderlyingPrice(cToken) == 0) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 3963,
          "vulnerability_to_line": null,
          "vulnerability_code": "            return fail(Error.PRICE_ERROR, FailureInfo.SET_COLLATERAL_FACTOR_WITHOUT_PRICE);\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 3964,
          "vulnerability_to_line": null,
          "vulnerability_code": "        }\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4198,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (deltaBlocks > 0 && supplySpeed > 0) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4199,
          "vulnerability_to_line": null,
          "vulnerability_code": "            uint supplyTokens = CToken(cToken).totalSupply();\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4200,
          "vulnerability_to_line": null,
          "vulnerability_code": "            uint compAccrued = mul_(deltaBlocks, supplySpeed);\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4201,
          "vulnerability_to_line": null,
          "vulnerability_code": "            Double memory ratio = supplyTokens > 0 ? fraction(compAccrued, supplyTokens) : Double({mantissa: 0});\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4202,
          "vulnerability_to_line": null,
          "vulnerability_code": "            Double memory index = add_(Double({mantissa: supplyState.index}), ratio);\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4203,
          "vulnerability_to_line": null,
          "vulnerability_code": "            compSupplyState[cToken] = CompMarketState({\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4204,
          "vulnerability_to_line": null,
          "vulnerability_code": "                index: safe224(index.mantissa, \"new index exceeds 224 bits\"),\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4205,
          "vulnerability_to_line": null,
          "vulnerability_code": "                block: safe32(blockNumber, \"block number exceeds 32 bits\")\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4206,
          "vulnerability_to_line": null,
          "vulnerability_code": "            });\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4207,
          "vulnerability_to_line": null,
          "vulnerability_code": "        } else if (deltaBlocks > 0) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4221,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (deltaBlocks > 0 && borrowSpeed > 0) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4222,
          "vulnerability_to_line": null,
          "vulnerability_code": "            uint borrowAmount = div_(CToken(cToken).totalBorrows(), marketBorrowIndex);\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4223,
          "vulnerability_to_line": null,
          "vulnerability_code": "            uint compAccrued = mul_(deltaBlocks, borrowSpeed);\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4224,
          "vulnerability_to_line": null,
          "vulnerability_code": "            Double memory ratio = borrowAmount > 0 ? fraction(compAccrued, borrowAmount) : Double({mantissa: 0});\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4225,
          "vulnerability_to_line": null,
          "vulnerability_code": "            Double memory index = add_(Double({mantissa: borrowState.index}), ratio);\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4226,
          "vulnerability_to_line": null,
          "vulnerability_code": "            compBorrowState[cToken] = CompMarketState({\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4227,
          "vulnerability_to_line": null,
          "vulnerability_code": "                index: safe224(index.mantissa, \"new index exceeds 224 bits\"),\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4228,
          "vulnerability_to_line": null,
          "vulnerability_code": "                block: safe32(blockNumber, \"block number exceeds 32 bits\")\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4229,
          "vulnerability_to_line": null,
          "vulnerability_code": "            });\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4230,
          "vulnerability_to_line": null,
          "vulnerability_code": "        } else if (deltaBlocks > 0) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4246,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (supplierIndex.mantissa == 0 && supplyIndex.mantissa > 0) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4247,
          "vulnerability_to_line": null,
          "vulnerability_code": "            supplierIndex.mantissa = compInitialIndex;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4248,
          "vulnerability_to_line": null,
          "vulnerability_code": "        }\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4288,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (userAccrued >= threshold && userAccrued > 0) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4289,
          "vulnerability_to_line": null,
          "vulnerability_code": "            Comp comp = Comp(getCompAddress());\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4290,
          "vulnerability_to_line": null,
          "vulnerability_code": "            uint compRemaining = comp.balanceOf(address(this));\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4291,
          "vulnerability_to_line": null,
          "vulnerability_code": "            if (userAccrued <= compRemaining) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4292,
          "vulnerability_to_line": null,
          "vulnerability_code": "                comp.transfer(user, userAccrued);\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4293,
          "vulnerability_to_line": null,
          "vulnerability_code": "                return 0;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4294,
          "vulnerability_to_line": null,
          "vulnerability_code": "            }\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4295,
          "vulnerability_to_line": null,
          "vulnerability_code": "        }\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4383,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (compSupplyState[cToken].index == 0 && compSupplyState[cToken].block == 0) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4384,
          "vulnerability_to_line": null,
          "vulnerability_code": "            compSupplyState[cToken] = CompMarketState({\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4385,
          "vulnerability_to_line": null,
          "vulnerability_code": "                index: compInitialIndex,\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4386,
          "vulnerability_to_line": null,
          "vulnerability_code": "                block: safe32(getBlockNumber(), \"block number exceeds 32 bits\")\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4387,
          "vulnerability_to_line": null,
          "vulnerability_code": "            });\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4388,
          "vulnerability_to_line": null,
          "vulnerability_code": "        }\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4390,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (compBorrowState[cToken].index == 0 && compBorrowState[cToken].block == 0) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4391,
          "vulnerability_to_line": null,
          "vulnerability_code": "            compBorrowState[cToken] = CompMarketState({\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4392,
          "vulnerability_to_line": null,
          "vulnerability_code": "                index: compInitialIndex,\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4393,
          "vulnerability_to_line": null,
          "vulnerability_code": "                block: safe32(getBlockNumber(), \"block number exceeds 32 bits\")\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4394,
          "vulnerability_to_line": null,
          "vulnerability_code": "            });\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 4395,
          "vulnerability_to_line": null,
          "vulnerability_code": "        }\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-prefix-decrement-not-postfix",
          "vulnerability_from_line": 3260,
          "vulnerability_to_line": null,
          "vulnerability_code": "        storedList.length--;\n",
          "message": "Consider using the prefix decrement expression whenever the return value is not needed. The prefix decrement expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 2905,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(nonce == nonces[signatory]++, \"Comp::delegateBySig: invalid nonce\");\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 3162,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < len; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 3247,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < len; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 3765,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < assets.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 4058,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < allMarkets.length; i ++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 4134,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < compMarketsToAdd.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 4138,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < otherMarketsToAdd.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 4161,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < allMarkets_.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 4170,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < allMarkets_.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 4181,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < allMarkets_.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 4326,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < cTokens.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 4332,
          "vulnerability_to_line": null,
          "vulnerability_code": "                for (uint j = 0; j < holders.length; j++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 4338,
          "vulnerability_to_line": null,
          "vulnerability_code": "                for (uint j = 0; j < holders.length; j++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 4368,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < cTokens.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 4475,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < m; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 4477,
          "vulnerability_to_line": null,
          "vulnerability_code": "                n++;\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 4483,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < m; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 1366,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == admin, \"only admin may initialize the market\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 1367,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(accrualBlockNumber == 0 && borrowIndex == 0, \"market may only be initialized once\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 1371,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(initialExchangeRateMantissa > 0, \"initial exchange rate must be greater than zero.\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 1383,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(err == uint(Error.NO_ERROR), \"setting interest rate model failed\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 2017,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(amountSeizeError == uint(Error.NO_ERROR), \"LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 2904,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(signatory != address(0), \"Comp::delegateBySig: invalid signature\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 2905,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(nonce == nonces[signatory]++, \"Comp::delegateBySig: invalid nonce\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 2906,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(now <= expiry, \"Comp::delegateBySig: signature expired\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 2928,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(blockNumber < block.number, \"Comp::getPriorVotes: not yet determined\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 2972,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(src != address(0), \"Comp::_transferTokens: cannot transfer from the zero address\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 2973,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(dst != address(0), \"Comp::_transferTokens: cannot transfer to the zero address\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 3219,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(oErr == 0, \"exitMarket: getAccountSnapshot failed\"); // semi-opaque error code\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 4087,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(markets[address(cToken)].isListed, \"cannot pause a market that is not listed\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 4088,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == pauseGuardian || msg.sender == admin, \"only pause guardian and admin can pause\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 4097,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(markets[address(cToken)].isListed, \"cannot pause a market that is not listed\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 4098,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == pauseGuardian || msg.sender == admin, \"only pause guardian and admin can pause\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 4107,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == pauseGuardian || msg.sender == admin, \"only pause guardian and admin can pause\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 4116,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == pauseGuardian || msg.sender == admin, \"only pause guardian and admin can pause\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 4125,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == unitroller.admin(), \"only unitroller admin can change brains\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "compound-borrowfresh-reentrancy",
          "vulnerability_from_line": 1809,
          "vulnerability_to_line": null,
          "vulnerability_code": "        doTransferOut(borrower, borrowAmount);\n",
          "message": "Function borrowFresh() in Compound performs state update after doTransferOut()"
        }
      ]
    },
    "slither": {
      "successfull_analysis": true,
      "errors": [
        "DOCKER_RECEIVED_SIGNAL_27"
      ],
      "vulnerability_findings": [
        {
          "name": "controlled-delegatecall",
          "vulnerability_from_line": 2722,
          "vulnerability_to_line": 2737,
          "vulnerability_code": "    function () payable external {\n\n        // delegate all other functions to current implementation\n\n        (bool success, ) = comptrollerImplementation.delegatecall(msg.data);\n\n\n\n        assembly {\n\n              let free_mem_ptr := mload(0x40)\n\n              returndatacopy(free_mem_ptr, 0, returndatasize)\n\n\n\n              switch success\n\n              case 0 { revert(free_mem_ptr, returndatasize) }\n\n              default { return(free_mem_ptr, returndatasize) }\n\n        }\n\n    }\n\n}\n\n\n",
          "message": "Unitroller.fallback (ComptrollerScenarioG3.sol#2722-2737) uses delegatecall to a input-controlled function id\n\t(success) = comptrollerImplementation.delegatecall(msg.data) (ComptrollerScenarioG3.sol#2724-2726)\n"
        },
        {
          "name": "uninitialized-state",
          "vulnerability_from_line": 198,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint public totalSupply;\n",
          "message": "CTokenStorage.totalSupply (ComptrollerScenarioG3.sol#198) is never initialized. It is used in:\n\t- exchangeRateStoredInternal (ComptrollerScenarioG3.sol#1609-1627)\n"
        },
        {
          "name": "uninitialized-state",
          "vulnerability_from_line": 203,
          "vulnerability_to_line": null,
          "vulnerability_code": "    mapping (address => uint) internal accountTokens;\n",
          "message": "CTokenStorage.accountTokens (ComptrollerScenarioG3.sol#203) is never initialized. It is used in:\n\t- balanceOf (ComptrollerScenarioG3.sol#1444-1446)\n\t- balanceOfUnderlying (ComptrollerScenarioG3.sol#1454-1457)\n"
        },
        {
          "name": "uninitialized-state",
          "vulnerability_from_line": 2452,
          "vulnerability_to_line": 2454,
          "vulnerability_code": "    address public comptrollerImplementation;\n\n\n",
          "message": "UnitrollerAdminStorage.comptrollerImplementation (ComptrollerScenarioG3.sol#2452-2454) is never initialized. It is used in:\n\t- _becomeG3 (ComptrollerScenarioG3.sol#4131-4147)\n\t- adminOrInitializing (ComptrollerScenarioG3.sol#4149-4153)\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 3034,
          "vulnerability_to_line": 3041,
          "vulnerability_code": "    function getChainId() internal pure returns (uint) {\n\n        uint256 chainId;\n\n        assembly { chainId := chainid() }\n\n        return chainId;\n\n    }\n\n}\n\n\n",
          "message": "Comp.getChainId (ComptrollerScenarioG3.sol#3034-3041) is declared view but contains assembly code\n"
        },
        {
          "name": "erc20-interface",
          "vulnerability_from_line": 1271,
          "vulnerability_to_line": 1333,
          "vulnerability_code": "interface EIP20NonStandardInterface {\n\n\n\n    /**\n\n     * @notice Get the total number of tokens in circulation\n\n     * @return The supply of tokens\n\n     */\n\n    function totalSupply() external view returns (uint256);\n\n\n\n    /**\n\n     * @notice Gets the balance of the specified address\n\n     * @param owner The address from which the balance will be retrieved\n\n     * @return The balance\n\n     */\n\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n\n\n    ///\n\n    /// !!!!!!!!!!!!!!\n\n    /// !!! NOTICE !!! `transfer` does not return a value, in violation of the ERC-20 specification\n\n    /// !!!!!!!!!!!!!!\n\n    ///\n\n\n\n    /**\n\n      * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n\n      * @param dst The address of the destination account\n\n      * @param amount The number of tokens to transfer\n\n      */\n\n    function transfer(address dst, uint256 amount) external;\n\n\n\n    ///\n\n    /// !!!!!!!!!!!!!!\n\n    /// !!! NOTICE !!! `transferFrom` does not return a value, in violation of the ERC-20 specification\n\n    /// !!!!!!!!!!!!!!\n\n    ///\n\n\n\n    /**\n\n      * @notice Transfer `amount` tokens from `src` to `dst`\n\n      * @param src The address of the source account\n\n      * @param dst The address of the destination account\n\n      * @param amount The number of tokens to transfer\n\n      */\n\n    function transferFrom(address src, address dst, uint256 amount) external;\n\n\n\n    /**\n\n      * @notice Approve `spender` to transfer up to `amount` from `src`\n\n      * @dev This will overwrite the approval amount for `spender`\n\n      *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n\n      * @param spender The address of the account which may transfer tokens\n\n      * @param amount The number of tokens that are approved\n\n      * @return Whether or not the approval succeeded\n\n      */\n\n    function approve(address spender, uint256 amount) external returns (bool success);\n\n\n\n    /**\n\n      * @notice Get the current allowance from `owner` for `spender`\n\n      * @param owner The address of the account which owns the tokens to be spent\n\n      * @param spender The address of the account which may transfer tokens\n\n      * @return The number of tokens allowed to be spent\n\n      */\n\n    function allowance(address owner, address spender) external view returns (uint256 remaining);\n\n\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n",
          "message": "EIP20NonStandardInterface (ComptrollerScenarioG3.sol#1271-1333) has incorrect ERC20 function interface(s):\n\t-transfer (ComptrollerScenarioG3.sol#1297)\n\t-transferFrom (ComptrollerScenarioG3.sol#1311)\n"
        },
        {
          "name": "incorrect-equality",
          "vulnerability_from_line": 3000,
          "vulnerability_to_line": 3013,
          "vulnerability_code": "    function _writeCheckpoint(address delegatee, uint32 nCheckpoints, uint96 oldVotes, uint96 newVotes) internal {\n\n      uint32 blockNumber = safe32(block.number, \"Comp::_writeCheckpoint: block number exceeds 32 bits\");\n\n\n\n      if (nCheckpoints > 0 && checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber) {\n\n          checkpoints[delegatee][nCheckpoints - 1].votes = newVotes;\n\n      } else {\n\n          checkpoints[delegatee][nCheckpoints] = Checkpoint(blockNumber, newVotes);\n\n          numCheckpoints[delegatee] = nCheckpoints + 1;\n\n      }\n\n\n\n      emit DelegateVotesChanged(delegatee, oldVotes, newVotes);\n\n    }\n\n\n",
          "message": "Comp._writeCheckpoint (ComptrollerScenarioG3.sol#3000-3013) uses a dangerous strict equality:\n\t- nCheckpoints > 0 && checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 2182,
          "vulnerability_to_line": 2194,
          "vulnerability_code": "    function _addReservesInternal(uint addAmount) internal nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n\n            return fail(Error(error), FailureInfo.ADD_RESERVES_ACCRUE_INTEREST_FAILED);\n\n        }\n\n\n\n        // _addReservesFresh emits reserve-addition-specific logs on errors, so we don't need to.\n\n        (error, ) = _addReservesFresh(addAmount);\n\n        return error;\n\n    }\n\n\n",
          "message": "Reentrancy in CToken._addReservesInternal (ComptrollerScenarioG3.sol#2182-2194):\n\tExternal calls:\n\t- error = accrueInterest() (ComptrollerScenarioG3.sol#2183-2184)\n\tState variables written after the call(s):\n\t- totalReserves (ComptrollerScenarioG3.sol#2190-2191)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 4131,
          "vulnerability_to_line": 4147,
          "vulnerability_code": "    function _becomeG3(uint compRate_, address[] memory compMarketsToAdd, address[] memory otherMarketsToAdd) public {\n\n        require(msg.sender == comptrollerImplementation, \"only brains can become itself\");\n\n\n\n        for (uint i = 0; i < compMarketsToAdd.length; i++) {\n\n            _addMarketInternal(address(compMarketsToAdd[i]));\n\n        }\n\n\n\n        for (uint i = 0; i < otherMarketsToAdd.length; i++) {\n\n            _addMarketInternal(address(otherMarketsToAdd[i]));\n\n        }\n\n\n\n        _setCompRate(compRate_);\n\n        _addCompMarkets(compMarketsToAdd);\n\n    }\n\n\n\n    /**\n",
          "message": "Reentrancy in ComptrollerG3._becomeG3 (ComptrollerScenarioG3.sol#4131-4147):\n\tExternal calls:\n\t- _setCompRate(compRate_) (ComptrollerScenarioG3.sol#4142-4143)\n\t- _addCompMarkets(compMarketsToAdd) (ComptrollerScenarioG3.sol#4143-4146)\n\tState variables written after the call(s):\n\t- compBorrowState (ComptrollerScenarioG3.sol#4143-4146)\n\t- compSpeeds (ComptrollerScenarioG3.sol#4143-4146)\n\t- compSupplyState (ComptrollerScenarioG3.sol#4143-4146)\n\t- markets (ComptrollerScenarioG3.sol#4143-4146)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 2242,
          "vulnerability_to_line": 2252,
          "vulnerability_code": "    function _reduceReserves(uint reduceAmount) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n\n            return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.\n\n        return _reduceReservesFresh(reduceAmount);\n\n    }\n\n\n",
          "message": "Reentrancy in CToken._reduceReserves (ComptrollerScenarioG3.sol#2242-2252):\n\tExternal calls:\n\t- error = accrueInterest() (ComptrollerScenarioG3.sol#2243-2244)\n\tState variables written after the call(s):\n\t- totalReserves (ComptrollerScenarioG3.sol#2249-2250)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 2114,
          "vulnerability_to_line": 2133,
          "vulnerability_code": "    function _setComptroller(ComptrollerInterface newComptroller) public returns (uint) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COMPTROLLER_OWNER_CHECK);\n\n        }\n\n\n\n        ComptrollerInterface oldComptroller = comptroller;\n\n        // Ensure invoke comptroller.isComptroller() returns true\n\n        require(newComptroller.isComptroller(), \"marker method returned false\");\n\n\n\n        // Set market's comptroller to newComptroller\n\n        comptroller = newComptroller;\n\n\n\n        // Emit NewComptroller(oldComptroller, newComptroller)\n\n        emit NewComptroller(oldComptroller, newComptroller);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Reentrancy in CToken._setComptroller (ComptrollerScenarioG3.sol#2114-2133):\n\tExternal calls:\n\t- require(bool,string)(newComptroller.isComptroller(),marker method returned false) (ComptrollerScenarioG3.sol#2122-2123)\n\tState variables written after the call(s):\n\t- comptroller (ComptrollerScenarioG3.sol#2125-2126)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 2305,
          "vulnerability_to_line": 2315,
          "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n\n        return _setInterestRateModelFresh(newInterestRateModel);\n\n    }\n\n\n",
          "message": "Reentrancy in CToken._setInterestRateModel (ComptrollerScenarioG3.sol#2305-2315):\n\tExternal calls:\n\t- error = accrueInterest() (ComptrollerScenarioG3.sol#2306-2307)\n\t- _setInterestRateModelFresh(newInterestRateModel) (ComptrollerScenarioG3.sol#2312-2313)\n\tState variables written after the call(s):\n\t- interestRateModel (ComptrollerScenarioG3.sol#2312-2313)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 2321,
          "vulnerability_to_line": 2351,
          "vulnerability_code": "    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {\n\n\n\n        // Used to store old model for use in the event that is emitted on success\n\n        InterestRateModel oldInterestRateModel;\n\n\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);\n\n        }\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);\n\n        }\n\n\n\n        // Track the market's current interest rate model\n\n        oldInterestRateModel = interestRateModel;\n\n\n\n        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true\n\n        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n\n\n\n        // Set the interest rate model to newInterestRateModel\n\n        interestRateModel = newInterestRateModel;\n\n\n\n        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)\n\n        emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Reentrancy in CToken._setInterestRateModelFresh (ComptrollerScenarioG3.sol#2321-2351):\n\tExternal calls:\n\t- require(bool,string)(newInterestRateModel.isInterestRateModel(),marker method returned false) (ComptrollerScenarioG3.sol#2340-2342)\n\tState variables written after the call(s):\n\t- interestRateModel (ComptrollerScenarioG3.sol#2343-2345)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 2138,
          "vulnerability_to_line": 2148,
          "vulnerability_code": "    function _setReserveFactor(uint newReserveFactorMantissa) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.\n\n            return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.\n\n        return _setReserveFactorFresh(newReserveFactorMantissa);\n\n    }\n\n\n",
          "message": "Reentrancy in CToken._setReserveFactor (ComptrollerScenarioG3.sol#2138-2148):\n\tExternal calls:\n\t- error = accrueInterest() (ComptrollerScenarioG3.sol#2139-2140)\n\tState variables written after the call(s):\n\t- reserveFactorMantissa (ComptrollerScenarioG3.sol#2145-2146)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 4037,
          "vulnerability_to_line": 4057,
          "vulnerability_code": "    function _supportMarket(CToken cToken) external returns (uint) {\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SUPPORT_MARKET_OWNER_CHECK);\n\n        }\n\n\n\n        if (markets[address(cToken)].isListed) {\n\n            return fail(Error.MARKET_ALREADY_LISTED, FailureInfo.SUPPORT_MARKET_EXISTS);\n\n        }\n\n\n\n        cToken.isCToken(); // Sanity check to make sure its really a CToken\n\n\n\n        markets[address(cToken)] = Market({isListed: true, isComped: false, collateralFactorMantissa: 0, version: Version.VANILLA});\n\n\n\n        _addMarketInternal(address(cToken));\n\n\n\n        emit MarketListed(cToken);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Reentrancy in ComptrollerG3._supportMarket (ComptrollerScenarioG3.sol#4037-4057):\n\tExternal calls:\n\t- cToken.isCToken() (ComptrollerScenarioG3.sol#4046)\n\tState variables written after the call(s):\n\t- markets (ComptrollerScenarioG3.sol#4048-4050)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 1642,
          "vulnerability_to_line": 1694,
          "vulnerability_code": "    function accrueInterest() public returns (uint) {\n\n        /* Remember the initial block number */\n\n        uint currentBlockNumber = getBlockNumber();\n\n        uint accrualBlockNumberPrior = accrualBlockNumber;\n\n\n\n        /* Short-circuit accumulating 0 interest */\n\n        if (accrualBlockNumberPrior == currentBlockNumber) {\n\n            return uint(Error.NO_ERROR);\n\n        }\n\n\n\n        /* Read the previous values out of storage */\n\n        uint cashPrior = getCashPrior();\n\n        uint borrowsPrior = totalBorrows;\n\n        uint reservesPrior = totalReserves;\n\n        uint borrowIndexPrior = borrowIndex;\n\n\n\n        /* Calculate the current borrow interest rate */\n\n        uint borrowRateMantissa = interestRateModel.getBorrowRate(cashPrior, borrowsPrior, reservesPrior);\n\n        require(borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n\n\n\n        /* Calculate the number of blocks elapsed since the last accrual */\n\n        uint blockDelta = sub_(currentBlockNumber, accrualBlockNumberPrior);\n\n\n\n        /*\n\n         * Calculate the interest accumulated into borrows and reserves and the new index:\n\n         *  simpleInterestFactor = borrowRate * blockDelta\n\n         *  interestAccumulated = simpleInterestFactor * totalBorrows\n\n         *  totalBorrowsNew = interestAccumulated + totalBorrows\n\n         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves\n\n         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\n\n         */\n\n\n\n        Exp memory simpleInterestFactor = mul_(Exp({mantissa: borrowRateMantissa}), blockDelta);\n\n        uint interestAccumulated = mul_ScalarTruncate(simpleInterestFactor, borrowsPrior);\n\n        uint totalBorrowsNew = add_(interestAccumulated, borrowsPrior);\n\n        uint totalReservesNew = mul_ScalarTruncateAddUInt(Exp({mantissa: reserveFactorMantissa}), interestAccumulated, reservesPrior);\n\n        uint borrowIndexNew = mul_ScalarTruncateAddUInt(simpleInterestFactor, borrowIndexPrior, borrowIndexPrior);\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accrualBlockNumber = currentBlockNumber;\n\n        borrowIndex = borrowIndexNew;\n\n        totalBorrows = totalBorrowsNew;\n\n        totalReserves = totalReservesNew;\n\n\n\n        /* We emit an AccrueInterest event */\n\n        emit AccrueInterest(cashPrior, interestAccumulated, borrowIndexNew, totalBorrowsNew);\n\n\n\n        return uint(Error.NO_ERROR);\n",
          "message": "Reentrancy in CToken.accrueInterest (ComptrollerScenarioG3.sol#1642-1694):\n\tExternal calls:\n\t- borrowRateMantissa = interestRateModel.getBorrowRate(cashPrior,borrowsPrior,reservesPrior) (ComptrollerScenarioG3.sol#1659)\n\tState variables written after the call(s):\n\t- accrualBlockNumber (ComptrollerScenarioG3.sol#1685)\n\t- borrowIndex (ComptrollerScenarioG3.sol#1686)\n\t- totalBorrows (ComptrollerScenarioG3.sol#1687)\n\t- totalReserves (ComptrollerScenarioG3.sol#1688)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 1749,
          "vulnerability_to_line": 1757,
          "vulnerability_code": "    function borrowInternal(uint borrowAmount) internal nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n\n            return fail(Error(error), FailureInfo.BORROW_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // borrowFresh emits borrow-specific logs on errors, so we don't need to\n\n        return borrowFresh(msg.sender, borrowAmount);\n",
          "message": "Reentrancy in CToken.borrowInternal (ComptrollerScenarioG3.sol#1749-1757):\n\tExternal calls:\n\t- error = accrueInterest() (ComptrollerScenarioG3.sol#1750)\n\t- borrowFresh(msg.sender,borrowAmount) (ComptrollerScenarioG3.sol#1756)\n\tState variables written after the call(s):\n\t- totalBorrows (ComptrollerScenarioG3.sol#1756)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 3215,
          "vulnerability_to_line": 3267,
          "vulnerability_code": "    function exitMarket(address cTokenAddress) external returns (uint) {\n\n        CToken cToken = CToken(cTokenAddress);\n\n        /* Get sender tokensHeld and amountOwed underlying from the cToken */\n\n        (uint oErr, uint tokensHeld, uint amountOwed, ) = cToken.getAccountSnapshot(msg.sender);\n\n        require(oErr == 0, \"exitMarket: getAccountSnapshot failed\"); // semi-opaque error code\n\n\n\n        /* Fail if the sender has a borrow balance */\n\n        if (amountOwed != 0) {\n\n            return fail(Error.NONZERO_BORROW_BALANCE, FailureInfo.EXIT_MARKET_BALANCE_OWED);\n\n        }\n\n\n\n        /* Fail if the sender is not permitted to redeem all of their tokens */\n\n        uint allowed = redeemAllowedInternal(cTokenAddress, msg.sender, tokensHeld);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.REJECTION, FailureInfo.EXIT_MARKET_REJECTION, allowed);\n\n        }\n\n\n\n        Market storage marketToExit = markets[address(cToken)];\n\n\n\n        /* Return true if the sender is not already \u2018in\u2019 the market */\n\n        if (!marketToExit.accountMembership[msg.sender]) {\n\n            return uint(Error.NO_ERROR);\n\n        }\n\n\n\n        /* Set cToken account membership to false */\n\n        delete marketToExit.accountMembership[msg.sender];\n\n\n\n        /* Delete cToken from the account\u2019s list of assets */\n\n        // load into memory for faster iteration\n\n        CToken[] memory userAssetList = accountAssets[msg.sender];\n\n        uint len = userAssetList.length;\n\n        uint assetIndex = len;\n\n        for (uint i = 0; i < len; i++) {\n\n            if (userAssetList[i] == cToken) {\n\n                assetIndex = i;\n\n                break;\n\n            }\n\n        }\n\n\n\n        // We *must* have found the asset in the list or our redundant data structure is broken\n\n        assert(assetIndex < len);\n\n\n\n        // copy last item in list to location of item to be removed, reduce length by 1\n\n        CToken[] storage storedList = accountAssets[msg.sender];\n\n        storedList[assetIndex] = storedList[storedList.length - 1];\n\n        storedList.length--;\n\n\n\n        emit MarketExited(cToken, msg.sender);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Reentrancy in ComptrollerG3.exitMarket (ComptrollerScenarioG3.sol#3215-3267):\n\tExternal calls:\n\t- (oErr,tokensHeld,amountOwed) = cToken.getAccountSnapshot(msg.sender) (ComptrollerScenarioG3.sol#3218-3219)\n\t- allowed = redeemAllowedInternal(cTokenAddress,msg.sender,tokensHeld) (ComptrollerScenarioG3.sol#3227-3228)\n\tState variables written after the call(s):\n\t- accountAssets (ComptrollerScenarioG3.sol#3259-3260)\n\t- accountAssets (ComptrollerScenarioG3.sol#3260-3262)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 1360,
          "vulnerability_to_line": 1391,
          "vulnerability_code": "    function initialize(ComptrollerInterface comptroller_,\n\n                        InterestRateModel interestRateModel_,\n\n                        uint initialExchangeRateMantissa_,\n\n                        string memory name_,\n\n                        string memory symbol_,\n\n                        uint8 decimals_) public {\n\n        require(msg.sender == admin, \"only admin may initialize the market\");\n\n        require(accrualBlockNumber == 0 && borrowIndex == 0, \"market may only be initialized once\");\n\n\n\n        // Set initial exchange rate\n\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n\n        require(initialExchangeRateMantissa > 0, \"initial exchange rate must be greater than zero.\");\n\n\n\n        // Set the comptroller\n\n        uint err = _setComptroller(comptroller_);\n\n        require(err == uint(Error.NO_ERROR), \"setting comptroller failed\");\n\n\n\n        // Initialize block number and borrow index (block number mocks depend on comptroller being set)\n\n        accrualBlockNumber = getBlockNumber();\n\n        borrowIndex = mantissaOne;\n\n\n\n        // Set the interest rate model (depends on block number / borrow index)\n\n        err = _setInterestRateModelFresh(interestRateModel_);\n\n        require(err == uint(Error.NO_ERROR), \"setting interest rate model failed\");\n\n\n\n        name = name_;\n\n        symbol = symbol_;\n\n        decimals = decimals_;\n\n\n\n        // The counter starts true to prevent changing it from zero to non-zero (i.e. smaller cost/refund)\n\n        _notEntered = true;\n",
          "message": "Reentrancy in CToken.initialize (ComptrollerScenarioG3.sol#1360-1391):\n\tExternal calls:\n\t- err = _setComptroller(comptroller_) (ComptrollerScenarioG3.sol#1374)\n\tState variables written after the call(s):\n\t- accrualBlockNumber (ComptrollerScenarioG3.sol#1378)\n\t- borrowIndex (ComptrollerScenarioG3.sol#1379)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 1946,
          "vulnerability_to_line": 1961,
          "vulnerability_code": "    function liquidateBorrowInternal(address borrower, uint repayAmount, CTokenInterface cTokenCollateral) internal nonReentrant returns (uint, uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\n\n            return (fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED), 0);\n\n        }\n\n\n\n        error = cTokenCollateral.accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\n\n            return (fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED), 0);\n\n        }\n\n\n\n        // liquidateBorrowFresh emits borrow-specific logs on errors, so we don't need to\n\n        return liquidateBorrowFresh(msg.sender, borrower, repayAmount, cTokenCollateral);\n",
          "message": "Reentrancy in CToken.liquidateBorrowInternal (ComptrollerScenarioG3.sol#1946-1961):\n\tExternal calls:\n\t- error = accrueInterest() (ComptrollerScenarioG3.sol#1947)\n\t- error = cTokenCollateral.accrueInterest() (ComptrollerScenarioG3.sol#1953)\n\t- liquidateBorrowFresh(msg.sender,borrower,repayAmount,cTokenCollateral) (ComptrollerScenarioG3.sol#1960)\n\tState variables written after the call(s):\n\t- totalBorrows (ComptrollerScenarioG3.sol#1960)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 1847,
          "vulnerability_to_line": 1855,
          "vulnerability_code": "    function repayBorrowBehalfInternal(address borrower, uint repayAmount) internal nonReentrant returns (uint, uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n\n            return (fail(Error(error), FailureInfo.REPAY_BEHALF_ACCRUE_INTEREST_FAILED), 0);\n\n        }\n\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n\n        return repayBorrowFresh(msg.sender, borrower, repayAmount);\n",
          "message": "Reentrancy in CToken.repayBorrowBehalfInternal (ComptrollerScenarioG3.sol#1847-1855):\n\tExternal calls:\n\t- error = accrueInterest() (ComptrollerScenarioG3.sol#1848)\n\t- repayBorrowFresh(msg.sender,borrower,repayAmount) (ComptrollerScenarioG3.sol#1854)\n\tState variables written after the call(s):\n\t- totalBorrows (ComptrollerScenarioG3.sol#1854)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 1831,
          "vulnerability_to_line": 1839,
          "vulnerability_code": "    function repayBorrowInternal(uint repayAmount) internal nonReentrant returns (uint, uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n\n            return (fail(Error(error), FailureInfo.REPAY_BORROW_ACCRUE_INTEREST_FAILED), 0);\n\n        }\n\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n\n        return repayBorrowFresh(msg.sender, msg.sender, repayAmount);\n",
          "message": "Reentrancy in CToken.repayBorrowInternal (ComptrollerScenarioG3.sol#1831-1839):\n\tExternal calls:\n\t- error = accrueInterest() (ComptrollerScenarioG3.sol#1832)\n\t- repayBorrowFresh(msg.sender,msg.sender,repayAmount) (ComptrollerScenarioG3.sol#1838)\n\tState variables written after the call(s):\n\t- totalBorrows (ComptrollerScenarioG3.sol#1838)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 3578,
          "vulnerability_to_line": 3607,
          "vulnerability_code": "    function seizeAllowed(\n\n        address cTokenCollateral,\n\n        address cTokenBorrowed,\n\n        address liquidator,\n\n        address borrower,\n\n        uint seizeTokens) external returns (uint) {\n\n        // Pausing is a very serious situation - we revert to sound the alarms\n\n        require(!seizeGuardianPaused, \"seize is paused\");\n\n\n\n        // Shh - currently unused\n\n        seizeTokens;\n\n\n\n        if (!markets[cTokenCollateral].isListed || !markets[cTokenBorrowed].isListed) {\n\n            return uint(Error.MARKET_NOT_LISTED);\n\n        }\n\n\n\n        if (CToken(cTokenCollateral).comptroller() != CToken(cTokenBorrowed).comptroller()) {\n\n            return uint(Error.COMPTROLLER_MISMATCH);\n\n        }\n\n\n\n        // Keep the flywheel moving\n\n        updateCompSupplyIndex(cTokenCollateral);\n\n        distributeSupplierComp(cTokenCollateral, borrower, false);\n\n        distributeSupplierComp(cTokenCollateral, liquidator, false);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
          "message": "Reentrancy in ComptrollerG3.seizeAllowed (ComptrollerScenarioG3.sol#3578-3607):\n\tExternal calls:\n\t- updateCompSupplyIndex(cTokenCollateral) (ComptrollerScenarioG3.sol#3599-3600)\n\t- distributeSupplierComp(cTokenCollateral,borrower,false) (ComptrollerScenarioG3.sol#3600-3601)\n\t- distributeSupplierComp(cTokenCollateral,liquidator,false) (ComptrollerScenarioG3.sol#3601-3603)\n\tState variables written after the call(s):\n\t- compAccrued (ComptrollerScenarioG3.sol#3601-3603)\n\t- compSupplierIndex (ComptrollerScenarioG3.sol#3601-3603)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 3641,
          "vulnerability_to_line": 3661,
          "vulnerability_code": "    function transferAllowed(address cToken, address src, address dst, uint transferTokens) external returns (uint) {\n\n        // Pausing is a very serious situation - we revert to sound the alarms\n\n        require(!transferGuardianPaused, \"transfer is paused\");\n\n\n\n        // Currently the only consideration is whether or not\n\n        //  the src is allowed to redeem this many tokens\n\n        uint allowed = redeemAllowedInternal(cToken, src, transferTokens);\n\n        if (allowed != uint(Error.NO_ERROR)) {\n\n            return allowed;\n\n        }\n\n\n\n        // Keep the flywheel moving\n\n        updateCompSupplyIndex(cToken);\n\n        distributeSupplierComp(cToken, src, false);\n\n        distributeSupplierComp(cToken, dst, false);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
          "message": "Reentrancy in ComptrollerG3.transferAllowed (ComptrollerScenarioG3.sol#3641-3661):\n\tExternal calls:\n\t- allowed = redeemAllowedInternal(cToken,src,transferTokens) (ComptrollerScenarioG3.sol#3647-3648)\n\t- updateCompSupplyIndex(cToken) (ComptrollerScenarioG3.sol#3653-3654)\n\t- distributeSupplierComp(cToken,src,false) (ComptrollerScenarioG3.sol#3654-3655)\n\t- distributeSupplierComp(cToken,dst,false) (ComptrollerScenarioG3.sol#3655-3657)\n\tState variables written after the call(s):\n\t- compAccrued (ComptrollerScenarioG3.sol#3655-3657)\n\t- compSupplierIndex (ComptrollerScenarioG3.sol#3655-3657)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 4216,
          "vulnerability_to_line": 4236,
          "vulnerability_code": "    function updateCompBorrowIndex(address cToken, Exp memory marketBorrowIndex) internal {\n\n        CompMarketState storage borrowState = compBorrowState[cToken];\n\n        uint borrowSpeed = compSpeeds[cToken];\n\n        uint blockNumber = getBlockNumber();\n\n        uint deltaBlocks = sub_(blockNumber, uint(borrowState.block));\n\n        if (deltaBlocks > 0 && borrowSpeed > 0) {\n\n            uint borrowAmount = div_(CToken(cToken).totalBorrows(), marketBorrowIndex);\n\n            uint compAccrued = mul_(deltaBlocks, borrowSpeed);\n\n            Double memory ratio = borrowAmount > 0 ? fraction(compAccrued, borrowAmount) : Double({mantissa: 0});\n\n            Double memory index = add_(Double({mantissa: borrowState.index}), ratio);\n\n            compBorrowState[cToken] = CompMarketState({\n\n                index: safe224(index.mantissa, \"new index exceeds 224 bits\"),\n\n                block: safe32(blockNumber, \"block number exceeds 32 bits\")\n\n            });\n\n        } else if (deltaBlocks > 0) {\n\n            borrowState.block = safe32(blockNumber, \"block number exceeds 32 bits\");\n\n        }\n\n    }\n\n\n\n    /**\n",
          "message": "Reentrancy in ComptrollerG3.updateCompBorrowIndex (ComptrollerScenarioG3.sol#4216-4236):\n\tExternal calls:\n\t- borrowAmount = div_(CToken(cToken).totalBorrows(),marketBorrowIndex) (ComptrollerScenarioG3.sol#4222-4223)\n\tState variables written after the call(s):\n\t- compBorrowState (ComptrollerScenarioG3.sol#4226-4230)\n"
        },
        {
          "name": "reentrancy-no-eth",
          "vulnerability_from_line": 4193,
          "vulnerability_to_line": 4213,
          "vulnerability_code": "    function updateCompSupplyIndex(address cToken) internal {\n\n        CompMarketState storage supplyState = compSupplyState[cToken];\n\n        uint supplySpeed = compSpeeds[cToken];\n\n        uint blockNumber = getBlockNumber();\n\n        uint deltaBlocks = sub_(blockNumber, uint(supplyState.block));\n\n        if (deltaBlocks > 0 && supplySpeed > 0) {\n\n            uint supplyTokens = CToken(cToken).totalSupply();\n\n            uint compAccrued = mul_(deltaBlocks, supplySpeed);\n\n            Double memory ratio = supplyTokens > 0 ? fraction(compAccrued, supplyTokens) : Double({mantissa: 0});\n\n            Double memory index = add_(Double({mantissa: supplyState.index}), ratio);\n\n            compSupplyState[cToken] = CompMarketState({\n\n                index: safe224(index.mantissa, \"new index exceeds 224 bits\"),\n\n                block: safe32(blockNumber, \"block number exceeds 32 bits\")\n\n            });\n\n        } else if (deltaBlocks > 0) {\n\n            supplyState.block = safe32(blockNumber, \"block number exceeds 32 bits\");\n\n        }\n\n    }\n\n\n\n    /**\n",
          "message": "Reentrancy in ComptrollerG3.updateCompSupplyIndex (ComptrollerScenarioG3.sol#4193-4213):\n\tExternal calls:\n\t- supplyTokens = CToken(cToken).totalSupply() (ComptrollerScenarioG3.sol#4199-4200)\n\tState variables written after the call(s):\n\t- compSupplyState (ComptrollerScenarioG3.sol#4203-4207)\n"
        },
        {
          "name": "uninitialized-local",
          "vulnerability_from_line": 1788,
          "vulnerability_to_line": null,
          "vulnerability_code": "        BorrowLocalVars memory vars;\n",
          "message": "vars in CToken.borrowFresh (ComptrollerScenarioG3.sol#1788) is a local variable never initialiazed\n"
        },
        {
          "name": "uninitialized-local",
          "vulnerability_from_line": 2203,
          "vulnerability_to_line": 2205,
          "vulnerability_code": "        uint actualAddAmount;\n\n\n",
          "message": "actualAddAmount in CToken._addReservesFresh (ComptrollerScenarioG3.sol#2203-2205) is a local variable never initialiazed\n"
        },
        {
          "name": "uninitialized-local",
          "vulnerability_from_line": 3408,
          "vulnerability_to_line": null,
          "vulnerability_code": "        (Error err, , uint shortfall) = getHypotheticalAccountLiquidityInternal(borrower, CToken(cToken), 0, borrowAmount);\n",
          "message": "err_scope_0 in ComptrollerG3.borrowAllowed (ComptrollerScenarioG3.sol#3408) is a local variable never initialiazed\n"
        },
        {
          "name": "uninitialized-local",
          "vulnerability_from_line": 1887,
          "vulnerability_to_line": null,
          "vulnerability_code": "        RepayBorrowLocalVars memory vars;\n",
          "message": "vars in CToken.repayBorrowFresh (ComptrollerScenarioG3.sol#1887) is a local variable never initialiazed\n"
        },
        {
          "name": "unused-return",
          "vulnerability_from_line": 4037,
          "vulnerability_to_line": 4057,
          "vulnerability_code": "    function _supportMarket(CToken cToken) external returns (uint) {\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SUPPORT_MARKET_OWNER_CHECK);\n\n        }\n\n\n\n        if (markets[address(cToken)].isListed) {\n\n            return fail(Error.MARKET_ALREADY_LISTED, FailureInfo.SUPPORT_MARKET_EXISTS);\n\n        }\n\n\n\n        cToken.isCToken(); // Sanity check to make sure its really a CToken\n\n\n\n        markets[address(cToken)] = Market({isListed: true, isComped: false, collateralFactorMantissa: 0, version: Version.VANILLA});\n\n\n\n        _addMarketInternal(address(cToken));\n\n\n\n        emit MarketListed(cToken);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "ComptrollerG3._supportMarket (ComptrollerScenarioG3.sol#4037-4057) does not use the value returned by external calls:\n\t-cToken.isCToken() (ComptrollerScenarioG3.sol#4046)\n"
        },
        {
          "name": "unused-return",
          "vulnerability_from_line": 4287,
          "vulnerability_to_line": 4300,
          "vulnerability_code": "    function transferComp(address user, uint userAccrued, uint threshold) internal returns (uint) {\n\n        if (userAccrued >= threshold && userAccrued > 0) {\n\n            Comp comp = Comp(getCompAddress());\n\n            uint compRemaining = comp.balanceOf(address(this));\n\n            if (userAccrued <= compRemaining) {\n\n                comp.transfer(user, userAccrued);\n\n                return 0;\n\n            }\n\n        }\n\n        return userAccrued;\n\n    }\n\n\n\n    /**\n",
          "message": "ComptrollerG3.transferComp (ComptrollerScenarioG3.sol#4287-4300) does not use the value returned by external calls:\n\t-comp.transfer(user,userAccrued) (ComptrollerScenarioG3.sol#4292-4293)\n"
        },
        {
          "name": "shadowing-local",
          "vulnerability_from_line": 916,
          "vulnerability_to_line": null,
          "vulnerability_code": "        (MathError err, Exp memory fraction) = divScalarByExp(scalar, divisor);\n",
          "message": "Exponential.divScalarByExpTruncate.fraction (local variable @ ComptrollerScenarioG3.sol#916) shadows:\n\t- Exponential.fraction (function @ ComptrollerScenarioG3.sol#1146-1148)\n"
        },
        {
          "name": "shadowing-local",
          "vulnerability_from_line": 945,
          "vulnerability_to_line": null,
          "vulnerability_code": "        Exp memory fraction = div_ScalarByExp(scalar, divisor);\n",
          "message": "Exponential.div_ScalarByExpTruncate.fraction (local variable @ ComptrollerScenarioG3.sol#945) shadows:\n\t- Exponential.fraction (function @ ComptrollerScenarioG3.sol#1146-1148)\n"
        },
        {
          "name": "shadowing-local",
          "vulnerability_from_line": 4200,
          "vulnerability_to_line": 4201,
          "vulnerability_code": "            uint compAccrued = mul_(deltaBlocks, supplySpeed);\n",
          "message": "ComptrollerG3.updateCompSupplyIndex.compAccrued (local variable @ ComptrollerScenarioG3.sol#4200-4201) shadows:\n\t- ComptrollerV3Storage.compAccrued (state variable @ ComptrollerScenarioG3.sol#2568-2571)\n"
        },
        {
          "name": "shadowing-local",
          "vulnerability_from_line": 4223,
          "vulnerability_to_line": 4224,
          "vulnerability_code": "            uint compAccrued = mul_(deltaBlocks, borrowSpeed);\n",
          "message": "ComptrollerG3.updateCompBorrowIndex.compAccrued (local variable @ ComptrollerScenarioG3.sol#4223-4224) shadows:\n\t- ComptrollerV3Storage.compAccrued (state variable @ ComptrollerScenarioG3.sol#2568-2571)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 4037,
          "vulnerability_to_line": 4057,
          "vulnerability_code": "    function _supportMarket(CToken cToken) external returns (uint) {\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SUPPORT_MARKET_OWNER_CHECK);\n\n        }\n\n\n\n        if (markets[address(cToken)].isListed) {\n\n            return fail(Error.MARKET_ALREADY_LISTED, FailureInfo.SUPPORT_MARKET_EXISTS);\n\n        }\n\n\n\n        cToken.isCToken(); // Sanity check to make sure its really a CToken\n\n\n\n        markets[address(cToken)] = Market({isListed: true, isComped: false, collateralFactorMantissa: 0, version: Version.VANILLA});\n\n\n\n        _addMarketInternal(address(cToken));\n\n\n\n        emit MarketListed(cToken);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Reentrancy in ComptrollerG3._supportMarket (ComptrollerScenarioG3.sol#4037-4057):\n\tExternal calls:\n\t- cToken.isCToken() (ComptrollerScenarioG3.sol#4046)\n\tState variables written after the call(s):\n\t- allMarkets (ComptrollerScenarioG3.sol#4050-4052)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 1771,
          "vulnerability_to_line": 1824,
          "vulnerability_code": "    function borrowFresh(address payable borrower, uint borrowAmount) internal returns (uint) {\n\n        /* Fail if borrow not allowed */\n\n        uint allowed = comptroller.borrowAllowed(address(this), borrower, borrowAmount);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.BORROW_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.BORROW_FRESHNESS_CHECK);\n\n        }\n\n\n\n        /* Fail gracefully if protocol has insufficient underlying cash */\n\n        if (getCashPrior() < borrowAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.BORROW_CASH_NOT_AVAILABLE);\n\n        }\n\n\n\n        BorrowLocalVars memory vars;\n\n\n\n        /*\n\n         * We calculate the new borrower and total borrow balances, failing on overflow:\n\n         *  accountBorrowsNew = accountBorrows + borrowAmount\n\n         *  totalBorrowsNew = totalBorrows + borrowAmount\n\n         */\n\n        vars.accountBorrows = borrowBalanceStoredInternal(borrower);\n\n        vars.accountBorrowsNew = add_(vars.accountBorrows, borrowAmount);\n\n        vars.totalBorrowsNew = add_(totalBorrows, borrowAmount);\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We invoke doTransferOut for the borrower and the borrowAmount.\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken borrowAmount less of cash.\n\n         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n\n         */\n\n        doTransferOut(borrower, borrowAmount);\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n\n        accountBorrows[borrower].interestIndex = borrowIndex;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n\n\n        /* We emit a Borrow event */\n\n        emit Borrow(borrower, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n\n\n        /* We call the defense hook */\n\n        // unused function\n\n        // comptroller.borrowVerify(address(this), borrower, borrowAmount);\n\n\n\n        return uint(Error.NO_ERROR);\n",
          "message": "Reentrancy in CToken.borrowFresh (ComptrollerScenarioG3.sol#1771-1824):\n\tExternal calls:\n\t- allowed = comptroller.borrowAllowed(address(this),borrower,borrowAmount) (ComptrollerScenarioG3.sol#1773)\n\tState variables written after the call(s):\n\t- accountBorrows (ComptrollerScenarioG3.sol#1812)\n\t- accountBorrows (ComptrollerScenarioG3.sol#1813)\n\t- totalBorrows (ComptrollerScenarioG3.sol#1814)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 1360,
          "vulnerability_to_line": 1391,
          "vulnerability_code": "    function initialize(ComptrollerInterface comptroller_,\n\n                        InterestRateModel interestRateModel_,\n\n                        uint initialExchangeRateMantissa_,\n\n                        string memory name_,\n\n                        string memory symbol_,\n\n                        uint8 decimals_) public {\n\n        require(msg.sender == admin, \"only admin may initialize the market\");\n\n        require(accrualBlockNumber == 0 && borrowIndex == 0, \"market may only be initialized once\");\n\n\n\n        // Set initial exchange rate\n\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n\n        require(initialExchangeRateMantissa > 0, \"initial exchange rate must be greater than zero.\");\n\n\n\n        // Set the comptroller\n\n        uint err = _setComptroller(comptroller_);\n\n        require(err == uint(Error.NO_ERROR), \"setting comptroller failed\");\n\n\n\n        // Initialize block number and borrow index (block number mocks depend on comptroller being set)\n\n        accrualBlockNumber = getBlockNumber();\n\n        borrowIndex = mantissaOne;\n\n\n\n        // Set the interest rate model (depends on block number / borrow index)\n\n        err = _setInterestRateModelFresh(interestRateModel_);\n\n        require(err == uint(Error.NO_ERROR), \"setting interest rate model failed\");\n\n\n\n        name = name_;\n\n        symbol = symbol_;\n\n        decimals = decimals_;\n\n\n\n        // The counter starts true to prevent changing it from zero to non-zero (i.e. smaller cost/refund)\n\n        _notEntered = true;\n",
          "message": "Reentrancy in CToken.initialize (ComptrollerScenarioG3.sol#1360-1391):\n\tExternal calls:\n\t- err = _setComptroller(comptroller_) (ComptrollerScenarioG3.sol#1374)\n\t- err = _setInterestRateModelFresh(interestRateModel_) (ComptrollerScenarioG3.sol#1382)\n\tState variables written after the call(s):\n\t- _notEntered (ComptrollerScenarioG3.sol#1390)\n\t- decimals (ComptrollerScenarioG3.sol#1387)\n\t- name (ComptrollerScenarioG3.sol#1385)\n\t- symbol (ComptrollerScenarioG3.sol#1386)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 1875,
          "vulnerability_to_line": 1936,
          "vulnerability_code": "    function repayBorrowFresh(address payer, address borrower, uint repayAmount) internal returns (uint, uint) {\n\n        /* Fail if repayBorrow not allowed */\n\n        uint allowed = comptroller.repayBorrowAllowed(address(this), payer, borrower, repayAmount);\n\n        if (allowed != 0) {\n\n            return (failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REPAY_BORROW_COMPTROLLER_REJECTION, allowed), 0);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return (fail(Error.MARKET_NOT_FRESH, FailureInfo.REPAY_BORROW_FRESHNESS_CHECK), 0);\n\n        }\n\n\n\n        RepayBorrowLocalVars memory vars;\n\n\n\n        /* We remember the original borrowerIndex for verification purposes */\n\n        vars.borrowerIndex = accountBorrows[borrower].interestIndex;\n\n\n\n        /* We fetch the amount the borrower owes, with accumulated interest */\n\n        vars.accountBorrows = borrowBalanceStoredInternal(borrower);\n\n\n\n        /* If repayAmount == -1, repayAmount = accountBorrows */\n\n        if (repayAmount == uint(-1)) {\n\n            vars.repayAmount = vars.accountBorrows;\n\n        } else {\n\n            vars.repayAmount = repayAmount;\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We call doTransferIn for the payer and the repayAmount\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken holds an additional repayAmount of cash.\n\n         *  doTransferIn reverts if anything goes wrong, since we can't be sure if side effects occurred.\n\n         *   it returns the amount actually transferred, in case of a fee.\n\n         */\n\n        vars.actualRepayAmount = doTransferIn(payer, vars.repayAmount);\n\n\n\n        /*\n\n         * We calculate the new borrower and total borrow balances, failing on underflow:\n\n         *  accountBorrowsNew = accountBorrows - actualRepayAmount\n\n         *  totalBorrowsNew = totalBorrows - actualRepayAmount\n\n         */\n\n        vars.accountBorrowsNew = sub_(vars.accountBorrows, vars.actualRepayAmount);\n\n        vars.totalBorrowsNew = sub_(totalBorrows, vars.actualRepayAmount);\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n\n        accountBorrows[borrower].interestIndex = borrowIndex;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n\n\n        /* We emit a RepayBorrow event */\n\n        emit RepayBorrow(payer, borrower, vars.actualRepayAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n\n\n        /* We call the defense hook */\n\n        // unused function\n\n        // comptroller.repayBorrowVerify(address(this), payer, borrower, vars.actualRepayAmount, vars.borrowerIndex);\n\n\n\n        return (uint(Error.NO_ERROR), vars.actualRepayAmount);\n",
          "message": "Reentrancy in CToken.repayBorrowFresh (ComptrollerScenarioG3.sol#1875-1936):\n\tExternal calls:\n\t- allowed = comptroller.repayBorrowAllowed(address(this),payer,borrower,repayAmount) (ComptrollerScenarioG3.sol#1877)\n\tState variables written after the call(s):\n\t- accountBorrows (ComptrollerScenarioG3.sol#1924)\n\t- accountBorrows (ComptrollerScenarioG3.sol#1925)\n\t- totalBorrows (ComptrollerScenarioG3.sol#1926)\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 2722,
          "vulnerability_to_line": 2737,
          "vulnerability_code": "    function () payable external {\n\n        // delegate all other functions to current implementation\n\n        (bool success, ) = comptrollerImplementation.delegatecall(msg.data);\n\n\n\n        assembly {\n\n              let free_mem_ptr := mload(0x40)\n\n              returndatacopy(free_mem_ptr, 0, returndatasize)\n\n\n\n              switch success\n\n              case 0 { revert(free_mem_ptr, returndatasize) }\n\n              default { return(free_mem_ptr, returndatasize) }\n\n        }\n\n    }\n\n}\n\n\n",
          "message": "Unitroller.fallback uses assembly (ComptrollerScenarioG3.sol#2722-2737)\n\t- ComptrollerScenarioG3.sol#2726-2737\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 3034,
          "vulnerability_to_line": 3041,
          "vulnerability_code": "    function getChainId() internal pure returns (uint) {\n\n        uint256 chainId;\n\n        assembly { chainId := chainid() }\n\n        return chainId;\n\n    }\n\n}\n\n\n",
          "message": "Comp.getChainId uses assembly (ComptrollerScenarioG3.sol#3034-3041)\n\t- ComptrollerScenarioG3.sol#3036-3037\n"
        },
        {
          "name": "constable-states",
          "vulnerability_from_line": 265,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint256 public collateralCap;\n",
          "message": "CCollateralCapStorage.collateralCap should be constant (ComptrollerScenarioG3.sol#265)\nCCollateralCapStorage.totalCollateralTokens should be constant (ComptrollerScenarioG3.sol#249)\nCErc20Storage.implementation should be constant (ComptrollerScenarioG3.sol#235)\nCErc20Storage.underlying should be constant (ComptrollerScenarioG3.sol#230)\nCSupplyCapStorage.internalCash should be constant (ComptrollerScenarioG3.sol#242)\nCTokenStorage.totalSupply should be constant (ComptrollerScenarioG3.sol#198)\nComptrollerV2Storage._borrowGuardianPaused should be constant (ComptrollerScenarioG3.sol#2530-2531)\nComptrollerV2Storage._mintGuardianPaused should be constant (ComptrollerScenarioG3.sol#2529-2530)\nComptrollerV4Storage.borrowCapGuardian should be constant (ComptrollerScenarioG3.sol#2573-2575)\nComptrollerV5Storage.supplyCapGuardian should be constant (ComptrollerScenarioG3.sol#2581-2583)\n"
        },
        {
          "name": "pragma",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": "Different versions of Solidity is used in ComptrollerScenarioG3.sol:\n\t- Version used: ['ABIEncoderV2', '^0.5.16']\n\t- ComptrollerScenarioG3.sol#3 declares pragma solidity^0.5.16\n\t- ComptrollerScenarioG3.sol#77 declares pragma solidity^0.5.16\n\t- ComptrollerScenarioG3.sol#110 declares pragma solidity^0.5.16\n\t- ComptrollerScenarioG3.sol#494 declares pragma solidity^0.5.16\n\t- ComptrollerScenarioG3.sol#680 declares pragma solidity^0.5.16\n\t- ComptrollerScenarioG3.sol#768 declares pragma solidity^0.5.16\n\t- ComptrollerScenarioG3.sol#1199 declares pragma solidity^0.5.16\n\t- ComptrollerScenarioG3.sol#1264 declares pragma solidity^0.5.16\n\t- ComptrollerScenarioG3.sol#1337 declares pragma solidity^0.5.16\n\t- ComptrollerScenarioG3.sol#2418-2420 declares pragma solidity^0.5.16\n\t- ComptrollerScenarioG3.sol#2435-2438 declares pragma solidity^0.5.16\n\t- ComptrollerScenarioG3.sol#2589-2592 declares pragma solidity^0.5.16\n\t- ComptrollerScenarioG3.sol#2739-2740 declares pragma solidity^0.5.16\n\t- ComptrollerScenarioG3.sol#2740-2742 declares pragma experimentalABIEncoderV2\n\t- ComptrollerScenarioG3.sol#3043-3052 declares pragma solidity^0.5.16\n\t- ComptrollerScenarioG3.sol#4438-4440 declares pragma solidity^0.5.16\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 391,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint);\n",
          "message": "CTokenInterface._setInterestRateModel (ComptrollerScenarioG3.sol#391) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 2305,
          "vulnerability_to_line": 2315,
          "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n\n        return _setInterestRateModelFresh(newInterestRateModel);\n\n    }\n\n\n",
          "message": "CToken._setInterestRateModel (ComptrollerScenarioG3.sol#2305-2315) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 466,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setImplementation(address implementation_, bool allowResign, bytes memory becomeImplementationData) public;\n",
          "message": "CDelegatorInterface._setImplementation (ComptrollerScenarioG3.sol#466) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 475,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _becomeImplementation(bytes memory data) public;\n",
          "message": "CDelegateInterface._becomeImplementation (ComptrollerScenarioG3.sol#475) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 480,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _resignImplementation() public;\n",
          "message": "CDelegateInterface._resignImplementation (ComptrollerScenarioG3.sol#480) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 1360,
          "vulnerability_to_line": 1391,
          "vulnerability_code": "    function initialize(ComptrollerInterface comptroller_,\n\n                        InterestRateModel interestRateModel_,\n\n                        uint initialExchangeRateMantissa_,\n\n                        string memory name_,\n\n                        string memory symbol_,\n\n                        uint8 decimals_) public {\n\n        require(msg.sender == admin, \"only admin may initialize the market\");\n\n        require(accrualBlockNumber == 0 && borrowIndex == 0, \"market may only be initialized once\");\n\n\n\n        // Set initial exchange rate\n\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n\n        require(initialExchangeRateMantissa > 0, \"initial exchange rate must be greater than zero.\");\n\n\n\n        // Set the comptroller\n\n        uint err = _setComptroller(comptroller_);\n\n        require(err == uint(Error.NO_ERROR), \"setting comptroller failed\");\n\n\n\n        // Initialize block number and borrow index (block number mocks depend on comptroller being set)\n\n        accrualBlockNumber = getBlockNumber();\n\n        borrowIndex = mantissaOne;\n\n\n\n        // Set the interest rate model (depends on block number / borrow index)\n\n        err = _setInterestRateModelFresh(interestRateModel_);\n\n        require(err == uint(Error.NO_ERROR), \"setting interest rate model failed\");\n\n\n\n        name = name_;\n\n        symbol = symbol_;\n\n        decimals = decimals_;\n\n\n\n        // The counter starts true to prevent changing it from zero to non-zero (i.e. smaller cost/refund)\n\n        _notEntered = true;\n",
          "message": "CToken.initialize (ComptrollerScenarioG3.sol#1360-1391) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 2625,
          "vulnerability_to_line": 2640,
          "vulnerability_code": "    function _setPendingImplementation(address newPendingImplementation) public returns (uint) {\n\n\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_IMPLEMENTATION_OWNER_CHECK);\n\n        }\n\n\n\n        address oldPendingImplementation = pendingComptrollerImplementation;\n\n\n\n        pendingComptrollerImplementation = newPendingImplementation;\n\n\n\n        emit NewPendingImplementation(oldPendingImplementation, pendingComptrollerImplementation);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Unitroller._setPendingImplementation (ComptrollerScenarioG3.sol#2625-2640) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 2645,
          "vulnerability_to_line": 2666,
          "vulnerability_code": "    function _acceptImplementation() public returns (uint) {\n\n        // Check caller is pendingImplementation and pendingImplementation \u2260 address(0)\n\n        if (msg.sender != pendingComptrollerImplementation || pendingComptrollerImplementation == address(0)) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_PENDING_IMPLEMENTATION_ADDRESS_CHECK);\n\n        }\n\n\n\n        // Save current values for inclusion in log\n\n        address oldImplementation = comptrollerImplementation;\n\n        address oldPendingImplementation = pendingComptrollerImplementation;\n\n\n\n        comptrollerImplementation = pendingComptrollerImplementation;\n\n\n\n        pendingComptrollerImplementation = address(0);\n\n\n\n        emit NewImplementation(oldImplementation, comptrollerImplementation);\n\n        emit NewPendingImplementation(oldPendingImplementation, pendingComptrollerImplementation);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n\n",
          "message": "Unitroller._acceptImplementation (ComptrollerScenarioG3.sol#2645-2666) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 2672,
          "vulnerability_to_line": 2690,
          "vulnerability_code": "    function _setPendingAdmin(address newPendingAdmin) public returns (uint) {\n\n        // Check caller = admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);\n\n        }\n\n\n\n        // Save current value, if any, for inclusion in log\n\n        address oldPendingAdmin = pendingAdmin;\n\n\n\n        // Store pendingAdmin with value newPendingAdmin\n\n        pendingAdmin = newPendingAdmin;\n\n\n\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\n\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Unitroller._setPendingAdmin (ComptrollerScenarioG3.sol#2672-2690) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 2695,
          "vulnerability_to_line": 2718,
          "vulnerability_code": "    function _acceptAdmin() public returns (uint) {\n\n        // Check caller is pendingAdmin and pendingAdmin \u2260 address(0)\n\n        if (msg.sender != pendingAdmin || msg.sender == address(0)) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);\n\n        }\n\n\n\n        // Save current values for inclusion in log\n\n        address oldAdmin = admin;\n\n        address oldPendingAdmin = pendingAdmin;\n\n\n\n        // Store admin with value pendingAdmin\n\n        admin = pendingAdmin;\n\n\n\n        // Clear the pending value\n\n        pendingAdmin = address(0);\n\n\n\n        emit NewAdmin(oldAdmin, admin);\n\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
          "message": "Unitroller._acceptAdmin (ComptrollerScenarioG3.sol#2695-2718) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 2886,
          "vulnerability_to_line": 2891,
          "vulnerability_code": "    function delegate(address delegatee) public {\n\n        return _delegate(msg.sender, delegatee);\n\n    }\n\n\n\n    /**\n",
          "message": "Comp.delegate (ComptrollerScenarioG3.sol#2886-2891) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 2899,
          "vulnerability_to_line": 2911,
          "vulnerability_code": "    function delegateBySig(address delegatee, uint nonce, uint expiry, uint8 v, bytes32 r, bytes32 s) public {\n\n        bytes32 domainSeparator = keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), getChainId(), address(this)));\n\n        bytes32 structHash = keccak256(abi.encode(DELEGATION_TYPEHASH, delegatee, nonce, expiry));\n\n        bytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n\n        address signatory = ecrecover(digest, v, r, s);\n\n        require(signatory != address(0), \"Comp::delegateBySig: invalid signature\");\n\n        require(nonce == nonces[signatory]++, \"Comp::delegateBySig: invalid nonce\");\n\n        require(now <= expiry, \"Comp::delegateBySig: signature expired\");\n\n        return _delegate(signatory, delegatee);\n\n    }\n\n\n\n    /**\n",
          "message": "Comp.delegateBySig (ComptrollerScenarioG3.sol#2899-2911) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 2927,
          "vulnerability_to_line": 2961,
          "vulnerability_code": "    function getPriorVotes(address account, uint blockNumber) public view returns (uint96) {\n\n        require(blockNumber < block.number, \"Comp::getPriorVotes: not yet determined\");\n\n\n\n        uint32 nCheckpoints = numCheckpoints[account];\n\n        if (nCheckpoints == 0) {\n\n            return 0;\n\n        }\n\n\n\n        // First check most recent balance\n\n        if (checkpoints[account][nCheckpoints - 1].fromBlock <= blockNumber) {\n\n            return checkpoints[account][nCheckpoints - 1].votes;\n\n        }\n\n\n\n        // Next check implicit zero balance\n\n        if (checkpoints[account][0].fromBlock > blockNumber) {\n\n            return 0;\n\n        }\n\n\n\n        uint32 lower = 0;\n\n        uint32 upper = nCheckpoints - 1;\n\n        while (upper > lower) {\n\n            uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\n\n            Checkpoint memory cp = checkpoints[account][center];\n\n            if (cp.fromBlock == blockNumber) {\n\n                return cp.votes;\n\n            } else if (cp.fromBlock < blockNumber) {\n\n                lower = center;\n\n            } else {\n\n                upper = center - 1;\n\n            }\n\n        }\n\n        return checkpoints[account][lower].votes;\n\n    }\n\n\n",
          "message": "Comp.getPriorVotes (ComptrollerScenarioG3.sol#2927-2961) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 3158,
          "vulnerability_to_line": 3172,
          "vulnerability_code": "    function enterMarkets(address[] memory cTokens) public returns (uint[] memory) {\n\n        uint len = cTokens.length;\n\n\n\n        uint[] memory results = new uint[](len);\n\n        for (uint i = 0; i < len; i++) {\n\n            CToken cToken = CToken(cTokens[i]);\n\n\n\n            results[i] = uint(addToMarketInternal(cToken, msg.sender));\n\n        }\n\n\n\n        return results;\n\n    }\n\n\n\n    /**\n",
          "message": "ComptrollerG3.enterMarkets (ComptrollerScenarioG3.sol#3158-3172) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 11,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function enterMarkets(address[] calldata cTokens) external returns (uint[] memory);\n",
          "message": "ComptrollerInterface.enterMarkets (ComptrollerScenarioG3.sol#11) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 3706,
          "vulnerability_to_line": 3713,
          "vulnerability_code": "    function getAccountLiquidity(address account) public view returns (uint, uint, uint) {\n\n        (Error err, uint liquidity, uint shortfall) = getHypotheticalAccountLiquidityInternal(account, CToken(0), 0, 0);\n\n\n\n        return (uint(err), liquidity, shortfall);\n\n    }\n\n\n\n    /**\n",
          "message": "ComptrollerG3.getAccountLiquidity (ComptrollerScenarioG3.sol#3706-3713) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 3732,
          "vulnerability_to_line": 3742,
          "vulnerability_code": "    function getHypotheticalAccountLiquidity(\n\n        address account,\n\n        address cTokenModify,\n\n        uint redeemTokens,\n\n        uint borrowAmount) public view returns (uint, uint, uint) {\n\n        (Error err, uint liquidity, uint shortfall) = getHypotheticalAccountLiquidityInternal(account, CToken(cTokenModify), redeemTokens, borrowAmount);\n\n        return (uint(err), liquidity, shortfall);\n\n    }\n\n\n\n    /**\n",
          "message": "ComptrollerG3.getHypotheticalAccountLiquidity (ComptrollerScenarioG3.sol#3732-3742) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 3886,
          "vulnerability_to_line": 3905,
          "vulnerability_code": "    function _setPriceOracle(PriceOracle newOracle) public returns (uint) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PRICE_ORACLE_OWNER_CHECK);\n\n        }\n\n\n\n        // Track the old oracle for the comptroller\n\n        PriceOracle oldOracle = oracle;\n\n\n\n        // Set comptroller's oracle to newOracle\n\n        oracle = newOracle;\n\n\n\n        // Emit NewPriceOracle(oldOracle, newOracle)\n\n        emit NewPriceOracle(oldOracle, newOracle);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
          "message": "ComptrollerG3._setPriceOracle (ComptrollerScenarioG3.sol#3886-3905) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 4069,
          "vulnerability_to_line": 4086,
          "vulnerability_code": "    function _setPauseGuardian(address newPauseGuardian) public returns (uint) {\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PAUSE_GUARDIAN_OWNER_CHECK);\n\n        }\n\n\n\n        // Save current value for inclusion in log\n\n        address oldPauseGuardian = pauseGuardian;\n\n\n\n        // Store pauseGuardian with value newPauseGuardian\n\n        pauseGuardian = newPauseGuardian;\n\n\n\n        // Emit NewPauseGuardian(OldPauseGuardian, NewPauseGuardian)\n\n        emit NewPauseGuardian(oldPauseGuardian, pauseGuardian);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "ComptrollerG3._setPauseGuardian (ComptrollerScenarioG3.sol#4069-4086) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 4086,
          "vulnerability_to_line": 4096,
          "vulnerability_code": "    function _setMintPaused(CToken cToken, bool state) public returns (bool) {\n\n        require(markets[address(cToken)].isListed, \"cannot pause a market that is not listed\");\n\n        require(msg.sender == pauseGuardian || msg.sender == admin, \"only pause guardian and admin can pause\");\n\n        require(msg.sender == admin || state == true, \"only admin can unpause\");\n\n\n\n        mintGuardianPaused[address(cToken)] = state;\n\n        emit ActionPaused(cToken, \"Mint\", state);\n\n        return state;\n\n    }\n\n\n",
          "message": "ComptrollerG3._setMintPaused (ComptrollerScenarioG3.sol#4086-4096) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 4096,
          "vulnerability_to_line": 4106,
          "vulnerability_code": "    function _setBorrowPaused(CToken cToken, bool state) public returns (bool) {\n\n        require(markets[address(cToken)].isListed, \"cannot pause a market that is not listed\");\n\n        require(msg.sender == pauseGuardian || msg.sender == admin, \"only pause guardian and admin can pause\");\n\n        require(msg.sender == admin || state == true, \"only admin can unpause\");\n\n\n\n        borrowGuardianPaused[address(cToken)] = state;\n\n        emit ActionPaused(cToken, \"Borrow\", state);\n\n        return state;\n\n    }\n\n\n",
          "message": "ComptrollerG3._setBorrowPaused (ComptrollerScenarioG3.sol#4096-4106) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 4106,
          "vulnerability_to_line": 4115,
          "vulnerability_code": "    function _setTransferPaused(bool state) public returns (bool) {\n\n        require(msg.sender == pauseGuardian || msg.sender == admin, \"only pause guardian and admin can pause\");\n\n        require(msg.sender == admin || state == true, \"only admin can unpause\");\n\n\n\n        transferGuardianPaused = state;\n\n        emit ActionPaused(\"Transfer\", state);\n\n        return state;\n\n    }\n\n\n",
          "message": "ComptrollerG3._setTransferPaused (ComptrollerScenarioG3.sol#4106-4115) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 4115,
          "vulnerability_to_line": 4124,
          "vulnerability_code": "    function _setSeizePaused(bool state) public returns (bool) {\n\n        require(msg.sender == pauseGuardian || msg.sender == admin, \"only pause guardian and admin can pause\");\n\n        require(msg.sender == admin || state == true, \"only admin can unpause\");\n\n\n\n        seizeGuardianPaused = state;\n\n        emit ActionPaused(\"Seize\", state);\n\n        return state;\n\n    }\n\n\n",
          "message": "ComptrollerG3._setSeizePaused (ComptrollerScenarioG3.sol#4115-4124) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 4124,
          "vulnerability_to_line": 4131,
          "vulnerability_code": "    function _become(Unitroller unitroller, uint compRate_, address[] memory compMarketsToAdd, address[] memory otherMarketsToAdd) public {\n\n        require(msg.sender == unitroller.admin(), \"only unitroller admin can change brains\");\n\n        require(unitroller._acceptImplementation() == 0, \"change not authorized\");\n\n\n\n        ComptrollerG3(address(unitroller))._becomeG3(compRate_, compMarketsToAdd, otherMarketsToAdd);\n\n    }\n\n\n",
          "message": "ComptrollerG3._become (ComptrollerScenarioG3.sol#4124-4131) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 4131,
          "vulnerability_to_line": 4147,
          "vulnerability_code": "    function _becomeG3(uint compRate_, address[] memory compMarketsToAdd, address[] memory otherMarketsToAdd) public {\n\n        require(msg.sender == comptrollerImplementation, \"only brains can become itself\");\n\n\n\n        for (uint i = 0; i < compMarketsToAdd.length; i++) {\n\n            _addMarketInternal(address(compMarketsToAdd[i]));\n\n        }\n\n\n\n        for (uint i = 0; i < otherMarketsToAdd.length; i++) {\n\n            _addMarketInternal(address(otherMarketsToAdd[i]));\n\n        }\n\n\n\n        _setCompRate(compRate_);\n\n        _addCompMarkets(compMarketsToAdd);\n\n    }\n\n\n\n    /**\n",
          "message": "ComptrollerG3._becomeG3 (ComptrollerScenarioG3.sol#4131-4147) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 4303,
          "vulnerability_to_line": 4308,
          "vulnerability_code": "    function claimComp(address holder) public {\n\n        return claimComp(holder, allMarkets);\n\n    }\n\n\n\n    /**\n",
          "message": "ComptrollerG3.claimComp (ComptrollerScenarioG3.sol#4303-4308) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 4402,
          "vulnerability_to_line": 4415,
          "vulnerability_code": "    function _dropCompMarket(address cToken) public {\n\n        require(msg.sender == admin, \"only admin can drop comp market\");\n\n\n\n        Market storage market = markets[cToken];\n\n        require(market.isComped == true, \"market is not a comp market\");\n\n\n\n        market.isComped = false;\n\n        emit MarketComped(CToken(cToken), false);\n\n\n\n        refreshCompSpeeds();\n\n    }\n\n\n\n    /**\n",
          "message": "ComptrollerG3._dropCompMarket (ComptrollerScenarioG3.sol#4402-4415) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 4419,
          "vulnerability_to_line": 4423,
          "vulnerability_code": "    function getAllMarkets() public view returns (CToken[] memory) {\n\n        return allMarkets;\n\n    }\n\n\n",
          "message": "ComptrollerG3.getAllMarkets (ComptrollerScenarioG3.sol#4419-4423) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 4446,
          "vulnerability_to_line": 4450,
          "vulnerability_code": "    function setCompAddress(address compAddress_) public {\n\n        compAddress = compAddress_;\n\n    }\n\n\n",
          "message": "ComptrollerScenarioG3.setCompAddress (ComptrollerScenarioG3.sol#4446-4450) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 4454,
          "vulnerability_to_line": 4458,
          "vulnerability_code": "    function membershipLength(CToken cToken) public view returns (uint) {\n\n        return accountAssets[address(cToken)].length;\n\n    }\n\n\n",
          "message": "ComptrollerScenarioG3.membershipLength (ComptrollerScenarioG3.sol#4454-4458) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 4458,
          "vulnerability_to_line": 4464,
          "vulnerability_code": "    function fastForward(uint blocks) public returns (uint) {\n\n        blockNumber += blocks;\n\n\n\n        return blockNumber;\n\n    }\n\n\n",
          "message": "ComptrollerScenarioG3.fastForward (ComptrollerScenarioG3.sol#4458-4464) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 4464,
          "vulnerability_to_line": 4468,
          "vulnerability_code": "    function setBlockNumber(uint number) public {\n\n        blockNumber = number;\n\n    }\n\n\n",
          "message": "ComptrollerScenarioG3.setBlockNumber (ComptrollerScenarioG3.sol#4464-4468) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 4472,
          "vulnerability_to_line": 4491,
          "vulnerability_code": "    function getCompMarkets() public view returns (address[] memory) {\n\n        uint m = allMarkets.length;\n\n        uint n = 0;\n\n        for (uint i = 0; i < m; i++) {\n\n            if (markets[address(allMarkets[i])].isComped) {\n\n                n++;\n\n            }\n\n        }\n\n\n\n        address[] memory compMarkets = new address[](n);\n\n        uint k = 0;\n\n        for (uint i = 0; i < m; i++) {\n\n            if (markets[address(allMarkets[i])].isComped) {\n\n                compMarkets[k++] = address(allMarkets[i]);\n\n            }\n\n        }\n\n        return compMarkets;\n\n    }\n\n\n",
          "message": "ComptrollerScenarioG3.getCompMarkets (ComptrollerScenarioG3.sol#4472-4491) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 4491,
          "vulnerability_to_line": 4494,
          "vulnerability_code": "    function unlist(CToken cToken) public {\n\n        markets[address(cToken)].isListed = false;\n\n    }\n",
          "message": "ComptrollerScenarioG3.unlist (ComptrollerScenarioG3.sol#4491-4494) should be declared external\n"
        },
        {
          "name": "solc-version",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": "Detected issues with version pragma in ComptrollerScenarioG3.sol:\n\t- pragma solidity^0.5.16 (ComptrollerScenarioG3.sol#3): it allows old versions\n\t- pragma solidity^0.5.16 (ComptrollerScenarioG3.sol#77): it allows old versions\n\t- pragma solidity^0.5.16 (ComptrollerScenarioG3.sol#110): it allows old versions\n\t- pragma solidity^0.5.16 (ComptrollerScenarioG3.sol#494): it allows old versions\n\t- pragma solidity^0.5.16 (ComptrollerScenarioG3.sol#680): it allows old versions\n\t- pragma solidity^0.5.16 (ComptrollerScenarioG3.sol#768): it allows old versions\n\t- pragma solidity^0.5.16 (ComptrollerScenarioG3.sol#1199): it allows old versions\n\t- pragma solidity^0.5.16 (ComptrollerScenarioG3.sol#1264): it allows old versions\n\t- pragma solidity^0.5.16 (ComptrollerScenarioG3.sol#1337): it allows old versions\n\t- pragma solidity^0.5.16 (ComptrollerScenarioG3.sol#2418-2420): it allows old versions\n\t- pragma solidity^0.5.16 (ComptrollerScenarioG3.sol#2435-2438): it allows old versions\n\t- pragma solidity^0.5.16 (ComptrollerScenarioG3.sol#2589-2592): it allows old versions\n\t- pragma solidity^0.5.16 (ComptrollerScenarioG3.sol#2739-2740): it allows old versions\n\t- pragma solidity^0.5.16 (ComptrollerScenarioG3.sol#3043-3052): it allows old versions\n\t- pragma solidity^0.5.16 (ComptrollerScenarioG3.sol#4438-4440): it allows old versions\n"
        },
        {
          "name": "low-level-calls",
          "vulnerability_from_line": 2722,
          "vulnerability_to_line": 2737,
          "vulnerability_code": "    function () payable external {\n\n        // delegate all other functions to current implementation\n\n        (bool success, ) = comptrollerImplementation.delegatecall(msg.data);\n\n\n\n        assembly {\n\n              let free_mem_ptr := mload(0x40)\n\n              returndatacopy(free_mem_ptr, 0, returndatasize)\n\n\n\n              switch success\n\n              case 0 { revert(free_mem_ptr, returndatasize) }\n\n              default { return(free_mem_ptr, returndatasize) }\n\n        }\n\n    }\n\n}\n\n\n",
          "message": "Low level call in Unitroller.fallback (ComptrollerScenarioG3.sol#2722-2737):\n\t-(success) = comptrollerImplementation.delegatecall(msg.data) ComptrollerScenarioG3.sol#2724-2726\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 7,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bool public constant isComptroller = true;\n",
          "message": "Constant 'ComptrollerInterface.isComptroller' (ComptrollerScenarioG3.sol#7) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 85,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bool public constant isInterestRateModel = true;\n",
          "message": "Constant 'InterestRateModel.isInterestRateModel' (ComptrollerScenarioG3.sol#85) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 117,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bool internal _notEntered;\n",
          "message": "Variable 'CTokenStorage._notEntered' (ComptrollerScenarioG3.sol#117) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 138,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint internal constant borrowRateMaxMantissa = 0.0005e16;\n",
          "message": "Constant 'CTokenStorage.borrowRateMaxMantissa' (ComptrollerScenarioG3.sol#138) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 143,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint internal constant reserveFactorMaxMantissa = 1e18;\n",
          "message": "Constant 'CTokenStorage.reserveFactorMaxMantissa' (ComptrollerScenarioG3.sol#143) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 386,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint);\n",
          "message": "Function 'CTokenInterface._setPendingAdmin' (ComptrollerScenarioG3.sol#386) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 387,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _acceptAdmin() external returns (uint);\n",
          "message": "Function 'CTokenInterface._acceptAdmin' (ComptrollerScenarioG3.sol#387) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 388,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setComptroller(ComptrollerInterface newComptroller) public returns (uint);\n",
          "message": "Function 'CTokenInterface._setComptroller' (ComptrollerScenarioG3.sol#388) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 389,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setReserveFactor(uint newReserveFactorMantissa) external returns (uint);\n",
          "message": "Function 'CTokenInterface._setReserveFactor' (ComptrollerScenarioG3.sol#389) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 390,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _reduceReserves(uint reduceAmount) external returns (uint);\n",
          "message": "Function 'CTokenInterface._reduceReserves' (ComptrollerScenarioG3.sol#390) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 391,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint);\n",
          "message": "Function 'CTokenInterface._setInterestRateModel' (ComptrollerScenarioG3.sol#391) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 274,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bool public constant isCToken = true;\n",
          "message": "Constant 'CTokenInterface.isCToken' (ComptrollerScenarioG3.sol#274) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 408,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _addReserves(uint addAmount) external returns (uint);\n",
          "message": "Function 'CErc20Interface._addReserves' (ComptrollerScenarioG3.sol#408) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 415,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint public constant flashFeeBips = 3;\n",
          "message": "Constant 'CCapableErc20Interface.flashFeeBips' (ComptrollerScenarioG3.sol#415) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 451,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setCollateralCap(uint newCollateralCap) external;\n",
          "message": "Function 'CCollateralCapErc20Interface._setCollateralCap' (ComptrollerScenarioG3.sol#451) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 466,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setImplementation(address implementation_, bool allowResign, bytes memory becomeImplementationData) public;\n",
          "message": "Function 'CDelegatorInterface._setImplementation' (ComptrollerScenarioG3.sol#466) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 475,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _becomeImplementation(bytes memory data) public;\n",
          "message": "Function 'CDelegateInterface._becomeImplementation' (ComptrollerScenarioG3.sol#475) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 480,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _resignImplementation() public;\n",
          "message": "Function 'CDelegateInterface._resignImplementation' (ComptrollerScenarioG3.sol#480) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 867,
          "vulnerability_to_line": 870,
          "vulnerability_code": "    function mul_ScalarTruncate(Exp memory a, uint scalar) pure internal returns (uint) {\n\n        Exp memory product = mul_(a, scalar);\n\n        return truncate(product);\n",
          "message": "Function 'Exponential.mul_ScalarTruncate' (ComptrollerScenarioG3.sol#867-870) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 875,
          "vulnerability_to_line": 878,
          "vulnerability_code": "    function mul_ScalarTruncateAddUInt(Exp memory a, uint scalar, uint addend) pure internal returns (uint) {\n\n        Exp memory product = mul_(a, scalar);\n\n        return add_(truncate(product), addend);\n",
          "message": "Function 'Exponential.mul_ScalarTruncateAddUInt' (ComptrollerScenarioG3.sol#875-878) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 927,
          "vulnerability_to_line": 939,
          "vulnerability_code": "    function div_ScalarByExp(uint scalar, Exp memory divisor) pure internal returns (Exp memory) {\n\n        /*\n\n          We are doing this as:\n\n          getExp(mulUInt(expScale, scalar), divisor.mantissa)\n\n\n\n          How it works:\n\n          Exp = a / b;\n\n          Scalar = s;\n\n          `s / (a / b)` = `b * s / a` and since for an Exp `a = mantissa, b = expScale`\n\n        */\n\n        uint numerator = mul_(expScale, scalar);\n\n        return Exp({mantissa: div_(numerator, divisor)});\n",
          "message": "Function 'Exponential.div_ScalarByExp' (ComptrollerScenarioG3.sol#927-939) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 944,
          "vulnerability_to_line": 947,
          "vulnerability_code": "    function div_ScalarByExpTruncate(uint scalar, Exp memory divisor) pure internal returns (uint) {\n\n        Exp memory fraction = div_ScalarByExp(scalar, divisor);\n\n        return truncate(fraction);\n",
          "message": "Function 'Exponential.div_ScalarByExpTruncate' (ComptrollerScenarioG3.sol#944-947) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 778,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint constant expScale = 1e18;\n",
          "message": "Constant 'Exponential.expScale' (ComptrollerScenarioG3.sol#778) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 779,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint constant doubleScale = 1e36;\n",
          "message": "Constant 'Exponential.doubleScale' (ComptrollerScenarioG3.sol#779) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 780,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint constant halfExpScale = expScale/2;\n",
          "message": "Constant 'Exponential.halfExpScale' (ComptrollerScenarioG3.sol#780) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 781,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint constant mantissaOne = expScale;\n",
          "message": "Constant 'Exponential.mantissaOne' (ComptrollerScenarioG3.sol#781) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 2064,
          "vulnerability_to_line": 2080,
          "vulnerability_code": "    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint) {\n\n        // Check caller = admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);\n\n        }\n\n\n\n        // Save current value, if any, for inclusion in log\n\n        address oldPendingAdmin = pendingAdmin;\n\n\n\n        // Store pendingAdmin with value newPendingAdmin\n\n        pendingAdmin = newPendingAdmin;\n\n\n\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\n\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n\n\n\n        return uint(Error.NO_ERROR);\n",
          "message": "Function 'CToken._setPendingAdmin' (ComptrollerScenarioG3.sol#2064-2080) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 2087,
          "vulnerability_to_line": 2109,
          "vulnerability_code": "    function _acceptAdmin() external returns (uint) {\n\n        // Check caller is pendingAdmin and pendingAdmin \u2260 address(0)\n\n        if (msg.sender != pendingAdmin || msg.sender == address(0)) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);\n\n        }\n\n\n\n        // Save current values for inclusion in log\n\n        address oldAdmin = admin;\n\n        address oldPendingAdmin = pendingAdmin;\n\n\n\n        // Store admin with value pendingAdmin\n\n        admin = pendingAdmin;\n\n\n\n        // Clear the pending value\n\n        pendingAdmin = address(0);\n\n\n\n        emit NewAdmin(oldAdmin, admin);\n\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Function 'CToken._acceptAdmin' (ComptrollerScenarioG3.sol#2087-2109) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 2114,
          "vulnerability_to_line": 2133,
          "vulnerability_code": "    function _setComptroller(ComptrollerInterface newComptroller) public returns (uint) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COMPTROLLER_OWNER_CHECK);\n\n        }\n\n\n\n        ComptrollerInterface oldComptroller = comptroller;\n\n        // Ensure invoke comptroller.isComptroller() returns true\n\n        require(newComptroller.isComptroller(), \"marker method returned false\");\n\n\n\n        // Set market's comptroller to newComptroller\n\n        comptroller = newComptroller;\n\n\n\n        // Emit NewComptroller(oldComptroller, newComptroller)\n\n        emit NewComptroller(oldComptroller, newComptroller);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Function 'CToken._setComptroller' (ComptrollerScenarioG3.sol#2114-2133) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 2138,
          "vulnerability_to_line": 2148,
          "vulnerability_code": "    function _setReserveFactor(uint newReserveFactorMantissa) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.\n\n            return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.\n\n        return _setReserveFactorFresh(newReserveFactorMantissa);\n\n    }\n\n\n",
          "message": "Function 'CToken._setReserveFactor' (ComptrollerScenarioG3.sol#2138-2148) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 2242,
          "vulnerability_to_line": 2252,
          "vulnerability_code": "    function _reduceReserves(uint reduceAmount) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n\n            return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.\n\n        return _reduceReservesFresh(reduceAmount);\n\n    }\n\n\n",
          "message": "Function 'CToken._reduceReserves' (ComptrollerScenarioG3.sol#2242-2252) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 2305,
          "vulnerability_to_line": 2315,
          "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n\n        return _setInterestRateModelFresh(newInterestRateModel);\n\n    }\n\n\n",
          "message": "Function 'CToken._setInterestRateModel' (ComptrollerScenarioG3.sol#2305-2315) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 2153,
          "vulnerability_to_line": 2177,
          "vulnerability_code": "    function _setReserveFactorFresh(uint newReserveFactorMantissa) internal returns (uint) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_RESERVE_FACTOR_ADMIN_CHECK);\n\n        }\n\n\n\n        // Verify market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_RESERVE_FACTOR_FRESH_CHECK);\n\n        }\n\n\n\n        // Check newReserveFactor \u2264 maxReserveFactor\n\n        if (newReserveFactorMantissa > reserveFactorMaxMantissa) {\n\n            return fail(Error.BAD_INPUT, FailureInfo.SET_RESERVE_FACTOR_BOUNDS_CHECK);\n\n        }\n\n\n\n        uint oldReserveFactorMantissa = reserveFactorMantissa;\n\n        reserveFactorMantissa = newReserveFactorMantissa;\n\n\n\n        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Function 'CToken._setReserveFactorFresh' (ComptrollerScenarioG3.sol#2153-2177) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 2182,
          "vulnerability_to_line": 2194,
          "vulnerability_code": "    function _addReservesInternal(uint addAmount) internal nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n\n            return fail(Error(error), FailureInfo.ADD_RESERVES_ACCRUE_INTEREST_FAILED);\n\n        }\n\n\n\n        // _addReservesFresh emits reserve-addition-specific logs on errors, so we don't need to.\n\n        (error, ) = _addReservesFresh(addAmount);\n\n        return error;\n\n    }\n\n\n",
          "message": "Function 'CToken._addReservesInternal' (ComptrollerScenarioG3.sol#2182-2194) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 2200,
          "vulnerability_to_line": 2237,
          "vulnerability_code": "    function _addReservesFresh(uint addAmount) internal returns (uint, uint) {\n\n        // totalReserves + actualAddAmount\n\n        uint totalReservesNew;\n\n        uint actualAddAmount;\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return (fail(Error.MARKET_NOT_FRESH, FailureInfo.ADD_RESERVES_FRESH_CHECK), actualAddAmount);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We call doTransferIn for the caller and the addAmount\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken holds an additional addAmount of cash.\n\n         *  doTransferIn reverts if anything goes wrong, since we can't be sure if side effects occurred.\n\n         *  it returns the amount actually transferred, in case of a fee.\n\n         */\n\n\n\n        actualAddAmount = doTransferIn(msg.sender, addAmount);\n\n\n\n        totalReservesNew = add_(totalReserves, actualAddAmount);\n\n\n\n        // Store reserves[n+1] = reserves[n] + actualAddAmount\n\n        totalReserves = totalReservesNew;\n\n\n\n        /* Emit NewReserves(admin, actualAddAmount, reserves[n+1]) */\n\n        emit ReservesAdded(msg.sender, actualAddAmount, totalReservesNew);\n\n\n\n        /* Return (NO_ERROR, actualAddAmount) */\n\n        return (uint(Error.NO_ERROR), actualAddAmount);\n\n    }\n\n\n\n\n",
          "message": "Function 'CToken._addReservesFresh' (ComptrollerScenarioG3.sol#2200-2237) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 2258,
          "vulnerability_to_line": 2299,
          "vulnerability_code": "    function _reduceReservesFresh(uint reduceAmount) internal returns (uint) {\n\n        // totalReserves - reduceAmount\n\n        uint totalReservesNew;\n\n\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.REDUCE_RESERVES_ADMIN_CHECK);\n\n        }\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDUCE_RESERVES_FRESH_CHECK);\n\n        }\n\n\n\n        // Fail gracefully if protocol has insufficient underlying cash\n\n        if (getCashPrior() < reduceAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDUCE_RESERVES_CASH_NOT_AVAILABLE);\n\n        }\n\n\n\n        // Check reduceAmount \u2264 reserves[n] (totalReserves)\n\n        if (reduceAmount > totalReserves) {\n\n            return fail(Error.BAD_INPUT, FailureInfo.REDUCE_RESERVES_VALIDATION);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        totalReservesNew = sub_(totalReserves, reduceAmount);\n\n\n\n        // Store reserves[n+1] = reserves[n] - reduceAmount\n\n        totalReserves = totalReservesNew;\n\n\n\n        // doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n\n        doTransferOut(admin, reduceAmount);\n\n\n\n        emit ReservesReduced(admin, reduceAmount, totalReservesNew);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Function 'CToken._reduceReservesFresh' (ComptrollerScenarioG3.sol#2258-2299) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 2321,
          "vulnerability_to_line": 2351,
          "vulnerability_code": "    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {\n\n\n\n        // Used to store old model for use in the event that is emitted on success\n\n        InterestRateModel oldInterestRateModel;\n\n\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);\n\n        }\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);\n\n        }\n\n\n\n        // Track the market's current interest rate model\n\n        oldInterestRateModel = interestRateModel;\n\n\n\n        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true\n\n        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n\n\n\n        // Set the interest rate model to newInterestRateModel\n\n        interestRateModel = newInterestRateModel;\n\n\n\n        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)\n\n        emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Function 'CToken._setInterestRateModelFresh' (ComptrollerScenarioG3.sol#2321-2351) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 2422,
          "vulnerability_to_line": 2424,
          "vulnerability_code": "    bool public constant isPriceOracle = true;\n\n\n",
          "message": "Constant 'PriceOracle.isPriceOracle' (ComptrollerScenarioG3.sol#2422-2424) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 2529,
          "vulnerability_to_line": 2530,
          "vulnerability_code": "    bool public _mintGuardianPaused;\n",
          "message": "Variable 'ComptrollerV2Storage._mintGuardianPaused' (ComptrollerScenarioG3.sol#2529-2530) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 2530,
          "vulnerability_to_line": 2531,
          "vulnerability_code": "    bool public _borrowGuardianPaused;\n",
          "message": "Variable 'ComptrollerV2Storage._borrowGuardianPaused' (ComptrollerScenarioG3.sol#2530-2531) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 2625,
          "vulnerability_to_line": 2640,
          "vulnerability_code": "    function _setPendingImplementation(address newPendingImplementation) public returns (uint) {\n\n\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_IMPLEMENTATION_OWNER_CHECK);\n\n        }\n\n\n\n        address oldPendingImplementation = pendingComptrollerImplementation;\n\n\n\n        pendingComptrollerImplementation = newPendingImplementation;\n\n\n\n        emit NewPendingImplementation(oldPendingImplementation, pendingComptrollerImplementation);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Function 'Unitroller._setPendingImplementation' (ComptrollerScenarioG3.sol#2625-2640) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 2645,
          "vulnerability_to_line": 2666,
          "vulnerability_code": "    function _acceptImplementation() public returns (uint) {\n\n        // Check caller is pendingImplementation and pendingImplementation \u2260 address(0)\n\n        if (msg.sender != pendingComptrollerImplementation || pendingComptrollerImplementation == address(0)) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_PENDING_IMPLEMENTATION_ADDRESS_CHECK);\n\n        }\n\n\n\n        // Save current values for inclusion in log\n\n        address oldImplementation = comptrollerImplementation;\n\n        address oldPendingImplementation = pendingComptrollerImplementation;\n\n\n\n        comptrollerImplementation = pendingComptrollerImplementation;\n\n\n\n        pendingComptrollerImplementation = address(0);\n\n\n\n        emit NewImplementation(oldImplementation, comptrollerImplementation);\n\n        emit NewPendingImplementation(oldPendingImplementation, pendingComptrollerImplementation);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n\n",
          "message": "Function 'Unitroller._acceptImplementation' (ComptrollerScenarioG3.sol#2645-2666) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 2672,
          "vulnerability_to_line": 2690,
          "vulnerability_code": "    function _setPendingAdmin(address newPendingAdmin) public returns (uint) {\n\n        // Check caller = admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);\n\n        }\n\n\n\n        // Save current value, if any, for inclusion in log\n\n        address oldPendingAdmin = pendingAdmin;\n\n\n\n        // Store pendingAdmin with value newPendingAdmin\n\n        pendingAdmin = newPendingAdmin;\n\n\n\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\n\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Function 'Unitroller._setPendingAdmin' (ComptrollerScenarioG3.sol#2672-2690) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 2695,
          "vulnerability_to_line": 2718,
          "vulnerability_code": "    function _acceptAdmin() public returns (uint) {\n\n        // Check caller is pendingAdmin and pendingAdmin \u2260 address(0)\n\n        if (msg.sender != pendingAdmin || msg.sender == address(0)) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);\n\n        }\n\n\n\n        // Save current values for inclusion in log\n\n        address oldAdmin = admin;\n\n        address oldPendingAdmin = pendingAdmin;\n\n\n\n        // Store admin with value pendingAdmin\n\n        admin = pendingAdmin;\n\n\n\n        // Clear the pending value\n\n        pendingAdmin = address(0);\n\n\n\n        emit NewAdmin(oldAdmin, admin);\n\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
          "message": "Function 'Unitroller._acceptAdmin' (ComptrollerScenarioG3.sol#2695-2718) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 2961,
          "vulnerability_to_line": 2971,
          "vulnerability_code": "    function _delegate(address delegator, address delegatee) internal {\n\n        address currentDelegate = delegates[delegator];\n\n        uint96 delegatorBalance = balances[delegator];\n\n        delegates[delegator] = delegatee;\n\n\n\n        emit DelegateChanged(delegator, currentDelegate, delegatee);\n\n\n\n        _moveDelegates(currentDelegate, delegatee, delegatorBalance);\n\n    }\n\n\n",
          "message": "Function 'Comp._delegate' (ComptrollerScenarioG3.sol#2961-2971) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 2971,
          "vulnerability_to_line": 2982,
          "vulnerability_code": "    function _transferTokens(address src, address dst, uint96 amount) internal {\n\n        require(src != address(0), \"Comp::_transferTokens: cannot transfer from the zero address\");\n\n        require(dst != address(0), \"Comp::_transferTokens: cannot transfer to the zero address\");\n\n\n\n        balances[src] = sub96(balances[src], amount, \"Comp::_transferTokens: transfer amount exceeds balance\");\n\n        balances[dst] = add96(balances[dst], amount, \"Comp::_transferTokens: transfer amount overflows\");\n\n        emit Transfer(src, dst, amount);\n\n\n\n        _moveDelegates(delegates[src], delegates[dst], amount);\n\n    }\n\n\n",
          "message": "Function 'Comp._transferTokens' (ComptrollerScenarioG3.sol#2971-2982) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 2982,
          "vulnerability_to_line": 3000,
          "vulnerability_code": "    function _moveDelegates(address srcRep, address dstRep, uint96 amount) internal {\n\n        if (srcRep != dstRep && amount > 0) {\n\n            if (srcRep != address(0)) {\n\n                uint32 srcRepNum = numCheckpoints[srcRep];\n\n                uint96 srcRepOld = srcRepNum > 0 ? checkpoints[srcRep][srcRepNum - 1].votes : 0;\n\n                uint96 srcRepNew = sub96(srcRepOld, amount, \"Comp::_moveVotes: vote amount underflows\");\n\n                _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);\n\n            }\n\n\n\n            if (dstRep != address(0)) {\n\n                uint32 dstRepNum = numCheckpoints[dstRep];\n\n                uint96 dstRepOld = dstRepNum > 0 ? checkpoints[dstRep][dstRepNum - 1].votes : 0;\n\n                uint96 dstRepNew = add96(dstRepOld, amount, \"Comp::_moveVotes: vote amount overflows\");\n\n                _writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);\n\n            }\n\n        }\n\n    }\n\n\n",
          "message": "Function 'Comp._moveDelegates' (ComptrollerScenarioG3.sol#2982-3000) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 3000,
          "vulnerability_to_line": 3013,
          "vulnerability_code": "    function _writeCheckpoint(address delegatee, uint32 nCheckpoints, uint96 oldVotes, uint96 newVotes) internal {\n\n      uint32 blockNumber = safe32(block.number, \"Comp::_writeCheckpoint: block number exceeds 32 bits\");\n\n\n\n      if (nCheckpoints > 0 && checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber) {\n\n          checkpoints[delegatee][nCheckpoints - 1].votes = newVotes;\n\n      } else {\n\n          checkpoints[delegatee][nCheckpoints] = Checkpoint(blockNumber, newVotes);\n\n          numCheckpoints[delegatee] = nCheckpoints + 1;\n\n      }\n\n\n\n      emit DelegateVotesChanged(delegatee, oldVotes, newVotes);\n\n    }\n\n\n",
          "message": "Function 'Comp._writeCheckpoint' (ComptrollerScenarioG3.sol#3000-3013) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 2753,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint public constant totalSupply = 9000000e18; // 9 million Comp\n",
          "message": "Constant 'Comp.totalSupply' (ComptrollerScenarioG3.sol#2753) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 3886,
          "vulnerability_to_line": 3905,
          "vulnerability_code": "    function _setPriceOracle(PriceOracle newOracle) public returns (uint) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PRICE_ORACLE_OWNER_CHECK);\n\n        }\n\n\n\n        // Track the old oracle for the comptroller\n\n        PriceOracle oldOracle = oracle;\n\n\n\n        // Set comptroller's oracle to newOracle\n\n        oracle = newOracle;\n\n\n\n        // Emit NewPriceOracle(oldOracle, newOracle)\n\n        emit NewPriceOracle(oldOracle, newOracle);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
          "message": "Function 'ComptrollerG3._setPriceOracle' (ComptrollerScenarioG3.sol#3886-3905) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 3910,
          "vulnerability_to_line": 3935,
          "vulnerability_code": "    function _setCloseFactor(uint newCloseFactorMantissa) external returns (uint) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_CLOSE_FACTOR_OWNER_CHECK);\n\n        }\n\n\n\n        Exp memory newCloseFactorExp = Exp({mantissa: newCloseFactorMantissa});\n\n        Exp memory lowLimit = Exp({mantissa: closeFactorMinMantissa});\n\n        if (lessThanOrEqualExp(newCloseFactorExp, lowLimit)) {\n\n            return fail(Error.INVALID_CLOSE_FACTOR, FailureInfo.SET_CLOSE_FACTOR_VALIDATION);\n\n        }\n\n\n\n        Exp memory highLimit = Exp({mantissa: closeFactorMaxMantissa});\n\n        if (lessThanExp(highLimit, newCloseFactorExp)) {\n\n            return fail(Error.INVALID_CLOSE_FACTOR, FailureInfo.SET_CLOSE_FACTOR_VALIDATION);\n\n        }\n\n\n\n        uint oldCloseFactorMantissa = closeFactorMantissa;\n\n        closeFactorMantissa = newCloseFactorMantissa;\n\n        emit NewCloseFactor(oldCloseFactorMantissa, closeFactorMantissa);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
          "message": "Function 'ComptrollerG3._setCloseFactor' (ComptrollerScenarioG3.sol#3910-3935) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 3941,
          "vulnerability_to_line": 3977,
          "vulnerability_code": "    function _setCollateralFactor(CToken cToken, uint newCollateralFactorMantissa) external returns (uint) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COLLATERAL_FACTOR_OWNER_CHECK);\n\n        }\n\n\n\n        // Verify market is listed\n\n        Market storage market = markets[address(cToken)];\n\n        if (!market.isListed) {\n\n            return fail(Error.MARKET_NOT_LISTED, FailureInfo.SET_COLLATERAL_FACTOR_NO_EXISTS);\n\n        }\n\n\n\n        Exp memory newCollateralFactorExp = Exp({mantissa: newCollateralFactorMantissa});\n\n\n\n        // Check collateral factor <= 0.9\n\n        Exp memory highLimit = Exp({mantissa: collateralFactorMaxMantissa});\n\n        if (lessThanExp(highLimit, newCollateralFactorExp)) {\n\n            return fail(Error.INVALID_COLLATERAL_FACTOR, FailureInfo.SET_COLLATERAL_FACTOR_VALIDATION);\n\n        }\n\n\n\n        // If collateral factor != 0, fail if price == 0\n\n        if (newCollateralFactorMantissa != 0 && oracle.getUnderlyingPrice(cToken) == 0) {\n\n            return fail(Error.PRICE_ERROR, FailureInfo.SET_COLLATERAL_FACTOR_WITHOUT_PRICE);\n\n        }\n\n\n\n        // Set market's collateral factor to new collateral factor, remember old value\n\n        uint oldCollateralFactorMantissa = market.collateralFactorMantissa;\n\n        market.collateralFactorMantissa = newCollateralFactorMantissa;\n\n\n\n        // Emit event with asset, old collateral factor, and new collateral factor\n\n        emit NewCollateralFactor(cToken, oldCollateralFactorMantissa, newCollateralFactorMantissa);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
          "message": "Function 'ComptrollerG3._setCollateralFactor' (ComptrollerScenarioG3.sol#3941-3977) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 3982,
          "vulnerability_to_line": 3996,
          "vulnerability_code": "    function _setMaxAssets(uint newMaxAssets) external returns (uint) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_MAX_ASSETS_OWNER_CHECK);\n\n        }\n\n\n\n        uint oldMaxAssets = maxAssets;\n\n        maxAssets = newMaxAssets;\n\n        emit NewMaxAssets(oldMaxAssets, newMaxAssets);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
          "message": "Function 'ComptrollerG3._setMaxAssets' (ComptrollerScenarioG3.sol#3982-3996) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 4001,
          "vulnerability_to_line": 4032,
          "vulnerability_code": "    function _setLiquidationIncentive(uint newLiquidationIncentiveMantissa) external returns (uint) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_LIQUIDATION_INCENTIVE_OWNER_CHECK);\n\n        }\n\n\n\n        // Check de-scaled min <= newLiquidationIncentive <= max\n\n        Exp memory newLiquidationIncentive = Exp({mantissa: newLiquidationIncentiveMantissa});\n\n        Exp memory minLiquidationIncentive = Exp({mantissa: liquidationIncentiveMinMantissa});\n\n        if (lessThanExp(newLiquidationIncentive, minLiquidationIncentive)) {\n\n            return fail(Error.INVALID_LIQUIDATION_INCENTIVE, FailureInfo.SET_LIQUIDATION_INCENTIVE_VALIDATION);\n\n        }\n\n\n\n        Exp memory maxLiquidationIncentive = Exp({mantissa: liquidationIncentiveMaxMantissa});\n\n        if (lessThanExp(maxLiquidationIncentive, newLiquidationIncentive)) {\n\n            return fail(Error.INVALID_LIQUIDATION_INCENTIVE, FailureInfo.SET_LIQUIDATION_INCENTIVE_VALIDATION);\n\n        }\n\n\n\n        // Save current value for use in log\n\n        uint oldLiquidationIncentiveMantissa = liquidationIncentiveMantissa;\n\n\n\n        // Set liquidation incentive to new incentive\n\n        liquidationIncentiveMantissa = newLiquidationIncentiveMantissa;\n\n\n\n        // Emit event with old incentive, new incentive\n\n        emit NewLiquidationIncentive(oldLiquidationIncentiveMantissa, newLiquidationIncentiveMantissa);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
          "message": "Function 'ComptrollerG3._setLiquidationIncentive' (ComptrollerScenarioG3.sol#4001-4032) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 4037,
          "vulnerability_to_line": 4057,
          "vulnerability_code": "    function _supportMarket(CToken cToken) external returns (uint) {\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SUPPORT_MARKET_OWNER_CHECK);\n\n        }\n\n\n\n        if (markets[address(cToken)].isListed) {\n\n            return fail(Error.MARKET_ALREADY_LISTED, FailureInfo.SUPPORT_MARKET_EXISTS);\n\n        }\n\n\n\n        cToken.isCToken(); // Sanity check to make sure its really a CToken\n\n\n\n        markets[address(cToken)] = Market({isListed: true, isComped: false, collateralFactorMantissa: 0, version: Version.VANILLA});\n\n\n\n        _addMarketInternal(address(cToken));\n\n\n\n        emit MarketListed(cToken);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Function 'ComptrollerG3._supportMarket' (ComptrollerScenarioG3.sol#4037-4057) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 4057,
          "vulnerability_to_line": 4065,
          "vulnerability_code": "    function _addMarketInternal(address cToken) internal {\n\n        for (uint i = 0; i < allMarkets.length; i ++) {\n\n            require(allMarkets[i] != CToken(cToken), \"market already added\");\n\n        }\n\n        allMarkets.push(CToken(cToken));\n\n    }\n\n\n\n    /**\n",
          "message": "Function 'ComptrollerG3._addMarketInternal' (ComptrollerScenarioG3.sol#4057-4065) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 4069,
          "vulnerability_to_line": 4086,
          "vulnerability_code": "    function _setPauseGuardian(address newPauseGuardian) public returns (uint) {\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PAUSE_GUARDIAN_OWNER_CHECK);\n\n        }\n\n\n\n        // Save current value for inclusion in log\n\n        address oldPauseGuardian = pauseGuardian;\n\n\n\n        // Store pauseGuardian with value newPauseGuardian\n\n        pauseGuardian = newPauseGuardian;\n\n\n\n        // Emit NewPauseGuardian(OldPauseGuardian, NewPauseGuardian)\n\n        emit NewPauseGuardian(oldPauseGuardian, pauseGuardian);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
          "message": "Function 'ComptrollerG3._setPauseGuardian' (ComptrollerScenarioG3.sol#4069-4086) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 4086,
          "vulnerability_to_line": 4096,
          "vulnerability_code": "    function _setMintPaused(CToken cToken, bool state) public returns (bool) {\n\n        require(markets[address(cToken)].isListed, \"cannot pause a market that is not listed\");\n\n        require(msg.sender == pauseGuardian || msg.sender == admin, \"only pause guardian and admin can pause\");\n\n        require(msg.sender == admin || state == true, \"only admin can unpause\");\n\n\n\n        mintGuardianPaused[address(cToken)] = state;\n\n        emit ActionPaused(cToken, \"Mint\", state);\n\n        return state;\n\n    }\n\n\n",
          "message": "Function 'ComptrollerG3._setMintPaused' (ComptrollerScenarioG3.sol#4086-4096) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 4096,
          "vulnerability_to_line": 4106,
          "vulnerability_code": "    function _setBorrowPaused(CToken cToken, bool state) public returns (bool) {\n\n        require(markets[address(cToken)].isListed, \"cannot pause a market that is not listed\");\n\n        require(msg.sender == pauseGuardian || msg.sender == admin, \"only pause guardian and admin can pause\");\n\n        require(msg.sender == admin || state == true, \"only admin can unpause\");\n\n\n\n        borrowGuardianPaused[address(cToken)] = state;\n\n        emit ActionPaused(cToken, \"Borrow\", state);\n\n        return state;\n\n    }\n\n\n",
          "message": "Function 'ComptrollerG3._setBorrowPaused' (ComptrollerScenarioG3.sol#4096-4106) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 4106,
          "vulnerability_to_line": 4115,
          "vulnerability_code": "    function _setTransferPaused(bool state) public returns (bool) {\n\n        require(msg.sender == pauseGuardian || msg.sender == admin, \"only pause guardian and admin can pause\");\n\n        require(msg.sender == admin || state == true, \"only admin can unpause\");\n\n\n\n        transferGuardianPaused = state;\n\n        emit ActionPaused(\"Transfer\", state);\n\n        return state;\n\n    }\n\n\n",
          "message": "Function 'ComptrollerG3._setTransferPaused' (ComptrollerScenarioG3.sol#4106-4115) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 4115,
          "vulnerability_to_line": 4124,
          "vulnerability_code": "    function _setSeizePaused(bool state) public returns (bool) {\n\n        require(msg.sender == pauseGuardian || msg.sender == admin, \"only pause guardian and admin can pause\");\n\n        require(msg.sender == admin || state == true, \"only admin can unpause\");\n\n\n\n        seizeGuardianPaused = state;\n\n        emit ActionPaused(\"Seize\", state);\n\n        return state;\n\n    }\n\n\n",
          "message": "Function 'ComptrollerG3._setSeizePaused' (ComptrollerScenarioG3.sol#4115-4124) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 4124,
          "vulnerability_to_line": 4131,
          "vulnerability_code": "    function _become(Unitroller unitroller, uint compRate_, address[] memory compMarketsToAdd, address[] memory otherMarketsToAdd) public {\n\n        require(msg.sender == unitroller.admin(), \"only unitroller admin can change brains\");\n\n        require(unitroller._acceptImplementation() == 0, \"change not authorized\");\n\n\n\n        ComptrollerG3(address(unitroller))._becomeG3(compRate_, compMarketsToAdd, otherMarketsToAdd);\n\n    }\n\n\n",
          "message": "Function 'ComptrollerG3._become' (ComptrollerScenarioG3.sol#4124-4131) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 4131,
          "vulnerability_to_line": 4147,
          "vulnerability_code": "    function _becomeG3(uint compRate_, address[] memory compMarketsToAdd, address[] memory otherMarketsToAdd) public {\n\n        require(msg.sender == comptrollerImplementation, \"only brains can become itself\");\n\n\n\n        for (uint i = 0; i < compMarketsToAdd.length; i++) {\n\n            _addMarketInternal(address(compMarketsToAdd[i]));\n\n        }\n\n\n\n        for (uint i = 0; i < otherMarketsToAdd.length; i++) {\n\n            _addMarketInternal(address(otherMarketsToAdd[i]));\n\n        }\n\n\n\n        _setCompRate(compRate_);\n\n        _addCompMarkets(compMarketsToAdd);\n\n    }\n\n\n\n    /**\n",
          "message": "Function 'ComptrollerG3._becomeG3' (ComptrollerScenarioG3.sol#4131-4147) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 4351,
          "vulnerability_to_line": 4362,
          "vulnerability_code": "    function _setCompRate(uint compRate_) public {\n\n        require(adminOrInitializing(), \"only admin can change comp rate\");\n\n\n\n        uint oldRate = compRate;\n\n        compRate = compRate_;\n\n        emit NewCompRate(oldRate, compRate_);\n\n\n\n        refreshCompSpeeds();\n\n    }\n\n\n\n    /**\n",
          "message": "Function 'ComptrollerG3._setCompRate' (ComptrollerScenarioG3.sol#4351-4362) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 4365,
          "vulnerability_to_line": 4375,
          "vulnerability_code": "    function _addCompMarkets(address[] memory cTokens) public {\n\n        require(adminOrInitializing(), \"only admin can add comp market\");\n\n\n\n        for (uint i = 0; i < cTokens.length; i++) {\n\n            _addCompMarketInternal(cTokens[i]);\n\n        }\n\n\n\n        refreshCompSpeeds();\n\n    }\n\n\n",
          "message": "Function 'ComptrollerG3._addCompMarkets' (ComptrollerScenarioG3.sol#4365-4375) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 4375,
          "vulnerability_to_line": 4399,
          "vulnerability_code": "    function _addCompMarketInternal(address cToken) internal {\n\n        Market storage market = markets[cToken];\n\n        require(market.isListed == true, \"comp market is not listed\");\n\n        require(market.isComped == false, \"comp market already added\");\n\n\n\n        market.isComped = true;\n\n        emit MarketComped(CToken(cToken), true);\n\n\n\n        if (compSupplyState[cToken].index == 0 && compSupplyState[cToken].block == 0) {\n\n            compSupplyState[cToken] = CompMarketState({\n\n                index: compInitialIndex,\n\n                block: safe32(getBlockNumber(), \"block number exceeds 32 bits\")\n\n            });\n\n        }\n\n\n\n        if (compBorrowState[cToken].index == 0 && compBorrowState[cToken].block == 0) {\n\n            compBorrowState[cToken] = CompMarketState({\n\n                index: compInitialIndex,\n\n                block: safe32(getBlockNumber(), \"block number exceeds 32 bits\")\n\n            });\n\n        }\n\n    }\n\n\n\n    /**\n",
          "message": "Function 'ComptrollerG3._addCompMarketInternal' (ComptrollerScenarioG3.sol#4375-4399) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 4402,
          "vulnerability_to_line": 4415,
          "vulnerability_code": "    function _dropCompMarket(address cToken) public {\n\n        require(msg.sender == admin, \"only admin can drop comp market\");\n\n\n\n        Market storage market = markets[cToken];\n\n        require(market.isComped == true, \"market is not a comp market\");\n\n\n\n        market.isComped = false;\n\n        emit MarketComped(CToken(cToken), false);\n\n\n\n        refreshCompSpeeds();\n\n    }\n\n\n\n    /**\n",
          "message": "Function 'ComptrollerG3._dropCompMarket' (ComptrollerScenarioG3.sol#4402-4415) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 3106,
          "vulnerability_to_line": 3108,
          "vulnerability_code": "    uint public constant compClaimThreshold = 0.001e18;\n\n\n",
          "message": "Constant 'ComptrollerG3.compClaimThreshold' (ComptrollerScenarioG3.sol#3106-3108) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 3109,
          "vulnerability_to_line": 3111,
          "vulnerability_code": "    uint224 public constant compInitialIndex = 1e36;\n\n\n",
          "message": "Constant 'ComptrollerG3.compInitialIndex' (ComptrollerScenarioG3.sol#3109-3111) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 3112,
          "vulnerability_to_line": 3113,
          "vulnerability_code": "    uint internal constant closeFactorMinMantissa = 0.05e18; // 0.05\n",
          "message": "Constant 'ComptrollerG3.closeFactorMinMantissa' (ComptrollerScenarioG3.sol#3112-3113) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 3115,
          "vulnerability_to_line": 3117,
          "vulnerability_code": "    uint internal constant closeFactorMaxMantissa = 0.9e18; // 0.9\n\n\n",
          "message": "Constant 'ComptrollerG3.closeFactorMaxMantissa' (ComptrollerScenarioG3.sol#3115-3117) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 3118,
          "vulnerability_to_line": 3120,
          "vulnerability_code": "    uint internal constant collateralFactorMaxMantissa = 0.9e18; // 0.9\n\n\n",
          "message": "Constant 'ComptrollerG3.collateralFactorMaxMantissa' (ComptrollerScenarioG3.sol#3118-3120) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 3121,
          "vulnerability_to_line": 3123,
          "vulnerability_code": "    uint internal constant liquidationIncentiveMinMantissa = 1.0e18; // 1.0\n\n\n",
          "message": "Constant 'ComptrollerG3.liquidationIncentiveMinMantissa' (ComptrollerScenarioG3.sol#3121-3123) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 3124,
          "vulnerability_to_line": 3126,
          "vulnerability_code": "    uint internal constant liquidationIncentiveMaxMantissa = 1.5e18; // 1.5\n\n\n",
          "message": "Constant 'ComptrollerG3.liquidationIncentiveMaxMantissa' (ComptrollerScenarioG3.sol#3124-3126) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "unused-state",
          "vulnerability_from_line": 781,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint constant mantissaOne = expScale;\n",
          "message": "Exponential.mantissaOne (ComptrollerScenarioG3.sol#781) is never used in ComptrollerScenarioG3\n"
        }
      ]
    },
    "smartcheck": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 4432,
          "vulnerability_to_line": null,
          "vulnerability_code": "        return 0xc00e94Cb662C3520282E6f5717214004A7f26888;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 1157,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (xx >= 0x100000000000000000000000000000000) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 1161,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (xx >= 0x10000000000000000) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 1165,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (xx >= 0x100000000) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 1169,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (xx >= 0x10000) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 1173,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (xx >= 0x100) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 1177,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (xx >= 0x10) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 1181,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (xx >= 0x8) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 2657,
          "vulnerability_to_line": null,
          "vulnerability_code": "        pendingComptrollerImplementation = address(0);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 2709,
          "vulnerability_to_line": null,
          "vulnerability_code": "        pendingAdmin = address(0);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ARRAY_LENGTH_MANIPULATION",
          "vulnerability_from_line": 3260,
          "vulnerability_to_line": null,
          "vulnerability_code": "        storedList.length--;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ERC20_APPROVE",
          "vulnerability_from_line": 1422,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function approve(address spender, uint256 amount) external returns (bool) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 3765,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < assets.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 4058,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < allMarkets.length; i ++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 4134,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < compMarketsToAdd.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 4138,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < otherMarketsToAdd.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 4161,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < allMarkets_.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 4170,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < allMarkets_.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 4181,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < allMarkets_.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 4326,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < cTokens.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 4332,
          "vulnerability_to_line": null,
          "vulnerability_code": "                for (uint j = 0; j < holders.length; j++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 4338,
          "vulnerability_to_line": null,
          "vulnerability_code": "                for (uint j = 0; j < holders.length; j++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 4368,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < cTokens.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 3162,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < len; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 3247,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < len; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 3765,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < assets.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 4058,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < allMarkets.length; i ++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 4134,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < compMarketsToAdd.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 4138,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < otherMarketsToAdd.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 4161,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < allMarkets_.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 4170,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < allMarkets_.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 4181,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < allMarkets_.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 4326,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < cTokens.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 4332,
          "vulnerability_to_line": null,
          "vulnerability_code": "                for (uint j = 0; j < holders.length; j++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 4338,
          "vulnerability_to_line": null,
          "vulnerability_code": "                for (uint j = 0; j < holders.length; j++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 4368,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < cTokens.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 4475,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < m; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 4483,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < m; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 2947,
          "vulnerability_to_line": null,
          "vulnerability_code": "        while (upper > lower) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_LOCKED_MONEY",
          "vulnerability_from_line": 270,
          "vulnerability_to_line": null,
          "vulnerability_code": "contract CTokenInterface is CTokenStorage {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_LOCKED_MONEY",
          "vulnerability_from_line": 2597,
          "vulnerability_to_line": null,
          "vulnerability_code": "contract Unitroller is UnitrollerAdminStorage, ComptrollerErrorReporter {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 77,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 110,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 494,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 680,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 768,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 1199,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 1264,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 1337,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 2418,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 2435,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 2589,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 2739,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 3043,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 4438,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.16;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_REVERT_REQUIRE",
          "vulnerability_from_line": 3370,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (redeemTokens == 0 && redeemAmount > 0) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 3034,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getChainId() internal pure returns (uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 72,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint repayAmount) external view returns (uint, uint);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 371,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 703,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function mulUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 720,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function divUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 731,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function subUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 742,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function addUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 755,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function addThenSubUInt(uint a, uint b, uint c) internal pure returns (MathError, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 796,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getExp(uint num, uint denom) pure internal returns (MathError, Exp memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 813,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function addExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 822,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function subExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 831,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function mulScalar(Exp memory a, uint scalar) pure internal returns (MathError, Exp memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 843,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function mulScalarTruncate(Exp memory a, uint scalar) pure internal returns (MathError, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 855,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function mulScalarTruncateAddUInt(Exp memory a, uint scalar, uint addend) pure internal returns (MathError, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 883,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function divScalar(Exp memory a, uint scalar) pure internal returns (MathError, Exp memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 895,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function divScalarByExp(uint scalar, Exp memory divisor) pure internal returns (MathError, Exp memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 915,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function divScalarByExpTruncate(uint scalar, Exp memory divisor) pure internal returns (MathError, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 952,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function mulExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 977,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function mulExp(uint a, uint b) pure internal returns (MathError, Exp memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 984,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function mulExp3(Exp memory a, Exp memory b, Exp memory c) pure internal returns (MathError, Exp memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 997,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function divExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 1465,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 1702,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function mintInternal(uint mintAmount) internal nonReentrant returns (uint, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 3706,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getAccountLiquidity(address account) public view returns (uint, uint, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 3718,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getAccountLiquidityInternal(address account) internal view returns (Error, uint, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 3736,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint borrowAmount) public view returns (uint, uint, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 3757,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint borrowAmount) internal view returns (Error, uint, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 3835,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function liquidateCalculateSeizeTokens(address cTokenBorrowed, address cTokenCollateral, uint actualRepayAmount) external view returns (uint, uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UNCHECKED_CALL",
          "vulnerability_from_line": 2724,
          "vulnerability_to_line": null,
          "vulnerability_code": "        (bool success, ) = comptrollerImplementation.delegatecall(msg.data);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 2726,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 3036,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly { chainId := chainid() }\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 386,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1771,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function borrowFresh(address payable borrower, uint borrowAmount) internal returns (uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 386,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 778,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint constant expScale = 1e18;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 779,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint constant doubleScale = 1e36;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 780,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint constant halfExpScale = expScale/2;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 781,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint constant mantissaOne = expScale;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1771,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function borrowFresh(address payable borrower, uint borrowAmount) internal returns (uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1771,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function borrowFresh(address payable borrower, uint borrowAmount) internal returns (uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1771,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function borrowFresh(address payable borrower, uint borrowAmount) internal returns (uint) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1773,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint allowed = comptroller.borrowAllowed(address(this), borrower, borrowAmount);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1774,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (allowed != 0) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1775,
          "vulnerability_to_line": null,
          "vulnerability_code": "            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.BORROW_COMPTROLLER_REJECTION, allowed);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1775,
          "vulnerability_to_line": null,
          "vulnerability_code": "            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.BORROW_COMPTROLLER_REJECTION, allowed);\n",
          "message": null
        }
      ]
    },
    "oyente": {
      "successfull_analysis": false,
      "errors": [
        "exception (RuntimeError: Source map error, unknown name(SHR) or instr_name(INVALID))"
      ],
      "vulnerability_findings": []
    },
    "mythril": {
      "successfull_analysis": false,
      "errors": [
        "DOCKER_TIMEOUT"
      ],
      "vulnerability_findings": []
    },
    "osiris": {
      "successfull_analysis": false,
      "errors": [
        "Solidity compilation failed"
      ],
      "vulnerability_findings": []
    }
  }
}