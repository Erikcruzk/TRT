{
  "smartbugs_completed": true,
  "analyzer_results": {
    "semgrep": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "use-abi-encodecall-instead-of-encodewithselector",
          "vulnerability_from_line": 617,
          "vulnerability_to_line": null,
          "vulnerability_code": "        (bool success, bytes memory data) = address(_token).call(abi.encodeWithSelector(APPROVE_FUNC_SELECTOR, _spender, _value));\n",
          "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
        },
        {
          "name": "use-abi-encodecall-instead-of-encodewithselector",
          "vulnerability_from_line": 631,
          "vulnerability_to_line": null,
          "vulnerability_code": "       (bool success, bytes memory data) = address(_token).call(abi.encodeWithSelector(TRANSFER_FUNC_SELECTOR, _to, _value));\n",
          "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
        },
        {
          "name": "use-abi-encodecall-instead-of-encodewithselector",
          "vulnerability_from_line": 646,
          "vulnerability_to_line": null,
          "vulnerability_code": "       (bool success, bytes memory data) = address(_token).call(abi.encodeWithSelector(TRANSFER_FROM_FUNC_SELECTOR, _from, _to, _value));\n",
          "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
        },
        {
          "name": "use-abi-encodecall-instead-of-encodewithselector",
          "vulnerability_from_line": 2088,
          "vulnerability_to_line": null,
          "vulnerability_code": "        bytes memory data = abi.encodeWithSelector(IS_V28_OR_HIGHER_FUNC_SELECTOR);\n",
          "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
        },
        {
          "name": "inefficient-state-variable-increment",
          "vulnerability_from_line": 1123,
          "vulnerability_to_line": null,
          "vulnerability_code": "        reserveRatio += _weight;\n",
          "message": "<x> += <y> costs more gas than <x> = <x> + <y> for state variables."
        },
        {
          "name": "init-variables-with-default-value",
          "vulnerability_from_line": 507,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bool private locked = false;\n",
          "message": "Uninitialized variables are assigned with the types default value. Explicitly initializing a variable with its default value costs unnecessary gas."
        },
        {
          "name": "init-variables-with-default-value",
          "vulnerability_from_line": 782,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint32 public reserveRatio = 0;                     // ratio between the reserves and the market cap, equal to the total reserve weights\n",
          "message": "Uninitialized variables are assigned with the types default value. Explicitly initializing a variable with its default value costs unnecessary gas."
        },
        {
          "name": "init-variables-with-default-value",
          "vulnerability_from_line": 783,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint32 public override maxConversionFee = 0;        // maximum conversion fee for the lifetime of the contract,\n",
          "message": "Uninitialized variables are assigned with the types default value. Explicitly initializing a variable with its default value costs unnecessary gas."
        },
        {
          "name": "init-variables-with-default-value",
          "vulnerability_from_line": 785,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint32 public override conversionFee = 0;           // current conversion fee, represented in ppm, 0...maxConversionFee\n",
          "message": "Uninitialized variables are assigned with the types default value. Explicitly initializing a variable with its default value costs unnecessary gas."
        },
        {
          "name": "init-variables-with-default-value",
          "vulnerability_from_line": 1651,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint256 public lastWeightAdjustmentMarketCap = 0;\n",
          "message": "Uninitialized variables are assigned with the types default value. Explicitly initializing a variable with its default value costs unnecessary gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 186,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor() public {\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 187,
          "vulnerability_to_line": null,
          "vulnerability_code": "        owner = msg.sender;\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 188,
          "vulnerability_to_line": null,
          "vulnerability_code": "    }\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 315,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor(IContractRegistry _registry) internal validAddress(address(_registry)) {\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 316,
          "vulnerability_to_line": null,
          "vulnerability_code": "        registry = IContractRegistry(_registry);\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 317,
          "vulnerability_to_line": null,
          "vulnerability_code": "        prevRegistry = IContractRegistry(_registry);\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 318,
          "vulnerability_to_line": null,
          "vulnerability_code": "    }\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 512,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor() internal {}\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 1376,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor(\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 1377,
          "vulnerability_to_line": null,
          "vulnerability_code": "        IDSToken _token,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 1378,
          "vulnerability_to_line": null,
          "vulnerability_code": "        IContractRegistry _registry,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 1379,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint32 _maxConversionFee\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 1380,
          "vulnerability_to_line": null,
          "vulnerability_code": "    )\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 1381,
          "vulnerability_to_line": null,
          "vulnerability_code": "        ConverterBase(_token, _registry, _maxConversionFee)\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 1382,
          "vulnerability_to_line": null,
          "vulnerability_code": "        public\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 1383,
          "vulnerability_to_line": null,
          "vulnerability_code": "    {\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 1384,
          "vulnerability_to_line": null,
          "vulnerability_code": "    }\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 1666,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor(\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 1667,
          "vulnerability_to_line": null,
          "vulnerability_code": "        IDSToken _token,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 1668,
          "vulnerability_to_line": null,
          "vulnerability_code": "        IContractRegistry _registry,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 1669,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint32 _maxConversionFee\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 1670,
          "vulnerability_to_line": null,
          "vulnerability_code": "    )\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 1671,
          "vulnerability_to_line": null,
          "vulnerability_code": "        LiquidTokenConverter(_token, _registry, _maxConversionFee)\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 1672,
          "vulnerability_to_line": null,
          "vulnerability_code": "        public\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 1673,
          "vulnerability_to_line": null,
          "vulnerability_code": "    {\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 1674,
          "vulnerability_to_line": null,
          "vulnerability_code": "    }\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 1852,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor(IContractRegistry _registry, IEtherToken _etherToken) ContractRegistryClient(_registry) public {\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 1853,
          "vulnerability_to_line": null,
          "vulnerability_code": "        etherToken = _etherToken;\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 1854,
          "vulnerability_to_line": null,
          "vulnerability_code": "    }\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 1979,
          "vulnerability_to_line": null,
          "vulnerability_code": "            else if (reserveAddress == etherToken) {\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 2019,
          "vulnerability_to_line": null,
          "vulnerability_code": "            else if (reserveAddress == etherToken) {\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 2020,
          "vulnerability_to_line": null,
          "vulnerability_code": "                reserveBalance = etherToken.balanceOf(address(_oldConverter));\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 2021,
          "vulnerability_to_line": null,
          "vulnerability_code": "                _oldConverter.withdrawTokens(etherToken, address(this), reserveBalance);\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 2022,
          "vulnerability_to_line": null,
          "vulnerability_code": "                etherToken.withdrawTo(address(_newConverter), reserveBalance);\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 1970,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint16 i = 0; i < reserveTokenCount; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 2012,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint16 i = 0; i < reserveTokenCount; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 2050,
          "vulnerability_to_line": null,
          "vulnerability_code": "            for (uint16 i = 0; i < reserveTokenCount; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 198,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == owner, \"ERR_ACCESS_DENIED\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 209,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_newOwner != owner, \"ERR_SAME_OWNER\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 217,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == newOwner, \"ERR_ACCESS_DENIED\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 241,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_value > 0, \"ERR_ZERO_VALUE\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 252,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_address != address(0), \"ERR_INVALID_ADDRESS\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 263,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_address != address(this), \"ERR_ADDRESS_IS_SELF\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 307,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == addressOf(_contractName), \"ERR_ACCESS_DENIED\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 325,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == owner || !onlyOwnerCanUpdateRegistry, \"ERR_ACCESS_DENIED\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 331,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(newRegistry != registry && address(newRegistry) != address(0), \"ERR_INVALID_REGISTRY\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 334,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(newRegistry.addressOf(CONTRACT_REGISTRY) != address(0), \"ERR_INVALID_REGISTRY\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 524,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(!locked, \"ERR_REENTRANCY\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 547,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(z >= _x, \"ERR_OVERFLOW\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 560,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_x >= _y, \"ERR_UNDERFLOW\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 578,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(z / _x == _y, \"ERR_OVERFLOW\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 591,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_y > 0, \"ERR_DIVIDE_BY_ZERO\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 618,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(success && (data.length == 0 || abi.decode(data, (bool))), 'ERR_APPROVE_FAILED');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 632,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(success && (data.length == 0 || abi.decode(data, (bool))), 'ERR_TRANSFER_FAILED');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 647,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(success && (data.length == 0 || abi.decode(data, (bool))), 'ERR_TRANSFER_FROM_FAILED');\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 870,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(isActive(), \"ERR_INACTIVE\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 881,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(!isActive(), \"ERR_ACTIVE\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 892,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(reserves[_address].isSet, \"ERR_INVALID_RESERVE\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 903,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_conversionFee <= PPM_RESOLUTION, \"ERR_INVALID_CONVERSION_FEE\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 914,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_weight > 0 && _weight <= PPM_RESOLUTION, \"ERR_INVALID_RESERVE_WEIGHT\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 933,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(reserves[ETH_RESERVE_ADDRESS].isSet, \"ERR_INVALID_RESERVE\"); // require(hasETHReserve(), \"ERR_INVALID_RESERVE\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 957,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(!isActive() || owner == converterUpgrader, \"ERR_ACCESS_DENIED\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1024,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(reserveTokenCount() > 0, \"ERR_INVALID_RESERVE_COUNT\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1036,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_conversionFee <= maxConversionFee, \"ERR_INVALID_CONVERSION_FEE\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1062,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(!reserves[_token].isSet || !isActive() || owner == converterUpgrader, \"ERR_ACCESS_DENIED\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1114,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(address(_token) != address(anchor) && !reserves[_token].isSet, \"ERR_INVALID_RESERVE\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1115,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_weight <= PPM_RESOLUTION - reserveRatio, \"ERR_INVALID_RESERVE_WEIGHT\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1116,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(reserveTokenCount() < uint16(-1), \"ERR_INVALID_RESERVE_COUNT\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1191,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_sourceToken != _targetToken, \"ERR_SAME_SOURCE_TARGET\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1194,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(address(conversionWhitelist) == address(0) ||\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1195,
          "vulnerability_to_line": null,
          "vulnerability_code": "                (conversionWhitelist.isWhitelisted(_trader) && conversionWhitelist.isWhitelisted(_beneficiary)),\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1196,
          "vulnerability_to_line": null,
          "vulnerability_code": "                \"ERR_NOT_WHITELISTED\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1417,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(reserveTokenCount() == 0, \"ERR_INVALID_RESERVE_COUNT\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1439,
          "vulnerability_to_line": null,
          "vulnerability_code": "        revert(\"ERR_INVALID_TOKEN\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1472,
          "vulnerability_to_line": null,
          "vulnerability_code": "            revert(\"ERR_INVALID_TOKEN\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1564,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(amount != 0, \"ERR_ZERO_TARGET_AMOUNT\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1570,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(msg.value == _amount, \"ERR_ETH_AMOUNT_MISMATCH\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1572,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(msg.value == 0 && reserveToken.balanceOf(address(this)).sub(reserveBalance(reserveToken)) >= _amount, \"ERR_INVALID_AMOUNT\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1597,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_amount <= IDSToken(address(anchor)).balanceOf(address(this)), \"ERR_INVALID_AMOUNT\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1603,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(amount != 0, \"ERR_ZERO_TARGET_AMOUNT\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1763,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(currentMarketCap > (lastWeightAdjustmentMarketCap.add(marketCapThreshold)), \"ERR_MARKET_CAP_BELOW_THRESHOLD\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1768,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(newWeight >= minimumWeight, \"ERR_INVALID_RESERVE_WEIGHT\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 331,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(newRegistry != registry && address(newRegistry) != address(0), \"ERR_INVALID_REGISTRY\");\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 618,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(success && (data.length == 0 || abi.decode(data, (bool))), 'ERR_APPROVE_FAILED');\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 632,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(success && (data.length == 0 || abi.decode(data, (bool))), 'ERR_TRANSFER_FAILED');\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 647,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(success && (data.length == 0 || abi.decode(data, (bool))), 'ERR_TRANSFER_FROM_FAILED');\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 914,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_weight > 0 && _weight <= PPM_RESOLUTION, \"ERR_INVALID_RESERVE_WEIGHT\");\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 1114,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(address(_token) != address(anchor) && !reserves[_token].isSet, \"ERR_INVALID_RESERVE\");\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 1194,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(address(conversionWhitelist) == address(0) ||\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 1195,
          "vulnerability_to_line": null,
          "vulnerability_code": "                (conversionWhitelist.isWhitelisted(_trader) && conversionWhitelist.isWhitelisted(_beneficiary)),\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 1196,
          "vulnerability_to_line": null,
          "vulnerability_code": "                \"ERR_NOT_WHITELISTED\");\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 1572,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(msg.value == 0 && reserveToken.balanceOf(address(this)).sub(reserveBalance(reserveToken)) >= _amount, \"ERR_INVALID_AMOUNT\");\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 1433,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (_targetToken == IDSToken(address(anchor)) && reserves[_sourceToken].isSet)\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 1434,
          "vulnerability_to_line": null,
          "vulnerability_code": "            return purchaseTargetAmount(_amount);\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 1435,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (_sourceToken == IDSToken(address(anchor)) && reserves[_targetToken].isSet)\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 1436,
          "vulnerability_to_line": null,
          "vulnerability_code": "            return saleTargetAmount(_amount);\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 1462,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (_targetToken == IDSToken(address(anchor)) && reserves[_sourceToken].isSet) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 1463,
          "vulnerability_to_line": null,
          "vulnerability_code": "            reserveToken = _sourceToken;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 1464,
          "vulnerability_to_line": null,
          "vulnerability_code": "            targetAmount = buy(_amount, _trader, _beneficiary);\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 1465,
          "vulnerability_to_line": null,
          "vulnerability_code": "        }\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 1466,
          "vulnerability_to_line": null,
          "vulnerability_code": "        else if (_sourceToken == IDSToken(address(anchor)) && reserves[_targetToken].isSet) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 1467,
          "vulnerability_to_line": null,
          "vulnerability_code": "            reserveToken = _targetToken;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 1468,
          "vulnerability_to_line": null,
          "vulnerability_code": "            targetAmount = sell(_amount, _trader, _beneficiary);\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 1469,
          "vulnerability_to_line": null,
          "vulnerability_code": "        }\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 1470,
          "vulnerability_to_line": null,
          "vulnerability_code": "        else {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 1471,
          "vulnerability_to_line": null,
          "vulnerability_code": "            // invalid input\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 1466,
          "vulnerability_to_line": null,
          "vulnerability_code": "        else if (_sourceToken == IDSToken(address(anchor)) && reserves[_targetToken].isSet) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 1467,
          "vulnerability_to_line": null,
          "vulnerability_code": "            reserveToken = _targetToken;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 1468,
          "vulnerability_to_line": null,
          "vulnerability_code": "            targetAmount = sell(_amount, _trader, _beneficiary);\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 1469,
          "vulnerability_to_line": null,
          "vulnerability_code": "        }\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 1470,
          "vulnerability_to_line": null,
          "vulnerability_code": "        else {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 1471,
          "vulnerability_to_line": null,
          "vulnerability_code": "            // invalid input\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 1472,
          "vulnerability_to_line": null,
          "vulnerability_code": "            revert(\"ERR_INVALID_TOKEN\");\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 1473,
          "vulnerability_to_line": null,
          "vulnerability_code": "        }\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 2091,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (success && returnData.length == 32) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 2092,
          "vulnerability_to_line": null,
          "vulnerability_code": "            return abi.decode(returnData, (bool));\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 2093,
          "vulnerability_to_line": null,
          "vulnerability_code": "        }\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 1251,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 i = 0; i < reserveCount; i++)\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 1970,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint16 i = 0; i < reserveTokenCount; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 2012,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint16 i = 0; i < reserveTokenCount; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 2050,
          "vulnerability_to_line": null,
          "vulnerability_code": "            for (uint16 i = 0; i < reserveTokenCount; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        }
      ]
    },
    "slither": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": []
    },
    "smartcheck": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 763,
          "vulnerability_to_line": null,
          "vulnerability_code": "    IERC20Token internal constant ETH_RESERVE_ADDRESS = IERC20Token(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 1828,
          "vulnerability_to_line": null,
          "vulnerability_code": "    IERC20Token private constant ETH_RESERVE_ADDRESS = IERC20Token(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 220,
          "vulnerability_to_line": null,
          "vulnerability_code": "        newOwner = address(0);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_LOCKED_MONEY",
          "vulnerability_from_line": 1368,
          "vulnerability_to_line": null,
          "vulnerability_code": "contract LiquidTokenConverter is ConverterBase {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 507,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bool private locked = false;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 603,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bytes4 private constant APPROVE_FUNC_SELECTOR = bytes4(keccak256(\"approve(address,uint256)\"));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 604,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bytes4 private constant TRANSFER_FUNC_SELECTOR = bytes4(keccak256(\"transfer(address,uint256)\"));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 605,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bytes4 private constant TRANSFER_FROM_FUNC_SELECTOR = bytes4(keccak256(\"transferFrom(address,address,uint256)\"));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 1828,
          "vulnerability_to_line": null,
          "vulnerability_code": "    IERC20Token private constant ETH_RESERVE_ADDRESS = IERC20Token(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 2083,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bytes4 private constant IS_V28_OR_HIGHER_FUNC_SELECTOR = bytes4(keccak256(\"isV28OrHigher()\"));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SAFEMATH",
          "vulnerability_from_line": 760,
          "vulnerability_to_line": null,
          "vulnerability_code": "    using SafeMath for uint256;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 77,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function targetAmountAndFee(IERC20Token _sourceToken, IERC20Token _targetToken, uint256 _amount) external view returns (uint256, uint256);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 102,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function connectors(IERC20Token _address) external view returns (uint256, uint32, bool, bool, bool);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 414,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function latestRate(IERC20Token _tokenA, IERC20Token _tokenB) external view returns (uint256, uint256);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 416,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function latestRateAndUpdateTime(IERC20Token _tokenA, IERC20Token _tokenB) external view returns (uint256, uint256, uint256);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 491,
          "vulnerability_to_line": null,
          "vulnerability_code": "                             external view returns (uint32, uint32);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 926,
          "vulnerability_to_line": null,
          "vulnerability_code": "        returns (uint256, uint256);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 1432,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function targetAmountAndFee(IERC20Token _sourceToken, IERC20Token _targetToken, uint256 _amount) public view override returns (uint256, uint256) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UNCHECKED_CALL",
          "vulnerability_from_line": 617,
          "vulnerability_to_line": null,
          "vulnerability_code": "        (bool success, bytes memory data) = address(_token).call(abi.encodeWithSelector(APPROVE_FUNC_SELECTOR, _spender, _value));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UNCHECKED_CALL",
          "vulnerability_from_line": 631,
          "vulnerability_to_line": null,
          "vulnerability_code": "       (bool success, bytes memory data) = address(_token).call(abi.encodeWithSelector(TRANSFER_FUNC_SELECTOR, _to, _value));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UNCHECKED_CALL",
          "vulnerability_from_line": 646,
          "vulnerability_to_line": null,
          "vulnerability_code": "       (bool success, bytes memory data) = address(_token).call(abi.encodeWithSelector(TRANSFER_FROM_FUNC_SELECTOR, _from, _to, _value));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 78,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function convert(IERC20Token _sourceToken,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 95,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function withdrawETH(address payable _to) external;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 385,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function withdrawTo(address payable _to, uint256 _amount) external;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1454,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function doConvert(IERC20Token _sourceToken, IERC20Token _targetToken, uint256 _amount, address _trader, address payable _beneficiary)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 82,
          "vulnerability_to_line": null,
          "vulnerability_code": "                     address payable _beneficiary) external payable returns (uint256);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 88,
          "vulnerability_to_line": null,
          "vulnerability_code": "    receive() external payable;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 385,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function withdrawTo(address payable _to, uint256 _amount) external;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 385,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function withdrawTo(address payable _to, uint256 _amount) external;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 932,
          "vulnerability_to_line": null,
          "vulnerability_code": "    receive() external override payable {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 933,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(reserves[ETH_RESERVE_ADDRESS].isSet, \"ERR_INVALID_RESERVE\"); // require(hasETHReserve(), \"ERR_INVALID_RESERVE\");\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 933,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(reserves[ETH_RESERVE_ADDRESS].isSet, \"ERR_INVALID_RESERVE\"); // require(hasETHReserve(), \"ERR_INVALID_RESERVE\");\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 933,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(reserves[ETH_RESERVE_ADDRESS].isSet, \"ERR_INVALID_RESERVE\"); // require(hasETHReserve(), \"ERR_INVALID_RESERVE\");\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1457,
          "vulnerability_to_line": null,
          "vulnerability_code": "        returns (uint256)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1459,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint256 targetAmount;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1460,
          "vulnerability_to_line": null,
          "vulnerability_code": "        IERC20Token reserveToken;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1462,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (_targetToken == IDSToken(address(anchor)) && reserves[_sourceToken].isSet) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1462,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (_targetToken == IDSToken(address(anchor)) && reserves[_sourceToken].isSet) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1462,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (_targetToken == IDSToken(address(anchor)) && reserves[_sourceToken].isSet) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1462,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (_targetToken == IDSToken(address(anchor)) && reserves[_sourceToken].isSet) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1463,
          "vulnerability_to_line": null,
          "vulnerability_code": "            reserveToken = _sourceToken;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1464,
          "vulnerability_to_line": null,
          "vulnerability_code": "            targetAmount = buy(_amount, _trader, _beneficiary);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1464,
          "vulnerability_to_line": null,
          "vulnerability_code": "            targetAmount = buy(_amount, _trader, _beneficiary);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1464,
          "vulnerability_to_line": null,
          "vulnerability_code": "            targetAmount = buy(_amount, _trader, _beneficiary);\n",
          "message": null
        }
      ]
    },
    "oyente": {
      "successfull_analysis": false,
      "errors": [
        "Solidity compilation failed"
      ],
      "vulnerability_findings": []
    },
    "mythril": {
      "successfull_analysis": false,
      "errors": [
        "Solc experienced a fatal error"
      ],
      "vulnerability_findings": []
    },
    "osiris": {
      "successfull_analysis": false,
      "errors": [
        "Solidity compilation failed"
      ],
      "vulnerability_findings": []
    }
  }
}