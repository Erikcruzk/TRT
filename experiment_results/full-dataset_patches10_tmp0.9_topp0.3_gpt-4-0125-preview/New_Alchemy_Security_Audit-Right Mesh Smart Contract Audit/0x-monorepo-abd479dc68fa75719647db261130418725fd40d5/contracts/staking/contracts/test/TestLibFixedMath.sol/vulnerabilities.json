{
  "smartbugs_completed": true,
  "analyzer_results": {
    "semgrep": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "use-abi-encodecall-instead-of-encodewithselector",
          "vulnerability_from_line": 33,
          "vulnerability_to_line": null,
          "vulnerability_code": "        return abi.encodeWithSelector(STANDARD_ERROR_SELECTOR, bytes(message));\n",
          "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
        },
        {
          "name": "use-abi-encodecall-instead-of-encodewithselector",
          "vulnerability_from_line": 102,
          "vulnerability_to_line": null,
          "vulnerability_code": "        return abi.encodeWithSelector(\n",
          "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
        },
        {
          "name": "use-abi-encodecall-instead-of-encodewithselector",
          "vulnerability_from_line": 103,
          "vulnerability_to_line": null,
          "vulnerability_code": "            SIGNED_VALUE_ERROR_SELECTOR,\n",
          "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
        },
        {
          "name": "use-abi-encodecall-instead-of-encodewithselector",
          "vulnerability_from_line": 104,
          "vulnerability_to_line": null,
          "vulnerability_code": "            uint8(error),\n",
          "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
        },
        {
          "name": "use-abi-encodecall-instead-of-encodewithselector",
          "vulnerability_from_line": 105,
          "vulnerability_to_line": null,
          "vulnerability_code": "            n\n",
          "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
        },
        {
          "name": "use-abi-encodecall-instead-of-encodewithselector",
          "vulnerability_from_line": 106,
          "vulnerability_to_line": null,
          "vulnerability_code": "        );\n",
          "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
        },
        {
          "name": "use-abi-encodecall-instead-of-encodewithselector",
          "vulnerability_from_line": 117,
          "vulnerability_to_line": null,
          "vulnerability_code": "        return abi.encodeWithSelector(\n",
          "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
        },
        {
          "name": "use-abi-encodecall-instead-of-encodewithselector",
          "vulnerability_from_line": 118,
          "vulnerability_to_line": null,
          "vulnerability_code": "            UNSIGNED_VALUE_ERROR_SELECTOR,\n",
          "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
        },
        {
          "name": "use-abi-encodecall-instead-of-encodewithselector",
          "vulnerability_from_line": 119,
          "vulnerability_to_line": null,
          "vulnerability_code": "            uint8(error),\n",
          "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
        },
        {
          "name": "use-abi-encodecall-instead-of-encodewithselector",
          "vulnerability_from_line": 120,
          "vulnerability_to_line": null,
          "vulnerability_code": "            n\n",
          "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
        },
        {
          "name": "use-abi-encodecall-instead-of-encodewithselector",
          "vulnerability_from_line": 121,
          "vulnerability_to_line": null,
          "vulnerability_code": "        );\n",
          "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
        },
        {
          "name": "use-abi-encodecall-instead-of-encodewithselector",
          "vulnerability_from_line": 133,
          "vulnerability_to_line": null,
          "vulnerability_code": "        return abi.encodeWithSelector(\n",
          "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
        },
        {
          "name": "use-abi-encodecall-instead-of-encodewithselector",
          "vulnerability_from_line": 134,
          "vulnerability_to_line": null,
          "vulnerability_code": "            BIN_OP_ERROR_SELECTOR,\n",
          "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
        },
        {
          "name": "use-abi-encodecall-instead-of-encodewithselector",
          "vulnerability_from_line": 135,
          "vulnerability_to_line": null,
          "vulnerability_code": "            uint8(error),\n",
          "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
        },
        {
          "name": "use-abi-encodecall-instead-of-encodewithselector",
          "vulnerability_from_line": 136,
          "vulnerability_to_line": null,
          "vulnerability_code": "            a,\n",
          "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
        },
        {
          "name": "use-abi-encodecall-instead-of-encodewithselector",
          "vulnerability_from_line": 137,
          "vulnerability_to_line": null,
          "vulnerability_code": "            b\n",
          "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
        },
        {
          "name": "use-abi-encodecall-instead-of-encodewithselector",
          "vulnerability_from_line": 138,
          "vulnerability_to_line": null,
          "vulnerability_code": "        );\n",
          "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 501,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (c > 0 && a < 0 && b < 0) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 502,
          "vulnerability_to_line": null,
          "vulnerability_code": "            LibRichErrors.rrevert(LibFixedMathRichErrors.BinOpError(\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 503,
          "vulnerability_to_line": null,
          "vulnerability_code": "                LibFixedMathRichErrors.BinOpErrorCodes.SUBTRACTION_OVERFLOW,\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 504,
          "vulnerability_to_line": null,
          "vulnerability_code": "                a,\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 505,
          "vulnerability_to_line": null,
          "vulnerability_code": "                b\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 506,
          "vulnerability_to_line": null,
          "vulnerability_code": "            ));\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 507,
          "vulnerability_to_line": null,
          "vulnerability_code": "        }\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 508,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (c < 0 && a > 0 && b > 0) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 509,
          "vulnerability_to_line": null,
          "vulnerability_code": "            LibRichErrors.rrevert(LibFixedMathRichErrors.BinOpError(\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 510,
          "vulnerability_to_line": null,
          "vulnerability_code": "                LibFixedMathRichErrors.BinOpErrorCodes.ADDITION_OVERFLOW,\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 511,
          "vulnerability_to_line": null,
          "vulnerability_code": "                a,\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 512,
          "vulnerability_to_line": null,
          "vulnerability_code": "                b\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 513,
          "vulnerability_to_line": null,
          "vulnerability_code": "            ));\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 514,
          "vulnerability_to_line": null,
          "vulnerability_code": "        }\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        }
      ]
    },
    "slither": {
      "successfull_analysis": true,
      "errors": [
        "EXIT_CODE_28"
      ],
      "vulnerability_findings": [
        {
          "name": "constant-function",
          "vulnerability_from_line": 38,
          "vulnerability_to_line": 42,
          "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
          "message": "LibRichErrors.rrevert (TestLibFixedMath.sol#38-42) is declared view but contains assembly code\n"
        },
        {
          "name": "uninitialized-local",
          "vulnerability_from_line": 307,
          "vulnerability_to_line": null,
          "vulnerability_code": "        int256 y;\n",
          "message": "y in LibFixedMath._ln (TestLibFixedMath.sol#307) is a local variable never initialiazed\n"
        },
        {
          "name": "uninitialized-local",
          "vulnerability_from_line": 397,
          "vulnerability_to_line": null,
          "vulnerability_code": "        int256 y;\n",
          "message": "y in LibFixedMath._exp (TestLibFixedMath.sol#397) is a local variable never initialiazed\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 38,
          "vulnerability_to_line": 42,
          "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
          "message": "LibRichErrors.rrevert uses assembly (TestLibFixedMath.sol#38-42)\n\t- TestLibFixedMath.sol#39-41\n"
        },
        {
          "name": "solc-version",
          "vulnerability_from_line": 21,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.9;\n",
          "message": "Detected issues with version pragma in TestLibFixedMath.sol:\n\t- pragma solidity^0.5.9 (TestLibFixedMath.sol#21): it allows old versions\n\t- pragma solidity^0.5.9 (TestLibFixedMath.sol#65): it allows old versions\n\t- pragma solidity^0.5.9 (TestLibFixedMath.sol#162): it allows old versions\n\t- pragma solidity^0.5.9 (TestLibFixedMath.sol#537): it allows old versions\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 32,
          "vulnerability_to_line": 34,
          "vulnerability_code": "    function StandardError(string memory message) internal pure returns (bytes memory) {\n\n        return abi.encodeWithSelector(STANDARD_ERROR_SELECTOR, bytes(message));\n",
          "message": "Function 'LibRichErrors.StandardError' (TestLibFixedMath.sol#32-34) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 94,
          "vulnerability_to_line": 107,
          "vulnerability_code": "    function SignedValueError(\n\n        ValueErrorCodes error,\n\n        int256 n\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            SIGNED_VALUE_ERROR_SELECTOR,\n\n            uint8(error),\n\n            n\n\n        );\n",
          "message": "Function 'LibFixedMathRichErrors.SignedValueError' (TestLibFixedMath.sol#94-107) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 109,
          "vulnerability_to_line": 122,
          "vulnerability_code": "    function UnsignedValueError(\n\n        ValueErrorCodes error,\n\n        uint256 n\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            UNSIGNED_VALUE_ERROR_SELECTOR,\n\n            uint8(error),\n\n            n\n\n        );\n",
          "message": "Function 'LibFixedMathRichErrors.UnsignedValueError' (TestLibFixedMath.sol#109-122) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 124,
          "vulnerability_to_line": 139,
          "vulnerability_code": "    function BinOpError(\n\n        BinOpErrorCodes error,\n\n        int256 a,\n\n        int256 b\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            BIN_OP_ERROR_SELECTOR,\n\n            uint8(error),\n\n            a,\n\n            b\n\n        );\n",
          "message": "Function 'LibFixedMathRichErrors.BinOpError' (TestLibFixedMath.sol#124-139) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 181,
          "vulnerability_to_line": 183,
          "vulnerability_code": "    function _one() internal pure returns (int256 f) {\n\n        f = FIXED_1;\n",
          "message": "Function 'LibFixedMath._one' (TestLibFixedMath.sol#181-183) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 186,
          "vulnerability_to_line": 188,
          "vulnerability_code": "    function _add(int256 a, int256 b) internal pure returns (int256 c) {\n\n        c = __add(a, b);\n",
          "message": "Function 'LibFixedMath._add' (TestLibFixedMath.sol#186-188) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 191,
          "vulnerability_to_line": 193,
          "vulnerability_code": "    function _sub(int256 a, int256 b) internal pure returns (int256 c) {\n\n        c = __add(a, -b);\n",
          "message": "Function 'LibFixedMath._sub' (TestLibFixedMath.sol#191-193) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 196,
          "vulnerability_to_line": 198,
          "vulnerability_code": "    function _mul(int256 a, int256 b) internal pure returns (int256 c) {\n\n        c = __mul(a, b) / FIXED_1;\n",
          "message": "Function 'LibFixedMath._mul' (TestLibFixedMath.sol#196-198) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 201,
          "vulnerability_to_line": 203,
          "vulnerability_code": "    function _div(int256 a, int256 b) internal pure returns (int256 c) {\n\n        c = __div(__mul(a, FIXED_1), b);\n",
          "message": "Function 'LibFixedMath._div' (TestLibFixedMath.sol#201-203) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 206,
          "vulnerability_to_line": 208,
          "vulnerability_code": "    function _mulDiv(int256 a, int256 n, int256 d) internal pure returns (int256 c) {\n\n        c = __div(__mul(a, n), d);\n",
          "message": "Function 'LibFixedMath._mulDiv' (TestLibFixedMath.sol#206-208) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 213,
          "vulnerability_to_line": 225,
          "vulnerability_code": "    function _uintMul(int256 f, uint256 u) internal pure returns (uint256) {\n\n        if (int256(u) < int256(0)) {\n\n            LibRichErrors.rrevert(LibFixedMathRichErrors.UnsignedValueError(\n\n                LibFixedMathRichErrors.ValueErrorCodes.TOO_LARGE,\n\n                u\n\n            ));\n\n        }\n\n        int256 c = __mul(f, int256(u));\n\n        if (c <= 0) {\n\n            return 0;\n\n        }\n\n        return uint256(uint256(c) >> 127);\n",
          "message": "Function 'LibFixedMath._uintMul' (TestLibFixedMath.sol#213-225) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 228,
          "vulnerability_to_line": 234,
          "vulnerability_code": "    function _abs(int256 f) internal pure returns (int256 c) {\n\n        if (f >= 0) {\n\n            c = f;\n\n        } else {\n\n            c = -f;\n\n        }\n",
          "message": "Function 'LibFixedMath._abs' (TestLibFixedMath.sol#228-234) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 237,
          "vulnerability_to_line": 239,
          "vulnerability_code": "    function _invert(int256 f) internal pure returns (int256 c) {\n\n        c = __div(FIXED_1_SQUARED, f);\n",
          "message": "Function 'LibFixedMath._invert' (TestLibFixedMath.sol#237-239) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 242,
          "vulnerability_to_line": 244,
          "vulnerability_code": "    function _toFixed(int256 n) internal pure returns (int256 f) {\n\n        f = __mul(n, FIXED_1);\n",
          "message": "Function 'LibFixedMath._toFixed' (TestLibFixedMath.sol#242-244) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 247,
          "vulnerability_to_line": 249,
          "vulnerability_code": "    function _toFixed(int256 n, int256 d) internal pure returns (int256 f) {\n\n        f = __div(__mul(n, FIXED_1), d);\n",
          "message": "Function 'LibFixedMath._toFixed' (TestLibFixedMath.sol#247-249) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 253,
          "vulnerability_to_line": 261,
          "vulnerability_code": "    function _toFixed(uint256 n) internal pure returns (int256 f) {\n\n        if (int256(n) < int256(0)) {\n\n            LibRichErrors.rrevert(LibFixedMathRichErrors.UnsignedValueError(\n\n                LibFixedMathRichErrors.ValueErrorCodes.TOO_LARGE,\n\n                n\n\n            ));\n\n        }\n\n        f = __mul(int256(n), FIXED_1);\n",
          "message": "Function 'LibFixedMath._toFixed' (TestLibFixedMath.sol#253-261) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 265,
          "vulnerability_to_line": 279,
          "vulnerability_code": "    function _toFixed(uint256 n, uint256 d) internal pure returns (int256 f) {\n\n        if (int256(n) < int256(0)) {\n\n            LibRichErrors.rrevert(LibFixedMathRichErrors.UnsignedValueError(\n\n                LibFixedMathRichErrors.ValueErrorCodes.TOO_LARGE,\n\n                n\n\n            ));\n\n        }\n\n        if (int256(d) < int256(0)) {\n\n            LibRichErrors.rrevert(LibFixedMathRichErrors.UnsignedValueError(\n\n                LibFixedMathRichErrors.ValueErrorCodes.TOO_LARGE,\n\n                d\n\n            ));\n\n        }\n\n        f = __div(__mul(int256(n), FIXED_1), int256(d));\n",
          "message": "Function 'LibFixedMath._toFixed' (TestLibFixedMath.sol#265-279) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 282,
          "vulnerability_to_line": 284,
          "vulnerability_code": "    function _toInteger(int256 f) internal pure returns (int256 n) {\n\n        return f / FIXED_1;\n",
          "message": "Function 'LibFixedMath._toInteger' (TestLibFixedMath.sol#282-284) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 287,
          "vulnerability_to_line": 372,
          "vulnerability_code": "    function _ln(int256 x) internal pure returns (int256 r) {\n\n        if (x > LN_MAX_VAL) {\n\n            LibRichErrors.rrevert(LibFixedMathRichErrors.SignedValueError(\n\n                LibFixedMathRichErrors.ValueErrorCodes.TOO_LARGE,\n\n                x\n\n            ));\n\n        }\n\n        if (x <= 0) {\n\n            LibRichErrors.rrevert(LibFixedMathRichErrors.SignedValueError(\n\n                LibFixedMathRichErrors.ValueErrorCodes.TOO_SMALL,\n\n                x\n\n            ));\n\n        }\n\n        if (x == FIXED_1) {\n\n            return 0;\n\n        }\n\n        if (x <= LN_MIN_VAL) {\n\n            return EXP_MIN_VAL;\n\n        }\n\n\n\n        int256 y;\n\n        int256 z;\n\n        int256 w;\n\n\n\n        // Rewrite the input as a quotient of negative natural exponents and a single residual q, such that 1 < q < 2\n\n        // For example: log(0.3) = log(e^-1 * e^-0.25 * 1.0471028872385522)\n\n        //              = 1 - 0.25 - log(1 + 0.0471028872385522)\n\n        // e ^ -32\n\n        if (x <= int256(0x00000000000000000000000000000000000000000001c8464f76164760000000)) {\n\n            r -= int256(0x0000000000000000000000000000001000000000000000000000000000000000); // - 32\n\n            x = x * FIXED_1 / int256(0x00000000000000000000000000000000000000000001c8464f76164760000000); // / e ^ -32\n\n        }\n\n        // e ^ -16\n\n        if (x <= int256(0x00000000000000000000000000000000000000f1aaddd7742e90000000000000)) {\n\n            r -= int256(0x0000000000000000000000000000000800000000000000000000000000000000); // - 16\n\n            x = x * FIXED_1 / int256(0x00000000000000000000000000000000000000f1aaddd7742e90000000000000); // / e ^ -16\n\n        }\n\n        // e ^ -8\n\n        if (x <= int256(0x00000000000000000000000000000000000afe10820813d78000000000000000)) {\n\n            r -= int256(0x0000000000000000000000000000000400000000000000000000000000000000); // - 8\n\n            x = x * FIXED_1 / int256(0x00000000000000000000000000000000000afe10820813d78000000000000000); // / e ^ -8\n\n        }\n\n        // e ^ -4\n\n        if (x <= int256(0x0000000000000000000000000000000002582ab704279ec00000000000000000)) {\n\n            r -= int256(0x0000000000000000000000000000000200000000000000000000000000000000); // - 4\n\n            x = x * FIXED_1 / int256(0x0000000000000000000000000000000002582ab704279ec00000000000000000); // / e ^ -4\n\n        }\n\n        // e ^ -2\n\n        if (x <= int256(0x000000000000000000000000000000001152aaa3bf81cc000000000000000000)) {\n\n            r -= int256(0x0000000000000000000000000000000100000000000000000000000000000000); // - 2\n\n            x = x * FIXED_1 / int256(0x000000000000000000000000000000001152aaa3bf81cc000000000000000000); // / e ^ -2\n\n        }\n\n        // e ^ -1\n\n        if (x <= int256(0x000000000000000000000000000000002f16ac6c59de70000000000000000000)) {\n\n            r -= int256(0x0000000000000000000000000000000080000000000000000000000000000000); // - 1\n\n            x = x * FIXED_1 / int256(0x000000000000000000000000000000002f16ac6c59de70000000000000000000); // / e ^ -1\n\n        }\n\n        // e ^ -0.5\n\n        if (x <= int256(0x000000000000000000000000000000004da2cbf1be5828000000000000000000)) {\n\n            r -= int256(0x0000000000000000000000000000000040000000000000000000000000000000); // - 0.5\n\n            x = x * FIXED_1 / int256(0x000000000000000000000000000000004da2cbf1be5828000000000000000000); // / e ^ -0.5\n\n        }\n\n        // e ^ -0.25\n\n        if (x <= int256(0x0000000000000000000000000000000063afbe7ab2082c000000000000000000)) {\n\n            r -= int256(0x0000000000000000000000000000000020000000000000000000000000000000); // - 0.25\n\n            x = x * FIXED_1 / int256(0x0000000000000000000000000000000063afbe7ab2082c000000000000000000); // / e ^ -0.25\n\n        }\n\n        // e ^ -0.125\n\n        if (x <= int256(0x0000000000000000000000000000000070f5a893b608861e1f58934f97aea57d)) {\n\n            r -= int256(0x0000000000000000000000000000000010000000000000000000000000000000); // - 0.125\n\n            x = x * FIXED_1 / int256(0x0000000000000000000000000000000070f5a893b608861e1f58934f97aea57d); // / e ^ -0.125\n\n        }\n\n        // `x` is now our residual in the range of 1 <= x <= 2 (or close enough).\n\n\n\n        // Add the taylor series for log(1 + z), where z = x - 1\n\n        z = y = x - FIXED_1;\n\n        w = y * y / FIXED_1;\n\n        r += z * (0x100000000000000000000000000000000 - y) / 0x100000000000000000000000000000000; z = z * w / FIXED_1; // add y^01 / 01 - y^02 / 02\n\n        r += z * (0x0aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa - y) / 0x200000000000000000000000000000000; z = z * w / FIXED_1; // add y^03 / 03 - y^04 / 04\n\n        r += z * (0x099999999999999999999999999999999 - y) / 0x300000000000000000000000000000000; z = z * w / FIXED_1; // add y^05 / 05 - y^06 / 06\n\n        r += z * (0x092492492492492492492492492492492 - y) / 0x400000000000000000000000000000000; z = z * w / FIXED_1; // add y^07 / 07 - y^08 / 08\n\n        r += z * (0x08e38e38e38e38e38e38e38e38e38e38e - y) / 0x500000000000000000000000000000000; z = z * w / FIXED_1; // add y^09 / 09 - y^10 / 10\n\n        r += z * (0x08ba2e8ba2e8ba2e8ba2e8ba2e8ba2e8b - y) / 0x600000000000000000000000000000000; z = z * w / FIXED_1; // add y^11 / 11 - y^12 / 12\n\n        r += z * (0x089d89d89d89d89d89d89d89d89d89d89 - y) / 0x700000000000000000000000000000000; z = z * w / FIXED_1; // add y^13 / 13 - y^14 / 14\n\n        r += z * (0x088888888888888888888888888888888 - y) / 0x800000000000000000000000000000000;                      // add y^15 / 15 - y^16 / 16\n",
          "message": "Function 'LibFixedMath._ln' (TestLibFixedMath.sol#287-372) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 375,
          "vulnerability_to_line": 469,
          "vulnerability_code": "    function _exp(int256 x) internal pure returns (int256 r) {\n\n        if (x < EXP_MIN_VAL) {\n\n            // Saturate to zero below EXP_MIN_VAL.\n\n            return 0;\n\n        }\n\n        if (x == 0) {\n\n            return FIXED_1;\n\n        }\n\n        if (x > EXP_MAX_VAL) {\n\n            LibRichErrors.rrevert(LibFixedMathRichErrors.SignedValueError(\n\n                LibFixedMathRichErrors.ValueErrorCodes.TOO_LARGE,\n\n                x\n\n            ));\n\n        }\n\n\n\n        // Rewrite the input as a product of natural exponents and a\n\n        // single residual q, where q is a number of small magnitude.\n\n        // For example: e^-34.419 = e^(-32 - 2 - 0.25 - 0.125 - 0.044)\n\n        //              = e^-32 * e^-2 * e^-0.25 * e^-0.125 * e^-0.044\n\n        //              -> q = -0.044\n\n\n\n        // Multiply with the taylor series for e^q\n\n        int256 y;\n\n        int256 z;\n\n        // q = x % 0.125 (the residual)\n\n        z = y = x % 0x0000000000000000000000000000000010000000000000000000000000000000;\n\n        z = z * y / FIXED_1; r += z * 0x10e1b3be415a0000; // add y^02 * (20! / 02!)\n\n        z = z * y / FIXED_1; r += z * 0x05a0913f6b1e0000; // add y^03 * (20! / 03!)\n\n        z = z * y / FIXED_1; r += z * 0x0168244fdac78000; // add y^04 * (20! / 04!)\n\n        z = z * y / FIXED_1; r += z * 0x004807432bc18000; // add y^05 * (20! / 05!)\n\n        z = z * y / FIXED_1; r += z * 0x000c0135dca04000; // add y^06 * (20! / 06!)\n\n        z = z * y / FIXED_1; r += z * 0x0001b707b1cdc000; // add y^07 * (20! / 07!)\n\n        z = z * y / FIXED_1; r += z * 0x000036e0f639b800; // add y^08 * (20! / 08!)\n\n        z = z * y / FIXED_1; r += z * 0x00000618fee9f800; // add y^09 * (20! / 09!)\n\n        z = z * y / FIXED_1; r += z * 0x0000009c197dcc00; // add y^10 * (20! / 10!)\n\n        z = z * y / FIXED_1; r += z * 0x0000000e30dce400; // add y^11 * (20! / 11!)\n\n        z = z * y / FIXED_1; r += z * 0x000000012ebd1300; // add y^12 * (20! / 12!)\n\n        z = z * y / FIXED_1; r += z * 0x0000000017499f00; // add y^13 * (20! / 13!)\n\n        z = z * y / FIXED_1; r += z * 0x0000000001a9d480; // add y^14 * (20! / 14!)\n\n        z = z * y / FIXED_1; r += z * 0x00000000001c6380; // add y^15 * (20! / 15!)\n\n        z = z * y / FIXED_1; r += z * 0x000000000001c638; // add y^16 * (20! / 16!)\n\n        z = z * y / FIXED_1; r += z * 0x0000000000001ab8; // add y^17 * (20! / 17!)\n\n        z = z * y / FIXED_1; r += z * 0x000000000000017c; // add y^18 * (20! / 18!)\n\n        z = z * y / FIXED_1; r += z * 0x0000000000000014; // add y^19 * (20! / 19!)\n\n        z = z * y / FIXED_1; r += z * 0x0000000000000001; // add y^20 * (20! / 20!)\n\n        r = r / 0x21c3677c82b40000 + y + FIXED_1; // divide by 20! and then add y^1 / 1! + y^0 / 0!\n\n\n\n        // Multiply with the non-residual terms.\n\n        x = -x;\n\n        // e ^ -32\n\n        if ((x & int256(0x0000000000000000000000000000001000000000000000000000000000000000)) != 0) {\n\n            r = r * int256(0x00000000000000000000000000000000000000f1aaddd7742e56d32fb9f99744)\n\n                / int256(0x0000000000000000000000000043cbaf42a000812488fc5c220ad7b97bf6e99e); // * e ^ -32\n\n        }\n\n        // e ^ -16\n\n        if ((x & int256(0x0000000000000000000000000000000800000000000000000000000000000000)) != 0) {\n\n            r = r * int256(0x00000000000000000000000000000000000afe10820813d65dfe6a33c07f738f)\n\n                / int256(0x000000000000000000000000000005d27a9f51c31b7c2f8038212a0574779991); // * e ^ -16\n\n        }\n\n        // e ^ -8\n\n        if ((x & int256(0x0000000000000000000000000000000400000000000000000000000000000000)) != 0) {\n\n            r = r * int256(0x0000000000000000000000000000000002582ab704279e8efd15e0265855c47a)\n\n                / int256(0x0000000000000000000000000000001b4c902e273a58678d6d3bfdb93db96d02); // * e ^ -8\n\n        }\n\n        // e ^ -4\n\n        if ((x & int256(0x0000000000000000000000000000000200000000000000000000000000000000)) != 0) {\n\n            r = r * int256(0x000000000000000000000000000000001152aaa3bf81cb9fdb76eae12d029571)\n\n                / int256(0x00000000000000000000000000000003b1cc971a9bb5b9867477440d6d157750); // * e ^ -4\n\n        }\n\n        // e ^ -2\n\n        if ((x & int256(0x0000000000000000000000000000000100000000000000000000000000000000)) != 0) {\n\n            r = r * int256(0x000000000000000000000000000000002f16ac6c59de6f8d5d6f63c1482a7c86)\n\n                / int256(0x000000000000000000000000000000015bf0a8b1457695355fb8ac404e7a79e3); // * e ^ -2\n\n        }\n\n        // e ^ -1\n\n        if ((x & int256(0x0000000000000000000000000000000080000000000000000000000000000000)) != 0) {\n\n            r = r * int256(0x000000000000000000000000000000004da2cbf1be5827f9eb3ad1aa9866ebb3)\n\n                / int256(0x00000000000000000000000000000000d3094c70f034de4b96ff7d5b6f99fcd8); // * e ^ -1\n\n        }\n\n        // e ^ -0.5\n\n        if ((x & int256(0x0000000000000000000000000000000040000000000000000000000000000000)) != 0) {\n\n            r = r * int256(0x0000000000000000000000000000000063afbe7ab2082ba1a0ae5e4eb1b479dc)\n\n                / int256(0x00000000000000000000000000000000a45af1e1f40c333b3de1db4dd55f29a7); // * e ^ -0.5\n\n        }\n\n        // e ^ -0.25\n\n        if ((x & int256(0x0000000000000000000000000000000020000000000000000000000000000000)) != 0) {\n\n            r = r * int256(0x0000000000000000000000000000000070f5a893b608861e1f58934f97aea57d)\n\n                / int256(0x00000000000000000000000000000000910b022db7ae67ce76b441c27035c6a1); // * e ^ -0.25\n\n        }\n\n        // e ^ -0.125\n\n        if ((x & int256(0x0000000000000000000000000000000010000000000000000000000000000000)) != 0) {\n\n            r = r * int256(0x00000000000000000000000000000000783eafef1c0a8f3978c7f81824d62ebf)\n\n                / int256(0x0000000000000000000000000000000088415abbe9a76bead8d00cf112e4d4a8); // * e ^ -0.125\n\n        }\n",
          "message": "Function 'LibFixedMath._exp' (TestLibFixedMath.sol#375-469) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 472,
          "vulnerability_to_line": 484,
          "vulnerability_code": "    function __mul(int256 a, int256 b) private pure returns (int256 c) {\n\n        if (a == 0) {\n\n            return 0;\n\n        }\n\n        c = a * b;\n\n        if (c / a != b) {\n\n            LibRichErrors.rrevert(LibFixedMathRichErrors.BinOpError(\n\n                LibFixedMathRichErrors.BinOpErrorCodes.MULTIPLICATION_OVERFLOW,\n\n                a,\n\n                b\n\n            ));\n\n        }\n",
          "message": "Function 'LibFixedMath.__mul' (TestLibFixedMath.sol#472-484) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 487,
          "vulnerability_to_line": 496,
          "vulnerability_code": "    function __div(int256 a, int256 b) private pure returns (int256 c) {\n\n        if (b == 0) {\n\n            LibRichErrors.rrevert(LibFixedMathRichErrors.BinOpError(\n\n                LibFixedMathRichErrors.BinOpErrorCodes.DIVISION_BY_ZERO,\n\n                a,\n\n                b\n\n            ));\n\n        }\n\n        c = a / b;\n",
          "message": "Function 'LibFixedMath.__div' (TestLibFixedMath.sol#487-496) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 499,
          "vulnerability_to_line": 515,
          "vulnerability_code": "    function __add(int256 a, int256 b) private pure returns (int256 c) {\n\n        c = a + b;\n\n        if (c > 0 && a < 0 && b < 0) {\n\n            LibRichErrors.rrevert(LibFixedMathRichErrors.BinOpError(\n\n                LibFixedMathRichErrors.BinOpErrorCodes.SUBTRACTION_OVERFLOW,\n\n                a,\n\n                b\n\n            ));\n\n        }\n\n        if (c < 0 && a > 0 && b > 0) {\n\n            LibRichErrors.rrevert(LibFixedMathRichErrors.BinOpError(\n\n                LibFixedMathRichErrors.BinOpErrorCodes.ADDITION_OVERFLOW,\n\n                a,\n\n                b\n\n            ));\n\n        }\n",
          "message": "Function 'LibFixedMath.__add' (TestLibFixedMath.sol#499-515) is not in mixedCase\n"
        }
      ]
    },
    "smartcheck": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 25,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bytes4 internal constant STANDARD_ERROR_SELECTOR = 0x08c379a0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 83,
          "vulnerability_to_line": null,
          "vulnerability_code": "        0xed2f26a1;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 87,
          "vulnerability_to_line": null,
          "vulnerability_code": "        0xbd79545f;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 91,
          "vulnerability_to_line": null,
          "vulnerability_code": "        0x8c12dfe7;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 364,
          "vulnerability_to_line": null,
          "vulnerability_code": "        r += z * (0x100000000000000000000000000000000 - y) / 0x100000000000000000000000000000000; z = z * w / FIXED_1; // add y^01 / 01 - y^02 / 02\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 364,
          "vulnerability_to_line": null,
          "vulnerability_code": "        r += z * (0x100000000000000000000000000000000 - y) / 0x100000000000000000000000000000000; z = z * w / FIXED_1; // add y^01 / 01 - y^02 / 02\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 365,
          "vulnerability_to_line": null,
          "vulnerability_code": "        r += z * (0x0aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa - y) / 0x200000000000000000000000000000000; z = z * w / FIXED_1; // add y^03 / 03 - y^04 / 04\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 365,
          "vulnerability_to_line": null,
          "vulnerability_code": "        r += z * (0x0aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa - y) / 0x200000000000000000000000000000000; z = z * w / FIXED_1; // add y^03 / 03 - y^04 / 04\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 366,
          "vulnerability_to_line": null,
          "vulnerability_code": "        r += z * (0x099999999999999999999999999999999 - y) / 0x300000000000000000000000000000000; z = z * w / FIXED_1; // add y^05 / 05 - y^06 / 06\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 366,
          "vulnerability_to_line": null,
          "vulnerability_code": "        r += z * (0x099999999999999999999999999999999 - y) / 0x300000000000000000000000000000000; z = z * w / FIXED_1; // add y^05 / 05 - y^06 / 06\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 367,
          "vulnerability_to_line": null,
          "vulnerability_code": "        r += z * (0x092492492492492492492492492492492 - y) / 0x400000000000000000000000000000000; z = z * w / FIXED_1; // add y^07 / 07 - y^08 / 08\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 367,
          "vulnerability_to_line": null,
          "vulnerability_code": "        r += z * (0x092492492492492492492492492492492 - y) / 0x400000000000000000000000000000000; z = z * w / FIXED_1; // add y^07 / 07 - y^08 / 08\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 368,
          "vulnerability_to_line": null,
          "vulnerability_code": "        r += z * (0x08e38e38e38e38e38e38e38e38e38e38e - y) / 0x500000000000000000000000000000000; z = z * w / FIXED_1; // add y^09 / 09 - y^10 / 10\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 368,
          "vulnerability_to_line": null,
          "vulnerability_code": "        r += z * (0x08e38e38e38e38e38e38e38e38e38e38e - y) / 0x500000000000000000000000000000000; z = z * w / FIXED_1; // add y^09 / 09 - y^10 / 10\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 369,
          "vulnerability_to_line": null,
          "vulnerability_code": "        r += z * (0x08ba2e8ba2e8ba2e8ba2e8ba2e8ba2e8b - y) / 0x600000000000000000000000000000000; z = z * w / FIXED_1; // add y^11 / 11 - y^12 / 12\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 369,
          "vulnerability_to_line": null,
          "vulnerability_code": "        r += z * (0x08ba2e8ba2e8ba2e8ba2e8ba2e8ba2e8b - y) / 0x600000000000000000000000000000000; z = z * w / FIXED_1; // add y^11 / 11 - y^12 / 12\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 370,
          "vulnerability_to_line": null,
          "vulnerability_code": "        r += z * (0x089d89d89d89d89d89d89d89d89d89d89 - y) / 0x700000000000000000000000000000000; z = z * w / FIXED_1; // add y^13 / 13 - y^14 / 14\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 370,
          "vulnerability_to_line": null,
          "vulnerability_code": "        r += z * (0x089d89d89d89d89d89d89d89d89d89d89 - y) / 0x700000000000000000000000000000000; z = z * w / FIXED_1; // add y^13 / 13 - y^14 / 14\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 371,
          "vulnerability_to_line": null,
          "vulnerability_code": "        r += z * (0x088888888888888888888888888888888 - y) / 0x800000000000000000000000000000000;                      // add y^15 / 15 - y^16 / 16\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 371,
          "vulnerability_to_line": null,
          "vulnerability_code": "        r += z * (0x088888888888888888888888888888888 - y) / 0x800000000000000000000000000000000;                      // add y^15 / 15 - y^16 / 16\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 401,
          "vulnerability_to_line": null,
          "vulnerability_code": "        z = z * y / FIXED_1; r += z * 0x10e1b3be415a0000; // add y^02 * (20! / 02!)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 402,
          "vulnerability_to_line": null,
          "vulnerability_code": "        z = z * y / FIXED_1; r += z * 0x05a0913f6b1e0000; // add y^03 * (20! / 03!)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 403,
          "vulnerability_to_line": null,
          "vulnerability_code": "        z = z * y / FIXED_1; r += z * 0x0168244fdac78000; // add y^04 * (20! / 04!)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 404,
          "vulnerability_to_line": null,
          "vulnerability_code": "        z = z * y / FIXED_1; r += z * 0x004807432bc18000; // add y^05 * (20! / 05!)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 405,
          "vulnerability_to_line": null,
          "vulnerability_code": "        z = z * y / FIXED_1; r += z * 0x000c0135dca04000; // add y^06 * (20! / 06!)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 406,
          "vulnerability_to_line": null,
          "vulnerability_code": "        z = z * y / FIXED_1; r += z * 0x0001b707b1cdc000; // add y^07 * (20! / 07!)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 407,
          "vulnerability_to_line": null,
          "vulnerability_code": "        z = z * y / FIXED_1; r += z * 0x000036e0f639b800; // add y^08 * (20! / 08!)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 408,
          "vulnerability_to_line": null,
          "vulnerability_code": "        z = z * y / FIXED_1; r += z * 0x00000618fee9f800; // add y^09 * (20! / 09!)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 409,
          "vulnerability_to_line": null,
          "vulnerability_code": "        z = z * y / FIXED_1; r += z * 0x0000009c197dcc00; // add y^10 * (20! / 10!)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 410,
          "vulnerability_to_line": null,
          "vulnerability_code": "        z = z * y / FIXED_1; r += z * 0x0000000e30dce400; // add y^11 * (20! / 11!)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 411,
          "vulnerability_to_line": null,
          "vulnerability_code": "        z = z * y / FIXED_1; r += z * 0x000000012ebd1300; // add y^12 * (20! / 12!)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 412,
          "vulnerability_to_line": null,
          "vulnerability_code": "        z = z * y / FIXED_1; r += z * 0x0000000017499f00; // add y^13 * (20! / 13!)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 413,
          "vulnerability_to_line": null,
          "vulnerability_code": "        z = z * y / FIXED_1; r += z * 0x0000000001a9d480; // add y^14 * (20! / 14!)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 414,
          "vulnerability_to_line": null,
          "vulnerability_code": "        z = z * y / FIXED_1; r += z * 0x00000000001c6380; // add y^15 * (20! / 15!)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 415,
          "vulnerability_to_line": null,
          "vulnerability_code": "        z = z * y / FIXED_1; r += z * 0x000000000001c638; // add y^16 * (20! / 16!)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 416,
          "vulnerability_to_line": null,
          "vulnerability_code": "        z = z * y / FIXED_1; r += z * 0x0000000000001ab8; // add y^17 * (20! / 17!)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 417,
          "vulnerability_to_line": null,
          "vulnerability_code": "        z = z * y / FIXED_1; r += z * 0x000000000000017c; // add y^18 * (20! / 18!)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 418,
          "vulnerability_to_line": null,
          "vulnerability_code": "        z = z * y / FIXED_1; r += z * 0x0000000000000014; // add y^19 * (20! / 19!)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 419,
          "vulnerability_to_line": null,
          "vulnerability_code": "        z = z * y / FIXED_1; r += z * 0x0000000000000001; // add y^20 * (20! / 20!)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 420,
          "vulnerability_to_line": null,
          "vulnerability_code": "        r = r / 0x21c3677c82b40000 + y + FIXED_1; // divide by 20! and then add y^1 / 1! + y^0 / 0!\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 21,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.9;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 65,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.9;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 162,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.9;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 537,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.9;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 168,
          "vulnerability_to_line": null,
          "vulnerability_code": "    int256 private constant FIXED_1 = int256(0x0000000000000000000000000000000080000000000000000000000000000000);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 170,
          "vulnerability_to_line": null,
          "vulnerability_code": "    int256 private constant FIXED_1_SQUARED = int256(0x4000000000000000000000000000000000000000000000000000000000000000);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 172,
          "vulnerability_to_line": null,
          "vulnerability_code": "    int256 private constant LN_MAX_VAL = FIXED_1;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 174,
          "vulnerability_to_line": null,
          "vulnerability_code": "    int256 private constant LN_MIN_VAL = int256(0x0000000000000000000000000000000000000000000000000000000733048c5a);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 176,
          "vulnerability_to_line": null,
          "vulnerability_code": "    int256 private constant EXP_MAX_VAL = 0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 178,
          "vulnerability_to_line": null,
          "vulnerability_code": "    int256 private constant EXP_MIN_VAL = -int256(0x0000000000000000000000000000001ff0000000000000000000000000000000);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 38,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 39,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        }
      ]
    },
    "oyente": {
      "successfull_analysis": false,
      "errors": [
        "exception (IndexError: pop from empty list)"
      ],
      "vulnerability_findings": []
    },
    "mythril": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "Integer Arithmetic Bugs (SWC 101)",
          "vulnerability_from_line": 232,
          "vulnerability_to_line": null,
          "vulnerability_code": "            c = -f;\n",
          "message": "The arithmetic operator can underflow.\nIt is possible to cause an integer overflow or underflow in the arithmetic operation. \nClassification: SWC-101"
        },
        {
          "name": "Integer Arithmetic Bugs (SWC 101)",
          "vulnerability_from_line": 192,
          "vulnerability_to_line": null,
          "vulnerability_code": "        c = __add(a, -b);\n",
          "message": "The arithmetic operator can underflow.\nIt is possible to cause an integer overflow or underflow in the arithmetic operation. \nClassification: SWC-101"
        },
        {
          "name": "Integer Arithmetic Bugs (SWC 101)",
          "vulnerability_from_line": 178,
          "vulnerability_to_line": null,
          "vulnerability_code": "    int256 private constant EXP_MIN_VAL = -int256(0x0000000000000000000000000000001ff0000000000000000000000000000000);\n",
          "message": "The arithmetic operator can underflow.\nIt is possible to cause an integer overflow or underflow in the arithmetic operation. \nClassification: SWC-101"
        },
        {
          "name": "Integer Arithmetic Bugs (SWC 101)",
          "vulnerability_from_line": 476,
          "vulnerability_to_line": null,
          "vulnerability_code": "        c = a * b;\n",
          "message": "The arithmetic operator can overflow.\nIt is possible to cause an integer overflow or underflow in the arithmetic operation. \nClassification: SWC-101"
        },
        {
          "name": "Integer Arithmetic Bugs (SWC 101)",
          "vulnerability_from_line": 476,
          "vulnerability_to_line": null,
          "vulnerability_code": "        c = a * b;\n",
          "message": "The arithmetic operator can overflow.\nIt is possible to cause an integer overflow or underflow in the arithmetic operation. \nClassification: SWC-101"
        },
        {
          "name": "Integer Arithmetic Bugs (SWC 101)",
          "vulnerability_from_line": 476,
          "vulnerability_to_line": null,
          "vulnerability_code": "        c = a * b;\n",
          "message": "The arithmetic operator can overflow.\nIt is possible to cause an integer overflow or underflow in the arithmetic operation. \nClassification: SWC-101"
        },
        {
          "name": "Integer Arithmetic Bugs (SWC 101)",
          "vulnerability_from_line": 500,
          "vulnerability_to_line": null,
          "vulnerability_code": "        c = a + b;\n",
          "message": "The arithmetic operator can overflow.\nIt is possible to cause an integer overflow or underflow in the arithmetic operation. \nClassification: SWC-101"
        },
        {
          "name": "Integer Arithmetic Bugs (SWC 101)",
          "vulnerability_from_line": 500,
          "vulnerability_to_line": null,
          "vulnerability_code": "        c = a + b;\n",
          "message": "The arithmetic operator can overflow.\nIt is possible to cause an integer overflow or underflow in the arithmetic operation. \nClassification: SWC-101"
        }
      ]
    },
    "osiris": {
      "successfull_analysis": false,
      "errors": [
        "Solidity compilation failed"
      ],
      "vulnerability_findings": []
    }
  }
}