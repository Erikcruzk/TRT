{
  "smartbugs_completed": true,
  "analyzer_results": {
    "semgrep": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "use-abi-encodecall-instead-of-encodewithselector",
          "vulnerability_from_line": 39,
          "vulnerability_to_line": null,
          "vulnerability_code": "        return abi.encodeWithSelector(\n",
          "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
        },
        {
          "name": "use-abi-encodecall-instead-of-encodewithselector",
          "vulnerability_from_line": 40,
          "vulnerability_to_line": null,
          "vulnerability_code": "            MISMANAGED_MEMORY_ERROR_SELECTOR,\n",
          "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
        },
        {
          "name": "use-abi-encodecall-instead-of-encodewithselector",
          "vulnerability_from_line": 41,
          "vulnerability_to_line": null,
          "vulnerability_code": "            freeMemPtr,\n",
          "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
        },
        {
          "name": "use-abi-encodecall-instead-of-encodewithselector",
          "vulnerability_from_line": 42,
          "vulnerability_to_line": null,
          "vulnerability_code": "            addressArrayEndPtr\n",
          "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
        },
        {
          "name": "use-abi-encodecall-instead-of-encodewithselector",
          "vulnerability_from_line": 43,
          "vulnerability_to_line": null,
          "vulnerability_code": "        );\n",
          "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
        },
        {
          "name": "use-abi-encodecall-instead-of-encodewithselector",
          "vulnerability_from_line": 97,
          "vulnerability_to_line": null,
          "vulnerability_code": "        return abi.encodeWithSelector(\n",
          "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
        },
        {
          "name": "use-abi-encodecall-instead-of-encodewithselector",
          "vulnerability_from_line": 98,
          "vulnerability_to_line": null,
          "vulnerability_code": "            INVALID_BYTE_OPERATION_ERROR_SELECTOR,\n",
          "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
        },
        {
          "name": "use-abi-encodecall-instead-of-encodewithselector",
          "vulnerability_from_line": 99,
          "vulnerability_to_line": null,
          "vulnerability_code": "            errorCode,\n",
          "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
        },
        {
          "name": "use-abi-encodecall-instead-of-encodewithselector",
          "vulnerability_from_line": 100,
          "vulnerability_to_line": null,
          "vulnerability_code": "            offset,\n",
          "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
        },
        {
          "name": "use-abi-encodecall-instead-of-encodewithselector",
          "vulnerability_from_line": 101,
          "vulnerability_to_line": null,
          "vulnerability_code": "            required\n",
          "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
        },
        {
          "name": "use-abi-encodecall-instead-of-encodewithselector",
          "vulnerability_from_line": 102,
          "vulnerability_to_line": null,
          "vulnerability_code": "        );\n",
          "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
        },
        {
          "name": "use-abi-encodecall-instead-of-encodewithselector",
          "vulnerability_from_line": 148,
          "vulnerability_to_line": null,
          "vulnerability_code": "        return abi.encodeWithSelector(\n",
          "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
        },
        {
          "name": "use-abi-encodecall-instead-of-encodewithselector",
          "vulnerability_from_line": 149,
          "vulnerability_to_line": null,
          "vulnerability_code": "            STANDARD_ERROR_SELECTOR,\n",
          "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
        },
        {
          "name": "use-abi-encodecall-instead-of-encodewithselector",
          "vulnerability_from_line": 150,
          "vulnerability_to_line": null,
          "vulnerability_code": "            bytes(message)\n",
          "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
        },
        {
          "name": "use-abi-encodecall-instead-of-encodewithselector",
          "vulnerability_from_line": 151,
          "vulnerability_to_line": null,
          "vulnerability_code": "        );\n",
          "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
        }
      ]
    },
    "slither": {
      "successfull_analysis": true,
      "errors": [
        "EXIT_CODE_38"
      ],
      "vulnerability_findings": [
        {
          "name": "constant-function",
          "vulnerability_from_line": 157,
          "vulnerability_to_line": 164,
          "vulnerability_code": "    function rrevert(bytes memory errorData)\n\n        internal\n\n        pure\n\n    {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
          "message": "LibRichErrors.rrevert (LibAddressArray.sol#157-164) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 199,
          "vulnerability_to_line": 208,
          "vulnerability_code": "    function rawAddress(bytes memory input)\n\n        internal\n\n        pure\n\n        returns (uint256 memoryAddress)\n\n    {\n\n        assembly {\n\n            memoryAddress := input\n\n        }\n\n        return memoryAddress;\n",
          "message": "LibBytes.rawAddress (LibAddressArray.sol#199-208) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 213,
          "vulnerability_to_line": 222,
          "vulnerability_code": "    function contentAddress(bytes memory input)\n\n        internal\n\n        pure\n\n        returns (uint256 memoryAddress)\n\n    {\n\n        assembly {\n\n            memoryAddress := add(input, 32)\n\n        }\n\n        return memoryAddress;\n",
          "message": "LibBytes.contentAddress (LibAddressArray.sol#213-222) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 228,
          "vulnerability_to_line": 329,
          "vulnerability_code": "    function memCopy(\n\n        uint256 dest,\n\n        uint256 source,\n\n        uint256 length\n\n    )\n\n        internal\n\n        pure\n\n    {\n\n        if (length < 32) {\n\n            // Handle a partial word by reading destination and masking\n\n            // off the bits we are interested in.\n\n            // This correctly handles overlap, zero lengths and source == dest\n\n            assembly {\n\n                let mask := sub(exp(256, sub(32, length)), 1)\n\n                let s := and(mload(source), not(mask))\n\n                let d := and(mload(dest), mask)\n\n                mstore(dest, or(s, d))\n\n            }\n\n        } else {\n\n            // Skip the O(length) loop when source == dest.\n\n            if (source == dest) {\n\n                return;\n\n            }\n\n\n\n            // For large copies we copy whole words at a time. The final\n\n            // word is aligned to the end of the range (instead of after the\n\n            // previous) to handle partial words. So a copy will look like this:\n\n            //\n\n            //  ####\n\n            //      ####\n\n            //          ####\n\n            //            ####\n\n            //\n\n            // We handle overlap in the source and destination range by\n\n            // changing the copying direction. This prevents us from\n\n            // overwriting parts of source that we still need to copy.\n\n            //\n\n            // This correctly handles source == dest\n\n            //\n\n            if (source > dest) {\n\n                assembly {\n\n                    // We subtract 32 from `sEnd` and `dEnd` because it\n\n                    // is easier to compare with in the loop, and these\n\n                    // are also the addresses we need for copying the\n\n                    // last bytes.\n\n                    length := sub(length, 32)\n\n                    let sEnd := add(source, length)\n\n                    let dEnd := add(dest, length)\n\n\n\n                    // Remember the last 32 bytes of source\n\n                    // This needs to be done here and not after the loop\n\n                    // because we may have overwritten the last bytes in\n\n                    // source already due to overlap.\n\n                    let last := mload(sEnd)\n\n\n\n                    // Copy whole words front to back\n\n                    // Note: the first check is always true,\n\n                    // this could have been a do-while loop.\n\n                    // solhint-disable-next-line no-empty-blocks\n\n                    for {} lt(source, sEnd) {} {\n\n                        mstore(dest, mload(source))\n\n                        source := add(source, 32)\n\n                        dest := add(dest, 32)\n\n                    }\n\n\n\n                    // Write the last 32 bytes\n\n                    mstore(dEnd, last)\n\n                }\n\n            } else {\n\n                assembly {\n\n                    // We subtract 32 from `sEnd` and `dEnd` because those\n\n                    // are the starting points when copying a word at the end.\n\n                    length := sub(length, 32)\n\n                    let sEnd := add(source, length)\n\n                    let dEnd := add(dest, length)\n\n\n\n                    // Remember the first 32 bytes of source\n\n                    // This needs to be done here and not after the loop\n\n                    // because we may have overwritten the first bytes in\n\n                    // source already due to overlap.\n\n                    let first := mload(source)\n\n\n\n                    // Copy whole words back to front\n\n                    // We use a signed comparisson here to allow dEnd to become\n\n                    // negative (happens when source and dest < 32). Valid\n\n                    // addresses in local memory will never be larger than\n\n                    // 2**255, so they can be safely re-interpreted as signed.\n\n                    // Note: the first check is always true,\n\n                    // this could have been a do-while loop.\n\n                    // solhint-disable-next-line no-empty-blocks\n\n                    for {} slt(dest, dEnd) {} {\n\n                        mstore(dEnd, mload(sEnd))\n\n                        sEnd := sub(sEnd, 32)\n\n                        dEnd := sub(dEnd, 32)\n\n                    }\n\n\n\n                    // Write the first 32 bytes\n\n                    mstore(dest, first)\n\n                }\n\n            }\n\n        }\n",
          "message": "LibBytes.memCopy (LibAddressArray.sol#228-329) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 378,
          "vulnerability_to_line": 410,
          "vulnerability_code": "    function sliceDestructive(\n\n        bytes memory b,\n\n        uint256 from,\n\n        uint256 to\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory result)\n\n    {\n\n        // Ensure that the from and to positions are valid positions for a slice within\n\n        // the byte array that is being used.\n\n        if (from > to) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.FromLessThanOrEqualsToRequired,\n\n                from,\n\n                to\n\n            ));\n\n        }\n\n        if (to > b.length) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.ToLessThanOrEqualsLengthRequired,\n\n                to,\n\n                b.length\n\n            ));\n\n        }\n\n\n\n        // Create a new bytes structure around [from, to) in-place.\n\n        assembly {\n\n            result := add(b, from)\n\n            mstore(result, sub(to, from))\n\n        }\n\n        return result;\n",
          "message": "LibBytes.sliceDestructive (LibAddressArray.sol#378-410) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 415,
          "vulnerability_to_line": 437,
          "vulnerability_code": "    function popLastByte(bytes memory b)\n\n        internal\n\n        pure\n\n        returns (bytes1 result)\n\n    {\n\n        if (b.length == 0) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanZeroRequired,\n\n                b.length,\n\n                0\n\n            ));\n\n        }\n\n\n\n        // Store last byte.\n\n        result = b[b.length - 1];\n\n\n\n        assembly {\n\n            // Decrement length of byte array.\n\n            let newLen := sub(mload(b), 1)\n\n            mstore(b, newLen)\n\n        }\n\n        return result;\n",
          "message": "LibBytes.popLastByte (LibAddressArray.sol#415-437) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 442,
          "vulnerability_to_line": 464,
          "vulnerability_code": "    function popLast20Bytes(bytes memory b)\n\n        internal\n\n        pure\n\n        returns (address result)\n\n    {\n\n        if (b.length < 20) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsTwentyRequired,\n\n                b.length,\n\n                20 // 20 is length of address\n\n            ));\n\n        }\n\n\n\n        // Store last 20 bytes.\n\n        result = readAddress(b, b.length - 20);\n\n\n\n        assembly {\n\n            // Subtract 20 from byte array length.\n\n            let newLen := sub(mload(b), 20)\n\n            mstore(b, newLen)\n\n        }\n\n        return result;\n",
          "message": "LibBytes.popLast20Bytes (LibAddressArray.sol#442-464) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 488,
          "vulnerability_to_line": 517,
          "vulnerability_code": "    function readAddress(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (address result)\n\n    {\n\n        if (b.length < index + 20) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsTwentyRequired,\n\n                b.length,\n\n                index + 20 // 20 is length of address\n\n            ));\n\n        }\n\n\n\n        // Add offset to index:\n\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\n\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\n\n        index += 20;\n\n\n\n        // Read address from array memory\n\n        assembly {\n\n            // 1. Add index to address of bytes array\n\n            // 2. Load 32-byte word from memory\n\n            // 3. Apply 20-byte mask to obtain address\n\n            result := and(mload(add(b, index)), 0xffffffffffffffffffffffffffffffffffffffff)\n\n        }\n\n        return result;\n",
          "message": "LibBytes.readAddress (LibAddressArray.sol#488-517) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 523,
          "vulnerability_to_line": 566,
          "vulnerability_code": "    function writeAddress(\n\n        bytes memory b,\n\n        uint256 index,\n\n        address input\n\n    )\n\n        internal\n\n        pure\n\n    {\n\n        if (b.length < index + 20) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsTwentyRequired,\n\n                b.length,\n\n                index + 20 // 20 is length of address\n\n            ));\n\n        }\n\n\n\n        // Add offset to index:\n\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\n\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\n\n        index += 20;\n\n\n\n        // Store address into array memory\n\n        assembly {\n\n            // The address occupies 20 bytes and mstore stores 32 bytes.\n\n            // First fetch the 32-byte word where we'll be storing the address, then\n\n            // apply a mask so we have only the bytes in the word that the address will not occupy.\n\n            // Then combine these bytes with the address and store the 32 bytes back to memory with mstore.\n\n\n\n            // 1. Add index to address of bytes array\n\n            // 2. Load 32-byte word from memory\n\n            // 3. Apply 12-byte mask to obtain extra bytes occupying word of memory where we'll store the address\n\n            let neighbors := and(\n\n                mload(add(b, index)),\n\n                0xffffffffffffffffffffffff0000000000000000000000000000000000000000\n\n            )\n\n\n\n            // Make sure input address is clean.\n\n            // (Solidity does not guarantee this)\n\n            input := and(input, 0xffffffffffffffffffffffffffffffffffffffff)\n\n\n\n            // Store the neighbors and address into memory\n\n            mstore(add(b, index), xor(input, neighbors))\n\n        }\n",
          "message": "LibBytes.writeAddress (LibAddressArray.sol#523-566) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 572,
          "vulnerability_to_line": 596,
          "vulnerability_code": "    function readBytes32(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes32 result)\n\n    {\n\n        if (b.length < index + 32) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsThirtyTwoRequired,\n\n                b.length,\n\n                index + 32\n\n            ));\n\n        }\n\n\n\n        // Arrays are prefixed by a 256 bit length parameter\n\n        index += 32;\n\n\n\n        // Read the bytes32 from array memory\n\n        assembly {\n\n            result := mload(add(b, index))\n\n        }\n\n        return result;\n",
          "message": "LibBytes.readBytes32 (LibAddressArray.sol#572-596) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 602,
          "vulnerability_to_line": 625,
          "vulnerability_code": "    function writeBytes32(\n\n        bytes memory b,\n\n        uint256 index,\n\n        bytes32 input\n\n    )\n\n        internal\n\n        pure\n\n    {\n\n        if (b.length < index + 32) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsThirtyTwoRequired,\n\n                b.length,\n\n                index + 32\n\n            ));\n\n        }\n\n\n\n        // Arrays are prefixed by a 256 bit length parameter\n\n        index += 32;\n\n\n\n        // Read the bytes32 from array memory\n\n        assembly {\n\n            mstore(add(b, index), input)\n\n        }\n",
          "message": "LibBytes.writeBytes32 (LibAddressArray.sol#602-625) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 662,
          "vulnerability_to_line": 689,
          "vulnerability_code": "    function readBytes4(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes4 result)\n\n    {\n\n        if (b.length < index + 4) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsFourRequired,\n\n                b.length,\n\n                index + 4\n\n            ));\n\n        }\n\n\n\n        // Arrays are prefixed by a 32 byte length field\n\n        index += 32;\n\n\n\n        // Read the bytes4 from array memory\n\n        assembly {\n\n            result := mload(add(b, index))\n\n            // Solidity does not require us to clean the trailing bytes.\n\n            // We do it anyway\n\n            result := and(result, 0xFFFFFFFF00000000000000000000000000000000000000000000000000000000)\n\n        }\n\n        return result;\n",
          "message": "LibBytes.readBytes4 (LibAddressArray.sol#662-689) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 697,
          "vulnerability_to_line": 725,
          "vulnerability_code": "    function readBytesWithLength(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory result)\n\n    {\n\n        // Read length of nested bytes\n\n        uint256 nestedBytesLength = readUint256(b, index);\n\n        index += 32;\n\n\n\n        // Assert length of <b> is valid, given\n\n        // length of nested bytes\n\n        if (b.length < index + nestedBytesLength) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors\n\n                    .InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsNestedBytesLengthRequired,\n\n                b.length,\n\n                index + nestedBytesLength\n\n            ));\n\n        }\n\n\n\n        // Return a pointer to the byte array as it exists inside `b`\n\n        assembly {\n\n            result := add(b, index)\n\n        }\n\n        return result;\n",
          "message": "LibBytes.readBytesWithLength (LibAddressArray.sol#697-725) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 790,
          "vulnerability_to_line": 797,
          "vulnerability_code": "    function writeLength(bytes memory b, uint256 length)\n\n        internal\n\n        pure\n\n    {\n\n        assembly {\n\n            mstore(b, length)\n\n        }\n",
          "message": "LibBytes.writeLength (LibAddressArray.sol#790-797) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 833,
          "vulnerability_to_line": 887,
          "vulnerability_code": "    function append(address[] memory addressArray, address addressToAppend)\n\n        internal\n\n        pure\n\n        returns (address[] memory)\n\n    {\n\n        // Get stats on address array and free memory\n\n        uint256 freeMemPtr = 0;\n\n        uint256 addressArrayBeginPtr = 0;\n\n        uint256 addressArrayEndPtr = 0;\n\n        uint256 addressArrayLength = addressArray.length;\n\n        uint256 addressArrayMemSizeInBytes = 32 + (32 * addressArrayLength);\n\n        assembly {\n\n            freeMemPtr := mload(0x40)\n\n            addressArrayBeginPtr := addressArray\n\n            addressArrayEndPtr := add(addressArray, addressArrayMemSizeInBytes)\n\n        }\n\n\n\n        // Cases for `freeMemPtr`:\n\n        //  `freeMemPtr` == `addressArrayEndPtr`: Nothing occupies memory after `addressArray`\n\n        //  `freeMemPtr` > `addressArrayEndPtr`: Some value occupies memory after `addressArray`\n\n        //  `freeMemPtr` < `addressArrayEndPtr`: Memory has not been managed properly.\n\n        if (freeMemPtr < addressArrayEndPtr) {\n\n            LibRichErrors.rrevert(LibAddressArrayRichErrors.MismanagedMemoryError(\n\n                freeMemPtr,\n\n                addressArrayEndPtr\n\n            ));\n\n        }\n\n\n\n        // If free memory begins at the end of `addressArray`\n\n        // then we can append `addressToAppend` directly.\n\n        // Otherwise, we must copy the array to free memory\n\n        // before appending new values to it.\n\n        if (freeMemPtr > addressArrayEndPtr) {\n\n            LibBytes.memCopy(freeMemPtr, addressArrayBeginPtr, addressArrayMemSizeInBytes);\n\n            assembly {\n\n                addressArray := freeMemPtr\n\n                addressArrayBeginPtr := addressArray\n\n            }\n\n        }\n\n\n\n        // Append `addressToAppend`\n\n        addressArrayLength += 1;\n\n        addressArrayMemSizeInBytes += 32;\n\n        addressArrayEndPtr = addressArrayBeginPtr + addressArrayMemSizeInBytes;\n\n        freeMemPtr = addressArrayEndPtr;\n\n        assembly {\n\n            // Store new array length\n\n            mstore(addressArray, addressArrayLength)\n\n\n\n            // Update `freeMemPtr`\n\n            mstore(0x40, freeMemPtr)\n\n        }\n\n        addressArray[addressArrayLength - 1] = addressToAppend;\n\n        return addressArray;\n",
          "message": "LibAddressArray.append (LibAddressArray.sol#833-887) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 893,
          "vulnerability_to_line": 923,
          "vulnerability_code": "    function contains(address[] memory addressArray, address target)\n\n        internal\n\n        pure\n\n        returns (bool success)\n\n    {\n\n        assembly {\n\n\n\n            // Calculate byte length of array\n\n            let arrayByteLen := mul(mload(addressArray), 32)\n\n            // Calculate beginning of array contents\n\n            let arrayContentsStart := add(addressArray, 32)\n\n            // Calclulate end of array contents\n\n            let arrayContentsEnd := add(arrayContentsStart, arrayByteLen)\n\n\n\n            // Loop through array\n\n            for {let i:= arrayContentsStart} lt(i, arrayContentsEnd) {i := add(i, 32)} {\n\n\n\n                // Load array element\n\n                let arrayElement := mload(i)\n\n\n\n                // Return true if array element equals target\n\n                if eq(target, arrayElement) {\n\n                    // Set success to true\n\n                    success := 1\n\n                    // Break loop\n\n                    i := arrayContentsEnd\n\n                }\n\n            }\n\n        }\n\n        return success;\n",
          "message": "LibAddressArray.contains (LibAddressArray.sol#893-923) is declared view but contains assembly code\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 929,
          "vulnerability_to_line": 960,
          "vulnerability_code": "    function indexOf(address[] memory addressArray, address target)\n\n        internal\n\n        pure\n\n        returns (bool success, uint256 index)\n\n    {\n\n        assembly {\n\n\n\n            // Calculate byte length of array\n\n            let arrayByteLen := mul(mload(addressArray), 32)\n\n            // Calculate beginning of array contents\n\n            let arrayContentsStart := add(addressArray, 32)\n\n            // Calclulate end of array contents\n\n            let arrayContentsEnd := add(arrayContentsStart, arrayByteLen)\n\n\n\n            // Loop through array\n\n            for {let i:= arrayContentsStart} lt(i, arrayContentsEnd) {i := add(i, 32)} {\n\n\n\n                // Load array element\n\n                let arrayElement := mload(i)\n\n\n\n                // Return true if array element equals target\n\n                if eq(target, arrayElement) {\n\n                    // Set success and index\n\n                    success := 1\n\n                    index := div(sub(i, arrayContentsStart), 32)\n\n                    // Break loop\n\n                    i := arrayContentsEnd\n\n                }\n\n            }\n\n        }\n\n        return (success, index);\n",
          "message": "LibAddressArray.indexOf (LibAddressArray.sol#929-960) is declared view but contains assembly code\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 157,
          "vulnerability_to_line": 164,
          "vulnerability_code": "    function rrevert(bytes memory errorData)\n\n        internal\n\n        pure\n\n    {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
          "message": "LibRichErrors.rrevert uses assembly (LibAddressArray.sol#157-164)\n\t- LibAddressArray.sol#161-163\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 199,
          "vulnerability_to_line": 208,
          "vulnerability_code": "    function rawAddress(bytes memory input)\n\n        internal\n\n        pure\n\n        returns (uint256 memoryAddress)\n\n    {\n\n        assembly {\n\n            memoryAddress := input\n\n        }\n\n        return memoryAddress;\n",
          "message": "LibBytes.rawAddress uses assembly (LibAddressArray.sol#199-208)\n\t- LibAddressArray.sol#204-206\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 213,
          "vulnerability_to_line": 222,
          "vulnerability_code": "    function contentAddress(bytes memory input)\n\n        internal\n\n        pure\n\n        returns (uint256 memoryAddress)\n\n    {\n\n        assembly {\n\n            memoryAddress := add(input, 32)\n\n        }\n\n        return memoryAddress;\n",
          "message": "LibBytes.contentAddress uses assembly (LibAddressArray.sol#213-222)\n\t- LibAddressArray.sol#218-220\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 228,
          "vulnerability_to_line": 329,
          "vulnerability_code": "    function memCopy(\n\n        uint256 dest,\n\n        uint256 source,\n\n        uint256 length\n\n    )\n\n        internal\n\n        pure\n\n    {\n\n        if (length < 32) {\n\n            // Handle a partial word by reading destination and masking\n\n            // off the bits we are interested in.\n\n            // This correctly handles overlap, zero lengths and source == dest\n\n            assembly {\n\n                let mask := sub(exp(256, sub(32, length)), 1)\n\n                let s := and(mload(source), not(mask))\n\n                let d := and(mload(dest), mask)\n\n                mstore(dest, or(s, d))\n\n            }\n\n        } else {\n\n            // Skip the O(length) loop when source == dest.\n\n            if (source == dest) {\n\n                return;\n\n            }\n\n\n\n            // For large copies we copy whole words at a time. The final\n\n            // word is aligned to the end of the range (instead of after the\n\n            // previous) to handle partial words. So a copy will look like this:\n\n            //\n\n            //  ####\n\n            //      ####\n\n            //          ####\n\n            //            ####\n\n            //\n\n            // We handle overlap in the source and destination range by\n\n            // changing the copying direction. This prevents us from\n\n            // overwriting parts of source that we still need to copy.\n\n            //\n\n            // This correctly handles source == dest\n\n            //\n\n            if (source > dest) {\n\n                assembly {\n\n                    // We subtract 32 from `sEnd` and `dEnd` because it\n\n                    // is easier to compare with in the loop, and these\n\n                    // are also the addresses we need for copying the\n\n                    // last bytes.\n\n                    length := sub(length, 32)\n\n                    let sEnd := add(source, length)\n\n                    let dEnd := add(dest, length)\n\n\n\n                    // Remember the last 32 bytes of source\n\n                    // This needs to be done here and not after the loop\n\n                    // because we may have overwritten the last bytes in\n\n                    // source already due to overlap.\n\n                    let last := mload(sEnd)\n\n\n\n                    // Copy whole words front to back\n\n                    // Note: the first check is always true,\n\n                    // this could have been a do-while loop.\n\n                    // solhint-disable-next-line no-empty-blocks\n\n                    for {} lt(source, sEnd) {} {\n\n                        mstore(dest, mload(source))\n\n                        source := add(source, 32)\n\n                        dest := add(dest, 32)\n\n                    }\n\n\n\n                    // Write the last 32 bytes\n\n                    mstore(dEnd, last)\n\n                }\n\n            } else {\n\n                assembly {\n\n                    // We subtract 32 from `sEnd` and `dEnd` because those\n\n                    // are the starting points when copying a word at the end.\n\n                    length := sub(length, 32)\n\n                    let sEnd := add(source, length)\n\n                    let dEnd := add(dest, length)\n\n\n\n                    // Remember the first 32 bytes of source\n\n                    // This needs to be done here and not after the loop\n\n                    // because we may have overwritten the first bytes in\n\n                    // source already due to overlap.\n\n                    let first := mload(source)\n\n\n\n                    // Copy whole words back to front\n\n                    // We use a signed comparisson here to allow dEnd to become\n\n                    // negative (happens when source and dest < 32). Valid\n\n                    // addresses in local memory will never be larger than\n\n                    // 2**255, so they can be safely re-interpreted as signed.\n\n                    // Note: the first check is always true,\n\n                    // this could have been a do-while loop.\n\n                    // solhint-disable-next-line no-empty-blocks\n\n                    for {} slt(dest, dEnd) {} {\n\n                        mstore(dEnd, mload(sEnd))\n\n                        sEnd := sub(sEnd, 32)\n\n                        dEnd := sub(dEnd, 32)\n\n                    }\n\n\n\n                    // Write the first 32 bytes\n\n                    mstore(dest, first)\n\n                }\n\n            }\n\n        }\n",
          "message": "LibBytes.memCopy uses assembly (LibAddressArray.sol#228-329)\n\t- LibAddressArray.sol#240-245\n\t- LibAddressArray.sol#268-295\n\t- LibAddressArray.sol#297-326\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 378,
          "vulnerability_to_line": 410,
          "vulnerability_code": "    function sliceDestructive(\n\n        bytes memory b,\n\n        uint256 from,\n\n        uint256 to\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory result)\n\n    {\n\n        // Ensure that the from and to positions are valid positions for a slice within\n\n        // the byte array that is being used.\n\n        if (from > to) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.FromLessThanOrEqualsToRequired,\n\n                from,\n\n                to\n\n            ));\n\n        }\n\n        if (to > b.length) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.ToLessThanOrEqualsLengthRequired,\n\n                to,\n\n                b.length\n\n            ));\n\n        }\n\n\n\n        // Create a new bytes structure around [from, to) in-place.\n\n        assembly {\n\n            result := add(b, from)\n\n            mstore(result, sub(to, from))\n\n        }\n\n        return result;\n",
          "message": "LibBytes.sliceDestructive uses assembly (LibAddressArray.sol#378-410)\n\t- LibAddressArray.sol#405-408\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 415,
          "vulnerability_to_line": 437,
          "vulnerability_code": "    function popLastByte(bytes memory b)\n\n        internal\n\n        pure\n\n        returns (bytes1 result)\n\n    {\n\n        if (b.length == 0) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanZeroRequired,\n\n                b.length,\n\n                0\n\n            ));\n\n        }\n\n\n\n        // Store last byte.\n\n        result = b[b.length - 1];\n\n\n\n        assembly {\n\n            // Decrement length of byte array.\n\n            let newLen := sub(mload(b), 1)\n\n            mstore(b, newLen)\n\n        }\n\n        return result;\n",
          "message": "LibBytes.popLastByte uses assembly (LibAddressArray.sol#415-437)\n\t- LibAddressArray.sol#431-435\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 442,
          "vulnerability_to_line": 464,
          "vulnerability_code": "    function popLast20Bytes(bytes memory b)\n\n        internal\n\n        pure\n\n        returns (address result)\n\n    {\n\n        if (b.length < 20) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsTwentyRequired,\n\n                b.length,\n\n                20 // 20 is length of address\n\n            ));\n\n        }\n\n\n\n        // Store last 20 bytes.\n\n        result = readAddress(b, b.length - 20);\n\n\n\n        assembly {\n\n            // Subtract 20 from byte array length.\n\n            let newLen := sub(mload(b), 20)\n\n            mstore(b, newLen)\n\n        }\n\n        return result;\n",
          "message": "LibBytes.popLast20Bytes uses assembly (LibAddressArray.sol#442-464)\n\t- LibAddressArray.sol#458-462\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 488,
          "vulnerability_to_line": 517,
          "vulnerability_code": "    function readAddress(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (address result)\n\n    {\n\n        if (b.length < index + 20) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsTwentyRequired,\n\n                b.length,\n\n                index + 20 // 20 is length of address\n\n            ));\n\n        }\n\n\n\n        // Add offset to index:\n\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\n\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\n\n        index += 20;\n\n\n\n        // Read address from array memory\n\n        assembly {\n\n            // 1. Add index to address of bytes array\n\n            // 2. Load 32-byte word from memory\n\n            // 3. Apply 20-byte mask to obtain address\n\n            result := and(mload(add(b, index)), 0xffffffffffffffffffffffffffffffffffffffff)\n\n        }\n\n        return result;\n",
          "message": "LibBytes.readAddress uses assembly (LibAddressArray.sol#488-517)\n\t- LibAddressArray.sol#510-515\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 523,
          "vulnerability_to_line": 566,
          "vulnerability_code": "    function writeAddress(\n\n        bytes memory b,\n\n        uint256 index,\n\n        address input\n\n    )\n\n        internal\n\n        pure\n\n    {\n\n        if (b.length < index + 20) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsTwentyRequired,\n\n                b.length,\n\n                index + 20 // 20 is length of address\n\n            ));\n\n        }\n\n\n\n        // Add offset to index:\n\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\n\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\n\n        index += 20;\n\n\n\n        // Store address into array memory\n\n        assembly {\n\n            // The address occupies 20 bytes and mstore stores 32 bytes.\n\n            // First fetch the 32-byte word where we'll be storing the address, then\n\n            // apply a mask so we have only the bytes in the word that the address will not occupy.\n\n            // Then combine these bytes with the address and store the 32 bytes back to memory with mstore.\n\n\n\n            // 1. Add index to address of bytes array\n\n            // 2. Load 32-byte word from memory\n\n            // 3. Apply 12-byte mask to obtain extra bytes occupying word of memory where we'll store the address\n\n            let neighbors := and(\n\n                mload(add(b, index)),\n\n                0xffffffffffffffffffffffff0000000000000000000000000000000000000000\n\n            )\n\n\n\n            // Make sure input address is clean.\n\n            // (Solidity does not guarantee this)\n\n            input := and(input, 0xffffffffffffffffffffffffffffffffffffffff)\n\n\n\n            // Store the neighbors and address into memory\n\n            mstore(add(b, index), xor(input, neighbors))\n\n        }\n",
          "message": "LibBytes.writeAddress uses assembly (LibAddressArray.sol#523-566)\n\t- LibAddressArray.sol#545-565\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 572,
          "vulnerability_to_line": 596,
          "vulnerability_code": "    function readBytes32(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes32 result)\n\n    {\n\n        if (b.length < index + 32) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsThirtyTwoRequired,\n\n                b.length,\n\n                index + 32\n\n            ));\n\n        }\n\n\n\n        // Arrays are prefixed by a 256 bit length parameter\n\n        index += 32;\n\n\n\n        // Read the bytes32 from array memory\n\n        assembly {\n\n            result := mload(add(b, index))\n\n        }\n\n        return result;\n",
          "message": "LibBytes.readBytes32 uses assembly (LibAddressArray.sol#572-596)\n\t- LibAddressArray.sol#592-594\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 602,
          "vulnerability_to_line": 625,
          "vulnerability_code": "    function writeBytes32(\n\n        bytes memory b,\n\n        uint256 index,\n\n        bytes32 input\n\n    )\n\n        internal\n\n        pure\n\n    {\n\n        if (b.length < index + 32) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsThirtyTwoRequired,\n\n                b.length,\n\n                index + 32\n\n            ));\n\n        }\n\n\n\n        // Arrays are prefixed by a 256 bit length parameter\n\n        index += 32;\n\n\n\n        // Read the bytes32 from array memory\n\n        assembly {\n\n            mstore(add(b, index), input)\n\n        }\n",
          "message": "LibBytes.writeBytes32 uses assembly (LibAddressArray.sol#602-625)\n\t- LibAddressArray.sol#622-624\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 662,
          "vulnerability_to_line": 689,
          "vulnerability_code": "    function readBytes4(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes4 result)\n\n    {\n\n        if (b.length < index + 4) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsFourRequired,\n\n                b.length,\n\n                index + 4\n\n            ));\n\n        }\n\n\n\n        // Arrays are prefixed by a 32 byte length field\n\n        index += 32;\n\n\n\n        // Read the bytes4 from array memory\n\n        assembly {\n\n            result := mload(add(b, index))\n\n            // Solidity does not require us to clean the trailing bytes.\n\n            // We do it anyway\n\n            result := and(result, 0xFFFFFFFF00000000000000000000000000000000000000000000000000000000)\n\n        }\n\n        return result;\n",
          "message": "LibBytes.readBytes4 uses assembly (LibAddressArray.sol#662-689)\n\t- LibAddressArray.sol#682-687\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 697,
          "vulnerability_to_line": 725,
          "vulnerability_code": "    function readBytesWithLength(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory result)\n\n    {\n\n        // Read length of nested bytes\n\n        uint256 nestedBytesLength = readUint256(b, index);\n\n        index += 32;\n\n\n\n        // Assert length of <b> is valid, given\n\n        // length of nested bytes\n\n        if (b.length < index + nestedBytesLength) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors\n\n                    .InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsNestedBytesLengthRequired,\n\n                b.length,\n\n                index + nestedBytesLength\n\n            ));\n\n        }\n\n\n\n        // Return a pointer to the byte array as it exists inside `b`\n\n        assembly {\n\n            result := add(b, index)\n\n        }\n\n        return result;\n",
          "message": "LibBytes.readBytesWithLength uses assembly (LibAddressArray.sol#697-725)\n\t- LibAddressArray.sol#721-723\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 790,
          "vulnerability_to_line": 797,
          "vulnerability_code": "    function writeLength(bytes memory b, uint256 length)\n\n        internal\n\n        pure\n\n    {\n\n        assembly {\n\n            mstore(b, length)\n\n        }\n",
          "message": "LibBytes.writeLength uses assembly (LibAddressArray.sol#790-797)\n\t- LibAddressArray.sol#794-796\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 833,
          "vulnerability_to_line": 887,
          "vulnerability_code": "    function append(address[] memory addressArray, address addressToAppend)\n\n        internal\n\n        pure\n\n        returns (address[] memory)\n\n    {\n\n        // Get stats on address array and free memory\n\n        uint256 freeMemPtr = 0;\n\n        uint256 addressArrayBeginPtr = 0;\n\n        uint256 addressArrayEndPtr = 0;\n\n        uint256 addressArrayLength = addressArray.length;\n\n        uint256 addressArrayMemSizeInBytes = 32 + (32 * addressArrayLength);\n\n        assembly {\n\n            freeMemPtr := mload(0x40)\n\n            addressArrayBeginPtr := addressArray\n\n            addressArrayEndPtr := add(addressArray, addressArrayMemSizeInBytes)\n\n        }\n\n\n\n        // Cases for `freeMemPtr`:\n\n        //  `freeMemPtr` == `addressArrayEndPtr`: Nothing occupies memory after `addressArray`\n\n        //  `freeMemPtr` > `addressArrayEndPtr`: Some value occupies memory after `addressArray`\n\n        //  `freeMemPtr` < `addressArrayEndPtr`: Memory has not been managed properly.\n\n        if (freeMemPtr < addressArrayEndPtr) {\n\n            LibRichErrors.rrevert(LibAddressArrayRichErrors.MismanagedMemoryError(\n\n                freeMemPtr,\n\n                addressArrayEndPtr\n\n            ));\n\n        }\n\n\n\n        // If free memory begins at the end of `addressArray`\n\n        // then we can append `addressToAppend` directly.\n\n        // Otherwise, we must copy the array to free memory\n\n        // before appending new values to it.\n\n        if (freeMemPtr > addressArrayEndPtr) {\n\n            LibBytes.memCopy(freeMemPtr, addressArrayBeginPtr, addressArrayMemSizeInBytes);\n\n            assembly {\n\n                addressArray := freeMemPtr\n\n                addressArrayBeginPtr := addressArray\n\n            }\n\n        }\n\n\n\n        // Append `addressToAppend`\n\n        addressArrayLength += 1;\n\n        addressArrayMemSizeInBytes += 32;\n\n        addressArrayEndPtr = addressArrayBeginPtr + addressArrayMemSizeInBytes;\n\n        freeMemPtr = addressArrayEndPtr;\n\n        assembly {\n\n            // Store new array length\n\n            mstore(addressArray, addressArrayLength)\n\n\n\n            // Update `freeMemPtr`\n\n            mstore(0x40, freeMemPtr)\n\n        }\n\n        addressArray[addressArrayLength - 1] = addressToAppend;\n\n        return addressArray;\n",
          "message": "LibAddressArray.append uses assembly (LibAddressArray.sol#833-887)\n\t- LibAddressArray.sol#844-848\n\t- LibAddressArray.sol#867-870\n\t- LibAddressArray.sol#878-884\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 893,
          "vulnerability_to_line": 923,
          "vulnerability_code": "    function contains(address[] memory addressArray, address target)\n\n        internal\n\n        pure\n\n        returns (bool success)\n\n    {\n\n        assembly {\n\n\n\n            // Calculate byte length of array\n\n            let arrayByteLen := mul(mload(addressArray), 32)\n\n            // Calculate beginning of array contents\n\n            let arrayContentsStart := add(addressArray, 32)\n\n            // Calclulate end of array contents\n\n            let arrayContentsEnd := add(arrayContentsStart, arrayByteLen)\n\n\n\n            // Loop through array\n\n            for {let i:= arrayContentsStart} lt(i, arrayContentsEnd) {i := add(i, 32)} {\n\n\n\n                // Load array element\n\n                let arrayElement := mload(i)\n\n\n\n                // Return true if array element equals target\n\n                if eq(target, arrayElement) {\n\n                    // Set success to true\n\n                    success := 1\n\n                    // Break loop\n\n                    i := arrayContentsEnd\n\n                }\n\n            }\n\n        }\n\n        return success;\n",
          "message": "LibAddressArray.contains uses assembly (LibAddressArray.sol#893-923)\n\t- LibAddressArray.sol#898-921\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 929,
          "vulnerability_to_line": 960,
          "vulnerability_code": "    function indexOf(address[] memory addressArray, address target)\n\n        internal\n\n        pure\n\n        returns (bool success, uint256 index)\n\n    {\n\n        assembly {\n\n\n\n            // Calculate byte length of array\n\n            let arrayByteLen := mul(mload(addressArray), 32)\n\n            // Calculate beginning of array contents\n\n            let arrayContentsStart := add(addressArray, 32)\n\n            // Calclulate end of array contents\n\n            let arrayContentsEnd := add(arrayContentsStart, arrayByteLen)\n\n\n\n            // Loop through array\n\n            for {let i:= arrayContentsStart} lt(i, arrayContentsEnd) {i := add(i, 32)} {\n\n\n\n                // Load array element\n\n                let arrayElement := mload(i)\n\n\n\n                // Return true if array element equals target\n\n                if eq(target, arrayElement) {\n\n                    // Set success and index\n\n                    success := 1\n\n                    index := div(sub(i, arrayContentsStart), 32)\n\n                    // Break loop\n\n                    i := arrayContentsEnd\n\n                }\n\n            }\n\n        }\n\n        return (success, index);\n",
          "message": "LibAddressArray.indexOf uses assembly (LibAddressArray.sol#929-960)\n\t- LibAddressArray.sol#934-958\n"
        },
        {
          "name": "solc-version",
          "vulnerability_from_line": 21,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.9;\n",
          "message": "Detected issues with version pragma in LibAddressArray.sol:\n\t- pragma solidity^0.5.9 (LibAddressArray.sol#21): it allows old versions\n\t- pragma solidity^0.5.9 (LibAddressArray.sol#67): it allows old versions\n\t- pragma solidity^0.5.9 (LibAddressArray.sol#126): it allows old versions\n\t- pragma solidity^0.5.9 (LibAddressArray.sol#187): it allows old versions\n\t- pragma solidity^0.5.9 (LibAddressArray.sol#820): it allows old versions\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 31,
          "vulnerability_to_line": 44,
          "vulnerability_code": "    function MismanagedMemoryError(\n\n        uint256 freeMemPtr,\n\n        uint256 addressArrayEndPtr\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            MISMANAGED_MEMORY_ERROR_SELECTOR,\n\n            freeMemPtr,\n\n            addressArrayEndPtr\n\n        );\n",
          "message": "Function 'LibAddressArrayRichErrors.MismanagedMemoryError' (LibAddressArray.sol#31-44) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 88,
          "vulnerability_to_line": 103,
          "vulnerability_code": "    function InvalidByteOperationError(\n\n        InvalidByteOperationErrorCodes errorCode,\n\n        uint256 offset,\n\n        uint256 required\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            INVALID_BYTE_OPERATION_ERROR_SELECTOR,\n\n            errorCode,\n\n            offset,\n\n            required\n\n        );\n",
          "message": "Function 'LibBytesRichErrors.InvalidByteOperationError' (LibAddressArray.sol#88-103) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 141,
          "vulnerability_to_line": 152,
          "vulnerability_code": "    function StandardError(\n\n        string memory message\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            STANDARD_ERROR_SELECTOR,\n\n            bytes(message)\n\n        );\n",
          "message": "Function 'LibRichErrors.StandardError' (LibAddressArray.sol#141-152) is not in mixedCase\n"
        }
      ]
    },
    "smartcheck": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 28,
          "vulnerability_to_line": null,
          "vulnerability_code": "        0x5fc83722;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 85,
          "vulnerability_to_line": null,
          "vulnerability_code": "        0x28006595;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 133,
          "vulnerability_to_line": null,
          "vulnerability_code": "        0x08c379a0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 21,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.9;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 67,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.9;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 126,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.9;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 187,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.9;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 820,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.9;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 157,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function rrevert(bytes memory errorData)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 199,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function rawAddress(bytes memory input)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 213,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function contentAddress(bytes memory input)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 228,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function memCopy(\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 378,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function sliceDestructive(\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 415,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function popLastByte(bytes memory b)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 442,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function popLast20Bytes(bytes memory b)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 488,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function readAddress(\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 523,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function writeAddress(\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 572,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function readBytes32(\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 602,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function writeBytes32(\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 662,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function readBytes4(\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 697,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function readBytesWithLength(\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 790,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function writeLength(bytes memory b, uint256 length)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 833,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function append(address[] memory addressArray, address addressToAppend)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 893,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function contains(address[] memory addressArray, address target)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 929,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function indexOf(address[] memory addressArray, address target)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 932,
          "vulnerability_to_line": null,
          "vulnerability_code": "        returns (bool success, uint256 index)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 161,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 204,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 218,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 240,
          "vulnerability_to_line": null,
          "vulnerability_code": "            assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 268,
          "vulnerability_to_line": null,
          "vulnerability_code": "                assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 297,
          "vulnerability_to_line": null,
          "vulnerability_code": "                assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 405,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 431,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 458,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 510,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 545,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 592,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 622,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 682,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 721,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 794,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 844,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 867,
          "vulnerability_to_line": null,
          "vulnerability_code": "            assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 878,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 898,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 934,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        }
      ]
    },
    "oyente": {
      "successfull_analysis": false,
      "errors": [
        "exception (IndexError: pop from empty list)"
      ],
      "vulnerability_findings": []
    },
    "mythril": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": []
    },
    "osiris": {
      "successfull_analysis": false,
      "errors": [
        "Solidity compilation failed"
      ],
      "vulnerability_findings": []
    }
  }
}