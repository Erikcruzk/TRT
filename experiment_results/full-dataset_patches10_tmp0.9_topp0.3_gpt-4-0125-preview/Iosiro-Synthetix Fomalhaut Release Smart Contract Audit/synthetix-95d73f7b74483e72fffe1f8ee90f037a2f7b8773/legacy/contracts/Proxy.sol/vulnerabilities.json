{
  "smartbugs_completed": true,
  "analyzer_results": {
    "semgrep": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 10,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor(address _owner) public {\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 11,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_owner != address(0), \"Owner address cannot be 0\");\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 12,
          "vulnerability_to_line": null,
          "vulnerability_code": "        owner = _owner;\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 13,
          "vulnerability_to_line": null,
          "vulnerability_code": "        emit OwnerChanged(address(0), _owner);\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 14,
          "vulnerability_to_line": null,
          "vulnerability_code": "    }\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 52,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor(address _proxy, address _owner) public Owned(_owner) {\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 53,
          "vulnerability_to_line": null,
          "vulnerability_code": "        proxy = Proxy(_proxy);\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 54,
          "vulnerability_to_line": null,
          "vulnerability_code": "        emit ProxyUpdated(_proxy);\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 55,
          "vulnerability_to_line": null,
          "vulnerability_code": "    }\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 98,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor(address _owner) public Owned(_owner) {}\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 11,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_owner != address(0), \"Owner address cannot be 0\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 22,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == nominatedOwner, \"You must be nominated before you can accept ownership\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 29,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == owner, \"Only the contract owner may perform this action\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 71,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(Proxy(msg.sender) == proxy || Proxy(msg.sender) == integrationProxy, \"Only the proxy can call\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 86,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(messageSender == owner, \"Owner only function\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 183,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(Proxyable(msg.sender) == target, \"Must be proxy target\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 76,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (Proxy(msg.sender) != proxy && Proxy(msg.sender) != integrationProxy) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 77,
          "vulnerability_to_line": null,
          "vulnerability_code": "            messageSender = msg.sender;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 78,
          "vulnerability_to_line": null,
          "vulnerability_code": "        }\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 83,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (Proxy(msg.sender) != proxy && Proxy(msg.sender) != integrationProxy) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 84,
          "vulnerability_to_line": null,
          "vulnerability_code": "            messageSender = msg.sender;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 85,
          "vulnerability_to_line": null,
          "vulnerability_code": "        }\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 22,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == nominatedOwner, \"You must be nominated before you can accept ownership\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 29,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == owner, \"Only the contract owner may perform this action\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        }
      ]
    },
    "slither": {
      "successfull_analysis": true,
      "errors": [
        "EXIT_CODE_11"
      ],
      "vulnerability_findings": [
        {
          "name": "locked-ether",
          "vulnerability_from_line": 145,
          "vulnerability_to_line": 180,
          "vulnerability_code": "    function() external payable {\n\n        if (useDELEGATECALL) {\n\n            assembly {\n\n                /* Copy call data into free memory region. */\n\n                let free_ptr := mload(0x40)\n\n                calldatacopy(free_ptr, 0, calldatasize)\n\n\n\n                /* Forward all gas and call data to the target contract. */\n\n                let result := delegatecall(gas, sload(target_slot), free_ptr, calldatasize, 0, 0)\n\n                returndatacopy(free_ptr, 0, returndatasize)\n\n\n\n                /* Revert if the call failed, otherwise return the result. */\n\n                if iszero(result) {\n\n                    revert(free_ptr, returndatasize)\n\n                }\n\n                return(free_ptr, returndatasize)\n\n            }\n\n        } else {\n\n            /* Here we are as above, but must send the messageSender explicitly\n\n             * since we are using CALL rather than DELEGATECALL. */\n\n            target.setMessageSender(msg.sender);\n\n            assembly {\n\n                let free_ptr := mload(0x40)\n\n                calldatacopy(free_ptr, 0, calldatasize)\n\n\n\n                /* We must explicitly forward ether to the underlying contract as well. */\n\n                let result := call(gas, sload(target_slot), callvalue, free_ptr, calldatasize, 0, 0)\n\n                returndatacopy(free_ptr, 0, returndatasize)\n\n\n\n                if iszero(result) {\n\n                    revert(free_ptr, returndatasize)\n\n                }\n\n                return(free_ptr, returndatasize)\n\n            }\n\n        }\n",
          "message": "Contract locking ether found in Proxy.sol:\n\tContract Proxy has payable functions:\n\t - fallback (Proxy.sol#145-180)\n\tBut does not have a function to withdraw the ether\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 109,
          "vulnerability_to_line": 143,
          "vulnerability_code": "    function _emit(\n\n        bytes callData,\n\n        uint numTopics,\n\n        bytes32 topic1,\n\n        bytes32 topic2,\n\n        bytes32 topic3,\n\n        bytes32 topic4\n\n    ) external onlyTarget {\n\n        uint size = callData.length;\n\n        bytes memory _callData = callData;\n\n\n\n        assembly {\n\n            /* The first 32 bytes of callData contain its length (as specified by the abi).\n\n             * Length is assumed to be a uint256 and therefore maximum of 32 bytes\n\n             * in length. It is also leftpadded to be a multiple of 32 bytes.\n\n             * This means moving call_data across 32 bytes guarantees we correctly access\n\n             * the data itself. */\n\n            switch numTopics\n\n                case 0 {\n\n                    log0(add(_callData, 32), size)\n\n                }\n\n                case 1 {\n\n                    log1(add(_callData, 32), size, topic1)\n\n                }\n\n                case 2 {\n\n                    log2(add(_callData, 32), size, topic1, topic2)\n\n                }\n\n                case 3 {\n\n                    log3(add(_callData, 32), size, topic1, topic2, topic3)\n\n                }\n\n                case 4 {\n\n                    log4(add(_callData, 32), size, topic1, topic2, topic3, topic4)\n\n                }\n\n        }\n",
          "message": "Proxy._emit uses assembly (Proxy.sol#109-143)\n\t- Proxy.sol#120-143\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 145,
          "vulnerability_to_line": 180,
          "vulnerability_code": "    function() external payable {\n\n        if (useDELEGATECALL) {\n\n            assembly {\n\n                /* Copy call data into free memory region. */\n\n                let free_ptr := mload(0x40)\n\n                calldatacopy(free_ptr, 0, calldatasize)\n\n\n\n                /* Forward all gas and call data to the target contract. */\n\n                let result := delegatecall(gas, sload(target_slot), free_ptr, calldatasize, 0, 0)\n\n                returndatacopy(free_ptr, 0, returndatasize)\n\n\n\n                /* Revert if the call failed, otherwise return the result. */\n\n                if iszero(result) {\n\n                    revert(free_ptr, returndatasize)\n\n                }\n\n                return(free_ptr, returndatasize)\n\n            }\n\n        } else {\n\n            /* Here we are as above, but must send the messageSender explicitly\n\n             * since we are using CALL rather than DELEGATECALL. */\n\n            target.setMessageSender(msg.sender);\n\n            assembly {\n\n                let free_ptr := mload(0x40)\n\n                calldatacopy(free_ptr, 0, calldatasize)\n\n\n\n                /* We must explicitly forward ether to the underlying contract as well. */\n\n                let result := call(gas, sload(target_slot), callvalue, free_ptr, calldatasize, 0, 0)\n\n                returndatacopy(free_ptr, 0, returndatasize)\n\n\n\n                if iszero(result) {\n\n                    revert(free_ptr, returndatasize)\n\n                }\n\n                return(free_ptr, returndatasize)\n\n            }\n\n        }\n",
          "message": "Proxy.fallback uses assembly (Proxy.sol#145-180)\n\t- Proxy.sol#147-162\n\t- Proxy.sol#166-179\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 10,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor(address _owner) public {\n",
          "message": "Parameter '_owner' of Owned. (Proxy.sol#10) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 16,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function nominateNewOwner(address _owner) external onlyOwner {\n",
          "message": "Parameter '_owner' of Owned.nominateNewOwner (Proxy.sol#16) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 52,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor(address _proxy, address _owner) public Owned(_owner) {\n",
          "message": "Parameter '_proxy' of Proxyable. (Proxy.sol#52) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 57,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setProxy(address _proxy) external onlyOwner {\n",
          "message": "Parameter '_proxy' of Proxyable.setProxy (Proxy.sol#57) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 62,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setIntegrationProxy(address _integrationProxy) external onlyOwner {\n",
          "message": "Parameter '_integrationProxy' of Proxyable.setIntegrationProxy (Proxy.sol#62) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 82,
          "vulnerability_to_line": 88,
          "vulnerability_code": "    modifier optionalProxy_onlyOwner {\n\n        if (Proxy(msg.sender) != proxy && Proxy(msg.sender) != integrationProxy) {\n\n            messageSender = msg.sender;\n\n        }\n\n        require(messageSender == owner, \"Owner only function\");\n\n        _;\n",
          "message": "Modifier 'Proxyable.optionalProxy_onlyOwner' (Proxy.sol#82-88) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 100,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setTarget(Proxyable _target) external onlyOwner {\n",
          "message": "Parameter '_target' of Proxy.setTarget (Proxy.sol#100) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 109,
          "vulnerability_to_line": 143,
          "vulnerability_code": "    function _emit(\n\n        bytes callData,\n\n        uint numTopics,\n\n        bytes32 topic1,\n\n        bytes32 topic2,\n\n        bytes32 topic3,\n\n        bytes32 topic4\n\n    ) external onlyTarget {\n\n        uint size = callData.length;\n\n        bytes memory _callData = callData;\n\n\n\n        assembly {\n\n            /* The first 32 bytes of callData contain its length (as specified by the abi).\n\n             * Length is assumed to be a uint256 and therefore maximum of 32 bytes\n\n             * in length. It is also leftpadded to be a multiple of 32 bytes.\n\n             * This means moving call_data across 32 bytes guarantees we correctly access\n\n             * the data itself. */\n\n            switch numTopics\n\n                case 0 {\n\n                    log0(add(_callData, 32), size)\n\n                }\n\n                case 1 {\n\n                    log1(add(_callData, 32), size, topic1)\n\n                }\n\n                case 2 {\n\n                    log2(add(_callData, 32), size, topic1, topic2)\n\n                }\n\n                case 3 {\n\n                    log3(add(_callData, 32), size, topic1, topic2, topic3)\n\n                }\n\n                case 4 {\n\n                    log4(add(_callData, 32), size, topic1, topic2, topic3, topic4)\n\n                }\n\n        }\n",
          "message": "Function 'Proxy._emit' (Proxy.sol#109-143) is not in mixedCase\n"
        }
      ]
    },
    "smartcheck": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 25,
          "vulnerability_to_line": null,
          "vulnerability_code": "        nominatedOwner = address(0);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_LOCKED_MONEY",
          "vulnerability_from_line": 94,
          "vulnerability_to_line": null,
          "vulnerability_code": "contract Proxy is Owned {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_OVERPOWERED_ROLE",
          "vulnerability_from_line": 57,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setProxy(address _proxy) external onlyOwner {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_OVERPOWERED_ROLE",
          "vulnerability_from_line": 62,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setIntegrationProxy(address _integrationProxy) external onlyOwner {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_OVERPOWERED_ROLE",
          "vulnerability_from_line": 100,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setTarget(Proxyable _target) external onlyOwner {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_OVERPOWERED_ROLE",
          "vulnerability_from_line": 105,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setUseDELEGATECALL(bool value) external onlyOwner {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 120,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 147,
          "vulnerability_to_line": null,
          "vulnerability_code": "            assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 166,
          "vulnerability_to_line": null,
          "vulnerability_code": "            assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 50,
          "vulnerability_to_line": null,
          "vulnerability_code": "    address messageSender;\n",
          "message": null
        }
      ]
    },
    "oyente": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "Integer Overflow",
          "vulnerability_from_line": 118,
          "vulnerability_to_line": null,
          "vulnerability_code": "        bytes memory _callData = callData;\n",
          "message": null
        }
      ]
    },
    "mythril": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "External Call To User-Supplied Address (SWC 107)",
          "vulnerability_from_line": 165,
          "vulnerability_to_line": null,
          "vulnerability_code": "            target.setMessageSender(msg.sender);\n",
          "message": "A call to a user-supplied address is executed.\nAn external message call to an address specified by the caller is executed. Note that the callee account might contain arbitrary code and could re-enter any function within this contract. Reentering the contract in an intermediate state may lead to unexpected behaviour. Make sure that no state modifications are executed after this call and/or reentrancy guards are in place.\nClassification: SWC-107"
        },
        {
          "name": "State access after external call (SWC 107)",
          "vulnerability_from_line": 171,
          "vulnerability_to_line": null,
          "vulnerability_code": "                let result := call(gas, sload(target_slot), callvalue, free_ptr, calldatasize, 0, 0)\n",
          "message": "Read of persistent state following external call\nThe contract account state is accessed after an external call to a user defined address. To prevent reentrancy issues, consider accessing the state only before the call, especially if the callee is untrusted. Alternatively, a reentrancy lock can be used to prevent untrusted callees from re-entering the contract in an intermediate state.\nClassification: SWC-107"
        },
        {
          "name": "External Call To User-Supplied Address (SWC 107)",
          "vulnerability_from_line": 171,
          "vulnerability_to_line": null,
          "vulnerability_code": "                let result := call(gas, sload(target_slot), callvalue, free_ptr, calldatasize, 0, 0)\n",
          "message": "A call to a user-supplied address is executed.\nAn external message call to an address specified by the caller is executed. Note that the callee account might contain arbitrary code and could re-enter any function within this contract. Reentering the contract in an intermediate state may lead to unexpected behaviour. Make sure that no state modifications are executed after this call and/or reentrancy guards are in place.\nClassification: SWC-107"
        },
        {
          "name": "Multiple Calls in a Single Transaction (SWC 113)",
          "vulnerability_from_line": 171,
          "vulnerability_to_line": null,
          "vulnerability_code": "                let result := call(gas, sload(target_slot), callvalue, free_ptr, calldatasize, 0, 0)\n",
          "message": "Multiple calls are executed in the same transaction.\nThis call is executed following another call within the same transaction. It is possible that the call never gets executed if a prior call fails permanently. This might be caused intentionally by a malicious callee. If possible, refactor the code such that each transaction only executes one external call or make sure that all callees can be trusted (i.e. they\u2019re part of your own codebase).\nClassification: SWC-113"
        },
        {
          "name": "State access after external call (SWC 107)",
          "vulnerability_from_line": 171,
          "vulnerability_to_line": null,
          "vulnerability_code": "                let result := call(gas, sload(target_slot), callvalue, free_ptr, calldatasize, 0, 0)\n",
          "message": "Write to persistent state following external call\nThe contract account state is accessed after an external call to a user defined address. To prevent reentrancy issues, consider accessing the state only before the call, especially if the callee is untrusted. Alternatively, a reentrancy lock can be used to prevent untrusted callees from re-entering the contract in an intermediate state.\nClassification: SWC-107"
        }
      ]
    },
    "osiris": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "Reentrancy bug",
          "vulnerability_from_line": 171,
          "vulnerability_to_line": null,
          "vulnerability_code": "                let result := call(gas, sload(target_slot), callvalue, free_ptr, calldatasize, 0, 0)\n",
          "message": null
        }
      ]
    }
  }
}