function safeApprove(
    IERC20 token,
    address spender,
    uint256 value
) internal {
    // This is a mitigation for the issue described here:
    // https://github.com/ethereum/solidity/issues/4116
    // This ensures that the token allowance is set to 0 before setting it to a new value
    // for the approve() call

    // First, set the allowance to 0
    _callOptionalReturn(
        token,
        abi.encodeWithSelector(token.approve.selector, spender, 0)
    );
    // Next, set the allowance to the new value
    _callOptionalReturn(
        token,
        abi.encodeWithSelector(token.approve.selector, spender, value)
    );
}